"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","1227","Add type bounds to `TestTemplateInvocationContextProvider.provideTest…","…TemplateInvocationContexts`  issue https://github.com/junit-team/junit5/issues/1226  Signed-off-by: Mike Kobit   ## Overview  see issue https://github.com/junit-team/junit5/issues/1226  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","mkobit","2018-01-04T17:43:59Z","2018-01-13T19:27:55Z"
"","1616","closeAttemptExceptionWillBeThrownDownTheCallStack test is added","…ing AutoClosable ExtensionContext(that's all classes that extends  AbstractExtensionContext), this exception will be thrown further up the call stack.  ## Overview  Hi everyone. Just started to investigate the JUnit5 source code and decided to contribute a bit to this awesome project by covering with tests some uncovered code lines.   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","terziele","2018-10-03T17:51:02Z","2018-10-20T14:56:17Z"
"","1350","issue/1338: implemented prototype of early dynamic test discovery in …","…execution phase  ## Overview  When starting execution phase for dynamic tests all dynamic tests are discovered and dynamically registered as first action.  TODO: For now when there are more tests than just one @testFactoy method, tests are discovered when execution for this @testfactory method starts  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mibutec","2018-03-31T05:21:44Z","2018-04-02T15:45:27Z"
"","1538","Autocompletion script for ConsoleLauncher","Would there be interest in a bash/zsh completion script that would allow users to TAB-complete options and option parameters when invoking the `ConsoleLauncher`?  Currently the launcher is started with   ``` java -jar junit-platform-console-standalone-1.2.0.jar  ```  By using the Gradle `application` plugin, it is straightforward to generate a distribution that includes a script for running the application.   This script would become the main way to invoke the console launcher. For example:  ``` consolelauncher.sh  ```  Once we have a starter script, picocli can easily generate a [completion script](https://picocli.info/autocomplete.html) that suggests possible completion candidates for anything following `consolelauncher.sh` on the command line.  Let me know if there’s interest in doing this.","closed","status: stale,","remkop","2018-08-12T08:30:30Z","2021-06-19T12:50:05Z"
"","1273","Documentation: Chart of performance between JUnit 4 vs 5","Would be possible add a chart about the comparison about performance between JUnit 4 vs 5?","closed","status: stale,","manueljordan","2018-01-31T14:38:52Z","2021-09-20T20:43:42Z"
"","1921","Extension lifecycle diagram source","Word document used as a source to generate extensions lifecycle diagram.  Issue #1454   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","pietrygamat","2019-06-06T16:06:09Z","2019-06-20T07:58:05Z"
"","1453","Unexpected execution order of JUnit 4 and 5 test methods","With the following test class I wanted to show, that JUnit 4 and 5 tests can be run in parallel using the JUnit platform runner.  ```java @RunWith(JUnitPlatform.class) public class SomeTest {    @BeforeClass   public static void beforeClassTest() {     System.out.println(""*** beforeClassTest ***"");   }    @org.junit.Test   public void jUnit4test() {     System.out.println(""*** jUnit4test***"");   }    @org.junit.jupiter.api.Test   public void jUnit5test() {     System.out.println(""*** jUnit5test***"");   }  } ```  Running this test class in Eclipse, I get the following output:  ``` *** jUnit5test*** *** beforeClassTest *** *** jUnit4test*** ```  I expected the method annotated with @BeforeClass to be executed at first, but this wasn't the case. Is this a bug or intentional?  This are the dependencies resolved in my project: ``` junit: 4.12 junit-platform-runner: 1.1.0 ```","closed","component: Vintage,","IrisPallida","2018-06-06T13:18:17Z","2018-06-07T05:58:08Z"
"","1166","Gradle plugin should not show stdout by default","With the built-in gradle junit 4 support, stdout from tests is not output to the screen by default. Stdout is only output to screen when info logging is enable for gradle (`-i` or `--info`).   With the `junit-platform-gradle-plugin`, all stdout from executing tests is output to the screen by default. I don't think this is the correct behavior. `junit-platform-gradle-plugin` should follow the standard gradle convention.","closed","3rd-party: Gradle,","shollander","2017-11-16T17:11:43Z","2018-03-16T14:21:01Z"
"","1634","add global resource lock","Why: Some libraries provide test modules which work by modifying private global variables inside the library (i.e. Project Reactor virtual time step verifier). When such library is used as a basis for the whole app, nearly all test are affected by this manipulation. Parallel test execution becomes inpracticable, because all methods would need to be annotated with a READ ResourceLock and the few test methods which modify the global state one of type READ_WRITE.  ## Overview  The changes are only a quick&dirty implementation to get the discussion started.   I would really like to implement the feature, if you can give me some guidance about integrating it ""correctly"" into the framework.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","Danny02","2018-10-13T15:43:49Z","2019-05-01T13:35:55Z"
"","1722","Provide mechanism to reuse JUnit Jupiter extensions in other test engines","While writing an own `TestEngine` we found it quite handy to reuse JUnit Jupiter's extension mechanism along with `ExecutionCondition` to conditionally run/skip classes and methods (see mp911de/microbenchmark-runner#19 for further details).   However, some implementations (such as `DisabledCondition`) are not visible or internal API (e.g. `ExtensionRegistry`). As an implementer, there are two ways to implement extension support:  * Using internal API * Reimplementing  Neither is great, so it would be better to be able to reuse the existing bits of JUnit Jupiter's engine implementation.  ## Deliverables  - [ ] Stable implementation of `ExtensionRegistry` - [ ] Stable implementation of support classes (such as `AbstractExtensionContext` and `ExtensionUtils`)","open","component: Jupiter,","mp911de","2019-01-08T13:17:59Z","2022-06-22T17:11:56Z"
"","1675","Add note about controlling concurrency when using parallel execution to user guide","While working with parallel test execution in JUnit 5.3.1, I came across a mystery that I have not yet solved wherein I can trick JUnit into running more concurrent tests than it is configured to run as a side-effect of sleeping a thread inside of a `CompletableFuture` i.e.  ```java     CompletableFuture.runAsync(               () -> {                 try {                   Thread.sleep(1000);                 } catch (InterruptedException e) {                   Thread.currentThread().interrupt();                 }               })           .join(); ```  When this code is present in a test, JUnit will run an additional concurrent test. For example, if `junit.jupiter.execution.parallel.config.fixed.parallelism=4`, one expects at most 4 tests to run concurrently; however if this `CompletableFuture` code snippet is present in all running tests, I observe at most 8 concurrent tests (assuming the total number of tests is greater than 8).  ## Steps to reproduce  Maven project [gilday/junit-parallelization-issue](https://github.com/gilday/junit-parallelization-issue) contains code to reproduce this issue. It includes a counter class `HighWaterMark` which observes at most 8 concurrent tests running when `junit.jupiter.execution.parallel.config.fixed.parallelism=4`.  ## Context   - Jupiter 5.3.1  - Maven Surefire 2.22.1 - JDK 1.8","closed","theme: documentation,","gilday","2018-11-10T18:50:33Z","2019-04-08T13:30:33Z"
"","1745","Remove apiguardian dependency from published POM of org.junit.jupiter:junit-jupiter","While being pulled in transitively anyway, the POM unnecessarily references apiguardian as a direct dependency because of our build setup.   ## Deliverables  - [x] Remove apiguardian from org.junit.jupiter:junit-jupiter aggregator project","closed","component: Jupiter,","marcphilipp","2019-01-24T18:19:21Z","2019-01-30T15:31:33Z"
"","1673","Navigating to search results broken in snapshots Javadocs","When using the search box in the current [snapshot Javadocs](https://junit.org/junit5/docs/snapshot/api/), clicking on one of the results takes one to an invalid URL.  For example, when typing `TestDescriptor` and clicking on the first link, on ends up at https://junit.org/junit5/docs/snapshot/api/undefined/org/junit/platform/engine/TestDescriptor.html.  Note the `undefined` in the URL. Root cause is probably that we've started using JDK 11 to build the Javadocs and have customized it considerably.","closed","theme: documentation,","marcphilipp","2018-11-09T12:07:44Z","2018-11-09T13:30:58Z"
"","1141","Influence invocation order for TestTemplate executions","When using TestTemplate, JUnit will perform executions grouped by the test method.  For example, if I have a test class that defines 2 test methods (m1, m2) as TestTemplate and provide 2 invocation contexts (c1, c2) - JUnit will perform this in the following order:  ````     * m1:c1     * m1:c2     * m2:c1     * m2:c2 ```` But what I really need is:  ````     * m1:c1     * m2:c1     * m1:c2     * m2:c2 ````  My use case is that the invocation context describes a particular database schema layout.  So c1 and c2 define the same schema, but slightly differently (one adds extra columns to a given table and defoines others).  Given that JUnit wants to group these invocations by method (iterating the context within that) we are forced to recreate that schema before each invocation.  Effectively this becomes:  ````     * create schema1 (c1)      * run m1     * drop schema1     * create schema2 (c2)      * run m2     * drop schema2     * create schema1 (c1)     * run m1     * drop schema1     * create schema2 (c2)      * run m2     * drop schema2 ````  Obviously that works a lot better as:  ````     * create schema1 (c1)      * run m1     * run m2     * drop schema1     * create schema2 (c2)      * run m1     * run m2     * drop schema2 ````","closed","component: Jupiter,","sebersole","2017-11-03T15:47:44Z","2017-11-03T17:42:56Z"
"","1382","Provide Kotlin extension function for ArgumentsAccessor","When using JUnit 5.2.0-RC1 with Kotlin, you have to write e.g.: ``` val date = args.get(2, LocalDate::class.java) ``` It would be smoother when one could write (as e.g. in https://github.com/junit-team/junit5/blob/r5.2.0-RC1/junit-jupiter-api/src/main/kotlin/org/junit/jupiter/api/Assertions.kt#L96): ``` val date = args.get(2) ```","closed","theme: parameterized tests,","juergenzimmermann","2018-04-23T06:56:05Z","2018-05-05T10:48:03Z"
"","1265","Vintage Engine mistakenly executes test methods for non-included/excluded tags","When using a TagFilter to include/exclude a tag that represents a JUnit 4 category, e.g. `com.acme.Foo`, the Vintage Engine correctly returns a filtered tree of `TestDescriptors` after discovery. However, when executing these `TestDescriptors`, Vintage will run all test methods in a class that contains an included test method.  For example, given the following test class  ```java public class ExampleTests {     @Test     @Category(Foo.class)     public void foo() {}      @Test     public void bar() {} }     ```  and an `includeTags(""com.acme.Foo"")` filter, Vintage executes both `foo` and `bar`. Similarly, for an `excludeTags(""com.acme.Foo"")` filter, Vintage runs both methods.  ## Deliverables  - [ ] Ensure `PostDiscoveryFilters` are taken into account when executing a test class","closed","component: Vintage,","marcphilipp","2018-01-25T21:04:43Z","2018-02-02T06:35:43Z"
"","1591","AssertAll#assertAll() is not threadsafe","When using `AssertAll.assertAll()` with parallelStreams the concurrent adding of Throwables to the list of failures might lead to unexpected null-elements in the list of failures resulting in a NullPointerException in the constructor of MultipleFailuresError.  Solution: Use synchronized list.  `        List failures = Collections.synchronizedList(new ArrayList<>()); `","closed","component: Jupiter,","flowerrrr","2018-09-20T09:40:12Z","2018-11-20T12:52:23Z"
"","1303","Change attribute from name to value","When using `@ParameterizedTest`, one have to add the name-attribute to create a speaking text. For example:  ``` @ParameterizedTest(name = ""Wenn enableComments auf {0} steht, sollte isCommentable {1} zurück geben."") ```  When you change this attribute to ""value"", one can simplier write:  ``` @ParameterizedTest(""Wenn enableComments auf {0} steht, sollte isCommentable {1} zurück geben."") ```  This is similar to `@DisplayName`.","closed","status: works-as-designed,","michaelsiepmann","2018-02-23T10:33:58Z","2018-02-23T10:45:29Z"
"","1903","Document URI TestSource support of dynamic tests in User Guide","When URI `TestSource` support for dynamic tests was extended in #1895, we noticed that we don't have any documentation for this feature in the User Guide.  ## Deliverables  - [x] Add a subsection that documents the different supported URI formats with examples","closed","component: Jupiter,","marcphilipp","2019-05-28T18:28:08Z","2019-06-20T09:29:20Z"
"","1792","JMockit teardown no longer works as before","When upgrading from `5.3.2` to `5.4.0`, the JMockit mock leaks into other tests.   Previously, when mocking something in one test, the next test would be completely reset and be influenced by previous mocks.   After upgrading, my tests fail because mocks from other tests are still active.   ## Steps to reproduce  In my example I use JMockit to mock `System.getEnv`.  ```kotlin import mockit.Mock import mockit.MockUp import org.junit.jupiter.api.Test  class JMockitTest {      @Test fun willCreate() {         MockSystem(""key"" to ""1"")         val result = System.getenv(""key"")         assert(result == ""1"")     }      @Test fun shouldTearDown() {         val result = System.getenv(""key"")         assert(result == null)     }  }  class MockSystem(private val envs: Map) : MockUp() {      constructor(vararg envs: Pair) : this(mapOf(*envs))      @Mock fun getenv(name: String) = envs[name] } ```  And here is my build.gradle: ```groovy plugins { id 'org.jetbrains.kotlin.jvm' version '1.3.21' } group 'me.avo' version '1.0-SNAPSHOT' repositories { jcenter() } ext { junit_version = '5.4.0' }  dependencies {     implementation ""org.jetbrains.kotlin:kotlin-stdlib-jdk8""      testCompile ""org.jmockit:jmockit:1.45""     testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: junit_version     testRuntime ""org.junit.jupiter:junit-jupiter-engine:$junit_version"" }  test {     useJUnitPlatform {         includeEngines 'junit-jupiter'     }      doFirst {         def jMockit = configurations.testCompile.find {             it.name.startsWith(""jmockit-"")         }         jvmArgs ""-javaagent:${jMockit}""     } } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): `5.3.2` and `5.4.0`  - Build Tool/IDE: `IntelliJ Ultimate`","closed","component: Jupiter,","AndreasVolkmann","2019-02-23T10:18:07Z","2019-02-24T10:48:39Z"
"","1845","Errors in Spock data-provider preparation should be reported by Vintage Engine","When Spock data-provider preparation fails early, it only calls `RunListener.testFailure` but not `RunListener.testFinished` which causes the Vintage engine to never report the failure. Technically, this violates the `RunListener` interface but due to the established behavior when executing such tests with JUnit 4 in IDEs and build tools, we should provide a handle this case anyway.  ## Steps to reproduce  see https://github.com/spockframework/spock/issues/976   ## Deliverables  - [x] Report tests as finished when failures have been reported even if `testFinished` wasn't called","closed","component: Vintage,","marcphilipp","2019-04-04T15:07:55Z","2019-04-04T15:29:37Z"
"","1125","Classpath is too long 206 error","When running Junit5 on our huge project we are getting our classpath to the size of 35.8k when Windows (unfortunately) supports 32k only. I'm not sure how JUnit4 tests are handled in Gradle but it all works fine.  This is how its done in the plugin and it seems to do what it says but it creates a massive classpath and we are using Windows, sadly.  classpath = project.sourceSets.test.runtimeClasspath + project.configurations.junitPlatform  Is there any way we can work around this issue? it seems to pull the whole world into the classpath with all transitives.  > * Exception is: > org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':server:junitPlatformTest'. >  > Caused by: org.gradle.process.internal.ExecException: A problem occurred starting process 'command 'C:\Program Files\Java\jdk1.8.0_131\bin\java.exe'' > ... > Caused by: java.io.IOException: CreateProcess error=206, The filename or extension is too long  I Have created stack overflow question as well for this. https://stackoverflow.com/questions/46827241/junit5-gradle-plugin-the-filename-or-extension-is-too-long","closed","3rd-party: Gradle,","Enigamitsuj","2017-10-23T09:29:05Z","2019-07-19T19:32:45Z"
"","1524","Inconsistent output from TreePrinter in ConsoleLauncher with parallel test execution","When running all the tests in a few simple test classes with the 1.3.0-M1 ConsoleLauncher standalone jar with the parallel test execution, I am seeing inconsistent output. Sometimes there will be a NullPointerException in the TreePrinter, sometimes it will execute but some of the executed tests will not show up in the tree output (though they are in the final summary), sometimes it will display the ConsoleLauncher help output, and sometimes there is a mix of all of those behaviors. One example is:  ``` (aaron) $ java -jar junit-platform-console-standalone-1.3.0-M1.jar --cp tests.jar -p com.foo --config junit.jupiter.execution.parallel.enabled=true --details tree  java.lang.NullPointerException 	at org.junit.platform.console.tasks.TreePrinter.print(TreePrinter.java:54) 	at org.junit.platform.console.tasks.TreePrinter.print(TreePrinter.java:65) 	at org.junit.platform.console.tasks.TreePrinter.print(TreePrinter.java:65) 	at org.junit.platform.console.tasks.TreePrinter.print(TreePrinter.java:65) 	at org.junit.platform.console.tasks.TreePrinter.print(TreePrinter.java:49) 	at org.junit.platform.console.tasks.TreePrintingListener.testPlanExecutionFinished(TreePrintingListener.java:56) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry$CompositeTestExecutionListener.lambda$testPlanExecutionFinished$7(TestExecutionListenerRegistry.java:102) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry.notifyTestExecutionListeners(TestExecutionListenerRegistry.java:59) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry.access$100(TestExecutionListenerRegistry.java:28) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry$CompositeTestExecutionListener.testPlanExecutionFinished(TestExecutionListenerRegistry.java:102) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:155) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:166) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:145) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:92) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.executeTests(ConsoleTestExecutor.java:65) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.lambda$execute$0(ConsoleTestExecutor.java:57) 	at org.junit.platform.console.tasks.CustomContextClassLoaderExecutor.replaceThreadContextClassLoaderAndInvoke(CustomContextClassLoaderExecutor.java:41) 	at org.junit.platform.console.tasks.CustomContextClassLoaderExecutor.invoke(CustomContextClassLoaderExecutor.java:31) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.execute(ConsoleTestExecutor.java:57) 	at org.junit.platform.console.ConsoleLauncher.executeTests(ConsoleLauncher.java:84) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:74) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:47) 	at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:39)  ╷ ├─ JUnit Jupiter ✔ │  ├─ BarTest ✔ │  │     2018-08-05T09:09:25.959 log = `started class  BarTest` │  │     2018-08-05T09:09:26.980 log = `finished class BarTest` │  │  ├─ testBar1(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBar1(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBar1(TestReporter, TestInfo)` │  │  └─ testBar2(TestReporter, TestInfo) ✔ │  │        2018-08-05T09:09:25.970 log = `started testBar2(TestReporter, TestInfo)` │  │        2018-08-05T09:09:26.972 log = `finished testBar2(TestReporter, TestInfo)` │  ├─ BazTest ✔ │  │     2018-08-05T09:09:25.959 log = `started class  BazTest` │  │     2018-08-05T09:09:28.989 log = `finished class BazTest` │  │  ├─ testBaz03(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBaz03(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBaz03(TestReporter, TestInfo)` │  │  ├─ testBaz02(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBaz02(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBaz02(TestReporter, TestInfo)` │  │  ├─ testBaz01(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBaz01(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBaz01(TestReporter, TestInfo)` │  │  ├─ testBaz20(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBaz20(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBaz20(TestReporter, TestInfo)` │  │  ├─ testBaz19(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.980 log = `started testBaz19(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz19(TestReporter, TestInfo)` │  │  ├─ testBaz08(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.980 log = `started testBaz08(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz08(TestReporter, TestInfo)` │  │  ├─ testBaz07(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.980 log = `started testBaz07(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz07(TestReporter, TestInfo)` │  │  ├─ testBaz05(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.980 log = `started testBaz05(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz05(TestReporter, TestInfo)` │  │  ├─ testBaz04(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.980 log = `started testBaz04(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz04(TestReporter, TestInfo)` │  │  ├─ testBaz06(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.980 log = `started testBaz06(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz06(TestReporter, TestInfo)` │  │  ├─ testBaz10(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.982 log = `started testBaz10(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz10(TestReporter, TestInfo)` │  │  ├─ testBaz09(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:26.982 log = `started testBaz09(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:27.985 log = `finished testBaz09(TestReporter, TestInfo)` │  │  ├─ testBaz12(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:27.987 log = `started testBaz12(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:28.988 log = `finished testBaz12(TestReporter, TestInfo)` │  │  ├─ testBaz17(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:27.987 log = `started testBaz17(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:28.988 log = `finished testBaz17(TestReporter, TestInfo)` │  │  ├─ testBaz13(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:27.987 log = `started testBaz13(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:28.988 log = `finished testBaz13(TestReporter, TestInfo)` Option                                         Description                                 ------                                         -----------                                 -h, --help                                     Display help information.                   --disable-ansi-colors                          Disable ANSI colors in output (not                                                           supported by all terminals).              --details <[none,summary,flat,tree,verbose]    Select an output details mode for when        >                                              tests are executed. Use one of: [none,     ... more following this ```  The test classes are very simple, and here is an example of one of them:  ```java final class BarTest {      @BeforeAll     static void setup(TestReporter reporter, TestInfo testInfo) {         reporter.publishEntry(""log"", ""started class  "" + testInfo.getDisplayName());     }      @AfterAll     static void tearDown(TestReporter reporter, TestInfo testInfo) {         reporter.publishEntry(""log"", ""finished class "" + testInfo.getDisplayName());     }      @Test     void testBar1(TestReporter reporter, TestInfo testInfo) throws Exception {         reporter.publishEntry(""log"", ""started "" + testInfo.getDisplayName());         Thread.sleep(1_000);         reporter.publishEntry(""log"", ""finished "" + testInfo.getDisplayName());     }      @Test     void testBar2(TestReporter reporter, TestInfo testInfo) throws Exception {         reporter.publishEntry(""log"", ""started "" + testInfo.getDisplayName());         Thread.sleep(1_000);         reporter.publishEntry(""log"", ""finished "" + testInfo.getDisplayName());     } } ```","closed","component: Platform,","littleclay","2018-08-05T16:20:08Z","2018-08-09T07:21:44Z"
"","1262","ConsoleLauncher option is not supported","When I use `--details summary` option, the following exception occurred.   But it's mentioned in documentation http://junit.org/junit5/docs/snapshot/user-guide/#running-tests-console-launcher-options.   ``` Exception in thread ""main"" org.junit.platform.commons.JUnitException: Error parsing command-line arguments         at org.junit.platform.console.options.JOptSimpleCommandLineOptionsParser.parse(JOptSimpleCommandLineOptionsParser.java:44)         at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:68)         at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:47)         at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:39) Caused by: org.junit.platform.console.shadow.joptsimple.OptionArgumentConversionException: Cannot parse argument 'summary' of option details         at org.junit.platform.console.shadow.joptsimple.AbstractOptionSpec.convertWith(AbstractOptionSpec.java:92)         at org.junit.platform.console.shadow.joptsimple.ArgumentAcceptingOptionSpec.convert(ArgumentAcceptingOptionSpec.java:277)         at org.junit.platform.console.shadow.joptsimple.OptionSet.valuesOf(OptionSet.java:223)         at org.junit.platform.console.shadow.joptsimple.OptionSet.valueOf(OptionSet.java:172)         at org.junit.platform.console.options.AvailableOptions.toCommandLineOptions(AvailableOptions.java:207)         at org.junit.platform.console.options.JOptSimpleCommandLineOptionsParser.parse(JOptSimpleCommandLineOptionsParser.java:41)         ... 3 more Caused by: org.junit.platform.console.shadow.joptsimple.ValueConversionException: Value [summary] is not one of [[none,flat,tree,verbose]]         at org.junit.platform.console.shadow.joptsimple.util.EnumConverter.convert(EnumConverter.java:63)         at org.junit.platform.console.shadow.joptsimple.util.EnumConverter.convert(EnumConverter.java:41)         at org.junit.platform.console.shadow.joptsimple.internal.Reflection.convertWith(Reflection.java:124)         at org.junit.platform.console.shadow.joptsimple.AbstractOptionSpec.convertWith(AbstractOptionSpec.java:90)         ... 8 more ```","closed","component: Platform,","evser","2018-01-25T14:16:44Z","2018-01-25T15:09:25Z"
"","1927","Code coverage percentage dropped drastically with junit-platform 1.4.0","When I switched to junit-runner 1.4.0 code coverage dropped from around 92% to 6%  https://github.com/steinarb/authservice/#status-of-the-project  The drop in coverage happened on both coveralls and sonar.  I've used git bisect and found that the change happens with this commit (switching from version 1.1.0 to 1.4.0 of junit-runner): https://github.com/steinarb/authservice/commit/664ac362e2919382407194c4b2f398debdcab846  I'm currently using 1.4.2 of junit-runner so upgrading didn't help.  ## Steps to reproduce  1. Download and install sonar locally https://docs.sonarqube.org/latest/setup/get-started-2-minutes/ 2. Clone the repo ``` git clone https://github.com/steinarb/authservice.git ``` 3. Build the project with sonar analysis ``` cd authservice mvn clean org.jacoco:jacoco-maven-plugin:prepare-agent -B install sonar:sonar -Dsonar.host.url=http://localhost:9000 ``` 4. Open http://localhost:9000/dashboard?id=no.priv.bang.authservice%3Aauthservice and observe that the coverage is 6.3% where it should have been 92%  ## Context   - Used versions (Jupiter/Vintage/Platform): junit 5.4.2 junit-platform 1.4.2 openjdk-8 1.8.0_212  - Build Tool/IDE: maven 3.6.0 on debian 9.9 ""stretch"" (current stable) on amd64  ## Deliverables  - [ ] ...","closed","","steinarb","2019-06-12T19:42:00Z","2019-06-19T14:36:06Z"
"","1017","Cannot supply 8 or more parameters to a @ParameterizedTest","When I supply eight parameters or more to a `@ParameterizedTest`, it does not work with 5.0.0-M6.  Who can help me?  ```java     @ParameterizedTest     @CsvFileSource(resources=""test.csv"")     void test(int id,                                  String sId,                                  String sign_type,                                  String charset,                                  String content,                                  String sign,                                  String name,                                  String code     ){         System.out.println(id);     } ```  ``` TestEngine with ID 'junit-vintage' failed to discover tests org.junit.platform.commons.JUnitException: Failed to load parameter type [ ...] 	at org.junit.platform.commons.util.ReflectionUtils.lambda$loadRequiredParameterType$10(ReflectionUtils.java:694) 	at java.util.Optional.orElseThrow(Optional.java:290) 	at org.junit.platform.commons.util.ReflectionUtils.loadRequiredParameterType(ReflectionUtils.java:693) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:545) ```","closed","status: works-as-designed,","ychaoyang","2017-08-14T11:06:42Z","2017-08-15T10:47:57Z"
"","1520","Cannot execute nested suites","When I create a suite like this:  ```java @RunWith(JUnitPlatform.class) @SelectClasses(SimpleTest.class) public class Suite1 { } ```  I can execute this suite e.g. with Eclipse.  But if I nest this suite inside another, like this:  ```java @RunWith(JUnitPlatform.class) @SelectClasses(Suite1.class) public class Suite2 { } ```  nothing is executed.  Using the console launcher I can't even execute `Suite1`:  ``` [java] '-- JUnit Jupiter [OK] [java] [java] Test run finished after 31 ms [java] [         1 containers found      ] [java] [         0 containers skipped    ] [java] [         1 containers started    ] [java] [         0 containers aborted    ] [java] [         1 containers successful ] [java] [         0 containers failed     ] [java] [         0 tests found           ] [java] [         0 tests skipped         ] [java] [         0 tests started         ] [java] [         0 tests aborted         ] [java] [         0 tests successful      ] [java] [         0 tests failed          ] ```  (Versions: JUnit Jupiter 5.2.0, Platform 1.2.0)  With JUnit 4 this was possible.","closed","theme: diagnostics,","phoenix384","2018-08-03T11:51:53Z","2018-08-08T13:48:38Z"
"","1648","Wait for dynamic tests before finishing test factory","When executing tests in parallel, lifecycle methods and callbacks called after a `@TestFactory` method are now always executed after the dynamic tests returned by the method.  Fixes #1643.","closed","theme: dynamic tests,","marcphilipp","2018-10-24T18:00:10Z","2018-11-20T12:00:36Z"
"","1239","No runner equivalent","What was nice with runners was to be able to delegate a class model logic to another runner and inherit from a full lifecycle. With JUnit 5 the extensions don't allow that and enforces you to integrate in the existing lifecycle which is a lot of work for custom @test.  Only alternative is an engine but is too impacting in terms of setup for end users.","closed","component: Jupiter,","rmannibucau","2018-01-12T14:16:24Z","2018-01-12T16:05:38Z"
"","1880","Introduce `pleaseStop()` method for `org.junit.platform.launcher.Launcher`","We would like to send a command to the engine to control the execution and stop the progress of pending tests via the interface `org.junit.platform.launcher.Launcher`.","open","component: Platform,","Tibor17","2019-05-15T10:43:58Z","2022-07-12T06:02:29Z"
"","1959","@Timeout should support debugging","We tried to use the new `@Timeout` annotation introduced in https://github.com/junit-team/junit5/pull/1885 to enforce a global timeout. I put it on the base class that all our JUnit Jupiter integration tests extend from.   It works, but unfortunately without any kind of ""DisableOnDebug"" feature we cannot realistically use it. When debugging a test and stepping through with a debugger it will fail early with the timeout.  If adding a global ""DisableOnDebug"" is not being considered, I think it would be a small fix to `org.junit.jupiter.engine.extension.TimeoutExtension` itself.  Just need to add something like this (copied from JUnit 4's `DisableOnDebug`) to `TimeoutExtension` and not apply the timeout if `isDebugging()` is `true`.  ```java private static boolean isDebugging() {     List inputArguments = ManagementFactory.getRuntimeMXBean().getInputArguments();     Iterator iterator = inputArguments.iterator();     String argument;     do {         if (!iterator.hasNext()) {             return false;         }          argument = iterator.next();         if (""-Xdebug"".equals(argument)) {             return true;         }     } while (!argument.startsWith(""-agentlib:jdwp""));      return true; } ```","closed","component: Jupiter,","jportner-hw","2019-07-15T18:23:52Z","2019-10-11T05:03:01Z"
"","1298","ConsoleLauncher returns 0 although selected class could not be loaded","We run a set of tests in a CI pipeline and call our test classes like this:      java -classpath junit-jupiter-api-5.0.1.jar:junit-platform-console-standalone-1.0.1.jar org.junit.platform.console.ConsoleLauncher --select-class xy.Test  If class `xy.Test` cannot be found on the classpath an error message appears but `ConsoleLauncher`'s return value is **0**! Since our CI system runs unattended the return value is the only important return value!  As I have seen this behaviour got updated in [JUnit 5.0.0 M2][1] but I regard this as a mistake: If I define a class by `--select-class` and the class cannot be found then something has gone wrong!  As I countermeasure I hacked (by means of introspection) `org.junit.platform.commons.util.BlacklistedExceptions` by overwriting blacklist's field with `OutOfMemoryError` (=default) and `PreconditionViolationException` (=case where class could not be found).   (If the standard behaviour shall not be changed...) **I think there should be a better way to get this behaviour!**   (Originates to a post on [Stackoverflow](https://stackoverflow.com/questions/48788829/consolelauncher-returns-0-although-class-under-test-could-not-be-loaded).)     [1]: https://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.0-m2","closed","component: Platform,","pfuerholz","2018-02-17T21:19:37Z","2018-06-02T16:18:49Z"
"","1152","junit5 not support spring Autowired annotation","We have a junit4 test class with Autowired field. After converting to junit5, Autowired stops working and throws NullPointerException.  @RunWith(JUnitPlatform.class) public class GetAvailableRewardsComponentTests extends ServiceComponentTestsBase {     @Autowired     private RequestValidator m_requestValidator;      @BeforeEach     public void setup()     {         m_requestValidator.setEnabled(false);     } ...","closed","","htzhang2","2017-11-08T17:02:29Z","2017-11-08T22:56:11Z"
"","1584","ResourceLocks via Extensions","We are wanting to experiment with parallel test threads to speed up execution. We are using a custom Extension in our e2e test suite.  These e2e tests are mostly read only tests with a few that modify db state.  The annotation takes the name of the client we are testing against. The Extension is then responsible for making sure everything related to the client is prepared and in the base state.  It then uses the ParameterResolver feature to passes testing objects into each test method that automatically talk to the client based on the annotation.  Within the Extension we know if the helpers request modify state or are read only.  We would like to be able to extend our existing extension to be able to dynamic add ResourceLocks on a per test bases.","closed","status: stale,","ashley-taylor","2018-09-13T23:12:37Z","2021-06-19T12:50:32Z"
"","1724","Tests not found via classpath scanning within nested JAR in Spring Boot JAR","We are providing a test suite for our applications as Spring Boot application. The test suite is basically a set of regular JUnit 5 tests that are launched in the Spring Boot application. The application is packaged as Spring Boot JAR (created with the `spring-boot-maven-plugin`).  We do now have the problem, that the tests are not found when we are using `DiscoverySelectors.selectPackage()` and run the application as Spring Boot JAR. Everything works fine, when we select the tests by classname. Executing the application within an IDE works fine as well.  The problem seems to be in `ClasspathScanner#findClassesForPath())`. `Files.walkFileTree()` does not work with nested JAR files. A similar problem was already reported in #399.  ## Steps to reproduce I created a [project on GitHub](https://github.com/ferstl/junit5-spring-boot) to reproduce this issue. When the `Application` is run within the IDE, everything works fine. When it is executed as Spring Boot JAR, the test is not found.  ## Context   - Used versions (Jupiter/Vintage/Platform): junit-bom 5.3.2  - Build Tool/IDE: Maven, OpenJDK11, IntelliJ - Spring Boot: 2.1.1.RELEASE","open","status: waiting-for-interest,","ferstl","2019-01-10T14:12:47Z","2022-06-15T20:06:32Z"
"","1962","Missing overloads of assertNotEquals for primitive types","Version: JUnit Jupiter 5.3.2  ```java @Test void equalsVsNotEquals() {   assertEquals(0, 0L);   assertNotEquals(0, 0L); } ```  Both of the above assertions will work. The reason is that `assertEquals` provides overloads for primitive types, while `assertNotEquals` doesn't. In other words:  - `assertEquals`: Actually compares the primitives -> 0 == 0 - `assertNotEquals`: Compares the wrappers -> Int != Long  I'd expect `assertEquals` to be the opposite of `assertNotEquals`, which is not the case.","closed","component: Jupiter,","HK201","2019-07-23T09:41:59Z","2019-07-24T07:31:51Z"
"","965","Cannot select method using fully qualified method name if it contains parameterized type information","Version: JUnit Jupiter 5.0.0-M5  I have a custom parameter resolver for tests that have a signature like:  ```java @Test  void doTest(Map parameterMap) ```  Unfortunately, the default launcher fails with this error:  ``` WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests org.junit.platform.commons.JUnitException: Failed to load parameter type [java.util.Map parameterMap) ```  ``` WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests org.junit.platform.commons.JUnitException: Failed to load parameter type [java.util.Set] ```  If I take out the type arguments, everything behaves as expected.  Expected behavior:   JUnit parameter resolution should work with generic types.","closed","component: Platform,","no2chem","2017-07-18T22:22:36Z","2017-07-21T14:54:45Z"
"","1942","Default MethodOrderer.Random seed is printed even when a custom seed is provided","Version: JUnit 5.5.0  When MethodOrderer.Random is used a message is printed displaying the default seed that was generated. This is useful when attempting to recreate a build if an issue was discovered, however if a seed has been provided this message should not be printed as it could be confusing as to which seed was used when executing tests in random order.  ## Deliverables  - [ ] Default seed should only be printed when no seed is supplied","closed","status: stale,","wkorando","2019-07-02T14:09:32Z","2022-07-11T20:21:43Z"
"","966","Selecting a test method with a type parameter argument fails","Version: Junit 5.0.0-M6  In an exploration of using type arguments in a parameter resolver, it seems that selecting a generic type parameter fails. For example, I have code like this:  ```java public interface MapContract, K, V> extends TestableMap {     @InterfaceTest     default void canPut(M map, K k1, V v1) {         map.put(k1, v1);          assertThat(map)                 .containsExactly(MapEntry.entry(k1, v1));     } ```  If I run the entire test class, it seems to work okay. If I try to select canPut(M,K,V)() in IntelliJ, I get: ```java WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests org.junit.platform.commons.JUnitException: Failed to load parameter type [M] 	at org.junit.platform.commons.util.ReflectionUtils.lambda$loadRequiredParameterType$10(ReflectionUtils.java:694) 	at java.util.Optional.orElseThrow(Optional.java:290) 	at org.junit.platform.commons.util.ReflectionUtils.loadRequiredParameterType(ReflectionUtils.java:693) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:545) 	at java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:260) 	at java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:438) 	at org.junit.platform.commons.util.ReflectionUtils.resolveParameterTypes(ReflectionUtils.java:688) 	at org.junit.platform.commons.util.ReflectionUtils.findMethod(ReflectionUtils.java:701) 	at org.junit.platform.engine.discovery.MethodSelector.lazyLoadJavaMethod(MethodSelector.java:169) 	at org.junit.platform.engine.discovery.MethodSelector.getJavaMethod(MethodSelector.java:142) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolveSelectors$3(DiscoverySelectorResolver.java:62) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:61) 	at org.junit.jupiter.engine.JupiterTestEngine.resolveDiscoveryRequest(JupiterTestEngine.java:68) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:61) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:82) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:49) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ```  Expected behavior: Should be able to select test class with type arguments.","closed","status: duplicate,","no2chem","2017-07-19T17:05:01Z","2018-05-12T18:20:48Z"
"","1960","Support focusing in addition to skipping","Using traditional JUnit structure there are no problems executing a single isolated test.  ```kotlin class Suite {     @Test a() = Unit     @Test b() = Unit  } ``` In the snippet above re-running `b` in isolation usually is not an issue in such IDEs as IJ. There is a green arrow nearby which executes a single method. This is great.  However, using non-traditional DSLs, similar to RSpec does not provide such a luxury.  ```kotlin @Testable class Suite : Spec({     context(""A"") {         it(""works"") {         }     }     context(""B"") {         it(""works"") {         }     } }) ``` Since both `context` and `it` are not method declarations but invocations there are no IDE hints to execute a single `B`.   In RSpec this is achieved using skipping (`xit`, `xcontext`) and focusing (`fit`, `fcontext`).  Lucky for us there is the `org.junit.platform.engine.support.hierarchical.Node.SkipResult` API which can be used to provide skipping. Unfortunately there is nothing for focusing. Of course it is possible to implement focusing manually going over the `TestDescriptor` tree, finding if there are focused nodes, then go over the whole tree again and mark all non-focused nodes as skipped. However, I thought maybe there is a chance to provide a mirror API for `Node.SkipResult` like `Node.FocusResult`.   WDYT? Is there some other way to achieve focusing using JUnit Platform? Or maybe hint the IDE that it is possible to execute a single node?","closed","status: stale,","arturdryomov","2019-07-20T09:38:01Z","2021-06-03T23:11:07Z"
"","1774","Log Spam on STANDARD_ERROR?","Using JUnit 5.4.0.  junit-platform.properties ``` junit.jupiter.execution.parallel.enabled=true junit.jupiter.execution.parallel.mode.default=concurrent ```  build.gradle ``` tasks.withType(Test).configureEach {   useJUnitPlatform()    forkEvery = 1    testLogging {     showStandardStreams = true   } } ```  Will lead to:  ``` Gradle Test Executor 93 STANDARD_ERROR     Feb 14, 2019 2:57:50 PM org.junit.platform.launcher.core.LauncherConfigurationParameters fromClasspathResource     INFO: Loading JUnit Platform configuration parameters from classpath resource [file:/Users/dev/tmp/build/resources/test/junit-platform.properties].  Gradle Test Executor 94 STANDARD_ERROR     Feb 14, 2019 2:57:50 PM org.junit.platform.launcher.core.LauncherConfigurationParameters fromClasspathResource     INFO: Loading JUnit Platform configuration parameters from classpath resource [file:/Users/dev/tmp/build/resources/test/junit-platform.properties].  Gradle Test Executor 95 STANDARD_ERROR     Feb 14, 2019 2:57:50 PM org.junit.platform.launcher.core.LauncherConfigurationParameters fromClasspathResource     INFO: Loading JUnit Platform configuration parameters from classpath resource [file:/Users/dev/tmp/build/resources/test/junit-platform.properties].  Gradle Test Executor 96 STANDARD_ERROR     Feb 14, 2019 2:57:50 PM org.junit.platform.launcher.core.LauncherConfigurationParameters fromClasspathResource     INFO: Loading JUnit Platform configuration parameters from classpath resource [file:/Users/dev/tmp/build/resources/test/junit-platform.properties].  ... several more of the above ...  com.test.MyTest STANDARD_ERROR     Feb 14, 2019 2:57:51 PM org.junit.jupiter.engine.config.EnumConfigurationParameterConverter get     INFO: Using parallel execution mode 'CONCURRENT' set via the 'junit.jupiter.execution.parallel.mode.default' configuration parameter. ```  Is this ""spam"" desired?  *showStandardStreams* is enabled because we need it for another use case.","closed","status: works-as-designed,","sdavids","2019-02-14T15:06:08Z","2021-07-23T18:08:30Z"
"","1162","TestReporter entries of a TestInstancePostProcessor extension are not written to the TestInstance output","Using JUnit 5.0.2 with latest IntelliJ.  Having an extension with this code: ```   @Override   public void postProcessTestInstance(Object testInstance, ExtensionContext context) {       long seed = 123L;       context.publishReportEntry(""seed"", String.valueOf(seed));   } ``` When using this extension on a test class, the report entries is not written to the stdout of the test class, but to the general stdout of the test run. Having multiple test classes in one run it is not possible to determine which report entry belongs to which test class.  Kind regards, Michael","closed","component: Platform,","reitzmichnicht","2017-11-15T16:06:42Z","2017-11-15T18:53:20Z"
"","1161","TestReporter entries are not published to maven surefire reports","Using JUnit 5.0.2 it would be great if entries published to the TestReporter are also written to the TEST-*.xml files of the maven surefire reports as properties.  Needed for example to document the seed used for random values.  Kind regards, Michael","closed","3rd-party: Maven Surefire,","reitzmichnicht","2017-11-15T15:55:41Z","2019-02-01T16:35:31Z"
"","1205","Correct class names for surefire test reports generated tests","Using Junit 5.0.2  The surefire Plugin does not output correct information for classnames in the TEST-*.xml reports for tests using `@ParametrizedTest` or `@TestFactory` ```     ```  The last two entries are generated with TestFactory and the classname is missing. The missing classname has sideeffects for Jenkins Test Results and also the SonarQube runner does not recognize them.","closed","component: Platform,","reitzmichnicht","2017-12-12T13:14:19Z","2017-12-13T14:51:33Z"
"","1234","Setting launcher main class name to an empty string breaks test execution on Linux","Using Java 9 module path instead of classpath by specifying ``` junitPlatform {    enableModulePath = true } ``` makes Gradle plugin clear the main class name string: https://github.com/junit-team/junit5/blob/a94ef93a68edd481673a81db86b2f4d844a3e063/junit-platform-gradle-plugin/src/main/groovy/org/junit/platform/gradle/plugin/JUnitPlatformPlugin.groovy#L133  The problem is that Gradle's `JavaExec` task unconditionally adds the main class name to the list of command line parameters: https://github.com/gradle/gradle/blob/master/subprojects/core/src/main/java/org/gradle/process/internal/JavaExecHandleBuilder.java#L219 ``` public List getAllArguments() {     List arguments = new ArrayList();     arguments.addAll(getAllJvmArgs());     arguments.add(mainClass);     arguments.addAll(getArgs());     return arguments; } ``` This breaks test execution on systems which natively support passing command line parameters as an array of strings (at least on Linux but other Unix-like systems are likely to be affected too) because JVM launcher treats this empty string as the main class name (_By default, the first argument that isn’t an option of the `java` command is the fully qualified name of the class to be called_) and fails with the following error: ``` Error: Could not find or load main class  Caused by: java.lang.ClassNotFoundException:  java.lang.ClassNotFoundException:  	at java.base/java.lang.Class.forName0(Native Method) 	at java.base/java.lang.Class.forName(Class.java:375) 	at java.base/sun.launcher.LauncherHelper.loadMainClass(LauncherHelper.java:654) 	at java.base/sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:551) ```  Gradle's bug tracker already contains a somewhat related report (https://github.com/gradle/gradle/issues/1346) about the ""-jar"" option for executable JARs. `main = '-jar'` is suggested as a workaround there so moving the ""--module"" option from `args` to `main` may be used in this case.  Temporary solution for end-users: ``` junitPlatformTest {     doFirst {         args = args.subList(1, args.size())         main = '--module'     } } ```  Gradle 4.4.1 Oracle JDK 9.0.1 on Debian GNU/Linux JUnit Platform 1.1.0-M1 JUnit Jupiter 5.1.0-M1 Test project: https://github.com/cmakshin/junit5-bugs (does not include the temporary solution shown above)","closed","3rd-party: Gradle,","cmakshin","2018-01-08T04:05:51Z","2018-01-16T09:59:21Z"
"","1694","README Junit5 repo link as HTTPS","Using an HTTP connection to an artifact server can leave you vulnerable to MITM attack. Linked below is a POC created back in the days when Maven Central didn't support HTTPS that dynamically re-writes jar files as they are downloaded by maven. https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/  The README isn't currently really advising people to use this url directly, but still, best to be safe.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","JLLeitschuh","2018-12-03T21:28:17Z","2018-12-04T07:32:44Z"
"","1711","junit-jupiter:5.4.0-M1 does not provide 5.4.0-M1 dependencies with Spring Boot 2.1.x","Using `testImplementation(""org.junit.jupiter:junit-jupiter:5.4.0-M1"")` does not provide 5.4.0-M1 dependencies when using Spring Boot 2.1.x in a Gradle build.  ![image](https://user-images.githubusercontent.com/7620013/50446139-97f5ae80-0913-11e9-9f49-8a973e059def.png)","closed","3rd-party: Gradle,","octopus-prime","2018-12-26T12:40:33Z","2018-12-26T15:29:51Z"
"","1233","""junitPlatformTest"" Gradle task does not handle dependencies defined by the Java Library plugin","Using `JavaExec` as the base for ""junitPlatformTest"" task breaks Gradle builds which: * use Java Library plugin for better/proper separation of interface and implementation dependencies; * have a dependency with direction opposite to the lexicographical order of projects' names.  An example can be found at https://github.com/cmakshin/junit5-bugs: Java 9 Gradle 4.4.1 JUnit Platform 1.1.+ (tested with 1.1.0-M1) JUnit Jupiter 5.1.+ (tested with 5.1.0-M1)  Project ""atestproject"" depends on ""projectB"" which depends on ""projectA"" (all dependencies are specified as ""implementation"").  Running `gradlew -m -PnoDummyTest=y build` will produce this output (I removed some irrelevant lines): ``` :projectA:compileJava SKIPPED :projectB:compileJava SKIPPED :atestproject:compileJava SKIPPED ... :atestproject:junitPlatformTest SKIPPED ... :projectB:jar SKIPPED :atestproject:test SKIPPED ``` An actual build would fail at "":atestproject:junitPlatformTest"" because its runtime classpath includes the output of "":projectB:jar"".  Adding a dummy Test task and making it a dependency of ""junitPlatformTest"" ``` task dummyTest(type: Test) {    enabled = false }  junitPlatformTest {     dependsOn.add(dummyTest) } ``` fixes the problem (`gradlew -m build`): ``` :projectA:compileJava SKIPPED :projectB:compileJava SKIPPED :atestproject:compileJava SKIPPED ... :projectB:jar SKIPPED :atestproject:dummyTest SKIPPED :atestproject:junitPlatformTest SKIPPED :atestproject:test SKIPPED ```  This workaround implies that task ordering has nothing to do with the implementation of the standard ""test"" task.","closed","3rd-party: Gradle,","cmakshin","2018-01-07T20:56:52Z","2018-01-17T11:59:04Z"
"","1697","@ResourceLock should be usable on test templates","Using `@ResourceLock` on a `@ParameterizedTest` or `@RepeatedTest` currently yields the following exception:  ``` org.junit.platform.commons.JUnitException: Dynamic test descriptors must not declare exclusive resources: [ExclusiveResource [key = 'java.lang.System.properties', lockMode = READ_WRITE]] 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeDynamicTest(NodeTestTask.java:128) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$3(NodeTestTask.java:106) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:133) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:101) 	... ```  ## Deliverables  - [ ] Make `@ResourceLock` usable on a `@TestTemplate`","closed","component: Jupiter,","marcphilipp","2018-12-09T09:21:43Z","2018-12-15T15:07:49Z"
"","1389","Update checkStyle toolversion","Update checkStyle toolversion from 8.8 to 8.9 in line 210  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: build,","anonden","2018-04-24T13:05:26Z","2018-04-24T14:27:17Z"
"","1569","Update ClassGraph and use try-with-resources","Update `ClassGraph` and follow suggestions from the release notes: https://github.com/classgraph/classgraph/releases  This seems to be a one-off command, so resource leaks are unlikely to be a problem, but otherwise @lukehutch might send you a reminder like this one: https://github.com/BrynCooke/cdi-unit/issues/141  Related: #1512  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","seanf","2018-08-30T07:26:50Z","2018-09-04T10:23:59Z"
"","1211","Provide a full equivalent replacement for the @Rule functionality","To my understanding, currently, there's no clean and elegant replacement for all opportunities that could be achieved leveraging `@Rule` available in _JUnit 4_.  Here's the idiom how we often implement reusable `Rule`s in order to bootstrap and tear down test servers (e.g. embedded databases or _RMI_ / _FTP_ servers) needed to mock external systems when executing integration tests:  ``` public class TestServer extends ExternalResource {    private final String fUser;    private final String fPwd;    private final String fUrl;     public TestServer(final String user, final String pwd, final String url) {       fUser = user;       fPwd = pwd;       fUrl = url;    }     @Override    protected void before() {       System.out.println(String.format(""Starting test server ('%s', '%s', '%s') ..."", fUser, fPwd, fUrl));       /* start up test server using the information this object's holding */       System.out.println(""... started test server."");    }     @Override    protected void after() {       System.out.println(String.format(""Shutting down test server ('%s', '%s', '%s') ..."", fUser, fPwd, fUrl));       /* shut down test server using the information this object's holding */       System.out.println(""... shut down test server."");    }     public String user() { return fUser; }    public String pwd() { return fPwd; }    public String url() { return fUrl; } }  ```  In the test cases where such a functionality is needed, we just declare a field as follows:  ``` public class JUnit4StatefulRuleTest {     @Rule    public final TestServer server = new TestServer(""hans"", ""wurst"", ""http://localhost:8118"");     @Test    public void testIt() {       /* execute (integration) test depending on the test server bootstrapped */    } } ```  When trying to implement this with _JUnit 5_ using `Extension`s, i.e. introducing and registering a class implementing `BeforeEachCallback` and `AfterEachCallback`, at least three issues come to my mind: 1. Since we cannot rely on the `Extension` object's state, we had to use the `Store`– which is at least cumbersome and counter-intuitive. 2. During test execution, we often need to query and assert the test server's state, i.e. some object (maybe the `Extension` itself) representing the test server would have to be declared as a field in the test class. This could be achieved by implementing `TestInstancePostProcessor` and injecting it. However, there wouldn't be any obvious connection between the field injected and the `ExtendWith` annotation since the latter can only be applied to types or methods. 3. There's no – at least to my understanding – clean (i.e. without using reflection) way to pass (initialization) information to the `Extension` object (how it's done in the `TestServer` `Rule` by invoking the ctor).  Am I missing anything here?","closed","component: Jupiter,","nico-de","2017-12-18T17:16:24Z","2018-06-04T13:35:04Z"
"","1508","Introduce Before/AfterEachExceptionHandler","To handle exceptions thrown by test methods there is the TestExecutionExceptionHandler interface an extension can implement. But I did not find a possibility to handle exceptions thrown by any user defined BeforeEach or AfterEach method. Would it be possible to introduce something like a BeforeEachExceptionHandler/AfterEachExceptionHandler as well?","closed","component: Jupiter,","phoenix384","2018-07-25T16:01:03Z","2018-07-25T18:33:42Z"
"","1516","Pass ArgumentConverter to ArgumentAccessor::get","TL;DR: On `ArgumentAccessor`, implement ` T get(int, Class, ArgumentConverter)` or ` T get(int, ArgumentConverter)`  ## Current situation  Say there's a parameterized test that uses `ArgumentAccessor` and wants to convert a single argument to a custom type. This doesn't work out of the box if that type has no suitable factory:  ```java @ParameterizedTest @CsvSource({ ""0"" }) void testPointNorm_(ArgumentsAccessor arguments) { 	// ""ArgumentAccessException: Argument at index [0] with value [0] and  	// type [String] could not be converted or cast to type [NoFactory]."""" 	NoFactory nope = arguments.get(0, NoFactory.class); 	assertNotNull(nope); }  static class NoFactory { 	NoFactory(int __) { } } ```  ## Proposal  Would be nice to convert that `String` to a `NoFactory`. If only there was some kind of converter... oh, wait: 😉  ```java @ParameterizedTest @CsvSource({ ""0"" }) void testPointNorm_(ArgumentsAccessor arguments) { 	NoFactory yay = arguments.get(0, NoFactory.class, NoFactoryConverter.class); 	assertNotNull(yay); } ```  (Using the converter manually is near impossible because it needs a `ParameterContext`.)  Now, if `ArgumentConverter` were generic in the returned type, `get` could even elide the type token:  ```java  T get(int, ArgumentConverter); ```","closed","status: stale,","nipafx","2018-08-01T12:01:45Z","2021-06-19T12:50:04Z"
"","1664","Use realistic examples in User Guide","This pull request is created to update the examples in the official documentation.  Issue: #1651  ## Overview  - Added sample Calculator class  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","saikatsgupta","2018-11-03T11:04:57Z","2018-11-24T16:11:14Z"
"","1371","Introduce JUnit BOM","This pull request introduces the `junit-bom` subproject. In order to reuse build logic it was moved to `gradle/maven.gradle`. In addition, `gradle install` and `gradle uploadArchives` now use the same POM configuration.  Resolves #316.","closed","component: Vintage,","marcphilipp","2018-04-14T11:26:48Z","2018-04-14T17:29:21Z"
"","1885","Introduce declarative timeouts","This PR introduces declarative timeouts for testable and lifecycle methods. The API surface consists of a new `@Timeout` implementation that can be applied to `@Test`, `@TestTemplate`, `@TestFactory`, and lifecycle methods. In addition, it can be applied to a test class which has the same meaning as declaring it on all of its testable, but not its lifecycle methods.  Moreover, default timeouts can be defined using configuration parameters for all of the above methods, all lifecycle methods, all testable methods, or each type individually.  The timeout is implemented in a preemptive manner, but without having to execute the test in a different thread. Instead, a single-thread `ExecutorService` is used to schedule interrupting the original test thread. This way, `ThreadLocal` will continue to work which is important for integration tests that use frameworks like Spring and its `@Transactional` support.  Resolves #80.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","marcphilipp","2019-05-17T18:48:11Z","2019-05-28T17:53:46Z"
"","1086","Simplify Jupiter filtering","This PR includes two refactorings:  - Reuse ClasspathScanningSupport to simplify DiscoveryFilterApplier - Use same ClassFilter for classpath scanning and post-discovery filtering  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] ~Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes)~ - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","marcphilipp","2017-09-29T21:55:28Z","2017-09-30T14:17:55Z"
"","1461","Add support for parallel test execution","This PR adds support for parallel test execution (#60). Please refer to the added user guide sections for details.  The majority of this work was done by @leonard84 and me over the course of the last few months. I intend to squash the commits before merging this PR. For reviewing, I've decided to keep them in place so it's easier to see why a change was made.  If you want to see it in action, just execute `SlowTests` in an IDE (tested in IntelliJ IDEA).  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","marcphilipp","2018-06-08T15:24:14Z","2019-07-19T19:32:25Z"
"","1427","Introduce ArgumentsProvider that computes the cartesian product of collections of datapoints","This issue originates from a dicussion in https://github.com/junit-team/junit5/pull/1422#issuecomment-390582297.  While often it suffices to specify each set of arguments for the invocation of a parameterized test explicitly, there are cases where it's simply the combination of lists of potential values for each parameter, i.e. the cartesian product of these collections. While it's certainly already possible to compute these combinations manually, e.g. in a method referenced by `@MethodSource`, it would be more convenient if there were a declarative way to specify that.  Recently, @sormuras has written a sample [`CartesianProductProvider`](https://github.com/junit-team/junit5-samples/blob/master/junit5-jupiter-extensions/src/main/java/com/example/cartesian/CartesianProductProvider.java) extension which does that by implementing `TestTemplateInvocationContextProvider`. However, by implementing this functionality as a `ArgumentsProvider` users would not have to learn a new concept and we could reuse the existing infrastructure.  One possibility would be to use fields and methods, like the `Theories` runner from JUnit 4.  ```java @BaseSet static final Set strings = Set.of(""foo"", ""bar"");  @BaseSet static Set ints() {     return Set.of(23, 42); }  @ParameterizedTest @AllCombinationsSource void test(String a, int b) {...} ```  @junit-team/junit-lambda Thoughts?  ## Deliverables  - [ ] Introduce new `ArgumentsProvider` and related annotations","closed","status: stale,","marcphilipp","2018-05-21T08:15:03Z","2022-07-12T23:11:13Z"
"","1355","Document minimum requirements for implementing a TestEngine","This is kind of a follow up on #1109 ... I didn't get around to this up to now, but now I have a working POC of a `TestEngine` with similar features to the custom JUnit 4 runner.  You can check this out here https://github.com/TNG/ArchUnit/tree/junit5-support/archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit  I like the power, e.g. that I can just mark `@AnalyzeClasses` with `@Testable` and my IDE will pick it up, and the engine will be 'magically' discovered, without the need to specify sth. like the old `ArchUnitRunner` :smiley:   However, with regards to the `TestEngine` itself, I'm kind of unsure. Maybe I've overlooked some documentation here, the design seems very flexible, but that also makes it hard to know which contract to adhere to.  As an example: `TestDescriptor` offers an `Optional getSource()` with the JavaDoc ""Get the source of the test or container described by this descriptor, if available."". So I assumed, I could leave that out for my first draft, implement only the most necessary. And the tests ran in IntelliJ and they ran in Maven. However, in Gradle they were silently skipped. It took me some digging into the Gradle sources to find out, that Gradle uses the test source, to determine, if this test is a 'composite' or not. And if the source is absent, an `AssertionError` is thrown, which in turn gets silently swallowed.  Or another one, I'm pretty sure, that the ""old"" Gradle JUnit 5 plugin (before Gradle 4.6) would call the engine with a `ClasspathRootSelector`, while with Gradle 4.6 this suddenly changed to a set of `ClassSelector`.  For my POC now, I've only added support for `ClassSelector`, the question is, do I need to add support for all the selector types? I'm just not sure, how I can be certain, that I covered the minimum to run on all common platforms. Do I really need to add support for `UriSelector` for example, or is this irrelevant for all common IDEs and Build tools anyway?  It feels a little bit, that to implement a `TestEngine`, one has to study the Jupiter engine and copy the behavior, since sticking to API + Javadoc does sometimes lead to surprising results (which can of course also be my fault for not completely understanding the concepts :wink: )  Anyway, any tipps what I really need to be somewhat on the safe side (that this will behave natural for daily development tasks) would be highly appreciated!!","closed","status: stale,","codecholeric","2018-04-02T16:46:37Z","2021-06-19T12:50:31Z"
"","1718","Introduce Launcher.execute(TestPlan)","This commit adds a new overload for `Launcher.execute()` that accepts a `TestPlan` directly thus avoiding running test discovery twice when `discover()` is called prior to `execute()`. The `JUnitPlatform` runner is changed to make use of this new feature.  Resolves #1695.","closed","theme: discovery,","marcphilipp","2019-01-02T20:55:23Z","2019-01-13T11:56:57Z"
"","1498","Pass command line arguments via file to ConsoleLauncher","There is a command line argument limit on OS-es like Windows(8081). So it would be good if it is possible to pass command line arguments to `junit-platform-console-standalone` via file since the classpath might be very big.","closed","component: Platform,","yyoncho","2018-07-17T10:12:37Z","2018-08-12T09:28:22Z"
"","1872","Consider removing runtime scope on `junit:junit` from the Vintage engine","The vintage engine currently has a `runtime` scope on JUnit 4. Strictly speaking, I can't argue this is wrong but it has several unpleasant side effects:  * With Maven, adding the vintage engine in `test`scope means that everything that it brings share that scope (`test`) so `junit` is on the test classpath and all is well. * Gradle, on the other hand, looks at the scope in transitive dependencies and honours them. Adding the vintage engine in `testCompile` does not bring JUnit 4 to the test compile classpath.  Looking at your samples, this looks like [an intentional decision](https://github.com/junit-team/junit5-samples/blob/6b61ee73aa4e9f860ec7e2e34c025d58a3525a9c/junit5-migration-gradle/build.gradle#L27).   Would it be possible to remove that scope from the vintage engine so that the story is more consistent between those two build systems? The same way we've asked you to add `junit-jupiter` to have one library that brings the necessary bits, I'd argue that adding the vintage engine should bring me the necessary bits to compile/run tests using JUnit 4.  We didn't notice this problem immediately when we migrated Spring Boot to JUnit 5. We've taken the decision [to add junit 4 explicitly in our starter](https://github.com/spring-projects/spring-boot/issues/16807) to make sure gradle-based projects are not broken on upgrade. Doing so makes it harder to switch purely to JUnit 5 as [two dependencies have to be excluded now](https://github.com/spring-projects/spring-boot/commit/81af0f2fa672d962d4c8569b6b7ee802008717c2#diff-3034c859fdf54b18876462585532bd82R6822).","closed","component: Vintage,","snicoll","2019-05-09T13:51:20Z","2019-07-19T19:32:27Z"
"","1324","@BeforeAll not running","The UsersController field isn't getting initialized in the BeforeAll method. It's my understanding the BeforeAll method should run before the test in called, so the field should be initialized.   > java.lang.NullPointerException > 	at UsersControllerTest.register_test(UsersControllerTest.java:27)  ```java import static org.junit.jupiter.api.Assertions.assertEquals; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestInstance; import org.junit.jupiter.api.TestInstance.Lifecycle;  @TestInstance(Lifecycle.PER_CLASS) public class UsersControllerTest { 	UsersController usersController;  	@BeforeAll 	public void init() { 		this.usersController = new UsersController(); 	}  	@Test 	public void register_test() { 		String email = ""test@gmail.com""; 		String password = ""bitconnect""; 		String fname = ""Trevon""; 		String lname = ""James""; 		Users newUser = usersController.register(email, password, fname, lname); 		assertEquals(newUser.getFname(), fname); 	} } ```  https://github.com/7--/GoldTeam-Tomcat/blob/master/src/test/java/com/revature/controller/UsersControllerTest.java","closed","status: invalid,","7--","2018-03-11T04:37:41Z","2018-03-11T08:58:52Z"
"","1032","Don't call distinct on stream of requests","The requests are already distinct, because  1. TestClassRequest does not override equals. 2. CompleteRequests never have filters but filteredRequests always have. Therefore completeRequests and filteredRequests are disjunct. 3. CompleteRequests are created from a set of classes. Hence they are all different. 4. FilteredRequests are created from map entries. Hence they are all different.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","stefanbirkner","2017-08-25T05:30:39Z","2017-08-29T20:32:10Z"
"","1536","Deprecate junit-platform-surefire-provider","The provider is now part of Maven Surefire. Thus, the old provider should be deprecated.  ## Deliverables  - [x] Deprecate all public API - [x] Emit deprecation warning when it's used.","closed","3rd-party: Maven Surefire,","marcphilipp","2018-08-11T18:32:40Z","2018-08-12T09:55:44Z"
"","1813","Allow extensions to fail tests","The problem that I have, is that I need to fail all of the tests that took too long. I measured the test's execution time in the `beforeEach` and `afterEach` methods (works well), but when I try to throw the `AssertionFailedError` in the `afterEach` callback nothing happens. Should be solved by not catching this specific exception from the extensions. Correct me but I do not see a good reason throw this error in an extension, unless you want to modify the results. (I know that a test fails, if an exception is thrown in the `@BeforeEach`/`@AfterEach` methods)  ## Deliverables  - [ ] do not catch  `AssertionFailedError`s from extensions","closed","component: Jupiter,","Frontrider","2019-03-13T11:47:53Z","2019-03-14T12:47:26Z"
"","1710","Overloaded assertions should work from Groovy","The overloaded assertions introduced as part of #1638 broke Groovy's dynamic method dispatch. For example the following code yields the following exception:  ```groovy assertEquals(2, new Integer(2), ""some message"") ```  ``` groovy.lang.GroovyRuntimeException: Ambiguous method overloading for method org.junit.jupiter.api.Assertions#assertEquals. Cannot resolve which method to invoke for [class java.lang.Integer, class java.lang.Integer, class java.lang.String] due to overlapping prototypes between: 	[int, class java.lang.Integer, class java.lang.String] 	[class java.lang.Integer, int, class java.lang.String] ```  Adding an overload that matches `[class java.lang.Integer, class java.lang.Integer, class java.lang.String]` exactly might solve the issue.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.4 M1  ## Deliverables  - [x] Make Groovy's dynamic dispatch work with the new overloaded methods","closed","component: Jupiter,","marcphilipp","2018-12-23T18:53:38Z","2019-04-12T06:02:11Z"
"","1910","Add config param for default execution mode of top-level classes","The new `junit.jupiter.execution.parallel.mode.classes.default` configuration parameter can be used to run top-level classes in parallel but their methods sequentially or vice versa.  Resolves #1682.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2019-06-01T19:17:03Z","2019-06-05T17:49:04Z"
"","1547","Ship picocli license with junit-platform-console","The junit-platform-console JAR currently ships with `META-INF/LICENSE-jopt-simple.md`. Instead, it should include picocli's license.  ### Deliverables  - [x] Replace `LICENSE-jopt-simple.md` with `LICENSE-picocli.md`","closed","component: Platform,","marcphilipp","2018-08-14T18:26:22Z","2018-08-15T08:51:59Z"
"","1107","Gradle plugin to support 'ignoreFailures'","The Gradle plugin for JUnit 4 allows you to set 'ignoreFailures = true' so that failing tests do not fail the task.  There is no such option for the JUnit 5 gradle plugin. Please consider adding it.  The absence of this feature is a major roadblock for migrating to JUnit 5 as our builds rely on it heavily.","closed","3rd-party: Gradle,","cschwarz-inco","2017-10-13T23:04:32Z","2017-10-14T17:08:24Z"
"","1490","Kotlin extension function ArgumentsAccessor.get is unusable, i.e.compiled to private","The extension function ArgumentsAccessor.get(...) was introduced in https://github.com/junit-team/junit5/issues/1382. However, I cannot `import org.junit.jupiter.params.aggregator.get` because the extension function is compiled to a _private static_ method: ``` > javap -c -p -cp .\junit-jupiter-params-5.3.0-M1.jar org.junit.jupiter.params.aggregator.ArgumentsAccessorKt Compiled from ""ArgumentsAccessor.kt"" public final class org.junit.jupiter.params.aggregator.ArgumentsAccessorKt {   private static final  T get(org.junit.jupiter.params.aggregator.ArgumentsAccessor, int);     Code:        0: aload_0        1: iload_1        2: iconst_4        3: ldc           #26                 // String T        5: invokestatic  #32                 // Method kotlin/jvm/internal/Intrinsics.reifiedOperationMarker:(ILjava/lang/String;)V        8: ldc           #4                  // class java/lang/Object       10: invokeinterface #37,  3           // InterfaceMethod org/junit/jupiter/params/aggregator/ArgumentsAccessor.get:(ILjava/lang/Class;)Ljava/lang/Object;       15: dup       16: ldc           #39                 // String this.get(index, T::class.java)       18: invokestatic  #43                 // Method kotlin/jvm/internal/Intrinsics.checkExpressionValueIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V       21: areturn ```","closed","component: Kotlin,","juergenzimmermann","2018-07-08T06:26:15Z","2019-07-19T19:32:26Z"
"","1956","Fix discovery of inherited nested classes","The discovery algorithm introduced in 5.5 remembers already the resolution of each discovery selector. Prior to this commit, nested classes were resolved by adding a ClassSelector for the nested class. If that ClassSelector has been resolved before, discovery is assumed to be finished. Similarly, when resolving MethodSelectors for methods within a nested test class that have been resolved before, discovery will stop.  This commit introduces dedicated selectors for nested classes and their methods which take into account the actual enclosing classes that will be present at runtime. These selectors are package-private for now but could be made publicly available in a future release.  Fixes #1954.  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","marcphilipp","2019-07-10T19:16:05Z","2019-07-16T06:52:54Z"
"","1404","Dependency Diagram not rendered in User Guide","The Dependency Diagram is not rendered in the **current** version of the User Guide. Instead, the source code was emitted:  ``` skinparam {     defaultFontName Open Sans }  package org.junit.jupiter {     [junit-jupiter-api] as jupiter_api     [junit-jupiter-engine] as jupiter_engine     [junit-jupiter-params] as jupiter_params     [junit-jupiter-migrationsupport] as jupiter_migration_support }  package org.junit.vintage {     [junit-vintage-engine] as vintage_engine ... ```  https://junit.org/junit5/docs/current/user-guide/#dependency-diagram  Both, the HTML and PDF versions are affected.  The **snapshot** version shows the expected image:   ![component-diagram](https://junit.org/junit5/docs/snapshot/user-guide/images/component-diagram.svg)  https://junit.org/junit5/docs/snapshot/user-guide/#dependency-diagram","closed","theme: documentation,","sormuras","2018-05-02T20:52:29Z","2018-05-04T08:02:49Z"
"","1484","Allow Assertions and Assumptions classes to be extended","The current class is `final` and has a `private` constructor. This means that in order to use its methods without having to qualify them as `Assertions.assertEquals/assertTrue/etc...` one has to use static imports. In many projects (including ours) this is not allowed due to various concerns (here is neither the place nor the time to discuss them). In _JUnit 4_, the `Assert` class was not final, so we could easily extend it and use the various _assertXXX_ methods without having to qualify them ```java public class FooTest extends Assert {     @Test     public void testSomething() {         ....         assertEquals(""Mismatched X and Y"", x, y);     } } ``` Unfortunately, we cannot do this with `Assertions` - which means we cannot use _JUnit 5_ since our project does not allow static imports and we would rather not use qualified access on our 1000's of assertions (again, neither the place nor the time to discuss why...) . It would really help (IMO not just us) if `Assertions` was extensible...","closed","component: Jupiter,","lgoldstein","2018-07-01T13:12:25Z","2018-07-03T16:03:56Z"
"","1743","Functional View on top of the JUnit Jupiter Extension API","The Core API could be extended with an official functional view. Means, that the developer would have the choice between ""oo"" or ""functional"" approach. The functional API should be Core Java only, no ByteCode manipulation to be available from JDK8 up to JDKxx without changes.  ## Example Ideas..  ```java   static Function storeGlobal() {     return (context) -> context.getStore(NAMESPACE_GLOBAL);   }   static Function store() {     return (context) -> context.getStore(namespaceFor().apply(context));   }   static Function> storeObjectIn() {     return (context) -> (key, value) -> store().apply(context).put(key, value);   }    static Function> removeObjectIn() {     return (context) -> (key) -> store().apply(context).remove(key);   } ```  ## Deliverables I would like to deliver  - [ ] the Core Java API for the functional view on top of the JUnit Jupiter Extension API. - [ ] the documentation about the API - [ ] coding examples how to use it","closed","3rd-party: Pioneer,","svenruppert","2019-01-22T08:41:19Z","2019-02-05T08:27:23Z"
"","1361","Briefly explain support in Ant build tool for JUnit 5 tests","The commit here updates the user guide and adds a section for documenting the recent support available in Ant build tool for launching JUnit 5 tests. This relates to issue https://github.com/junit-team/junit5/issues/1352","closed","component: Platform,","jaikiran","2018-04-07T07:47:38Z","2018-04-10T08:41:47Z"
"","1838","Introduce support for rerunning failed tests first","the button in he JUnit eclipse view that says rerun failed first does nothing different than the one right next to it (rerun) please either remove or preferably fix its functionality ## Steps to reproduce  run tests that fail click rerun failed first no change in order  ## Context   - Used versions (Jupiter/Vintage/Platform):  - Build Tool/IDE: eclipse 2019-03 and previous  ## Deliverables","open","component: Platform,","jonnytest1","2019-03-28T13:40:50Z","2022-07-01T13:46:34Z"
"","1528","Fixing concurrent access issue in TreePrintingListener","The addNode operation in the TreePrintingListener was non-atomic and subject, therefore, to a race condition. This change makes the methods that access the map synchronized to remove that race condition. Since the access of the map is locked on the ""this"" object by the synchronized keyword, the use of the ConcurrentHashMap is no longer needed and is therefore an extra set of locking that is unnecessary.  Issue: #1524  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","littleclay","2018-08-07T02:23:41Z","2018-08-07T20:49:18Z"
"","1732","Forbid modification of TestPlan","The `TestPlan` returned by `Launcher.discover()` and passed to `TestExecutionListener.testPlanStarted()` is currently modifiable for backwards compatibility (see #1695 for background).  This issue is used to track progress of tool adoption so the JUnit team can decide when it's safe to ignore/forbid modification of `TestPlan`.","closed","component: Platform,","marcphilipp","2019-01-14T12:36:50Z","2021-06-05T16:32:02Z"
"","1919","Provide a MethodOrderer that uses the order in the source file","The `MethodOrderer` implementation `OrderAnnotation` uses an `@Order` annotation to allow sorting the execution order of tests (which is generally a smell, but sometimes necessary). But that means another annotation for every test method. It would be nicer to simply use the order of the methods in the source. As this information is not provided by the Java reflection API, we'd have to parse the class file. Maybe we don't need a full parser, but a simple heuristic may be enough.  Some years ago I already wrote a simple JUnit 4 runner for this [here](https://github.com/t1/test-tools/blob/master/src/main/java/com/github/t1/testtools/OrderedJUnitRunner.java)  ## Deliverables  - [ ] `ClassFileMethodOrderer` implementing `MethodOrderer`","closed","3rd-party: Pioneer,","t1","2019-06-06T06:22:31Z","2022-03-18T14:06:43Z"
"","1331","Delete junit-platform-gradle-plugin subproject","The `junit-platform-gradle-plugin` will be deprecated in JUnit Platform 1.2 and is scheduled to be discontinued in JUnit Platform 1.3.  ## Deliverables  - [x] Remove the `junit-platform-gradle-plugin` subproject from Gradle config and Git repo using the **JUnit Team** account for the commits","closed","3rd-party: Gradle,","marcphilipp","2018-03-17T10:15:36Z","2018-05-14T12:05:42Z"
"","1835","Discovery request resolver: apply class (name) filter by default","The `EngineDiscoveryRequestResolver` introduced in `1.5.0-M1` should apply _class name_ and _class instance_ filter by default.  ## Deliverables  - [ ] Find an appropriate way to pass filter predicate(s) when creating a `EngineDiscoveryRequestResolver` builder.","closed","component: Platform,","sormuras","2019-03-27T07:33:14Z","2019-05-27T19:53:54Z"
"","1798","Introduce configurable discovery algorithm","The `EngineDiscoveryRequestResolver` class implements a test discovery in a way that can be reused by different test engines. The Jupiter and Vintage test engines are changed to use it.  Main entry point is `EngineDiscoveryRequestResolver.builder()` which allows to add resolvers (via a new `SelectorResolvers` interface) and visitors (reusing `TestDescriptor.Visitor`) that will be called to resolve `DiscoverySelectors` in a given `EngineDiscoveryRequest`.  In order to support class based test engines, the predefined `ClassContainerSelectorResolver` may be added via the builder as well. It resolves `ClasspathRootSelectors`, `ModuleSelectors`, and `PackageSelectors` into `ClassSelectors` by scanning for classes in the corresponding class container.  The fundamental principle behind `SelectorResolver` is that both the designated parent of a `TestDescriptor` and its designated children can be specified using `DiscoverySelectors`. For example, in the case of the Jupiter engine, when resolving a nested test class, there's a resolver that specifies the parent using the `ClassSelector` of the enclosing class and the children as the set of `MethodSelectors` of the testable methods it contains joined with the set of `ClassSelectors` of nested classes it contains.  Overall, the algorithm works as follows:  1. Enqueue all selectors in the supplied request to be resolved. 2. While there are selectors to be resolved, get the next one.    Otherwise, the resolution is finished.    1. Iterate over all registered `SelectorResolvers` in the order they       were registered in and find the first one that returns a non-empty       resolution.    1. If such a resolution exists, enqueue the contained selectors.    1. For each exact match in the resolution, expand its children and       enqueue them as well.    1. Iterate over all registered visitors and let the engine descriptor       accept them.  Descriptors with the same unique ID are only resolved once, even if specified using multiple selectors.  Resolves #1739.  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","marcphilipp","2019-03-03T14:45:12Z","2019-03-10T20:15:59Z"
"","1833","Annotate user facing API with @API","The ``TempDirectory`` extension as well as others in https://github.com/junit-team/junit5/tree/835160321973c08ba03cd5792d6e42b2866aa98f/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension are effectively user APIs and should be annotated with their life-cycle status.  This is an interesting case because these classes are not in the API module, are specific to the Jupiter engine (they won't run in other test engines) but are explicitly advertised for use by test authors.  If we want to keep a strict separation between the API used by test authors and the engine, I suppose we could create a ""jupiter extensions"" module but in either case it's my opinion that these methods should be annotated and that tools for checking API guardian annotations should consider this package.  As an aside, do the API guardian tools consider unannotated targets as ``INTERNAL``?  Related to #1832 - ``@TempDir`` is listed in that issue which is a ``junit-jupiter-api`` use of the extension provided by ``junit-jupiter-engine``.","closed","","smoyer64","2019-03-25T15:03:39Z","2019-03-29T14:34:04Z"
"","1930","Extend fallback argument conversion","The [fallback approach to argument conversion](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-argument-conversion-implicit-fallback) is a good one, however I'd like to see it extended in two ways:  Firstly, it only considers methods that accept `String`, whereas there are cases where the factory method accepts `CharSequence`. Notably, this includes `java.time.*` and the related ThreeTen projects.  Secondly, the fallback approach can't complete if it finds multiple matching factory methods. This is an issue that [Joda-Convert](https://www.joda.org/joda-convert/) tackles with annotations:  ```java     import org.joda.convert.FromString;     public class Point {       @FromString       public static Point of(String str) {...}       public static Point ofInverted(String str) {...}     } ```  (the one annotated with `@FromString` is the one to use for parsing formalized strings in the way JUnit requires).  What I am proposing is that if the fallback mechanism reaches a point where it finds multiple matching factory methods/constructors, it then searches for an annotation with the name `FromString` (not the type `org.joda.convert.FromString` to avoid the dependency) and chooses that one. This would occur at the end of the current lookup process, thus be backwards compatible.  Supporting this approach would instantly make Joda-Time, Joda-Money and ThreeTen-Extra types compatible with JUnit 5, as they all use Joda-Convert.  For completeness, I note that the `ArgumentConverter` interface already allows Joda-Convert to be integrated if desired. Where the approach above enhances this is that it provides a way to integrate the concept of Joda-Convert directly into JUnit 5 *without the need to add the dependency*.","closed","status: stale,","jodastephen","2019-06-14T11:54:32Z","2021-06-19T12:50:05Z"
"","1353","Include OSGi metadata in published artifacts of mavenized projects","The 'osgi' Gradle plugin analyzes source files and creates an OSGi compatible MANIFEST.MF containing ""Import-Package"" and ""Export-Package"" as well as some further ""Bundle-*"" attributes. (see also https://docs.gradle.org/current/userguide/osgi_plugin.html)  Any feedback is welcome :-)  ## Overview  I applied the 'osgi' Gradle plugin to all mavenized projects. I also used this 'osgi' plugin for my project (https://github.com/TNG/junit-dataprovider) and it worked fine for a huge OSGi project. **Disclaimer**: As I have no longer access to that project, I could not test it myself. Maybe t is a good idea to test it with a real-life OSGi project.  Subproject 'junit-platform-console-standalone' is excluded as it does not contain any source code itself which is not supported by 'osgi' plugin.  For multi-release jars other dependencies of 'jar' task should not be removed, instead ':*-java-9:classes' task should only be added.  Issue: #195   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by ~~[automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests)~~ manual tests on a real life OSGi project (see comment above)   - Idea: Providing a SNAPSHOT version of this PR on Maven Central such that somebody can take it from there and test it on his/her OSGi project. - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes)    - Precondition: As soon as you accept the change, I will create a suggestion for the ""User Guide"" and ""Release Notes"" - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass - [ ] For issues: change is merged into master - [ ] Issue and pull request, if applicable, are closed and assigned to the corresponding milestone, the labels _in progress_ and _team discussion_ label have been removed","closed","","aaschmid","2018-03-31T21:52:43Z","2019-07-19T10:24:38Z"
"","1907","`junit-testkit` usability feedback","Thanks for providing the `junit-testkit` module, it has made testing extensions more straightforward and supported. I have been documenting some of my usability concerns with it while it is still in the experimental phase. These can most likely be split into multiple issues to decide what to do, but I thought I would put them here in aggregate to see how the team and other users feel about them.  For each section, I tried to demonstrate the problem with a code sample and offer up proposal idea for how I would like to see it behave. Take the proposals as an initial idea or to help frame the discussion around if my feedback is warranted or not.  ### `assertStatistics()` failure output  The failure output for `assertStatistics()` hasn't been useful, and the feature kind of feels like a trap. Asserting on events produces more helpful output than when using the statistics.  #### Demonstration  The example below let's say that one of the assertions failed:  ```kotlin results.tests().assertStatistics {     it.failed(0)     it.succeeded(1) } ```  The failure output is then:  ``` Expected :0 Actual   :1    Expected :1 Actual   :0 ```  Which doesn't help when debugging.  We have found ourselves instead just using the `assertThatEvents()` chaining as the events contain more information about why it succeeded/failed.  ```kotlin results.tests()     .failed()     .assertThatEvents()     .isEmpty()  results.tests()     .succeeded()     .assertThatEvents()     .hasSize(1) ```  #### Proposal  For us, we have tried to remove any usage of `assertStatistics` and only use the events as demonstrated above.  ### AssertJ `Condition`s are cumbersome  `junit-testkit` is tightly coupled to AssertJ, so the best way to build additional assertions is to use  `Condition`. For example, there are already [`EventConditions`](https://github.com/junit-team/junit5/blob/672ef9a2c50a50c96fca791e17b1d876a5caa7f4/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java) and [`TestExecutionResultConditions`](https://github.com/junit-team/junit5/blob/672ef9a2c50a50c96fca791e17b1d876a5caa7f4/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java) that comprise a good chunk of the conditions you may use. However, chaining `Condition` together can be cumbersome and also creating new ones can be a bit ugly.  #### Throwable Demonstration  ```kotlin results.tests()     .failed()     .assertThatEvents()     .hasSize(1)     .haveExactly(         1,         finishedWithFailure(             cause(                 allOf(                     message(""can't create configuration""),                     instanceOf(RuntimeException::class.java)                 )             )         )     ) ```  I find using nested `Condition`s tough. This feels closer to Hamcrest territory, and it misses out on all of the built-in assertions and output that AssertJ already provides.  #### Report Entry Demonstration  Here is an example for testing for `ReportEntry` and the published values. There aren't built-in `Condition`s for `ReportEntry` yet in `junit-testkit`, so we have a few of our own.  ```kotlin import org.assertj.core.api.Condition import org.junit.platform.engine.reporting.ReportEntry import org.junit.platform.testkit.engine.Event import org.junit.platform.testkit.engine.Event.byPayload import org.junit.platform.testkit.engine.Event.byType import org.junit.platform.testkit.engine.EventType  fun reportEntryPublished(): Condition {     return Condition(         byType(EventType.REPORTING_ENTRY_PUBLISHED),         ""report entry published event""     ) }  fun reportEntryPublished(condition: Condition): Condition {     return Condition(         byPayload(ReportEntry::class.java) { condition.matches(it) },         ""report entry published event with result where %s"",         condition     ) }  fun keyValuePairs(condition: Condition>): Condition {     return Condition(         Predicate { condition.matches(it.keyValuePairs) },         ""key value pairs where %s"",         condition     ) }  fun hasEntry(key: String, value: String): Condition> {     return Condition(Predicate { it[key] == value }, ""has entry (%s, %s)"", key, value) } ```  Using those `Condition` implementations on `EngineExecutionResults`:  ```kotlin  results.tests()     .reportingEntryPublished()     .assertThatEvents()     .haveExactly(1, reportEntryPublished(keyValuePairs(hasEntry(""thing_happened"", expectedValue)))) ```  I think this shows a few things:  * `Condition` types can be difficult to write * Nested conditions can be tough to use * No ability to use built-in AssertJ assertions like `MapAssert.hasKey` * No (I don't see one) clear path to using other assertion libraries (use `.list()` or `.stream()` to get `Events`, but you still need to filter and combine them with `Condition`)  #### Proposal  My proposal would be to try and make most of the types in `junit-testkit` agnostic of assertion library and also add stronger typing. This will enable users to use whatever assertion library they want, reducing size of needed APIs (I think), and not having to provide custom assertion entrypoints like the `assertStatistics()` above.  For example, instead of having `enum EventType` and `class Event`, they could be combined for stronger typing - like `ReportingEntryPublished`  Then, AssertJ might look like:  ```kotlin assertThat(result.tests().events())     .filteredOn { it is ReportingEntryPublished }     .extracting { it as ReportingEntryPublished }     .extracting> { it.keyValuePairs } ```  Possibly with some built-in helpers. Or, if AssertJ improves in this area (or I'm missing something), then users can use that version of AssertJ.  Or, when other assertion libraries like strikt/Kotlin are used:  ```kotlin expectThat(result)   .get { tests() }   .get { events() }   .filter { it is ReportingEntryPublished }   .map { it.keyValuePairs } ```  ### `EngineExecutionResults` method chaining  I find the chaining to be a bit misleading and confusing at times as the method chaining is not strongly typed. The meaning when doing this is unclear  #### Demonstration  ```kotlin results.tests().containers().tests().failed().success().all() ```  ```kotlin results.tests().failed().failed().all() ```  #### Proposal  In the same theme as the proposal above, is to make `junit-teskkit` agnostic of assertion library and make results more strongly typed.  ### Mocking dependencies in extensions  We often find ourselves wanting to ""inject"" behavior into our extensions to flex different behaviors in both them and the tests that would consume them. This comes up especially when our extensions are used with external tools that we don't necessarily want to actually use during testing of that extension. This is a little tough to do today due to the test engine constructs those extensions.  #### Demonstration  One of the incredibly ugly ways we have been doing this today is serializing/deserializing behavior we want by using `configurationParameter(String key, String value)`. This works for us, so ¯\\\_(ツ)\_/¯.  We have also started to experiment using `@RegisterExtension` and providing some factory that retrieves the ""mocked"" instance/behavior we want.  #### Proposal  I don't have anything concrete here, more just food-for-thought, and open to suggestions for how to make this better.","open","component: Test Kit,","mkobit","2019-05-30T21:33:47Z","2022-07-12T07:51:54Z"
"","1731","Discussion: constructor parameter resolution, scope, etc.","Thanks for adding TempDirectory to JUnit 5.4.0-M1. This will make migration from JUnit 4 easier in my projects :-)   One point looks wrong to me though: A `@TempDir` constructor parameter is treated like a parameter of a `@BeforeAll` method, ie its value is shared between all tests. See [Javadoc of TempDirectory](https://junit.org/junit5/docs/5.4.0-M1/api/org/junit/jupiter/api/support/io/TempDirectory.html): > The temporary directory will be shared by all tests in a class when the annotation is present on a parameter of a @BeforeAll method or the test class constructor. Otherwise, e.g. when only used on test or @BeforeEach or @AfterEach methods, each test will use its own temporary directory.  I would expect a `@TempDir` constructor parameter to be treated like parameter of a `@BeforeEach` method, ie a new value for each test.   I'm not sure about the finer points of parameter resolving in JUnit, so maybe the current behavior is as intended. Reasons why I think a `@TempDir` constructor parameter should have a new value for each test: 1. [According to the User Guide](https://junit.org/junit5/docs/5.4.0-M1/user-guide/#writing-tests-test-instance-lifecycle)  ""JUnit creates a new instance of each test class before executing each test method"" New instance -> new constructor call -> new value for constructor parameter (my expectation) 2. `@BeforeAll` = by default a static method = global state `@BeforeEach` = instance method = single test state constructor = instance bound = single test state 3. I normally want a clean temp directory for each test. Sometimes a shared temp directory might be needed, but it's the exception. 4. Isn't `@TestInstance(Lifecycle.PER_CLASS)` the normal way to share constructor state between all tests?  By the way, the Javadoc is really thorough. Very helpful!","closed","status: stale,","arend-von-reinersdorff","2019-01-13T21:57:45Z","2021-06-19T12:50:32Z"
"","1533","Lifecycle.PER_CLASS ⇒ ExecutionMode.SAME_THREAD","Tests in classes that use `Lifecycle.PER_CLASS` now use `ExecutionMode.SAME_THREAD` by default when parallel execution is enabled. In the case of nested classes, as soon as one enclosing class uses `Lifecycle.PER_CLASS` all contained nested classes and tests use `ExecutionMode.SAME_THREAD`.  Fixes #1511.","closed","component: Jupiter,","marcphilipp","2018-08-10T20:08:40Z","2018-08-13T18:55:17Z"
"","1218","Introduce implicit argument conversion for Locale, URI, and Currency","Tests for business apps will be easier when `@ParameterizedTest` tests also have implicit argument conversions for `java.net.URI` and `java.util.Currency` -- just as today for e.g. `LocalDate`.","closed","theme: parameterized tests,","juergenzimmermann","2017-12-28T06:06:13Z","2018-01-24T11:24:36Z"
"","1761","Class-level @Test annotation","TestNG has a nice feature where the `@Test` annotation is added to the test class instead of the test method. When the class is annotated, all public void-returning methods on the class are treated as test methods, as per the [documentation](https://testng.org/doc/documentation-main.html#class-level).  ```java @Test public class Test1 {      public void test1() {     }      public void test2() {     }  } ```  I'd like to see a mechanism to replicate this in JUnit 5. This would aid conversion from TestNG and be more DRY. It also avoids problems with annotating each method (eg. forgetting to add the annotation to one method in a large class, and the extra wasted vertical space.)  (Asked originally at [Stack Overflow](https://stackoverflow.com/questions/54520844/class-level-test-annotation-in-junit-5), and requested privately to raise an issue here)","closed","type: new feature,","jodastephen","2019-02-04T23:18:40Z","2019-06-28T20:49:20Z"
"","1892","Introduce support to add additional info for TestIdentifiers","TestExecutionListener is very useful to write custom reports, trace tests or view test plans. Informations like displayname, test source and legacy report name are already very useful for most situations.  But what if those infos from TestIdentifier are not enough? What if for creating reports etc. more informations are needed (i.e. like ""usecase_ID"", ""authors"" or ""description"") even before execution phase (ReportEntry only works during execution phase)? These infos could be stored in a Map or Map for that purpose.  Therefore it would be useful to introduce mechanics to add additional informations. This would require extensions in a few areas:  Examples: `Map TestIdentifier.getAdditionalInfos()` `Optional TestIdentifier.getAdditionalInfo(String key)`  I can imagine following way to add these infos to TestIdentifier (in Jupiter)  - `@Info(key = ""key"", value = ""value"")` can be used to add additional infos to Class- or MethodTestDescriptors (repeatable annotation) - TestDescriptor needs to be extended to return a Map - `TestIdentifier.from(TestDescriptor descriptor)` needs to be extended to get this info map from TestDescriptor  That way TestIdentifier is more flexible for report creating frameworks (i.e. [Extent Report](http://extentreports.com/)) using not just Jupiter Engine but also custom TestEngine implementations.","closed","status: stale,","performrumpf","2019-05-22T10:07:20Z","2021-06-19T12:50:15Z"
"","1514","Mention containers and tests that were ignored because of their tags","Tagging and filtering works great, but developers could be irritated when their test is not executed (because of a tag) and they don't know why (maybe being new to the code base).  Jupiter could print a message that tests were ignored because their tag was not activated. If these information are easy to gather without performance impact, it could even print some numbers, something like:  ``` 12 classes and 132 methods are tagged with ""integration"" and not executed ```","closed","theme: diagnostics,","nipafx","2018-08-01T11:59:03Z","2020-01-22T15:51:23Z"
"","1219","Introduce support for tag expressions","Tag expressions provide fine grained control over which tests to run, as long as they are tagged. This is based on Boolean expressions.  ## Overview Up until now junit provides two parameters to select tagged tests for execution `-t, --include-tag ` `-T, --exclude-tag  `  `junit -t foo -t bar`  will run all test tagged with `foo OR bar`. There is no way to only run tests that are tagged with `foo AND bar`.  This is now possible by extending the existing parameter to accept tag expressions. The most simple tag expression being just a tag and therefore maintaining backward compatibility.  `junit -t ""foo & bar""` `junit -t ""foo & bar"" -t baz`     `((foo AND bar) OR baz)` `junit -T ""foo & !bar"" -T baz`    `NOT ((foo AND NOT bar) | baz )`  For more details please have a look at the added documentation.  I'll force push required changes to keep this feature within a single commit.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","signed","2017-12-28T23:19:45Z","2018-01-19T19:34:39Z"
"","1891","Error and no ouput when running tests with 5.4.2","Switched to version `5.4.2` from `5.3.2`  ## Steps to reproduce  IntelliJ: Run any tets  `./gradlew cleanTest test`  ## Context   - Used versions (Jupiter/Vintage/Platform): ``` dependencies {     testRuntimeOnly(""org.junit.jupiter:junit-jupiter-engine:5.4.2"") } test {     useJUnitPlatform() } ``` also tried: ``` dependencies {     testRuntimeOnly(""org.junit.platform:junit-platform-launcher:1.4.2"")     testRuntimeOnly(""org.junit.jupiter:junit-jupiter-engine:5.4.2"")     testRuntimeOnly(""org.junit.vintage:junit-vintage-engine:5.4.2"") } test {     useJUnitPlatform() } ```   - Build Tool/IDE: gradle version: `5.4.1` intellij veriosn: `2019.1.2 (Ultimate Edition) Build #IU-191.7141.44`  ## Deliverables gradle output: not test output  IntelliJ output ``` Mai 22, 2019 11:26:39 AM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to execute tests java.lang.NoSuchMethodError: org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(Ljava/lang/String;)Lorg/junit/platform/commons/function/Try; 	at org.junit.jupiter.engine.support.OpenTest4JAndJUnit4AwareThrowableCollector.createAbortedExecutionPredicate(OpenTest4JAndJUnit4AwareThrowableCollector.java:40) 	at org.junit.jupiter.engine.support.OpenTest4JAndJUnit4AwareThrowableCollector.(OpenTest4JAndJUnit4AwareThrowableCollector.java:30) 	at org.junit.jupiter.engine.support.JupiterThrowableCollectorFactory.createThrowableCollector(JupiterThrowableCollectorFactory.java:34) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:68) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ```","closed","","mrt181","2019-05-22T09:36:15Z","2019-05-22T13:34:16Z"
"","1913","Introduce API to select and execute individual tests in inherited nested classes","Such an API is necessary for tools to be able to run individual tests, when such tests are defined in a nested class of a (possibly abstract) super-class of the test class. See:  * https://youtrack.jetbrains.com/issue/IDEA-195373 * https://youtrack.jetbrains.com/issue/IDEA-215440  ## Deliverables  I won't pretend to know how this should be done. Perhaps @akozlova has ideas.","closed","theme: discovery,","chrisvest","2019-06-03T14:03:18Z","2019-10-11T18:41:39Z"
"","1729","Introduce mechanism to stop test run with first failing test","Subject says it all. Would be especially useful for TCR (test && commit || reset) workflow. Feature could be globally configured or switched of from IDE / build tool.  https://github.com/junit-team/junit5/issues/431 is related and https://github.com/pitest/pitest-junit5-plugin/pull/15 might also profit.","closed","status: stale,","jlink","2019-01-12T14:02:24Z","2021-06-19T12:50:14Z"
"","1945","Support fallback parameter resolution extension","Spring Framework would like to be able to resolve parameters from its `ApplicationContext` so that users can easily create tests that inject beans. We'd also like to allow any existing `ParameterResolver` instances to take precedent so that Spring only attempts to resolve parameters that have not been otherwise claimed.  i.e., given something like this:  ```java @ExtendWith(SpringExtension.class) @ExtendWith(MockitoExtension.class) class MyTest {      MyTest(@Mock Customer customer, CustomerService service) {     } } ```  We'd like to allow the `MockitoExtension` to support `customer` and the `SpringExtension` to support `service`.  One option to allow this might be to have a `FallbackParameterResolver` interface which would be used only if no regular `ParameterResolver` supports the parameter.","open","component: Jupiter,","philwebb","2019-07-03T17:27:09Z","2022-06-20T18:21:42Z"
"","1893","Provide a public API for creating a MethodSource with a class name, method name, and a Class[] of parameters","Spock uses AST-Transformations to turn its expressive method names (e.g., ""a nice descriptive test name"") into ""safe"" method names in the bytecode `$spock_feature_1_0`.  Due to the issue with Intellij [IDEA-214779](https://youtrack.jetbrains.com/issue/IDEA-214779) we can't use `MethodSource.from(java.lang.reflect.Method)` but have to use the `org.junit.platform.engine.support.descriptor.MethodSource#from(java.lang.String, java.lang.String, java.lang.String)` variant. Unfortunately, `org.junit.platform.commons.util.ClassUtils#nullSafeToString(java.lang.Class...)` is internal, so we would have to duplicate the implementation.  ## Deliverables  - ❌ Make `org.junit.platform.commons.util.ClassUtils#nullSafeToString(java.lang.Class...)` public and/or - [x] Add `org.junit.platform.engine.support.descriptor.MethodSource#from(java.lang.String, java.lang.String, java.lang.Class...)` with the varargs being the parameter types..","closed","component: Platform,","leonard84","2019-05-23T12:20:57Z","2019-05-23T19:07:25Z"
"","1116","Fix typo to preserve loggers configured by classes in org.junit.jupiter.engine.FullLogging","Sorry for the noise, used old sources.","closed","","akozlova","2017-10-17T13:17:58Z","2017-10-17T13:30:38Z"
"","1842","Provide a way to NOT inherit extensions in nested containers or methods","Sometimes an extension should not be applied to nested containers, e.g. if the extension wants to open and close a resource just once per annotated container. It seems to me that currently any registered extension will also be applied to its children and I couldn't find a way to switch that off.  The workarounds I can think of require strange things like storing the first context object in order to compare the current context object with it. I might be missing something, though.  ## Related Issues  - #506","closed","status: stale,","jlink","2019-04-02T07:29:12Z","2021-06-19T12:50:34Z"
"","1505","Suggestion: rename 'name' attribute to 'value' in @ParameterizedTest","So you can write  `@ParameterizedTest(""Calculate {0}"")`  instead of   `@ParameterizedTest(name = ""Calculate {0}"")`","closed","theme: parameterized tests,","RomanIovlev","2018-07-20T10:31:51Z","2018-07-20T14:30:18Z"
"","1504","Suggestion: Move @DisplayName to attribute in @Test","so I can write  ```java @Test(""Awesome tests"") ```  instead of   ```java @Test @DisplayName(""Awesome tests"") ```","closed","component: Jupiter,","RomanIovlev","2018-07-20T10:30:06Z","2018-08-13T11:08:47Z"
"","1752","Reduce scope and surface area of TempDirectory extension","Since there are currently multiple issues (e.g. #864 and #1672) that might change how extensions that provide resources are written and registered, we should hide the implementation of `@TempDir` so we can easily change it in a future release.  ## Deliverables  - [x] Remove support for custom file systems, i.e. remove `ParentDirProvider` and `TempDirContext`. - [x] Make `@TempDir` a top-level type. - [x] Move appropriate Javadoc from `TempDirectory` to `@TempDir`. - [x] Move `TempDirectory` to `junit-jupiter-engine` and make it package-private. - [x] Register `TempDirectory` as a default extension. - [x] Update existing documentation in User Guide. - [x] Document breaking changes in Release Notes.","closed","component: Jupiter,","marcphilipp","2019-01-27T15:05:36Z","2019-01-28T14:46:43Z"
"","1079","Re-run failed tests immediately","Since rules are not supported anymore, is there a way to re-run failed tests immediately using extension model?","closed","","roman-ponomarenko","2017-09-28T09:41:58Z","2018-09-04T18:14:35Z"
"","1820","Report intermediate containers finished lazily","Since JUnit 4 does report events for intermediate containers, the Vintage engine has to synthesize them. Until now this was done lazily for start events, i.e. when the first child was started, but eagerly for finish events, i.e. when the last static child of a container was finished. However, the latter approach is problematic for containers that contain both static and dynamic children, for example a Spock specification with a regular and an unrolled feature method. Instead, intermediate containers are now reported as finished as soon as a test is started for which the container is not an ancestor.  Fixes #1819.","closed","component: Vintage,","marcphilipp","2019-03-16T17:27:50Z","2019-03-16T20:17:24Z"
"","1735","Task aggregateJavadocs is broken","Since building with OpenJDK 11.0.2 the `aggregateJavadocs` is broken: `javadoc: error - The code being documented uses modules but the packages defined in https://docs.oracle.com/javase/8/docs/api/ are in the unnamed module.`  Log: https://travis-ci.org/junit-team/junit5/jobs/480465467#L688   ## Deliverables  - [x] Fix javadoc aggregation task","closed","theme: documentation,","sormuras","2019-01-16T17:03:49Z","2019-03-29T08:02:39Z"
"","1873","[Cleanup] Simplify use of if(Optional.isPresent()) using functional style","Simple cleanup.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","","ielatif","2019-05-10T23:49:24Z","2019-05-11T17:23:06Z"
"","1794","Introduce generic @FileSource for @ParameterizedTest","Similar to the existing `@CsvFileSource` used for `@ParameterizedTest` I would be looking to get access to the raw content of a file, or collection of files in a directory (based on file filters, etc) from one or more classpath resources via a proposed annotation like `@FileSource`.  This would allow a user to also apply custom converters to the retrieved files to convert them to domain specific models if needed.  To elaborate, suppose you have the following files in `src/test/resources`:  `01.json` containing JSON content:  ```json { ""name"": ""John Doe"", ""age"": 30 } ```  `02.yml` containing YAML content:  ``` name: John Doe age: 30 ```  If I just want to test based on the raw strings of the file based inputs, I would do something like the following:  ```java public class ParameterizedFileSource {      @ParameterizedTest      // or also @FileSource(directory = ""/"") to read all files in directory      @FileSource(files = [""01.json"", ""02.yml""])      public void test(List files) {          assertThat(files.size()).isEqualTo(2);  // etc...      } } ```  However if I had some class `Person` for which the file represents, and some deserialization logic for it, I would like to have direct access to those objects as inputs to the tests:  ```java public class ObjectFixtureTests {      @ParameterizedTest      @FileSource(directory = ""/"")      public void test(@ConvertWith(PersonConverter.class) Person person) {           assertThat(person.name()).isEqualTo(""John Doe""); //etc      } } ```  ## Deliverables  - [ ] Functionality for new `@FileSource` annotation (with similar context to `@CsvFileSource`) - [ ] Documentation on usage for new `@FileSource` annotation, with examples with/without converters - [ ] Tests for the `@FileSource` annotation (with/without using converters as well)","open","type: new feature,","dotCipher","2019-02-26T21:48:45Z","2022-08-01T12:27:10Z"
"","1388","Upgrade to JRuby 9.1.17.0","See release notes at http://jruby.org/2018/04/23/jruby-9-1-17-0  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","hutaidavid","2018-04-24T11:50:39Z","2018-05-03T15:28:24Z"
"","1775","Extension Point Request: ability to catch a test outcome and fail a test","See https://gitter.im/junit-team/junit5?at=5c659880ef98455ea4364c08 for details.  Right now it's possible to catch a test failure in `handleTestExecutionException()`  and swallow it. But the other way around is not possible: it seems it's not possible to catch a test, perform some checks and decide to fail the test under some conditions.  I used to implement this in a JUnit4 RunListener and I tried to implement it in JUnit5 TestExecutionListener but I was told it's not the right way.  FTR here's my try:  ```    @Override     public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult)     { ...             throw new AssertionError(""There should be no content output to the console by the test! Instead we got ["" + outputContent + ""]""); ...         } ```  However this leads to the following test output:  ``` Test ignored.  java.lang.AssertionError: There should be no content output to the console by the test! Instead we got [...] ```  Notice the ""Test ignored"".","closed","type: new feature,","vmassol","2019-02-14T16:44:56Z","2020-05-22T19:56:14Z"
"","1917","Improve documentation for execution mode configuration parameters","See discussion in https://github.com/junit-team/junit5/pull/1910#discussion_r289649137  ## Deliverables  - [x] Add chart/ascii art illustrations for all combinations","closed","component: Jupiter,","marcphilipp","2019-06-05T17:51:25Z","2019-06-29T10:19:27Z"
"","1601","junit5 user guide - typo in one annotation - section 3.7.1","section 3.7.1 of userguide:  is:  ``` @TestOnMac void testOnMac() { ```  should be  ``` @Test void testOnMac() { ```  see here: https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution","closed","","tomekkaczanowski","2018-09-25T16:00:29Z","2018-09-25T16:26:41Z"
"","1449","Surefire provider truncates stacktraces","Running tests in JUnit 4, I get for each test error/failure the whole stack trace shown. Using `junit-platform-surefire-provider` there is a truncated stacktrace, as far I can see, it shows only the part of stacktrace happening in the test class itself.  Found same issue here: https://stackoverflow.com/questions/47282983/junit-5-truncates-stacktraces-and-crash-jvm-in-debug-mode but sadly with no satisfying answer.  Since this seems to be a feature, not a bug, is there a way to configure surefire plugin to show whole stacktraces?","closed","3rd-party: Maven Surefire,","mibutec","2018-06-05T11:29:53Z","2018-06-06T08:44:19Z"
"","1680","Catch up on JUnit 4 Runner support for custom ClassLoaders","Runners in JUnit 4 were a great way to control the test environment and instance from user land (without writing an engine).  It would be great if JUnit Jupiter would allow one to do the same.  The main challenge is controlling the test instance redefining a custom `@Test`.","closed","component: Jupiter,","rmannibucau","2018-11-15T09:50:06Z","2018-11-25T13:46:00Z"
"","1159","Build Failed: Host name 'repo1.maven.org' does not match the certificate subject","Run `./gradlew clean assemble` and get:  ``` * Where: Build file '/Users/path/to/junit5/build.gradle' line: 111  * What went wrong: A problem occurred evaluating root project 'junit5'. > Could not resolve all files for configuration 'classpath'.    > Could not resolve de.schauderhaft.degraph:degraph-check:0.1.4.      Required by:          unspecified:unspecified:unspecified       > Could not resolve de.schauderhaft.degraph:degraph-check:0.1.4.          > Could not get resource 'https://repo1.maven.org/maven2/de/schauderhaft/degraph/degraph-check/0.1.4/degraph-check-0.1.4.pom'.             > Could not GET 'https://repo1.maven.org/maven2/de/schauderhaft/degraph/degraph-check/0.1.4/degraph-check-0.1.4.pom'.                > Host name 'repo1.maven.org' does not match the certificate subject provided by the peer (CN=repo.maven.apache.org, O=""Sonatype, Inc"", L=Fulton, ST=MD, C=US)  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.  * Get more help at https://help.gradle.org  BUILD FAILED in 51s ```  My `gradle -version`:  ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/usr/local/Cellar/gradle/4.3.1/libexec/lib/groovy-all-2.4.12.jar) to method java.lang.Object.finalize() WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release  ------------------------------------------------------------ Gradle 4.3.1 ------------------------------------------------------------  Build time:   2017-11-08 08:59:45 UTC Revision:     e4f4804807ef7c2829da51877861ff06e07e006d  Groovy:       2.4.12 Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015 JVM:          9.0.1 (Oracle Corporation 9.0.1+11) OS:           Mac OS X 10.12.6 x86_64 ```  My `mvn -version`:  ``` Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T00:58:13-07:00) Maven home: /usr/local/Cellar/maven/3.5.2/libexec Java version: 9.0.1, vendor: Oracle Corporation Java home: /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home Default locale: en_US, platform encoding: UTF-8 OS name: ""mac os x"", version: ""10.12.6"", arch: ""x86_64"", family: ""mac"" ```","closed","status: works-as-designed,","boldcat2015","2017-11-13T19:15:36Z","2017-11-13T19:43:24Z"
"","1843","Need a global extension that run once in test lifecycle","Right now there is no extension that can be used to run once in the lifecycle of test execution like IExecutionListner in testng which can used to configure or prepare test environment   There should be @GlobalBeforeAllCallback that runs before all and once in test lifecycle","closed","","kamit78","2019-04-03T06:26:51Z","2019-04-03T11:02:04Z"
"","979","Return only visible default methods","Return only visible default methods  Addresses #978  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","theme: discovery,","sormuras","2017-07-24T15:44:58Z","2017-07-24T20:00:59Z"
"","1249","The 5.0.3 Revisions Having Issues In Repo","Result of running: mvn help:effective-pom (ran several times after rm-rf ~/.m2/repository and repopulated):  [INFO] Scanning for projects... [WARNING] Failed to retrieve plugin descriptor for org.junit.jupiter:junit-jupiter-api:5.0.3: Failed to parse plugin descriptor for org.junit.jupiter:junit-jupiter-api:5.0.3 (/Users/ssanbeg/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.0.3/junit-jupiter-api-5.0.3.jar): No plugin descriptor found at META-INF/maven/plugin.xml  [WARNING] Failed to retrieve plugin descriptor for org.junit.jupiter:junit-jupiter-engine:5.0.3: Failed to parse plugin descriptor for org.junit.jupiter:junit-jupiter-engine:5.0.3 (/Users/ssanbeg/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.0.3/junit-jupiter-engine-5.0.3.jar): No plugin descriptor found at META-INF/maven/plugin.xml  [WARNING] Failed to retrieve plugin descriptor for org.junit.platform:junit-platform-launcher:1.0.3: Failed to parse plugin descriptor for org.junit.platform:junit-platform-launcher:1.0.3 (/Users/ssanbeg/.m2/repository/org/junit/platform/junit-platform-launcher/1.0.3/junit-platform-launcher-1.0.3.jar): No plugin descriptor found at META-INF/maven/plugin.xml  [WARNING] Failed to retrieve plugin descriptor for org.junit.platform:junit-platform-runner:1.0.3: Failed to parse plugin descriptor for org.junit.platform:junit-platform-runner:1.0.3 (/Users/ssanbeg/.m2/repository/org/junit/platform/junit-platform-runner/1.0.3/junit-platform-runner-1.0.3.jar): No plugin descriptor found at META-INF/maven/plugin.xml  [WARNING] Failed to retrieve plugin descriptor for org.junit.vintage:junit-vintage-engine:4.12.3: Failed to parse plugin descriptor for org.junit.vintage:junit-vintage-engine:4.12.3 (/Users/ssanbeg/.m2/repository/org/junit/vintage/junit-vintage-engine/4.12.3/junit-vintage-engine-4.12.3.jar): No plugin descriptor found at META-INF/maven/plugin.xml","closed","status: invalid,","ghost","2018-01-18T21:56:27Z","2018-01-19T12:59:40Z"
"","1475","Use simple class name as display name in JUnit Vintage","Resolves Issue: #970  ## Overview  The changes involve the default display name of JUnit Vintage test classes. It was different from the Jupiter tests because it was the FQCN. This pull request makes the display names the same, and it fixes the tests that failed upon change.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Vintage,","Andrei94","2018-06-23T17:00:26Z","2019-01-07T13:25:42Z"
"","1922","add ClassFileMethodOrderer","Resolves #1919.  ## Overview  Add a `ClassFileMethodOrderer` that orders test methods according to the order in the class file (which is the same as the order in the source file)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) - [ ] Change is documented in the [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","t1","2019-06-07T12:48:28Z","2021-04-23T10:28:28Z"
"","1726","Ensure TempDirectory can return a File","Resolves #1725.","closed","component: Jupiter,","rmannibucau","2019-01-11T09:17:45Z","2019-01-16T16:46:52Z"
"","1650","Introduce ExtensionContext.getTestInstances() API","Resolves #1618.","closed","type: new feature,","marcphilipp","2018-10-26T07:10:57Z","2018-12-23T16:31:54Z"
"","1131","Ensure stackTraceWriter is always present","Resolves #1130  ## Overview  Maven surefire always assume that a `stackTraceWriter` is present, however `RunListenerAdapter` only provides a value when the `TestIdentifier` has a `ClassSource` or `MethodSource`. To fix this, we traverse the whole test hierarchy to find the appropriate `TestIdentifier`.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","raniejade","2017-10-30T09:55:45Z","2017-11-05T17:33:58Z"
"","1230","Allow executing dynamic tests/test template invocations by unique ID","Resolves #1025.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","marcphilipp","2018-01-06T19:16:57Z","2018-01-14T15:53:29Z"
"","1177","Publish dependencies and plugins to Gradle repo","Repo: maven { url ""https://plugins.gradle.org/m2/"" }  Docs: https://plugins.gradle.org/docs/publish-plugin","closed","","jaredsburrows","2017-11-22T00:20:48Z","2017-11-22T00:29:28Z"
"","1090","Display name for @ParameterizedTest should only include consumed arguments","Redundant arguments are filtered out in `ParameterizedTestExtension`, so only consumed arguments are passed to invocation context and used in name formatter. Filtering is applied only when number of arguments is greater than number of test method parameters. It should work with other extensions like parameter resolvers - when there are eg. 3 columns provided and only 2 test method parameters consumes them and the 3rd one is resolved by another extension, then exception about incorrect configuration will be thrown.  Please notice that some unchanged code in `ParameterizedTestIntegrationTests.java` is reformatted. I used formatter from `junit5/src/eclipse` and assume it was formatted incorrectly before. If it was correct, please let me know and I'll revert those changes.","closed","","karollewandowski","2017-10-03T19:05:47Z","2017-11-05T17:32:38Z"
"","1455","Improve exception message for non-static ArgumentsProvider","Raised in response to #1452.  ```java     class PluginProvider implements ArgumentsProvider {          @Override         public Stream provideArguments( ExtensionContext context ) {             return Stream.of(                     Collections.singletonList( XenoJavaLibPlugin.class ),                     Arrays.asList( JavaLibraryPlugin.class, XenoCodeQualityPlugin.class )             ).map( Arguments::of );         }     } ```  the exception I get is   ``` java.lang.NoSuchMethodException: com.xenoterracide.gradle.plugin.XenoPluginTest$PluginProvider.()  	at java.lang.Class.getConstructor0(Class.java:3082) 	at java.lang.Class.getDeclaredConstructor(Class.java:2178) 	at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:404) 	at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$1(ParameterizedTestExtension.java:70) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) ```  This is very opaque as to what the problem actually is.","closed","component: Jupiter,","xenoterracide","2018-06-06T14:42:01Z","2018-08-31T12:25:33Z"
"","1529","Make TreeNode thread-safe","Prior to this commit, both `add` methods in `TreeNode` had race conditions when children or report entries were added concurrently because adding to an `ArrayList` from multiple threads is documented to be unsafe. Now, both methods are synchronized.  Fixes #1524.","closed","component: Jupiter,","marcphilipp","2018-08-07T19:12:35Z","2018-08-09T07:21:45Z"
"","1709","Test being executed twice","Pom.xml ```           org.junit.platform     junit-platform-commons     1.3.2     test                org.junit.jupiter         junit-jupiter-api         5.3.2         test                         org.junit.jupiter         junit-jupiter-engine         5.3.2         test           ```  2) Test  ``` import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.assertTrue;  public class StandartTest { @Test public void succeedingTest() { System.out.println(""test started""); assertTrue(4==4); System.out.println(""test finished""); } } ```  Console output  ``` -------------------------------------------------------  T E S T S ------------------------------------------------------- Running StandardTest Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.002 sec Running StandartTest Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec  Results :  Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```","closed","component: Jupiter,","mopsafe","2018-12-23T13:49:55Z","2018-12-23T13:54:12Z"
"","1860","while executing the junit4 test in junit5(In migration process) some of the tests are executed bot not showing the output in console.","Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior). Junit version : 5.4.1 surefire plugin verions : 2.22.1 Jupiter version 5.4.1 Vintage version 5.4.1 surefire provider version: 1.3.2  ## Steps to reproduce During a migration process from junit 4 to junit 5, we have modified the pom.xml file.  and trying to run the tests, tests are running twice initially all the test are running in junit4 no display issues, but same tests running as well in junit5 but not getting all the tests execution dispaly on console.  Along with this facing powermock issues  also.  It will be more helpful for me if you provide me the very quick solution.  Please insert a code snippet or a link to another repo along with instructions how to reproduce the issue here. The example should be minimal, complete and verifiable (see https://stackoverflow.com/help/mcve).  ## Context  surefire plugin verions : 2.22.1 Jupiter version 5.4.1 Vintage version 5.4.1 surefire provider version: 1.3.2  Eclipse IDE Oxygen   - Used versions (Jupiter/Vintage/Platform):  - Build Tool/IDE:  ## Deliverables  - [ ] ...","closed","3rd-party: Maven Surefire,","Naresh-Shekkari","2019-04-12T11:07:01Z","2019-07-19T10:15:56Z"
"","1671","SNAPSHOT javadocs are missing ""framed"" version","Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  ## Steps to reproduce  1.  Browse to https://junit.org/junit5/docs/current/api/index.html?overview-summary.html and you'll     have the option to select ""Frames"" or ""No Frames"".  Note that this site comes up in the ""Frames""     mode by default. 2.  Browse to https://junit.org/junit5/docs/snapshot/api/index.html?overview-summary.html and the     sub-menu bar is completely missing.  Note that this site comes up in the ""No Frames mode by     default.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.3.x versus 5.4.x-SNAPSHOT  - Build Tool/IDE: N/A  ## Deliverables  - [ ] Make the SNAPSHOT javadocs format the same as the production/stable version.","closed","theme: documentation,","smoyer64","2018-11-08T20:31:24Z","2018-11-23T11:33:36Z"
"","1609","Introduce IndicativeSentences display name generator","Overview ---  Issue: #1596  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","olcbean","2018-09-29T10:22:57Z","2019-08-05T13:54:18Z"
"","1818","ci: only publish on success","Only run the publish steps when the build was successful, per https://github.com/junit-team/junit5/issues/1810#issuecomment-473516522.  Note that since the publish dependencies _only_ depend on the `linux_11` build, it's possible to publish even if the macOS (for instance) build fails.  I'm happy to tweak this if requested.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","ethomson","2019-03-16T10:38:58Z","2019-03-16T17:02:26Z"
"","1851","Support assertThrows() with suspending functions in Kotlin","Often when I write a unit test that has to assert that a certain exception is thrown I use the `assertThrows()` method. But I find myself regularly having to test suspending functions, so I have to wrap my function with a `runBlocking()`. This is a lot of repeating code if your entire codebase is heavily based on coroutines.   ### Proposed fix  I couldn't possibly have made this issue without also thinking about a solution.  Effectively, this is what I came up with:  ```kotlin private inline fun  assertThrows(         noinline executable: suspend () -> Unit     ) = assertThrows(T::class.java) {         runBlocking {             executable()         }     } ```  This way you can pass suspending functions as parameter `executable`, which will be invoked in a `runBlocking()` to make sure the suspending function joins before continuing.  ### tl;dr  I think it would be a good addition to JUnit Jupiter to have functions that allow easy testing of suspending functions.","closed","component: Kotlin,","DerkSchooltink","2019-04-08T15:37:41Z","2021-07-27T11:13:55Z"
"","1317","Deprecate JUnit Platform Gradle Plugin","Now that Gradle 4.6 has been released and provides native support for running tests on the JUnit Platform, we can go ahead and deprecate our custom plugin.  ## Deliverables  - [x] Emit deprecation warning when `junitPlatform` task is executed - [x] Deprecate all code in `junit-platform-gradle-plugin` subproject - [x] Add note to 5.1 User Guide and link to Gradle documentation - [x] Remove documentation for custom plugin from future 5.2 User Guide - [x] Document most frequent use cases of native `test` task in User Guide (e.g. how to use config params) - [x] Create follow-up task to delete subproject for 5.3 M1","closed","3rd-party: Gradle,","marcphilipp","2018-03-02T17:57:01Z","2018-03-17T10:16:25Z"
"","1512","Migrate to ClassGraph (formerly FastClasspathScanner) 4.0","Not ready to merge (final 4.0.0 release not yet available).  Followed migration guide at: https://github.com/classgraph/classgraph/wiki/Porting-FastClasspathScanner-code-to-ClassGraph  Just to provide some feedback for classgraph/classgraph#215.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---","closed","theme: build,","PascalSchumacher","2018-07-29T12:05:07Z","2018-08-03T16:25:38Z"
"","1713","New line characters in (dynamic) display names","New line characters may disrupt layout of the tree-based test plan rendering:  ``` [INFO] Launching JUnit Platform 1.4.0-M1... [INFO] . [INFO] '-- JUnit Jupiter [OK] [INFO]   +-- LayoutTests [OK] [INFO]   | +-- readModuleName() [OK] [INFO]   | | +-- module a { [OK] [INFO]   | | +-- open module a{ [OK] [INFO]   | | '-- what ever  [INFO]  prefix module    a    [INFO] { [OK] [INFO]   | '-- checkMavenProjects() [OK] ... ```  Other [ASCII control characters](https://en.wikipedia.org/wiki/Control_character) may even produce side-effects or more severe issues.  Should the tree renderer replace those control characters before emitting them?  What about other display name emitters, like reporting?","closed","component: Platform,","sormuras","2018-12-28T07:55:25Z","2019-01-21T18:17:32Z"
"","1884","Add ability to access the current repetition of a RepeatedTest from afterEach in a custom Extension","My use case:  * At the end of each test, save a video of the test in a file. * It has to support the `@RepeatedTest` annotation and thus the computed file name must include the repetition index.  It seems the info is in RepeatedTestInvocationContext but there are 2 issues:  1. I don't know how to get access to that object in my afterEach, i.e. from an ExtensionContext. I guess I could use instanceof on the parent but it seems it's a TestTemplateExtensionContext so it wouldn't even work (and it feels hacky ;)) 2. Even if I were able to get access to RepeatedTestInvocationContext it doesn't contain any API to get the current repetition. The only thing it offers is a custom displayName but having to parse that to get the repetition index doesn't feel right.  ## Related Issues  - #944 - #1139 - #1668","closed","status: stale,","vmassol","2019-05-17T12:12:10Z","2021-06-19T12:50:34Z"
"","1733","[Event] Add Jfocus 2019 talk","My talk ""Spock vs JUnit 5 - Clash of the Titans"" at Jfocus: https://www.jfokus.se/jfokus19/talks/2481","closed","","szpak","2019-01-14T19:20:00Z","2019-03-23T10:46:50Z"
"","1831","[Event] Add talk at Greach 2019","My talk ""Spock vs JUnit 5 - Clash of the Titans"" at [Greach](https://agenda.greachconf.com/talk/spock-vs-junit5-clash-of-the-titans).","closed","","szpak","2019-03-23T10:45:42Z","2019-03-23T10:58:26Z"
"","1502","Support class references for factory methods in @MethodSource","My request related to implemented feature #1088 for `@MethodSource`.  Can we also implement case 2?  Reason: sometimes full path is too long and most important part, the method name become not obvious.  Example:  ```java @MethodSource(""com.company.area.subarea.undere.some.package.services.dataProviders.ComplexDataProvider#rule1"") @MethodSource(""com.company.area.subarea.undere.some.package.services.dataProviders.ComplexDataProvider#rule2"") @MethodSource(""com.company.area.subarea.undere.some.package.services.dataProviders.ComplexDataProvider#rule3"") ```  vs  ```java @MethodSource(value = ""rule1"", source = ComplexDataProvider.class) @MethodSource(value = ""rule2"", source = ComplexDataProvider.class) @MethodSource(value = ""rule3"", source = ComplexDataProvider.class) ```  And `Class` is more stable than `String` during refactoring.  If you agree I can do pull request.  P.S. In any case this is just an additional way and if you want you can use current approach.","closed","theme: parameterized tests,","RomanIovlev","2018-07-20T08:38:07Z","2018-07-20T15:39:56Z"
"","1870","Allow to define parameter source per method argument.","My parametrized test needs to accept two arguments.  ```java void testMethod(Charset charset, Integer number) { } ``` I would like to execute above test for let's say charsets (UTF_8, ISO_8859_1) and 0, 1, 2, 10, 200. Right now the only option is to use ArgumentsSource or MethodSource and write by hand the Cartesian product code.  ## Deliverables  Instead we can provide a possibility to define test like this: ```java void testMethod(@ArgumentSource Charset charset, @NullSource @ValueSource Integer number){ } ``` It looks for me it as a very natural use case of the test parameters. Currently ```@Source``` annotations cannot be defined over parameters.","closed","theme: parameterized tests,","mielecmichal","2019-05-05T22:15:37Z","2019-05-13T12:57:30Z"
"","1720","Use Deptective to ensure module-internal constraints","Move cyclic dependency checks from very late in the game integration tests to early compile time checks using https://github.com/moditect/deptective","closed","theme: build,","sormuras","2019-01-07T10:28:05Z","2019-04-20T06:22:39Z"
"","1821","Introduce test report checkpoint support","Motivation: https://github.com/junit-team/junit5/pull/1768#issuecomment-473538214  Using a proof-of-concept implementation... ![image](https://user-images.githubusercontent.com/2319838/54489542-a2d63480-48ad-11e9-80fa-fb0aabe5aff3.png)  ...yields ![image](https://user-images.githubusercontent.com/2319838/54489559-cd27f200-48ad-11e9-85eb-a28218821a97.png)  ## Related Issues  - #703  - #1515","closed","status: stale,","sormuras","2019-03-17T11:12:35Z","2022-07-11T20:21:29Z"
"","1909","Improve error reporting for exceptions thrown by test engines","Mixed versions on the classpath often cause test discovery or execution to fail. Currently, the Launcher only logs an error message in such cases which is easy to miss. Instead, it should report it as a failed test descriptor so that the IDE or build tool can handle and report it like a failed test.  ## Deliverables  - [x] Report exceptions thrown by test engines by reporting the engine descriptor as failed when executed.","closed","component: Platform,","marcphilipp","2019-06-01T10:28:57Z","2019-09-23T11:04:51Z"
"","1220","ClasspathScanner loads all classes causing class visibility side effects","Migrating my Tests from JUnit 4 got stuck because my productive code (not test code) contains a class that MUST be loaded with the system/bootstrap class loader (the code is quite complex).  JUnit Jupiter seems to scan all classes and loads them with the current classloader. The latter is a problem for me, because an already loaded class shadows the one which is loaded later on (in the test) by the system classloader (meaning that the test operates on a different class than the rest of the program).  Maybe it would be better to do classpath scanning in a separate classloader (and reload only those classes that were qualified by the scanner).  If you are interested in an example I will prepare a branch in my github project to contain only the classes that provoke this error.","closed","status: stale,","almondtools","2017-12-29T17:24:26Z","2021-06-19T12:50:14Z"
"","1805","MethodOrderer.Random should print seed if none is configured to allow reproducibility","MethodOrderer.Random is using `System.nanoTime()` as a seed to generate a random order. There is also a configuration property to allow reproducability by providing seed. It might be hard to determine the value of `System.nanoTime()` after execution, when there is no seed configured. Hence that it would be beneficiary to print the seed to the log with a message like `Using 'System.nanoTime()' as seed for ordering with value [%s].`.  Additionally the seed is right now computed for each test class, which makes it also hard to reproduce multiple tests at once. So the seed generation should be handled during the static initialization of `MethodOrderer.Random` so each test is utilizing the same seed.  Based on the current implementation i would suggest to use ""logger.config"" as it is also used if a seed is configured via property. like: ``` logger.config(() -> String.format(""Using 'System.nanoTime()' as seed for ordering with value [%s]."", seed));  ```  Sidenote: Initially suggested by @nicolaiparlog during his live exploration of junit5 parallel execution.  ## Deliverables  - [x] Log if random seed is generated via System.nanoTime() - [x] provide a configuration parameter to swap default execution mode for `MethodOrderer.Random` - [x] Appropriate test cases for changes","closed","theme: diagnostics,","aepfli","2019-03-09T19:14:47Z","2019-06-25T06:39:45Z"
"","1301","Upgrade AssertJ to 3.9.1","Main feature: Cglib was replaced with Byte-Buddy.  See http://joel-costigliola.github.io/assertj/assertj-core-news.html#assertj-core-3.9.1 for details.  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: modules,","PascalSchumacher","2018-02-21T23:08:05Z","2018-02-25T09:12:23Z"
"","1546","Kotlin extension function ArgumentsAccessor.getAs cannot be imported","Looks like https://github.com/junit-team/junit5/issues/1490 still doesn't work:  ``` import org.junit.jupiter.params.aggregator.getAs ``` results in: ``` e: C:\testcase\src\test\kotlin\de\test\MyTest.kt: (7, 44): Unresolved reference: getAs ```  A testcase is attached. [testcase.zip](https://github.com/junit-team/junit5/files/2287420/testcase.zip)","closed","theme: parameterized tests,","juergenzimmermann","2018-08-14T14:56:09Z","2018-08-15T08:49:35Z"
"","1948","Introduce @TestClassOrder for ordering test classes in JUnit Jupiter","Like `@TestMethodOrder`, could you please introduce a `@TestClassOrder` annotation to define the execution order of test classes?","closed","type: new feature,","jflefebvre06","2019-07-04T08:11:48Z","2021-01-28T17:42:48Z"
"","1716","Add JsonFileSource and YmlFileSource as params provider.","Just like the CsvFileSource, having JsonFilleSource and YmlFileSource would help developers load test data and configuration from respective file formats.","closed","","sanjuthomas","2018-12-31T00:23:57Z","2018-12-31T00:46:15Z"
"","970","Default display name for test class is generated differently for Vintage and Jupiter","Jupiter's `ClassTestDescriptor` provides short class name as display names; whereas, Vintage's `RunnerTestDescriptor` provides fully qualified class names.  Is there any rationale behind this?  Looks suspicious in the UI,  and I hesitate if I should explicitly change the display names so they look pretty.   Screenshot of current IDEA version with mixed Vintage/Jupiter tests: ![image](https://user-images.githubusercontent.com/4306070/28464282-c06702be-6e24-11e7-933a-2d20b0f1a47b.png)","closed","component: Vintage,","akozlova","2017-07-21T12:56:40Z","2018-06-27T19:43:37Z"
"","1121","ant noframe report extra test for ParameterizedTest","Junit5 version: 1.0.1 Test class: @RunWith(JUnitPlatform.class) public class Junit5SampleUnitTests {     @DisplayName(""Parameterized positive tests"")     @ParameterizedTest     @ValueSource(strings = {""aba"", ""cbggbc""})     public void testPositivePalindromes(String argument)     {         assertTrue(isPalindrome(argument));     }    private boolean isPalindrome(String testString)     {...} } Command: ant test  Ant config:                                                 Expected: two tests are reported  Actual: Three tests are reported in TESTS-TestSuites.xml:","closed","component: Platform,","henryzhang1","2017-10-19T23:19:59Z","2017-10-29T16:07:24Z"
"","1551","@ParameterizedTest using @CsvFileSource does not allow trailing whitespace in last argument","JUnit version: 5.2.0  When I create a test that uses a CSV file and the last argument has whitespace to the right, the method's parameter gets a value without the whitespace.","closed","theme: parameterized tests,","juniorjrjl","2018-08-17T15:45:59Z","2018-08-23T14:28:24Z"
"","1793","Support repeatable annotations for built-in conditions","Junit should support multiple condition annotations on classes and tests. One use case for this is a test that should not run in two situations: the first is that it should never run in the CI environment (CI=true), and the second is if a dev sets another environment variable (SKIP_X=true). One approach is to use the `@DisabledIfEnvironmentVariable` twice.  The only solution currently is to do `@DisabledIfEnvironmentVariable(named = ""SKIP_X"", matches = ""true"")`, and then set `SKIP_X` in the CI environment. However, with this approach we lose some self-documentation -- the explicit `CI=true` check documents the fact that this test doesn't run currently in the CI environment, but may in the future, and is an easy way to find all such cases. It is also far less maintainable, as each such case requires modifying the CI configuration settings.  ## Deliverables  - [x] Support multiple condition annotations on classes and tests","closed","component: Jupiter,","rocketraman","2019-02-24T08:32:25Z","2019-11-10T15:37:32Z"
"","1755","Add ""Support the Development of JUnit"" message","JUnit is maintained by a team of passionate volunteers. Let our users know how to take a chance to give back and support the project -- besides contributing here at GitHub.  Such a message could read as simple as and point to https://steadyhq.com/junit ``` Thanks for using JUnit 5 -- support its development at https://steadyhq.com/junit ```  Gradle does something similar: https://travis-ci.org/junit-team/junit5/jobs/485515552#L463-L469  ## Deliverables  - [x] Decide if we want it - [x] Decide where we want the message to be emitted - [x] For example, the JUnit Platform `ConsoleLauncher` could print such a message - [x] Decide when and how often the message is displayed: once per version, on each run, after failures are detected...","closed","component: Platform,","sormuras","2019-01-29T09:41:30Z","2019-01-31T19:52:39Z"
"","1865","Executing pretty small number of dynamic tests (with ""large"" Executable) results in OutOfMemoryError","JUnit 5.4.1 (Jupiter)  ## Steps to reproduce  Run the following test:  ```java import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.DynamicTest; import org.junit.jupiter.api.TestFactory; import org.junit.jupiter.api.parallel.Execution; import org.junit.jupiter.api.parallel.ExecutionMode;  import java.util.concurrent.ThreadLocalRandom; import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.Stream;  @Execution(ExecutionMode.SAME_THREAD) class FatExecutablesLeadToOutOfMemoryErrorTest {      private static final int ONE_MB = 1024 * 1024;     private static final int TEN_MB = 10 * ONE_MB;     private static final AtomicInteger testCounter = new AtomicInteger(0);      @TestFactory     Stream demoTest() {         int desiredArraySize = TEN_MB;         return Stream.generate(() -> createByteArray(desiredArraySize))                 .map(bytes ->                         DynamicTest.dynamicTest(                                 ""Test "" + testCounter.incrementAndGet(),                                 () -> Assertions.assertEquals(bytes.length, desiredArraySize)                         )                 )                 .limit(10000L);     }      private static byte[] createByteArray(int size) {         byte[] array = new byte[size];         ThreadLocalRandom.current().nextBytes(array);         return array;     } } ``` with e.g. `-Xmx=256m`  After around 22 ""DynamicTest"" instances you get  ``` java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid16732.hprof ... Heap dump file created [235907219 bytes in 0.095 secs] Apr 16, 2019 4:09:54 PM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNUNG: TestEngine with ID 'junit-jupiter' failed to execute tests org.junit.platform.commons.JUnitException: Error executing tests for engine junit-jupiter 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.util.concurrent.ExecutionException: java.lang.OutOfMemoryError 	at java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:1006) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	... 9 more Caused by: java.lang.OutOfMemoryError 	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) 	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) 	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) 	at java.lang.reflect.Constructor.newInstance(Constructor.java:423) 	at java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:598) 	at java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:1005) 	... 10 more Caused by: java.lang.OutOfMemoryError: Java heap space 	at FatExecutablesLeadToOutOfMemoryErrorTest.createByteArray(FatExecutablesLeadToOutOfMemoryErrorTest.java:32) 	at FatExecutablesLeadToOutOfMemoryErrorTest.lambda$demoTest$0(FatExecutablesLeadToOutOfMemoryErrorTest.java:21) 	at FatExecutablesLeadToOutOfMemoryErrorTest$$Lambda$217/1223463362.get(Unknown Source) 	at java.util.stream.StreamSpliterators$InfiniteSupplyingSpliterator$OfRef.tryAdvance(StreamSpliterators.java:1356) 	at java.util.stream.StreamSpliterators$WrappingSpliterator.lambda$initPartialTraversalState$0(StreamSpliterators.java:294) 	at java.util.stream.StreamSpliterators$WrappingSpliterator$$Lambda$197/89358177.getAsBoolean(Unknown Source) 	at java.util.stream.StreamSpliterators$AbstractWrappingSpliterator.fillBuffer(StreamSpliterators.java:206) 	at java.util.stream.StreamSpliterators$AbstractWrappingSpliterator.doAdvance(StreamSpliterators.java:169) 	at java.util.stream.StreamSpliterators$WrappingSpliterator.tryAdvance(StreamSpliterators.java:300) 	at java.util.Spliterators$1Adapter.hasNext(Spliterators.java:681) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.lambda$invokeTestMethod$1(TestFactoryTestDescriptor.java:97) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor$$Lambda$215/1220005704.execute(Unknown Source) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.invokeTestMethod(TestFactoryTestDescriptor.java:88) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:127) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$158/545351516.execute(Unknown Source) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$157/1020432366.invoke(Unknown Source) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$156/183820972.execute(Unknown Source) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171) 	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:115) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$158/545351516.execute(Unknown Source) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter  - Build Tool/IDE: IntelliJ 2018.3.6 Community Edition","closed","theme: dynamic tests,","Petikoch","2019-04-16T14:17:54Z","2019-04-16T17:39:58Z"
"","1800","JUnit5 5.4.0 broke Android support","JUnit 5.4.0 started crashing on Android due to unsupported UNICODE_CHARACTER_CLASS flag in Pattern.  ## Steps to reproduce  1. Create brand new emulator from Android Studio with `Android 9.0 (Google Play) x86_64` image 2. checkout https://github.com/mannodermaus/android-junit5/tree/7b9f490d9ba6e7eb6b91b99e6d2755c546354e4f 3. Start emulator 4. Run `./gradlew :sample:connectedExperimentalDebugAndroidTest` from the root of checked out repo 5. Tests will crash with following exception:  ``` java.lang.ExceptionInInitializerError at org.junit.platform.commons.util.StringUtils.isNotBlank(StringUtils.java:64) at org.junit.platform.commons.util.Preconditions.notBlank(Preconditions.java:248) at org.junit.platform.launcher.core.LauncherConfigurationParameters.(LauncherConfigurationParameters.java:44) at org.junit.platform.launcher.core.LauncherConfigurationParameters.(LauncherConfigurationParameters.java:39) at org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.build(LauncherDiscoveryRequestBuilder.java:194) at org.junit.platform.runner.JUnitPlatform.createDiscoveryRequest(JUnitPlatform.java:153) at org.junit.platform.runner.JUnitPlatform.(JUnitPlatform.java:124) at org.junit.platform.runner.JUnitPlatform.(JUnitPlatform.java:117) at de.mannodermaus.junit5.AndroidJUnit5.(Runner.kt:17) at de.mannodermaus.junit5.RunnerKt.createJUnit5Runner(Runner.kt:22) at de.mannodermaus.junit5.AndroidJUnit5Builder.runnerForClass(RunnerBuilder.kt:69) at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) at androidx.test.internal.runner.AndroidRunnerBuilder.runnerForClass(AndroidRunnerBuilder.java:147) at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) at androidx.test.internal.runner.TestLoader.doCreateRunner(TestLoader.java:73) at androidx.test.internal.runner.TestLoader.getRunnersFor(TestLoader.java:104) at androidx.test.internal.runner.TestRequestBuilder.build(TestRequestBuilder.java:789) at androidx.test.runner.AndroidJUnitRunner.buildRequest(AndroidJUnitRunner.java:543) at androidx.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:386) at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2145) Caused by: java.lang.IllegalArgumentException: Unsupported flags: 256 at java.util.regex.Pattern.(Pattern.java:1324) at java.util.regex.Pattern.compile(Pattern.java:975) at org.junit.platform.commons.util.StringUtils.(StringUtils.java:36) ... 20 more ```  It looks like [UNICODE_CHARACTER_CLASS was added to StringUtils](https://github.com/junit-team/junit5/commit/db8b3d4cdd588fad4660fbedaf1c6b2f68daed77#diff-6620c2fff8288084514a095acc4cb5a8R36) in JUnit 5.4.0. This flag is not supported on Android (not even on the latest devices) and causes crash whenever  `StringUtils` class is initialized.","closed","component: Platform,","matejdro","2019-03-05T13:26:06Z","2019-03-17T16:55:38Z"
"","1801","Test with @TempDir fails with NoSuchFileException if the tempDir is deleted inside the test","JUnit 5.4.0  ## Steps to reproduce ```java     @Test     void deleteDirectory(@TempDir Path tempDirectory) throws IOException {         Files.delete(tempDirectory);         assertThat(tempDirectory).doesNotExist();     } ``` ## Context   - Used versions (Jupiter/Vintage/Platform): 5.4.0  - Build Tool/IDE: IntelliJ / Maven 3.6.0","closed","component: Jupiter,","gastaldi","2019-03-06T13:56:18Z","2019-03-09T16:09:19Z"
"","1683","Document default execution mode for test classes that use Lifecycle.PER_CLASS and for @Nested test classes","JUnit 5.3.1 I have set junit.jupiter.execution.parallel.enabled=true in junit-platform.properties.  According to the docs, all tests should now run in parallel.  In fact, only tests with @Execution(ExecutionMode.CONCURRENT) run in parallel.  Attaching 2 test classes.  [examples.zip](https://github.com/junit-team/junit5/files/2600122/examples.zip)","closed","component: Jupiter,","sidamos","2018-11-20T14:32:11Z","2018-12-03T20:01:45Z"
"","1684","Support having only a few parallel test classes","JUnit 5.3.1  According to the docs, when I set `junit.jupiter.execution.parallel.enabled=true` in `junit-platform.properties`, then all tests run in parallel, unless they have annotation `@Execution(ExecutionMode.SAME_THREAD)`.  This is not true (see issue #1683), but once this is true, then this will be pretty annoying. From our preliminary testing of JUnit 5, I can say that making tests thread-safe can be a greater task than one would anticipate.  Therefore, we'd need the ability to easily only have some classes run in parallel and not the other way around (only some classes not parallel), like this seems to be planned according to the docs.  Thanks!","closed","component: Jupiter,","sidamos","2018-11-20T14:36:55Z","2018-12-03T20:01:48Z"
"","1000","JUnit 5 RC2 source JARs downloaded from Maven contain each file twice","JUnit 5 RC2 source JARs downloaded from http://repo1.maven.org/maven2/org/junit/ contain each file twice. For example, in `junit-jupiter-api-5.0.0-RC2-sources.jar`, `org\junit\jupiter\api\function\` contains two `Executable.java` files. This can be seen while trying to extract the JAR also.  Is this expected?","closed","component: Kotlin,","noopur2507","2017-08-03T16:13:25Z","2017-08-19T11:11:42Z"
"","1362","Fix Javadoc stylesheet for JDK 10","Jenkins is already using JDK 10 to generate Javadoc. I've noticed that [the overview](https://junit.org/junit5/docs/snapshot/api/overview-summary.html) now uses tabs for the groups ""Jupiter"", ""Vintage"", and ""Platform"". Before using JDK 10 or higher to compile a release we need to improve our stylesheet. We should probably diff the JDK 9 and 10 default stylesheets/html output to see what changed.","closed","theme: documentation,","marcphilipp","2018-04-08T17:46:30Z","2018-04-17T16:46:28Z"
"","1773","java.lang.NoSuchMethodError: org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass Migrating to 5.4.0","JDK: 11 Spring Boot: 2.1.2.RELEASE JUnit: 5.4.0 Maven: 3.6.0 Surefire: 3.0.0-M3  At first, I got the following error running the tests on IntelliJ and using the command mvn clean install: ``` [INFO] --- maven-surefire-plugin:3.0.0-M3:test (default-test) @ xxxxx --- [INFO] [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- Feb 12, 2019 12:53:00 PM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to execute tests java.lang.NoSuchMethodError: org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(Ljava/lang/String;)Lorg/junit/platform/commons/function/Try;         at org.junit.jupiter.engine.support.OpenTest4JAndJUnit4AwareThrowableCollector.createAbortedExecutionPredicate(OpenTest4JAndJUnit4AwareThrowableCollecto ```  After adding this dependency, I could run the tests in IntelliJ but not using Maven: ```                      org.junit.platform             junit-platform-launcher             1.4.0             test          ```  Rolling back to version 5.3.2 solves the problem","closed","","ahmedyarub","2019-02-12T14:57:16Z","2021-03-18T14:38:46Z"
"","1135","Support for extension (@ExtendWith) parameters","It would be great if it were possible to parameterize JUnit 5 extensions. For instance, something like this:  ```java @ExtendWith(LiquibaseExtension.class, properties={     @ExtensionProperty(key=""url"", value=""jdbc:h2:...""),     @ExtensionProperty(key=""changeLogFile"", value=""path/to/changelog"") }) class MyTest { } ```  This would enable re-using extension across different codebases and organizations.  Thanks for the terrific tool!","closed","","maxenglander","2017-11-01T23:41:43Z","2017-11-02T14:45:19Z"
"","1920","Introduce assertions for java.util.Optional","It would be convenient to have some type safe shortcuts to test the content of an Optional for its presence and value. This has been discussed a few times like: https://stackoverflow.com/questions/38954742/assert-that-optional-has-certain-value  The following Assertions methods shall explain, what I have in mind:  ```java     public static void assertEmpty(Optional optional) {         assertNotNull(optional);         assertTrue(optional.isEmpty());     }      public static void assertPresent(Optional optional) {         assertNotNull(optional);         assertTrue(optional.isPresent());     }      public static  void assertContains(T expected, Optional actual) {         assertNotNull(expected);         assertPresent(actual);         // maybe even more strict: assertEquals(optional.get().getClass(), value.getClass());         assertEquals(actual.get(), expected);     } ```","closed","component: Jupiter,","stolle","2019-06-06T12:16:17Z","2019-06-07T10:49:09Z"
"","1766","JAR manifests contain invalid Specification-Version","It reads `Specification-Version: MatchGroup(value=5.4.0, range=0..4)` for Jupiter and Vintage JARs, but should be `Specification-Version: 5.4.0`. Same goes for Platform JARs, which contain `Specification-Version: MatchGroup(value=1.4.0, range=0..4)`, but should have`Specification-Version: 1.4.0`.  ## Deliverables  - [x] Use correct value for `Specification-Version` in all manifest files - [x] Write an integration test that checks expected manifest values","closed","component: Vintage,","sormuras","2019-02-08T10:52:45Z","2019-03-09T10:40:49Z"
"","1613","Allow 0 as a delta in assertEquals methods","Issues: #1606   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","mateuszjarzyna","2018-10-02T09:58:15Z","2018-10-08T20:00:04Z"
"","1073","Redirect test output to file, if this setting is enabled.","Issue: #986  ## Overview  Hi!  I inspected the way test output are redirected to file, in surefire-junit4 provider.  The main surefire-junit4 provider class can be found [here](https://github.com/apache/maven-surefire/blob/master/surefire-providers/surefire-junit4/src/main/java/org/apache/maven/surefire/junit4/JUnit4Provider.java).  I've noticed similarities, between surefire-junit4 and junit5 provider.  When maven instantiates the surefire provider, it sends an object of type `ProviderParameters` to the surefire provider (in main class's constructor). This object is used to create an `ReporterFactory`, then an `RunListener`. This `RunListener` is actually an interface. Running the debugger, I saw that the actual implementation is an object of type `ForkingRunListener`. `ForkingRunListener` also implements `ConsoleOutputReceiver`.   Method `ConsoleOutputCapture.startCapture(ConsoleOutputReceiver target)` is responsible for the actual output redirection. This method is invoked in surefire-junit4, but not in junit5 provider.  After this change, the tests output are redirected correctly.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","BogdanStirbat","2017-09-23T16:42:10Z","2017-11-05T17:34:08Z"
"","1217","Refactor HierarchicalTestExecutor","Issue: #742  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] ~Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes)~ - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2017-12-26T08:27:05Z","2017-12-28T09:04:39Z"
"","1784","Add support for boolean to @ValueSource","Issue: #1780  ## Overview  adding additional support for boolean to `@ValueSource` based on feature request #1780   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---   ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","aepfli","2019-02-17T21:37:43Z","2019-03-11T18:50:15Z"
"","1789","Safeguard against exceptions thrown in TestExecutionListeners","Issue: #1777   ## Overview  Prior to this PR, Test plan used to fail upon exception occurs while executing `TestExecutionListener` or `EagerTestExecutionListener`.  To improve the platform behavior, we decided to not fail the test plan vs log an exception occurred in `TestExecutionListener` or `EagerTestExecutionListener` (WARN level) and continue test plan.   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","gopinath-langote","2019-02-20T14:59:53Z","2019-05-05T13:42:57Z"
"","1615","Add CamelCase Display Name Generator","Issue: #1595  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","zoltanersek","2018-10-03T13:32:41Z","2020-04-02T12:54:30Z"
"","1433","Only instantiate Argument Converters and aggregators once per parameterized test","Issue: #1397  ## Overview  Prior to this commit Argument Converter and Aggregator classed were instantiated once per invocation of the @ParameterizedTest invocation.  With this commit instances will be created during the first invocation of the @ParameterizedTest method, stored and reused on subsequent invocations.  If the same Converter of Aggregator classes are used on other @ParameterizedTest methods a new instance will be created on first invocation and reused for subsequent invocations of that method.  Of the two proposed options to implement this, either eager instantiation or reuse I chose reuse. The rationale was if the instantiation of a Converter of Aggregator failed with an exception this error could be caught with the existing safe mechanism and also for the failure to be very close to the impacting test invocation.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","gaganis","2018-05-27T15:06:13Z","2019-07-19T19:32:24Z"
"","1364","Introduce variant of Assertions.fail() without arguments","Issue: #1333  ## Overview  Implemented as discussed to achieve a reasonable behaviour with both, the current and the upcoming versions of `opentest4j`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","mmerdes","2018-04-11T08:28:36Z","2019-04-14T13:43:11Z"
"","1271","Make @MethodSource `value` attribute optional","Issue: #1270  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","nikowitt","2018-01-30T13:55:13Z","2018-02-02T09:07:21Z"
"","1136","Ignore empty strings supplied via includeTags and excludeTags in Maven Surefire provider","Issue: #1126  ## Overview  IncludeTags and ExcludeTags are modified to accept empty strings as input parameter.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","VikasSherawat","2017-11-02T15:49:34Z","2017-11-11T22:39:36Z"
"","1142","Fix Javadoc @value tag usages issue","Issue: #1098  ## Overview  Hardcoded values as no other syntax is being resolved in java 9.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","","VikasSherawat","2017-11-04T14:07:04Z","2017-11-04T15:25:34Z"
"","1173","Break out release notes from user guide in their own page","Issue: #1068  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","theme: documentation,","gaganis","2017-11-18T17:37:36Z","2018-01-14T09:15:30Z"
"","1957","Introduce Assertions#assertSorted for Iterables","Introduce methods for asserting sorted state of `java.lang.Iterable`s.  ## Deliverables  - [ ] ` void assertSorted(Iterable iterable, Comparator comparator)` - [ ] `> void assertSortedInNaturalOrder(Iterable iterable)` - [ ] `> void assertSortedInReverseOrder(Iterable iterable)`  Implementing these methods is fairly simple, I believe. And here comes examples returns a `boolean`. ```java     public static  boolean isSorted(final Iterable iterable,                                        final Comparator comparator) {         boolean beforeTheFirst = true;         T previous = null; // null shouldn't be considered as the before-the-first state.         for (final T current : iterable) {             if (beforeTheFirst) {                 beforeTheFirst = false;                 previous = current;                 continue;             }             if (comparator.compare(previous, current) > 0) {                 return false;             }             previous = current;         }         return true;     }      public static > boolean isSortedInNaturalOrder(             final Iterable iterable) {         return isSorted(iterable, Comparator.naturalOrder());     }      public static > boolean isSortedInReverseOrder(             final Iterable iterable) {         return isSorted(iterable, Comparator.reverseOrder());     } ```","closed","component: Jupiter,","onacit","2019-07-13T05:22:05Z","2019-07-25T10:20:07Z"
"","1698","[ConsoleLauncher] Extend stack trace output","Include root cause and suppressed exceptions in the stack trace printed by the Console Launcher  Resolves #1693.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","olcbean","2018-12-09T11:10:56Z","2019-01-14T17:30:16Z"
"","1552","Unrecognized module","In testing JDK9 module system, module related information is not available. Can only get module information of JDK. I wrote the same module code in the main function and the test method, but the results were different.The main function can get the relevant information normally, but the test method is not.","closed","theme: modules,","Yang-xingchen","2018-08-18T03:30:42Z","2018-08-20T14:46:57Z"
"","1826","Configure dependency cache on GitHub Actions","In order to speed up builds on GitHub Actions: https://github.com/marketplace/actions/cache  ### Jobs  - [ ] Linux (uses `container: junitteam/build:latest`) - [ ] Windows - [ ] Mac OS - [ ] Coverage (uses `container: junitteam/build:latest`) - [ ] Publish Snapshot Artifacts - [ ] Update Snapshot Documentation","open","theme: build,","marcphilipp","2019-03-19T13:25:53Z","2022-07-12T08:04:49Z"
"","1416","Publish default scope 'test' in junit-bom","In order to prevent users from accidentally introducing compile dependencies on JUnit artifacts, we should set the default `scope` to `test` for all artifacts in the `junit-bom`.  ## Deliverables  - [ ] Set `scope` to `test` for all artifacts. - [ ] Check that the `scope` defined in a BOM is actually applied in a project that imports the BOM.","closed","component: Platform,","marcphilipp","2018-05-11T10:30:25Z","2019-10-08T01:50:50Z"
"","1457","Deprecate @ParameterizedTest and add required annotation to @ArgumentSource","In order to avoid [PEBCAK](https://www.webopedia.com/TERM/P/PEBCAK.html) errors and refactoring mistakes, I think it would be better to be able to simply write:  ```java @Test @ArgumentSource(MySource.class) ```  ... such that the ""parameterized"" portion becomes inferred.  This could also simplify conventions for #871, since you could simply put `@ArgumentSource` on the class as well... however this probably means more complicated code in JUnit Jupiter.  This is just an idea as client refactoring seems slightly tedious and error prone.","closed","theme: parameterized tests,","xenoterracide","2018-06-06T19:49:55Z","2018-06-07T10:00:27Z"
"","1409","How to use JUnit 5 and Java 10 in Maven with the confilcting maven-surefire-plugin and org.ow2.asm","In my project I try to use Java 10 with Junit 5, but something interesting occurs.  **Background**   To make maven work well under Java 10, we need to change the asm library of `maven-compiler-plugin` to `org.ow2.asm`. And to make Junit 5 work well under Java 10, we need `maven-surefire-plugin`. Here is the `plugin` part of my `pom.xml`.                                    org.apache.maven.plugins                 maven-compiler-plugin                 3.7.0                                      10                     10                                                                                org.ow2.asm                         asm                         6.1.1                                                                                 maven-surefire-plugin                 21.1.0                                                               org.junit.platform                         junit-platform-surefire-provider                         ${junit.platform.version}                                                              And when I run run maven's test command in Idea, everything is fine. But when I run `mvn test -f pom.xml -e` on the root dir, it gives a error:      [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project user-module: Execution default-test of goal     org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test failed.: IllegalArgumentException -> [Help 1]     org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on proj     ect user-module: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test failed.         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:213)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)         at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)         at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)         at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)         at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)         at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)         at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)         at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke (Method.java:498)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)         at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)     Caused by: org.apache.maven.plugin.PluginExecutionException: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test failed.         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:148)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)         at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)         at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)         at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)         at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)         at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)         at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)         at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke (Method.java:498)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)         at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)     Caused by: java.lang.IllegalArgumentException         at org.objectweb.asm.ClassReader. (Unknown Source)         at org.objectweb.asm.ClassReader. (Unknown Source)         at org.objectweb.asm.ClassReader. (Unknown Source)         at org.codehaus.plexus.languages.java.jpms.AsmModuleInfoParser.parse (AsmModuleInfoParser.java:89)         at org.codehaus.plexus.languages.java.jpms.AsmModuleInfoParser.getModuleDescriptor (AsmModuleInfoParser.java:54)         at org.codehaus.plexus.languages.java.jpms.LocationManager.resolvePaths (LocationManager.java:83)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.newStartupConfigForModularClasspath (AbstractSurefireMojo.java:1765)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.createStartupConfiguration (AbstractSurefireMojo.java:1708)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.createForkStarter (AbstractSurefireMojo.java:2043)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider (AbstractSurefireMojo.java:1146)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked (AbstractSurefireMojo.java:978)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute (AbstractSurefireMojo.java:854)         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)         at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)         at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)         at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)         at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)         at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)         at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)         at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke (Method.java:498)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)         at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)  The `java.lang.IllegalArgumentException` at `org.objectweb.asm.ClassReader` is really weird, maybe `org.ow2.asm` is not compatible with `maven-surefire-plugin`?  Do you guys have any solution? I won't change Java 10 and Junit 5 for some reasons, so don't let me change to Java 8, THX!","closed","3rd-party: Maven Surefire,","UkonnRa","2018-05-06T07:21:58Z","2018-05-06T15:05:24Z"
"","1961","Default display name for methods appends empty parentheses","In JUnit Jupiter 5.5.1 using Kotlin 1.3.41:  ```kotlin @Nested inner class `assign to group` {     @Test     fun `failure -- stop`() {     }     @Test     fun assigned() {     } } ```  Results in the following display names:  ``` assign to group   failure -- stop()   assigned() ```  While I expect it without parentheses:  ``` assign to group   failure -- stop   assigned ```","closed","type: new feature,","Sam-Kruglov","2019-07-22T14:22:38Z","2020-03-03T07:38:06Z"
"","1816","Add TestSkippedException to black-listed exceptions","In a DynamicTest it would be nice to be able to programmatically indicate that a test was skipped by throwing the ``TestSkippedException``.  This exception currently causes a test failure but in this case it should be caught and the test execution should be marked as skipped.","closed","component: Jupiter,","smoyer64","2019-03-15T20:10:17Z","2019-03-18T18:54:10Z"
"","1933","Introduce getOrDefault() in ExtensionContext.Store","Implements #1932  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sbrannen","2019-06-15T14:36:46Z","2019-06-20T07:58:06Z"
"","1029","Introduce support for configuration parameters in console launcher and build plugins","Implementation for #1015.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2017-08-21T20:11:45Z","2017-08-22T18:03:08Z"
"","1765","Introduce assertion support for object properties of a common type","Imagine that you have an object and you want to assert every property for String.EMPTY value. Instead of using all getters of that object, isn't it a good idea to you guys to implement a new feature for getting all getter methods by using reflection and assert them?  For example:  ```java // Object with several properties DummyObj dummyObj = // ...  // In a method that returns String.class, assert the result with a empty string Assertions.assertPropertiesEquals(dummyObj, String.class, """"); ```","closed","component: Jupiter,","ptjuanramos","2019-02-08T10:20:28Z","2020-03-02T12:45:30Z"
"","1582","Using JUnit 4 APIs with JUnit 5 is punitive","If you import a JUnit 4 API by mistake, JUnit 5 doesn’t honor it. For example, if you use `assumeTrue()` from the legacy package your test will fail with an `org.junit.AssumptionViolatedException`.  ``` import static org.junit.Assume.assumeTrue; ``` The same is true for `org.junit.Ignore` vs `org.junit.jupiter.api.Disabled`. The `@Ignore` annotation is not honored and there’s not even guidance that the annotation has changed.  I work with both versions and so I’m frequently suffering papercuts because the APIs are needlessly incompatible.","closed","theme: diagnostics,","swankjesse","2018-09-11T16:03:58Z","2018-09-14T10:48:51Z"
"","1964","Vintage engine to warn/error on mixed JUnit 3/4 tests","If the Vintage engine encounters a class that extends `TestCase` *and* has `@Test` annotations in it, then it will silently ignore all of the JUnit 4 tests. It would be good if it were not so silent about it, as it could lull people into a false sense of security that all their tests are passing, when some are simply not running at all.  I just encountered the case where a test class had no tests found, and Vintage helpfully noted the fact as a test under the relevant class named ""warning"", with appropriate diagnostics in the error message/stack trace. A similar technique could be used to report the error when `TestCase` and `@Test` are mixed.","closed","theme: diagnostics,","kriegfrj","2019-07-24T05:14:57Z","2019-12-16T20:12:19Z"
"","1401","Add assertThrows overloads that take a ThrowingSupplier","If the given ThrowingSupplier fails to throw the expected exception and instead returns a value, the string representation of the value is included in the failure message to aide debugging.  Fixes #1394  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","cushon","2018-05-02T03:07:35Z","2018-06-21T20:39:36Z"
"","1704","Improve message of Assertions.assertDoesNotThrow","If an unexpected error is thrown, the throwable message is added to the resulting `AssertionFailedError`.  Issue: #1703  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","olcbean","2018-12-17T18:18:27Z","2018-12-17T21:36:42Z"
"","1687","Discovery selector & filter model does not work with dynamically registered tests","I'm writing a TestEngine against JUnit 5.3.1.  The test engine I am writing registers tests dynamically, during the execution phase rather than discovery.  In the current engine API, discovery selectors and filters are passed to the `discover` method of the engine in the `EngineDiscoveryTest`, but not to the `execute` method in the `ExecuteRequest`. This means that selectors and filters are not available to be applied to dynamically registered tests.  For example, this means that there is no way to run an specific dynamically registered test identified by a UniqueIdSelector.  Suggested solution: pass the selectors and filters to the execute phase in the `ExecuteRequest`.","closed","","npryce","2018-11-23T08:59:39Z","2018-11-23T10:47:50Z"
"","1944","Unsupported or missing version of JUnit 4 should fail the build","I'm using junit and vintage from the bom 5.5.0 in a Maven based project. https://github.com/nielsbasjes/yauaa  In this project I have created a udf for Apache Pig. In the pig dependency for this udf I also get junit 4.11.  The consequence of this older version of junit is that I get this perfectly fine stack trace during my build:  ``` [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- Jul 02, 2019 11:42:33 PM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-vintage' failed to discover tests org.junit.platform.commons.JUnitException: Unsupported version of junit:junit: 4.11. Please upgrade to version 4.12 or later. 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:39) 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:32) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:61) ``` and later on ``` [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  The bug I'm reporting is that I think this is should be a fatal error and not just a warning.  None of the tests I have ran and the ONLY reason I noticed this is because I saw a sudden drop in the code coverage of the tests.  So if this problem happens then please fail the build.","closed","theme: diagnostics,","nielsbasjes","2019-07-03T08:13:37Z","2020-04-26T13:26:00Z"
"","1858","Parallelism option ignored when using own ForkJoinPool","I'm using Junit 5.4.1 and am experiencing a weird issue related to parallelism.  I have a set of Tests that I want to execute in parallel. 4 of these tests are tagged with the tag ""main"". Which I want to execute using maven. However I only want to execute 2 of them at the same time. Thus I configured jUnit 5 as follows:  `junit.jupiter.execution.parallel.enabled=true junit.jupiter.execution.parallel.config.strategy=fixed junit.jupiter.execution.parallel.config.fixed.parallelism=2`  This config works when I invoke the following mvn command:  `mvn test`  However, when i add the parameter to only execute the Tests tagged with main:  `mvn test -Dgroups=main`  ALL of the tests (meaning 4) tagged with ""main"" are executed in parallel, when only 2 should be executed at the same time. It seems that somehow, the parallelism count is ignored. Unfortunately I can't verify which setting is used by JUnit5 or if this bug is related to mvn surefire or Junit5  ## Steps to reproduce  - Create a Test Suite with 5 or more Tests - Tag 4 of them with a tag (e.g main) - invoke mvn test -Dgroups=main   ## Context   - Used versions (Jupiter/Vintage/Platform): 5.4.1 Jupiter / no vintage / 1.4.1 platform  - Build Tool/IDE: maven 3.6 surefire 2.22.1","open","component: Jupiter,","fredericOfTestfabrik","2019-04-11T13:33:24Z","2022-08-02T10:22:38Z"
"","1938","JMockit does not work with JUnit Jupiter 5.5.0-RC2","I'm using JUnit 5 together with jmockit-1.46.  When I use JUnit 5.5.0-M1 then my unit tests work properly, but when I use 5.5.0-RC2 then I get a `ParameterResolutionException` for parameters injected into tests with `@Mocked`.   Please guide me how to provide more useful information if needed.","closed","component: Jupiter,","AlvaHenrik","2019-06-27T07:23:37Z","2019-06-27T09:44:28Z"
"","1568","Pass test Method to TestInstanceFactory when using Lifecycle.PER_METHOD","I'm trying to update [CDI-Unit](http://bryncooke.github.io/cdi-unit) to [support JUnit 5](https://github.com/BrynCooke/cdi-unit/issues/103), specifically CDI-Unit's [`ProducerConfig` feature for JUnit 4](https://github.com/BrynCooke/cdi-unit/blob/805e077660d7d609b24b0d2b8dc1fa264ad30082/cdi-unit/src/test/java/org/jglue/cdiunit/TestProducerConfig.java) which uses annotations on the test method to help configure the deployment payload for Weld. Weld is then used to construct test instances. This can almost be replicated in JUnit 5, by implementing a `TestInstanceFactory`.  (Obviously this won't be compatible with `Lifecycle.PER_CLASS`, because the instances must allow for per-method configuration.)  The problem is, when `TestInstanceFactory.createTestInstance()` is called, `extensionContext.getTestMethod()` always returns `Optional.empty()`, even when using `Lifecycle.PER_METHOD`.  If the `TestInstanceFactory` were to receive the test Method, when using `Lifecycle.PER_METHOD`, it would be possible to use annotations from the test method to control test instance creation, thus allowing features like `ProducerConfig` to be created.","open","component: Jupiter,","seanf","2018-08-30T02:38:46Z","2021-08-15T07:50:30Z"
"","1612","Can't exclude tags with Maven Surefire via command line options","I'm trying to exclude a tag from test execution with Java system props that are passed via the command line, but it's not working.  ```java public class A {      @Test     @Tag(""NotThreadSafe"")     public void test(){         System.out.println(""NotThreadSafe"");     }      @Test     public void test2(){         System.out.println(""It's ok"");     } } ```  `$: mvn clean test -Dtest=""**/selftest/**"" -DexcludeTags=""NotThreadSafe""`  Output:  ``` NotThreadSafe It's ok ```  But `-Dgroups` propery works fine:  `$: mvn clean test -Dtest=""**/cdp/autotests/selftest/**"" -Dgroups=""NotThreadSafe""`  Output:  ``` NotThreadSafe ```","closed","3rd-party: Maven Surefire,","hmartinh","2018-10-02T09:21:41Z","2020-07-24T12:53:43Z"
"","1193","Surefire does not execute single test method when selected via system property","I'm trying to do this `mvn test -Dtest=SingleMethodTest#firstMethod`, but Maven Surefire executes all the test methods.  - here you can check the [test](https://github.com/AlejandroJadzinsky/junit5-test)  -   used versions 2.19.1 5.0.1 1.0.1  - expected result  only 'firstMethod' is tested.","closed","3rd-party: Maven Surefire,","AlejandroJadzinsky","2017-11-30T15:40:14Z","2018-06-26T19:44:46Z"
"","1721","Intelligent scheduling of parallel tests with @ResourceLock","I'm running a test suite in parallel which uses `@ResourceLock` on a few tests. Most tests don't use any resource locks. There are two tests which lock resource `X`. If the first test runs rather late, the second will have to wait for the first to finish, often being the last test being executed, while the other threads already finished and have nothing left to do.  It would be helpful if all tests with locking would be scheduled before any tests without locking. The workers can pick a lock-less test if there's nothing else. This should on average result in a shorter total execution time, as the blocking of lock-awaiting tests will happen while there are still other tests to be executed by other workers, instead of having a sequential test execution order at the end.","closed","status: stale,","kelunik","2019-01-07T16:35:19Z","2021-06-19T12:50:05Z"
"","1435","Running Test suite with a @TestFactory method","I'm running a Test Suite in JUnit 5 using TestFactory methods to run dynamic tests.  But then the result is always showing a **no name** DisplayName even though I have written a display name.  Also noticed that static tests were run but ended up using a new Junit Jupiter Test instance.  See photo below.  ![image](https://user-images.githubusercontent.com/39552864/40642271-2c7638d8-634f-11e8-899e-f92efa619e54.png)","closed","theme: suites,","aaronhonra","2018-05-29T06:47:28Z","2018-06-03T16:43:17Z"
"","1335","Feature Request: Structures in Dynamic Tests","I'm really looking forward using JUnit 5, especially Dynamic Tests. In our company we are using a lot of JBehave. In short JBehave allows to describe scenarios written in special DSL files and execute them by an own JBehave Runner.  In JUnit 4 we had a lot of problems getting test reporting done for that tests being executed by JBehave Runner, so each successful and each failed scenario is reported and counted correctly in JUnit. Now in JUnit 5 each scenario is a Dynamic Test and things work fine.  The only drawback: Test description in JBehave is quite hierarchical: One JUnit-Test may execute several story files, one story file consists of several scenarios, one scenario may consist of multiple examples.  For now I'm just able to flatten all that hierarchy to the lowest level, hiding a lot of information from developers. It would be great, if it was possible to structure those tests in a hierarchic view having some logical containers on some levels.","closed","component: Jupiter,","mibutec","2018-03-19T17:33:02Z","2018-03-20T09:09:11Z"
"","1109","Custom discovery of dynamic tests","I'm pondering how to integrate JUnit 5 support into https://github.com/TNG/ArchUnit The pattern with JUnit 4 was, to use a custom Runner, then write sth. like ``` @RunWith(ArchUnitRunner.class) @AnalyzeClasses(packages = ""foo.bar"") public class ArchitectureTest {     @ArchTest     public static final ArchRule only_DAOs_may_use_the_EntityManager =         noClasses().that().resideOutsideOfPackage(""..dao.."")             .should().accessClassesThat().areAssignableTo(EntityManager.class); } ``` How would you propose, I'd migrate this? I have a couple of ideas, just wanted to make sure I'm not running in a wrong direction here:  * I could use `@TestFactory` in a base class, scan for `@ArchTest`'s and generate dynamic tests * I could write my own `TestEngine`, adding a discovery process that picks up `@ArchTest` fields  The first approach seems to be easy to implement, but forces the extension of a base class on every client, which I generally don't like too much (I'd rather use inheritance for ""is a"" relationships, not for ""wants to share some common logic"")  The second approach would force me, to copy a lot of code from the Jupiter Engine, since most of the code is private and what I really need, is just a discovery extension, i.e. influence how tests are discovered and add the mechanism to discover fields instead of methods.  I think there has been discussion about this, but there is no simple extension point for discovering test cases, am I correct?","closed","component: Jupiter,","codecholeric","2017-10-15T04:46:27Z","2019-07-19T10:16:13Z"
"","1878","Replace `Path` with `File` in docs for TempDir","I'm not sure why you use `Path` instead of `File` in your documentation for the `TempDir` feature. But I think that should be changed to `File` because this is way more common to use instead of `Path`.","closed","theme: documentation,","StefMa","2019-05-13T13:49:42Z","2019-05-13T17:37:40Z"
"","1574","Polish the User Guide and ComparableContract example","I'm not sure which is appropriate English, `larger number` or `bigger number` ;-p  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: documentation,","oohira","2018-08-31T20:50:30Z","2018-09-01T14:55:59Z"
"","1456","Doubly Parameterized tests within a nested test class","I'm not sure if this is a doc improvement or request for feature, from the docs I'm not sure if what I'm trying to do is possible which is why I'm posting here  ```java class XenoPluginTest {      private Project project;      @BeforeEach     void setup() {         project = ProjectBuilder.builder().build();     }      @ParameterizedTest     @ArgumentsSource( PluginProvider.class )     void codeQuality( Collection>> pluginClass ) {         pluginClass.forEach( project.getPluginManager()::apply );          PluginContainer plugins = project.getPlugins();          assertAll( ""plugins"",                 () -> assertTrue( plugins.hasPlugin( IdeaPlugin.class ), ""idea"" ),                 () -> assertTrue( plugins.hasPlugin( SpotBugsPlugin.class ), ""spotbugs"" ),                 () -> assertTrue( plugins.hasPlugin( ErrorPronePlugin.class ), ""errorprone"" ),                 () -> assertTrue( plugins.hasPlugin( CheckstylePlugin.class ), ""checkstyle"" ),                 () -> assertTrue( plugins.hasPlugin( JavaLibraryPlugin.class ), ""java"" )         );     }      @Nested     class SourceSetExtensions {          @ParameterizedTest         @ArgumentsSource( ExtensionProvider.class )         void hasSourceSets( Class cqe ) {             assertThat( project.getExtensions().getByType( cqe ).getSourceSets() ).isNotEmpty();         }     }      static class ExtensionProvider implements ArgumentsProvider {          @Override         public Stream provideArguments( ExtensionContext context ) {             return Stream.of( SpotBugsExtension.class, CheckstyleExtension.class ).map( Arguments::of );         }     }      static class PluginProvider implements ArgumentsProvider {          @Override         public Stream provideArguments( ExtensionContext context ) {             return Stream.of(                     Arrays.asList( JavaLibraryPlugin.class, XenoCodeQualityPlugin.class ),                     Collections.singleton( XenoJavaLibPlugin.class )             ).map( Arguments::of );         }     } } ```  What I really want here, `codeQuality` runs twice, once for each plugin class list (this works). `hasSourceSets` runs *4* times. The `@Nested` runs twice for each plugin class, and then `hasSourceSets` would run twice fore each of those with each extension given. If this is currently possible perhaps an example could be added to the docs. If it isn't possible, I think being able to do this somehow would be a great feature.","closed","theme: parameterized tests,","xenoterracide","2018-06-06T15:13:20Z","2019-07-19T10:11:51Z"
"","1682","Add parallel execution mode that runs only test classes in parallel","I'm in the process of upgrading our parallel test setup to JUnit5. My JUnit4 surefire configuration looks like this:  ```      classes     1     true  ```  With this configuration, test classes run in parallel but individual test methods within a class run within the same thread (see [Surefire Docs]( https://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html)).  I tried to emulate this behavior with `@Execution(ExecutionMode.SAME_THREAD)` on my test classes. But as discussed on Gitter, this actually causes the test and all its method to run in the same thread as the test classes parent node which is the test engine.  @marcphilipp suggested two possible workarounds: - you could put the annotation on each test method but that's probably overkill - you could put all your test methods into `@Nested` classes and use `@Execution(ExecutionMode.SAME_THREAD)` on the nested class  Both workarounds are quite invasive and not very intuitive for authors of new tests.  It would be great if we had an additional execution mode that runs only test classes in parallel or if `@Execution(ExecutionMode.SAME_THREAD)` on test classes could be adapted to do that.","closed","component: Jupiter,","theigl","2018-11-19T18:20:49Z","2021-10-31T08:44:09Z"
"","1194","Long test execution time (gradle)","I'm experiencing slow builds on pretty simple test configuration  [configuration, test & log](https://gist.github.com/nyakto/b18f7cb0a8fa2a393394e95d3f8edd23)  Test execution takes pretty stable 5-6 seconds (never lower than 5 seconds, looks like threshold), though it makes nothing But overall build taken even longer (for another 5 seconds!) It's total 10-11 seconds for do-nothing test  I've played with configuration a bit and found, that removing ```logManager``` from configuration reduces build time for 5 seconds (test execution time unaffected)","closed","3rd-party: Gradle,","nyakto","2017-12-02T05:40:19Z","2017-12-22T17:07:33Z"
"","1802","Support composability for `ParameterResolver`s","I would like to leverage existing `ParameterResolver` implementations and use/adapt the type they would resolve in my own `ParameterResolver`. If possible, I would like to use them in a declarative fashion.  ## Use Cases  ### Using a `ParameterResolver` result in another `ParameterResolver`  The first use case I have is leveraging the built-in [`@TempDir`](https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/io/TempDir.html) while testing against multiple Gradle versions and different configurations. We have an extension that works as a `TestTemplate` to run tests against multiple Gradle versions. Right now, both parameters are injected separately and are setup at the start of the test (`@ParameterizedTest`) or set up (`@BeforeEach`):  ```kotlin @TestTemplate @ForGradleVersions([""5.1"", ""5.2""]) internal fun `do thing with GradleRunner`(@TempDir directory: Path, gradleRunner: GradleRunner) {   // assume GradleRunner sort-of-configured here   gradleRunner.withProjectDir(directory.toFile())   // run build with Gradle Runner } ```  I would like to be able to compose the `ParameterResolver` class that is performing the resolution for `GradleRunner` with the `ParameterResolver` for `@TempDir`'s path.  For example, something like this:  ```kotlin @TestTemplate @ForGradleVersions([""5.1"", ""5.2""]) internal fun `do thing with GradleRunner`(gradleRunner: GradleRunner) {   // gradleRunner.withProjectDir(directory.toFile()) unneeded because @ForGradleVersions extension leverages another tool/extension to bootstrap a project directory   // now, run build with Gradle Runner } ```  In this example, the extension would leverage the JUnit Jupiter built-in `@TempDir` `ParameterResolver` to set the `withProjectDir(...)` before the parameter is actually injected. The other extension lifecycle methods would also be invoked appropriately.  ------  Another similar example we have is another `ParameterResolver`-like extension that gets some local Gradle project files and provides the location of it to the test as a `Path`. Then, in the test setup, the `GradleRunner` is set up wit those files before building.  An example might look like this:  ```kotlin @TestTemplate @ForGradleVersions([""5.1"", ""5.2""]) internal fun `do thing with GradleRunner and files`(@TempDir directory: Path, gradleRunner: GradleRunner, @GradleProject([""projects"", ""only-plugins-block""]) directoryWithProject: Path) {   // assume GradleRunner sort-of-configured here with version and withPluginClassPath()   recursivelyCopyDirectory(from = directoryWithProject, to = directory)   gradleRunner.withProjectDir(directory.toFile())   // run build with Gradle Runner } ```  In here, I have multiple `ParameterResolver`s that all get combined in the test (`@ParmaterizedTest`) implementation. I want to mutate the `GradleRunner` that was passed in with another ""modifier"" like extension.  Since the `GradleRunner` has a `null` `.getProjectDir()`, then the customization of the directory from the `@GradleProject` resolver can't really do much.  An example of what it might look like with this feature might be:  ```kotlin @TestTemplate @ForGradleVersions([""5.1"", ""5.2""]) internal fun `do thing with GradleRunner`(@GradleProject([""projects"", ""only-plugins-block""]) gradleRunner: GradleRunner) {   // GradleRunner has full project configured and setup   // run build with Gradle Runner } ```  In this example, the `GradleRunner` has the `withProjectDir(...)` configured by the `ParameterResolver` for `@TempDir` and it's `getProjectDir()` mutated by the `ParameterResolver` (or some other extension) that makes use of `@GradleProject`.  ### Adapting/converting an existing `ParameterResolver`  result  We have an internal JUnit Jupiter `ParameterResolver` that provisions Docker containers. We like that is is mostly generic and can be used to create arbitrary Docker containers, networks, and other launch configurations that we can execute against.  For some containers that get used, a user would like to ""adapt"" the `Container` parameter that gets injected  to a client for whatever service they are starting.  For example, here is an example that provisions a Cassandra Docker container on `localhost` and runs against it:  ```kotlin @ExtendWith(DockerContainerExtension::class) @Test internal fun `my test that uses cassandra container`(@DockerContainer(CassandraContainerLaunchConfigurationProducer::class) container: Container) {   Cluster.builder()     .withPort(container.bindings.first { it.fromPort == 9042 }.toPort)     .addContactPoint(""localhost"")     .withoutJMXReporting()     .withoutMetrics()     .build().use { cluster ->       cluster.connect().use { session ->         // create keyspace, tables, etc.         // run test       }     } } ```  The `Cluster` and `Session` are opened and used to setup some additional resources like tables, keyspace, etc. before being used in test code. In this example, we are not (at least not yet) composing `ParameterResolver` and performing the set up in the test (`@Test`) or set up (`@BeforeEach`) methods.  Below is an example of what I would like it to (possibly) look like.  ```kotlin @ExtendWith(DockerContainerExtension::class) @Test internal fun `my test that uses cassandra container`(@DockerCassandraSession session: Session, @DockerCassandraKeyspace keyspace: String) {   // do test with cassandra   // expect cassandra stuff shut down by extension } ```  In this example, the underlying connection is to a `Container` is abstracted away. I'm also hoping to resolve multiple parameters here for a single `Container`. This example does not have multiple `Container`s, but that is most likely a valid use case, too.  ## Using Existing Tools  From what I can tell, there is no way to do this with existing tooling. The `ExtensionContext.Store` isn't helpful here because each extension has dependencies which would require ordering. There is a desire to reduce the amount of parameters that a test needs as input while also not introducing any inheritance.  The way we have been mostly doing it is to put the injection and configuration in a `@BeforeEach` method and then perform the setup in the test. We would like to, instead, build upon JUnit Jupiter's tools and extension model.  ## Related Issues  - #1604   ## Deliverables  Unsure on exact deliverables.  - [ ] ...","closed","status: stale,","mkobit","2019-03-06T20:45:15Z","2021-06-19T12:50:33Z"
"","1787","Support custom reason in @Disabled* / @Enabled* variants","I would like to be able to write the reason why a test is disabled or enabled on a particular OS, JRE, etc. Currently the text is fixed in the different `ExecutionCondition`(s).   I would propose that a new `default String reason() """"` is added to the variants and that reason is suffixed to the current default text for each condition.  ## Deliverables  TBD","closed","component: Jupiter,","filiphr","2019-02-18T15:02:57Z","2020-05-22T19:55:09Z"
"","1134","Callback Extensions Order","I will be happy to have an order of callback executions. Say a test have 2 extensions, I want to execute the callbacks in a certain order.","closed","status: invalid,","Lubetkin","2017-11-01T15:01:04Z","2017-11-01T15:10:29Z"
"","1334","Test suites not working with JUnit 5","I was moving tests from JUnit 4 to JUnit 5. We are using test suites in our project, and there I got some weird behavior. I'm able to launch tests with JUnit 5 RC versions, but on release 5.1 tests does not start.  Project and POM structure same as [here](https://github.com/howtoprogram/junit5-examples/tree/master/junit5-test-suite-example).  Here is a working POM:  ```xml     5.0.0-M2     4.12.0-M2     1.0.0-M2 ```  When I update to latest release versions:  ```xml     5.1.0     5.1.0     1.1.0 ```  Tests does not start, neither from Eclipse or Maven.  Could not find any mentions, that suites are not supported in latest release. So it seems like JUnit issue.","closed","component: Platform,","PE-test","2018-03-19T16:36:01Z","2020-02-03T12:44:57Z"
"","1402","Request For Enhancement: simple mechanism to tell the framework which test methods to run without @Test annotation","I wanted to be able to be able to run unit tests without them being picked up automatically. I.e. I only want to run them from inside a `main()` method. Sormuras came up with a solution to my question [here](https://stackoverflow.com/questions/50110819/launching-junit-jupiter-tests-from-inside-a-main-method), and suggested that I submit a feature request. I propose that specifying a class or method in a `selector` supplied to the `LauncherDiscoveryRequestBuilder` should make the engine pick that class/methods up and run them even if they're not annotated with `@Test`. I.e. it would be an alternative method of telling the engine what to run.","closed","status: stale,","henrik-io","2018-05-02T15:25:49Z","2021-06-03T20:47:11Z"
"","1759","skipped tags using maven with only api dependency","I use JUnit 5.3.1 in combination with maven 3.6 and surefire 2.22.1 with **forkmode once**. I know this setting seems to be deprecated, but I can reproduce this with the actual settings (**forkCount**) as well.   ## Steps to reproduce  I have a simple testclass within my project with @AfterAll and @Disabled tags. **clean install** does not find those tags and run the specific methods if I only specify the API dependency:  ```  	org.junit.jupiter 	junit-jupiter-api 	5.3.1 	test  ``` But it does not fail as well. Only if I include the **engine** as well:  ```  	org.junit.jupiter 	junit-jupiter-engine 	5.3.1 	test  ``` it works like expected.    That is quite a source of error.   Either it should fail without the engine or pick the right version, if it is a version conflict.","closed","3rd-party: Maven Surefire,","wumpz","2019-02-04T08:20:20Z","2019-02-28T06:53:20Z"
"","1464","JUnit Platform Surefire Provider silently ignores tests when run using Java 7","I tried to use JUnit 5.2 surefire/failsafe provider in maven to run my tests.  I accidentally had the JDK set to 1.7. In that case I got this  ``` [INFO] --- maven-failsafe-plugin:2.21.0:integration-test (default) @ CBASOL-JETQARUN-ALL-CI --- [INFO]  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ``` Eventually I figured out the JVM was wrong so I changed it to JDK 1.8.  Then I got  ``` [INFO] --- maven-failsafe-plugin:2.21.0:integration-test (default) @ CBASOL-JETQARUN-ALL-CI --- [INFO]  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running com.clear2pay.jetqarun.junit5.JUnit5TestFactory ... ```  So it seems that if you specify the wrong JDK, the provider silently ignores the tests. An obvious mistake on my part, but the error handling made it very difficult to diagnose the issue.  Note that all the tests i was running were DynamicTests. Not sure if that makes a difference, but it may do,   Something as simple as an exception which says ""JUnit5 surefire provider requires Java 8"" would have made diagnosing a lot easier.","closed","3rd-party: Maven Surefire,","k1w1m8","2018-06-14T02:27:08Z","2019-02-01T16:35:32Z"
"","1391","Include the apiguardian-api in junit-bom","I thought `apiguardian-api` could also be included in `junit-bom`.","closed","type: question,","syhily","2018-04-25T06:27:48Z","2018-04-25T10:26:19Z"
"","1901","@ValueSource explanation in user guide is misleading","I think the explation of `Null and Empty Sources` section is a little misleading. In the user guide,   * https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-null-and-empty  > If you need to supply multiple varying types of empty or blank strings to a parameterized test, you can achieve that using `@ValueSource` — for example, `@ValueSource(strings = {"" "", "" "", ""\t"", ""\n""})`.  I think   1. `@ValueSource(strings = {"" "", "" "", ""\t"", ""\n""})` is typo of `@ValueSource(strings = {"" "", ""   "", ""\t"", ""\n""})` (NOTE: the 1st argument is 1x space, and the 2nd argument is 3x space. GitHub does not support to display it ...?) because the 1st and 2nd arguments are same, and inconsistent with the folowing code example.      ```java     @ParameterizedTest     @NullSource     @EmptySource     @ValueSource(strings = { "" "", ""   "", ""\t"", ""\n"" })     void nullEmptyAndBlankStrings(String text) {         assertTrue(text == null || text.trim().isEmpty());      }     ``` 1. explanation of `supply multiple varying types of empty or blank strings ...` is misleading because the above example of `@ValueSource` produces four parameters all of which are blank string but not empty string.     * To produce an empty string, you should use `@ValueSource` with `@EmptySource` or specified `strings = {"""", ...}` args for `@ValueSource`.","closed","theme: documentation,","oohira","2019-05-26T13:59:25Z","2019-05-26T22:31:35Z"
"","1679","Run only ""untagged"" tests","I request the ability to run only ""untagged"" tests.  Most tests will run with default arguments and should not require `@Tag(""fast"")`. Other tests require special needs or take a long time so we tag them (i.e. `@Tag(""slow"")`). I would prefer not to require the majority of tests to be tagged at all.  Current workarounds include parsing the code for all declared instances of `@Tag(""*"")` or using the [Launcher#discover](https://github.com/junit-team/junit5/blob/a425b2c52b92befc148962f90d1358014cb38aec/junit-platform-launcher/src/main/java/org/junit/platform/launcher/Launcher.java#L82) method in the build phase, such that all found tags can be excluded.  ## Deliverables  - Provide a keyword (i.e. ""all"") for the `excludeTags` property to exclude all tests that are tagged **OR** some solution providing the equivalent result.","closed","theme: discovery,","calvertdw","2018-11-14T22:00:59Z","2020-05-22T19:52:34Z"
"","1264","junit-vintage-engine coupling to JUnit 4.12","I noticed that `org.junit.vintage:junit-vintage-engine` had its versioning scheme changed in 1562208a3111d919b5505514baac87912870f533. Since the vintage engine depends directly on JUnit 4.12 (and therefore, transitively, on Hamcrest 1.3), I'm not sure what is going to happen when JUnit 4.13 is released, or how to model these artifacts in my company's build system (which is much stricter than Maven when it comes to version conflicts). Should there perhaps be separate vintage engines for JUnit 4.12 and 4.13?","closed","component: Vintage,","rschmitt","2018-01-25T19:55:33Z","2018-01-27T20:34:26Z"
"","1855","Add support for an optional message with assertLinesMatch","I love assertLinesMatch, but it seems odd that this is the only assertion that doesn't support an associated message.  Please add a version of assertLinesMatch that accepts a third argument for a String message, to be consistent with all other assertion types.  Thanks!","closed","component: Jupiter,","tcfurrer","2019-04-09T23:24:29Z","2020-05-22T19:54:10Z"
"","1414","Change to assertThrows in #1394 makes some existing call sites ambiguous","I initially reported this as a comment in #1394 after that issue was closed. I wanted to start a new bug in case the comment got missed.  We started using the new `assertThrows` in our code base, and found that there is a small fraction of cases where this change is incompatible with existing uses of the method.  If the argument is a lambda the compiler will perform type inference and select one of the two overloads. However for method references to some generic methods that throw checked exceptions, type inference isn't powerful enough to disambiguate the overloads:  ```java // error: both method assertThrows(Class,Runnable) and // method assertThrows(Class,Callable) in Z match assertThrows(ExecutionException.class, future::get); ```  This isn't a common problem: it affects about 1% of files in our codebase that use `assertThrows`. The vast majority of those are specifically using `future::get`, and we may have an unusual number of expected exception tests on `Future`s. There's also a simple work-around of using `() -> future.get()` instead of `future::get`.  This seems OK from my perspective. What do you think? Is this a concern, or is it an acceptable breaking change?","closed","component: Jupiter,","cushon","2018-05-10T01:43:48Z","2021-03-08T14:28:33Z"
"","1806","Fix typo","I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","oohira","2019-03-11T13:00:23Z","2019-03-11T13:20:16Z"
"","1657","Allow non void BeforeEach methods to act as a parameter supplier","I have this test  ```java @DataJpaTest @SpringJUnitConfig @AutoConfigureTestDatabase( replace = AutoConfigureTestDatabase.Replace.NONE ) class EmrRepoTest {      private final EmrRepo repo;     private final LocalDateTime now = LocalDateTime.now();     private final Duration duration = Duration.ofSeconds( 5 );      @Autowired     EmrRepoTest( EmrRepo repo ) {         this.repo = repo;     }      Emr save;      @BeforeEach     void setup() {         var entity = new Emr();         entity.setMrn( ""abc123"" );         entity.setDescription( ""mydesc"" );         entity.setTimestamp( now.minus( duration ).plusSeconds( 2 ) );         entity.setUnits( ""mg"" );         entity.setValue( ""25"" );         save = repo.save( entity );     }      @Test     void save() {         assertThat( save ).extracting( Persistable::getId ).hasSize( 1 ).doesNotContainNull();     }      @Test     void findByTimestampIsAfter() {         assertThat( repo.findByTimestampIsAfter( now.minus( duration ) ) ).containsExactly( save );     }  } ```  I would prefer to write  ```java @DataJpaTest @SpringJUnitConfig @AutoConfigureTestDatabase( replace = AutoConfigureTestDatabase.Replace.NONE ) class EmrRepoTest {      private final EmrRepo repo;     private final LocalDateTime now = LocalDateTime.now();     private final Duration duration = Duration.ofSeconds( 5 );      @Autowired     EmrRepoTest( EmrRepo repo ) {         this.repo = repo;     }      @BeforeEach     Emr setup() {         var entity = new Emr();         entity.setMrn( ""abc123"" );         entity.setDescription( ""mydesc"" );         entity.setTimestamp( now.minus( duration ).plusSeconds( 2 ) );         entity.setUnits( ""mg"" );         entity.setValue( ""25"" );         return repo.save( entity );     }      @Test     void save( Emr save ) {         assertThat( save ).extracting( Persistable::getId ).hasSize( 1 ).doesNotContainNull();     }      @Test     void findByTimestampIsAfter( Emr save ) {         assertThat( repo.findByTimestampIsAfter( now.minus( duration ) ) ).containsExactly( save );     }  } ```   ## Related Issues  - #1513","closed","component: Jupiter,","xenoterracide","2018-10-30T20:41:04Z","2018-11-01T10:44:14Z"
"","1667","Assumptions.assume(not)Throws","I have this test  ```java     @Test     void equalsAndHashcodeForFields() {             EqualsVerifier.forClass( Emr.class )                     .withRedefinedSuperclass()                     .withIgnoredFields( AbstractEntityBase.ID )                     .verify();     } ```  currently it's failing for reasons not relevant here, verify returns void and throws an exception. I was hoping I could wrap it in an assumption of some kind.  Instead I guess I'll mark it disabled.","closed","status: superseded,","xenoterracide","2018-11-08T00:10:54Z","2021-05-23T15:49:56Z"
"","1358","JUnit Jupiter instantiates test class for a disabled test method","I have this class:  ```java import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test;  public class JunitTest {     {         System.out.println(""yo"");     }     @Disabled     @Test     public void disabledTest() {      }     @Test     public void enabledTest() {      } } ```  and I would expect that it outputs ""yo"" once, but it outputs it twice. I'm pretty sure that JUnit 4 did not do that.   In that example it may seem far fetched, but the my real test suite is in Kotlin and to keep everything immutable I initialize my dependencies in the class instead of in `@BeforeEach`:  ```java class Tests {   val webServer=TestUtils.startWebserver()    @AfterEach   fun stopIt() {     webServer.stop()   } } ```  so if i add a disabled test method to this class, my webserver is started, but not stopped.","closed","component: Jupiter,","christophsturm","2018-04-04T13:34:04Z","2018-04-05T15:40:23Z"
"","1284","Migration to JUnit 5: Correct configuration about static nested classes","I have the following code for:  * Spring Framework `4.3.x` * JUnit `4.x`  The following works fine (the experience is already shared in: [Testing one Spring Test Class for many different set of profiles](https://stackoverflow.com/questions/47816959/testing-one-spring-test-class-for-many-different-set-of-profiles))  **Alpha**  ```java @Transactional @RunWith(Parameterized.class) @ContextConfiguration(classes={RootApplicationContext.class}) @TestExecutionListeners(listeners={LoggingTestExecutionListener.class}, mergeMode=MergeMode.MERGE_WITH_DEFAULTS) public abstract class PersonaServiceImplTest {  	private static final Logger logger = LoggerFactory.getLogger(PersonaServiceImplTest.class.getSimpleName());  	@ClassRule 	public static final SpringClassRule SPRING_CLASS_RULE = new SpringClassRule();  	@Rule 	public final SpringMethodRule springMethodRule = new SpringMethodRule();  	@Autowired 	private Environment environment;  	@Autowired 	private PersonaService personaServiceImpl;  	private final Persona persona;  	@Parameters 	public static Collection data() { 		return Arrays.asList(new Persona[][] { 	        {PersonaFactory.crearPersona01()}, 	        {PersonaFactory.crearPersona02()}, 	        {PersonaFactory.crearPersona03()}, 	        {PersonaFactory.crearPersona04()}, 	        {PersonaFactory.crearPersonaMix()} 	    }); 	}  	public PersonaServiceImplTest(Persona persona){ 		this.persona = persona; 	}  	@Before 	public void setup(){ 		logger.info(""Profiles: {}"", Arrays.toString(environment.getActiveProfiles())); 	}  	public void saveOneTest(){                 ... the asserts 	}  	public void findOneTest(){                 ... the asserts 	}         ...  	@ActiveProfiles(resolver=TestJdbcActiveProfilesResolver.class) 	public static class ForJdbc extends PersonaServiceImplTest {  		public ForJdbc(Persona persona){ 			super(persona); 		}  		@Test 		@Override 		@Sql(scripts={""classpath:/com/manuel/jordan/db/delete.sql""}) 		public void saveOneTest(){ 			super.saveOneTest(); 		}  		@Test 		@Override 		public void findOneTest(){ 			super.findOneTest(); 		}                               ...         }        @ActiveProfiles(resolver=TestHibernateActiveProfilesResolver.class)       public static class ForHibernate extends PersonaServiceImplTest {  		public ForHibernate(Persona persona){ 			super(persona); 		}  		@Test 		@Override 		@Sql(scripts={""classpath:/com/manuel/jordan/db/delete.sql""}) 		public void saveOneTest(){ 			super.saveOneTest(); 		}  		@Test 		@Override 		public void findOneTest(){ 			super.findOneTest(); 		}                 ...         }  } ```  Thus practically through a _static nested class_  (mandatory be *public*) with `@ActiveProfiles` I get the desired behaviour explained in the `SO` post. Until here I am fine.  I like this approach because it is centralized to one class and its static nested classes.  I did do a migration to `JUnit` **5** (same for `Spring Framework` to 5). Therefore I have the following now:  **Beta**  ```java @Transactional @SpringJUnitConfig(classes={RootApplicationContext.class}) @TestExecutionListeners(listeners={LoggingTestExecutionListener.class}, mergeMode=MergeMode.MERGE_WITH_DEFAULTS) public abstract class PersonaServiceImplTest {  	private static final Logger logger = LoggerFactory.getLogger(PersonaServiceImplTest.class.getSimpleName());  	@Autowired 	private Environment environment;  	@Autowired 	private PersonaService personaServiceImpl;  	//private final Persona persona;  	static Stream data(){ 		return Stream.of( 				PersonaFactory.crearPersona01(), 		        PersonaFactory.crearPersona02(), 		        PersonaFactory.crearPersona03(), 		        PersonaFactory.crearPersona04(), 		        PersonaFactory.crearPersonaMix()); 	}  //	public PersonaServiceImplTest(Persona persona){ //		this.persona = persona; //	}  	@BeforeEach 	public void setup(){ 		logger.info(""Profiles: {}"", Arrays.toString(environment.getActiveProfiles())); 	}  	public void saveOneTest(Persona persona){                 ... the asserts 	}  	public void findOneTest(Persona persona){                 ... the asserts 	}  	...  	/** 	 * 	 * @author manueljordan 	 * @since web-29 	 */ 	@ActiveProfiles(resolver=TestJdbcActiveProfilesResolver.class) 	public static class ForJdbc extends PersonaServiceImplTest {  //		public ForJdbc(Persona persona){ //			super(persona); //		}  		@Override 		@ParameterizedTest 		@MethodSource(""data"") 		@Sql(scripts={""classpath:/com/manuel/jordan/db/delete.sql""}) 		public void saveOneTest(Persona persona){ 			super.saveOneTest(persona); 		}  		@Override 		@ParameterizedTest 		@MethodSource(""data"") 		public void findOneTest(Persona persona){ 			super.findOneTest(persona); 		}                  ...  	}  	/** 	 * 	 * @author manueljordan 	 * @since web-29 	 */ 	@ActiveProfiles(resolver=TestHibernateActiveProfilesResolver.class) 	public static class ForHibernate extends PersonaServiceImplTest {  //		public ForHibernate(Persona persona){ //			super(persona); //		}  		@Override 		@ParameterizedTest 		@MethodSource(""data"") 		@Sql(scripts={""classpath:/com/manuel/jordan/db/delete.sql""}) 		public void saveOneTest(Persona persona){ 			super.saveOneTest(persona); 		}  		@Override 		@ParameterizedTest 		@MethodSource(""data"") 		public void findOneTest(Persona persona){ 			super.findOneTest(persona); 		}                  ...  	} } ```  The code shown compiles fine but when it is executed **none** test is executed, practically nothing.  Thus two questions:  What is missing? (Some extra special configuration or some new annotation to used) **or** Is it now the expected behavior?  I have tried other combinations or ways, but has no sense to share because they are not work and has no sense do verbose this post.  My unique way to get the desired behaviour in `JUnit` 5, _about the `Spring` Profile_, is have three _outer_ classes:  ```java @Transactional @SpringJUnitConfig(classes={RootApplicationContext.class}) @TestExecutionListeners(listeners={LoggingTestExecutionListener.class}, mergeMode=MergeMode.MERGE_WITH_DEFAULTS) abstract class AbstractPersonaServiceImplTest {  ...  }  @ActiveProfiles(resolver=TestHibernateActiveProfilesResolver.class) class PersonaServiceImplForHibernateTest extends AbstractPersonaServiceImplTest {   ...  }  @ActiveProfiles(resolver=TestJdbcActiveProfilesResolver.class) class PersonaServiceImplForJdbcTest extends AbstractPersonaServiceImplTest {  ...  }  ```  Just curious if is possible have one outer class with nested static class.  Thank you","closed","status: works-as-designed,","manueljordan","2018-02-05T20:38:51Z","2018-03-14T17:18:49Z"
"","1242","Conditional extension registration via @ExtendWith","I have a use case where I have a custom annotation i.e. `@MyAnnotation` that is annotated by `@ExtendWith(Extension.class)`.  On a test method, I declare `@MyAnnotation` and another annotation, `@OtherAnnotation`.  ```java @MyAnnotation @OtherAnnotation void test(){...} ```  I want to be able to deactivate the extension registered in `MyAnnotation` (`Extension.class`) when the second annotation, `OtherAnnotation` is present, because JUnit Jupiter takes the extension from `MyAnnotation` and runs it, but I want that `MyAnnotation` could be used as a self contained annotation in other test cases.  Is there a way to tell if `OtherAnnotation` is present and not run the `Extension.class` in `MyAnnotation`?","closed","component: Jupiter,","Lubetkin","2018-01-14T10:22:50Z","2021-08-26T15:35:11Z"
"","1203","Gradle test runner does not show line number or stack trace of failed assertion","I have a test that fails only in gradle, and its impossible for me to find out in what line it fails: ``` Failures (1):   JUnit Jupiter:SeleniumIT:generates a valid video request with a video player()     MethodSource [className = '....', methodName = 'generates a valid video request with a video player', methodParameterTypes = '']     => java.lang.AssertionError:  Expecting actual not to be null ```  junit neither shows a line number nor a stack trace. I think it should show the line number per default. Also i googled and searched the User's guide, and was not able to find a solution.","closed","component: Platform,","christophsturm","2017-12-11T18:24:15Z","2017-12-23T13:42:47Z"
"","1963","Make org.junit.platform.console.tasks.*Listener classes public","I have a project where it would be nice to be able to plug in arbitrary test listeners to get the output that you want.  It would be nice to be able to use the listeners in the console package to optionally produce nicely-formatted test output. Unfortunately, I can't do this easily because the classes are package private, so I have to use reflection if I want to use them.  It seems a pity that JUnit 5 now has all this nice modularity to facilitate plug-and-play code re-use like this, but the opportunity to re-use it is thwarted by hiding it away in a private package.","open","status: waiting-for-interest,","kriegfrj","2019-07-24T00:10:28Z","2022-06-21T15:37:28Z"
"","1786","Support @TempDir tags in extensions","I have a bunch of tests that require me to initialise a temporary directory with some files, so that the methods in my tests can read and write to it. Currently, the solution is to implement a BeforeAll/BeforeEach tag and initialise the temporary directory for each test class. As this is a common routine, it would be more reuse friendly if we could write an extension that encapsulates this routine, and which only needs to receive an input of a Path to initialise a temporary directory with all the files. I envision the extension to look something like  DirectoryInitExtension.java ```java public class DirectoryInitExtension implements BeforeEachCallback {      private Path TEST_DATA_FOLDER;      @TempDir     public Path tempDir;      public static DirectoryInitExtension initializeWith(Path folder) {         return new DirectoryInitExtension(folder);     }      @Override     public void beforeEach(ExtensionContext extensionContext) throws IOException {         // Copy files from TEST_DATA_FOLDER into tempDir, then return this tempDir as part of the test context.     } } ``` MainTest.java ```java  @RegisterExtension     public static DirectoryResetExtension tempDir = DirectoryResetExtension.initializeWith(TEST_DATA_FOLDER); ```  However, as I soon learnt (thanks to a fast response [here](https://stackoverflow.com/questions/54647577/how-to-use-tempdir-in-extensions)), TempDirs are not supported in extensions.  I wonder if it is a possibility to enable the same capabilities of TempDirs in extensions.  ## Deliverables  - [ ] Support TempDir in extensions? (Sorry, not too sure what to write here)","open","component: Jupiter,","sijie123","2019-02-18T04:21:41Z","2021-08-13T10:32:02Z"
"","1462","@ParameterizedTest annotation does not appear to be valid in Groovy file","I get a compile error using the `@ParamterizedTest` annotation in a Groovy file.  `@Test` works fine.  Using JUnit 5 parallel-exectution branch, but just testing a simple JUnit 5 test in a groovy file.  File:  ParamerizedTests.groovy  ```groovy import org.junit.jupiter.api.Test import org.junit.jupiter.params.ParameterizedTest import org.junit.jupiter.params.provider.ValueSource  class ParameterizedTests {     @ParameterizedTest     @ValueSource(strings = {""Dave"", ""Bill""})     public void T(String s) {         println( ""Hello ${s}"")     } } ```  I get a compile error.  ``` [ERROR] Failed to execute goal org.codehaus.gmavenplus:gmavenplus-plugin:1.6:generateTestStubs (default) on project fitpay-automation: Error occurred while calling a method on a Groovy class from classpath.: InvocationTargetException: startup failed: [ERROR] /Users/davidlanaghen/work/automation3/automation/src/test/groovy/fitpay/automation/api/tests/users/ParameterizedTests.groovy: 8: unexpected token: @ @ line 8, column 5. [ERROR]        @ParameterizedTest [ERROR]        ^ [ERROR]  [ERROR] 1 error ```  This is a springboot application and the following dependency has been added to allow for Groovy compilation:  ```xml                     org.codehaus.groovy             groovy          ```","closed","status: works-as-designed,","dlanaghen","2018-06-08T22:00:19Z","2018-06-10T13:50:46Z"
"","1165","Test container which only has aborted tests should also be marked as aborted","I figured out that JUnit 5 is marking Containers as successful even though it only has aborted tests:  *Example:* `@DisplayName(""Parameterized test with custom argument provider"")` `@ParameterizedTest` `@ValueSource(strings={"""", """", """", """"})` `public void paraTests(String param) {`        `assumeFalse(param.isEmpty());`        `assertTrue(param.length() > 0);` `}`  Logs (with registered TestExecutionListener overriding start, finished and register test execution)  > Custom TestExecListener: Start    CONTAINER ""MyJUnit5Test"" Custom TestExecListener: Start    CONTAINER ""Parameterized test"" Custom TestExecListener: Register TEST      ""[1] "" Custom TestExecListener: Start    TEST      ""[1] "" Custom TestExecListener: Finished TEST      ""[1] "" (ABORTED) Custom TestExecListener: Register TEST      ""[2] "" Custom TestExecListener: Start    TEST      ""[2] "" Custom TestExecListener: Finished TEST      ""[2] "" (ABORTED) Custom TestExecListener: Register TEST      ""[3] "" Custom TestExecListener: Start    TEST      ""[3] "" Custom TestExecListener: Finished TEST      ""[3] "" (ABORTED) Custom TestExecListener: Register TEST      ""[4] "" Custom TestExecListener: Start    TEST      ""[4] "" Custom TestExecListener: Finished TEST      ""[4] "" (ABORTED) Custom TestExecListener: Finished CONTAINER ""Parameterized test"" (SUCCESSFUL) Custom TestExecListener: Finished CONTAINER ""MyJUnit5Test"" (SUCCESSFUL)  Same problem with Dynamic tests  ## Acceptance Criteria  - [ ] A CONTAINER should only be marked as SUCCESSFUL if it has at least 1 CONTAINER/TEST which has been SUCCESSFUL and when there are no FAILED CONTAINERs/TESTs at all in it - [ ] A CONTAINER should be marked as FAILED if it has at least 1 CONTAINER/TEST which has FAILED - [ ] A CONTAINER should be marked as ABORTED if all of its CONTAINERs/TESTs have been ABORTED","closed","component: Platform,","rumpfc","2017-11-16T07:35:15Z","2017-12-02T13:22:31Z"
"","1875","Remove parentheses when generating display name with ReplaceUnderscores","I don't know if this has already been discussed, but I noticed something when I discovered the display name generation (which is a cool feature btw!).  When using `ReplaceUnderscores` as a [DisplayNameGenerator](https://github.com/junit-team/junit5/blob/c4ccb87c6afd33e5a09414dd8bb26728d890a684/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java), we can witness the following behavior:  ```java @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class) class SomeTest {      @Test     void this_is_a_test() {         // ...     }      @ParameterizedTest     @CsvSource({""a, b""})     void this_is_a_test_with_arguments(String a, String b) {         // ...     }  } ```  IDE output:    In the first case, I would suggest removing the extra parentheses in the output, as it brings nothing but noise, IMO.  In the second one I'm not sure. Personally I would remove them too, but then we would lose the information about the parameters (I don't know if we really need it though?). Maybe at least put a space between the end of the name and the opening bracket? (Sorry I'm a bit picky ahah)  Tell me what you think! I'd be happy to do it if you agree :)","closed","component: Jupiter,","juliette-derancourt","2019-05-11T14:43:46Z","2019-05-20T11:33:31Z"
"","1788","Make emptyValue configurable in @CsvSource and @CsvFileSource","I did not find a way to set the emptyValue of CsvParserSettings in case of having ""null"" and not """" for empty values.  For example, the values could be  `1;null;20.7;6.75;9; 6.25` And it is not neccessary to have `1;;20.7;6.75;9; 6.25`  I could provide a pull request with the proposal that at the end could be so configured:  `@CsvFileSource(numLinesToSkip = 1, delimiter = ';', emptyValue='null', resources =[....]`  By default is `@CsvFileSource(numLinesToSkip = 1, delimiter = ';', emptyValue='', resources =[....]` `@CsvFileSource(numLinesToSkip = 1, delimiter = ';', resources =[....]`","closed","theme: parameterized tests,","Ciruman","2019-02-19T09:29:15Z","2020-05-22T19:54:34Z"
"","1340","Support methods from external classes in @MethodSource #1088","I cleaned by the way unused `throws` clauses in `ReflectionUtilsTests`. FQMN parsing result is just a String array, I think it's simple enough and creating something like `MethodInfo` data class would be too much. Please carefully review added test cases - I didn't have too much time for it and could miss some important ones.","closed","theme: parameterized tests,","karollewandowski","2018-03-21T23:05:29Z","2018-04-01T16:29:15Z"
"","1904","Prefer public methods when creating Vintage MethodSource","I am working on porting a legacy application to JUnit5.  The test framework implements a `TestExecutionListener` which is listening for `executionStarted` and `executionFinished` methods and from the `TestIdentifier`, extract the `TestSource` and find out if it is a `ClassSource` or a `MethodSource` and do some operations based on that (the tests are cached and a TESTSUITES.xml file built at the end).  What I notice is with a legacy JUnit4 test, if there is a test, say  ```java @Test  public void foo() {  } ```  and the test also has a private overriden method with the same name:  ```java private void foo(final boolean arg) { } ```  then in the `executionStarted` and `executionFinished` callbacks, the `TestSource` contained in the `TestIdentifier` are for a `ClassSource` and not a `MethodSource`.  I lose all information on that _specific_ method being tested.  Attached a reproducible unit test and the build.gradle file.  ```java import java.io.PrintWriter; import java.util.HashSet; import java.util.Set;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.junit.platform.engine.TestExecutionResult; import org.junit.platform.engine.TestSource; import org.junit.platform.engine.discovery.DiscoverySelectors; import org.junit.platform.engine.support.descriptor.MethodSource; import org.junit.platform.launcher.Launcher; import org.junit.platform.launcher.LauncherDiscoveryRequest; import org.junit.platform.launcher.TestExecutionListener; import org.junit.platform.launcher.TestIdentifier; import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder; import org.junit.platform.launcher.core.LauncherFactory; import org.junit.platform.launcher.listeners.SummaryGeneratingListener; import org.junit.platform.launcher.listeners.TestExecutionSummary;  public class TestLauncher {      @Test     public void testLauncher() {          final Launcher launcher = LauncherFactory.create();         final LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()                 .selectors(DiscoverySelectors.selectClass(SimpleLegacyTest.class)).build();         final SummaryGeneratingListener listener = new SummaryGeneratingListener();         final SimpleListener simpleListener = new SimpleListener();         launcher.registerTestExecutionListeners(listener, simpleListener);         launcher.execute(request);         final TestExecutionSummary summary = listener.getSummary();         summary.printTo(new PrintWriter(System.out));         Assertions.assertEquals(summary.getTestsFoundCount(), simpleListener.methods.size());     }      private static class SimpleListener             implements TestExecutionListener {          private final Set methods = new HashSet<>();          @Override         public void executionFinished(final TestIdentifier testIdentifier,                                       final TestExecutionResult testExecutionResult) {             final String message = String.format(""Execution Finished: %s - %s - %s"",                     testIdentifier.getDisplayName(), testIdentifier.getUniqueId(), testExecutionResult);             System.out.println(message);             if (testIdentifier.getSource().isPresent()) {                 final TestSource testSource = testIdentifier.getSource().get();                 if (testSource instanceof MethodSource) {                     this.methods.add(((MethodSource) testSource).getMethodName());                 }             }         }     }      public static class SimpleLegacyTest {         @org.junit.Test         public void testFoo() {          }          @org.junit.Test         public void testBar() {          }          @org.junit.Test         public void foobar() {          }          private void testFoo(final boolean flag) {          }          private void testBar(final boolean flag) {          }     } } ```  ```groovy plugins {     id 'java' }  group 'test' version '1.0-SNAPSHOT'  sourceCompatibility = 1.8  repositories {     mavenCentral() }  dependencies {     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'     compile(""org.junit.platform:junit-platform-launcher:1.4.2"")     testCompile(""org.junit.vintage:junit-vintage-engine:5.4.2"") }  test {     useJUnitPlatform {         excludeTags 'slow'         includeEngines 'junit-jupiter', 'junit-vintage'     } } ```  Notice that the `SummaryGeneratingListener` contains the correct number of tests executed (3), but the methods tested only has one (the only method without a non conflicting name).  Also note that, if there are no legacy tests, then this does not fail.","closed","component: Vintage,","obelix74","2019-05-28T23:28:51Z","2019-06-05T18:24:50Z"
"","1181","class extending TestDataPublisher not being detected by jenkins for new plugin","I am working on a custom plugin for modifying test reports. I have : `public class CheckTestDataPublisher extends TestDataPublisher` which overrides `contributeTestData()` and `getTestAction()`. Yet, both are not called once the test results are collected.","closed","status: invalid,","vcramach","2017-11-23T12:55:05Z","2017-12-02T13:30:12Z"
"","1744","Using the JUnit 5 Standalone Console launcher when classpath points to a different drive in Windows 10, the tests are not detected","I am using the following from a command line: java -jar junit-platform-console-standalone-1.4.0-M1.jar @junit5learn-args.txt   The contents of the junit5learn-args.txt file are: --include-engine=junit-jupiter --exclude-engine=junit-vintage --disable-ansi-colors --details=verbose --details-theme=ascii --fail-if-no-tests --reports-dir=L:/junit5/reports --class-path=JavaProjects/Eclipse/junit5learn/target/test-classes --scan-classpath   This works, and the tests are seen and run perfectly.   However if my test classes are on a different drive the following errors occur when I try to change –class-path variable:   --class-path=L:/JavaProjects/Eclipse/junit5learn/target/test-classes  Results in: Test plan execution started. Number of static tests: 0   --class-path=”L:/JavaProjects/Eclipse/junit5learn/target/test-classes” or  --class-path=’L:/JavaProjects/Eclipse/junit5learn/target/test-classes’ Results in: Error parsing command-line arguments: Unmatched argument: L:JavaProjectsEclipsejunit5learn      arget   est-classes   In addition, is there a way to add comments to the Junit 5 Arguments file? [junit5learn-args.txt](https://github.com/junit-team/junit5/files/2791183/junit5learn-args.txt)","closed","component: Platform,","npworkcode","2019-01-24T10:16:31Z","2019-01-24T23:34:40Z"
"","1215","Global namespace is reset when running via maven surefire","I am using the `Namespace.GLOBAL` namespace to avoid recreating an expensive resource in the `BeforeAllCallback` of an extension. This works great when running tests via IDEA's junit test runner.  When running the tests via `maven test`, the global namespace appears to be reset for every test class. My ""if resource is already created, do nothing"" code is always creating the resource.  This is using Jupiter 5.0.2, Platform 1.0.2, and Surefire 2.19.1.  Here's the (very simple) extension. You see ""Creating new LocalDatastoreHelper"" logged many times instead of once: https://github.com/objectify/objectify/blob/v6/src/test/java/com/googlecode/objectify/test/util/LocalDatastoreExtension.java  If I had to take a wild guess, the surefire plugin is forking for every test class? If this is something that can be fixed as a parameter to surefire, can we put instructions in the Junit5 maven chapter?","closed","3rd-party: Maven Surefire,","stickfigure","2017-12-21T22:26:13Z","2019-07-19T19:32:23Z"
"","1685","Tags are not being picked up correctly","I am using JUnit 5.3.1 with Gradle 4.10.2 in the context of a medium sized application with a fair bit of legacy infrastructure, both for tests and for the build. I am trying to run a subset of my tests based on how they are tagged. However, running the following Gradle tasks picks up no tests at all: ``` task testIntegrationTests(type: Test) { 	useJUnitPlatform { 		includeTags 'IntegrationTest' 	} } ``` This is counter to the fact that such tests exist: ``` import org.myapp.IntegrationTest; import org.junit.experimental.categories.Category; import org.junit.jupiter.api.Tag;  @Tag(""IntegrationTest"") @Category(IntegrationTest.class) public class MyAppIntegrationTest {     ... } ``` As you can see, the test also is annotated with a JUnit 4 `@Category` annotation. This is where it gets weird, because substituting the following Gradle task for the previously mentioned one works and, in fact, selects the correct subset of tests: ``` task testIntegrationTests(type: Test) { 	useJUnitPlatform { 		includeTags 'org.myapp.IntegrationTest' 	} } ``` In other words, regular JUnit Platform Tags are not picked up by my Gradle Test Runner, while the autogenerated Category Tags are processed correctly.  I have tried removing the Category annotations altogether, to no discernible effect.  My hypothesis at this point is that I am seeing some weird corner case possibly created by the interplay of some dependencies, so I am going to provide the full set here: ``` 'org.junit.jupiter:junit-jupiter-api:5.3.1', 'org.junit.jupiter:junit-jupiter-engine:5.3.1', 'org.junit.jupiter:junit-jupiter-params:5.3.1', 'org.junit.vintage:junit-vintage-engine:5.3.1', 'org.junit.platform:junit-platform-launcher:1.3.1', 'org.junit.platform:junit-platform-suite-api:1.3.1', 'junit:junit:4.12', 'org.assertj:assertj-core:3.11.1', 'org.mockito:mockito-core:2.19.0', 'nl.jqno.equalsverifier:equalsverifier:2.4.7' ``` My question: How can I proceed debugging this to produce a minimal test case? I have found next to no information about tracing test discovery and selection through Gradle and JUnit Platform, so I am posting here in hope of some advice. What information can I provide that will make debugging this possible? (Note that my reason for not providing full build scripts here is that they are a horrible mess spread over twenty files that will take some considerable effort to comprehend, but if necessary I can post relevant extracts)","closed","3rd-party: Gradle,","scharfstein-dev","2018-11-20T20:32:04Z","2018-11-21T11:09:08Z"
"","1019","JUnit Platform Surefire Provider does not distinguish between failure and error","I am using JUnit 5 RC2 to execute the following simple test case, both with Maven and Gradle:  ```java package io.github.bonigarcia;  import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test;  class PlayingWithReportingTest {      @Test     void successTest() {         assertTrue(true);     }      @Test     void failureTest() {         assertTrue(false);     }      @Test     void errorTest() {         throw new RuntimeException(""This test is broken!"");     }  } ```  When running with Maven, I get the following:  ``` > mvn clean test [INFO] Scanning for projects... ...  -------------------------------------------------------  T E S T S ------------------------------------------------------- Running io.github.bonigarcia.PlayingWithReportingTest Tests run: 3, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.106 sec <<< FAILURE! - in io.github.bonigarcia.PlayingWithReportingTest errorTest()  Time elapsed: 0.021 sec  <<< FAILURE! java.lang.RuntimeException: This test is broken!         at io.github.bonigarcia.PlayingWithReportingTest.errorTest(PlayingWithReportingTest.java:37)  failureTest()  Time elapsed: 0.003 sec  <<< FAILURE! org.opentest4j.AssertionFailedError:         at io.github.bonigarcia.PlayingWithReportingTest.failureTest(PlayingWithReportingTest.java:32)   Results :  Failed tests:   PlayingWithReportingTest.errorTest:37 Runtime This test is broken!   PlayingWithReportingTest.failureTest:32  Tests run: 3, Failures: 2, Errors: 0, Skipped: 0 ```  ... which I think is incorrect, since I would expect that 1 test (`failureTest`) is declared as failure (assertion error), other one (`errorTest`) is declared and error (exception in the test), and the other one as success. Instead, the Maven output says there are 2 failures.  Moreover, when running the same test with Gradle:  ``` > gradle clean test :clean ...  Failures (2):   JUnit Jupiter:PlayingWithReportingTest:errorTest()     MethodSource [className = 'io.github.bonigarcia.PlayingWithReportingTest', methodName = 'errorTest', methodParameterTypes = '']     => java.lang.RuntimeException: This test is broken!   JUnit Jupiter:PlayingWithReportingTest:failureTest()     MethodSource [className = 'io.github.bonigarcia.PlayingWithReportingTest', methodName = 'failureTest', methodParameterTypes = '']     => org.opentest4j.AssertionFailedError:  Test run finished after 128 ms [         2 containers found      ] [         0 containers skipped    ] [         2 containers started    ] [         0 containers aborted    ] [         2 containers successful ] [         0 containers failed     ] [         3 tests found           ] [         0 tests skipped         ] [         3 tests started         ] [         0 tests aborted         ] [         1 tests successful      ] [         2 tests failed          ]  :junitPlatformTest FAILED ```  Similaryly, there are 2 tests declared as failure and besides, the output says there that 2 containers found, but if I'm not wrong there should be just one, since there is only one test class in the project.  Is this a bug or I am misinterpreting something here?  Thanks in advance. Keep up with great work!  PS: Source code [here](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-reporting).","closed","3rd-party: Maven Surefire,","bonigarcia","2017-08-15T00:14:34Z","2017-08-19T18:47:18Z"
"","1020","Gradle plugin seems incompatible with TestReport","I am trying to generate an HTML test report using JUnit 5 RC2 and Gradle. The content of my `build.gradle` is as follows:  ``` buildscript {     ext {         junitPlatformVersion = '1.0.0-RC2'     }     repositories {         mavenCentral()     }     dependencies {         classpath(""org.junit.platform:junit-platform-gradle-plugin:${junitPlatformVersion}"")     } }  repositories {     mavenCentral() }  ext {     junitJupiterVersion  = '5.0.0-RC2' }  apply plugin: 'java' apply plugin: 'eclipse' apply plugin: 'idea' apply plugin: 'org.junit.platform.gradle.plugin'  jar {     baseName = 'junit5-reporting'     version = '1.0.0' }  compileTestJava {     sourceCompatibility = 1.8     targetCompatibility = 1.8     options.compilerArgs += '-parameters' }  dependencies {     testCompile(""org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}"")     testRuntime(""org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}"") }  test {     reports.junitXml.enabled = true     reports.html.enabled = true } ```  The important part is in the final (`test`). In theory, with that part, the XML test result should be available, but also some human-readable HTML. The fact if that when running some tests (`gradle test`) the XML is avaiable, but the HTML is not.  If I remove the following line:  apply plugin: 'org.junit.platform.gradle.plugin'  ... then the HTML is available, but empty since Jupiter are not recognized:  ![image](https://user-images.githubusercontent.com/5413013/29297497-b408befe-8161-11e7-9ab2-672c21fd3250.png)  Is there any plan to support HTML reporting in `org.junit.platform.gradle.plugin`?  Thank you again.  PS: Source code [here](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-reporting).","closed","3rd-party: Gradle,","bonigarcia","2017-08-15T00:38:00Z","2017-08-15T22:27:09Z"
"","1439","Enhance DynamicTest API to support ""ignored"" tests so that I can see them in the test reports","I am planning to use `DynamicTest` API to as a kind of proxy to create and run tests inside an IDE or Maven which are written in XML and stored on a filesystem.  The tests stored on the filesystem include the concept of an ignored test, which is a feature supported by JUnit 4 via `@Ignore` and JUnit 5 via `@Disabled`, where the ignored/disabled test is shown visibly on the IDE test UI, or in the HTML JUnit reports generated by Maven.  However, I am not aware of a way to declare an ignored test via the `DynamicTest` API so that the ignored test is shown in the test reporting in IDE or HTML reports, as can be done for a static test.  I would like to see the `DynamicTest` API extended to allow me to dynamically ignore tests so that the ignored tests are shown in the UI rather than simply disappearing.  Hopefully this should be quite trivial to implement ;-)","closed","theme: dynamic tests,","k1w1m8","2018-05-31T23:45:36Z","2018-10-15T02:15:14Z"
"","1275","Improve documentation for @ParameterizedTest","I am migrating a Spring App from JUnit 4 to 5. The purpose is only have the API for JUnit 5.  Currently the following works fine with JUnit **4**  **Alpha** ``` @Transactional @RunWith(Parameterized.class) @ActiveProfiles(resolver=TestJdbcActiveProfilesResolver.class) @ContextConfiguration(classes={RootApplicationContext.class}) @TestExecutionListeners(listeners={LoggingTestExecutionListener.class}, mergeMode=MergeMode.MERGE_WITH_DEFAULTS) public class PersonaJdbcRepositoryTest {      private static final Logger logger = LoggerFactory.getLogger(PersonaJdbcRepositoryTest.class.getSimpleName());      @ClassRule     public static final SpringClassRule SPRING_CLASS_RULE = new SpringClassRule();      @Rule     public final SpringMethodRule springMethodRule = new SpringMethodRule();      ...      @Parameters     public static Collection data() { 	return Arrays.asList(new Persona[][] { 	       //something to do 	 });     }      public PersonaJdbcRepositoryTest(Persona persona){ 	this.persona = persona;     }      @Test     public void aTest(){       ...     }      @Test     public void bTest(){       ...     }      ...  } ```  After to read the following documentation:  * [3.13. Parameterized Tests](http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests) * [JUnit 5 – Parameterized Tests](https://blog.codefx.org/libraries/junit-5-parameterized-tests/)  I have tried the following in JUnit **5** and works fine.  **Beta** ``` @Transactional @SpringJUnitConfig(classes={RootApplicationContext.class}) @ActiveProfiles(resolver=TestJdbcActiveProfilesResolver.class) @TestExecutionListeners(listeners={LoggingTestExecutionListener.class}, mergeMode=MergeMode.MERGE_WITH_DEFAULTS) class PersonaJdbcRepositoryTest {  	private static final Logger logger = LoggerFactory.getLogger(PersonaJdbcRepositoryTest.class.getSimpleName());  //	@ClassRule //	public static final SpringClassRule SPRING_CLASS_RULE = new SpringClassRule(); // //	@Rule //	public final SpringMethodRule springMethodRule = new SpringMethodRule();  	static Collection data() { 		return Arrays.asList(new Persona[][] { 	        {PersonaFactory.crearPersona01()}, 	        {PersonaFactory.crearPersona02()}, 	        {PersonaFactory.crearPersona03()}, 	        {PersonaFactory.crearPersona04()}, 	        {PersonaFactory.crearPersonaMix()} 	    }); 	}  	static Stream dataa(){ 		return Stream.of( 				PersonaFactory.crearPersona01(), 		                PersonaFactory.crearPersona02(), 		                PersonaFactory.crearPersona03(), 		                PersonaFactory.crearPersona04(), 		                PersonaFactory.crearPersonaMix()); 	}  //	public PersonaJdbcRepositoryTest(Persona persona){ //		this.persona = persona; //	}  	//@Test 	@ParameterizedTest 	@MethodSource(""data"") 	@Sql(scripts={""classpath:/com/manuel/jordan/db/delete.sql""}) 	void saveOneTest(Persona persona){ 		... 	}          ...  } ```  From above I have the following points (please consider in explain each point adding each answer to the Reference Documentation for the community, I think would be valuable).  1. I am concerned that `@ParameterizedTest` be experimental, it means that it would be disappear. Am I correct? If yes, how would be replaced? It would be complicated for many Test classes, consider the long refactor. 2. `@MethodSource` can works with either `data` or `dataa` methods, thus the documentation should explain if is mandatory use a method returning a `Stream` or not. 3. For `@MethodSource` is mandatory use it together with `@ParameterizedTest` and not with `@Test`, if the latter is used, I get:  ``` org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [com.manuel.jordan.domain.Persona arg0] in executable [void com.manuel.jordan.repository.jdbc.PersonaJdbcRepositoryTest.saveOneTest(com.manuel.jordan.domain.Persona)]. 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:191) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:174) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:135) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:116) 	at  ``` Consider add a new feature about use `@Test` working with and without `@MethodSource`. It because consider the complications about do a migration of `@Test` to `@ParameterizedTest` from many Test classes according JUnit 4 to 5 working in a Parameterized scenario  4. Even when is possible reduce some code (see the commented lines in **Beta**), seems is mandatory add a parameter for each test method, when `@MethodSource` and `@ParameterizedTest` are used. In some way would be verbose, but I am OK with this new approach until some point. Just curious if `@MethodSource` (or a new annotation variation) would be added to work with a constructor and in this way avoid add a new parameter for each test method. Something like:  ```         @MethodSource(""data"") 	public PersonaJdbcRepositoryTest(Persona persona){ 		this.persona = persona;	         }  	@Test 	@Sql(scripts={""classpath:/com/manuel/jordan/db/delete.sql""}) 	void saveOneTest(){ 		... 	} ```  Practically the same approach that `@Parameters` in JUnit 4. I hope you see my point  Thanks in advance by your support.","closed","theme: parameterized tests,","manueljordan","2018-02-01T03:04:36Z","2018-05-21T14:03:10Z"
"","1327","Getting PreconditionViolationException: Classpath resource does not exist: /JuntTest.csv","I am getting below exception while using `@ParameterizedTest` with `@CsvFileSource`, even though the `JunitTest.csv` file is present in `src/test/resources`.   Can someone help on this?  **Test Method:**   ```java     @ParameterizedTest     @CsvFileSource(resources = ""/JuntTest.csv"")     void testCsvFileSource(String col1, String col2, String col3){         System.out.println(""Column1: ""+col1+"" Column2: ""+col2+"" Column3: ""+col3);     } ```  **Maven Dependencies:**  ```xml              UTF-8         5.1.0         5.1.0         1.1.0                            org.junit.jupiter             junit-jupiter-api             ${junit.jupiter.version}             test                               org.junit.jupiter             junit-jupiter-params             ${junit.jupiter.version}             test                                org.junit.jupiter             junit-jupiter-engine             ${junit.jupiter.version}             test                               org.junit.vintage             junit-vintage-engine             ${junit.vintage.version}             test          ```  **Exception:**     ```     org.junit.platform.commons.util.PreconditionViolationException: Classpath resource does not exist: /JuntTest.csv  	at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:297) 	at org.junit.platform.commons.util.Preconditions.notNull(Preconditions.java:69) 	at org.junit.jupiter.params.provider.CsvFileArgumentsProvider.openInputStream(CsvFileArgumentsProvider.java:78) 	at org.junit.jupiter.params.provider.CsvFileArgumentsProvider.lambda$provideArguments$0(CsvFileArgumentsProvider.java:70) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:101) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:38) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:112) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:65) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 	Suppressed: org.junit.platform.commons.util.PreconditionViolationException: Configuration error: You must provide at least one argument for this @ParameterizedTest 		at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:297) 		at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$7(ParameterizedTestExtension.java:60) 		at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) 		at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:271) 		... 52 more ```","closed","theme: parameterized tests,","Rajaram-Chelladurai","2018-03-16T02:28:34Z","2019-01-10T23:05:18Z"
"","1339","Getting org.junit.platform.commons.util.PreconditionViolationException: Classpath resource does not exist: /JuntTest.csv #1327","I am getting below exception while using @parameterizedtest with @csvfilesource. Can someone help on this?  Test Method: @parameterizedtest @csvfilesource(resources = ""/JuntTest.csv"") void testCsvFileSource(String col1, String col2, String col3){ System.out.println(""Column1: ""+col1+"" Column2: ""+col2+"" Column3: ""+col3); } JunitTest.csv file present in src/test/resources  Maven Dependencies:  UTF-8 5.1.0 5.1.0 1.1.0              org.junit.jupiter         junit-jupiter-api         ${junit.jupiter.version}         test                   org.junit.jupiter         junit-jupiter-params         ${junit.jupiter.version}         test                    org.junit.jupiter         junit-jupiter-engine         ${junit.jupiter.version}         test                   org.junit.vintage         junit-vintage-engine         ${junit.vintage.version}         test      Exception: org.junit.platform.commons.util.PreconditionViolationException: Classpath resource does not exist: /JuntTest.csv  at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:297) at org.junit.platform.commons.util.Preconditions.notNull(Preconditions.java:69) at org.junit.jupiter.params.provider.CsvFileArgumentsProvider.openInputStream(CsvFileArgumentsProvider.java:78) at org.junit.jupiter.params.provider.CsvFileArgumentsProvider.lambda$provideArguments$0(CsvFileArgumentsProvider.java:70) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:101) at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:38) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:112) at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) at java.util.Iterator.forEachRemaining(Iterator.java:116) at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) at java.util.Iterator.forEachRemaining(Iterator.java:116) at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55) at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:65) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Suppressed: org.junit.platform.commons.util.PreconditionViolationException: Configuration error: You must provide at least one argument for this @ParameterizedTest 	at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:297) 	at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$7(ParameterizedTestExtension.java:60) 	at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:271) 	... 52 more","closed","theme: parameterized tests,","CybertekSchool","2018-03-21T21:06:30Z","2018-03-21T21:27:55Z"
"","1314","DisplayName not working","I am currently using junit5 jupiter for all my tests, and would like to report that the displayname has no effect either in the netbeans test results window or launching maven test phase from the terminal. The default java name is used in both cases.","closed","status: duplicate,","dnccfu","2018-02-25T21:33:16Z","2018-02-26T18:30:09Z"
"","1482","Kotlin @ParameterizedTest with @MethodSource results in failed test with No ParameterResolver registered","I am beginning to write some unit tests in Kotlin and tried to create a @ParameterizedTest, but there appears to be an issue.  Oddly, the test actually runs and succeeds, but the IntelliJ UI also shows that the test class fails presumably in some setup phase.  The test class shows a failure, the test itself succeeds.  I see the following error message:  `org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [java.lang.String arg0] in method [public final void fitpay.automation.api.kotlin.model.ParameterizedTests.Anonymous users(java.lang.String)] `  My test looks like:  ``` class ParameterizedTests {     companion object {         @JvmStatic fun anonymousUserProviders(): List {             return listOf(                     arguments(""test 1""),                     arguments(""test 2"")             )         }     }      @ParameterizedTest     @MethodSource(""anonymousUserProviders"")     @Test fun `Anonymous users`(_testName: String) {         assertNotNull(_testName)     } }   I am using 5.3.0-M1","closed","","dlanaghen","2018-06-28T18:43:37Z","2018-06-28T19:08:02Z"
"","1374","Code Styling via Intellij","I am an intellij user, and it seems like the default Intellij project files set the import order to be different than what you guys specified in the [CONTRIBUTING.md > Formatting](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#formatting) section, thus the arrangement of import ordering conflicts directly between the two styles.  This manifest itself as when a developer applies the `Cmd + Alt + L` (format code) command to intellij, the order will change once (via the intellij formatting style) then immediately a second time (via the enabled eclipse formatter).  This can be confusing since the order of formatters seems to be non-deterministic, thus leaving the developer in an unknown state of proper formatting.  I realize that applying `./gradlew spotlessApply` can fix this on an ad-hoc basis, but it might be better to have tooling that directly alters the default Intellij project code style files, instead of bypassing it through a third-party plugin.","closed","status: waiting-for-feedback,","dotCipher","2018-04-16T20:49:16Z","2020-03-29T16:11:05Z"
"","1373","Add link to RepetitionInfoParameterResolver in User Guide","I added a link to `RepetitionInfoParameterResolver.java` from User Guide (""3.11. Dependency Injection for Constructors and Methods"") because other two resolvers (i.e. `TestInfoParameterResolver` and `TestReporterParameterResolver`) have links to their source code.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","oohira","2018-04-15T14:16:51Z","2018-04-16T13:25:19Z"
"","1521","@TestFactory should be able to return a single DynamicNode","I [experimented](https://github.com/CodeFX-org/demo-junit-5/blob/0dbfbfdade3995cbf35541449fe60ebde95d9aa3/src/test/java/org/codefx/demo/junit5/dynamic/ArithmeticTreeTest.java) with using dynamic tests to generate a hierarchical structure that mirrors the test data's structure (went well), and I came up with one minor possible improvement:  Allow test factory methods to return a single `DynamicNode`.  I ended up there because my input data was a tree, which has just a single top-level node, so I created a test plan with a single top-level `DynamicContainer`. Wrapping that in a `Stream` is not complicated, but unnecessary.","closed","theme: dynamic tests,","nipafx","2018-08-03T14:13:55Z","2018-11-25T14:16:27Z"
"","1549","gh-pages: added Droidcon NY","https://www.nyc.droidcon.com/","closed","","dpreussler","2018-08-15T20:32:52Z","2018-08-16T06:12:55Z"
"","1295","How to use slf4 in gradle as logger","https://junit.org/junit5/docs/current/user-guide/#running-tests-build-gradle-junit-configure only shows up to use jul to log4j ... but gradle typically logs via slf4  related to / tried to workaround https://github.com/junit-team/junit5/issues/1166  ``` plugins {     id ""java-gradle-plugin""     // see https://github.com/junit-team/junit5/issues/768     id(""org.junit.platform.gradle.plugin"") version '1.0.3' }  buildscript {   dependencies {     // classpath 'org.apache.logging.log4j:log4j-core:2.10.0'     classpath 'org.apache.logging.log4j:log4j-jul:2.10.0'     classpath 'org.slf4j:log4j-over-slf4j:1.7.25'   } }  junitPlatform {     logManager 'org.apache.logging.log4j.jul.LogManager' } ```  still ends up in  `ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console...`  when adding `logback-classic` we get an additional ``` SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/home/marcel/.gradle/caches/4.5/generated-gradle-jars/gradle-api-4.5.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/home/marcel/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.2.3/7c4f3c474fb2c041d8028740440937705ebb473a/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [org.gradle.internal.logging.slf4j.OutputEventListenerBackedLoggerContext]  ```  I admit: this logging stuff is a way brainfucked ... or I am :D","closed","3rd-party: Gradle,","childnode","2018-02-14T15:13:07Z","2018-02-14T16:28:56Z"
"","1717","Introduce platform mechanism to switch off conditions","https://github.com/junit-team/junit5/issues/78 solved the problem for just Jupiter and (probably) Vintage. If other engines introduce the same all IDEs will have to adapt to each engine's naming of params and values.  I suggest to either: - Choose config param name that is agnostic to engine. Currently it is `junit.jupiter.conditions.deactivate`.  This will also require to standardize the possible values which currently refer to class names in Jupiter/Vintage. - Add dedicated property  in `ConfigurationParameters` e.g. `ConfigurationParameters.getDeactivatedConditions() : List`.  Any other ideas?","closed","status: stale,","jlink","2019-01-01T13:01:57Z","2021-06-19T12:50:14Z"
"","1357","Upgrade to Gradle 4.7-rc-1","https://docs.gradle.org/4.7-rc-1/release-notes.html","closed","","sormuras","2018-04-03T16:30:30Z","2018-04-03T17:00:27Z"
"","1421","howto ? : Adding metainfo that is in CSV, HTML, XML and JUnit XML reports : enhancement?","How can arbitrary information be added to the JUnit run (per class and per method)?  Prefer in an annotation.  If not possible now, please consider this a feature/enhancement request. examples: requirements number, reference number, some external info  Want the data to show up in: - results data; xml, csv - reports : html  Ideally to work in JUnit4 AND JUnit5","closed","theme: reporting,","hanasaki","2018-05-15T19:55:44Z","2018-05-27T15:26:37Z"
"","1827","Let Assert.fail have an arbitrary return type","How about letting `Assert.fail(...)` pretend that it returns something of a generic type `T`?      public static  T fail() { ... }  this would be backward compatible in all regards, but also allow for expressions like      String result = x == 1 ? ""one""                   : y == 2 ? ""two""                   : z == 3 ? ""three""                   : fail();  Refer to this blog post: https://aioo.be/2016/06/28/returning-assert-method.html","closed","theme: programming model,","aioobe","2019-03-20T03:29:32Z","2019-03-20T13:15:18Z"
"","1678","Abstract slides, flyer, sticker?","Hi. I´d like to promote JUnit 5 inside my company, do you provide any kind of abstract or open slides that i can use? By chance, do you have kind of abstract or sth. like a onepager/flyer, that i can drop at the right table?","closed","status: stale,","onemanagency","2018-11-13T09:49:25Z","2021-06-19T12:50:05Z"
"","1756","@RegisterExtension instance field is not disposed in @Nested classes","Hi, just tried using [this AssertJ feature](http://joel-costigliola.github.io/assertj/assertj-core-news.html#assertj-core-3.11.0-junit5-soft-assertions)  The following test class fails both tests but should only faild test `one`.  ```java import org.assertj.core.api.JUnitJupiterSoftAssertions; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestInstance; import org.junit.jupiter.api.extension.RegisterExtension;  @TestInstance(TestInstance.Lifecycle.PER_METHOD) public class Bla {      @RegisterExtension     public final JUnitJupiterSoftAssertions softly = new JUnitJupiterSoftAssertions();      @BeforeEach     void setUp() {        //in IDEA place a breakpoint to NOT suspend and log and evaluate softly.hashcode()         System.out.println(""before"");     }      @Nested     class A {                      @Test         void one() {             softly.assertThat(1).isEqualTo(2);         }          @Test         void two() {             softly.assertThat(1).isEqualTo(1);         }     } } ```  Also, go into JUnitJupiterSoftAssertions#afterEach and also place a breakpoint to log `this.hashcode()` when `errors` is not empty.  The problem is actually fixed by removing the nested class and just putting both tests into the root. Or by placing the field and setUp into the nested class. So, the `@Nested` breaks everything here.   Versions: assertJ 3.11.1 Junit 5.3.2 open jdk 11.0.1 kotlin 1.3.11 IntelliJ IDEA 2018.3.4 (Ultimate Edition) macOS 10.13.6","closed","component: Jupiter,","Sam-Kruglov","2019-02-01T13:53:58Z","2019-02-01T14:00:13Z"
"","1341","maven-surefire-plugin 2.21.0 does not detect JUnit tests","Hi, I'm trying to integrate JUnit 5 using the maven-surefire-plugin 2.21.0. But when I use that version, either JUnit5 nor JUnit4 tests are found/run.  Steps to reproduce: ``` git clone https://github.com/junit-team/junit5-samples.git cd junit5-samples/junit5-maven-consumer mvn test ... # All tests are run vim pom.xml # change maven-surefire-plugin version to 2.21.0 mvn test ... # No tests are run ```  Is this behavior intended, do I miss something?  You could also add org.junit.jupiter:junit-jupiter-engine to the surefire dependencies, but it wouldn't make a difference: ```      org.junit.jupiter     junit-jupiter-engine     ${junit.jupiter.version}  ```  Related issue: https://github.com/junit-team/junit5/issues/809#issuecomment-330488537","closed","3rd-party: Maven Surefire,","galan","2018-03-22T07:20:55Z","2018-03-22T17:31:30Z"
"","1150","Cannot compile on the command-line","Hi, I am new to gradle and junit5. After I run `gradle clean test` in the Terminal, I got:  ```  > Task :junit-platform-commons-java-9:compileJava FAILED /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:19: error: package java.lang.module does not exist import java.lang.module.ModuleFinder;                        ^ /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:20: error: package java.lang.module does not exist import java.lang.module.ModuleReader;                        ^ /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:21: error: package java.lang.module does not exist import java.lang.module.ModuleReference;                        ^ /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:22: error: package java.lang.module does not exist import java.lang.module.ResolvedModule;                        ^ /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:117: error: cannot find symbol         private static Stream boot(Predicate moduleNamePredicate) {                               ^   symbol:   class ResolvedModule   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:123: error: cannot find symbol         private static List> scan(Set references, ClassFilter filter, ClassLoader loader) {                                                ^   symbol:   class ModuleReference   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:150: error: cannot find symbol                 List> scan(ModuleReference reference) {                                     ^   symbol:   class ModuleReference   location: class ModuleReferenceScanner /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:68: error: cannot find symbol                 Set systemModules = ModuleFinder.ofSystem().findAll().stream()                                             ^   symbol:   variable ModuleFinder   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:72: error: cannot find symbol                                 .map(ResolvedModule::name)                                      ^   symbol:   variable ResolvedModule   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:87: error: cannot find symbol                 return Optional.of(type.getModule().getName());                                        ^   symbol:   method getModule()   location: variable type of type Class /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:91: error: cannot find symbol                 Module module = type.getModule();                 ^   symbol:   class Module   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:91: error: cannot find symbol                 Module module = type.getModule();                                     ^   symbol:   method getModule()   location: variable type of type Class /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:109: error: cannot find symbol                 Set moduleReferences = boot(isEqual(moduleName))                     ^   symbol:   class ModuleReference   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:110: error: cannot find symbol                                 .map(ResolvedModule::reference)                                      ^   symbol:   variable ResolvedModule   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:118: error: cannot find symbol                 Stream stream = ModuleLayer.boot().configuration().modules().stream();                        ^   symbol:   class ResolvedModule   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:118: error: cannot find symbol                 Stream stream = ModuleLayer.boot().configuration().modules().stream();                                                 ^   symbol:   variable ModuleLayer   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:127: error: cannot find symbol                 for (ModuleReference reference : references) {                      ^   symbol:   class ModuleReference   location: class ModuleUtils /Users/bird/eclipse-workspace/junit5/junit-platform-commons-java-9/src/main/java/org/junit/platform/commons/util/ModuleUtils.java:151: error: cannot find symbol                         try (ModuleReader reader = reference.open()) {                              ^   symbol:   class ModuleReader   location: class ModuleReferenceScanner 18 errors   FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':junit-platform-commons-java-9:compileJava'. > Compilation failed; see the compiler error output for details.  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.  * Get more help at https://help.gradle.org  BUILD FAILED in 19s 43 actionable tasks: 43 executed ```  I am on master branch (ec6d727). My java version is 1.8.0_151-b12 and my gradle version is 4.3.","closed","","yiming-tang-cs","2017-11-08T07:16:39Z","2017-11-08T16:55:58Z"
"","999","Extension request","Hi,   Is it possible to add a new extension with which I can determine 'how' a test is executed. 'how' here means that, for example, I can determine which thread my tests should be executed. I just don't want to wrap each test with some skeleton codes (almost the same) to archive that. thanks","closed","component: Jupiter,","seventh7me","2017-08-03T14:02:38Z","2017-08-03T17:41:28Z"
"","1696","Make ParameterizedTestExtension public.","Hi,  Using Using: JUnit: 5.3.2  ## Problem Let's assume that I am testing on different browsers that a title, on a single website, is equals to ""Junit5"". I do that using the convenient test template (TestTemplateInvocationContextProvider) feature. A TestTemplateInvocationContext by browser. That scenario works really well.  As of today a new use case came up. I need to do the same on two different sites and one of them will always have ""Junit4"" for title.  ## What I want to do : I would like to mix my custom Extension with the ParameterizedTestExtension extension.  ### What I guessed after a quick look at the Jupiter Engine Annotating the tests methods with both annotations (SeleniumExtension and ParametrizedExtension) does not work. This is expected as the jupiter engine only picks and uses only the first TestTemplateInvocationContextProvider he finds. That behavior makes perfect sense as it is impossible to easily guess how the two lists of TestTemplateInvocationContext should be merged.  ## How I would do it My idea is to create a TestTemplateInvocationContextProvider wrapper containing both Extensions that way I could choose how to merge them.  Unfortunately, ParametrizedExtension is not public and I'd rather avoid using introspection to get the object.  ## Deliverables Would you consider making ParametrizedExtension public ? Or do you have a better idea ?  Thanks for your help.","closed","theme: parameterized tests,","grunenwflorian","2018-12-07T16:46:04Z","2018-12-10T12:35:59Z"
"","1947","Make MAX_STACKTRACE_LINES in MutableTestExecutionSummary configurable","Hi,  running tests programmatically with a   ```java Launcher launcher = LauncherFactory.create(); ```  where I register a `SummaryGeneratingListener`. Unfortunately, the failure messages are of limited use, as `MutableTestExecutionSummary.MAX_STACKTRACE_LINES` is a constant set to the low value of 10. It would be good if such value could be configurable in `SummaryGeneratingListener`, or at least provide a higher default (e.g., 30 or 50).  This issue seems somehow related to #1693.","closed","component: Platform,","arcuri82","2019-07-03T20:57:52Z","2019-07-16T14:26:22Z"
"","1494","maven-surefire-plugin is skipping/not finding tests","Hi,  Recently in our hadoop project, we added maven-surefire-plugin for running unit tests by categories.  in hadoop root pom.xml:                 junit         junit         4.11        . .      org.apache.hadoop.classification.TestJUnitCategory$AllTests     4.11                      org.apache.maven.plugins           maven-surefire-plugin           2.21.0                        ${test.groups}                                  flakies                org.apache.hadoop.classification.TestJUnitCategory$FlakiesTest                        stables                org.apache.hadoop.classification.TestJUnitCategory$StablesTest                        integrations                org.apache.hadoop.classification.TestJUnitCategory$IntegrationsTest                        none                !org.apache.hadoop.classification.TestJUnitCategory$AllTest                 Invoking tests by category works fine: mvn -P integrations. However, our old fashioned unit test execution got skipped by this maven-surefire-plugin:  13:16:35 [INFO] --- maven-antrun-plugin:1.7:run (create-log-dir) @ hadoop-hdfs --- 13:16:35 [INFO] Executing tasks 13:16:35  13:16:35 main: 13:16:35    [delete] Deleting directory /tmp/tmp.o7flMN8505/src/ghuang/ghuang/hadoop-hdfs-project/hadoop-hdfs/target/test/data 13:16:35     [mkdir] Created dir: /tmp/tmp.o7flMN8505/src/ghuang/ghuang/hadoop-hdfs-project/hadoop-hdfs/target/test/data 13:16:35      [copy] Copying 16 files to /tmp/tmp.o7flMN8505/src/ghuang/ghuang/hadoop-hdfs-project/hadoop-hdfs/target/test-classes/webapps 13:16:35 [INFO] Executed tasks 13:16:35 [INFO]  13:16:35 [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hadoop-hdfs --- 13:16:35 [INFO] Nothing to compile - all classes are up to date 13:16:35 [INFO]  13:16:35 [INFO] --- maven-surefire-plugin:2.20:test (default-test) @ hadoop-hdfs --- 13:16:35 [INFO] Surefire report directory: /tmp/tmp.o7flMN8505/src/ghuang/ghuang/hadoop-hdfs-project/hadoop-hdfs/target/surefire-reports 13:16:35 [INFO] parallel='none', perCoreThreadCount=true, threadCount=0, useUnlimitedThreads=false, threadCountSuites=0, threadCountClasses=0, threadCountMethods=0, parallelOptimized=true 13:16:35 [INFO]  13:16:35 [INFO] ------------------------------------------------------- 13:16:35 [INFO]  T E S T S 13:16:35 [INFO] ------------------------------------------------------- 13:26:01 [INFO]  13:26:01 [INFO] Results: 13:26:01 [INFO]  13:26:01 [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 13:26:01 [INFO]  13:26:01 [INFO]  13:26:01 [INFO] --- maven-antrun-plugin:1.7:run (hdfs-test-bats-driver) @ hadoop-hdfs ---  I also verified that by removing surefire-plugin block in root pom.xml file will make these tests executing again as usual. So I have some questions here:  1. I saw the reported surefire-plugin version was 2.20 while I was defining 2.21 in my change. This is because it gets overwritten by the parent pom. So how do I make it use my customized version.  2. Is the version 2.21 the right version for this? I saw some post indicated version 2.21 might have some bug?  3. What is the fix for this issue?  Many thanks, George","closed","","ghuangups","2018-07-10T21:20:11Z","2018-07-25T18:21:49Z"
"","1493","DiscoverySelectors#selectPackage does not select packages from JAR","Hi,  I use JUnit 5.2.0 and I want to select classes from package that locate in jar file. ```         LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request().selectors(selectPackage(""my.custom.package"")).build();         Launcher launcher = LauncherFactory.create();         launcher.execute(request); ```  If my package exists as file: URL=`file:/path_to_project/target/my/custom/package` it works fine, but if this package locate in jar: URL=`jar:file:/path_to_jar/tests.jar!/my/custom/package/` org.junit.platform.commons.util.ClasspathScanner does not find it.  Solution:  [ClasspathScanner](https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClasspathScanner.java#L211) should append `/` symbol  at the end:  ``` now: packagePath(""my.custom.package"") -> ""my/custom/package"" with fix: packagePath(""my.custom.package"") -> ""my/custom/package/"" ``` Because `getClassLoader().getResources(String)` on [line 217](https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClasspathScanner.java#L217) expect such result from `packagePath` method.","closed","component: Platform,","artem-fedorov","2018-07-10T13:59:33Z","2018-07-28T17:53:41Z"
"","1507","Help with maven surefire plugin configurations","Hi,  I need some help with maven surefire plugin. My original post is at here: https://github.com/junit-team/junit5/issues/1494 which was two week ago :(  However, it has been a long time and I'm not getting anywhere. Can some one please help? Is there anyone I can contact/talk to besides post an issue here? I can be reached at j.huang@cloudera.com.  Thanks in advance, George","closed","","ghuangups","2018-07-24T22:44:01Z","2018-07-25T18:23:21Z"
"","1106","There was an error in the forked process","Hi,  I have integrated my selenium web framework with the Git hub, which is successfully running on my windows machine, but same thing when iam trying to run on the Jenkins slave machine(linux, ubuntu), getting the following error.  My `pom.xml` looks like this  ```xml   	4.0.0 	TestingXperts 	com.testautomation 	0.0.1-SNAPSHOT 	jar 	http://maven.apache.org 	 		UTF-8 		1.8 		1.8 		${project.basedir}  	 	 		 			org.apache.maven 			maven-plugin-api 			3.3.9 		 		 			org.testng 			testng 			6.9.13.6 		 		 			org.seleniumhq.selenium 			selenium-java 			3.0.1 		  		 			xml-apis 			xml-apis 			1.4.01 		 		 			org.apache.poi 			poi 			3.15 		 		 			org.apache.poi 			poi-ooxml 			3.15 		 		 			log4j 			log4j 			1.2.17 		  		 		 			com.relevantcodes 			extentreports 			2.41.2 		  		 			org.apache.commons 			commons-csv 			1.4 		 		 			ru.yandex.qatools.ashot 			ashot 			1.5.3 		 		 			com.itextpdf 			itextpdf 			5.5.6 		 		 			mysql 			mysql-connector-java 			5.1.39 		 		 			org.xerial 			sqlite-jdbc 			3.8.11.2 		 		 			commons-io 			commons-io 			2.5 		 		 			com.google.guava 			guava 			19.0 		 		 			javax.mail 			mail 			1.4 		  		  		 			org.apache.xmlrpc 			xmlrpc-client 			3.1.3 		 		 			com.dropbox.core 			dropbox-core-sdk 			2.1.1 		    		 		 			commons-logging 			commons-logging 			1.1 		 		 		 			org.apache.ws.commons.util 			ws-commons-util 			1.0.2 		 		 org.apache.xmlrpc xmlrpc-client  			3.1.3  --> 		 org.apache.xmlrpc xmlrpc-common  			3.1.3  -->   		 		 			com.fasterxml.jackson.core 			jackson-databind 			2.4.1.3 		 		 			com.sun.jersey 			jersey-client 			1.8 		  		 			org.json 			json 			20090211 		  		 		 			org.apache.httpcomponents 			httpclient 			4.5.2 		 		 			commons-codec 			commons-codec 			20041127.091804 		  		 			org.apache.httpcomponents 			httpmime 			4.3.1 		 	 	     com.jayway.restassured     rest-assured     2.9.0  		  	  	 		test 		src/main/java 		src/test/java  		 			  				 					org.codehaus.sonar-plugins 					sonar-timeline-plugin 					1.4 				 				 					org.sonarsource.scanner.maven 					sonar-maven-plugin 					3.2 				  				 					org.apache.maven.plugins 					maven-compiler-plugin 					3.6.0 					 						true 						true 						${JAVA_HOME}/bin/javac 						1.8 						1.8 						1.8 					 				  				 				 					org.apache.maven.plugins 					maven-surefire-plugin 					2.19.1 					 					 						 						 						                          true                           						 							 								 								surefire.testng.verbose 								2 							 						 						 							 							testng.xml.swp 						 					 				 				 				 					org.apache.maven.plugins 					maven-javadoc-plugin 					2.10.4 				 			 		 	  	AutomationFramework   ```  The error stake looks like below.  ``` -------------------------------------------------------  T E S T S -------------------------------------------------------  Results :  Tests run: 0, Failures: 0, Errors: 0, Skipped: 0  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 7.691 s [INFO] Finished at: 2017-10-12T12:25:18+00:00 [INFO] Final Memory: 15M/237M [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test (default-test) on project com.testautomation: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test failed: There was an error in the forked process [ERROR] org.apache.maven.surefire.testset.TestSetFailedException: Suite file /home/jenkins/workspace/_automation-web-test_master-CKCPK3QTWAJWIZ523MR6MZUPAQLODM3AX23HU3Z7SICQ6ZD3TZKA@2/testng.xml.swp is not a valid file [ERROR] at org.apache.maven.surefire.testng.TestNGXmlTestSuite.locateTestSets(TestNGXmlTestSuite.java:98) [ERROR] at org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:120) [ERROR] at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:290) [ERROR] at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:242) [ERROR] at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:121) [ERROR] -> [Help 1] [ERROR]  [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/PluginExecutionException script returned exit code 1 ```  trying to resolve the issue from 2 days but could not get any working solution. tried adding mvn dependency::tree dint work..  My declarative jenkins file look like below  ``` pipeline {     agent { 	label 'qa-1'}     stages {         stage('Build') {             agent { 			label 'qa-1'} 			 			          steps {                 sh 'mvn clean'             } 		}         stage('Dependencies') {             agent {                  label 'qa-1'             }            steps {                 sh 'mvn dependency::tree'             }                  }         stage('Test on Linux') {             agent {                  label 'qa-1'             }            steps {                 sh 'mvn test'             }                  }     } } ```  Thanks in advance.","closed","status: invalid,","lavanyanalabolu","2017-10-13T10:33:14Z","2017-10-13T13:22:02Z"
"","1108","Unable to resolve org.junit.jupiter:junit-jupiter-api:5.0.1","Hi,  I am using gradle to download junit.  My gradle file is very simple. It just contains only the below few lines, but I got unable to resolve org.junit.jupiter:junit-jupiter-api:5.0.1.  Any idea why is that so?    My group id, artifact id and version number seems to be correct. And I am using kotlin-dsl for gradle.  ```groovy plugins {     java }  dependencies{     testCompile(""org.junit.jupiter:junit-jupiter-api:5.0.1"")  } ```","closed","status: works-as-designed,","hanct","2017-10-14T07:31:28Z","2022-04-30T09:14:49Z"
"","1365","Introduce ReflectiveFieldArguments for parameterized tests","Hi there,  Maybe this pull request is considered useful as I'm probably going to use this quite often with Lombok's `@AllArgsConstructor` in our code base.  The basic idea is just to have a class with a field definition that automatically produces arguments that can be then used e.g via `@MethodSource`.  Any comments or feedback is greatly appreciated.  If you think if that is useful, I will clean up the code and complete the documentation.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","nikowitt","2018-04-12T11:25:06Z","2019-07-20T15:14:40Z"
"","1206","Link to screencast in Wiki","Hi guys (I already asked on Twitter and Sam Brannen told me to open up a Github issue, so here we are:)  Although this might come off as blatant self promotion, I was wondering if you guys were willing to link to  [this screencast on ""What's new in Junit 5?""](https://www.marcobehler.com/episodes/93-what-s-new-in-junit-5) from the Wiki?  Cheers, Marco","closed","theme: web site,","marcobehler","2017-12-12T16:20:32Z","2017-12-13T14:22:09Z"
"","1628","Rerun failing parameterized test","Hi I need to rerun failed tests that are parameterized. But I didn't manage. The parametrization is preventing the rerun of failed tests.  In JUnit 4 I could use reluse and control the outcome the test very easy, but with JUnit 5 and parameterization I cannot do that anymore!!???  Any suggestions?  Cheers George","closed","theme: parameterized tests,","geokh77","2018-10-08T19:59:32Z","2018-12-01T15:47:56Z"
"","1238","Document the extension ordering","Hi  Can you please ensure the documentation contains how to sort extensions. Since Java sorts the annotations and keeps it into the bytecode, it is just a matter of writing the extension definition order is the one used - including nested levels of repeatable annotations. So using @SetEnv @StartServer will let the server use the env setup whereas @StartServer @SetEnv wouldnt.  Compared to Junit4 RuleChain this is way nicer but without it being explicit it can be seen as a hack since you need to check the code to ensure Junit 5 uses only array and lists and not sets for extensions.  Thanks, Romain","closed","component: Jupiter,","rmannibucau","2018-01-12T10:30:05Z","2018-01-12T17:19:07Z"
"","1703","Improve message of Assertions.assertDoesNotThrow","Here, https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertDoesNotThrow.java#L51-L52 and here https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertDoesNotThrow.java#L74-L75 only the `t.getClass().getName()` from the unexpected throwable is added to the message of the created `AssertionFailedError` instance. The message should also contain the `t.getMessage()` text from the unexpected throwable.  ## Deliverables  - [x] Attach non-empty message from the unexpected throwable","closed","component: Jupiter,","sormuras","2018-12-15T14:05:29Z","2018-12-17T21:35:32Z"
"","1700","JUnit data sets - Not failing when looking for NULL, if value is present.","Hello. Used both JUnit 4.12 and 4.13-beta-1. Also dbUnit 3.4.2 and 3.4.6 and also xmlunit both 1.3 and 1.6.  Firstly apologies if this is in the wrong place. I am also unsure if this issue is JUnit or dbUnit.   We are creating JUnits and using xml datasets as an expected result following running tests, to ensure data is as expected on our Oracle database.  We are now finding an issue, where if we look for null values in our dataset ([null]), it does not fail if the column we are checking does actually contain a value.  If we specify a value in the data set, which is different to the actual value in the colum, it will fail and tell us the difference.  So the issue is that the data set does not detect if a column has a value it in, when our data set is looking for a NULL value.  In the code snippet below, if there is a value on the table 'TABLE_NAME' in the column 'COLUMN_THREE', it will not throw an error.  ```              ```  Thank you very much for any information or help that can be provided and to all those who have put the work into this framework.  Stacks","closed","status: declined,","stacksamus","2018-12-12T14:58:37Z","2018-12-12T15:44:20Z"
"","1742","Failed timeout does not stop user code","Hello, I didn't find this issue reported.  On JUnit 5 (5.3.1.v20181005-1442) and also in JUnit 4 (4.12.0.v201504281640), when running the test below on eclipse (Version: 2018-12 (4.10.0) Build id: 20181214-0600) on Ubuntu 18.04, the timeout rule fails to stop de test.  ```java     @Rule     public Timeout globalTimeout = Timeout.millis(1000);      @Test     void test() { 	NaughtyList list = new NaughtyList();         list.add(1);     } ```  For the following class  ```java     public class NaughtyList { 	 	public static class NaughtyNode { 		public int value; 		public NaughtyNode next; 	} 	 	private NaughtyNode header; 	 	public NaughtyList() { 		header = new NaughtyNode(); 		header.value = Integer.MIN_VALUE; 	} 	 	public void add(int elem) { 		NaughtyNode current = header; 		while(true) { 			current.next = new NaughtyNode(); 			current = current.next; 			current.value = elem; 		} 	}      } ```  I know that this is an extreme case but I found this issue when doing some mutation testing experiments and some mutants caused an infinite loop on a very simple code that kept creating new objets.","closed","type: question,","saiema","2019-01-21T20:27:42Z","2020-04-29T08:07:58Z"
"","1769","Access method name in beforeAll extension point","Hello, I am writing a JUnit 5 extension.  ``` public void beforeAll(ExtensionContext extensionContext) { .. } ``` My custom code is being called, which is awesome.  But I can't seem to find a way to have a callback for methods marked with `@BeforeAll`.","closed","type: new feature,","MykolaGolubyev","2019-02-09T16:40:21Z","2019-11-01T12:07:07Z"
"","1180","Getting AbstractMethodError when running @ParameterizedTest","Hello,  I'm trying to run a very simple @ParameterizedTest:  ``` import static org.junit.jupiter.api.Assertions.assertEquals; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import org.junit.jupiter.params.provider.ValueSource; import java.util.ArrayList; import java.util.List; @DisplayName(""Test class for ReturnNegative"") public class ReturnNegativeTest {        @ParameterizedTest     @ValueSource(ints = {1,2,3,4,5})     public void testA(int v){         assertEquals(v, v);     } } ```  This is my pom.xml ```                                        org.apache.maven.plugins                 maven-surefire-plugin                 2.19.1                                                               org.junit.platform                         junit-platform-surefire-provider                         1.0.1                                                                   org.junit.jupiter                         junit-jupiter-engine                         5.0.1                                                                                            org.junit.jupiter             junit-jupiter-api             5.0.1             test                               org.junit.jupiter             junit-jupiter-engine             5.0.1             test                               org.junit.vintage             junit-vintage-engine             4.12.1             test                               org.junit.platform             junit-platform-launcher             1.0.1             test                               org.junit.platform             junit-platform-runner             1.0.1             test                               org.junit.jupiter             junit-jupiter-params             5.0.0-M4             test               ```  And this is the result: ``` ------------------------------------------------------------------------------- Test set: returnnegative.ReturnNegativeTest ------------------------------------------------------------------------------- Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.108 sec <<< FAILURE! - in returnnegative.ReturnNegativeTest testA(int)  Time elapsed: 0.097 sec  <<< ERROR! java.lang.AbstractMethodError ```","closed","","jcarroyo","2017-11-22T19:31:43Z","2017-11-22T22:35:47Z"
"","1736","Feature suggestion: Detect missing @Nested annotations","Hello there, and thanks for JUnit! :wave:  My team has recently migrated to JUnit 5, and previously we were previously using the [junit-hierarchicalcontextrunner](https://github.com/bechte/junit-hierarchicalcontextrunner) for nested tests. One big difference from that one is that on JUnit 5 the native nested tests require that nested classes be annotated with the `@Nested` annotation.  We've now been using it for a few weeks, and my team found that sometimes we forget to add an `@Nested` annotation to an inner class.  This leads to a test suite that is _apparently_ green, but that in reality is missing tests, and is hard to spot.  Would it be possible to either:  * add a validation that would warn us that we could possibly be missing `@Nested` -- by for instance detecting that a nested class had JUnit annotations on it but would not be executed  * have a mode/option/top-level annotation for executing tests in nested classes without needing an explicit `@Nested`  Thanks! :pray:   ## Related issues  * #242 * https://stackoverflow.com/questions/54107409/how-do-detect-missing-nested-annotations/54130013","open","theme: diagnostics,","ivoanjo","2019-01-17T17:04:41Z","2022-06-28T10:15:51Z"
"","1499","Unable to run single test that inherits all test methods with surefire","Hello JUnit team,  I noticed that running a single test which inherits all test methods does not work with Maven. JUnit 5.3.0-M1, surefire 2.22.0.  Base test class:  ```java abstract class AbstractTestBase {   @Test   void theTest() {     assertTrue(getValue());   }    protected abstract boolean getValue(); } ```  child class:  ```java class ConcreteTest extends AbstractTestBase {   @Override   protected boolean getValue() {     return true;   } } ```  Maven command `mvn test -Dtest=ConcreteTest`.  Surefire provider is now part of the surefire plugin but this issue might be JUnit related. I think this is what happens:   1. surefire parses the command like into a class patttern ""**/ConcreteTest""  2. JUnit performs test discovery and notices `ConcreteTest#theTest()`  3. `MethodBasedTestDescriptor` is created with `MethodSource` as its test source  4. `MethodSource` is created using `MethodSource#from(Method)` and the discovered `ConcreteTest` class is not used  5. `MethodSource` constructor tries to figure out the class name using `method.getDeclaringClass().getName()`  6. resulting `MethodSource` is for class `AbstractTestBase` and method `#theTest()`  7. surefire's `TestMethodFilter` tries to match `MathodSource(AbstractTestBase, theTest)` with ""**/ConcreteTest""  8. class name does not match and the test is skipped; at this point there is no way for surefire to undestand that `AbstractTestBase#theTest()` and `ConcreteTest#theTest()` is the same thing  Running `mvn test -Dtest=ConcreteTest` results in an error saying ""No tests were executed!"". Command `mvn test -Dtest=ConcreteTest,AbstractTestBase` can be used as a workaround. It results in a single executed test, as expected.  Problem can be fixed by making constructor of `MethodBasedTestDescriptor` use `MethodSource#from(String className, String methodName)` static factory instead of `MethodSource#from(Method)`. This preserves ""ConcreteTest"" name for future checks executed by surefire.  `VintageTestDescriptor` also uses `MethodSource#from(Method)` and might have the same problem.  Example project from [this gist](https://gist.github.com/lutovich/b9beac0da1f95fcbcec848d7be43328a) can be used to reproduce the problem.  I'd be happy to provide a fix for this problem if it is really in JUnit code and my findings are correct.  Thanks in advance!","closed","3rd-party: Maven Surefire,","lutovich","2018-07-17T21:32:50Z","2018-07-20T16:42:32Z"
"","1406","Unexpected behavior with inheritance and -Dtest with Surefire","Having such a construct  ```java public abstract class SomeAbstract5Test {     @Test     public void abstr() {         System.out.println(""abstr"");     } }  public class SomeConcrete5Test extends SomeAbstract5Test {     @Test     public void concrete() {         System.out.println(""concrete"");     } } ```  When executing tests with `mvn test -Dtest=SomeConcrete5Test` only tests defined in concrete test class are executed. The expected behavior (and the behavior provided by JUnit 4) would be to execute all tests inherited, too.  Is there a way to achieve this using JUnit Platform 1.2 and JUnit Jupiter 5.2?  ## Related Issues  - #1237 - #1499","closed","3rd-party: Maven Surefire,","mibutec","2018-05-03T13:26:58Z","2018-07-27T20:03:42Z"
"","1641","Error occurs when trying to execute Tag-based Gradle task using & separator between tags","Good Afternoon. Could you please assist me with problem that I'm facing?  I use JUnit 5, Gradle, Java 8, and Spring.  I've tried to create new gradle task  ```groovy task pipelineTest(type: Test) { Test task ->     task.useJUnitPlatform { org.gradle.api.tasks.testing.junitplatform.JUnitPlatformOptions options ->         options.includeTags 'Authorization-QA & Authorization-DEV'     } } ```  As a result the build fails.  In your official documentation mentioned that it is possible.  Stack trace and debug results in the attachment: [stackTrace.txt](https://github.com/junit-team/junit5/files/2496338/stackTrace.txt)","closed","3rd-party: Gradle,","AlienBykova","2018-10-19T15:02:35Z","2018-10-20T11:01:28Z"
"","986","maven-surefire-plugins's setting ""redirectTestOutputToFile"" is being ignored","Given the following plugin definition:  ```xml     maven-surefire-plugin    2.19.1           true                         org.junit.platform          junit-platform-surefire-provider          1.0.0-M6                        org.junit.vintage          junit-vintage-engine          4.12.0-M6                        org.junit.jupiter          junit-jupiter-engine          5.0.0-M6             ```  and tests, that produce console output with `System.out.println()`, Test's console output is being written out on the actual console, while it is expected to be redirected to surefire's files, as it happened before adding `junit-vintage-engine` and `junit-platform-surefire-provider` to dependencies.  This issue is severe, because the project I'm working on heavily depends on the fact that tests output is suppressed (without it, it produces hundreds of megabytes of logs, ruining the performance and blocking storage capacity).","closed","3rd-party: Maven Surefire,","piotrkrokowski","2017-07-25T18:50:27Z","2017-11-05T17:34:08Z"
"","987","Failure during test discovery doesn't cause Maven run failure","Given the following plugin definition:  ```xml     maven-surefire-plugin    2.19.1                     org.junit.platform          junit-platform-surefire-provider          1.0.0-M6                       org.junit.jupiter          junit-jupiter-engine          5.0.0-M6             ```  and the following (incorrect) test:  ```java public class JUnit5Test {     @BeforeAll    void setUp() {    }     @Test    void name() {       assertTrue(true);    } } ```  Running tests with maven `mvn clean test` will cause a Jupiter failure (which is expected, because `@BeforeAll` should be static), but will end up with a successful Maven run (see attached Maven console output).  This behavior is quite dangerous, and might cause someone to oversee tests failure.  [run-success.txt](https://github.com/junit-team/junit5/files/1174674/run-success.txt)","closed","3rd-party: Maven Surefire,","piotrkrokowski","2017-07-25T20:29:38Z","2020-02-02T16:17:37Z"
"","1643","When using parallel execution, Callback methods/extensions should be called after all dynamic tests of a @TestFactory method are finished","Given a test case like the following:  ```java class ConcurrentDynamicTestCase { 	@AfterEach 	void afterEach() { 		... 	} 	@TestFactory 	DynamicTest testFactory() { 		return dynamicTest(""slow"", () -> { 			Thread.sleep(500); 		}); 	} } ```  ## Expected behavior  `afterEach` is called _after_ all dynamic tests from `testFactory()` are finished.  ## Current behavior  `afterEach` is called before.","closed","component: Jupiter,","marcphilipp","2018-10-22T10:35:38Z","2018-11-16T20:31:32Z"
"","1188","Excluded tags don't work on Maven with JDK 9","From the `junit5-vanilla-maven` project, add a new test:  ```java @Tag(""filtered"") public class FilteredTest {     @Test     public void dummy() {  } } ``` Exclude the tag in the pom.xml:  ```xml         filtered     ```  Modified project: https://github.com/acogoluegnes/junit5-vanilla-maven  Exclusion works on JDK 8, but not on JDK 9:  ``` $ ./mvnw --version /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-03T21:39:06+02:00) Maven home: /home/acogoluegnes/.m2/wrapper/dists/apache-maven-3.5.0-bin/6ps54u5pnnbbpr6ds9rppcc7iv/apache-maven-3.5.0 Java version: 1.8.0_144, vendor: Oracle Corporation Java home: /usr/local/java-install/jdk1.8.0_144/jre Default locale: en_US, platform encoding: UTF-8 OS name: ""linux"", version: ""4.4.0-101-generic"", arch: ""amd64"", family: ""unix"" $ ./mvnw clean test [INFO] Scanning for projects... [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] Building junit5-vanilla-maven 1.0-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO]  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ junit5-vanilla-maven --- [INFO] Deleting /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/target [INFO]  [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ junit5-vanilla-maven --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/src/main/resources [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ junit5-vanilla-maven --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 1 source file to /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/target/classes [INFO]  [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ junit5-vanilla-maven --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/src/test/resources [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ junit5-vanilla-maven --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 2 source files to /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/target/test-classes [INFO]  [INFO] --- maven-surefire-plugin:2.19.1:test (default-test) @ junit5-vanilla-maven ---  -------------------------------------------------------  T E S T S ------------------------------------------------------- Running com.example.project.CalculatorTests Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.059 sec - in com.example.project.CalculatorTests  Results :  Tests run: 1, Failures: 0, Errors: 0, Skipped: 0  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 3.993 s [INFO] Finished at: 2017-11-27T11:30:40+01:00 [INFO] Final Memory: 16M/199M [INFO] ------------------------------------------------------------------------ ```   ``` $ ./mvnw --version /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-03T21:39:06+02:00) Maven home: /home/acogoluegnes/.m2/wrapper/dists/apache-maven-3.5.0-bin/6ps54u5pnnbbpr6ds9rppcc7iv/apache-maven-3.5.0 Java version: 9, vendor: Oracle Corporation Java home: /usr/local/java-install/jdk-9 Default locale: en_US, platform encoding: UTF-8 OS name: ""linux"", version: ""4.4.0-101-generic"", arch: ""amd64"", family: ""unix"" $ ./mvnw clean test [INFO] Scanning for projects... [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] Building junit5-vanilla-maven 1.0-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO]  [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ junit5-vanilla-maven --- [INFO] Deleting /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/target [INFO]  [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ junit5-vanilla-maven --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/src/main/resources [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ junit5-vanilla-maven --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 1 source file to /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/target/classes [INFO]  [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ junit5-vanilla-maven --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/src/test/resources [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ junit5-vanilla-maven --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 2 source files to /home/acogoluegnes/temp/junit5-samples/junit5-vanilla-maven/target/test-classes [INFO]  [INFO] --- maven-surefire-plugin:2.19.1:test (default-test) @ junit5-vanilla-maven ---  -------------------------------------------------------  T E S T S ------------------------------------------------------- Running com.example.project.CalculatorTests Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.106 sec - in com.example.project.CalculatorTests Running com.example.project.FilteredTest Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec - in com.example.project.FilteredTest  Results :  Tests run: 2, Failures: 0, Errors: 0, Skipped: 0  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 4.348 s [INFO] Finished at: 2017-11-27T11:29:34+01:00 [INFO] Final Memory: 14M/47M [INFO] ------------------------------------------------------------------------ ```","closed","3rd-party: Maven Surefire,","acogoluegnes","2017-11-27T10:47:23Z","2018-03-12T15:50:55Z"
"","1890","Remove or update translation links in User Guide","From https://github.com/junit-team/junit5/pull/1198#issuecomment-494631822:  > http://sjyuan.cc/junit5/user-guide-cn now is 404 - There isn't a GitHub Pages site here.  ## Deliverables  - [x] Fix link or remove it","closed","theme: documentation,","marcphilipp","2019-05-22T09:00:10Z","2019-06-20T07:58:05Z"
"","1819","Vintage engine reports intermediate containers as finished before executing dynamic children","For the demo project below, Vintage reports the `AbcTest` class as finished before starting its dynamic children:  ``` Started:     JUnit Vintage ([engine:junit-vintage]) Started:     AbcTestSuite ([engine:junit-vintage]/[runner:AbcTestSuite]) Started:     AbcTest ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]) Started:     simple ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]/[test:simple(AbcTest)]) Finished:    simple ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]/[test:simple(AbcTest)]) Finished:    AbcTest ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]) Test registered:   aaa 1 ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]/[dynamic:aaa 1(AbcTest)]) Started:     aaa 1 ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]/[dynamic:aaa 1(AbcTest)]) Finished:    aaa 1 ([engine:junit-vintage]/[runner:AbcTestSuite]/[test:AbcTest]/[dynamic:aaa 1(AbcTest)]) Finished:    AbcTestSuite ([engine:junit-vintage]/[runner:AbcTestSuite]) Finished:    JUnit Vintage ([engine:junit-vintage]) ```  ## Steps to reproduce  run `./gradlew test` with https://github.com/tomekgajdos/tmp-test-lib-a  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.4.0  - Build Tool/IDE: Gradle  ## Deliverables  - [ ] Report intermediate containers as finished lazily, i.e. when a new test is started that is not a child of the current container or when the runner is finished (except for well-known runners such as `Parameterized`)","closed","component: Vintage,","marcphilipp","2019-03-16T13:03:22Z","2019-03-17T19:00:51Z"
"","1841","PR Codecov report not getting published","For recent PRs codecov reports are not available. https://codecov.io/gh/junit-team/junit5/pulls  In the CI pipeline, Codecov `Coverage ` step (Codecov returning 400 for URL.)   ```     ‌query:‌ branch=merge&commit=853385448e466fc4c64505a0d69a6065dba387b8&build=20190401.4&build_url=https%3A%2F%2Fdev.azure.com%2Fjunit-team%2Fjunit5%2F_build%2Fresults%3FbuildId%3D111&name=&tag=&slug=junit-team%2Fjunit5&service=azure_pipelines&flags=&pr=&job=111‌     ‌->‌ Pinging Codecov‌ https://codecov.io/upload/v4?package=bash-8a28df4&token=$(codecovToken)&branch=merge&commit=853385448e466fc4c64505a0d69a6065dba387b8&build=20190401.4&build_url=https%3A%2F%2Fdev.azure.com%2Fjunit-team%2Fjunit5%2F_build%2Fresults%3FbuildId%3D111&name=&tag=&slug=junit-team%2Fjunit5&service=azure_pipelines&flags=&pr=&job=111 HTTP 400‌ Provided token is not a UUID.‌ ##[section]Finishing: Coverage ```  Ex Build: https://dev.azure.com/junit-team/junit5/_build/results?buildId=111","closed","status: stale,","gopinath-langote","2019-04-01T12:18:33Z","2021-06-19T12:50:15Z"
"","1797","Support global configuration to override the default DisplayNameGenerator","For our case, nearly all of our test cases are written in Kotlin. With the default name generation, that can result in a bit more cumbersome/ugly test names that are output by IDEs or in reporting.  For example, in a Gradle project we have.  ```kotlin internal class MkobitExample {     @Test     internal fun `this is an example test that should demonstrate something!`() {     }      @Test     internal fun `this test uses the @TempDir extension`(@TempDir path: Path) {     } } ```  Which results in test names like  * `this is an example test that should demonstrate something!$my_service()` * `this test uses the @TempDir extension$my_service(Path)`  Where `my_service` is the name of the module (Gradle's `project.group`).  What we have been doing is using our own simple `DisplayNameGenerator.Standard` implementation:  ```kotlin private class KotlinFriendlyDisplayNameGenerator : DisplayNameGenerator.Standard() {     override fun generateDisplayNameForNestedClass(nestedClass: Class<*>): String {         return nestedClass.kotlin.simpleName ?: super.generateDisplayNameForNestedClass(nestedClass)     }      override fun generateDisplayNameForMethod(testClass: Class<*>, testMethod: Method): String {         return testMethod.kotlinFunction?.name ?: super.generateDisplayNameForMethod(testClass, testMethod)     }      override fun generateDisplayNameForClass(testClass: Class<*>): String {         return testClass.kotlin.simpleName ?: super.generateDisplayNameForClass(testClass)     } }  @DisplayNameGeneration(KotlinFriendlyDisplayNameGenerator::class) internal annotation class KotlinFriendlyDisplayNames ```  Then, Gradle reports the test as:  * *Test* - `this is an example test that should demonstrate something!` - *Method name* `this is an example test that should demonstrate something!$frame_service()` * *Test* - `this test uses the @TempDir extension` - *Method name* `this test uses the @TempDir extension$frame_service(Path)`  It would be useful to allow a user supplied override parameter to select the default `DisplayNameGenerator` implementation.  ## Deliverables  - [ ] Configuration parameter support for Jupiter engine to override default `DisplayNameGenerator`","closed","component: Jupiter,","mkobit","2019-02-27T16:31:10Z","2020-05-22T19:53:46Z"
"","1337","ParameterizedTests: no conversion is possible for primitive types","For example, ``` class MyTest {     @ParameterizedTest     @ValueSource(bytes = 1)     void name(int i) {     } } ``` fails with ``` Caused by: org.junit.jupiter.params.converter.ArgumentConversionException: No implicit conversion to convert object of type java.lang.Byte to type java.lang.Integer 	at org.junit.jupiter.params.converter.DefaultArgumentConverter.convertToTargetType(DefaultArgumentConverter.java:124) 	at org.junit.jupiter.params.converter.DefaultArgumentConverter.convert(DefaultArgumentConverter.java:93) 	at org.junit.jupiter.params.converter.SimpleArgumentConverter.convert(SimpleArgumentConverter.java:30) ```  though the following code is totally fine  ```         byte b = 0;         int i = b; ```","closed","theme: parameterized tests,","akozlova","2018-03-20T14:30:23Z","2018-03-20T16:01:34Z"
"","1632","How to use internal custom TestEngine implementations in Maven-Surefire-Plugin?","For developing custom TestEngine classes there already is a lot of documentation on how to use them:  - ServiceLoader and plugin system - LauncherConfig  Well, I tried to use a custom TestEngine with ServiceLoader (intern), it works fine in IntelliJ or using a Launcher, but I didn't get anything while running **mvn test**.  In Maven Surefire documentation it's mentioned that you only need to add JUnit-Jupiter-Engine in dependencies without the help of an provider. But these engines are external. What about internal engines?","closed","3rd-party: Maven Surefire,","performrumpf","2018-10-12T08:07:14Z","2018-10-16T17:35:58Z"
"","1537","Respect `--disable-ansi-colors` option when showing usage help","Following up on #1530:  > @marcphilipp: Should we take into account the `--disable-ansi-colors` option when printing the usage message? >  > @remkop: I would like to but the API of the `CommandLineOptionsParser` interface in its current form does not lend itself to this: the `printHelp` method has no parameter to indicate whether ANSI colors should be used. > @remkop: Shall we discuss improving the internal `CommandLineOptionsParser` API to cater for switching off ANSI output in a separate ticket? > @marcphilipp: Yeah, let's do that.   Salient points: * this is an internal API and can be modified at will * it may not always be possible to respect the `--disable-ansi-colors` option, e.g., when the input is invalid","closed","component: Platform,","remkop","2018-08-12T07:31:16Z","2020-07-06T09:37:17Z"
"","1367","Surefire can't find class `org.apache.maven.plugin.surefire.log.api.ConsoleLogger`","Follow-up from https://github.com/junit-team/junit5/issues/801#issuecomment-380481871","closed","3rd-party: Maven Surefire,","sormuras","2018-04-13T11:22:16Z","2018-08-22T10:30:14Z"
"","1936","Build JUnit 5 using JDK 14","Follow-up from #1934   > Groovy- > ``` > Task :junit-jupiter-engine:compileTestGroovy FAILED > > FAILURE: Build failed with an exception. >  > * What went wrong: > Execution failed for task ':junit-jupiter-engine:compileTestGroovy'. > > BUG! exception in phase 'semantic analysis' in source unit >  '...\junit-jupiter-engine\src\test\groovy\ >    org\junit\jupiter\api\GroovyAssertEqualsTests.groovy' > Unsupported class file major version 58 > ``` > ... and Mockito-based tests... > ``` > org.junit.jupiter.params.provider.MethodArgumentsProviderTests >   providesArgumentsUsingIterator() FAILED >     org.mockito.exceptions.base.MockitoException: >     Cannot call abstract real method on java object! >     Calling real methods is only possible when mocking non abstract method. > ``` > ...failed to compile/run on JDK 14. JDK 11, 12 and 13 are okay.  ## Deliverables  - [x] Upgrade to Gradle/Groovy version that supports JDK 14 - [x] Upgrade to Mockito version that supports JDK 14 - [x] Add Azure build for JDK 14","closed","theme: modules,","sormuras","2019-06-16T02:11:14Z","2019-07-15T19:47:00Z"
"","1771","Support loose event matching in Test Kit","Follow up of #1532  ## Description  Provide method to assert events regardless of completeness and order.  ## Example  ```java Events events =      EngineTestKit 	.engine(testEngine) 	.execute() 	.all();      events.assertEventsInAnyOrder( 	event(container(MyContainerClass.class), started()), 	... 	event(container(MyContainerClass.class), finishedSuccessfully())     ); ```  ### Why should that be part of the Test Kit?  My guess is that most test engine builders have the need to check for only some of the generated events. My attempts to use `events.assertEventsMatch()` did not lead anywhere since AssertJ's `ListAssert` class does not come with something like `matchOneOf(Condition... conditions)`.","closed","component: Test Kit,","jlink","2019-02-10T14:27:47Z","2020-04-19T14:59:20Z"
"","1253","Add support for tag expressions","Fixes #454.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","marcphilipp","2018-01-19T19:33:32Z","2018-01-24T13:58:53Z"
"","995","Add Store.Key, to allow easier type-safe access to values in a store.","Fixes #361  ## Overview  Please describe your changes here and list any open questions you might have.  This provides a much-less error-prone way to access a Store in a type-safe way.  Open question: Can we remove the old methods, or is it too late for that? ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","kcooney","2017-07-30T09:00:20Z","2017-07-31T15:45:34Z"
"","1659","Introduce LOCALE and TIME_ZONE constants in Resources","Fixes #1658  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","sdavids","2018-11-01T10:37:41Z","2018-11-03T17:11:40Z"
"","1347","Ensure failures in lifecycle methods take precedence over earlier TestAbortedExceptions","Fixes #1313.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2018-03-28T09:08:26Z","2018-07-07T20:15:44Z"
"","1297","Fix handling of trailing null elements in @CsvSource","Fixes #1296.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2018-02-17T19:32:58Z","2018-02-17T19:55:06Z"
"","1118","Translate `--scan-module-path` into multiple module selectors","Fixes #1115  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] ~Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes)~ - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2017-10-17T16:45:20Z","2017-10-17T18:04:54Z"
"","1137","Surefire: Run all TestsToRun in one execution using a single TestPlan","Fixes #1113.  - Move testSetStarting/testSetCompleted into RunListenerAdapter - Start a test set for every child of an engine descriptor that   is a container and has a ClassSource - Ensure every reported test belongs to a test set (for engines   that do not use ClassSource)  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","marcphilipp","2017-11-02T19:35:34Z","2018-01-15T11:38:32Z"
"","1138","Create test instance after evaluating conditions","Fixes #1103.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2017-11-02T19:37:53Z","2017-11-05T17:34:23Z"
"","1281","Fix or remove PDF version of User Guide","Fix the PDF version of the user guide OR remove the link to it from the top of the User Guide.","closed","theme: documentation,","marcphilipp","2018-02-04T15:24:31Z","2018-02-16T16:48:04Z"
"","1779","EngineTestKit: How to prevent selected class run from outside engine","First of all thanks for the `EngineTestKit` — it just came in time, as I need to test exception handling in my extension.  Unfortunately the test detection mechanism in Idea as well as when run from Gradle also finds the referenced class to run (which should fail) instead of ignoring it.  My workaround: I annotated my ""test under test"" with `@EnabledIfSystemProperty(named = ""engine.test.kit"", matches = ""enabled"")` and in the test class with `EngineTestKit` I defined `BeforeAll` and `AfterAll`:  ```java   @BeforeAll   static void setUpAll() {     System.setProperty(""engine.test.kit"", ""enabled"");   }    @AfterAll   static void tearDownAll() {     System.setProperty(""engine.test.kit"", """");   } ```  This works... but I think there should be a simpler way of doing so. Any ideas?  If there is no solution up to now, I suggest to have an `ExecutionCondition` like `@OnlyRunViaEngineTestKit` or something similar.  Possibly related to #1372.","closed","status: stale,","mmichaelis","2019-02-15T19:07:09Z","2022-07-11T20:21:33Z"
"","1101","Support multiple annotations as source for Parameterized Tests","Feature Request to simplify Parameterized Tests.  I am looking for an easy way to implement Parameterized Tests with multiple arguments.  While I could use `@CsvSource`, I'd appreciate multiple annotations, similar to NUnit's `TestCase`.  Example:  ```java     @ParameterizedTest // still required?     @Parameter(10, ""10000"")     @Parameter(20, ""20000"")     @Parameter(30, ""30000"")     void calculate(int input, String expected) {         assertThat(Integer.toString(input*1000)).isEqualTo(expected);     } ```  Any thoughts on this?","closed","component: Jupiter,","jochenchrist","2017-10-10T09:22:40Z","2021-05-31T17:06:35Z"
"","1622","@CsvSource - allow collections as parameters","Feature Request for `@CsvSource`:  I often need to verify that the output of a method is a list or set of values.  Right now I end up passing the list as a single string with a different delimiter and then splitting it in the test method. It would be more convenient to be able to do something like:  ```java @ParameterizedTest @CsvSource({ ""foo, bar, [ABC, DEF]"", ""one, two, []"", }) public void testMethod(String param1, String param2, Set expectedResult) {     Set actualResult = someMethod(param1, param2);     assertThat(actualResult, is(expectedResult)); } ```","closed","theme: parameterized tests,","llowrey","2018-10-06T14:44:49Z","2018-10-08T09:39:23Z"
"","1876","Improve String-based comparison in assertLinesMatch","Extra new line characters were introduced in https://github.com/junit-team/junit5/pull/1861/files#diff-1d1ebfdfa50596f4e0ecb4039d842b03R167 to improve textual layout of the comparison of non-matching lists of lines on the console. See the changes made to the unit test within the linked commit.  tl;dr Match two single-line lists, like: ```java assertLinesMatch(List.of(""single line""), List.of(""another line"")); ``` ...yields on the console: ``` ...   => org.opentest4j.AssertionFailedError: expected line #1:`single line` doesn't match ==> expected: < single line > but was: < another line > ``` ...but in IDE(a)s the extra new lines disturb the diff view: ![image](https://user-images.githubusercontent.com/2319838/57603562-4ec09700-7562-11e9-8245-a1cd0316e41f.png)  Users may be confused by where lines 1 and 3 originate from...  @junit-team Remove the extra new lines or keep them?","closed","component: Jupiter,","sormuras","2019-05-13T07:36:31Z","2019-05-23T16:04:27Z"
"","1811","Add optional order parameter to @ExtendWith","Extensions can be added to a test class on class level (using `@ExtendWith` on the class) and with `@RegisterExtension` on fields of the test class.  While ordering the `@RegisterExtension` extensions can be achieved with the `@Order` annotation there is no way to do that with the `@ExtendWith` extensions - at least not in a way that the `@RegisterExtension` extensions actually are wrapped by the `@ExtendWith` extensions.  This could be achieved by adding an optional order parameter to the `@ExtendWith` annotation with basically the same semantics as the `@Order` annotation for `@RegisterExtension`.  Note that using multiple separate `@ExtendWith` annotations should use their own order parameters.  The effect should be that `@RegisterExtension` with a given order number wrap `@ExtendWith` with the same order number, which then wrap `@RegisterExtension` extensions with a higher order number or without an order number, with `@ExtendWith` without order parameter being the innermost extensions in this wrapping hierarchy.  A scenario where this would be useful is with Mockito and its `@ExtendWith(MockitoExtension.class)` extension, which initializes fields annotated with `@Mock`. These fields currently cannot be used by `@RegisterExtension` extensions, since they aren't initialized yet when `@RegisterExtension` extensions execute their `beforeEach()` methods.  Workarounds include using `Mockito.mock(MyClass.class)` instead of `@Mock`, or using `BeforeTestExecutionCallback` instead of `BeforeEachCallback`, but that might not help or be possible in all szenarios (with or without Mockito).","closed","component: Jupiter,","ugrepel","2019-03-12T10:12:08Z","2019-12-05T16:44:51Z"
"","1653","Introduce Try type to preserve failure cause","Exceptions reported due to failed reflective operations such as loading a class, reading a field's value, or looking up a method by name now include the original exception as their cause to make it easier to debug underlying issues.  Such operations in `ReflectionUtils` and `ReflectionSupport` no longer return an instance of `Optional` but one of a new `Try` type which encapsulates either a successful invocation with a (nullable) resulting value or a failure with an exception as its cause. Depending on the caller, the cause can then be logged or rethrown as appropriate.  Resolves #602.","closed","theme: diagnostics,","marcphilipp","2018-10-28T15:04:05Z","2018-11-09T19:19:02Z"
"","1403","@Disabled annotation not honored using Maven","Environment:  - JDK 8 - Maven 3.5.3 - JUnit 5.2.0 - maven-surefire-plugin 2.21.0 - Eclipse Oxygen.3a (4.7.3a)   When I run the [attached sample project](https://github.com/junit-team/junit5/files/1968805/foo.zip) in Maven both the tests are executed, while running them in Eclipse the annotation works.  Project highlights:  **pom.xml** ```  	 		 			org.junit 			junit-bom 			5.2.0 			pom 			import 		 	   	 		org.junit.jupiter 		junit-jupiter-api 		test 	 	 		org.junit.platform 		junit-platform-launcher 		test 	 	 		org.junit.jupiter 		junit-jupiter-engine 		test 	   	 		 			maven-surefire-plugin 			2.21.0 		 	  ```  **TestFoo.java**: ``` import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test;  public class TestFoo {      @Test     public void testEnabled() {         System.out.println(""ENABLED"");     }      @Disabled     @Test     public void testDisabled() {         System.out.println(""DISABLED"");     }  } ```","closed","3rd-party: Maven Surefire,","giacgbj","2018-05-02T20:31:51Z","2021-10-28T19:14:11Z"
"","1408","junit-jupiter-params-5.2.0.jar invalid CEN header (bad signature)","Encountered a problem with JUnit Params 5.2.0. Compiler can't read JAR file because it seems to be corrupted:  > [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project junit5testproject: Compilation failure: Compilation failure: [ERROR] error reading C:\Users\c.rumpf\.m2\repository\org\junit\jupiter\junit-jupiter-params\5.2.0\junit-jupiter-params-5.2.0.jar; invalid CEN header (bad signature)  Solutions how I can use it (without downloading ZIP file or using version 5.1.1)?","closed","component: Jupiter,","rumpfc","2018-05-04T06:44:31Z","2018-05-05T08:26:37Z"
"","1715","fix LegacyXmlReportGeneratingListener to generate one xml file per test class","edit: looks like you have tests that actually assert a different behavior, so not sure how to progress here...  ## Overview  Currently, this listener generates one xml file per testPlan. The testPlan generally contains all tests discovered by jupiter engine (ie all classes and their test methods).  So, overall, this listener produces just a single xml file named ""TEST-junit-jupiter.xml"", containing all test results.  However, junit4 behaviour was to generate one xml file per test class.  Many tools depend on this assumption, ie ant's html test report generator.  Current listener implementation confuses this tool and makes it believe that tests are all present under class named 'JUnit Jupiter'.  This (rather hackish) change fixes it.   To reproduce, you can use this main method (make sure there's some jupiter discoverable tests on the classpath): ```java import java.io.File; import java.io.FileInputStream; import java.io.PrintWriter; import javax.xml.parsers.DocumentBuilderFactory; import org.apache.tools.ant.Project; import org.apache.tools.ant.taskdefs.optional.junit.AggregateTransformer; import org.apache.tools.ant.taskdefs.optional.junit.XMLResultAggregator; import org.apache.tools.ant.types.FileSet; import org.junit.platform.engine.discovery.DiscoverySelectors; import org.junit.platform.launcher.Launcher; import org.junit.platform.launcher.LauncherDiscoveryRequest; import org.junit.platform.launcher.core.LauncherConfig; import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder; import org.junit.platform.launcher.core.LauncherFactory; import org.junit.platform.reporting.legacy.xml.LegacyXmlReportGeneratingListener; import org.junit.platform.reporting.legacy.xml.LegacyXmlReportGeneratingListener;  public class LaunchTestsAndGenerateHtmlReport {     public static void main(String[] args) throws Exception {         final LauncherConfig.Builder config = LauncherConfig.builder();         final Launcher launcher = LauncherFactory.create(config.build());          final LauncherDiscoveryRequest request = new LauncherDiscoveryRequestBuilder()                 .selectors(DiscoverySelectors.selectPackage(""""))                 .build();          final File xmlDir = new File(""./report/xml"");         launcher.execute(request, new LegacyXmlReportGeneratingListener(                 xmlDir.toPath(),                 new PrintWriter(System.err)         ));          final Project project = new Project();         project.setBaseDir(new File("".""));         project.setProperty(""java.io.tmpdir"", ""tmp"");          final XMLResultAggregator aggregator = new XMLResultAggregator();         final FileSet fs = new FileSet();         fs.setDir(xmlDir);         fs.createPatternSet().createInclude().setName(""**/*.xml"");         aggregator.setProject(project);         aggregator.addFileSet(fs);         aggregator.setTofile(""./report/aggregated.xml"");         aggregator.execute();          final AggregateTransformer report = aggregator.createReport();         final AggregateTransformer.Format format = new AggregateTransformer.Format();         format.setValue(""frames"");         report.setFormat(format);         report.setTodir(new File(""./report/html""));          report.setXmlDocument(DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(                 new FileInputStream(""./report/aggregated.xml""))         );         report.transform();     } } ```  dependencies required to run, in maven format: ```xml              org.junit.jupiter         junit-jupiter-engine         5.4.0-M1                   org.junit.platform         junit-platform-launcher         1.4.0-M1                   org.junit.platform         junit-platform-reporting         1.4.0-M1                   org.apache.ant         ant-junit         1.10.5      ```   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass  PS Sorry for the commit thrash, had to copy-paste this code manually from my IDE, which had different import order settings and I didn't want to mess with yours...","closed","","alepar","2018-12-29T00:37:39Z","2019-04-14T13:33:23Z"
"","1102","Surefire plugin ignores test classes which doesn't follow certain name pattern","During some JUnit 5 training sessions I discovered that test classes are ignored by Surefire plugin if they don't follow a certain name pattern:  **class names where tests will run**  - MyJUnitTest - TestFirstDynamicTestExample - TestLoginLogout  **class names where tests are ignored**  - FirstDynamicTestExample - LoginLogout - MyJUnitExample  I don't know if that's on purpose or an accidental bug. Same happens with JUnit 4 surefire plugin","closed","status: invalid,","rumpfc","2017-10-11T08:16:46Z","2017-10-11T13:10:49Z"
"","1908","Relax RegisterExtension field type restriction","Due to the checks in [ExtensionUtils.IsNonStaticExtensionField](https://github.com/junit-team/junit5/blob/463a838002b1603853e8e5cb528d4a9ade9a22d7/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java#L140) and [ExtensionUtils.IsStaticExtensionField](https://github.com/junit-team/junit5/blob/463a838002b1603853e8e5cb528d4a9ade9a22d7/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java#L158) it is not currently possible to use `@RegisterExtension` on fields that do not implement `Extension`. Furthermore, no warning or error is produced telling the developer that the extension is not active.  I wonder if this restriction could be relaxed, and the `@RegisterExtension` annotation alone be used as the trigger. If the actual field instance does not implement `Extension` then an error could be raised.  The specific driver for this issue is to allow a `@RegisterExtension` class that does not present JUnit specific APIs to the user. i.e.:  ```java public class UserFacingApi {   // .. API methods the user will want }  public class ExtensionClass extends UserFacingApi implement Extension... {   // .. JUnit methods that the user should not call } ```  ```java @RegisterExtension private UserFacingApi userFacing = new ExtensionClass(); ```  (see https://github.com/spring-projects/spring-boot/issues/17029 for a real use-case)","closed","component: Jupiter,","philwebb","2019-05-31T16:57:39Z","2019-06-03T08:13:51Z"
"","1822","PROOF-OF-CONCEPT: Checkpoints","Draft PR for #1821 ...","closed","","sormuras","2019-03-17T11:14:02Z","2019-07-19T10:30:05Z"
"","1282","Document module path requirements for running junit-jupiter-engine","Document that junit-jupiter-engine does not ship with a module descriptor but requires java.scripting and can be run using `--add-modules ALL-MODULE-PATH,ALL-DEFAULT`.","closed","theme: modules,","marcphilipp","2018-02-04T15:28:07Z","2018-02-09T12:09:34Z"
"","1522","Use field injection for TestReporter et al","Do not require Jupiter users to create a constructor to use fields of type `TestReporter` (and other types Jupiter injects by default). Instead, inject instances into such fields after construction.  **PS**: This is a straw man, I don't actually want this feature, but I'd like to have a place to direct people to for explanation on why it doesn't exist. Why I don't think that's a good idea:  * field injection is ""magic"", i.e. a decent amount of developers will be unsure where the instances come from * fields can be declared all over the place, which makes it easy to miss one * injected fields can not be referenced in the constructor because they are still `null`  All you get for that is saving less than the dozen keystrokes it takes to have you IDE generate or update the constructor.  If this feature is not implemented, this issue could serve as documentation for why not. Beyond that a short note in the user guide could mention that this is not an oversight.","closed","","nipafx","2018-08-03T14:23:31Z","2020-09-19T16:53:19Z"
"","1751","Delete junit-platform-surefire-provider from documentation","Delete `junit-platform-surefire-provider` from documentation https://junit.org/junit5/docs/current/user-guide  The users still refer to it and report fake bugs in Surefire JIRA.  Rather put this link to your documentation https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit-platform.html","closed","3rd-party: Maven Surefire,","Tibor17","2019-01-27T10:14:29Z","2019-01-27T12:32:29Z"
"","1081","Display name for @ParameterizedTest should only include consumed arguments","Default display name for test using parameters from `@CsvSource` could be improved. Currently the following test: ```java class Test {     @ParameterizedTest     @CsvSource({""value1,value2""})     void test(String string) {         //      } } ``` will produce test name: ``` [1] value1, value2 ```  The reason is that generated test name contains all columns from record provided by `@CsvSource`. In above example the record `""value1,value2""` is converted to 2 columns: `""value1""` and `""value2""`. It would be better to include only actually used columns, so in this case: `""value1""`.","closed","component: Jupiter,","karollewandowski","2017-09-28T21:39:20Z","2017-11-05T17:32:38Z"
"","1526","Add JUnit5 to Maven Central repo","Dear JUnit team,  Thank you for JUnit. And for new features of JUnit5. Could you add it to Maven Central repo, please.  Building JUnit5 and plugging it to my project seems too complicated. Currently my build fails: ""Could not find artifact junit:junit:jar:5.2.0 in central (https://repo.maven.apache.org/maven2)"". JUnit5 is listed under http://repo1.maven.org/maven2/org/junit/, but from 2016 - old.","closed","","peter-kehl","2018-08-06T18:21:53Z","2020-07-24T07:58:42Z"
"","1943","Feature request: Allow Abstract parameter resolver","Dear Friends,  May I suggest to allow the parameter resolver class to be abstract?  Here is my scenario: I have a single parameter resolver for the whole project (200+ integration tests) But a few days ago, I was required to add a 'follow redirect' parameter on jersey but just for one very specific class of integration tests  The thing is that parameter resolver is shared among all integration test classes and because parameter resolver is not 'aware' of integration test classes it is been reflected on, I cannot control the behaviour without playing with additional parameter resolvers instead of making a single abstract parameter resolver that I can extend and customise the behaviour  I have tried to make my parameter resolver abstract to prove this idea But because JUnit uses reflection, I've got InstanciationException  So, my current/quick workaround was to copy and paste the original parameter resolver to another class with the customisations I need and change the @ExtendsWith() to point to this specific parameter resolver of this specific set of integration tests that are requiring it   Thank You Very Much/Kind Regards, Geraldo Netto","closed","component: Jupiter,","geraldo-netto","2019-07-03T07:28:09Z","2019-07-03T07:42:08Z"
"","1397","Only instantiate ArgumentConverters and ArgumentsAggregators once per parameterized test method","Currently, any `ArgumentConverter` or `ArgumentsAggregator` registered via `@ConvertWith` or `@AggregateWith`, respectively, is instantiated once per invocation of the `@ParameterizedTest` method.  For example, the following class  ```java class NoisyTestCase {      static class MyConverter implements ArgumentConverter {         public MyConverter() {             System.out.println(""created instance of "" + MyConverter.class);         }          @Override         public Object convert(Object source, ParameterContext context) throws ArgumentConversionException {             return source;         }     }      static class MyAggregator implements ArgumentsAggregator {         public MyAggregator() {             System.out.println(""created instance of "" + MyAggregator.class);         }          @Override         public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context) throws ArgumentsAggregationException {             return null;         }     }      @ParameterizedTest     @ValueSource(ints = {1, 2, 3})     void test(@ConvertWith(MyConverter.class) int i, @AggregateWith(MyAggregator.class) Object o) {         System.out.println(""test("" + i + "", "" + o + "")"");     } }  ```  prints  ``` created instance of class NoisyTestCase$MyConverter created instance of class NoisyTestCase$MyAggregator test(1, null) created instance of class NoisyTestCase$MyConverter created instance of class NoisyTestCase$MyAggregator test(2, null) created instance of class NoisyTestCase$MyConverter created instance of class NoisyTestCase$MyAggregator test(3, null) ```  ## Deliverables  - [x] Instantiate `ArgumentConverter` or `ArgumentsAggregator` registered via `@ConvertWith` or `@AggregateWith`, respectively, only once per parameterized test method (e.g. instantiate eagerly or reuse for subsequent invocations)","closed","theme: parameterized tests,","marcphilipp","2018-04-28T20:12:08Z","2018-07-01T15:54:39Z"
"","1326","Build should respect JAVA_HOME when running executables","Currently when java is not on the path or the java/jar executable is on path, but the version is not 9+, junit5 cannot be build.  It would be nice if project can be build using command something like   ``` JAVA_HOME=/usr/lib/jvm/java-9-jdk ./gradlew  clean build ```  The proposed change uses gradle's internal api which is probably not ok, but couldn't find better solution.","closed","theme: build,","tsachev","2018-03-14T13:00:47Z","2018-03-16T09:02:23Z"
"","1776","Method order not adhering to @Order","Currently using 5.4.0 with Kotlin 1.3.21 and Java 8 and with Intellij 2018.3   When I add `@TestMethodOrder(OrderAnnotation::class)` with `Order` annotation the order doesn't seem to run in what I was expecting for example, I expect this method to run first   ```java    @Test     @Order(1)     fun `add a session to cache`() {          val header = HttpHeaders()         header.contentType = MediaType.APPLICATION_JSON          val json = ""{\""protocolRestriction\"":false}""          val entity = HttpEntity(json, header)          val request = restTemplate.postForEntity(""/session/10.36.55.1/create"",entity)          assertThat(request.statusCode).isEqualTo(HttpStatus.OK)     } ```  but this method is the last one to run.   here is my full code,   ```java package sky.wifi.sessionmanager  import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.* import org.junit.jupiter.api.MethodOrderer.OrderAnnotation; import org.junit.jupiter.api.extension.ExtendWith import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.web.client.TestRestTemplate import org.springframework.boot.test.web.client.getForEntity import org.springframework.boot.test.web.client.postForEntity import org.springframework.http.HttpEntity import org.springframework.http.HttpHeaders import org.springframework.http.HttpStatus import org.springframework.http.MediaType import org.springframework.test.context.ActiveProfiles import org.springframework.test.context.junit.jupiter.SpringExtension  @ExtendWith(SpringExtension::class) @ActiveProfiles(""qa"") @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestInstance(TestInstance.Lifecycle.PER_CLASS) @TestMethodOrder(OrderAnnotation::class) class ControllerTest(@Autowired var restTemplate: TestRestTemplate) {      @Test     @Order(1)     fun `add a session to cache`() {          val header = HttpHeaders()         header.contentType = MediaType.APPLICATION_JSON          val json = ""{\""protocolRestriction\"":false}""          val entity = HttpEntity(json, header)          val request = restTemplate.postForEntity(""/session/10.36.55.1/create"",entity)          assertThat(request.statusCode).isEqualTo(HttpStatus.OK)     }      @Test     @Order(2)     fun `get all sessions from empty cache`() {          val entity = restTemplate.getForEntity(""/session/all"")          assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)          assertThat(entity.body).isNotEmpty()     }      @Test     @Order(3)     fun `update a session from cache`() {          val header = HttpHeaders()         header.contentType = MediaType.APPLICATION_JSON          val entity = HttpEntity("""", header)          val request = restTemplate.postForEntity(""/session/10.36.55.1/update"",entity)          assertThat(request.statusCode).isEqualTo(HttpStatus.OK)     }      @Test     @Order(4)     fun `delete a session from cache`() {          val header = HttpHeaders()         header.contentType = MediaType.APPLICATION_JSON          val entity = HttpEntity("""", header)          val request = restTemplate.postForEntity(""/session/10.36.55.1/delete"",entity)          assertThat(request.statusCode).isEqualTo(HttpStatus.OK)     }  } ```  here is a screenshot of the test methods: https://cdn1.imggmi.com/uploads/2019/2/15/6465ce0507fcb3e6f3bd2e1340df0c7a-full.png","closed","component: Jupiter,","ergunp","2019-02-15T09:34:21Z","2021-02-13T19:14:18Z"
"","1195","Tight coupling in TestEngine","Currently there is no easy way to customize TestEngine.discover  For JUnit 4 we have our own approach very similar to JUnit 5 Tags. We have different Test-Suites which define includes and excludes via Java-Code. Porting it to JUnit 5 (without the JUnit 4 adapters) is very hard, because there is no SPI like a TestClassResolver to ""extend"" only TestEngine.discover and keep the rest of JupiterTestEngine.  Esp. the fact that testEngineDescriptors in org.junit.platform.launcher.core.Root uses the TestEngine as a key makes it hard to provide a custom TestEngine which only implements TestEngine.discover.  Also implementing TestEngine.discover or an additional SPI should be easier. In JUnit 4 it's just about providing an array of classes and pass it to the constructor of org.junit.runners.Suite.","closed","status: duplicate,","ps4os","2017-12-02T12:46:49Z","2017-12-02T13:37:55Z"
"","1274","Improve documentation about logManager for Gradle plugin","Currently in the reference documentation in the [Configuring the JUnit Gradle Plugin](http://junit.org/junit5/docs/current/user-guide/#running-tests-build-gradle-junit-configure) section exists this example:  `logManager 'org.apache.logging.log4j.jul.LogManager'`  Is not clear:  * If that `org.apache.logging.log4j.jul.LogManager` is mandatory or not * If we are able to change to `logback`, if yes, what is the value?  I am working with `Jenkins`, when I execute the test for a module, my `@Test` pass but I get  ``` :junit-01-infrastructure:junitPlatformTestCould not load Logmanager ""org.apache.logging.log4j.jul.LogManager"" java.lang.ClassNotFoundException: org.apache.logging.log4j.jul.LogManager 	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) ```  I have in my classpath `SLF4J` and `Logback`, I did a research for the latter and there is no nothing similar than `LogManager` but the former has [org.apache.log4j.LogManager](https://www.slf4j.org/apidocs/org/apache/log4j/LogManager.html) (different package), thus if I use now:  ``` //logManager 'org.apache.logging.log4j.jul.LogManager' logManager 'org.apache.log4j.LogManager' ```  Then again the `@Test` pass but I get now:  ``` :junit-01-infrastructure:junitPlatformTestCould not load Logmanager ""org.apache.log4j.LogManager"" java.lang.ClassNotFoundException: org.apache.log4j.LogManager 	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ``` Thus I am not able to see the `Gradle Report` (the `reports` directory within the `build` directory), but I know that all the `@Test` pass due the `JUnit` plugin in `Jenkins`  If I comment both lines  ``` //logManager 'org.apache.logging.log4j.jul.LogManager' //logManager 'org.apache.log4j.LogManager' ```  the `reports` directory within the `build` directory does not appear  Not sure how handle correctly this situation.  ## Related Issues  - #1295","closed","3rd-party: Gradle,","manueljordan","2018-01-31T14:57:33Z","2018-02-17T13:18:45Z"
"","1566","Nested PER_METHOD inside PER_CLASS should call TestInstanceFactory for enclosing class","Currently I am trying to integrate JUnit 5.3.0-RC1 into a Weld-SE-Test framework, `ejb-cdi-unit`.  The first solution based on JUnit 5.2.0 available in `ejb-cdi-unit:1.1.15` restricts the TestInstance-Classes somewhat concerning CDI. I can only allow `@Inject`. That helps already very much, but see [this note](https://github.com/1and1/ejb-cdi-unit#junit5).  Now while trying to implement the `TestInstanceFactory` to avoid the aforementioned restrictions, I encounter problems with [this example](https://github.com/1and1/ejb-cdi-unit/blob/master/examples/ex1-1entity5/src/test/java/com/oneandone/ejbcdiunit/example1_5/ServiceTest5.java).  You can see a `ServiceTest5` test class working with lifecycle `PER_CLASS` and two nested test classes of which one is working with lifecycle `PER_METHOD`.  The inner classes are currently disabled to avoid email notifications from Travis CI.  I would expect, that before the method `ServiceTest5.WhenSomeEntitiesInDbExist.cantReadTestDataUsingServiceInRequiredNew()` is called, that a completely new instance of `ServiceTest5` would be created using the `TestInstanceFactory` implemented in `JUnit5Extension`, since the nested inner class `WhenSomeEntitiesInDbExist` has Lifecycle `PER_METHOD`.  That is not the case.  Is that by design or a bug in the release candidate?","closed","component: Jupiter,","aschoerk","2018-08-29T13:45:45Z","2018-09-01T12:30:05Z"
"","1263","`junit-platform-gradle-plugin` requires 'Test' suffix for tests to be discovered","Currently I am switching from the built-in build system of IntelliJ (Community 2017.3.3) to using Gradle for my project.  I struggled for a long time trying to figure out why when I ran my tests using the 'Platform Test Runner' of IntelliJ, more tests were discovered than when using the `junit-platform-gradle-plugin` (org.junit.platform:junit-platform-gradle-plugin:1.1.0-M1).  After an extensive investigation I seem to have discovered that `gradle test` only runs tests defined in classes which are suffixed with 'Test'. (p.s. I am using Kotlin, in case that matters)  ```kotlin class Bleh {      @Test     fun Test() { } } ```  This test is not discovered by `gradle test`, but it is when the class is renamed to `BlehTest` or `BlehTests`. Not even `TestBleh` works. I'm new to Gradle and JUnit 5, but this does not seem like expected/intended behavior to me.","closed","3rd-party: Gradle,","Whathecode","2018-01-25T16:00:40Z","2018-01-25T16:21:35Z"
"","1946","@ParameterizedTest Thread count","could you please add a way to configure the number  of threads running @ParameterizedTest like testng dataproviderthreadcount","closed","status: stale,","jflefebvre06","2019-07-03T19:46:38Z","2022-07-12T23:11:04Z"
"","1315","Declare proper JDK version in example usage of the install script","copy paste typos are the best typos see also https://github.com/junit-team/junit5-samples/pull/59  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","MiniDigger","2018-02-26T12:55:39Z","2018-02-26T14:58:43Z"
"","1405","Include dependency versions as properties in junit-bom","Considering the following scenario, which I think is the main scenario for Maven users, `junit-bom` seems to be useless because Maven doesn't allow to propagate versions imported to plugins' dependencies (https://issues.apache.org/jira/browse/MNG-5588).  ```xml  	 		 			org.junit 			junit-bom 			5.2.0 			pom 			import 		 	   	 		 			maven-surefire-plugin 			2.21.0 			 				 					org.junit.platform 					junit-platform-surefire-provider                                           					1.2.0 				 			 		 	  ```  Would it be possible to expose junit-bom's dependencies' versions using properties in order to reference them?","closed","3rd-party: Gradle,","giacgbj","2018-05-03T06:36:39Z","2019-07-19T19:32:24Z"
"","1305","Bug: AfterAllCallback extension hides container failure","Consider this test code:  ```java @ExtendWith(ThrowingExtension.class) class ReproTest {     ReproTest() { this(""""); }     ReproTest(String s) { }      @Test void test() { } } class ThrowingExtension implements AfterAllCallback {     @Override     public void afterAll(ExtensionContext context) {         throw new IllegalStateException(""Callback fails"");     } } ```  This test is invalid, because it has two constructors. And JUnit will usually tell you exactly that. Unfortunately, the `AfterAllCallback` will still be executed in this case, and will hide the actual informative message.  If I have the thrown exception in an `@AfterAll` method in the test class itself, this will work correctly and give the `PreconditionViolationException` I'd expect.","closed","component: Jupiter,","jorn86","2018-02-23T13:29:01Z","2018-03-05T14:01:05Z"
"","1304","Feature request: Allow multiple constructors in test class","Consider the following test code:  ``` class ReproTest extends BaseTest {     private final int expectedValue;      ReproTest() {         this(1);     }      private ReproTest(int value) {         super(new ClassUnderTest(value));         this.expectedValue = value;     }      @Test     void test() {         assertEquals(expectedValue, subject.value);     } } abstract class BaseTest {     final ClassUnderTest subject;      BaseTest(ClassUnderTest subject) {         this.subject = subject;     } } class ClassUnderTest {     final int value;      ClassUnderTest(int value) {         this.value = value;     } } ```  Can  we find a way to allow a second constructor in a test class to support this case? Perhaps by ignoring the private constructor or by annotating the constructor JUnit is supposed to use? There is no way to achieve the same functionality without either duplicating values (it's not a constant in my real-world case) or having a second constructor.","closed","","jorn86","2018-02-23T13:09:51Z","2018-02-26T18:25:30Z"
"","1208","Enhancement request : Introduce a way to distinguish between test failures and errored out tests","Consider the following test case:  ``` public class SomeTest {      @Test     public void testOne() {        Assert.assertEquals(1, 2);     }     @Test    public void testTwo() {        Integer i = null;        i.toString(); // leads to NPE    } } ```  Both these test methods are expected to fail. Right now, the JUnit *platform* doesn't distinguish between these two different types of failures. I consider the `testOne` to be a ""failure"" where as the `testTwo` as an error.   It would be good to have this distinction available at the platform level, through platform APIs, so that test engines can (optionally) mark certain types of exceptions as ""failures"" and that information then gets propagated all the way back to the `TestExecutionListener`(s) so that the `TestExecutionResult` has a way to distinguish between such failures.  Right now, the only way to do that in a framework that integrates with JUnit 5 platform is something like this in a TestExecutionListener:  ``` public void executionFinished(final TestIdentifier testIdentifier, final TestExecutionResult testExecutionResult) {     switch (testExecutionResult.getStatus()) {         case SUCCESSFUL: {             // succeeded             break;         }         case FAILED: {             if (testExecutionResult.getThrowable() instanceof ) {                 // consider this a failure             } else {                 // consider this an error             }             break;         }         case ABORTED: {             // aborted         }     } } ``` As you can see the `if` is testing against a specific test engine specific exception class which isn't a good thing and most of the times not feasible (since it adds a compile time dependency on the test engine specific libraries in the framework).","closed","component: Platform,","jaikiran","2017-12-15T11:29:16Z","2017-12-23T12:56:21Z"
"","1958","Add support for String delimiters in @CsvSource and @CsvFileSource","Configuring the delimiter in `@CsvSource` when using Groovy is extremely limited due to the lack of support of character literals.  The only way to configure the delimiter in the annotation that I could find is to cast it to char which requires the class the use of `@CompileStatic`.  The [univocity parser](https://github.com/uniVocity/univocity-parsers/blob/v2.8.2/src/main/java/com/univocity/parsers/csv/CsvFormat.java) that is used can take either a `char` or `String` delimiter.  In order to offer better support for writing tests in Groovy, please update this annotation so that a string delimiter may be used.  ## Deliverables  - [x] Add support for String delimiters in `@CsvSource` and `@CsvFileSource`","closed","component: Groovy,","nrundle","2019-07-15T12:46:48Z","2019-08-23T09:31:29Z"
"","1686","Concurrency issue with resolving parameters in test methods using the SpringExtension","Concurrency issues with resolving parameters in test methods ## Steps to reproduce * Gradle java project with Junit5 tests that use `SpringExtension` * Have at least one method `@Test/@BeforeEach` with parameter annotated with spring `@Autowired` * Run all test with enabled default parallel strategy `junit.jupiter.execution.parallel.enabled= true` * And with default ""per-method"" test instance lifecycle ## Expected behavior * Test passed ## Actual behavior * Some times get concurrency issues for example ``` Caused by: java.lang.IllegalArgumentException:  Given parameter [com.example.project.Calculator arg0]  does not match any parameter in the declaring executable ```   ## Example project  * That reproduce issue https://github.com/mdolinin/gradle-junit5-spring-example  ## Context  - Used versions : Jupiter 5.3.1 /Platform 1.3.1/ Spring Test 5.1.2  - Build Tool/IDE: gradle 4.10.2  ## Posible rootcause * After some investigation found that this exceptions is thrown by Spring from `org.springframework.core.MethodParameter` ``` java protected static int findParameterIndex(Parameter parameter) { 	Executable executable = parameter.getDeclaringExecutable(); 	Parameter[] allParams = executable.getParameters(); 	for (int i = 0; i < allParams.length; i++) { 		if (parameter == allParams[i]) { 			return i; 		} 	} 	throw new IllegalArgumentException(""Given parameter ["" + parameter + 			""] does not match any parameter in the declaring executable""); } ``` * This could happen because how JUnit create this parameter in  https://github.com/junit-team/junit5/blob/5caf217676e85a51aabec736fce7cadf687a299d/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java#L160 * If run this in parallel two or more thread will get here with same link to one `executable` method * And because inside `Executable` class parameters are stored in `private transient volatile Parameter[] parameters;` ``` java private Parameter[] privateGetParameters() {         // Use tmp to avoid multiple writes to a volatile.         Parameter[] tmp = parameters;          if (tmp == null) {              // Otherwise, go to the JVM to get them             try {                 tmp = getParameters0();             } catch(IllegalArgumentException e) {                 // Rethrow ClassFormatErrors                 throw new MalformedParametersException(""Invalid constant pool index"");             }              // If we get back nothing, then synthesize parameters             if (tmp == null) {                 hasRealParameterData = false;                 tmp = synthesizeAllParams();             } else {                 hasRealParameterData = true;                 verifyParameters(tmp);             }              parameters = tmp;         }          return tmp;     }  ``` * First thread could get parameters array from second one  ### Posible solutions * Synchronize calls to `executable` * Or provide clone of `executable` to each thread","closed","component: Jupiter,","mdolinin","2018-11-21T19:35:37Z","2018-11-24T14:46:33Z"
"","1167","Add assertAll consuming Collection<()->Unit> in Kotlin","Closes #1163  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","JLLeitschuh","2017-11-16T17:24:51Z","2017-11-17T14:08:48Z"
"","1527","Clarified invocation of gradlew on Unix and Windows","Clarified invocation of gradlew. Otherwise newbies get confused, try to search/install a 'gradlew' from the Internet - a waste of time.","closed","theme: documentation,","peter-kehl","2018-08-06T19:14:09Z","2018-08-08T10:56:01Z"
"","1882","Deprecate ""Script-based Conditions"" for removal","Citing our [User Guide](https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution-scripts)  > If you find yourself using the same script-based condition many times, consider writing a dedicated `ExecutionCondition` extension in order to implement the condition in a faster, type-safe, and more maintainable manner.  Additional reasons for removing ""Script-based Conditions"": - #1481 -- Nashorn is being deprecated for removal - https://github.com/sormuras/junit5-class-vs-module-path - ... - It was just an experiment.","closed","component: Jupiter,","sormuras","2019-05-16T04:12:15Z","2020-05-22T19:53:37Z"
"","1899","Jupiter doesn't worked in maven project with mixed java + kotlin sources/tests configuration","Cannot setup maven parent pom with success junit / jupiter test executions in mixed java + kotlin project. I have only Kotlin tests and they are located in src/test/kotlin directory of each submodule, but src/test/java also should be available for java tests in case of  any..  Please help me with some worked example if you have one. Seems like some versions are incompatible, but I just tired search what will works fine...  ## Steps to reproduce  1) create parent project with that pom.xml  ```xml      4.0.0   com.github.daggerok   kotlin-coroutines-examples   1.0-SNAPSHOT   pom         1.8     ${java.version}     ${java.version}      UTF-8     ${encoding}     ${encoding}      1.3.31     true     1.2.1      3.12.2     4.12     5.3.1      3.1.0     3.1.0                            org.junit         junit-bom         ${junit-jupiter.version}         pom         import                               org.jetbrains.kotlin       kotlin-stdlib       ${kotlin.version}                 org.jetbrains.kotlin       kotlin-reflect       ${kotlin.version}                 org.jetbrains.kotlinx       kotlinx-coroutines-core       ${kotlinx-coroutines-core.version}                 org.jetbrains.kotlinx       kotlinx-coroutines-test       ${kotlinx-coroutines-core.version}                 org.jetbrains.kotlin       kotlin-test-junit5       ${kotlin.version}       test                 org.jetbrains.kotlin       kotlin-test-junit       ${kotlin.version}       test                 org.assertj       assertj-core       ${assertj.version}       test                 org.junit.platform       junit-platform-launcher       test                 org.junit.platform       junit-platform-commons       test                 org.junit.jupiter       junit-jupiter-api       test                 org.junit.jupiter       junit-jupiter-engine       test                 org.junit.vintage       junit-vintage-engine       test                 junit       junit       ${junit.version}       test                 clean test                             kotlin-maven-plugin         org.jetbrains.kotlin         ${kotlin.version}                    ${maven.compiler.target}                        -Xjsr305=strict                                   no-arg             all-open                                                     compile                            compile                                                          ${project.basedir}/src/main/java                 ${project.basedir}/src/main/kotlin                                                               test-compile                            test-compile                                                          ${project.basedir}/src/test/java                 ${project.basedir}/src/test/kotlin                                                                        org.apache.maven.plugins         maven-compiler-plugin         3.8.0                    ${maven.compiler.source}           ${maven.compiler.target}                                          default-compile             none                                   default-testCompile             none                                   java-compile             compile                            compile                                                java-test-compile             test-compile                            testCompile                                                         org.apache.maven.plugins         maven-failsafe-plugin         2.22.0                                 --illegal-access=permit                                            org.apache.maven.plugins         maven-surefire-plugin         2.22.0                                 --illegal-access=permit                                             ```  2) next, create submodule with kotlin code and tests written by using Junit Jupiter and located in src/test/kotlin folder of that submodule  3) run command `mvn clean test` and verify something like that:  ```bash -------------------------------------------------------  T E S T S -------------------------------------------------------  Results :  Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  ## Context   - Used versions (Jupiter/Vintage/Platform): I have tried versions 5.3.2 / 1.3.2 and 5.5.0-M3 / 1.5.0-M3  - Build Tool/IDE: tried use java versions 11 and 8, by using maven 3.5.4, 3.6.0 and 3.6.1  I have [worked Gradle Kotlin DSL configurations](https://github.com/daggerok/kotlin-examples/tree/master/kotlin-coroutines-examples) with what I want, but similar versions doesn't work in maven project  --- Regards, Maksim","closed","","daggerok","2019-05-24T20:03:15Z","2019-05-26T02:03:42Z"
"","1746","Forbid @TempDir on constructor parameters","Because `@TempDir` on constructor parameters would create a shared temp dir which is unintuitive (see discussion in #1731), we should forbid it and hint toward using field injection instead.  ## Deliverables  - [x] Forbid `@TempDir` on constructor parameters","closed","component: Jupiter,","marcphilipp","2019-01-24T19:22:26Z","2019-01-24T19:31:42Z"
"","1002","Use same default lifecycle for Kotlin and Java test classes","Based on the discussion in #905 we've decided to revert #991.  ## Deliverables  - [x] Use same default Lifecycle for Kotlin and Java","closed","component: Kotlin,","marcphilipp","2017-08-04T18:49:26Z","2017-08-19T11:11:42Z"
"","1620","Document order of callback methods and extensions that run after test/container execution","Based on [JUnit5 user-guide](https://junit.org/junit5/docs/current/user-guide/#extensions) extensions execution order should correlate with extensions declaration order:  > Extensions registered declaratively via @ExtendWith will be executed in the order in which they are declared in the source code. For example, the execution of tests in both MyFirstTests and MySecondTests will be extended by the FooExtension and BarExtension, in exactly that order.  But it does not.   Example: https://github.com/apodkutin/junit5-extensions-order-test/blob/master/src/test/java/junit5/extensions/order/JUnit5ExtensionsOrderTest.java  `@ExtendWith({FirstExtension.class, SecondExtension.class})`  ### Expected output _FirstExtension afterEach method call_ _SecondExtension afterEach method call_  ### Actual output _SecondExtension afterEach method call_ _FirstExtension afterEach method call_  Jupiter-api version is 5.3.1  ``` org.junit.jupiter junit-jupiter-api 5.3.1 ```  ## Deliverables  - Document the **lack** of explicit ordering for all user-supplied callback methods (i.e., `@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll`) declared within a single test class/interface.    - [x] in Javadoc    - [x] in User Guide  - Document the **lack** of _wrapping_ behavior for all user-supplied callback methods (e.g., `@AfterAll`, `@AfterEach`) declared within a single test class/interface.    - [x] in Javadoc    - [x] in User Guide  - Document _wrapping_ behavior for all user-supplied callback methods (i.e., `@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll`) within test class/interface hierarchies.    - [x] in Javadoc    - [x] in User Guide  - Document _wrapping_ behavior for all applicable extension APIs (e.g., `TestExecutionExceptionHandler`, `AfterTestExecutionCallback`, `AfterEachCallback`, `AfterAllCallback`, etc.).    - [x] in Javadoc    - [x] in User Guide","closed","component: Jupiter,","apodkutin","2018-10-05T09:49:19Z","2019-02-07T19:55:41Z"
"","1955","Publish JUnit Jupiter Assertions as a separate artifact","AssertJ and Truth are a couple of alternatives which provide fluent assertions. Assertions provided by JUnit are part of the core `junit-jupiter-api` module.  It would be great if the Assertions are moved into a separate sub-module/module, so that they can be excluded in the dependencies, and provide a better auto complete IDE experience.  ## Deliverables  - [ ] Reorganize Assertions into it's own module","closed","component: Jupiter,","bhchandra","2019-07-10T15:46:37Z","2020-11-19T11:00:51Z"
"","1043","Remove the workaround for Kotlin on JDK9","As the bug was fixed in Kotlin 1.1.4 acording to youtrack this workarround can be removed. https://youtrack.jetbrains.com/issue/KT-18832  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","JLLeitschuh","2017-09-04T19:54:17Z","2017-09-07T13:48:21Z"
"","1535","Revise documentation on Maven support","As originally reported in https://github.com/junit-team/junit5-samples/issues/80, the current documentation on how to run tests using Maven in the user guide and sample projects is inconsistent.  ## Deliverables  - [x] Mention `junit-platform-surefire-provider` is deprecated but remove it from all examples in the user guide - [x] Move the engine dependencies to the regular `dependencies` section in all examples in the user guide","closed","3rd-party: Maven Surefire,","marcphilipp","2018-08-11T17:42:51Z","2018-08-16T17:09:04Z"
"","1737","Add a download link to the JUnit 5 home page","As noted in #1587, the JUnit 5 home page doesn't provide a link to the compiled JARs like JUnit 4's page did.  For the rare user that's not using a dependency management tool with defined repositories, this will give them a place to start their dependency hell.  ## Deliverables  - [ ] Add a ""Download JARs"" link to the ""Resources"" section of https://junit.org/junit5/ that points to the latest release JARs. - [ ] Add ""Download JAR"" links to the `README` in this repository.","closed","status: stale,","smoyer64","2019-01-17T20:48:30Z","2021-06-19T12:50:32Z"
"","1676","Adopt Contributor Covenant code of conduct","As discussed within the team, we'd like to adopt the Contributor Covenant code of conduct.","closed","type: task,","marcphilipp","2018-11-12T10:38:43Z","2018-11-12T21:49:49Z"
"","1338","Discover dynamic tests early during discovery phase","As discussed in https://stackoverflow.com/questions/49401619/test-discovery-of-dynamic-tests-in-eclipse-slow it would be cool, if dynamic tests could be discovered at start time of a test. Advantages are: - No jumping of IDEs JUnit view while more ans more tests are detected - I can start a test-class to get a list of all known tests and than start selectivly the ones I'm interested in - When executing in IDE I get an idea of how long execution of a test-class will take based on number of tests.  Since a TestFactory returns a tupel of display name and executable code, I think it should be possible to iterate throu the returned Stream / Iterable to get all display names and create complete view on test start of a test.","closed","theme: dynamic tests,","mibutec","2018-03-21T09:49:50Z","2018-04-03T12:38:06Z"
"","1030","Fix bug in AssertionUtils.toString(Object)","As described in the commit message,  ``` Beforehand it would print arrays via the arrays' toString() methods. Now it prints them using `Arrays.toString()`, which produces the expected result.  This is a prerequisite for #961. ```  This PR was requested by @sbrannen at https://github.com/junit-team/junit5/pull/961#discussion_r134114088.  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","jbduncan","2017-08-22T00:29:27Z","2017-08-22T15:49:37Z"
"","1859","Overloaded assertions fail for Kotlin","As described in https://github.com/junit-team/junit5/issues/1710#issuecomment-482147200 the following snippet  ```kotlin assertEquals(2, jsonValidator.getList(""actions"")?.size) ```  produces an error at runtime:  ``` java.lang.NoSuchMethodError: org.junit.jupiter.api.Assertions.assertEquals(ILjava/lang/Integer;)V 	at org.projectforge.rest.json.JsonValidatorTest.parseJson(JsonValidatorTest.kt:27) ```  Not sure whether this is an issue with Jupiter's overloads or it's bug in Kotlin.  @JLLeitschuh -- any idea?","closed","component: Jupiter,","sormuras","2019-04-11T16:17:20Z","2019-04-15T16:47:56Z"
"","1937","Increase log level for when Random prints out default seed value","As a part of #1805 when no seed value is configured a default one is generated and printed to the console. However that message is currently set to config level which isn't printed by default. It seems this could frequently lead to issues where a generated seed causes a test to fail, but the seed isn't printed to console, because Java util log wasn't configured to print out config messages.  Should this logging message be changed to print a higher level, possibly INFO, which is printed out by default?  ## Deliverables  - [x] Update `MethodOrderer` to print default seed to `INFO`","closed","theme: diagnostics,","wkorando","2019-06-25T15:09:06Z","2019-06-28T11:13:10Z"
"","1825","Consider repeatable @EnabledIfEnvironmentVariableExist","Apologies, `@IfNotApplicable`.  I faced a problem with my integration test that needs multiple environment variables to run.  ```java class MyIT {      void test() {         // needs multiple environment variables to run.     } } ```  Do we have any chances to get `@EnableIfEnvironmentExist`?  ```java @EnableIfEnvironmentVariables({     @EnableIfEnvronmentVariable(exist = true, andOptionallyMatches=""...""),     @EnableIfEnvronmentVariable(exist = true, andOptionallyMatches=""...""),     @EnableIfEnvronmentVariable(exist = true, andOptionallyDoesNotMatch=""...""), }) void test() { } ``` or ```java @EnableIfEnvironmentVariableExists({     @EnableIfEnvronmentVariableExist(andOptionallyMatches=""...""),     @EnableIfEnvronmentVariableExist(andOptionallyMatches=""...""),     @EnableIfEnvronmentVariableExist(andOptionallyDoesNotMatch=""...""), }) void test() { } ```","closed","component: Jupiter,","onacit","2019-03-19T06:04:48Z","2019-03-19T14:49:08Z"
"","1874","Update the documentation to note the enhancement in Ant's junitlauncher task","Apache Ant 1.10.6 has been released this week and it contains enhanced support in `junitlauncher` task to support launching the tests in a forked JVM[1]. The commit in this PR, updates the documentation to make a note of this new support.  [1] https://jaitechwriteups.blogspot.com/2019/05/apache-ant-1106-released-fork-mode-for.html","closed","component: Platform,","jaikiran","2019-05-11T12:19:14Z","2019-05-11T12:27:32Z"
"","1352","Document Ant build support in User Guide","Ant support has been released (cf. https://github.com/junit-team/junit5/issues/512#issuecomment-376820461).  ## Deliverables  - [x] Add Ant subsection with a minimal example and links to the official Ant documentation","closed","component: Platform,","marcphilipp","2018-03-31T10:27:45Z","2018-04-07T09:32:48Z"
"","1896","Custom URLClassLoader is not closed","An instance of [URLClassLoader](https://github.com/junit-team/junit5/blob/master/junit-platform-console/src/main/java/org/junit/platform/console/tasks/ConsoleTestExecutor.java#L81) is created for additional class path entries -- but it is never closed.  ## Deliverables  - [x] Close the instance after usage to free file handles gracefully","closed","component: Platform,","sormuras","2019-05-24T09:32:29Z","2019-05-27T08:20:24Z"
"","1739","Provide reusable base implementation of test discovery","All class-based test engines should handle the following selectors during test discovery:  - `ClasspathResourceSelector` - `ClasspathRootSelector` - `ModuleSelector` - `PackageSelector` - `UniqueIdSelector` - `ClassSelector` - `MethodSelector`  The code required to handle the first four of these is straightforward but repetitive and [easy to forget](https://stackoverflow.com/questions/52780940/kotlintestengine-discover-doesnt-return-any-tests). Moreover, resolving `UniqueIdSelectors` is non-trivial but the implementations of the Jupiter and Vintage engine provide examples of how to handle them correctly. Both use a similar yet slightly different approach. If we implemented the base algorithm once in an extensible way, it could be reused by other test engines. Doing so would reduce the burden on test engine authors and increase consistency across test engine implementations.  ## Deliverables  - [x] Extract an extendable base algorithm for resolving selectors from existing implementations - [x] Provide extensible configuration mechanism - [x] Provide sensible defaults for class-based test engines - [x] Use base algorithm in Jupiter and Vintage - [x] Reach out to authors of third-party test engines to get feedback and help them adopt the new base algorithm","closed","type: new feature,","marcphilipp","2019-01-20T12:08:36Z","2019-03-07T19:51:04Z"
"","1810","Polish Azure Pipelines build","After-math for #1807 and closes #1795.  ## Deliverables  - [x] Provide credentials to publish SNAPSHOT assets (artifacts and documentation) - [x] Update https://github.com/junit-team/junit5/blob/master/README.md#continuous-integration-builds table with shields pointing to Azure Pipelines - [x] Configure ""Publish Test Results Job"" to include only propery results: https://github.com/junit-team/junit5/pull/1807#discussion_r264530632 - [x] Configure ""Checkout task"" to only checkout the current branch - [x] The two last jobs (publish snapshot assets) should only start if ""Linux (JDK 11)"" was successfully executed - [x] Remove AppVeyor configuration - [x] Uninstall/disconnect AppVeyor service - [x] Remove Travis CI configuration - [x] Uninstall/disconnect Travis CI service - [x] ~Configure dependency cache on Azure Pipelines~ will be done in https://github.com/junit-team/junit5/issues/1826","closed","theme: build,","sormuras","2019-03-12T07:29:50Z","2019-03-19T13:27:05Z"
"","1836","Regression: Parameterized test written in Kotlin fails after upgrade to v5.4.0","After upgrading from 5.3.1 to 5.4.0 the following Kotlin test failes.  Note: The Kotlin version (1.3.21) have not been change .   ```kotlin import org.junit.jupiter.params.ParameterizedTest import org.junit.jupiter.params.provider.MethodSource   object Test {     @JvmStatic     fun data() = arrayOf(             arrayOf(""A"", 1),             arrayOf(""B"", 2),             arrayOf(""C"", 3),             arrayOf("""", 4),             arrayOf(null, 5) //null is a problem     )      @ParameterizedTest     @MethodSource(""securityLevels"")     fun securityLevelMappingTest(char: String, number: Integer) {      } } ```  Fails with Exception: ``` org.junit.platform.commons.JUnitException: The display name pattern defined for the parameterized test is invalid. See nested exception for further details. ```   Full Stacktrace  ``` org.junit.platform.commons.JUnitException: The display name pattern defined for the parameterized test is invalid. See nested exception for further details.         at org.junit.jupiter.params.ParameterizedTestNameFormatter.format(ParameterizedTestNameFormatter.java:46) 	at org.junit.jupiter.params.ParameterizedTestInvocationContext.getDisplayName(ParameterizedTestInvocationContext.java:38) 	at org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor.(TestTemplateInvocationTestDescriptor.java:44) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.createInvocationTestDescriptor(TestTemplateTestDescriptor.java:128) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$1(TestTemplateTestDescriptor.java:101) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$11$1.accept(ReferencePipeline.java:373) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1376) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1376) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:104) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:40) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.util.ArrayList.forEach(ArrayList.java:1251) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.util.ArrayList.forEach(ArrayList.java:1251) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.ArrayStoreException: java.lang.String 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.makeReadable(ParameterizedTestNameFormatter.java:79) 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.formatSafely(ParameterizedTestNameFormatter.java:53) 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.format(ParameterizedTestNameFormatter.java:41) 	... 83 more ```","closed","theme: parameterized tests,","ChristianSchwarz","2019-03-27T08:23:22Z","2019-04-07T14:32:47Z"
"","1543","Merge @Test and @DisplayName annotations","After reviewing some tests written with JUnit 5 I noticed that parameterized tests can be expressed in a more compact form than ""regular"" tests because the @ParameterizedTest annotation supports the name parameter whereas the regular tests need a @Test and @DisplayName annotation.  If the @Test annotation would accept a String value the same could be achieved by using just one annotation.  What do you think?","closed","component: Jupiter,","ViToni","2018-08-12T17:20:50Z","2018-08-13T11:08:29Z"
"","1523","Introduce publishMessage(String) in TestReporter API","Adds:  * `TestReporter::publishMessage` * `ExtensionContext::publishReportMessage` * a few tests/demos * a gazillion text files to appease the console runner tests (better never change the output format)  Fixes #1515.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","nipafx","2018-08-05T07:20:12Z","2020-09-08T18:29:40Z"
"","1570","Add TestInstanceFactory to @ExtendWith doc","Adds `TestInstanceFactory` to `@ExtendWith` javadoc.  I've put (EXPERIMENTAL) after TestInstanceFactory in the doc. Not sure if that's needed or desired.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","seanf","2018-08-30T07:45:58Z","2018-08-31T14:06:04Z"
"","1379","Adding information about my conversation on heisenbug conf","Adding information about my conversation on heisenbug conf see: https://heisenbug-piter.ru/en/talks/2018/spb/sncgtn5gisoswks6owgwq/","closed","","dtuchs","2018-04-18T15:58:03Z","2018-04-18T16:33:01Z"
"","1871","[Event] Add JUnit talk at Voxxed Days Luxembourg","Adding a JUnit related talk at [Voxxed Days Luxembourg](https://cfp-voxxed-lux.yajug.org/talk/MCB-0767) in June :)","closed","","juliette-derancourt","2019-05-09T10:50:47Z","2019-05-09T13:50:41Z"
"","1750","Allow defining @Nested test classes in a different class file","Adding a feature request as suggested at: https://gitter.im/junit-team/junit5?at=5c4c985d7b68f941022161c5   I like the Nesting feature of JUnit5 and the ability to have a single BeforeClass/AfterClass (I have some docker JUnit5 Extension that starts/stops a set of containers and do complex setup). However it leads to large classes. It would be great to be able to make the test class manageable (I currently over 1000 lines of test code which is too much for a single class).  Thus the ability to define the Nested class not as an inner class but as some external class would be awesome.  Thanks","closed","component: Jupiter,","vmassol","2019-01-26T23:42:54Z","2019-02-14T17:05:46Z"
"","1840","Add workshop at DevSum19","Added a new event, a workshop at [DevSum19](http://devsum.se/). This workshop is commercial, i.e. attendees pay for it on top of the conference ticket (in case this matters).","closed","","nipafx","2019-03-30T17:16:08Z","2020-09-08T18:29:44Z"
"","1931","Add more java.time types to implicit conversion","Add support for Duration, Period, MonthDay, ZoneId and ZoneOffset Closes #1929  ## Overview  Five new types added to the implicit converter. As far as I know, these only need to be added in one place. Tests have been added. Docs updated.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","jodastephen","2019-06-14T15:50:56Z","2019-06-20T07:58:06Z"
"","1503","Feature: Introduce Steps","Add Steps support for JUnit Jupiter.  The idea is to allow the user to mark some methods with a `@Step` annotation and have the ability to do something with these _steps_ -- for example, logging, monitoring, timing, etc.  In addition it will be good to have access on JUnit asserts in same extension.  So for test  ```java Calculator calc = new Calculator();  @Test public void simpleTest() {   int multiplication = calc.multiply(3,5);   assertEquals(multiplication, 15);   int sum = calc.sum(2,8);   assertEquals(sum, 10);   int division = calc.divide(12,3);   assertEquals(division, 4); } ```  I can see log:  ``` TEST: simpleTest()  Step: multiply(3, 5) AssertEquals: 15 Step: sum(2, 8) AssertEquals: 10 Step: divide(12, 3) AssertEquals: 4 Method [simpleTest] took 11 ms. ```  See project example on [GitHub](https://github.com/RomanIovlev/simple-junit-test)  Suggested code marked as // ADD","closed","component: Jupiter,","RomanIovlev","2018-07-20T10:25:19Z","2018-07-20T15:46:43Z"
"","1583","Include Javadoc and Sources in Platform ConsoleLauncher standalone artifacts","Actual: The sources/javadoc JARs on maven only contain the manifest information, but are missing the real information.  Expected: I would expect the files to contain the sources and javadocs of all the classes delivered in junit-platform-console-standalone-1.3.0.jar  Rationale: The standalone JAR offers an easy way to migrate an old JUnit 3/4 code base to JUnit Jupiter. But without Javadoc and/or Java sources a lot of important information how to perform the migration (e.g. deprecation notes) is harder to access.  The can easily be seen if you have a look at the artefact list: http://central.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.3.0/","closed","status: stale,","krizleebear","2018-09-12T12:38:54Z","2021-06-19T12:50:32Z"
"","1515","Clarify how TestReporter's keys and values are to be used","About `TestReporter`, the documentation says:  > In JUnit Jupiter you should use `TestReporter` where you used to print information to `stdout` or `stderr` in JUnit 4.  This does not clarify the intend behind key value pairs, though, and since leaving them empty is an error, it would help to explain how to use them. Otherwise users might be under the impression that the reporter is only useful to output test data (like in `reportSeveralValues` in [the user guide](https://junit.org/junit5/docs/current/user-guide/#writing-tests-dependency-injection)), but not status messages.  Or maybe add an overload that accepts a single string as a message.","closed","component: Jupiter,","nipafx","2018-08-01T11:59:58Z","2018-08-07T11:43:12Z"
"","1182","Wrong name and class name in XML report for parameterized tests","A test like this  ```java package com.example; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.ValueSource; public class SomeTest {    @ParameterizedTest    @ValueSource(strings = { ""val0"", ""val1"" })    void testSomething(String someValue) {    } } ```  results in an XML report (`TEST-junit-jupiter.xml`) like this:  ```xml ... ... ... ... ```  A similar test in JUnit 4 (`@RunWith(Parameterized.class)`), however, produces something like this:  ```xml ...   ... ```  My ""problem"" in particular or rather observation is that after migrating to JUnit 5 the number of tests reported in sonar dropped and the tests only using `@ParameterizedTest` no longer show up. Since as far as I know, sonar parses those XML reports, it's the only explanation I have for that drop. This for sure is not limited to sonar but all tools parsing those XML reports.  So it obviously has no high priority, at all but it would be great if you could fix this at some point.  In case it is relevant: I am using gradle.   ```groovy buildscript {   repositories {     mavenCentral()   }   dependencies {     classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.2'   } } repositories {   mavenCentral() }  apply plugin: 'eclipse' apply plugin: 'java' apply plugin: 'org.junit.platform.gradle.plugin'  dependencies {   testCompile(     'org.junit.jupiter:junit-jupiter-api:5.0.2',     'org.junit.jupiter:junit-jupiter-params:5.0.2'   )   testRuntime(     'org.junit.jupiter:junit-jupiter-engine:5.0.2',     'org.junit.platform:junit-platform-launcher:1.0.2'   ) } ```  ## Deliverables  - [x] Ensure that attribute values (e.g., `name` and `classname`) in XML reports make sense for the following use cases.   - [x] repeated tests   - [x] parameterized tests   - [x] dynamic containers   - [x] dynamic tests","closed","3rd-party: Gradle,","bbilger","2017-11-23T23:14:51Z","2021-02-09T11:02:22Z"
"","1198","Add Translations section to Overview chapter","A link to JUnit 5 User Guide(Simplified Chinese) is attached.  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","yuanshenjian","2017-12-05T02:10:14Z","2019-05-22T09:00:44Z"
"","1785","Add booleans to @ValueSource","`ValueSource` supports all of Java's primitives except for `boolean`s. This patch closes that gap and adds the ability to provide an array of primitive `boolean`s as a value source.  This patch includes: - Adding the property to `ValueSource` - Adding the code to `ValueArgumentsProvider` to handle the new property - Adding tests for the new feature in `ValueArgumentsProviderTests` - Adding a mention of the new property in the User Guide - Adding a mention of the new property in the 5.5.0-M1 release notes  Closes issue #1780  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","mureinik","2019-02-17T21:46:34Z","2019-03-29T13:08:23Z"
"","1485","Introduce ParameterizedTestMethodContext","`ParameterizedTestMethodContext` encapsulates access to the test method parameters' annotations to ensure it is only done once per `@ParameterizedTest.`  Resolves #1483.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","marcphilipp","2018-07-01T18:49:00Z","2018-07-03T17:51:43Z"
"","1772","Make ExecutionRecorder in Test Kit public","`org.junit.platform.testkit.engine.ExecutionRecorder` could be used to test internals of 3rd party TestEngine implementations if the class was public with a public constructor or a public factory method.","closed","component: Test Kit,","jlink","2019-02-10T15:21:04Z","2020-07-25T13:26:54Z"
"","1693","Root causes of exceptions are lost due to limited stacktrace in ConsoleLauncher","`ConsoleLauncher` limits stacktraces to 10 lines (followed by [...]). However, not all exceptions have their 'root' cause at the top. One example is an exception raised in a static initializer. It gets wrapped with an 'empty' `ExceptionInInitializerError`, making the first 10 lines not helpful.   AFAIK, there is no workaround available to print the full stacktrace using `ConsoleLauncher`. The only workaround is using another tool (IDE/mvn) to run the tests.  Example of 'unhelpful' stacktrace:  ```   JUnit Jupiter:DataPolicyTest     ClassSource [className = 'DataPolicyTest', filePosition = null]     => java.lang.ExceptionInInitializerError        ImpactAccess.(ImpactAccess.java:21)        DataPolicyTest.(DataPolicyTest.java:20)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:532)        org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)       org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$invokeBeforeAllMethods$8(ClassTestDescriptor.java:373)        org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)        [...] ```  ## Steps to reproduce  Make sure an exception is raised in a static initializer of a test class. This is just one way of reproducing.   ## Context  - Used versions (Jupiter/Vintage/Platform): jupiter v5.3.2 - Build Tool/IDE: junit-platform-console v1.3.2  ## Deliverables  - [ ] List causes and suppressed exceptions with a limited number of entries recursively.","closed","component: Platform,","janssk1","2018-12-03T08:45:03Z","2019-01-14T17:29:59Z"
"","1452","ParameterizedTest not playing nice with Collections","```java     @ParameterizedTest     @ArgumentsSource( PluginProvider.class )     void codeQuality( Collection> toApply ) {         Project project = ProjectBuilder.builder().build();         toApply.forEach( project.getPluginManager()::apply );         PluginContainer plugins = project.getPlugins();          assertAll( ""plugins"",                 () -> assertTrue( plugins.hasPlugin( IdeaPlugin.class ), ""idea"" ),                 () -> assertTrue( plugins.hasPlugin( SpotBugsPlugin.class ), ""spotbugs"" ),                 () -> assertTrue( plugins.hasPlugin( ErrorPronePlugin.class ), ""errorprone"" ),                 () -> assertTrue( plugins.hasPlugin( CheckstylePlugin.class ), ""checkstyle"" ),                 () -> assertTrue( plugins.hasPlugin( JavaLibraryPlugin.class ), ""java"" )         );          Collection sourceSets                 = project.getExtensions().getByType( SpotBugsExtension.class ).getSourceSets();          assertThat( sourceSets ).isNotEmpty();     }      class PluginProvider implements ArgumentsProvider {          @Override         public Stream provideArguments( ExtensionContext context ) {             return Stream.of(                     Collections.singletonList( XenoJavaLibPlugin.class ),                     Arrays.asList( JavaLibraryPlugin.class, XenoCodeQualityPlugin.class )             ).map( Arguments::of );         }     } ```  the exception I get is   ``` java.lang.NoSuchMethodException: com.xenoterracide.gradle.plugin.XenoPluginTest$PluginProvider.()  	at java.lang.Class.getConstructor0(Class.java:3082) 	at java.lang.Class.getDeclaredConstructor(Class.java:2178) 	at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:404) 	at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$1(ParameterizedTestExtension.java:70) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:101) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:38) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:113) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 	Suppressed: org.junit.platform.commons.util.PreconditionViolationException: Configuration error: You must provide at least one argument for this @ParameterizedTest 		at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:282) 		at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$7(ParameterizedTestExtension.java:78) 		at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) 		at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:271) 		... 52 more ```","closed","theme: parameterized tests,","xenoterracide","2018-06-05T23:40:22Z","2018-09-11T16:12:10Z"
"","1432","Investigate warning printed when compiling Kotlin code","``` w: junit5/junit-jupiter-params/src/main/kotlin/org/junit/jupiter/params/aggregator/ArgumentsAccessor.kt: (23, 47): Extension is shadowed by a member:    public abstract operator fun get(index: Int): Any! ```  ## Deliverables  - [x] Figure out if this is a problem, i.e. if both methods can still be called from Kotlin code - [x] Fix or suppress warning for this specific case","closed","component: Kotlin,","marcphilipp","2018-05-25T10:20:29Z","2018-06-09T15:21:26Z"
"","1780","Add support for booleans in @ValueSource","`@ValueSource` supports all the primitive types, Classes and Strings, i.e. all the compile time constants, except `boolean`s. This is a motion to fix this gap.  See also #1235 where all the others were added, and where @sbrannen said: > Although it doesn't make sense to support literals of type `boolean` (since there are only two possible such values)  My argument is: 2 is still more than 1 input that `@Test` ""supports"", so I have to use a `@ParameterizedTest` if I want to execute a test of same setup and expectation for both `true` and `false`, e.g.: ```kotlin @ValueSource(booleans = [true, false]) @ParameterizedTest fun `foo works regardless of`(someOtherSetting: Boolean) { 	sut.someOtherSetting = someOtherSetting 	// setup for foo() omitted  	val result = sut.foo()  	// verify foo() result } ```  ## Deliverables  - [ ]  Add support for `boolean` values via a new `booleans` attribute in `@ValueSource`. - [ ] Introduce appropriate tests in `org.junit.jupiter.params.provider.ValueArgumentsProviderTests` - [ ]  Document in User Guide. - [ ]  Document in Release Notes.","closed","theme: parameterized tests,","TWiStErRob","2019-02-16T11:59:03Z","2019-03-09T13:16:57Z"
"","1511","Parallel execution and @TestInstance(PER_CLASS) result in concurrency issues for instance fields mutated in test and lifecycle methods","`@TestInstance` annotation seems to cause threading problems with tests in Spring Boot.  ```xml 5.3.0-M1 1.2.0 ```  I was able to replicate this problem by creating a small Spring Boot application using the Spring Initializer (https://start.spring.io/).  The application:  ```java package com.example.demo;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class DemoApplication {  	public static void main(String[] args) { 		SpringApplication.run(DemoApplication.class, args); 	} } ```  A dummy class for testing:  ```java package com.example.demo;  public class Klass {     public Klass(String field) {         this.field = field;     }      public String getField() {         return field;     }      public void setField(String field) {         this.field = field;     }      String field; } ```   My test class:  ```java package com.example.demo;  import org.junit.Test; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.RepeatedTest; import org.junit.jupiter.api.TestInstance; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit.jupiter.SpringExtension; import org.springframework.test.context.junit4.SpringRunner;  // @TestInstance(TestInstance.Lifecycle.PER_CLASS) // Needed for BeforeAll annotation but causes threading issues.  @ExtendWith(SpringExtension.class) @SpringBootTest(classes = {DemoApplication.class}) public class DemoApplicationTests {  	@Test 	public void contextLoads() { 	}  	Klass klass = null;  	@BeforeEach 	public void beforeEach() { 		klass = new Klass(Thread.currentThread().getName()); 	}  	@RepeatedTest(8) 	public void parallel() { 		klass.setField(""Modified: "" + klass.getField()); 	}  	@AfterEach 	public void afterEach() { 		System.out.println(String.format(""%s - %s"", Thread.currentThread().getName(), klass.field )); 	} } ```   Output when not using `@TestInstance`:  ``` ForkJoinPool-1-worker-3 - Modified: ForkJoinPool-1-worker-3 ForkJoinPool-1-worker-0 - Modified: ForkJoinPool-1-worker-0 ForkJoinPool-1-worker-2 - Modified: ForkJoinPool-1-worker-2 ForkJoinPool-1-worker-3 - Modified: ForkJoinPool-1-worker-3 ForkJoinPool-1-worker-4 - Modified: ForkJoinPool-1-worker-4 ForkJoinPool-1-worker-4 - Modified: ForkJoinPool-1-worker-4 ForkJoinPool-1-worker-6 - Modified: ForkJoinPool-1-worker-6 ForkJoinPool-1-worker-2 - Modified: ForkJoinPool-1-worker-2 ```  Output when using `@TestInstance`:  ``` ForkJoinPool-1-worker-0 - Modified: ForkJoinPool-1-worker-4 <<< oops ForkJoinPool-1-worker-2 - Modified: ForkJoinPool-1-worker-4 <<< ForkJoinPool-1-worker-3 - Modified: ForkJoinPool-1-worker-3 ForkJoinPool-1-worker-0 - Modified: ForkJoinPool-1-worker-0 ForkJoinPool-1-worker-4 - Modified: ForkJoinPool-1-worker-0 <<< ForkJoinPool-1-worker-2 - Modified: ForkJoinPool-1-worker-2 ForkJoinPool-1-worker-3 - Modified: ForkJoinPool-1-worker-3 ```","closed","component: Jupiter,","dlanaghen","2018-07-27T18:38:58Z","2018-08-13T18:51:11Z"
"","1658","Introduce LOCALE and TIME_ZONE constants in Resources","` java.util.Locale.setDefault()` `java.util.TimeZone.setDefault()`  https://junit-pioneer.org/docs/default-locale-timezone/","closed","component: Jupiter,","sdavids","2018-11-01T10:05:33Z","2018-11-03T17:11:55Z"
"","1900","New annotation ""@Requirement""","_On the last JUG I met @sormuras and he motivated me to participate for the first time by presenting a feature-request. So here it is._  **Motivation:** When we write tests we do this mostly because of two reasons:  1. Avoid technical errors (like NPE) 2. Ensure our code fullfills the defined requirements / avoid functional errors  But as of today (_as far as I know_) the only way to ""link"" a test to a requirement is by using it's (displayed) name, for example putting the id of the requirement (_I'll call this ""req-id"" in the following lines_) in front of the name - like `req123_testSomethingInThisMethod`. I think you all agree that this is not a good way to show that this method is a test to ensure the requirement with the id `req123`.  **Suggestion:** Therefore I would like to suggest do add a new annotation `@Requirement`.  This annotation should be used to show that a particular test is written to ensure the specific requirement. The annotation takes the req-id as a string parameter, e.g. (`@Requirement(""REQ-123"")`). In the test result this req-id is then published as an attribut of the test case. This allows tools which parse the result to show if all tests annotated with a given req-id have passed and therefore the requirement is fullfilled.  I don't see the need of making this annotation repeatable on a method. In my opinion each test method should only verify one aspect. I also don't see the need of using this annotation on class level as I in my opinion a test calls - especially for small methods - may contain technical and functional tests.  Maybe this can also be taken into the considerations about a standard test result format (https://github.com/ota4j-team/opentest4j/issues/9)  **Lookout:**  To be honest only printing an additional attribut containing the id of a requirment is only one part of a useful funcitonality to check if all requirements are fullfilled. As without a list of definied requirements the report only containts information about tests which are annotation with a requirment but the report (tool) doesn't know if there were tests to all requirements. While I'm quite sure the suggested annotation should be a feature of JUnit I'm not sure if the ""linking functionality"" is seen as one by the JUnit-Team. I'll make a short description of what I mean, then maybe it's more clear:  To compare a list of requirements to the list of test results a comparator needs an input of this list. So I see the need of some module which takes this list (e.g. a file, service call, etc.) as an input and compares it with the test results and then creates a report which shows the reader which requirements don't have test at all, or which tests of a given requirement have passed/failed.  But maybe this is just a second step and - as mentioned - maybe not even in focus of JUnit.","closed","component: Jupiter,","Bukama","2019-05-25T10:25:03Z","2021-05-15T12:25:17Z"
"","1791","JUnit 4 vintage tests fail with NPE when run together with JUnit 5 tests","[StackOverflow Post](https://stackoverflow.com/questions/54747636/junit-4-vintage-tests-fail-with-npe-when-run-together-with-junit-5-tests)  When I run a set of JUnit 4 tests on their own, they run without a problem, but when I execute the package of tests, the JUnit 4 tests throw Nullpointer Exceptions when trying to mock the method of a mocked instance.  For testing one of my methods, I need to mock the behaviour of a static method of a library (an API call) for this I am using Powermock with Mockito, which only runs under JUnit 4, so I need to run them with JUnit Vintage in our project.  The Project is a SpringBoot Project.  ## Steps to reproduce  ```Java import com.chargebee.Result; import com.chargebee.internal.Request; import com.chargebee.org.json.JSONObject; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mockito; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.transaction.annotation.Transactional;  @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @ActiveProfiles({""dev""}) @Transactional public class CheckJunit4 {     @Rule     public PowerMockRule rule = new PowerMockRule();      @Test     public void subscriptionDeletedEvent() throws Exception {         Request mockedRequest = Mockito.mock(Request.class);         Mockito.when(mockedRequest.request()).thenReturn(new Result(200, new JSONObject(""{"" + ""\""event\"": {"" + ""\""event_type\"": \""subscription_deleted\"","" + ""\""content\"": {"" + ""\""customer\"": {"" + ""\""id\"": \"""" + ""12344"" + ""\"","" + ""},"" + ""}"" + ""}"" + ""}"")));     } }   ```  When I run the file with the JUnit 4 tests on their own, all of them pass, but when I run the package of tests (one file with JUnit5 and one with JUnit 4 tests), a NPE gets thrown at Mockito.when(mockedRequest.request()).  Problel occurs when running the tests with the IDE launcher  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter + Vintage Junit 4.12, Jupiter 5.4.0 Vintage Engine 5.4.0 Mockito 2.8.9 SpringBootVersion 2.0.0.BUILD-SNAPSHOT   - Build Tool/IDE: Gradle/IntelliJ Idea  **Edit:** The problem also occurs when I remove all PowerMock Code","closed","component: Vintage,","AntonOellerer","2019-02-22T11:05:30Z","2019-07-19T10:12:46Z"
"","1929","Implicit conversion of complete set of java.time types","[Implicit conversion](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-argument-conversion-implicit) is supported for most `java.time.*` types. However, there are some missing ones:  * `Period` * `Duration` * `MonthDay` * `ZoneId` * `ZoneOffset`  Please can the set of implicit conversion types be extended to support these additional types.","closed","theme: parameterized tests,","jodastephen","2019-06-14T11:40:17Z","2019-06-20T07:58:06Z"
"","1767","Introduce @DependsOn annotation to prioritize test method execution order","@**Update**: _Now it works exactly like TestNG, which means if A depends on B, and B is disabled, then A is disabled as well_.  Hi everyone,  I am creating a pull request for this feature. It should work similar to TestNG (`@Test(dependsOn = ...)`) but it will not disable the test if some test fails. It just gives methods a priority like `@Order`.  It would be great if someone can give me some advice how to improve it.  Thank you :)","open","status: waiting-for-interest,","duckladydinh","2019-02-09T05:17:52Z","2022-07-12T09:56:10Z"
"","1702","ExtendWith triggers java.lang.NullPointerException when tests run with Maven","?","closed","3rd-party: Maven Surefire,","blockjon","2018-12-14T07:36:36Z","2018-12-27T15:41:40Z"
"","1708","Test does not start","1) Pom.xml  ```            org.junit.platform     junit-platform-commons     1.3.2     test                org.junit.jupiter         junit-jupiter-api         5.3.2         test                    org.junit.vintage         junit-vintage-engine         5.3.2         test         ```  2) Test class  ``` import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.assertTrue;  public class StandartTest { @Test public void succeedingTest() { System.out.println(""test started""); assertTrue(4==4); System.out.println(""test finished""); } } ```  Console output  ``` -------------------------------------------------------  T E S T S -------------------------------------------------------  Results :  Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  Why does the test did not start?","closed","component: Jupiter,","mopsafe","2018-12-23T13:18:16Z","2018-12-23T13:30:07Z"
"","1953","Link to Truth docs instead of GitHub landing page.","---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","theme: documentation,","cpovirk","2019-07-09T21:15:59Z","2019-07-10T06:32:19Z"
"","1869","Introduce findRepeatableAnnotations(Optional, Class) in AnnotationSupport","- [x] Introduce `org.junit.platform.commons.support.AnnotationSupport.findRepeatableAnnotations(Optional, Class)`","closed","component: Platform,","sbrannen","2019-05-04T17:44:09Z","2019-05-04T17:46:04Z"
"","1146","Create 5.0.2 Release Notes","- [x] Create Release Notes for 5.0.2","closed","type: task,","marcphilipp","2017-11-05T17:37:20Z","2017-11-12T12:38:01Z"
"","1071","Implementation of TestExecutionListener called LoggingListener doesn't print to console","- ( ) **Question.**   I'm trying to execute the LoggingListener with the LauncherDiscoveryRequest but don't work.  - ( ) **Bug report.**  Junit version:  5.0.0 Expected: print in console somethig similar to ``` 2017-09-20 10:53:48.041  INFO 11596 --- TestPlan Execution Started: .... 2017-09-20 10:53:48.041  INFO 11596 --- TestPlan Execution Finished: .... ``` Actual behavior: Don't print nothing. You cant test it with:  ```java import static org.junit.platform.engine.discovery.ClassNameFilter.includeClassNamePatterns; import static org.junit.platform.engine.discovery.DiscoverySelectors.selectPackage;  import org.junit.platform.launcher.Launcher; import org.junit.platform.launcher.LauncherDiscoveryRequest; import org.junit.platform.launcher.TestExecutionListener; import org.junit.platform.launcher.TestIdentifier; import org.junit.platform.launcher.TestPlan; import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder; import org.junit.platform.launcher.core.LauncherFactory; import org.junit.platform.launcher.listeners.LoggingListener;  public class MainPrueba {     public static void main(String[] args) throws InterruptedException {         Runnable task = () -> {             LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()                 .selectors(                         selectPackage(""org.package.qabootfx.test.ping"")                         //,selectClass(QabootfxApplicationTests.class)                 )                 .filters(                     //includeClassNamePatterns("".*Test"")                         includeClassNamePatterns("".*"")                 )                 .build();             Launcher launcher = LauncherFactory.create();              // Register a listener of your choice             //TestExecutionListener listener = new SummaryGeneratingListener();             TestExecutionListener listener = LoggingListener.forJavaUtilLogging(); //new LoggingListener();             launcher.registerTestExecutionListeners(listener);             launcher.execute(request);         };         new Thread(task).start();         Thread.sleep(5000);     } } ```","closed","status: invalid,","ballgas","2017-09-20T19:26:06Z","2017-09-20T20:23:14Z"
"","1954","Regression: discovery for @Nested test classes with same superclass no longer works","**Version 5.5.0**  Given the following:  ```java     abstract class AbstractClassWithNestedTest {          abstract String expectedValue();          @Nested         class AbstractNested {              @Test             void abstractClassAssert1() {                 Assertions.assertEquals(expectedValue(), ""pass"");             }         }     } ```  and  ```java class MainTest {      @Nested     class Inner1  extends AbstractClassWithNestedTest {          @Override         String expectedValue() {             return ""pass"";         }     }      @Nested     class Inner2 extends AbstractClassWithNestedTest {          @Override         String expectedValue() {             return ""fail"";         }     } } ```  **Expected Behavior:** `abstractClassAssert1()` to execute twice; once as instance of `Inner1` with a passing test and once as instance of `Inner2` with a failing test.  **Actual Behavior:** `abstractClassAssert1()` executes only once as instance of `Inner1` with a passing test.  If I remove class `Inner1` then `abstractClassAssert1()` executes only once as instance of `Inner2` and test fails.  If I declare class `Inner2` before class `Inner1` then `abstractClassAssert1()` executes  only once as instance of `Inner2` and test fails.  If I remove class `AbstractNested` and declare `abstractClassAssert1()` inside of class `AbstractClassWithNestedTest` then `abstractClassAssert1()` executes twice; once as instance of `Inner1` with a passing test and once as instance of `Inner2` with a failing test.","closed","theme: discovery,","mbush8","2019-07-10T14:58:43Z","2019-07-16T09:21:19Z"
"","1635","Introduce 'empty or null' source annotations for parameterized tests","**Superseded by #1637**  ## Overview  I would like to propose two new annotations :  - `@EmptyStringSource`: provides a parameterized test with the following values : the `null` String, the empty String, and the blank String - `@EmptyListSource`: provides a parameterized test with the following values : the `null` List and the empty List  ### Reasoning  - Given a method having a String input, I often have preconditions throwing an error on the null/empty/blank values - I have then to cover all those use cases in unit tests - Same for the null/empty list - I can't pass `null` to `@ValueSource` or any other annotation  I ended up developing those annotations to avoid redundant code. And following that, I ended up copy/pasting them in several projects.  So I thought maybe it could be baseline in `junit-jupiter-params`.  What do you think?  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","jmaniquet","2018-10-14T15:14:43Z","2018-10-20T10:32:30Z"
"","1575","TestInstance.Lifecycle on enclosing class not inherited by @Nested test class","**JUnit version:**  `master` branch, commit 16ac9ac4de (git describe: r5.3.0-RC1-47-g16ac9ac4de).  **Expected behaviour:**   - Configured `Lifecycle.PER_CLASS` is inherited in Nested test class from the outer class. - `@Nested` class cannot override enclosing class's `Lifecycle` - Ref: https://github.com/junit-team/junit5/issues/1566#issuecomment-416966563  **Actual behaviour:**  - `@Nested` test class has `Lifecycle.PER_METHOD` - `@Nested` test class can override enclosing class's `Lifecycle`  **Test case:** ```java import java.util.Optional;  import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestInstance; import org.junit.jupiter.api.extension.BeforeEachCallback; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.api.extension.ExtensionContext; import org.junit.jupiter.api.extension.TestInstanceFactory; import org.junit.jupiter.api.extension.TestInstanceFactoryContext; import org.junit.jupiter.api.extension.TestInstantiationException;  import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS; import static org.junit.platform.commons.util.ReflectionUtils.newInstance;  /**  * @author Sean Flanigan sflaniga@redhat.com  */  @ExtendWith(BeforeEachLogger.class) // if you enable this, it show that InnerTestCase really is constructed twice: //@ExtendWith(CustomTestInstanceFactory.class) @TestInstance(PER_CLASS) class OuterTestCase {      @Test     void outerTest() {         System.out.println(""executing outerTest"");     }      @Nested     // Unless you specify PER_CLASS again, the InnerTestCase will be     // constructed more than once, despite the PER_CLASS on OuterTestCase //    @TestInstance(PER_CLASS)     class InnerTestCase {          @Test         void innerTest1() {             System.out.println(""executing innerTest1"");         }          @Nested         class InnerInnerTestCase {              @Test             void innerTest2() {                 System.out.println(""executing innerTest2"");             }         }     } }  class BeforeEachLogger implements BeforeEachCallback {     @Override     public void beforeEach(ExtensionContext context) throws Exception {         System.out.println(""beforeEach() called for: "" + context.getRequiredTestMethod());         // It APPEARS that getTestInstanceLifecycle is always present in beforeEach         // but this seems to be undocumented.         System.out.println(""beforeEach() lifecycle: "" + context.getTestInstanceLifecycle().get());     } }  class CustomTestInstanceFactory implements TestInstanceFactory {     @Override     public Object createTestInstance(             TestInstanceFactoryContext factoryContext,             ExtensionContext extensionContext)             throws TestInstantiationException {         try {             Optional outerInstance = factoryContext.getOuterInstance();             Class testClass = factoryContext.getTestClass();             if (outerInstance.isPresent()) {                 System.out.println(""createTestInstance() called for inner class: "" + testClass.getSimpleName());                 return newInstance(testClass, outerInstance.get());             }             else {                 System.out.println(""createTestInstance() called for outer class: "" + testClass.getSimpleName());                 return newInstance(testClass);             }         }         catch (Exception e) {             throw new TestInstantiationException(e.getMessage(), e);         }     } } ```","closed","component: Jupiter,","seanf","2018-09-01T01:28:33Z","2018-09-01T12:39:24Z"
"","1513","Use @BeforeEach method return value as an implicit ParameterResolver","**Feature request.**  Been reading https://junit.org/junit5/docs/current/user-guide/#writing-tests-dependency-injection and thinking I often write things like:  ```java     private Project project;      @BeforeEach     void setup() throws Exception {         project = ProjectBuilder.builder().build();         Git git = new InitCommand().setDirectory( project.getProjectDir() ).call();         RevCommit one = git.commit().setMessage( ""one"" ).setAllowEmpty( true ).call();     }       @ParameterizedTest     @ArgumentsSource( PluginProvider.class )     void codeQuality( Collection>> pluginClass ) {         pluginClass.forEach( project.getPluginManager()::apply ); ```   where I create a new instance of something simply to ensure the state is known prior to running the test, however it would be nice to be able to achieve this same thing by writing:   ```java     @BeforeEach     Project setup() throws Exception {         Project project = ProjectBuilder.builder().build();         Git git = new InitCommand().setDirectory( project.getProjectDir() ).call();         RevCommit one = git.commit().setMessage( ""one"" ).setAllowEmpty( true ).call();         return project;     }       @ParameterizedTest     @ArgumentsSource( PluginProvider.class )     void codeQuality( Project project, Collection>> pluginClass ) {         pluginClass.forEach( project.getPluginManager()::apply );  ```  this seems more functional and certainly requires less state mutation. I know I could write a `ParameterResolver`, but it honestly doesn't seem as natural.  ## Related Issues  - #1657","closed","component: Jupiter,","xenoterracide","2018-07-31T04:05:10Z","2019-07-19T19:32:26Z"
"","1246","Timeout Rule replacement","**Feature request** We have a large number of end-to-end automation tests that have a dependency on an external resource (e.g. network calls, actual db, etc). There have been times that a test run will get caught up waiting for db locks, etc. In JUnit 4 we solve these problems by using the Timeout rule on a base class that our automation test classes extends. I don't see any way to replicate that behavior in JUnit 5, though.  According to the following comment it sounds like the only current solution is to use the assertions that have a timeout, but this only works for a timeout of the assertion itself, not for other parts of the test method (e.g. during setup).  [#343](https://github.com/junit-team/junit5/issues/343#issuecomment-238154229)  **Deliverable** Have a way of preemptively terminating an executing test at any point in it's lifecycle.  **P.S.** I suppose if we had control of the thread executing the tests at an appropriate time (so that the time countdown doesn't include time waiting for the test to actually start executing) as per this issue we could solve this with an extension similarly to how the timeout rule works, but I'm unsure of how much control the actual implementation of this issue will give extension authors.  [#20](https://github.com/junit-team/junit5/issues/20)","closed","status: duplicate,","littleclay","2018-01-17T06:44:10Z","2018-01-17T11:27:58Z"
"","1469","Java 10/JUnit 5/Spring Boot 2: Unit tests fail when Surefire forkCount > 0 or not specified","**Dependencies** `JUnit`: 5.2.0 `Spring Boot`: 2.0.3-RELEASE `Java`: 10 *(in module mode)* `Surefire`: 2.22.0  **Error** When I run the tests, I see the following error:  ``` java.lang.NoClassDefFoundError: Could not initialize class org.springframework.test.context.TestContextManager 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$0(ExtensionValuesStore.java:78) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:183) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:85) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:89) 	at org.junit.jupiter.engine.execution.NamespaceAwareStore.getOrComputeIfAbsent(NamespaceAwareStore.java:61) 	at org.springframework.test.context.junit.jupiter.SpringExtension.getTestContextManager(SpringExtension.java:202) 	at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:76) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$invokeBeforeAllCallbacks$5(ClassTestDescriptor.java:224) 	at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.invokeBeforeAllCallbacks(ClassTestDescriptor.java:224) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.before(ClassTestDescriptor.java:161) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.before(ClassTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:111) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) 	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:121) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at org.junit.platform.surefire.provider.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:132) 	at org.junit.platform.surefire.provider.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:111) 	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:383) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:344) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:417) 	Suppressed: java.lang.NoClassDefFoundError: Could not initialize class org.springframework.test.context.TestContextManager 		at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$0(ExtensionValuesStore.java:78) 		at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:183) 		at org.junit.jupiter.engine.execution.ExtensionValuesStore.remove(ExtensionValuesStore.java:99) 		at org.junit.jupiter.engine.execution.NamespaceAwareStore.remove(NamespaceAwareStore.java:73) 		at org.springframework.test.context.junit.jupiter.SpringExtension.afterAll(SpringExtension.java:88) 		at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$invokeAfterAllCallbacks$9(ClassTestDescriptor.java:262) 		at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40) 		at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$invokeAfterAllCallbacks$10(ClassTestDescriptor.java:262) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1378) 		at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.invokeAfterAllCallbacks(ClassTestDescriptor.java:262) 		at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.after(ClassTestDescriptor.java:177) 		at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.after(ClassTestDescriptor.java:65) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeAfter(HierarchicalTestExecutor.java:135) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:128) 		... 29 more ```  **Test Case** One of my tests:  ```java @ExtendWith(SpringExtension.class) @DataJpaTest @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) @ActiveProfiles(""test"") public class UserRepositoryTest {      @Autowired     private TestEntityManager testEntityManager;      @Autowired     private UserRepository userRepository;      @AfterEach     public void tearDown() {         userRepository.deleteAll();     }      @Test     public void whenFindBySomeUserId_thenReturnUser() {         // given         User user1 = new User();         user1.setSomeAccountId(""274712734545"");         user1.setSomeUserId(""ABC123TEST"");         user1.setSomeUserName(""test-demo"");          testEntityManager.persistAndFlush(user1);          // when         User found = userRepository.findBySomeUserId(user1.getAwsUserId());          // then         assertEquals(user1.getSomeUserId(), found.getSomeUserId());     } } ```  **Expected behavior:** Tests run successfully when `forkCount` != 0  **Actual behavior:** All tests fail, unless I set `forkCount` to 0 in my `surefire` configuration  ```xml                              org.apache.maven.plugins                 maven-surefire-plugin                 2.22.0 		 			1 		                                                               org.ow2.asm                         asm                         6.2                      		    			org.junit.platform 			junit-platform-surefire-provider 			1.2.0 		                                  ```","closed","3rd-party: Maven Surefire,","testphreak","2018-06-17T01:03:53Z","2018-07-25T19:41:20Z"
"","1491","Memory issues with concurrent ParameterizedTest","**Bug report**  I am trying to make use of the new concurrency features in 5.3.0-M1 to speed up some long running parameterized tests. With JUnit 5.2 or with 5.3.0-M1 using `SAME_THREAD` execution mode, everything works as expected. With 5.3.0-M1 and `CONCURRENT` execution mode, the test runs only for a short while, after which the VM starts getting very busy with garbage collection and the execution of the actual test code clogs up and comes almost to a complete halt.  Simplified code, with which the behavior can be reproduced:  ```java @TestInstance(TestInstance.Lifecycle.PER_CLASS) @Execution(CONCURRENT) public class OOMTest {      @ParameterizedTest     @MethodSource     public void test(int a, int b, int c, int d) {      }      public Stream test() {         return IntStream.range(0, 1000).boxed()                 .flatMap(a -> IntStream.range(0, 1000).boxed()                         .flatMap(b -> IntStream.range(0, 1000).boxed()                                 .flatMap(c -> IntStream.range(0, 1000).boxed()                                         .map(d -> Arguments.of(a, b, c, d)))));     }  }  ```  In reality, we have a method source, which reads real production data from a database on an 'on demand' basis. The test arguments are not read from the DB until they are actually pulled from the stream. The simplified test code emulates this behavior by generating the Cartesian product of four sets of integers in the range [0, 999] to form the four test arguments.  When this test is run in concurrent execution mode, it seems as if the argument stream is very eagerly consumed, long before any test runner is free to actually execute the test code. With a 4GB default heap limit, the pasted test code slows down on my machine already after a few 10.000 test cases as it is filling up the available heap. A heap dump shows that about 1.500.000 instances of `org.junit.platform.launcher.TestIdentifier` and `org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor` have already been created. Each instance of `TestTemplateInvocationTestDescriptor` contains an invocation context with an `Object` array with arguments, which have already been pulled from the argument stream.  I haven't looked into the implementation, but it looks to me as if something is reading the arguments from the stream, creating some kind of executable test task and puts these tasks into an executor queue at a much higher rate than they can be consumed. Limiting the size of the queue will probably solve the problem.","closed","component: Platform,","jarnbjo","2018-07-09T17:16:29Z","2018-08-03T16:29:44Z"
"","1592","JUnit Jupiter Assumptions do not work in @BeforeAll methods","* JUnit version: 5.1.0 * JUnit platform version: 1.1.0  The following test will fail with a `TestAbortedException`:  ```java public class AssumptionTestJUnit5 {      @BeforeAll     static void setup() {         Assumptions.assumeTrue(false);     }      @Test     void someTest() throws Exception {         // Never reached     } } ```  I would expect that a failed assumption in the setup method would simply skip the tests instead of triggering a test failure.  The following JUnit4 test (run against the JUnit4 test runner) matches my expectations; it skips the tests instead of reporting a failure:  ```java public class AssumptionTestJUnit4 {      @BeforeClass     public static void setup() {         Assume.assumeTrue(false);     }      @Test     public void someTest() throws Exception {         // Never reached     } } ```","closed","component: Vintage,","jkarshin","2018-09-20T19:15:36Z","2020-11-26T20:40:37Z"
"","1617","Better support for accessing test class and test instance fields","(ReflectionUtils approach)  Resolves #1611.  ## Overview  Please describe your changes here and list any open questions you might have.  Attempt to implement ReflectionSupport approach. Please comment with suggestions.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","zoltanersek","2018-10-04T11:48:07Z","2019-01-22T14:23:32Z"
"","1294","JUnit5 Platform Launcher API - Cannot create Launcher without at least one TestEngine","> Copying from StackOverflow due to inactivity: https://stackoverflow.com/questions/48672051/junit5-platform-launcher-api-cannot-create-launcher-without-at-least-one-teste  I am attempting to upgrade the testing abilities of our automated testing suite to accept JUnit5 tests and when following The [JUnit Platform Launcher API instructions][1] I get the error **""Cannot create Launcher without at least one TestEngine; consider adding an engine implementation JAR to the classpath""**. The cause is that the following is unable to find any instances of `TestEngine`:  ```java Iterable testEngines = ServiceLoader.load(TestEngine.class,ClassLoaderUtils.getDefaultClassLoader()); ```  Do you have any suggestions on how to ensure that the `ServiceLoader` is able to find an instance of `TestEngine`?  I have included `org.junit.jupiter.engine`, which contains `JupiterTestEngine` which implements `TestEngine`, as a required plugin. I have tried adding a direct path to the `jupiter.engine` JAR in the project's `.classpath`. I have tried creating an instance of `JupiterTestEngine` within the same file and it is created successfully, but still no ```TestEngine```s found by the service loader.  This is for Eclipse and you can see the code base here: http://git.eclipse.org/c/platform/eclipse.platform.releng.git/tree/bundles/org.eclipse.test  I added the following to the manifest:  ```     org.junit.platform.launcher,     org.junit.jupiter.api;bundle-version=""5.0.0"",     org.junit.platform.engine;bundle-version=""1.0.0"",     org.junit.platform.commons;bundle-version=""1.0.0"",     org.junit.jupiter.engine;bundle-version=""5.0.0"",     org.junit.vintage.engine;bundle-version=""4.12.0"" ```  Added this to the `.classplath`: ``  Added the `org.junit.jupiter.engine` JAR to the lib folder then added it to be included in the binary build. (I'm stretching for a solution)  And I'm trying to get the Tutorial code to work in an edited version of http://git.eclipse.org/c/platform/eclipse.platform.releng.git/tree/bundles/org.eclipse.test/src/org/eclipse/test/EclipseTestRunner.java with all the old JUnit code removed and `LauncherFactory.create();` added to the `EclipseTestRunner` constructor.    [1]: https://junit.org/junit5/docs/current/user-guide/#launcher-api","closed","theme: discovery,","LucasBullen","2018-02-12T15:14:57Z","2018-02-14T08:57:18Z"
"","1768","Introduce @DependsOn annotation for method ordering","### Introduction  Hi,  I want to implement the feature as I suggested in #1767: A mechanism for scenario testing. I really want to make a contribution to open source project. If there is something not good, it would be great if you can give me some advice :).   Thank you.  ---  ### Usage   ###### You can add the following annotations to your test class.  **_@TestMethodOrder(DependsOnAnnotation.class)_** - Most important: It sorts the test methods according to the dependent order, but this alone does not disable child method if any ancestor method fails.  **_@ExtendWith(DependsOnTestWatcher.class)_** - Second most important: It will disable child method if any ancestor method fails.  ###### You can add the following annotation to your test method.  **_@DependsOn(""ancestorMethodName"")_** - Most important: It will provide the relative relationship that you want to realize.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","duckladydinh","2019-02-09T05:26:46Z","2021-09-08T14:31:27Z"
"","1306","Allow to reference test parameters that aren't among the method arguments","### Feature Request Would you please consider allowing referencing a test parameter in a formatting string when it does not appear in a formal method parameter list?  Consider the following code:  ```java import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.stream.Stream; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  class SampleTest {    @ParameterizedTest(name = ""{1}: {0}"")   @MethodSource(""testParameters"")   void test(String s,             // IDE highlights 'testDescription' variable below as unused,             // although it is used in the formatting string (as {1}).             String testDescription) {     assertThrows(NumberFormatException.class,         () -> Integer.parseInt(s)     );   }    static Stream testParameters() {     return Stream.of(         Arguments.of(""1a"", ""illegal character""),         Arguments.of(""10000000000000"", ""out of bounds"")     );   } } ```  The IDE highlights `testDescription` variable below as unused, although it is used in the formatting string (as `{1}`). Even if this issue is [fixed](https://youtrack.jetbrains.com/issue/IDEA-184660) in Intellij IDEA, I believe many static analysis tools out there might not be updated.  A possible workaround is to mark the parameter with `@SuppressWarnings(""unused"")`, but it's tedious to write each time.  If `testDescription` is removed, JUnit will not replace `{1}`, resulting in the following output (as of 5.1.0): ``` {1}: 1a {1}: 10000000000000 ```  There are some things to consider:   - (+) A user can omit an extra parameter when it's meaning is clear from the context.   - (+) A user can omit any number of parameters (a ""tail"" of parameters), that are not related to the current parameterized test, but still reference any of them in the description. That might be useful, when some arguments are not necessary in all parameterized tests sharing the same arguments source.   - (-) This feature will improve readability only if a test method and its arguments source are _adjacent_. When an index to a parameter that is not among method parameters is included in the formatting string *and* the arguments source is far from the parameterized test, it will confuse the readers. In that case it would be cleaner to add a method parameter and give it a proper name.   - (-) Can't say how much, but I think support for this feature might make the JUnit internals more complex.  ### Alternatives  As suggested by @sormuras , add a `description` method to the `Arguments` interface + a transforming method that sets a description, e.g.:  ```java Arguments {   Arguments description(String newDescription);   Arguments description(); } ```","closed","theme: parameterized tests,","dmitry-timofeev","2018-02-23T19:44:21Z","2018-03-02T18:52:23Z"
"","1307","Improve the ease of Arguments transformation","### Feature Request Please consider improving the ease of `Arguments` transformation. Currently a user can only get an underlying array of `Object`s, and cast each of them to the desired type manually.  ### Uses cases Consider the following code: ```java import static org.junit.jupiter.api.Assertions.assertThrows;  import com.exonum.serialization.runtime.StringReader; import com.exonum.serialization.runtime.testutils.ByteBuffers; import java.nio.ByteBuffer; import java.util.stream.Stream; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  class ExampleTest {    @ParameterizedTest(name = ""[{index}] {1}"")   @MethodSource(""invalidUtf8Strings"")   void testInvalidStrings(ByteBuffer buffer,                           @SuppressWarnings(""unused"") String description) {      // Check that the SuT rejects invalid UTF-8 strings in binary form.   }    private static Stream invalidUtf8Strings() {     return Stream.of(         // …         // Missing continuation bytes         Arguments.of(""DF"", ""2nd byte expected""),         Arguments.of(""EF BF"",  ""3rd byte expected"")         // …     )         .map(args -> {           String strHex = (String) args.get()[0];           ByteBuffer strBuffer = ByteBuffers.fromHex(strHex.toLowerCase());           String testDescription = (String) args.get()[1];           String fullDescription = String.format(""%s: %s"", testDescription, strHex);           return Arguments.of(strBuffer, fullDescription);         });   } ``` `invalidUtf8Strings` uses a hex-string representation of binary data, because it's easier to write and read than an array of bytes (`bytes(0xEF, 0xBF)`). That hex-string representation must be converted into a ByteBuffer to be used by the test. On top of that, the transformation function creates a friendly test description.  When `Arguments` expose only an array of `Object`s, that requires the callers to perform type casts.  ### Possible solution The following APIs may be added to simplify a transformation of an `Arguments`: - Generic specializations of an `Arguments` interface for _2…N_ number of arguments, e.g., `Arguments3`, where _N_ is the number of specializations it makes sense to support. Such interfaces must extend `Arguments`. - Overloads of factory method `Arguments.of`, for _0…N+1_. - ` R ArgumentsN#map(Function transformingFunction)`, where _X_ in _2…N_, allowing to easily transform the arguments.  ### Results The code of the source method above may evolve into either of: ```java   private static Stream invalidUtf8Strings_1() {     return Stream.of(         // Same as above ^, but here Arguments.of          // may produce an instance of Arguments2:         Arguments.of(""DF"", ""2nd byte expected"")     )         .map(args -> {           String strHex = args.first();  // or A1 get0(), TBD           ByteBuffer strBuffer = ByteBuffers.fromHex(strHex.toLowerCase());           String testDescription = args.second(); // or A2 get1()           String fullDescription = String.format(""%s: %s"", testDescription, strHex);           return Arguments.of(strBuffer, fullDescription);         });   }      private static Stream invalidUtf8Strings_2() {     return Stream.of(         // same as above ^     )         .map(args -> args.map((strHex, testDescription) -> {           ByteBuffer strBuffer = ByteBuffers.fromHex(strHex.toLowerCase());           String fullDescription = String.format(""%s: %s"", testDescription, strHex);           return Arguments.of(strBuffer, fullDescription);         }));   } } ```  ### Questions 1. Is it a common use case to transform the arguments? 2. Is it worth the effort and maintenance cost? 3. How many specializations shall we provide (what is the value of _N_)? 4. Shall we implement `ArgumentsX#map` for _X > 2_? It will require implementing the corresponding functional interfaces (if there isn't a library with them).","closed","theme: parameterized tests,","dmitry-timofeev","2018-02-24T13:01:00Z","2018-02-25T08:21:17Z"
"","1877","Missing opens directives in module descriptors","### Description  Having declared  ```java @Test @EnabledOnJre(JRE.JAVA_11) void test() {} ```  or other usages of Jupiter API that internally needs to access _package private_ types yields:  ``` Unable to make org.junit.jupiter.api.condition.EnabledOnJreCondition() accessible: module org.junit.jupiter.api does not ""opens org.junit.jupiter.api.condition""                                    to module org.junit.platform.commons ```  Module `org.junit.jupiter.api` is declared like follows: ```java module org.junit.jupiter.api { 	requires transitive org.apiguardian.api; 	requires transitive org.junit.platform.commons; 	requires transitive org.opentest4j;  	exports org.junit.jupiter.api; 	exports org.junit.jupiter.api.condition; 	exports org.junit.jupiter.api.extension; 	exports org.junit.jupiter.api.function; 	exports org.junit.jupiter.api.io; 	exports org.junit.jupiter.api.parallel; } ```  Exporting _public_ types from all 6 packages doesn't allow deep reflective access to non-public types. Thus, directives like `opens org.junit.jupiter.api.condition to org.junit.platform.commons;` need to added to this module descriptor. This goes also for all other modules that make use of the reflection support provided by module `org.junit.platform.commons`.  #### Reflecting code uses * Usages of `@ExtendWith` in JUnit ""Project Production Java Files"" ![image](https://user-images.githubusercontent.com/2319838/57631781-76ceeb00-75a0-11e9-90ad-0ac736af099f.png)  ### Deliverables - [ ] Write integration test that shows the issue. - [ ] Fix by adding appropriate `opens to org.junit.platform.commons` directives. - [ ] Find other places where reflection support from `org.junit.platform.commons` is used.","closed","theme: modules,","sormuras","2019-05-13T12:08:47Z","2020-06-05T11:36:17Z"
"","1471","Introduce assertDefaultValue method","### **Feature request** Provide convenient assertion methods for commonly used assertions, for example empty strings, assertIsZero etc, as well as a way to define a default value for your own objects.  ### **Deliverables**  - [ ] convenience methods(`assertEmptyString`, `assertIsZero`...) - [ ] way to define default value for objects  ### **Possible solutions for defining default values**  - use the default constructor of the objects - match the passed arguments to the method call with an existing constructor","closed","component: Jupiter,","Andrei94","2018-06-18T19:47:26Z","2018-06-20T10:59:49Z"
"","1815","Test Kit swallows exceptions from JUnit Jupiter extensions","## Steps to reproduce Make this extension ```java class FailingExtension implements AfterEachCallback{  @Override     public void afterEach(ExtensionContext context) throws Exception {             throw new AssertionFailedError(""fail"")     } } ``` Run this test with the testkit ```java @ExtendWith(FailingExtension .class) class Test{      @Test     void test(){         assertTrue(true);     } } ``` This test will pass, even tough we throw an exception.  ```java class TestKitTest {     @Test     @DisplayName(""tests that take too long will trigger an error"")     void longTests() {         EngineTestKit                 .engine(""junit-jupiter"")                 .selectors(selectClass(Test.class))                 .execute()                 .containers()                 .assertStatistics(stats -> stats.started(2).succeeded(0).failed(2))                 .assertThatEvents().haveExactly(1,                 event(                         test(""test()""), finishedWithFailure(                                 instanceOf(AssertionFailedError.class))                 ));     } }  ``` In the report I see this: ``` Container Event Statistics (2 failures) 	succeeded ==> expected: <0> but was: <2> 	failed ==> expected: <2> but was: <0> org.opentest4j.MultipleFailuresError: Container Event Statistics (2 failures) 	succeeded ==> expected: <0> but was: <2> 	failed ==> expected: <2> but was: <0> ``` (I'm making the assumption, that the number 2 refers to the class and the method in the tree) Running the test directly from the IDE/Gradle works. ## Context   - Used versions (Jupiter/Vintage/Platform):     Jupiter 5.4.0     vintage 5.4.0     platform 1.4.0    testkit 1.4.0  - Build Tool/IDE:   Intellij+gradle","closed","component: Test Kit,","Frontrider","2019-03-13T12:56:54Z","2019-03-14T12:47:36Z"
"","1887","[Kotlin] Compiler picks assertTimeout(Duration, Executable) over assertTimeout(Duration, ThrowingSupplier)","## Steps to reproduce  The following does not compile with the Kotlin compiler.  ```kotlin private fun timeoutTest(): Int {     return assertTimeout(Duration.ofSeconds(1)) {         42     } } ```     ## Cause  The Kotlin compiler incorrectly picks the `void assertTimeout(Duration timeout, Executable executable)` over the ` T assertTimeout(Duration timeout, ThrowingSupplier supplier)` implementation of the method.  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.4.0  - Build Tool/IDE: ``` IntelliJ IDEA 2019.1 (Ultimate Edition) Build #IU-191.6183.87, built on March 27, 2019 JRE: 1.8.0_202-release-1483-b39 x86_64 JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o macOS 10.13.6 ```  ## Deliverables  - [ ] Add explicit Kotlin implementation of `assertTimeout`.","closed","component: Kotlin,","JLLeitschuh","2019-05-20T16:11:00Z","2019-05-23T19:19:19Z"
"","1666","Exception thrown by a static @RegisterExtension field is swallowed","## Steps to reproduce  Running this test case  ```java package org.example;  import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.Extension; import org.junit.jupiter.api.extension.RegisterExtension;  class ExplosiveTests {  	@RegisterExtension 	static Extension field = new Extension() { 		{ 			if (true) { 				throw new Error(""boom""); 			} 		} 	};  	@Test 	void test() { 	} } ```  should report:   ``` java.lang.Error: boom 	at org.example.ExplosiveTests$1.(ExplosiveTestClass.java:31) 	at org.example.ExplosiveTests.(ExplosiveTestClass.java:28) ```  instead of:  ``` java.lang.NoClassDefFoundError: Could not initialize class org.example.ExplosiveTests ```  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit Jupiter 5.2.0  - Build Tool/IDE: Intellij Idea 2018.2  ## Related Issues  - #602","closed","theme: diagnostics,","mbaechler","2018-11-06T15:33:03Z","2018-11-20T15:50:36Z"
"","1714","@ParameterizedTest name only supports String formatters (no numbers, etc)","## Steps to reproduce  ```java @ParameterizedTest(name=""{0,number}"") @ValueSource(ints = {1, 2, 3}) void someTest(int testInt) {     assertTrue(testInt > 0); } ```  results in the following error during test discovery:  ``` org.junit.platform.commons.JUnitException: The display name pattern defined for the parameterized test is invalid. See nested exception for further details. 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.formatSafely(ParameterizedTestNameFormatter.java:76) ... Caused by: java.lang.IllegalArgumentException: Cannot format given Object as a Number 	at java.text.DecimalFormat.format(DecimalFormat.java:507) 	at java.text.Format.format(Format.java:157) 	at java.text.MessageFormat.subformat(MessageFormat.java:1322) 	at java.text.MessageFormat.format(MessageFormat.java:865) ```  This happens because `ParameterizedTestNameFormatter.format()` transforms all arguments into strings before invoking the `MessageFormat.format()` method. The `DecimalFormatter` however only works with numbers.  Being able to use the full range of `MessageFormat` would be useful to pad the parameter names. Also the javadoc for `ParameterizedTest.name` sounds to me, as if this functionality is supposed to be supported.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.3.2  - Build Tool/IDE: N/A","closed","theme: parameterized tests,","t-8ch","2018-12-28T10:48:53Z","2019-01-25T14:51:49Z"
"","1898","ConsoleLauncher's class-path scanning sometimes does not work","## Steps to reproduce  _Working on a minimal non-working example..._   ## Context  Starting the `ConsoleLauncher` via reflection and in-process in a layered class loader setup works as expected. Adding multiple drives (on Windows) into the equation results in the class-path scanning no longer finding tests. It is **similar**(!) to the following snippet: ``` C:\>java    --class-path junit-platform-console-standalone.jar   ...   ConsoleLauncher    ...   --class-path       Z:\project\main-classes;Z:\project\test-classes   --scan-class-path ```  ## Deliverables  - [ ] Investigate underlying issue","closed","component: Platform,","sormuras","2019-05-24T19:52:01Z","2020-06-05T10:25:49Z"
"","1928","Setting default display name generator throws exception","## Steps to reproduce  1. Clone or set up JUnit 5 project (I used the official junit5-samples/junit5-jupiter-starter-gradle but I have been able to reliably reproduce this across different projects) 2. Create `src/test/resources/junit-platform.properties` with following setting: ``` junit.jupiter.displayname.generator.default = \     org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.5.0-RC1  - Build Tool/IDE: Intellij IDEA 2019.1.3 CE - build.gradle (see below) ``` plugins { 	id 'java' 	id 'eclipse' // optional (to generate Eclipse project files) 	id 'idea' // optional (to generate IntelliJ IDEA project files) }  repositories { 	mavenCentral() }  dependencies { 	testImplementation('org.junit.jupiter:junit-jupiter:5.5.0-RC1') }  test { 	useJUnitPlatform() 	testLogging { 		events ""passed"", ""skipped"", ""failed"" 	} } ```  ## Output  ``` Jun 13, 2019 2:43:16 PM org.junit.jupiter.engine.config.DisplayNameGeneratorParameterConverter logFailureMessage WARNING: Failed to load default display name generator class 'org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores' set via the 'junit.jupiter.displayname.generator.default' configuration parameter. Falling back to default behavior. java.lang.ClassNotFoundException: org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	at org.junit.platform.commons.util.ReflectionUtils.lambda$tryToLoadClass$9(ReflectionUtils.java:779) 	at org.junit.platform.commons.function.Try.lambda$call$0(Try.java:57) 	at org.junit.platform.commons.function.Try.of(Try.java:93) 	at org.junit.platform.commons.function.Try.call(Try.java:57) 	at org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(ReflectionUtils.java:742) 	at org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(ReflectionUtils.java:698) 	at org.junit.jupiter.engine.config.DisplayNameGeneratorParameterConverter.instantiateGenerator(DisplayNameGeneratorParameterConverter.java:42) 	at org.junit.jupiter.engine.config.DisplayNameGeneratorParameterConverter.lambda$get$1(DisplayNameGeneratorParameterConverter.java:35) 	at java.base/java.util.Optional.flatMap(Optional.java:294) 	at org.junit.jupiter.engine.config.DisplayNameGeneratorParameterConverter.get(DisplayNameGeneratorParameterConverter.java:35) 	at org.junit.jupiter.engine.config.DefaultJupiterConfiguration.getDefaultDisplayNameGenerator(DefaultJupiterConfiguration.java:92) 	at org.junit.jupiter.engine.config.CachingJupiterConfiguration.lambda$getDefaultDisplayNameGenerator$6(CachingJupiterConfiguration.java:85) 	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) 	at org.junit.jupiter.engine.config.CachingJupiterConfiguration.getDefaultDisplayNameGenerator(CachingJupiterConfiguration.java:84) 	at java.base/java.util.Optional.orElseGet(Optional.java:369) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.getDisplayNameGenerator(DisplayNameUtils.java:104) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.lambda$createDisplayNameSupplierForClass$2(DisplayNameUtils.java:81) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.determineDisplayName(DisplayNameUtils.java:71) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.(JupiterTestDescriptor.java:69) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.(ClassBasedTestDescriptor.java:91) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:47) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.newClassTestDescriptor(ClassSelectorResolver.java:110) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.lambda$resolve$0(ClassSelectorResolver.java:70) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution$DefaultContext.createAndAdd(EngineDiscoveryRequestResolution.java:249) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution$DefaultContext.addToParent(EngineDiscoveryRequestResolution.java:212) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:70) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:129) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1631) 	at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) 	at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:543) ```","closed","","gabriel-ntuc","2019-06-13T06:48:34Z","2019-06-13T07:14:11Z"
"","1809","Improve ReflectionSupport.newInstance to support creating instances that have polymorphic-accepting constructors","## Steps to reproduce  * Java 8, Kotlin 1.3.21, JUnit `5.4.0`  ```kotlin import org.junit.platform.commons.support.ReflectionSupport  internal class ConstructorWithString(s: String)  internal class ConstructorWithCharSequence(n: Number)  fun main() {     val s: String = ""hey""     ReflectionSupport.newInstance(ConstructorWithString::class.java, s)     ReflectionSupport.newInstance(ConstructorWithCharSequence::class.java, s) }  ```  Fails with  ``` Exception in thread ""main"" java.lang.NoSuchMethodException: ConstructorWithCharSequence.(java.lang.String) 	at java.lang.Class.getConstructor0(Class.java:3082) 	at java.lang.Class.getDeclaredConstructor(Class.java:2178) 	at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:428) 	at org.junit.platform.commons.support.ReflectionSupport.newInstance(ReflectionSupport.java:180) 	at MkDemoReflectionSupportKt.main(mkDemoReflectionSupport.kt:10) 	at MkDemoReflectionSupportKt.main(mkDemoReflectionSupport.kt)  ```  ## Context   - Used versions (Jupiter/Vintage/Platform): `5.4.0`/-/`1.4.0`  - Build Tool/IDE:  Attempting to build an extension that uses a `ReflectionSupport.newInstance(MyType::class.java, extensionContext)` where the constructor looks like `MyType(private val extensionContext: ExtensionContext)`  but, the object fails to construct due to  ``` java.lang.NoSuchMethodException: MyType.(org.junit.jupiter.engine.descriptor.MethodExtensionContext) ```  Because a constructor is being looked up for the concrete type that is passed in rather than the interface.  My expectation was that the constructor using the interface was going to be used to instantiate the object instead of the concrete type.  ## Deliverables  If support is desired:  - [ ] Improve `ReflectionSupport.newInstance` to support instantiating types where the type doesn't match the concrete implementation type passed in as the `args` to `newInstance`","closed","component: Platform,","mkobit","2019-03-12T05:04:32Z","2019-03-17T16:26:03Z"
"","1688","Interrupted test cases cause random failures with thread reuse","## Status Quo  Whenever a test case is interrupted (`Thread.interrupt()`), the test runner thread seems to stay in interrupted state. This causes random failures later when the thread is reused for other test cases.  ## Expected Behavior  When the thread is reused, the interrupted flag for the thread is cleaned before starting a new test case. This can be done by calling `Thread.interrupted()`, which returns the interrupted state and clears the interrupted flag.  ## Steps to Reproduce  The following code reproduces the problem (when run against JUnit Jupiter 5.4 snapshots), given that `test1()` is run before `test2()`.  ```java package example;  import org.junit.jupiter.api.MethodOrderer.Alphanumeric; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestMethodOrder;  @TestMethodOrder(Alphanumeric.class) class ThreadTests {    @Test   void test1() {     Thread.currentThread().interrupt();   }    @Test   void test2() throws InterruptedException {     Thread.sleep(1000);   }  } ```  ## Analysis  This problem is reproducible using both Jupiter and Vintage (tried on version 5.3.1), launching the test both from Gradle 4.10.2 and IntelliJ IDEA 2018.3 (and previous).  I guess it is the same exact bug reported in JUnit 4 (https://github.com/junit-team/junit4/issues/1365)  ## Deliverables  - [x] Reset the interrupted flag before/after executing a `Node`. - [x] Document in Release Notes.","closed","component: Platform,","bacer-esteco","2018-11-28T06:28:54Z","2018-11-30T14:47:46Z"
"","1699","User Guide does not include all published APIs in Experimental/Deprecated sections","## Status Quo  The ""Experimental APIs"" and ""Deprecated APIs"" sections of the User Guide do not cover all published APIs since the `ApiReportGenerator` does not _see_ all published projects on its classpath.  For example, the current [Experimental APIs section](https://junit.org/junit5/docs/current/user-guide/#api-evolution-experimental-apis) does not include any APIs from the `junit-jupiter-migrationsupport` module. Similarly, prior to commit 9e4b822a0dedfd61c580aa9ca43827a7dae67da8, APIs from the new `junit-platform-testkit` were also not included.  ## Deliverables  - [x] Ensure that all published APIs are included in the ""Experimental APIs"" and ""Deprecated APIs"" sections of the User Guide via an automated process.","closed","theme: documentation,","sbrannen","2018-12-11T10:52:44Z","2018-12-11T11:05:18Z"
"","983","Introduce support for finding a method based on a predicate","## Status Quo  Currently, the Jupiter and Vintage test engines both execute exhaustive searches across the entire class hierarchy in search of all methods annotated with @Test, just to determine if there is a single such method. The results are then discarded.  This is obviously not an optimal use of resources.  ## Related Issues  - #734   ## Deliverables  - [x] Introduce support in `ReflectionUtils` for finding a method based on a predicate.","closed","component: Vintage,","sbrannen","2017-07-25T13:28:13Z","2017-07-25T13:46:09Z"
"","1589","Treat enclosing class as container for static nested test classes","## Status Quo  A `static` nested test class is currently treated identical to a top-level test class.  This applies to how it is executed and how it is displayed within the test plan hierarchy in IDEs, reports, etc.  Note that this in contrast to non-static nested test classes (i.e., `@Nested` test classes).  ## Proposal  Treat a class (potentially itself a test class) as a _container_ for any `static` nested test classes. The _enclosing_ class could be either top-level or itself a static nested class.  This new treatment would alter where such static nested test classes show up in the test plan's ""tree""; however, the manner in which such static nested classes are executed would not change, except that static nested test classes would now be guaranteed to execute after their enclosing test class.  ## Further Considerations  Implementing the proposal would affect the SPI proposals for #162, since we would then need to be able to differentiate between static and non-static nested classes.  ## Related Issues  - #162   ## Deliverables  - [ ] Decide if we want to implement the proposal.","closed","status: stale,","sbrannen","2018-09-17T12:33:55Z","2021-06-19T12:50:05Z"
"","1419","Introduce Arguments.arguments() as an alias for Arguments.of()","## Status Quo  ```java static Stream stringIntAndListProvider() { 	return Stream.of( 		Arguments.of(""foo"", 1, asList(""a"", ""b"")), 		Arguments.of(""bar"", 2, asList(""x"", ""y"")) 	); } ```  ## Proposal  ```java static Stream stringIntAndListProvider() { 	return Stream.of( 		arguments(""foo"", 1, asList(""a"", ""b"")), 		arguments(""bar"", 2, asList(""x"", ""y"")) 	); } ```  ## Deliverables  - [x] Introduce static `arguments(Object...)` method in `Arguments` which simply delegates to `Arguments.of()`.","closed","component: Jupiter,","sbrannen","2018-05-14T11:00:30Z","2018-05-14T11:41:22Z"
"","1747","Update documentation for @TempDir regarding constructor parameters","## Related Issues  - #1746  ## Deliverables  - [x] Update JavaDoc for `TempDirectory` and `@TempDir` regarding constructor parameters. - [x] Update documentation for `TempDirectory` and `@TempDir` regarding constructor parameters in the User Guide.","closed","component: Jupiter,","sbrannen","2019-01-25T15:12:26Z","2019-01-27T14:55:45Z"
"","1934","Extend JRE enum to support Java 14","## Related Issues  - #1656  ## Deliverables  Perform the following for Java 14.  - [x] Extend `JRE` enum with the new `JAVA_N` constant, with `N` being the latest feature version number. - [x] Update `EnabledOnJreIntegrationTests`, `DisabledOnJreIntegrationTests`, `EnabledOnJreConditionTests`, and `DisabledOnJreConditionTests` accordingly. - [x] Test against JDK `N`.","closed","theme: modules,","sormuras","2019-06-15T18:23:12Z","2020-06-16T10:48:51Z"
"","1760","Extend JRE enum to support Java 13","## Related Issues  - #1656  ## Deliverables  Perform the following for Java 13.  - [x] Extend `enum JRE` with the new `JAVA_N` constant, with `N` being the latest feature version number. - [x] Update `EnabledOnJreIntegrationTests`, `DisabledOnJreIntegrationTests`, `EnabledOnJreConditionTests`, and `DisabledOnJreConditionTests` accordingly. - [x] Test against JDK `N`. - [x] Document in Release Notes.","closed","theme: modules,","sbrannen","2019-02-04T19:36:41Z","2019-02-04T20:18:41Z"
"","1924","Support first/last order for extensions registered via @RegisterExtension","## Question  Would it be possible to have `@Order` annotation take priority over reverse execution order of `AfterEachCallback` extensions?  ## Overview  Assume I want extension annotated with `@Order(1)` executed first:  ```java class Tests {      @Order(1)     @RegisterExtension     AfterEachCallback first = (context -> System.out.println(""first""));      @RegisterExtension     AfterEachCallback second = (context -> System.out.println(""second""));      @RegisterExtension     AfterEachCallback third = (context -> System.out.println(""third""));      @RegisterExtension     AfterEachCallback fourth = (context -> System.out.println(""fourth""));      @Test     public void test1(){         System.out.println(""test"");     } } ```  However per extension execution order the result is currently:  ``` test third second fourth first ```  To have first extension executed first I have to annotate each and every extension (including superclasses):  ```java class Tests {      @Order(4)     @RegisterExtension     AfterEachCallback first = (context -> System.out.println(""first""));      @Order(3)     @RegisterExtension     AfterEachCallback second = (context -> System.out.println(""second""));      @Order(2)     @RegisterExtension     AfterEachCallback third = (context -> System.out.println(""third""));      @Order(1)     @RegisterExtension     AfterEachCallback fourth = (context -> System.out.println(""fourth""));      @Test     public void test1(){         System.out.println(""test"");     } } ```  Then I get the result I want:  ``` test first second third fourth ```","closed","component: Jupiter,","ihorppp","2019-06-12T09:59:22Z","2019-10-18T11:25:17Z"
"","1011","Document versioning schema of JUnit 5 release numbers (Semver?)","## Question  Will this project's release numbers conform to [Semver](http://semver.org/)?  Inevitably in every project mistakes are made and the team realizes that API's that made sense once no longer do. Semver defines a versioning schema.  Many projects say that they conform to Semver but they ignore the 8th point:  > 8\. Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. It MAY include minor and patch level changes. Patch and minor version MUST be reset to 0 when major version is incremented. > \- [Semver Section 8](http://semver.org/#spec-item-8)  Many projects are afraid to bump the major version unless there is some major feature addition or wild rewrite of the API. One exception to this is [Google Guava's releases](https://github.com/google/guava/releases). They will perform many major version releases in a year because they break API's. That team isn't afraid of the major version number.  That being said, they have a prominent warning in their [README about their versioning](https://github.com/google/guava#important-warnings).  The `@API` annotations are great; guava has something similar with their `@Beta` annotation.  ## Implications  If JUnit 5 decides to follow Semver and makes a release that has a breaking API change, it would be JUnit 6!  ## Deliverables  - [ ] Document detailing the release number versioning decisions of the JUnit Team","closed","status: stale,","JLLeitschuh","2017-08-08T20:26:22Z","2021-06-19T12:50:13Z"
"","1468","Why doesn't JUnit include a stub or mock feature?","## Question  Usually, I use JUnit to do unit testing and integration testing. However, I need another framework like EasyMock to generate mocks. Wouldn't it be better to integrate the feature within JUnit?","closed","theme: programming model,","BeyondW","2018-06-16T05:28:47Z","2018-06-16T21:21:09Z"
"","1463","Does the default class name filter work as expected?","## Question  Originating from Stack Overflow: https://stackoverflow.com/questions/50730460/tests-not-being-discovered-in-junit-5-consolelauncher-no-errors  The `-c com.test.package.testsets.TestClass` should work, as the class name starts with `Test`.   According to https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher-options the default regex should match that class name: `[...] To avoid loading classes unnecessarily, the default pattern only includes class names that begin with ""Test"" or end with ""Test"" or ""Tests"". When this option is repeated, all patterns will be combined using OR semantics. (default: ^(Test.*|.+[.$]Test.*|.*Tests?)$)`  ## Related Issues  - #1354   ## Deliverables  - [x] Check current regex and fix it if it's broken","closed","theme: discovery,","sormuras","2018-06-09T10:01:49Z","2018-06-22T10:34:21Z"
"","1179","Do not print summary for 'details=none' in Gradle plugin unless there are errors","## Overview:  Can we add an option to not print out to the console? Or only print failures, similar to Gradle's Junit 4 test task?  ## Example DSL usage of `JUnitPlatformExtension`:  ```groovy junitPlatform {     filters {         engines {             include ""spek""         }     } } ```  ## Example output after tests:  ``` > Task :kotlin:junitPlatformTest   Test run finished after 70 ms [         9 containers found      ] [         0 containers skipped    ] [         9 containers started    ] [         0 containers aborted    ] [         9 containers successful ] [         0 containers failed     ] [         4 tests found           ] [         0 tests skipped         ] [         4 tests started         ] [         0 tests aborted         ] [         4 tests successful      ] [         0 tests failed          ] ```","closed","component: Platform,","jaredsburrows","2017-11-22T19:22:47Z","2018-01-15T11:32:31Z"
"","1518","[bug] Spek tests not executed with junit-jupiter-engine:5.3.0-M1","## Overview Trying to create Kotlin project with maven build. The Spek tests are not executed with jupiter 5.3.0-M1, although they are executed correctly with jupiter 5.2.0. I have attached complete Maven + Kotlin project  [test_prj.zip](https://github.com/junit-team/junit5/files/2249959/test_prj.zip)  to reproduce the behavior. To switch between jupiter versions please change the  Maven _jupiter.version_ property, in the attached _pom.xml_  ## Bug report #### Junit artefacts versions (can be seen also in the attached pom.xml): - junit-jupiter-api: 5.3.0-M1 - junit-jupiter-engine: 5.3.0-M1  #### Java version:  _java version ""1.8.0_151""  Java(TM) SE Runtime Environment (build 1.8.0_151-b12)  Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)_  #### Maven version: _Apache Maven 3.3.9_  #### Expected behavior (works with jupiter 5.2.0): 4 unit tests are executed, 2 of them fail  - Maven surefire report:    _Tests run: 4, Failures: 2, Errors: 0, Skipped: 0_ #### Current behavior (with jupiter 5.3.0-M1): no unit tests are executed, alghough the _*Spec_ file to be executed is detected. - Maven surefire report (incorrect): _Tests run: 0, Failures: 0, Errors: 0, Skipped:_","closed","","stefan-hornea","2018-08-01T15:07:38Z","2018-09-04T18:12:29Z"
"","1883","Add null value attribute to @CsvSource and @CsvFileSource","## Overview This PR implements the proposed enhancement in https://github.com/junit-team/junit5/issues/1856 .  It will introduce a `nullSymbols` attribute in the `CsvSource` and `CsvFileSource` Annotation.  The `nullSymbols` will be converted into `null` if it is found in the CSV.   Resolves #1856   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","Farbauti89","2019-05-17T08:45:16Z","2019-10-18T13:54:37Z"
"","1783","Supply expected and actual values for failed boolean assertions for enhanced IDE support. Issue: #1781","## Overview Solution for #1781   Supply actual and expected values to `org.opentest4j.AssertionFailedError` constructor in  `assertTrue()` and `assertFalse()` methods in `org.junit.jupiter.api.Assertions`.  This will make assertions APIs consistent & these values are used by tools like Eclipse.   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","gopinath-langote","2019-02-17T21:03:24Z","2019-03-09T13:29:15Z"
"","967","Read the project modules from settings.gradle","## Overview Read the gradle modules from where they are actually defined.  The test `org.junit.AutomaticModuleNameTests#automaticModuleName` was failing on my local junit copy because I still had the directory `junit-jupiter-migration-support` that was later renamed to `junit-jupiter-migrationsupport`. The `Automatic-Module-Name` field was missing in the old build artifacts. It took me some time to figure out what the problem was and deleting the old directory fixed the failing test.  Reading the module information form settings.gradle will prevent this problem for good.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","signed","2017-07-19T20:37:29Z","2017-07-27T20:28:39Z"
"","1509","Introduce exception handling support for lifecycle callback methods","## Overview PR for Issue #1454  Make it possible to also handle exceptions thrown by BeforeEach/AfterEach methods via the TestExecutionExceptionHandler. The new handler methods are default methods to make them optional and to not break the FunctionalInterface. This PR is a proposal to solve the issue. It's not complete. The Javadoc is not adjusted and the exception handling for the BeforeAll/AfterAll methods is missing.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","phoenix384","2018-07-26T15:51:46Z","2019-05-03T10:47:11Z"
"","1213","Add Kotlin ""fail"" methods to org.junit.jupiter.api","## Overview Makes calling `fail` from Kotlin more friendly by adding methods that return [`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html).   Closes #1209  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","JLLeitschuh","2017-12-20T18:05:59Z","2018-01-20T15:39:31Z"
"","1660","Split up ReflectionUtils findMethod with 3 additional methods","## Overview Issue: #981   Moved for loops out of the findMethod to their own methods named searchForMatchingMethod and searchForMatchingMethodInInterfaces. Added a new public method to get superclasses of a class. Overall algorithm of findMethod hasn't changed much, though.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","ufko","2018-11-01T15:34:14Z","2018-11-05T15:58:07Z"
"","1424","JUnit 5 with Maven Surefire does not run `parallel` tests","## overview I'm trying to use JUnit5 and Surefire to run tests on parallel threads. I have a test that will just run multiple test methods and print out the thread name, to check that the test methods are on different threads. In my POM I use the recommended versions of all junit and surefire packages and dependencies.  If I run `mvn clean test` the tests methods run, but they all run sequentially on the `main` thread. If I run `mvn clean surefire:test` the test does not run at all.  In issue #1341 the fix was to use `junit-platform-surefire-provider` 1.2.0-SNAPSHOT. I'm using the released 1.2.0 version from april 2018 and it's still not working. There is no information on that issue about whether the tests are actually running parallelised.  ## reproduction code I included reproduction code in this gist: https://gist.github.com/jennyowen/563dbf93315e357bdf9e0bb2e098600b  ## versions Apache Maven 3.3.9 Java openjdk8 maven-surefire-plugin 2.21.0 junit-platform-surefire-provider 1.2.0 junit-jupiter-engine 5.2.0 junit-jupiter-api 5.2.0  ## related issues  #809 #1341","closed","3rd-party: Maven Surefire,","jennyowen","2018-05-18T10:20:48Z","2020-05-12T10:30:10Z"
"","1248","Provide a way to specify my own test method runner","## Overview I'm part of Arquillian team and I've been trying to implement either Arquillian Engine or Arquilian Extension for JUnit 5. Unfortunately, nothing is feasible for now. The Engine is a bigger issue. In case of extension, there is missing only one functionality.   ## Specific problem One of Arquillian modes is running in-container tests - executing test methods/classes inside of a container (as part of a deployment). Unfortunately, currently there is no way to tell JUnit 5 where the test should be executed or to provide my own runner that would execute the test method either on a client or in a container. I can only skip the test methods or let them run locally.  ## Possible solutions  ### Custom ExecutableInvoker The easiest solution would be having an SPI (eg. using service loader) that would load inside of the [TestMethodTestDescriptor](https://github.com/junit-team/junit5/blob/master/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java#L60) a custom implementation of the `ExecutableInvoker` class (if none is provided, then the default would be used) and execute the method using the provided invoker.  ### Custom runner for test descriptors The previous solution is easy to do, but has one side effect - the method callbacks would be executed on both sides - on a client and inside of the container (as I would need to simulate everything inside of the container again). An advanced solution would be having a possibility to provide an invoker for every `TestDescriptor` separately.  For more information about my research see this issue: https://github.com/arquillian/arquillian-core/issues/137  ## Related Issues  - #157","closed","status: stale,","MatousJobanek","2018-01-18T15:16:58Z","2021-06-03T19:47:23Z"
"","1308","Bug: duplicate --config key reported but value shown","## Overview I am using the platform-version 1.0.2. The bug happens when I use the ConsoleLauncher (from a gradle JavaExec Task, but I doubt that matters).  I accidentally provided twice the same key for `--config` as follows: '--config', 'forgive="".*spec:ch.tutteli.atrium.api.cc.en_UK.Iterable.*error cases.*""', '--config', 'forgive="".*spec:ch.tutteli.atrium.api.cc.en_UK.Iterable.*failing cases.*""',  The following Exception was thrown ``` Exception in thread ""main"" java.lang.IllegalStateException: Duplicate key .*spec:ch.tutteli.atrium.api.cc.en_UK.Iterable.*error 	at java.util.stream.Collectors.lambda$throwingMerger$114(Collectors.java:133) 	at java.util.HashMap.merge(HashMap.java:1245) 	at java.util.stream.Collectors.lambda$toMap$172(Collectors.java:1320) 	at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.platform.console.options.AvailableOptions.toCommandLineOptions(AvailableOptions.java:237) 	at org.junit.platform.console.options.JOptSimpleCommandLineOptionsParser.parse(JOptSimpleCommandLineOptionsParser.java:41) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:68) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:47) 	at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:39) ```  The error as such is fine, but I would have expected it reports that `forgive` was duplicated. I am not entirely sure if this a junit5 bug or a JDK8 bug but I guess you will find out quickly.","closed","theme: modules,","robstoll","2018-02-24T15:23:25Z","2018-04-15T10:13:29Z"
"","1210","Receiving a lot of warning messages because guardian-api is not brought in by junit","## Overview I am using junit-jupiter-api version 5.0.2 in my tests (using JDK 8) and I am getting `warning: unknown enum constant Status.STABLE   reason: class file for org.apiguardian.api.API$Status not found` printed out a lot. I have noticed that JUnit is using apiguardian-api and so I have brought this in as a dependency to get rid of the warnings. But as we want to have warnings appear as errors, and as far as I'm aware, that is a common thing to do, why isn't it included as a transitive dependency instead of making the users try and figure out what is going on?  ## Deliverables  - [ ] include apiguradian-api as a transitive dependency","closed","status: duplicate,","gigaSproule","2017-12-18T10:24:19Z","2017-12-18T10:32:13Z"
"","1122","Error combining TestSuite with ParameterizedTest","## Overview Hi, I'm trying to combine a ParameterizedTest with a TestSuite, but it does not work. The only message that I get is ""test not started"", if there is other tests in the same file, none of them start.  After some combinations, I found the minimal expression that fails.  This is happening to me in IntelliJ Idea 2017.2.5 Jupiter api, engine and params version: 5.0.1 junit-platform-runner version: 1.0.1  Here is my suite:  ``` import org.junit.platform.runner.JUnitPlatform; import org.junit.platform.suite.api.SelectPackages; import org.junit.runner.RunWith;  @RunWith(JUnitPlatform.class) @SelectPackages(""suite.example.junit5"") public class TestSuite { } ```  And here is the test:  ``` public class BasicTest {  	@ParameterizedTest 	@ValueSource(ints = {2, 4}) 	void parameterized(final int argument) { 		assertEquals(0,argument % 2); 	}  } ```  pd: Sorry for my bad english","closed","","lgiorcelli","2017-10-20T03:15:47Z","2017-10-29T18:13:43Z"
"","1089","Fix compile errors in Eclipse.","## Overview Fix compile errors in Eclipse. Eclipse uses a different compiler, which is sometimes better-- but sometimes worse--at inferring arguments.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","kcooney","2017-09-30T23:01:13Z","2017-10-03T17:26:10Z"
"","1058","**Bug report.** junit5-dynamic-test-example returns java.lang.ClassNotFoundException: org.junit.platform.commons.logging.LoggerFactory","## Overview Environment:  > Apache Maven 3.3.3  > Java version: 1.8.0_92 > OS name: ""windows 7  - ( ) **Bug report.** Look into attached project created from original tutorial for junit 5. This project is compiled correctly by Maven or Eclipse. But when I run mvn clean test then I see:  > ------------------------------------------------------- >  T E S T S > ------------------------------------------------------- >  > Results : >  > Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 >  > [INFO] ------------------------------------------------------------------------ > [INFO] BUILD FAILURE > [INFO] ------------------------------------------------------------------------ > [INFO] Total time: 4.045 s > [INFO] Finished at: 2017-09-12T15:44:42+02:00 > [INFO] Final Memory: 36M/3191M > [INFO] ------------------------------------------------------------------------ > [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2. > 19:test (default-test) on project junit5-dynamic-test-example: Execution default > -test of goal org.apache.maven.plugins:maven-surefire-plugin:2.19:test failed: T > here was an error in the forked process > [ERROR] java.util.ServiceConfigurationError: org.junit.platform.engine.TestEngin > e: Provider org.junit.vintage.engine.VintageTestEngine could not be instantiated >  > [ERROR] at java.util.ServiceLoader.fail(ServiceLoader.java:232) > [ERROR] at java.util.ServiceLoader.access$100(ServiceLoader.java:185) > [ERROR] at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:3 > 84) > [ERROR] at java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:404) > [ERROR] at java.util.ServiceLoader$1.next(ServiceLoader.java:480) > [ERROR] at org.junit.platform.launcher.core.DefaultLauncher.validateUniqueIds(De > faultLauncher.java:60) > [ERROR] at org.junit.platform.launcher.core.DefaultLauncher.(DefaultLaunch > er.java:55) > [ERROR] at org.junit.platform.launcher.core.LauncherFactory.create(LauncherFacto > ry.java:42) > [ERROR] at org.junit.platform.surefire.provider.JUnitPlatformProvider.invoke(JUn > itPlatformProvider.java:59) > [ERROR] at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameCla > ssLoader(ForkedBooter.java:286) > [ERROR] at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(Fork > edBooter.java:240) > [ERROR] at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java: > 121) > [ERROR] Caused by: java.lang.NoClassDefFoundError: org/junit/platform/commons/lo > gging/LoggerFactory > [ERROR] at org.junit.vintage.engine.VintageTestEngine.(VintageTestEngine > .java:40) > [ERROR] at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) >  > [ERROR] at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstruct > orAccessorImpl.java:62) > [ERROR] at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingC > onstructorAccessorImpl.java:45) > [ERROR] at java.lang.reflect.Constructor.newInstance(Constructor.java:423) > [ERROR] at java.lang.Class.newInstance(Class.java:442) > [ERROR] at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:3 > 80) > [ERROR] ... 9 more > [ERROR] Caused by: java.lang.ClassNotFoundException: org.junit.platform.commons. > logging.LoggerFactory > [ERROR] at java.net.URLClassLoader.findClass(URLClassLoader.java:381) > [ERROR] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) > [ERROR] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) > [ERROR] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) > [ERROR] ... 16 more > [ERROR] -> [Help 1]  [junit5-dynamic-test-example.zip](https://github.com/junit-team/junit5/files/1296200/junit5-dynamic-test-example.zip)","closed","status: invalid,","Wojand","2017-09-12T14:03:40Z","2017-09-12T14:55:46Z"
"","1147","Added org.junit.platform.commons.support.ClassSupport","## Overview Addresses https://github.com/junit-team/junit5/issues/1144  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","jlink","2017-11-06T08:49:37Z","2017-11-10T23:59:17Z"
"","1472","Add Japanese translation link to User Guide","## Overview A link to JUnit 5 User Guide(Japanese) is attached. The repository is [here](https://github.com/udzuki/junit5-user-guide-ja).  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","tsukakei","2018-06-19T05:32:14Z","2018-06-19T10:41:26Z"
"","1366","Tag Expressions with spaces do not work with Surefire provider","## Overview - Tag Expression used in Maven POM cannot include spaces. - Tag Expression cannot use `|` (or) symbol, must use `,` (comma) for or instead  ## Versions JDK:  ``` java version ""1.8.0_161"" Java(TM) SE Runtime Environment (build 1.8.0_161-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode) ``` Junit Version: `5.1.1` Surefire version: `2.19.1` (2.21.0 fails with `ClassNotFoundException: org.apache.maven.plugin.surefire.log.api.ConsoleLogger`)   ## Examples  Given the following code: ```java public class TagExpressionTest {     @Test     @Tag(""TagA"")     @DisplayName(""Test with Tag A"")     public void testWithTagA() {         out.println(""Test with Tag A"");     }      @Test     @Tag(""TagB"")     @DisplayName(""Test with Tag B"")     public void testWithTagB() {         out.println(""Test with Tag B"");     }      @Test     @Tags({@Tag(""TagA""), @Tag(""TagB"")})     @DisplayName(""Test with Tag B"")     public void testWithTagsAandB() {         out.println(""Test with Tags A & B"");     } } ```  ### TagA & TagB The following fails with `PreconditionViolationException: Unable to parse tag expression ""&"": missing lhs and rhs operand for '&' at index <0>`: ```xml TagA & TagB ``` however: ```xml TagA&TagB ``` is ok, runs only `testWithTagsAandB`  ### TagA or TagB The following fails with `PreconditionViolationException: Unable to parse tag expression ""|"": missing lhs and rhs operand for '|' at index <0>`: ```xml TagA | TagB ``` however: ```xml TagA|TagB ``` is ok, runs `testWithTagA`, `testWithTagB` & `testWithTagsAandB`","closed","3rd-party: Maven Surefire,","thecatwhisperer","2018-04-12T13:40:10Z","2019-07-19T19:32:24Z"
"","1160","Typed tags","## Overview - (x) **Feature request.**   As far as I can see, currently a tag only allows for a string as the argument. It would be nice if we could add tags in a more ""typed"" way. For example, create an enum `MyTags` and then annotate tests with for example `@Tag(MyTags.Fast)`. In this way, the magical strings disappear and you get IDE support (e.g, auto-completion and advanced renaming facilities).  I know I can already use `@Tag(MyTags.Fast.name())` but that feels more like a work-around then a real solution.","closed","component: Jupiter,","tobiasdiez","2017-11-14T01:24:45Z","2017-11-16T07:41:10Z"
"","1363","MethodArgumentsProvider doesn't work as Documentation states","## Overview - (x) **Bug report.** Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  *5.1.0*  ## Deliverables [Documentation](https://junit.org/junit5/docs/5.1.0/api/org/junit/jupiter/params/provider/MethodSource.html) states: `By default, such factory methods must be static unless the PER_CLASS test instance lifecycle mode is used for the test class.` but this: ``` @TestInstance(Lifecycle.PER_CLASS) public class MethodArgumentsProviderTest {      @Nested     public class MyNested {          Stream myArgumentsProvider() {             return Stream.of(                     Arguments.of(0)             );         }          @ParameterizedTest         @MethodSource(""myArgumentsProvider"")         public void shouldWork(final int myInt) {             assertTrue(true);         }     } } ``` throws: ``` org.junit.platform.commons.util.PreconditionViolationException: Cannot invoke non-static method [java.util.stream.Stream test.MethodArgumentsProviderTest$MyNested.myArgumentsProvider()] on a null target. 	at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:297) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:432) 	at org.junit.jupiter.params.provider.MethodArgumentsProvider.lambda$provideArguments$3(MethodArgumentsProvider.java:47) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1494) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1494) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:101) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:38) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:112) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) 	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) 	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) 	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:94) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$100(JUnitPlatformTestClassProcessor.java:80) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:71) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93) 	at com.sun.proxy.$Proxy1.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:123) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:146) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:128) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55) 	at java.base/java.lang.Thread.run(Thread.java:844) ```","closed","","eximius313","2018-04-10T15:32:03Z","2018-04-10T15:53:53Z"
"","1376","VerboseTreePrintingListener does not print exception thrown from beforeAll methods","## Overview - (x ) **Bug report.**  Junit5 Version: **5.1.1**  When using the VerboseTreePrintingListener by setting the `--details` argument of the ConsoleLauncher to `verbose` the exceptions are not printed in the tree. When setting `--details` to `tree` they are. My expectation is that the `verbose` setting does print the exceptions and the stacktraces of exceptions thrown within a `beforeAll` method.  ### Acutal: Exceptions thrown in the `beforeAll` method of extensions are not printed when using the `VerboseTreePrintingListener`  ### Expected: Exceptions thrown from the `beforeAll` method of extensions shall be printed similar to when using the `TreePrintingListener`. The full stacktrace should be printed.  ## Suggestion In the class `VerboseTreePrintingListener` move the following line from line 104 up before the `if` to line 97. ``` testExecutionResult.getThrowable().ifPresent(t -> printDetail(Color.FAILED, ""caught"", readStackTrace(t))); ```  - Before ``` @Override 	public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) { 	if (testIdentifier.isContainer()) { 		Long creationMillis = frames.pop(); 		printVerticals(theme.end()); 		printf(Color.CONTAINER, "" %s"", testIdentifier.getDisplayName()); 		printf(NONE, "" finished after %d ms.%n"", System.currentTimeMillis() - creationMillis); 		return; 	} 	testExecutionResult.getThrowable().ifPresent(t -> printDetail(Color.FAILED, ""caught"", readStackTrace(t))); 	printDetail(NONE, ""duration"", ""%d ms%n"", System.currentTimeMillis() - executionStartedMillis); 	String status = theme.status(testExecutionResult) + "" "" + testExecutionResult.getStatus(); 	printDetail(Color.valueOf(testExecutionResult), ""status"", ""%s%n"", status); } ``` - After ``` public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) { 	testExecutionResult.getThrowable().ifPresent(t -> printDetail(Color.FAILED, ""caught"", readStackTrace(t))); 	if (testIdentifier.isContainer()) { 		Long creationMillis = frames.pop(); 		printVerticals(theme.end()); 		printf(Color.CONTAINER, "" %s"", testIdentifier.getDisplayName()); 		printf(NONE, "" finished after %d ms.%n"", System.currentTimeMillis() - creationMillis); 		return; 	} 	printDetail(NONE, ""duration"", ""%d ms%n"", System.currentTimeMillis() - executionStartedMillis); 	String status = theme.status(testExecutionResult) + "" "" + testExecutionResult.getStatus(); 	printDetail(Color.valueOf(testExecutionResult), ""status"", ""%s%n"", status); } ```","closed","component: Platform,","RMsiemens","2018-04-17T09:25:40Z","2018-05-03T10:36:17Z"
"","1757","Use varargs for throwable conditions in TestExecutionResultConditions","## Overview  Within the Engine Test Kit, factory methods for `Condition` in `TestExecutionResultConditions` currently accept a single `Condition` argument.  This forces developers to use `allOf(...)` or invoke such factory methods multiple times with different arguments.  It would be better to support varargs for such methods, analogous to what we already do in `EventConditions.finishedWithFailure(Condition...)`  ## Deliverables  - [x] Use varargs for throwable conditions in TestExecutionResultConditions","closed","component: Platform,","sbrannen","2019-02-02T13:49:33Z","2019-02-06T16:17:24Z"
"","1168","Further simplify assertAll() usage in Kotlin","## Overview  With the current Kotlin `assertAll` API you still have the the doubly nested braces `{ { } }`. Eg: ```kotlin @Test fun `assertions from a collection`() {     assertAll(         ""people with last name of Doe"",         people.map { { assertEquals(""Doe"", it.lastName) } }     ) } ``` One thing I was just thinking about that might make the API even nicer for kotlin would be exposing extension methods that would let you do something like this:  ```kotlin @Test fun `assertions from a collection`() {     assertAll(         ""people with last name of Doe"",         people.mapExecutable { assertEquals(""Doe"", it.lastName) }     ) } ```  The signature of that would be something like this: ```kotlin package org.junit.jupiter.api  public inline fun  Unit> Iterable.mapExecutable(transform: (T) -> Unit): Collection<() -> Unit> {     return map { { transform(it) } } } ``` This might go beyond the scope of the API that the team wants to expose.  Other possible names for the function:  - `mapAssert`  - `mapExec`  - `mapTest`  - `test`  ## Deliverables  - [ ] Decision to support adding this extension method. - [ ] New Kotlin extension method `mapExecutable`","closed","component: Kotlin,","JLLeitschuh","2017-11-16T22:39:35Z","2021-05-28T10:22:39Z"
"","1429","Introduce tooling support tests","## Overview  With the cron-based daily build of the [junit5-samples](https://github.com/junit-team/junit5-samples) via [Travis CI](https://travis-ci.org/junit-team/junit5-samples/builds) some basic integration checks are in place. The sample projects use very simple setups on purpose and cover mainly the minimal ""happy path"" available.  The main JUnit 5 project should provide and maintain an ""integration subproject"" containing ""end-to-end"" checks using various build tools that natively support the JUnit Platform. The ""integration subproject"" will contain many standalone projects that will be executed as an ""build integration test suite"", and the respective build results will be verified.  See similar checks that Surefire performs at https://github.com/apache/maven-surefire/tree/master/surefire-its  ## Deliverables  - [x] Create `platform-tooling-support-tests` project - [x] Integrate `platform-tooling-support-tests` into build process -- as an opt-in build step - [x] Support usage of local (SNAPSHOT) build artifacts","closed","component: Platform,","sormuras","2018-05-23T10:20:23Z","2018-05-28T15:21:00Z"
"","1025","Cannot select @TestTemplate or @TestFactory invocations by Unique ID","## Overview  With reference to [bug request 520923](https://bugs.eclipse.org/bugs/show_bug.cgi?id=520923) in Eclipse, I am trying to rerun a single invocation of a parameterized test (and similarly, a repeated and a dynamic test) using its unique ID like this:  ``` java LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request().selectors(DiscoverySelectors.selectUniqueId(uniqueId)).build(); ```  A new `Launcher` instance is created to discover the above request.  This method works for a normal test with ID:  ``` java [engine:junit-jupiter]/[class:test.FirstTest]/[method:myFirstTest(org.junit.jupiter.api.TestInfo)] ```   But it gives this error for a dynamic test:  ``` org.junit.jupiter.engine.discovery.JavaElementsResolver resolveUniqueId WARNING: Unique ID '[engine:junit-jupiter]/[class:test.dynamic.DynamicTestsDemo]/[test-factory:dynamicTestsFromIntStream()]/[dynamic-test:#2]' could not be resolved ```  or a parameterized test:  ``` org.junit.jupiter.engine.discovery.JavaElementsResolver resolveUniqueId WARNING: Unique ID '[engine:junit-jupiter]/[class:jb.Junit5SimpleParamTest]/[test-template:dummy(java.lang.String)]/[test-template-invocation:#1]' could not be resolved ```  In JUnit 4, it was done using `org.junit.runner.Request.filterWith(Filter filter)`.   ## Question  What is the recommended way to do this in JUnit 5?  ## Related Issues  - #1026  - #1031  ## Analysis  Given a _Unique ID_ such as `[engine:junit-jupiter]/[class:test.dynamic.DynamicTestsDemo]/[test-factory:dynamicTestsFromIntStream()]/[dynamic-test:#2]`, `JavaElementsResolver.resolveUniqueId(TestDescriptor, List)` returns `true` if **all** segments of the supplied Unique ID could be resolved.  So, in such a case, the test class and test factory method do in fact get resolved, but the dynamic test itself does not get resolved.  That means that the test class and test factory method will be executed in the test plan even though there is a warning (which actually only applies to the last segment of the Unique ID).  ## Proposals  1. Selection of any invocation of a test template or test factory results in selection of the test template or test factory as a _container_ and consequently the _selection_ of all invocations.    - This appears to already be the case: see _Analysis_ for details. 2. Selection of a specific invocation of a test template or test factory results in selection of only that specific invocation of the test template or test factory.     - This could potentially be achieved via a special type of _filter_ that is applied to the stream of dynamic tests or test template invocations.  ## Deliverables  - [x] Ensure that an invocation of a `@TestTemplate` method can be selected by _Unique ID_.   - This applies to `@RepeatedTest` and `@ParameterizedTest` as well as any _test template_ method. - [x] Ensure that an invocation of a dynamic test supplied by a `@TestFactory` method can be selected by _Unique ID_.","closed","theme: discovery,","noopur2507","2017-08-18T15:43:17Z","2018-01-20T10:52:32Z"
"","1481","Nashorn is deprecated in Java 11","## Overview  With _""Deprecate the Nashorn JavaScript Engine""_ http://openjdk.java.net/jeps/335 integrated in JDK 11 we need to find another default value for `DisabledIf::engine() default ""Nashorn"";`:  - https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/DisabledIf.java#L176  and also `EnabledIf::engine() default ""Nashorn"";`:  - https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/EnabledIf.java#L176  Another Nashorn lives here:  - https://github.com/junit-team/junit5/blob/master/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/script/Script.java#L35  ## Marked for removal  _""A separate JEP will be filed for the actual removal of the types and modules in a future JDK feature release.""_   Which feature version will be the first without Nashorn? 12?  ## Alternatives  As explicitly stated in JEP 335: _""This deprecation does not affect, in any way, the `javax.script` API.""_ finding another ""general purpose language"" via using the support exposed by the [java.scripting](https://download.java.net/java/early_access/jdk11/docs/api/java.scripting/module-summary.html) module should be possible.  - Provide JSR 223 compatible wrapper around [jdk.jshell](https://download.java.net/java/early_access/jdk11/docs/api/jdk.jshell/module-summary.html) -- it is based on `jdk.compiler` and should stay accessible for the next decade... methinks. Example: https://github.com/dmac100/JShellScriptEngine  - Find and integrate (shade) another light-wight solution: http://java-source.net/open-source/scripting-languages  - ...or mark `DisabledIf` and `EnabledIf` as deprecated (for removal) as well?","closed","theme: modules,","sormuras","2018-06-28T17:12:22Z","2020-02-27T09:18:04Z"
"","1175","ModuleUtils should scan ""current"" module layer","## Overview  While integrating JUnit 5.1's module scanning support into https://github.com/forax/pro/issues/53 finding test classes in module was not possible.  ## Deliverables  - [x] Find reason for empty ""module references set"" and fix it.","closed","theme: modules,","sormuras","2017-11-20T15:39:51Z","2017-11-26T06:50:02Z"
"","1799","Thread context classloader should be reset after each test","## Overview  Whenever a test case sets the thread context `ClassLoader`, the test runner thread keeps using that `ClassLoader` for the following tests. This causes failures when combined with Mockito and mocks of package private classes/interfaces.  ## Expected Behavior  When the thread is reused to run another test, the context `ClassLoader` should be reset to the original one.  ## Steps to Reproduce  To reproduce the problem I created this example repo: https://github.com/bacer-esteco/junit5-bug-report.  Just run the 'test' task.  This problem is reproducible using both Jupiter and Vintage (tried on version 5.4.0), launching the test both from Gradle 5.2.1 and IntelliJ IDEA 2018.3 (and previous).  ## Related Issues  - #201 - #1688","open","component: Vintage,","bacer-esteco","2019-03-05T12:02:02Z","2022-06-11T14:07:41Z"
"","977","Introduce overloaded versions of assertThrows() that accept a message or message supplier","## Overview  When you call `assertThrows`, there is no way to add a message nor a supplier for a message. This would be nice, for example when calling `assertThrows` multiple times or inside an `assertAll`.  ## Deliverables  - [x] Introduce a version of `assertThrows()` that accepts a `String` message. - [x] Introduce a version of `assertThrows()` that accepts a `Supplier` message supplier.","closed","component: Jupiter,","michaelsiepmann","2017-07-24T09:34:42Z","2017-07-27T15:21:30Z"
"","1074","Complain when @Test is applied to an inappropriate method","## Overview  When writing tests in Groovy, it's tempting to use `def` for the test methods, since that is typically the way to go in Groovy. However, for `def` the compiler produces a method that returns `Object`.  If this was a method annotated with `@Test`, it would be silently ignored by JUnit, as it should be a `void` method. This leads to lots of pulled hairs and other frustrations.  ``` Test run finished after 13 ms [         2 containers found      ] [         0 containers skipped    ] [         2 containers started    ] [         0 containers aborted    ] [         2 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ] ```  I would like JUnit to shout in my face that I'm using it wrong.","closed","theme: diagnostics,","islandsvinur","2017-09-25T08:28:58Z","2018-12-28T14:05:20Z"
"","1633","Fix mixed content warning issued from documentation page","## Overview  When visiting the documentation page modern browsers will issue a mixed content warning, because the documentation is served from https://junit.org/ but it references the junit5-logo.png from via http://junit.org.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  _does not apply_","closed","theme: web site,","britter","2018-10-12T09:41:09Z","2018-10-12T11:04:58Z"
"","1016","CSV parser returns an empty String instead of null","## Overview  When using `@CsvSource` or `@CsvFileSource` in a parameterized test, if the CSV parser does not read any character from the input, and the input is within quotes, an empty string `""""` is returned instead of `null`.  Closes #1014  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x]  Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","sormuras","2017-08-13T08:34:19Z","2019-03-11T13:54:36Z"
"","1839","Make emptyValue configurable in @CsvSource and @CsvFileSource","## Overview  When using `@CsvSource` or `@CsvFileSource` in a parameterized test, if the CSV parser does not read any character from the input, and the input is within quotes, and emptyValue is configured, an emptyValue is returned instead of default `""""`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass   Closes #1788  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","theme: parameterized tests,","Ciruman","2019-03-29T15:59:38Z","2019-04-18T07:08:07Z"
"","1445","Executing large number of dynamic tests results in OutOfMemoryError: GC overhead limit exceeded","## Overview  When trying to run a large number of dynamic tests the framework throws an out of memory error.  For the sake of simplicity, below is a sample test I ran.  ```java import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.DynamicNode; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestFactory;  import java.util.stream.IntStream; import java.util.stream.Stream;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.DynamicTest.dynamicTest;  class RunnerTest {      @TestFactory     Stream dynamicTestPerformance() {         return IntStream                 .rangeClosed(1, 14_000_000)                 .mapToObj(num -> dynamicTest(""Test "" + num, () -> {                     System.out.println(""Running Test "" + num);                     assertEquals(num, -1);                 }));     } } ```  I have run this using both `ConsoleLauncher` and `maven-surefire-plugin` 2.21.0, but both approaches give the same problem. Below is the error.  ``` Running Test 1019735 Running Test 1019736 Running Test 1019737 Jun 04, 2018 3:28:25 PM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to execute tests java.lang.OutOfMemoryError: GC overhead limit exceeded 	at java.util.Arrays.copyOfRange(Arrays.java:3664) 	at java.lang.String.(String.java:207) 	at java.lang.StringBuilder.toString(StringBuilder.java:407) 	at org.junit.platform.engine.UniqueIdFormat.encode(UniqueIdFormat.java:148) 	at org.junit.platform.engine.UniqueIdFormat.describe(UniqueIdFormat.java:134) 	at org.junit.platform.engine.UniqueIdFormat$$Lambda$153/459296537.apply(Unknown Source) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1380) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.platform.engine.UniqueIdFormat.format(UniqueIdFormat.java:129) 	at org.junit.platform.engine.UniqueId.toString(UniqueId.java:205) 	at org.junit.platform.launcher.TestIdentifier.from(TestIdentifier.java:57) 	at org.junit.platform.launcher.core.ExecutionListenerAdapter.dynamicTestRegistered(ExecutionListenerAdapter.java:39) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$0(HierarchicalTestExecutor.java:114) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor$$Lambda$170/701141022.execute(Unknown Source) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor$$Lambda$216/133250414.accept(Unknown Source) 	at java.util.Optional.ifPresent(Optional.java:159) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.lambda$invokeTestMethod$1(TestFactoryTestDescriptor.java:92) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor$$Lambda$210/1730173572.execute(Unknown Source) 	at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40) 	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.invokeTestMethod(TestFactoryTestDescriptor.java:79) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:113) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor$$Lambda$169/1268066861.execute(Unknown Source) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) ```  ## Versions  - JUnit 5.2.0 - maven-surefire-plugin 2.21.0  ## Use Case  I am writing a small application to find and report differences between two databases and am generating a dynamic test for each db row for comparison.","closed","theme: dynamic tests,","vinayf","2018-06-04T14:06:57Z","2021-01-11T11:35:05Z"
"","1394","Improve assertThrows failure message if the lambda returns a result instead of throwing","## Overview  When testing code whose expected behavior is to throw an exception, it is sometimes useful to have a custom failure message for the case where the code does not throw an exception but instead returns a value:  ```java try {   double processedValue = process(bytes);   fail(""Expected an exception, but got "" + processedValue); } catch (IllegalArgumentException expected) { } ```  One of the few disadvantages of using `assertThrows` instead of the try/catch/fail pattern above is that `assertThrows` does not provide an easy way to customize the failure message to include a result that was returned when an exception was not thrown.  One might be tempted to write something like:  ```java assertThrows(    IllegalArgumentException.class,    () -> {       double processedValue = process(bytes);       fail(""Expected an exception, but got "" + processedValue);    }); ```  ... but in general, it's a bad idea to have more than one statement in the body of the lambda passed to `assertThrows`, since in the case where the test passes those additional assertions will never be executed:  ```java ImmutableList xs = ImmutableList.of(); assertThrows(     UnsupportedOperationException.class,     () -> {         xs.add(0);         assertThat(xs).isEmpty(); // oops, never executed!     }); ```  What do you think about adding support to `assertThrows` for a custom failure message that includes the result of the expression that was expected to throw an exception?  ## Deliverables  This can be achieved without adding an additional parameter to the `assertThrows` API, e.g.:  ```java public static  T assertThrows(     Class expectedType, ThrowingSupplier supplier) { ... } ```  If the provided supplier returns a value, the implementation can include its string representation in the failure message.  Adding `ThrowingSupplier` overloads avoids adding another parameter to the API and allows existing code that is passing `ThrowingSupplier`-compatible lambdas to the existing `assertThrows` methods to get the improved failure messages for free.  For an example of what the implementation might look like, see: https://github.com/junit-team/junit5/compare/master...cushon:assertThrows","closed","component: Jupiter,","cushon","2018-04-27T05:00:40Z","2018-05-10T01:43:51Z"
"","1018","Fix selection of method from JUnit 4 parameterized test","## Overview  When selecting a test method from a JUnit 4 parameterized test it, the method would run only once, without considering the parameters it should receive.  Resolves #549   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---","closed","component: Vintage,","Andrei94","2017-08-14T17:08:24Z","2017-08-18T13:26:36Z"
"","1153","Reduce log level in Jupiter discovery","## Overview  When running tests using several test engines, all those test engines will receive discovery request for certain classes or methods or packages (e.g. if you click the run tests button in IntelliJ). It's a normal thing that not all engines can resolve a certain element.  Using logging level `WARNING`, e.g. `logger.warn(() -> format(""Class '%s' could not be resolved."", testClass.getName()));` in `JavaElementsResolver` creates noise in the test runner's output.  Reducing the logging level to `DEBUG` would be preferable from a 3rd-party-testengine POV.","closed","component: Jupiter,","jlink","2017-11-10T07:48:26Z","2018-01-12T13:28:44Z"
"","1014","CsvSource with empty strings instead of null","## Overview  When I add the following `CsvSource` to a test  ```java @CsvSource({"",''"", ""'',''"", ""text1,text2""}) void teaserText(String source, String expected) { } ```  I would expect, that   - in the first step `source` is `null`, and `expected` is an empty string. - in the second step both are empty strings. - in the third step `source` is `text1`, and `expected` is `test2`.  but two single quotes without any content inside are parsed as `null`.  How can one create an empty string?","closed","component: Jupiter,","michaelsiepmann","2017-08-11T07:44:00Z","2019-07-19T19:32:42Z"
"","1069","ExpectedExceptionSupport causes exceptions to be silently ignored","## Overview  When adding the class annotation `@EnableRuleMigrationSupport`, no exceptions thrown will make the tests fail.  Example code :  ```java package be.algielen.soap;  import static org.junit.jupiter.api.Assertions.assertTrue;  import org.junit.jupiter.api.Test; import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;  @EnableRuleMigrationSupport class HelloServiceTest {      @Test     void sayHello() {         assertTrue(true);     }      @Test     void throwsException() {         throw new RuntimeException();     } } ```  All tests succeed even though `throwsException()` should obviously fail.  Version I tested it on :   ```xml          maven-surefire-plugin         2.19                     -Xmx512M                                          org.junit.platform             junit-platform-surefire-provider             1.0.0             compile                                   org.junit.jupiter             junit-jupiter-engine             5.0.0             compile                            ...            org.junit.jupiter       junit-jupiter-api       5.0.0       test                 org.junit.jupiter       junit-jupiter-migrationsupport       5.0.0       test      ```  Using Maven surefire 2.19 and with the integrated JUnit 5 Runner of Intellij IDEA 2012.2.4  ## Deliverables  - [x] `ExpectedExceptionSupport` must never swallow unexpected exceptions thrown from test methods. - [x] Document fix in the release notes in the User Guide.","closed","component: Jupiter,","algielen","2017-09-18T13:54:36Z","2017-09-22T13:52:45Z"
"","1448","Improve error messages for ParameterResolutionExceptions","## Overview  When a `ParameterResolutionException` is thrown, the message currently states something similar to the following.  ``` No ParameterResolver registered for parameter [java.lang.String arg0] in executable [org.example.MyTests(java.lang.String)]. ```  In the above example, the ""executable"" is actually a constructor, but many developers might not recognize that immediately based on the somewhat cryptic error message.  In addition, the cause of the above exception is that the developer introduced a constructor in a test class that accepts a parameter for which there is no registered `ParameterResolver`. However, many developers do not know what a `ParameterResolver` is or what the error message is intending to convey.  ## Deliverables  - [x] Replace ""executable"" with ""constructor"" or ""method"" in all error messages used in `ParameterResolutionException`s. - [ ] Consider introducing further contextual information when a test class introduces a constructor that accepts arguments for which there is no registered `ParameterResolver`.   - for example, by providing a hint for how to fix the problem.","closed","status: stale,","sbrannen","2018-06-05T10:08:40Z","2021-06-19T12:50:04Z"
"","1864","Introduce TestInstancePreDestroyCallback as counterpart to TestInstancePostProcessor","## Overview  We use the `TestInstancePostProcessor` to inject handles to external resources. These resources need to be released after the tests is completed.   Depending on the concrete test this might happen after each test method or after the class is completed.  We use the `TestInstance` `Lifecycle` to control the injection of new handles (for each method or for each class) and register to `afterEach` and `afterAll` to do the cleanup depending on the instance lifecycle. To make this work we have to do read the `Lifecycle`, check whether to release or collect instances, and so on.  ## Proposal  With a `TestInstanceFinalizer` extension, executed after JUnit Jupiter is finished running tests in this particular test instances (depending on the Lifecycle), cleanup could be implemented more easily.  This would be the counterpart of the existing `TestInstancePostProcessor`; all other Extensions have a counterpart.","closed","component: Jupiter,","joerg1985","2019-04-14T21:32:33Z","2019-12-05T17:17:01Z"
"","1701","Assertions.assertTimeoutPreemptively() breaks Spring test transaction rollback","## Overview  We use **JUnit Jupiter 5.3.1** in our web project, the `assertTimeoutPreemptively()` method will break the transaction rollback in spring's testing framework. As we use `DataSourceTransactionManager` as the main transaction manager, the manager will propagate the transaction in the same thread, not across threads. The `assertTimeoutPreemptively()` method starts a new thread running our code which differs from the main test thread resulting in transaction propagation  breakage.  ## Steps to reproduce  1. run test code surround by `assertTimeoutPreemptively()` 2. the test code request a URI in Spring's mocked web environment  3. the URI insert a record to  database 4. the record is not rolled back  ## Context   - 5.3.1  (Jupiter/Vintage/Platform):  - Intellij  ## Possible resolution  Run test code in main test thread and run timeout in spawned thread.  ## Related Issues  - #80   ## Deliverables  - [x] Add note regarding the use of `assertTimeoutPreemptively()` and the effects on `ThreadLocal` storage (in general) and with Spring's transaction management (as an example) in ...    - [x] Javadoc    - [x] User Guide","closed","component: Jupiter,","oopschen","2018-12-13T09:18:23Z","2019-01-08T12:45:50Z"
"","1375","Make XML report generator available to the public","## Overview  We have written our own test runner and would like to use the JUnit Platform's `XmlReportsWritingListener` to generate test result output. However the implementation is currently not in the public API.  Background:  We have created our own test runner, it seems for the following reasons.  - Setup of external dependencies - Provide own `TestExecutionListener`  With this we replace which I assume would otherwise be provided by the `ConsoleTestExecutor`, which is the only point in JUnit which accesses the `XmlReportsWritingListener`.  ## Deliverables  - [x]  Make XML report generation publicly available.","closed","component: Platform,","cburgmer","2018-04-17T07:25:02Z","2018-11-24T14:36:09Z"
"","1560","Vintage + JUnit < 4.5 fails","## Overview  Vintage fails to run (here `junit:junit:3.8.1` was used). A `ClassNotFoundException: org.junit.runners.model.RunnerBuilder` is thrown.  ``` Aug. 24, 2018 4:04:22 VORM. org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-vintage' failed to discover tests java.lang.NoClassDefFoundError: org/junit/runners/model/RunnerBuilder 	at org.junit.vintage.engine.discovery.VintageDiscoverer.(VintageDiscoverer.java:35) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:61) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:133) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:120) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:93) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.executeTests(ConsoleTestExecutor.java:65) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.lambda$execute$0(ConsoleTestExecutor.java:57) 	at org.junit.platform.console.tasks.CustomContextClassLoaderExecutor.invoke(CustomContextClassLoaderExecutor.java:33) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.execute(ConsoleTestExecutor.java:57) 	at org.junit.platform.console.ConsoleLauncher.executeTests(ConsoleLauncher.java:97) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:87) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:49) 	at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:41) Caused by: java.lang.ClassNotFoundException: org.junit.runners.model.RunnerBuilder 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:582) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	... 13 more ```   All JUnit versions below `4.5` should be affected: [`org.junit.runners.model.RunnerBuilder`](https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/runners/model/RunnerBuilder.java#L41) was introduced in `4.5`  ## Deliverables  - [x] Detect JUnit version `< 4.12` early and throw an exception with a better error message, suggesting to update to `4.12`.","closed","theme: diagnostics,","sormuras","2018-08-24T02:29:59Z","2019-01-19T16:35:00Z"
"","1478","Fix broken tests in DefaultParallelExecutionConfigurationStrategyTests","## Overview  Various tests in `DefaultParallelExecutionConfigurationStrategyTests` are broken (presumably) due to issues with Mockito on Java 10. Specifically, the mocked method invocations appear not to work at all.  ## Deliverables  - [x] Fix broken, `@Disabled` tests in `DefaultParallelExecutionConfigurationStrategyTests`.","closed","component: Platform,","sbrannen","2018-06-24T15:37:24Z","2018-06-24T17:15:39Z"
"","1477","ParameterizedTestExtension disallows acceptable case of zero invocations","## Overview  Using: JUnit: 5.2.0  Great job on the new `ParameterizedTest` support in v.5. The replacement of the static, one-per-class Parameters annotation with more flexible `MethodSource`, etc. has been like a breath of fresh air and allowed me to remove thousands (!!) of lines of supporting code from my system. I'm really loving it. However, someone decided to disallow zero parameters with this precondition check in `ParameterizedTestExtension`.  ```java .onClose(() ->     Preconditions.condition(invocationCount.get() > 0,     ""Configuration error: You must provide at least one argument for this @ParameterizedTest"")); ```  The problem with this is that we have some testing situations where parameterized tests with zero parameters are not exceptional. For example, we run tests against thousands of a certain type of class generically against a database of past production failures, and many of these classes have never experienced a production failure. When the tests are run, we now get failures due the above precondition check. JUnit 4 handled this cleanly: it would simply not run any tests on those classes.  ## Workaround  I can get around this by adding a `null` to the method creating the collection of parameters if it is empty, and then return from the beginning of the `@ParameterizedTest` method code if the passed parameter is `null`. That lets us continue to run the parameterized tests against all of the classes, but comes with some disadvantages:  - We must add specific code to the front and back of every parameterized pair just to avoid a failure that doesn't matter to the tests. - The handling of the `null` causes the test count inflation for these ""phantom"" tests. - `null` is now reserved as a signal for no parameters, rather than something wrong in the parameter creation.  ## Proposal  If nobody has any strong feelings about disallowing the no-parameter case, can we just have this precondition removed from a future version?  Thanks.","closed","status: stale,","johnchurchill","2018-06-23T19:28:19Z","2022-07-13T10:36:45Z"
"","1479","SurefireBooterForkException with maven-surefire-plugin 2.22.0 and JDK 10.0.1","## Overview  Using JUnit 5.2.0  I built a small sample project to evaluate JDK 10 with maven. Unfortunately I am running into several errors with the `maven-surefire-plugin`.  Here my sample `pom.xml`  ```xml       4.0.0      de.onkelpixel.sample-project     core     3.0.0-SNAPSHOT     jar     sample-project-core               UTF-8         UTF-8         10         10         5.2.0         6.2                                 com.fasterxml.jackson.core             jackson-databind             test             2.9.4                               org.projectlombok             lombok             1.18.0             true                               org.junit.jupiter             junit-jupiter-api             ${junit.jupiter.version}             test                                                          maven-surefire-plugin                 2.22.0                                           maven-jar-plugin                 3.1.0                                           org.apache.maven.plugins                 maven-compiler-plugin                 3.7.0                                      ${maven.compiler.source}                     ${maven.compiler.target}                                                                                org.ow2.asm                         asm                         ${asm.version}                                                                                                   org.springframework.build                 aws-maven                 5.0.0.RELEASE                             ```  And here is the error after executing `mvn test -e`    ``` [INFO] Error stacktraces are turned on. [INFO] Scanning for projects... [INFO]  [INFO] --------------------< de.onkelpixel.sample-project:core >--------------------- [INFO] Building sample-project-core 3.0.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO]  [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ core --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] Copying 0 resource [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ core --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 11 source files to /media/christian/data/workspace/onkelpixel/sample-project/core/target/classes [INFO]  [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ core --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /media/christian/data/workspace/onkelpixel/sample-project/core/src/test/resources [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ core --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 3 source files to /media/christian/data/workspace/onkelpixel/sample-project/core/target/test-classes [INFO]  [INFO] --- maven-surefire-plugin:2.22.0:test (default-test) @ core --- [INFO] Surefire report directory: /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire-reports [INFO]  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [WARNING] Corrupted STDOUT by directly writing to native stream in forked JVM 1. See FAQ web page and the dump file /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire-reports/2018-06-24T21-07-32_966-jvmRun1.dumpstream [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 1.886 s [INFO] Finished at: 2018-06-24T21:07:33+02:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.0:test (default-test) on project core: There are test failures. [ERROR]  [ERROR] Please refer to /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. [ERROR] The forked VM terminated without properly saying goodbye. VM crash or System.exit called? [ERROR] Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp [ERROR] Error occurred in starting fork, check output in log [ERROR] Process Exit Code: 1 [ERROR] org.apache.maven.surefire.booter.SurefireBooterForkException: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? [ERROR] Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp [ERROR] Error occurred in starting fork, check output in log [ERROR] Process Exit Code: 1 [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:671) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:533) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:278) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:244) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1194) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1022) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:868) [ERROR]         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81) [ERROR]         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128) [ERROR]         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305) [ERROR]         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192) [ERROR]         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105) [ERROR]         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:956) [ERROR]         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:290) [ERROR]         at org.apache.maven.cli.MavenCli.main(MavenCli.java:194) [ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) [ERROR]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [ERROR]         at java.base/java.lang.reflect.Method.invoke(Method.java:564) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356) [ERROR]  [ERROR] -> [Help 1] org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.0:test (default-test) on project core: There are test failures.  Please refer to /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire-reports for the individual test results. Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp Error occurred in starting fork, check output in log Process Exit Code: 1 org.apache.maven.surefire.booter.SurefireBooterForkException: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp Error occurred in starting fork, check output in log Process Exit Code: 1         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:671)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:533)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:278)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:244)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1194)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1022)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:868)         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56)         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192)         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105)         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:956)         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:290)         at org.apache.maven.cli.MavenCli.main(MavenCli.java:194)         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.base/java.lang.reflect.Method.invoke(Method.java:564)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)      at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:213)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:564)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) Caused by: org.apache.maven.plugin.MojoExecutionException: There are test failures.  Please refer to /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire-reports for the individual test results. Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream. The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp Error occurred in starting fork, check output in log Process Exit Code: 1 org.apache.maven.surefire.booter.SurefireBooterForkException: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp Error occurred in starting fork, check output in log Process Exit Code: 1         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:671)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:533)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:278)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:244)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1194)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1022)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:868)         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56)         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192)         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105)         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:956)         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:290)         at org.apache.maven.cli.MavenCli.main(MavenCli.java:194)         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.base/java.lang.reflect.Method.invoke(Method.java:564)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)      at org.apache.maven.plugin.surefire.SurefireHelper.throwException (SurefireHelper.java:235)     at org.apache.maven.plugin.surefire.SurefireHelper.reportExecution (SurefireHelper.java:112)     at org.apache.maven.plugin.surefire.SurefirePlugin.handleSummary (SurefirePlugin.java:364)     at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked (AbstractSurefireMojo.java:1052)     at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute (AbstractSurefireMojo.java:868)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:564)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) Caused by: org.apache.maven.surefire.booter.SurefireBooterForkException: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Command was /bin/sh -c cd /media/christian/data/workspace/onkelpixel/sample-project/core && /home/christian/.sdkman/candidates/java/10.0.1-zulu/bin/java @/media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire/surefireargs17213011163078562359 /media/christian/data/workspace/onkelpixel/sample-project/core/target/surefire 2018-06-24T21-07-32_966-jvmRun1 surefire15319763581280232854tmp surefire_097255199938309580tmp Error occurred in starting fork, check output in log Process Exit Code: 1     at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork (ForkStarter.java:671)     at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork (ForkStarter.java:533)     at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run (ForkStarter.java:278)     at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run (ForkStarter.java:244)     at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider (AbstractSurefireMojo.java:1194)     at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked (AbstractSurefireMojo.java:1022)     at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute (AbstractSurefireMojo.java:868)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:564)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356) [ERROR]  [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR]  [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException ```    Also tried to update the `org.ow2.asm dependency` to the latest version (6.2), but I'm still getting some errors. I also experimented with the `forkCount` and `forkMode` configuration parameter. But I didn't get the `mvn test` to work.  ## Expectations  I expect my tests to be executed. Before I changed to `maven-surefire-plugin:2.22.0` I tried the following setup:  ```xml                  org.apache.maven.plugins                 maven-surefire-plugin                 2.19.1                                                               org.junit.platform                         junit-platform-surefire-provider                         1.1.1                                                                   org.junit.jupiter                         junit-jupiter-engine                         5.1.1                                                    ``` And with that everything works well.","closed","3rd-party: Maven Surefire,","cremich","2018-06-24T19:15:43Z","2019-02-01T16:35:32Z"
"","1492","Safely generate display name for @ParameterizedTest if argument.toString() throws exception","## Overview  Using JUnit 5.2.0  I am using parameterized tests, and for the most part everything works as expected. However the name with pattern fails if any object has a bad `toString()`, even if the object is not referenced by the pattern. For example:  ```java public class BadToStringTest {      static Object[] data() {         return new Object[][] { { ""has a bad toString()"", new BadToString() } };     }      @ParameterizedTest(name = ""{0}"")     @MethodSource(""data"")     void test(String name, Object bad) {         // Empty Block     }      static class BadToString {         @Override         public String toString() {             throw new RuntimeException(""Very bad to string"");         }     } } ```  In the example an exception is thrown as all arguments are formatted not just the specified pattern.  I understand that throwing an exception from `toString()` is a really bad idea; however, it is somewhat unexpected that the formatter is calling `toString()` on arguments that it is not explicitly being asked to format.  As a side note, Hamcrest for a similar situation uses a `toString()` that conforms to `Object#toString()`:  ```java try {     return String.valueOf(value); } catch (Exception e) {     return value.getClass().getName() + ""@"" + Integer.toHexString(value.hashCode()); } ```  ## Deliverables  - [x] Ensure that invocation of `toString()` on arguments supplied to a `@ParameterizedTest` method does not prevent generation of the display name.   - In other words, invoke `toString()` _safely_ (within a try-catch block).","closed","theme: parameterized tests,","johnsoneal","2018-07-10T09:33:04Z","2018-07-16T17:55:52Z"
"","1022","Ensure JavaDoc provides complete examples and references for JUnit 5 power users","## Overview  Users who are familiar with JUnit 5 will still rely on the javadocs displayed by their IDE for reference information.  One example of where the javadocs could be more helpful is the ```@CsvSource``` annotation.  The user's guide has an extremely useful paragraph for this ```@ArgumentSource``` that describes how to use single quotes as well as how to produce null values versus empty String objects.  The table referenced in the users guide would definitely be a bonus.  Note that I'm not proposing the users guide move completely into the javadocs (e.g. Mockito) and that I recognize this adds housekeeping complexity to ensure that the javadocs and users guide don't contradict each other.  But in thinking about how I program with libraries I know well, there are definitely still javadoc pages that I rely on (e.g. the Java SE Pattern and SimpleDateFormat javadocs)  - (X) **Feature request.** Update the javadocs for types that commonly require looking at reference information.  This request could be limited to the ```junit-jupiter-api``` and ```junit-jupiter-params``` packages which would be sufficient to provide documentation to both test and extension writers.  ## Deliverables  - [ ] CsvSource - [ ] CsvFileSource - [ ] ...  *Prompted by the discussion on #1014*","closed","status: stale,","smoyer64","2017-08-15T11:29:20Z","2022-07-12T23:11:06Z"
"","1625","Support converting integral types in hex and octal","## Overview  Use PrimitiveType#decode to convert strings to the primitive integral types. This allows the values to be specified in the following format: ```     DecodableString:         Signopt DecimalNumeral         Signopt 0x HexDigits         Signopt 0X HexDigits         Signopt # HexDigits         Signopt 0 OctalDigits     Sign:         -         + ```  Addresses #1624  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","dmitry-timofeev","2018-10-07T12:53:53Z","2018-10-13T17:58:18Z"
"","1072","Use module descriptor for artifact and version information retrieval","## Overview  Use module descriptor for artifact and version information retrieval, if the Java Platform Module System in available on the current runtime.  Closes #600  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2017-09-21T04:49:28Z","2017-09-24T06:23:31Z"
"","1497","Use Bartholdy tooling library","## Overview  Use [Bartholdy](https://github.com/sormuras/bartholdy) tooling library to manage external tool installations.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: build,","sormuras","2018-07-14T07:00:44Z","2018-08-09T06:46:54Z"
"","1846","[#1091] Modules via @moditect","## Overview  Use @moditect to inject module descriptors.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2019-04-04T16:46:08Z","2019-04-15T03:21:14Z"
"","988","Fixed ""NoSuchMethodError"" when running tests from IntelliJ","## Overview  Upon running any test from the `documentation` project or from `org.junit.vintage.engine` IntelliJ throws `NoSuchMethodError`. It seems that the problem is the missing `execute(LauncherDiscoveryRequest)` from `org.junit.platform.launcher`. Upon adding it, the tests run as expected.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","status: works-as-designed,","Andrei94","2017-07-25T21:09:32Z","2017-07-25T21:31:03Z"
"","1407","Upgrade some dependencies","## Overview  Upgrade some build dependencies.  - org.ajoberstar:gradle-git-publish:0.4.1 - org.junit.platform:junit-platform-gradle-plugin:1.2.0 - checkstyle toolVersion 8.10  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: build,","hutaidavid","2018-05-03T14:33:42Z","2018-05-03T15:27:50Z"
"","1200","Update User Docs IDE Support info","## Overview  Updating User Docs to include updated information about Eclipse IDE support   Closes #1199   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---","closed","component: Platform,","wkorando","2017-12-07T19:18:15Z","2018-01-12T13:24:11Z"
"","1288","Fix junit-platform-commons-java-9 subproject build","## Overview  Update Gradle script so that subproject `junit-platform-commons-java-9` is really built with source, target and API of Java 9.  Before, two things were happening:  - `--release` compiler option was missing and all modules were compiler against JDK9 API  - `javacRelease = 9` did not work for the subproject, because compiler settings were configured too early.  This was spotted while trying to import the project to IntelliJ IDEA https://youtrack.jetbrains.com/issue/IDEA-186344   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] N/A Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] N/A Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] N/A Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","nskvortsov","2018-02-07T15:00:02Z","2018-02-07T17:06:19Z"
"","1080","Add --scan-module-path support","## Overview  Umbrella issue for adding `--scan-module-path` support to the JUnit Platform.  ## Related Issues  - #1087 - [Multi-release JAR](http://openjdk.java.net/jeps/238) with `JigsawUtils` and module-path scanning support - https://github.com/junit-team/junit5-samples/pull/36 - Sample running on the module-path  ## Outdated Pull Requests  - Part I #1061 - SPI `ModuleClassFinder` - Part II #1057  - Default (single) implementation  ## Deliverables  - [x] Make `--scan-module-path` work - [X] ~Add `--scan-module-path` and `--select-module` support to Gradle Plugin~ will be done in #1119 - [X] ~Add `--scan-module-path` and `--select-module` support to Maven Surefire Plugin~","closed","theme: modules,","sormuras","2017-09-28T09:55:36Z","2017-10-19T19:08:13Z"
"","1487","Build broken on 11-ea+20","## Overview  Travis CI Build `#6501.4` using `OpenJDK Runtime Environment 18.9 (build 11-ea+19)` worked fine: https://travis-ci.org/junit-team/junit5/jobs/399160225  Travis CI Build `#6506.4` using `OpenJDK Runtime Environment 18.9 (build 11-ea+20)` failed: https://travis-ci.org/junit-team/junit5/jobs/399549280  Same Build `#6506` works fine on `OpenJDK Runtime Environment (build 10.0.1+10)`. Linux and Mac: https://travis-ci.org/junit-team/junit5/builds/399549276  ## Analysis  Underlying exception, copied from Travis CI Build `#6514.4` with `--stacktrace` enabled:  ``` [...] 17:51:06.239 [DEBUG] [org.gradle.api.internal.artifacts.ivyservice.ivyresolve.RepositoryChainComponentMetaDataResolver] Attempting to resolve component for com.gradle.build-scan:com.gradle.build-scan.gradle.plugin:1.14 using repositories [Gradle Central Plugin Repository] 17:51:06.248 [DEBUG] [org.gradle.api.internal.artifacts.repositories.resolver.DefaultExternalResourceArtifactResolver] Loading https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom 17:51:06.251 [DEBUG] [org.gradle.internal.resource.transfer.DefaultCacheAwareExternalResourceAccessor] Constructing external resource: https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom 17:51:06.251 [DEBUG] [org.gradle.cache.internal.DefaultCacheAccess] Creating new cache for metadata-2.58/resource-at-url, path /home/travis/.gradle/caches/modules-2/metadata-2.58/resource-at-url.bin, access org.gradle.cache.internal.DefaultCacheAccess@a2df0d5 17:51:06.252 [DEBUG] [org.gradle.cache.internal.btree.BTreePersistentIndexedCache] Opening cache resource-at-url.bin (/home/travis/.gradle/caches/modules-2/metadata-2.58/resource-at-url.bin) 17:51:06.261 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Download https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom' started 17:51:06.261 [DEBUG] [org.gradle.internal.resource.transport.http.HttpResourceAccessor] Constructing external resource: https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom 17:51:06.266 [DEBUG] [org.gradle.internal.resource.transport.http.HttpClientHelper] Performing HTTP GET: https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom 17:51:06.595 [DEBUG] [org.apache.http.client.protocol.RequestAddCookies] CookieSpec selected: default 17:51:06.605 [DEBUG] [org.apache.http.client.protocol.RequestAuthCache] Auth cache not set in the context 17:51:06.606 [DEBUG] [org.apache.http.impl.conn.PoolingHttpClientConnectionManager] Connection request: [route: {s}->https://plugins.gradle.org:443][total kept alive: 0; route allocated: 0 of 20; total allocated: 0 of 20] 17:51:06.621 [DEBUG] [org.apache.http.impl.conn.PoolingHttpClientConnectionManager] Connection leased: [id: 0][route: {s}->https://plugins.gradle.org:443][total kept alive: 0; route allocated: 1 of 20; total allocated: 1 of 20] 17:51:06.622 [DEBUG] [org.apache.http.impl.execchain.MainClientExec] Opening connection {s}->https://plugins.gradle.org:443 17:51:06.630 [DEBUG] [org.apache.http.impl.conn.DefaultHttpClientConnectionOperator] Connecting to plugins.gradle.org/104.16.172.166:443 17:51:06.630 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory] Connecting socket to plugins.gradle.org/104.16.172.166:443 with timeout 30000 17:51:06.647 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory] Enabled protocols: [TLSv1.3, TLSv1.2, TLSv1.1, TLSv1] 17:51:06.648 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory] Enabled cipher suites:[TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_DSS_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_DSS_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_AES_256_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384, TLS_DHE_RSA_WITH_AES_256_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_EMPTY_RENEGOTIATION_INFO_SCSV] 17:51:06.648 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory] Starting handshake 17:51:06.819 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory] Secure session established 17:51:06.819 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory]  negotiated protocol: TLSv1.2 17:51:06.820 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory]  negotiated cipher suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 17:51:06.820 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory]  peer principal: CN=ssl473435.cloudflaressl.com, OU=PositiveSSL Multi-Domain, OU=Domain Control Validated 17:51:06.820 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory]  peer alternative names: [ssl473435.cloudflaressl.com, *.gradle.org, gradle.org] 17:51:06.820 [DEBUG] [org.apache.http.conn.ssl.SSLConnectionSocketFactory]  issuer principal: CN=COMODO ECC Domain Validation Secure Server CA 2, O=COMODO CA Limited, L=Salford, ST=Greater Manchester, C=GB 17:51:06.824 [DEBUG] [org.apache.http.impl.conn.DefaultHttpClientConnectionOperator] Connection established 172.17.0.4:52010<->104.16.172.166:443 17:51:06.824 [DEBUG] [org.apache.http.impl.conn.DefaultManagedHttpClientConnection] http-outgoing-0: set socket timeout to 30000 17:51:06.826 [DEBUG] [org.apache.http.impl.execchain.MainClientExec] Executing request GET /m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom HTTP/1.1 17:51:06.826 [DEBUG] [org.apache.http.impl.execchain.MainClientExec] Target auth state: UNCHALLENGED 17:51:06.826 [DEBUG] [org.apache.http.impl.execchain.MainClientExec] Proxy auth state: UNCHALLENGED 17:51:06.865 [DEBUG] [org.apache.http.impl.execchain.MainClientExec] Connection can be kept alive indefinitely 17:51:06.865 [DEBUG] [org.apache.http.impl.conn.DefaultManagedHttpClientConnection] http-outgoing-0: Shutdown connection 17:51:06.866 [DEBUG] [org.apache.http.impl.execchain.MainClientExec] Connection discarded 17:51:06.866 [DEBUG] [org.apache.http.impl.conn.PoolingHttpClientConnectionManager] Connection released: [id: 0][route: {s}->https://plugins.gradle.org:443][total kept alive: 0; route allocated: 0 of 20; total allocated: 0 of 20] 17:51:06.866 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Completing Build operation 'Download https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom' 17:51:06.867 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Download https://plugins.gradle.org/m2/com/gradle/build-scan/com.gradle.build-scan.gradle.plugin/1.14/com.gradle.build-scan.gradle.plugin-1.14.pom' completed 17:51:06.878 [DEBUG] [org.gradle.api.internal.artifacts.ivyservice.resolveengine.oldresult.TransientConfigurationResultsBuilder] Flushing resolved configuration data in Binary store in /tmp/gradle13037367070599796318.bin. Wrote root 2. 17:51:06.884 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Completing Build operation 'Resolve dependencies of detachedConfiguration1' 17:51:06.885 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Resolve dependencies of detachedConfiguration1' completed 17:51:06.889 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Completing Build operation 'Apply script build.gradle to root project 'junit5'' 17:51:06.889 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Apply script build.gradle to root project 'junit5'' completed 17:51:06.889 [DEBUG] [org.gradle.configuration.project.BuildScriptProcessor] Timing: Running the build script took 2.038 secs 17:51:06.897 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Notify afterEvaluate listeners of :' started 17:51:06.899 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Completing Build operation 'Notify afterEvaluate listeners of :' 17:51:06.899 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Notify afterEvaluate listeners of :' completed 17:51:06.899 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Completing Build operation 'Configure project :' 17:51:06.899 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Configure project :' completed 17:51:06.899 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Completing Build operation 'Configure build' 17:51:06.899 [DEBUG] [org.gradle.internal.operations.DefaultBuildOperationExecutor] Build operation 'Configure build' completed 17:51:06.914 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]  17:51:06.914 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] FAILURE: Build failed with an exception. 17:51:06.914 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]  17:51:06.914 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] * Where: 17:51:06.914 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] Build file '/home/travis/build/junit-team/junit5/build.gradle' line: 5 17:51:06.914 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]  17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] * What went wrong: 17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] Plugin [id: 'com.gradle.build-scan', version: '1.14'] was not found in any of the following sources: 17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]  17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] - Gradle Core Plugins (plugin is not in 'org.gradle' namespace) 17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] - Plugin Repositories (could not resolve plugin artifact 'com.gradle.build-scan:com.gradle.build-scan.gradle.plugin:1.14') 17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]   Searched in the following repositories: 17:51:06.915 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]     Gradle Central Plugin Repository [...] ``` https://api.travis-ci.org/v3/job/399694216/log.txt  ## Changes from jdk-11-ea+19 to +20  - http://hg.openjdk.java.net/jdk/jdk/log?revcount=10000&rev=reverse(%22jdk-11%2B19%22%3A%3A%22jdk-11%2B20%22)  What happend from +19 to +20 to cause this issue?","closed","3rd-party: Gradle,","sormuras","2018-07-04T06:50:48Z","2018-08-02T08:51:11Z"
"","1255","Gradle build fails with GradleScriptException if JDK is not 9 or higher","## Overview  Today I checked out the source of junit5 and opened it in my IntelliJ editor. IntelliJ triggered the automatic Gradle build, which failed with the following internal exception:    ``` org.gradle.api.GradleScriptException: A problem occurred evaluating settings 'junit5'. 	at org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactory$ScriptRunnerImpl.run(DefaultScriptRunnerFactory.java:92) 	at org.gradle.configuration.DefaultScriptPluginFactory$ScriptPluginImpl$2.run(DefaultScriptPluginFactory.java:199) 	at org.gradle.configuration.DefaultScriptTarget.addConfiguration(DefaultScriptTarget.java:74) 	at org.gradle.configuration.DefaultScriptPluginFactory$ScriptPluginImpl.apply(DefaultScriptPluginFactory.java:204) 	at org.gradle.configuration.BuildOperationScriptPlugin$1.run(BuildOperationScriptPlugin.java:61) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110) 	at org.gradle.configuration.BuildOperationScriptPlugin.apply(BuildOperationScriptPlugin.java:58) 	at org.gradle.initialization.ScriptEvaluatingSettingsProcessor.applySettingsScript(ScriptEvaluatingSettingsProcessor.java:67) 	at org.gradle.initialization.ScriptEvaluatingSettingsProcessor.process(ScriptEvaluatingSettingsProcessor.java:58) 	at org.gradle.initialization.PropertiesLoadingSettingsProcessor.process(PropertiesLoadingSettingsProcessor.java:37) 	at org.gradle.initialization.NotifyingSettingsProcessor$1.call(NotifyingSettingsProcessor.java:45) 	at org.gradle.initialization.NotifyingSettingsProcessor$1.call(NotifyingSettingsProcessor.java:42) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:350) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:340) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:120) 	at org.gradle.initialization.NotifyingSettingsProcessor.process(NotifyingSettingsProcessor.java:42) 	at org.gradle.initialization.DefaultSettingsLoader.findSettingsAndLoadIfAppropriate(DefaultSettingsLoader.java:111) 	at org.gradle.initialization.DefaultSettingsLoader.findAndLoadSettings(DefaultSettingsLoader.java:48) 	at org.gradle.internal.composite.CompositeBuildSettingsLoader.findAndLoadSettings(CompositeBuildSettingsLoader.java:40) 	at org.gradle.initialization.NotifyingSettingsLoader.findAndLoadSettings(NotifyingSettingsLoader.java:31) 	at org.gradle.initialization.DefaultGradleLauncher$LoadBuild.run(DefaultGradleLauncher.java:235) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110) 	at org.gradle.initialization.DefaultGradleLauncher.loadSettings(DefaultGradleLauncher.java:159) 	at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:122) 	at org.gradle.initialization.DefaultGradleLauncher.getConfiguredBuild(DefaultGradleLauncher.java:104) 	at org.gradle.internal.invocation.GradleBuildController$2.call(GradleBuildController.java:87) 	at org.gradle.internal.invocation.GradleBuildController$2.call(GradleBuildController.java:84) 	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:152) 	at org.gradle.internal.invocation.GradleBuildController.doBuild(GradleBuildController.java:100) 	at org.gradle.internal.invocation.GradleBuildController.configure(GradleBuildController.java:84) 	at org.gradle.tooling.internal.provider.runner.ClientProvidedBuildActionRunner.run(ClientProvidedBuildActionRunner.java:64) 	at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35) 	at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35) 	at org.gradle.tooling.internal.provider.ValidatingBuildActionRunner.run(ValidatingBuildActionRunner.java:32) 	at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner$1.run(RunAsBuildOperationBuildActionRunner.java:43) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199) 	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110) 	at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner.run(RunAsBuildOperationBuildActionRunner.java:40) 	at org.gradle.tooling.internal.provider.SubscribableBuildActionRunner.run(SubscribableBuildActionRunner.java:51) 	at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:47) 	at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:30) 	at org.gradle.launcher.exec.BuildTreeScopeBuildActionExecuter.execute(BuildTreeScopeBuildActionExecuter.java:39) 	at org.gradle.launcher.exec.BuildTreeScopeBuildActionExecuter.execute(BuildTreeScopeBuildActionExecuter.java:25) 	at org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:80) 	at org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:53) 	at org.gradle.tooling.internal.provider.ServicesSetupBuildActionExecuter.execute(ServicesSetupBuildActionExecuter.java:57) 	at org.gradle.tooling.internal.provider.ServicesSetupBuildActionExecuter.execute(ServicesSetupBuildActionExecuter.java:32) 	at org.gradle.tooling.internal.provider.GradleThreadBuildActionExecuter.execute(GradleThreadBuildActionExecuter.java:36) 	at org.gradle.tooling.internal.provider.GradleThreadBuildActionExecuter.execute(GradleThreadBuildActionExecuter.java:25) 	at org.gradle.tooling.internal.provider.ParallelismConfigurationBuildActionExecuter.execute(ParallelismConfigurationBuildActionExecuter.java:43) 	at org.gradle.tooling.internal.provider.ParallelismConfigurationBuildActionExecuter.execute(ParallelismConfigurationBuildActionExecuter.java:29) 	at org.gradle.tooling.internal.provider.StartParamsValidatingActionExecuter.execute(StartParamsValidatingActionExecuter.java:69) 	at org.gradle.tooling.internal.provider.StartParamsValidatingActionExecuter.execute(StartParamsValidatingActionExecuter.java:30) 	at org.gradle.tooling.internal.provider.SessionFailureReportingActionExecuter.execute(SessionFailureReportingActionExecuter.java:59) 	at org.gradle.tooling.internal.provider.SessionFailureReportingActionExecuter.execute(SessionFailureReportingActionExecuter.java:44) 	at org.gradle.tooling.internal.provider.SetupLoggingActionExecuter.execute(SetupLoggingActionExecuter.java:45) 	at org.gradle.tooling.internal.provider.SetupLoggingActionExecuter.execute(SetupLoggingActionExecuter.java:30) 	at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:67) 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:37) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:26) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.RequestStopIfSingleUsedDaemon.execute(RequestStopIfSingleUsedDaemon.java:34) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:74) 	at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:72) 	at org.gradle.util.Swapper.swap(Swapper.java:38) 	at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:72) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.LogAndCheckHealth.execute(LogAndCheckHealth.java:55) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:62) 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:82) 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36) 	at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:122) 	at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:50) 	at org.gradle.launcher.daemon.server.DaemonStateCoordinator$1.run(DaemonStateCoordinator.java:295) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55) 	at java.lang.Thread.run(Thread.java:748) Caused by: groovy.lang.MissingMethodException: No signature of method: static java.lang.Runtime.version() is applicable for argument types: () values: [] Possible solutions: iterator(), every() 	at groovy.lang.MetaClassImpl.invokeStaticMissingMethod(MetaClassImpl.java:1501) 	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1487) 	at org.codehaus.groovy.runtime.callsite.StaticMetaClassSite.call(StaticMetaClassSite.java:53) 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117) 	at settings_8j4fho6fwgg1lr5dvquwa2tzz.run(/home/tim/Projects/junit5/settings.gradle:31) 	at org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactory$ScriptRunnerImpl.run(DefaultScriptRunnerFactory.java:90) 	... 95 more ```     The affected line is `gradle.ext.kotlinIsSupported = Runtime.version().major() < 10`  I get the same error when running `./gradlew assemble`:  ``` FAILURE: Build failed with an exception.  * Where: Settings file '/home/tim/Projects/junit5/settings.gradle' line: 31  * What went wrong: A problem occurred evaluating settings 'junit5'. > No signature of method: static java.lang.Runtime.version() is applicable for argument types: () values: []   Possible solutions: iterator(), every()  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  BUILD FAILED in 0s ```  This is my system information:  Java ``` java version ""9.0.1"" Java(TM) SE Runtime Environment (build 9.0.1+11) Java HotSpot(TM) 64-Bit Server VM (build 9.0.1+11, mixed mode) ``` Ubuntu 16.04 ``` Gradle version 4.4.1 (automatically loaded by IntelliJ) IntelliJ 2017.3.3, built on January 15 2018 ```  The README mentions that JDK 9 is required, but that's what I have installed. Although I suspect this is actually a Groovy/Gradle issue.  Am I missing a configuration setting?","closed","theme: build,","TimvdLippe","2018-01-21T16:49:49Z","2018-01-21T20:37:42Z"
"","1434","(Suggestion : feature / improvement) Do not rerun tests where nothing had changed","## Overview  To start with a  disclaimer : this feature would not be generic. It would not apply for fast running tests, but more for slow tests / integration tests.   A. If one thinks about an engine whose purpose is to skip tests, the first idea to spawn in mind is ""That defeats the whole purpose of the concept of testing. I want to change stuff, and I want the tests to tell me what I broke"".   However, there can be some tests that take a lot of time (integration tests are the most basic example), so why run them for no particular reason? Notice how above, one part of the remark is ""I want to change stuff and..."". So, how about when nothing changed?  B. Another remark would be : ""isn't this engine dangerous?"" and the answer : ""hell, yeah""  **Feature request.**  Do not rerun tests where nothing has changed.  For a certain type of tests (marked with a specific annotation ; in order to keep the global approach ""run all tests""), try to optimize the reruns.   Build a dependency matrix (things that impact each test), monitor the dependencies and rerun only where changes had ocured.  ## Deliverables Concepts: 1. test resources = anything that, when changed, could affect the test results ; the test class itself and the class under test are implicit test resources ; other things could be : files that are used as inputs for tests (changing should a file would definitely require a test rerun) 2. tests and resource dependency matrix  Real deliverables a. the reports show what was run and why (what changed from the dependency list that triggered the runner to rerun a test)  b. annotations to configure what goes under the jurisdiction of this new engine c. OR dsl for the Runner to configure this new engine d. annotations to ""guide"" the engine : basically markers or configuration that says what is a ""test resource"" and to which test it applies; in fact, this engine does not have to be smart at all (there will be no magic inside of it that detects what is a ""test resource""), it will just read the configuration, monitor resources between runs, and rerun tests according to the dependency matrix","closed","theme: build,","belun","2018-05-28T21:37:31Z","2018-05-29T11:15:29Z"
"","1692","Use realistic examples in User Guide","## Overview  This pull request is created to update the examples in the official documentation.  Issue: #1651   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","saikatsgupta","2018-12-02T09:11:49Z","2019-01-04T13:48:58Z"
"","1046","Replace constructors with static factory methods","## Overview  This pull request includes changes discussed in #939.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","sbrannen","2017-09-07T14:55:08Z","2017-09-08T11:41:32Z"
"","996","Introduce StoredValues","## Overview  This provides more type-safe access to values in a `Store`.  Fixes #361  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","kcooney","2017-07-30T17:15:23Z","2019-07-19T19:32:42Z"
"","1348","Introduce assertDoesNotThrow()","## Overview  This proposal is a result of a [discussion on Twitter](https://twitter.com/KevlinHenney/status/978565873991548929).  It has been noted that AssertJ provides similar support via the following construct.  ```java assertThatCode(() -> {}).doesNotThrowAnyException(); ```  ## Deliverables  - [x] Introduce `assertDoesNotThrow(Executable)` in JUnit Jupiter's `Assertions` along with variants accepting a `String` or `Supplier` for failure messages.","closed","component: Jupiter,","sbrannen","2018-03-28T10:08:18Z","2018-04-23T11:12:50Z"
"","1278","Upgrade to Kotlin 1.2.30","## Overview  This PR will introduce Kotlin version 1.2.30 and remove the exclusion of the Kotlin support when running on Java 10.  At the moment, Kotlin 1.2.30 is published as an EAP-47 via their [bintray](https://dl.bintray.com/kotlin/kotlin-eap/org/jetbrains/kotlin/kotlin-compiler/) repository. Therefore this PR is blocked until GA of version 1.2.30.  Closes #1169   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done - [x] Upgrade `kotlinVersion` in `gradle.properties` to `1.2.30`, when it is available - [x] Remove `https://dl.bintray.com/kotlin/kotlin-eap` repository from `build.gradle`","closed","component: Kotlin,","sormuras","2018-02-02T17:25:46Z","2018-03-05T13:59:41Z"
"","1857","Introduce explicit Java modules","## Overview  This PR solves #1091 -- and supersedes all draft PRs and branches created lately.  Closes #1091  Closes #1216  Closes #1844  Closes #1846  Closes #1847  Closes #1848   Closes #1854   ## TODO  - [x] Create Gradle `mainRelease9` `SourceSet` in `junit-platform-commons` as a container for the 9er MR-JAR version of `ModuleUtils`. - [x] Enumerate all required modules in each module, although they are added via `transitive` directives. Effectively sync the `requires` directives with the `dependencies` block declared in our Gradle build. - [x] Remove internal and almost dead [`ClasspathScanningSupport`](https://github.com/junit-team/junit5/blob/master/junit-platform-engine/src/main/java/org/junit/platform/engine/support/filter/ClasspathScanningSupport.java) class. - [x] @sbrannen please verify the project imports hasslefree into Eclipse -- we might need to exlude `mainRelease9` from the `.classpath` file  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sormuras","2019-04-10T11:13:07Z","2019-04-15T03:17:17Z"
"","1013","Cleanup ExtensionContext Namespace API","## Overview  This PR removes the method `getStore()` from the `ExtensionContext` interface and renames `Namespace.DEFAULT` to `Namespace.GLOBAL`.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2017-08-09T08:10:58Z","2017-08-10T14:30:50Z"
"","1359","Remove `junit-platform-gradle-plugin` from build configuration","## Overview  This PR removes the `junit-platform-gradle-plugin` from build configuration. It does **not** delete the directory.  Addresses part of #1331  Note: Do **not** press the ""Rebase and merge"" button, yet. Wait until `5.3.0-SNAPSHOT` is active on `master`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","3rd-party: Gradle,","sormuras","2018-04-06T11:18:02Z","2018-05-23T11:15:04Z"
"","1061","Part I - Introduce ModuleUtils with ClassFinder SPI","## Overview  This PR prepares the support for selecting Java 9 modules for test discovery.  Basic idea: publish a `String`-based service providing interface for naming module(s) of interest and let an explicit module register a service implementation for actually finding classes in the module graph at runtime. This service implementation should be hosted in a different (sub-) project, like `junit-platform-commons-jpms`. See #1057   At runtime, using Java 9, the user can add the `org.junit.platform.commons.jpms` module to the module-path and specify which module he wants to test. The `mods` directory contains the JUnit 5 artifacts (loaded as automatic modules), the `org.junit.platform.commons.jpms` module, the application modules (tested objects), and the test modules (classes with `@Test` annotated methods):  ``` java --module-path   mods --add-modules   ALL-MODULE-PATH --module   org.junit.platform.console --select-module   jpms.integration ```  ## New Console Launcher Options  - `--scan-module-path` Scan all modules on the runtime boot module-path for test discovery. See http://mail.openjdk.java.net/pipermail/jigsaw-dev/2017-September/013180.html for details.  - `-o` or `--select-module` with single argument `` Select single module for test discovery. This option can be repeated. Same runtime boot module-path as above, but only the test classes of the named modules are selected.  ## TODO  - [ ] Add an option handle to (console) launcher that parses an list of paths like `--scan-module-path [entry1[:entry_n]]` and delegates to the `ModuleFinderSelector` See http://download.java.net/java/jdk9/docs/api/java/lang/module/ModuleFinder.html  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2017-09-13T05:46:37Z","2017-10-17T12:45:28Z"
"","1237","Support Maven Surefire's `test` system property","## Overview  This PR makes surefire provider able to recognize `-Dtest=...` system property and filter discovered/executed tests based on its value.  Surefire parses provided system property value into `TestListResolver` which represents included and excluded tests as an object model. Model can be queried if particular class & method pair is included or not using `#shouldRun(String, String)` method. This PR wraps `TestListResolver` into a `PostDiscoveryFilter`, which is used to discover and execute actual tests with the `Launcher`.  Fixes #1193  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","lutovich","2018-01-10T23:55:22Z","2018-01-15T11:35:46Z"
"","1052","Polishing","## Overview  This PR is a smaller separated part of #1049, as requested by @sbrannen. It does the following: - Rename `URIConverter` to `UriConverter` for consistency with `UriSelector`.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jbduncan","2017-09-08T16:16:36Z","2017-09-12T08:10:09Z"
"","1050","Polishing","## Overview  This PR is a smaller separated part of #1049, as requested by @sbrannen. It does the following: - Move parentheses to make the precedence of certain operations clearer. - Replace a complicated usage of the ternary operator (?:) with if/else statements. - Shorten very simple if/else statements to ternary operators.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","jbduncan","2017-09-08T16:02:37Z","2017-11-09T13:27:52Z"
"","1051","Polishing","## Overview  This PR is a smaller separated part of #1049, as requested by @sbrannen. It does the following: - Apply `private` and `final` to an applicable class field. - Remove usages of `Collectors.toList()` and use `Stream` directly for brevity. - Use AssertJ's assertions over JUnit 5's more for consistency and clarity.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jbduncan","2017-09-08T16:11:23Z","2017-09-12T16:48:56Z"
"","1049","Polishing","## Overview  This PR introduces some polishing changes, including: - Moving parentheses to make the precedence of certain operations clearer. - Replacing a complicated usage of the ternary operator (?:) with if/else statements. - Shortening very simple if/else statements to ternary operators. - Applying `private` and `final` for class fields where applicable. - Using `Stream` more for brevity and clarity. - Using AssertJ's assertions over JUnit 5's own assertions more consistently. - Renaming `URIConverter` to `UriConverter` for consistency with `UriSelector`.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests)(http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jbduncan","2017-09-08T15:26:43Z","2017-09-08T16:17:16Z"
"","975","Polishing","## Overview  This PR introduces minor polishing improvements to JUnit 5 tests.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","jbduncan","2017-07-22T16:18:36Z","2017-07-27T14:11:10Z"
"","1400","Introduce a Kotlin extension function for ArgumentsAccessor","## Overview  This PR introduces a Kotlin _extension function_ for `ArgumentsAccessor` for parameterized tests.  Issue: #1382   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","wilder","2018-05-02T02:21:32Z","2018-05-05T10:47:38Z"
"","1117","Revise TestEngine default implementations","## Overview  This PR introduces a better implementation of `getArtifactId()` and `getVersion()` in interface `TestEngine` and `ModuleUtils`.  Closes #1114   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] ~~Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-not)~~ - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2017-10-17T15:16:34Z","2017-10-18T09:17:45Z"
"","1057","Part II - Add module org.junit.platform.commons.jpms","## Overview  This PR introduces `org.junit.platform.commons.jpms` as the default `ModuleClassFinder` implementation. See #1061 for details.  - [x] Revise directory layout according to https://guides.gradle.org/building-java-9-modules/ - [ ] Get a Gradle guru to review changes made to the build process - especially conditional `include`  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2017-09-11T21:46:26Z","2018-01-12T13:41:57Z"
"","1399","Add --fail-if-no-tests command line option to ConsoleLauncher","## Overview  This PR implements the `--fail-if-no-tests` command line option for the `ConsoleLauncher` as discussed in #1298.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Platform,","gaganis","2018-05-01T08:22:06Z","2018-06-21T20:37:20Z"
"","1530","Support @-files (parameter files) in ConsoleLauncher by migrating from jopt-simple to picocli","## Overview  This PR implements support for @-files (parameter files) by using the picocli command line parser instead of jopt-simple.   This also gives ANSI colored usage help on supported platforms.  Classes DetailsConverter, ThemeConverter, UriConverter, and KeyValuePairConverter were removed since they are not longer needed.  Checkstyle had some trouble with a javadoc `@throws` tag with a static inner class Exception. I enabled `SuppressionCommentFilter` and used `//CHECKSTYLE:OFF` to work around this. There may be a better solution.  Finally, the build failed on task `:platform-tests:checkstyleTest` for reasons that I did not understand. There were no error details. It could be an artifact of my environment, I may need some help with this.  Issue: #1498  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","remkop","2018-08-08T12:34:16Z","2018-08-12T11:12:20Z"
"","980","Overloaded assertThrows() that accept a message or message supplier","## Overview  This PR adds overloads for `assertThrows` that accept either a `String` or a `Supplier` as requested by issue #977 .  - [x] Introduce a version of assertThrows() that accepts a String message. - [x] Introduce a version of assertThrows() that accepts a Supplier message supplier.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","component: Jupiter,","Andrei94","2017-07-24T17:37:29Z","2017-07-27T14:20:41Z"
"","1741","Issues/1710 groovy assertions fixes","## Overview  This PR adds overloaded `assertEquals()` and `assertNotEqualsMethods()` to reestablish compatibility with Groovy's dynamic method dispatch.  Fixes #1710.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","mmerdes","2019-01-21T08:51:07Z","2019-04-14T13:06:17Z"
"","1556","Add ArchUnit-based tests to `platform-tooling-support-tests`","## Overview  This PR adds ArchUnit-based tests to the `platform-tooling-support-tests` project.  _At the moment it only enforces a cycle check that Degraph already applies. Caveat: both tools don't find the ""bad edges"" that `jdeps` is able to detect._  @codecholeric Am I using Arch-Unit as intended here? What could be improved?  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Vintage,","sormuras","2018-08-20T08:49:38Z","2018-08-31T14:01:37Z"
"","1539","Add JMH-based benchmarks for the Platform, Jupiter, and Vintage","## Overview  This PR add following platform benchmarks :  - junit 4 platform     + ```junit4_platform_noTest()``` : run a test class with no test method using junit 4 platform     + ```junit4_platform_emptyTest()``` : run a test class with an empty test method using junit 4 platform - junit jupiter platform     + using ```VintageTestEngine```         * ```junitJupiter_platform_vintage_noTest()``` : run a test class with no test method using  ```VintageTestEngine```         * ```junitJupiter_platform_vintage_emptyTest()``` : run a test class with an empty test method using ```VintageTestEngine```     + using ```JupiterTestEngine```         * ```junitJupiter_platform_noTest()``` : run a test class with no test method using ```JupiterTestEngine```         * ```junitJupiter_platform_emptyTest()``` : run a test class with an empty test method using ```JupiterTestEngine```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","fduminy","2018-08-12T09:23:56Z","2018-12-01T12:53:50Z"
"","1563","AssertThrows curiosity when supplier should return a Stream (in Eclipse)","## Overview  This may belong in the Eclipse bug tracker (assuming it's using its own JIT compiler), but it might also be based on how the runner is instantiated.  When a ``ThrowingSupplier`` passed to the ``assertThrows()`` method returns a ``Stream``, the assertion passes if the lambda method is enclosed in a block but fails if it's a single statement.  Note that Surefire 2.22.0 runs both assertions successfully.  I don't see anything in the ``AssertThrows`` class that would produce this behavior.  In addition, if the return type of the method throwing the NPE is not a ``Stream``, then both will pass (well ... for the few types that I tested anyway).  ```java     @Test     void assertThrowsCuriousity() {         assertThrows(NullPointerException.class, () -> { generateNpe(); });         assertThrows(NullPointerException.class, () -> generateNpe());     }      Stream generateNpe() {         throw new NullPointerException();     } ```  ## Deliverables  - [x] perhaps none","closed","component: Jupiter,","smoyer64","2018-08-28T20:45:04Z","2018-09-04T15:45:53Z"
"","1280","Introduce unit tests for predefined @Disabled*/@Enabled* variants","## Overview  This issue picks up where #219 left off.  ## Deliverables  - [x] Introduce dedicated unit tests for `EnabledIfSystemPropertyCondition`. - [x] Introduce dedicated unit tests for `DisabledIfSystemPropertyCondition`. - [x] Introduce dedicated unit tests for `EnabledIfEnvironmentVariableCondition`. - [x] Introduce dedicated unit tests for `DisabledIfEnvironmentVariableCondition`. - [x] Introduce dedicated unit tests for `EnabledOnOsCondition`. - [x] Introduce dedicated unit tests for `DisabledOnOsCondition`. - [x] Introduce dedicated unit tests for `EnabledOnJreCondition`. - [x] Introduce dedicated unit tests for `DisabledOnJreCondition`.","closed","component: Jupiter,","sbrannen","2018-02-03T18:00:05Z","2018-02-09T13:37:33Z"
"","1383","Introduce assertDoesNotThrow() with return value","## Overview  This issue picks up where #1348 left off.  ## Deliverables  - [x] Introduce overloaded variants of `assertDoesNotThrow()` that return a value, analogous to the `assertTimeout()` variants that accept a `ThrowingSupplier` instead of an `Executable`.","closed","component: Jupiter,","sbrannen","2018-04-23T11:16:00Z","2018-04-23T11:56:56Z"
"","1370","Improve test coverage for argument aggregator support","## Overview  This issue picks up where #1191 left off.  ## Deliverables  - [x] Verify that we have _decent_ code coverage for features introduced to support argument aggregation. - [x] Introduce unit tests for `ArgumentsAccessor`.   - Introduced in 5.2 M1. - [x] Introduce tests for exception handling and error cases when parameterized tests with aggregators are executed.   - In other words, `AggregatorIntegrationTests` currently only tests _happy paths_, but we need to test for known error cases as well.","closed","component: Jupiter,","sbrannen","2018-04-14T11:26:42Z","2018-04-29T12:04:05Z"
"","1369","Improve documentation for argument aggregator support","## Overview  This issue picks up where #1191 left off.  ## Deliverables  - [x] Document ""formal parameter order"" policy in public JavaDoc. - [x] Document ""formal parameter order"" policy in User Guide.","closed","component: Jupiter,","sbrannen","2018-04-13T16:29:16Z","2018-04-14T11:28:38Z"
"","1031","Status quo for selecting @TestTemplate or @TestFactory invocations by Unique ID","## Overview  This issue is a prerequisite for #1025.  ## Implementation Notes  - Update `JavaElementsResolver.resolveUniqueId(TestDescriptor, List)` so that it returns the number of resolved segments instead of a `boolean` and then check that all segments were resolved in `JavaElementsResolver.resolveUniqueId(UniqueId)` in order to determine what information to include in the log message.  ## Deliverables  - [x] Test the _status quo_ for selecting `@TestTemplate` and `@TestFactory` invocations by Unique ID.   - See `DiscoverySelectorResolverTests`. - [x] Update the warning logged by `JavaElementsResolver.resolveUniqueId()` so that it informs the user that the _Unique ID_ could only be _partially resolved_ and that all test template invocations or dynamic tests will be executed.   - See _Implementation Notes_.","closed","component: Jupiter,","sbrannen","2017-08-23T13:42:27Z","2017-08-23T17:32:07Z"
"","1291","allow to disable reporting","## Overview  This is only a hack, but I hope it shows what the intention is. I want to be able to disable the report entirely. Currently I modify `junitPlatformTest` as follows which is even a bigger hack:  ```groovy def reportIndex = junitPlatformTestTask.args.findIndexOf { it=='--reports-dir' } def keep = (0..(junitPlatformTestTask.args.size()-1)) - [reportIndex, reportIndex + 1] junitPlatformTestTask.args = junitPlatformTestTask.args[keep] ```  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","robstoll","2018-02-10T17:47:13Z","2018-02-12T14:01:24Z"
"","1310","WIP of #1309: Add support for a description of Arguments.","## Overview  This is a WIP PR for #1309. Some documentation is _deliberately_ missed, because we haven't yet agreed on the approach to go with, and on some implementation details.  Feedback is welcome! Perhaps some of TODOs are better to be discussed in the [issue](https://github.com/junit-team/junit5/issues/1309), not in the PR.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  --- ### TODO - [ ] CsvSource & CsvFileSource (need to agree on requirements, see the issue). - [ ] Consider lazy `Arguments#get` (a decorator) and more factory methods (depends on ^, see the [thread](https://github.com/junit-team/junit5/pull/1310#discussion_r170445795)) - [ ] Test description is preserved when arguments are stripped. - [ ] Default `ParameterizedTest#name` and how it is expanded (need to agree on requirements, see the issue).  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","dmitry-timofeev","2018-02-24T19:53:48Z","2021-04-23T10:58:44Z"
"","978","Overridden interface default methods are not considered overridden","## Overview  This is a follow-up to #976.  Whether or not the bug described in _this_ issue existed at a previous point in time is currently unknown (simply because it has not been researched).  In any case, we now have a situation where an _overridden_ interface default method is not considered to be overridden by the `findMethods()` search algorithm in `ReflectionUtils`.  Consequently, if we execute all tests in the following `GenericTestCaseWithOverriddenDefaultMethod` JUnit Jupiter based test class, we see that 3 tests are executed instead of 2. Specifically, we expect that only `test(Long)` and `test(Double)` will be executed; however, `test(Number)` is additionally _discovered_ resulting in `test(Long)` being executed twice.  ```java @ExtendWith({ LongParameterResolver.class, DoubleParameterResolver.class }) interface GenericTestInterface {  	@Test 	default void test(N number) { 	} }  class GenericTestCaseWithOverriddenDefaultMethod implements GenericTestInterface {  	@Test 	@Override 	public void test(Long number) { 	}  	@Test 	void test(Double number) { 	} } ```  ## Analysis  The recent series of [Whac-A-Mole](https://en.wikipedia.org/wiki/Whac-A-Mole) bug fixes in this area leads to me believe that the only _real_ solution to this set of problems is one that takes into account the actual generic and parameterized type information instead of relying on a best-guess approach involving method sub-signatures and blind checks for the presence of generics.  Depending on how we _take into account the actual generic and parameterized type information_, we might potentially wish to reverse a subset of changes in fae5b6a4f001e7427fba13b13fb844074d5ff099 that explicitly treat default methods as locally declared methods (while leaving the other changes in that commit in tact).  ## Further Considerations  This issue currently only focuses on overridden interface default methods; however, it may well be the case that our `findMethods()` search algorithm contains other bugs related to generics.  ## Related Issues  - #333  - #976   ## Deliverables  - [x] Ensure that overridden interface default methods are not returned in the results of `ReflectionUtils.findMethods()`. - [x] Investigate possible additional bugs hinted at in _Further Considerations_.   - to be addressed in #981","closed","theme: discovery,","sbrannen","2017-07-24T13:34:11Z","2017-07-24T19:46:41Z"
"","1047","Make custom logging façade testable","## Overview  This is a follow-up to #834.  ## Deliverables  - [x] Make custom logging façade _testable_ -- for example, by allowing tests to _attach_ some sort of listener in order to verify that particular statements were logged at a specific log level.   - See `org.junit.vintage.engine.RecordCollectingLogger` for inspiration.","closed","component: Vintage,","sbrannen","2017-09-08T13:09:08Z","2017-09-23T15:35:14Z"
"","1054","Set @API consumers attribute across the code base","## Overview  This is a follow-up task for #436.   ## Deliverables  - [ ]  Set the `consumers` attribute for `@API` declarations across the JUnit 5 code base.","open","component: Kotlin,","sbrannen","2017-09-09T14:06:21Z","2022-06-20T18:20:49Z"
"","1094","ExternalResource should implement AutoCloseable","## Overview  This is a feature request. We've some code that uses ExternalResources like TemporaryFolder within a test method, and that would be cleaner if ExternalResource implemented java.lang.AutoCloseable -  a trivial implementation like  ```        @Override         public void close() throws Exception {             after();         } ```  would be more than enough. Not suppling a patch per your request :)  ## Deliverables  - [ ] ...","closed","component: Vintage,","rbtcollins","2017-10-04T18:37:39Z","2017-10-29T16:07:06Z"
"","1285","Vintage 5.1.0-RC1 executes @BeforeClass before [runner:VintageBeforeClass$VintageTest] event","## Overview  This is a bug report. Different behaviors are observed after upgrading to `5.1.0-RC1`:  ```java public class VintageBeforeClass {     public static void main(String[] args) {         Launcher launcher = LauncherFactory.create();          launcher.registerTestExecutionListeners(new TestExecutionListener() {             @Override             public void executionStarted(TestIdentifier testIdentifier) {                 System.out.println(""Start: "" + testIdentifier.getUniqueId());             }         });          LauncherDiscoveryRequestBuilder requestBuilder = LauncherDiscoveryRequestBuilder.request()                 .selectors(selectClass(VintageTest.class));         launcher.execute(requestBuilder.build());     }      public static class VintageTest {         @BeforeClass         public static void beforeClass() {             System.out.println(""before class!"");         }          @org.junit.Test         public void test() {             System.out.println(""test!"");         }     } } ```  With `org.junit.vintage:junit-vintage-engine:5.1.0-M2`:  ``` Start: [engine:junit-vintage] Start: [engine:junit-vintage]/[runner:VintageBeforeClass$VintageTest] before class! Start: [engine:junit-vintage]/[runner:VintageBeforeClass$VintageTest]/[test:test(VintageBeforeClass$VintageTest)] test! ```  With `org.junit.vintage:junit-vintage-engine:5.1.0-RC1`:  ``` Start: [engine:junit-vintage] before class! Start: [engine:junit-vintage]/[runner:VintageBeforeClass$VintageTest] Start: [engine:junit-vintage]/[runner:VintageBeforeClass$VintageTest]/[test:test(VintageBeforeClass$VintageTest)] test! ```  `5.1.0-RC1` executes the `@BeforeClass` method before the `[runner:VintageBeforeClass$VintageTest]` event is triggered. This makes us unable to track which class the stdout comes from.","closed","component: Vintage,","blindpirate","2018-02-06T03:15:34Z","2018-02-06T13:49:57Z"
"","1309","Support custom description for set of arguments in parameterized tests","## Overview  This is a *feature request* and a follow-up to the discussion in #1306. Currently if a user needs to add a description of a set of arguments (e.g., because their string representation is not enough, or the differences between adjacent arguments are subtle), they need to (ab)use the `Arguments` by adding an additional one. This has a couple of drawbacks: - That argument must be specified in the test method signature. Although it may be given a descriptive name to clarify its purpose (e.g., ""testDescription""), it will still be highlighted by an IDE as _unused_ (see #1306). - A proper workaround is ugly: `@SuppressWarnings(""unused"")  // Used in the test name above` - Such argument is misleading, as it isn't a test _parameter_, but a meta-data about test parameters. It shall not affect the test results.  ### Example ```java import static org.junit.jupiter.api.Assertions.assertThrows;  import java.util.stream.Stream; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  class SampleTest {    @ParameterizedTest(name = ""{1}: {0}"")   @MethodSource(""testParameters"")   void test(String s,             @SuppressWarnings(""unused"")  // Used in the test name above             String testDescription) {     assertThrows(NumberFormatException.class,         () -> Integer.parseInt(s)     );   }    static Stream testParameters() {     return Stream.of(         Arguments.of(""1a"", ""illegal character""),         Arguments.of(""10000000000000"", ""out of bounds"")     );   } } ```  ## Possible solutions As suggested by @sormuras  in the [discussion](https://github.com/junit-team/junit5/issues/1306#issuecomment-368229340), an optional attribute may be added to `Arguments`.  ## Alternatives - #1306, but it will enable users to write confusing code (= reference some arguments that do not appear in the method parameters by index).  ## Questions - [ ] Q1: Shall `CsvSource` & `CsvFileSource` be expanded with a similar attribute (e.g., description column index): ```java @CsvSource(arguments = {     ""Arg1, Arg2, Test Case #1 Description"",     // …     }, descriptionColumnIndex = 2) ```  ? - [ ] Q2:  Shall we change the default value of `org.junit.jupiter.params.ParameterizedTest#name` or the interpretation of `{arguments}` to include the description if it's non-empty? - [ ] Q3: What a name of the method setting a description should be (consider IDE auto-complete!):    - ~~`desc`~~    - `description`    - `describedAs`    - `withDescription`? - [x] Q4: What return type of the method returning the description should be:    - ~~String, with empty string meaning no description.~~    - Optional, with empty meaning no description. PoC shows, that this one is preferred. - [ ] Q5: Shall the method setting a description accept:    - `String`.    - `CharSequence`    - `Object` and format as it does the parameters? - [ ] Q6: How to separate parameters and their description:   - a space: ` `   - a dot + space: `. `   - a colon + space: `: ` (A colon is likely to appear in description itself, e.g. ""Regression: Integer.MIN_VALUE, see XYZ-123"").   ## Deliverables  - [ ] User Guide must be updated - [ ] **TBD**","open","status: waiting-for-interest,","dmitry-timofeev","2018-02-24T16:03:11Z","2022-05-12T18:28:48Z"
"","1823","Introduce config parameter for default DisplayNameGenerator","## Overview  This feature enables users to use their custom display name generator by providing Jupiter configuration.  - Jupiter configuration parameter for default display name generator: `junit.jupiter.displayname.generator.default` - Generator class needs to be of type `org.junit.jupiter.api.DisplayNameGenerator` - The fully qualified class name should be provided via this configuration parameter. - If the configuration parameter is not provided, Jupiter will use the `Standard` implementation. - Order of display name logic is 1.  Take value from `@DisplayName`. 2. Use `DisplayNameGenerator` configured via `@DisplayNameGeneration`. 2. Use `DisplayNameGenerator` configured via the `junit.jupiter.displayname.generator.default` configuration parameter. 4. Use `org.junit.jupiter.api.DisplayNameGenerator.Standard` as fallback.  Issue: #1797  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","gopinath-langote","2019-03-17T11:41:29Z","2019-05-23T12:09:03Z"
"","1067","Extract the `ApiReport` into `apiguardian` project","## Overview  This extracts the `ApiReport` type into the `apiguardian` project.  This PR will not build as it is without a release to some common shared repository of the `apiguardian-report` project.  This can still be tested by checking out the `apiguardian` PR in a directory that is a sibling of the `junit5` directory.  Paired with this PR: https://github.com/apiguardian-team/apiguardian/pull/1  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","JLLeitschuh","2017-09-16T02:36:54Z","2019-07-19T19:32:44Z"
"","1674","Introduce junit-platform-reporting module","## Overview  This commit moves the `XmlReportsWritingListener` and related types from the `junit-platform-console` module into the new `junit-platform-reporting` module. It also publishes the listener for external use, marked with `@API(status = EXPERIMENTAL)` for now.  Addresses #1375  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2018-11-10T15:24:47Z","2018-11-21T19:28:29Z"
"","1010","Add support for TestNG-style assertions.","## Overview  This change provides a migration path for projects to migrate from TestNG-style assertions to JUnit-5-style assertions. Specifically, it implements an AssertionsTestNG class that duplicates the functionality of Assertions, but with the order of expected and actual arguments reversed to fit with the TestNG convention.  Issue: #1009  Javadoc in AssertionsTestNG.java hasn't been updated pending agreement that this change is fundamentally acceptable. I propose that the documentation for every method be limited to a link to the equivalent method in Assertions.java and a class-level introduction explaining the difference.  The tests are purposely shallow, and is solely to be sure that the correct expected and actual value information ends up in the AssertionFailedErrors that are raised.  ---  ~~I hereby agree to the terms of the JUnit Contributor License Agreement.~~ (Pending corporate agreement)  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","ebd2","2017-08-08T18:15:18Z","2017-08-08T19:18:26Z"
"","1868","Introduce extension APIs to handle exceptions from lifecycle callback methods","## Overview  This change is an alternative take on issue #1454 based on still not merged PR https://github.com/junit-team/junit5/pull/1509. In this version there are separate interfaces supporting exception handling in each of `@BeforeAll`, `@BeforeEach`, `@AfterEach` and `@AfterAll`, so that it is not forced on the handler to implement `handleTestExecutionException` in addition to `handle(Before/After)(/All/Each)ExecutionException`  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","pietrygamat","2019-04-22T01:10:51Z","2019-06-06T13:29:22Z"
"","992","Update Gradle from 4.0.1 to 4.0.2","## Overview  This bug-fix release addresses two regressions in 4.0/4.0.1 that may lead to hanging build executions and one that can cause issues with dependency excludes.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","stefanbirkner","2017-07-28T20:51:10Z","2017-07-30T18:55:35Z"
"","994","Resolvers apply class filter themselves","## Overview  This avoids that some class filters are applied twice. Now there is a dedicated place for applying the class filters.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","stefanbirkner","2017-07-29T17:50:14Z","2017-08-24T05:58:31Z"
"","1001","Add Kotlin specific assertion helpers","## Overview  This adds several Kotlin friendly assertions to the standard JUnit assertion API.  Closes #924  ## What does this actually add?  The `Assertions.kt` file you see has top-level functions. When the compiler runs it actually creates a ""hidden"" class called `AssertionsKt` that contains these static methods. This name could be changed with an annotation to something like `KotlinAssertions`. This name will never actually show up in anyone's code but will end up in the compiled bytecode so changing the name of this file will be a breaking change (like changing the name of any class in Java).  ## Documentation  Unfortunately, I was unable to get (Dokka)[https://github.com/Kotlin/dokka] to behave correctly so that it would generate JavaDocs. The best that we can do on this front is document these methods in the user guide and show how they can be imported.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","JLLeitschuh","2017-08-04T00:48:47Z","2017-11-13T19:10:13Z"
"","1470","Rename file to match class name","## Overview  There’s a bug in the source: The file  `junit-platform-console/src/main/java/org/junit/platform/console/options/URIConverter.java` contains the class `org.junit.platform.console.options.UriConverter` –  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Platform,","piefel","2018-06-18T15:12:36Z","2018-06-20T17:33:47Z"
"","1607","Introduce support for assertNotEquals for primitive data types","## Overview  There is currently support for `assertEquals( expected, actual )` and `assertEquals( expected, actual , delta )` for primitive types, e.g. `int`, `float`, `double`, but there is no support for `assertNotEquals( unexpected, actual , delta )`. The current `assertNotEquals()` function only works on `Object`.   This is a change from JUnit 4 which had support for functions such as this. Auto-boxing technically adds support for `assertNotEquals( unexpected, actual )` to primitive types, but that could cause performance issues if testing a very large number of points.  ## Deliverables  - [x] Introduce `assertNotEquals( expected, actual , delta )`  for floats and doubles - [x] Introduce `assertNotEquals( unexpected, actual )` for `boolean`, `byte`, `char`, `short`, `int`, `float`, `double`  ## Related Issues  - #269","closed","component: Jupiter,","lessthanoptimal","2018-09-28T16:19:03Z","2018-10-18T09:05:51Z"
"","1222","Dependency Diagram missing in User Guide","## Overview  There is a bug in the Gradle plugin for Asciidoctor (https://github.com/asciidoctor/asciidoctor-gradle-plugin/issues/222) which prevents the diagram from being generated if the Gradle daemon is running.  ## Workaround  The following (which disables the Gradle daemon) generates the diagram on my local machine:  `gradle --no-daemon :documentation:clean ascii`  ## Original Assumption  Due to recent changes to the build, the _Dependency Diagram_ created with Plant UML is no longer included in the snapshot build for the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/#dependency-diagram), and we now see the following warning during the build.  `asciidoctor: WARNING: overview.adoc: line 146: invalid style for listing block: plantuml`  ## Deliverables  - [x] Ensure that the _Dependency Diagram_ is included in the User Guide -- for example, by disabling the Gradle daemon when generating the User Guide on the CI server.","closed","component: Platform,","sbrannen","2017-12-31T14:03:39Z","2018-01-08T16:09:46Z"
"","1587","How do non-Maven users download JUnit?","## Overview  There doesn't seem to be a way for developers who aren't using Maven to download JUnit 5 and reference it from their projects.  Am I missing something, or is this something that JUnit doesn't support as yet?  ## Deliverables  A method of downloading JUnit and getting it running in a Java build system which doesn't use Maven.","closed","status: stale,","andrewducker","2018-09-14T13:39:37Z","2021-06-19T12:50:32Z"
"","1590","Easily apply the same assertion(s) on a collection of items","## Overview  There are occasions in which you have a collection or stream of items, and you want to run the same assertion(s) on all of them. Moreover, you don't want to stop at the first failure, but rather you want to run the assertion in all items and get a full report. This can be done with the current set of assertions, but it could be useful to have some syntactic sugar to do this in a more compact manner.  For instance, if I have a list of invalid documents (that I'm defining somewhere else), and I want to test that my validator appropriately reports all of them as invalid, I would like a construct like this:  ```java List invalidDocuments = getInvalidDocuments(); assertForAll(invalidDocuments, doc -> () -> assertFalse(validator.isValid(doc))); ```  I know this looks similar to the following, but this stops at the first failure, which isn't what I would like to achieve:  ```java List invalidDocuments = getInvalidDocuments(); invalidDocuments.forEach(doc -> assertFalse(validator.isValid(doc))); ```  I guess I could also use `assertThat` on the collection and then specify a matcher to be applied to all items, but then I would have to write matchers instead of straight assertions, which would be more code. I would like the simplicity of one single, static assertion to check all items abide by one or more assertions.  ## Deliverables  Something like the following can work; further versions can easily be made to cover `Stream` and the like.  ```java public static  void assertForAll(Collection items, Function executableProvider) throws MultipleFailuresError { 	final List assertions = items.stream() 			.map(executableProvider) 			.collect(toList());  	assertAll(assertions); } ```","closed","component: Jupiter,","quiram","2018-09-19T15:24:47Z","2018-09-22T14:23:47Z"
"","1323","Move Cross-Engine Annotations to Platform API Package","## Overview  There are a few annotations (`@DisplayName`, `@Tag`, `@Tags`, `@Disabled`) that will eventually be implemented by all annotation-based test engines. For example, jqwik just introduced a `@Label` annotation to allow for customized test names.  For test writers it can be confusing why they have to choose different annotations for different types of tests to basically do the same thing.  ### Suggested Solution  Duplicate `@DisplayName`, `@Tag`, `@Tags`, `@Disabled` in org.junit.platform.commons.annotation (which already contains `@Testable`) and mark the original ones as deprecated.   Alternatively one could introduce a new package, e.g. org.junit.platform.api for these annotations.","closed","component: Platform,","jlink","2018-03-08T07:13:17Z","2018-03-12T18:25:51Z"
"","1084","Vintage engine does not apply PackageNameFilters consistently","## Overview  The Vintage engine does not apply `PackageNameFilters` when tests are selected via `ClassSelectors`, `MethodSelectors`, or `UniqueIdSelectors`.  ## Deliverables  - [x] Apply `PackageNameFilters` when tests are selected via `ClassSelectors`, `MethodSelectors`, or `UniqueIdSelectors`. - [x] Update Release Notes","closed","theme: discovery,","marcphilipp","2017-09-29T20:15:31Z","2017-09-29T20:51:47Z"
"","1817","Avoid using deprecated gradle configurations in user guide","## Overview  The user guide instructions used `testCompile` and `testRuntime` Gradle configurations, which are deprecated for quite a long time now (see file:///Users/jb/projects/gradle/subprojects/docs/build/docs/userguide/java_plugin.html#tab:configurations). This PR replaces them by `testImplementation` and `testRuntimeOnly`  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jnizet","2019-03-16T09:22:49Z","2019-03-16T09:27:19Z"
"","1037","Cache downloaded dependencies with Travis CI","## Overview  The travis builds could be faster if they used the build cache. This would simply store the dependencies of the build so that they don't have to get re-downloaded for ever build.  https://docs.travis-ci.com/user/languages/java/#Caching  ## Deliverables  - [ ] Add dependency caching to travis config","closed","theme: build,","JLLeitschuh","2017-08-30T21:21:13Z","2018-01-12T13:43:16Z"
"","1224","Test methods cannot combine RepeatedTest and ParameterizedTest annotations","## Overview  The title pretty much explains it. Test methods annotated with `@RepeatedTest(n)` and `@ParameterizedTest` will fail _n_ times with a `ParameterResolutionException`, then run the parameterized test as normal  #### Test class  ```java class JUnitCannotCombineRepeatedAndParameterizedTests {    @RepeatedTest(5)   @ParameterizedTest   @MethodSource(""source"")   void test(String param) {     System.out.println(param);   }    static Stream source() {     return Stream.of(Arguments.of(""foo""),                      Arguments.of(""bar""));   }  } ```  #### Expected result  The parameterized test should run 5 times with the parameters generated by the `source()` method eg  ``` [repetition 1 of 5]   foo   bar [repetition 2 of 5]   foo   bar ... ```  #### Actual result  There are 5 repetitions of the test, each one failing with this exception:  ```java org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [java.lang.String arg0] in executable [void JUnitCannotCombineRepeatedAndParameterizedTests.test(java.lang.String)]. ```  After this, the test is run with the parameters generated by `source()`  This occurs on 5.0.0 and 5.1.0-M1","closed","theme: parameterized tests,","SamCarlberg","2018-01-04T05:16:57Z","2021-01-28T18:14:16Z"
"","1226","TestTemplateInvocationContextProvider should have type bounded return to allow implementations to more easily return TestTemplateInvocationContext implementations","## Overview  The signature of `Stream provideTestTemplateInvocationContexts(ExtensionContext context);` requires casting under certain implementation conditions. For example, one usage where I am forced to cast the implementation type to the interface type is here: https://github.com/mkobit/jenkins-pipeline-shared-libraries-gradle-plugin/blob/b1d0b2f207cf2d28d96fa8e16692fda657abfb75/src/test/kotlin/testsupport/MultiVersionGradleProjectTestTemplate.kt#L35-L43  Contrived example:  Java:  ```java class NoExtends implements TestTemplateInvocationContextProvider {      @Override public boolean supportsTestTemplate(final ExtensionContext context) { return false; }      @Override     public Stream provideTestTemplateInvocationContexts(ExtensionContext context) {       // Dumb example, but would be something more complex context.getTestInstance().map(i -> Stream.of(DummyContext))       // or context.getConfigurationParameter().map()       Stream s = Stream.of(new DummyContext());       return s;     }     private static class DummyContext implements TestTemplateInvocationContext {}   } ```  Fails to compile to do incompatible type of `Stream` and `Stream`.  _Proposal_: change `Stream provideTestTemplateInvocationContexts(ExtensionContext context);` to `Stream provideTestTemplateInvocationContexts(ExtensionContext context)`, but it looks to be backwards compatibility breaking change based on the discussion on the Gitter and my understanding of https://wiki.eclipse.org/Evolving_Java-based_APIs_2#Evolving_API_interfaces_-_API_methods  > Add, delete, or change type bounds of type parameter | - | **Breaks compatibility** -- | -- | --  I do believe that implementations of the `TestTemplateInvocationContextProvider` would still be able to compile with no changes but I don't know the runtime implications.  ## Deliverables  - [ ] ...","closed","component: Jupiter,","mkobit","2018-01-04T17:40:30Z","2018-01-13T19:28:05Z"
"","1480","Prune Release Notes for 5.3","## Overview  The release notes in `master` currently include:  > the _change log_ for all JUnit 5 releases since 5.1 GA.  That should be ""since 5.2 GA"", and we should _prune_ the release notes like we have done previoulsy (see ef576cafe55e62e69a0cca8940e342c64f6d8ee5).  ## Related Issues  - #1349  ## Deliverables  - [x] Prune Release Notes for 5.3.","closed","theme: documentation,","sbrannen","2018-06-26T14:03:18Z","2018-06-26T15:26:11Z"
"","1269","Introduce LauncherConfig for configuring engines and listeners","## Overview  The pull request addresses the feature request in #767.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","baev","2018-01-29T15:05:58Z","2018-08-10T11:31:08Z"
"","1300","Export findAllClassesInModule() for usage outside the framework","## Overview  The platform-internal method `findAllClassesInModule` in class `org.junit.platform.commons.util.ModuleUtils` is not exported for external usage.   The Jupiter engine uses it here:  https://github.com/junit-team/junit5/blob/master/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java#L62-L63  3rd-party test engines, as [JQwik](https://github.com/jlink/jqwik/blob/master/src/main/java/net/jqwik/discovery/JqwikDiscoverer.java), can't find test classes in modules, yet.  ## Deliverables  - [x] Add `findAllClassesInModule` to `org.junit.platform.commons.support.ReflectionSupport`","closed","theme: modules,","sormuras","2018-02-19T20:30:36Z","2018-04-04T15:53:43Z"
"","1099","Update Asciidoctor PDF backend of the user-guide","## Overview  The PDF backend of the User Guide is disabled at the moment, since it does not work with Java 9.  See `documentation/documentation.gradle:83` for backend configuration.  See https://github.com/jruby/jruby/issues/4805 for the underlying issue.  ## Related Issues  - #770  - #777   ## Deliverables  - [x] Fix broken links:   - [x] link from PDF version of User Guide to release notes   - [x] link from PDF version of Release Notes to user guide - [x] Enable PDF backend when https://github.com/jruby/jruby/issues/4805 is solved and JRuby **9.1.14** is released.","closed","component: Platform,","sormuras","2017-10-09T08:35:54Z","2018-04-22T21:06:22Z"
"","1608","Asciidoctor PDF backend fails on Java 11","## Overview  The PDF backend of the User Guide is disabled at the moment, since it does not work with Java 11.  Similar to #1099 -- when upgrading to Java 9.  Related issue: https://github.com/jruby/jruby-openssl/issues/175  ## Deliverables  - [x] Enable PDF backend when it works again.","closed","theme: documentation,","sormuras","2018-09-29T06:49:30Z","2019-02-06T16:17:42Z"
"","1852","Introduce InvocationInterceptor extension API","## Overview  The new extension API allows intercepting the invocation of test class constructors, lifecycle methods, testable methods, and dynamic tests. It validates that an invocation is asked to proceed exactly once. The user guide is updated with an example that executes all test methods in Swing's EDT.  Resolves #157.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","marcphilipp","2019-04-08T20:13:19Z","2019-05-05T12:07:25Z"
"","1056","AbstractTestDescriptor allows inconsistent parent/child relationships","## Overview  The methods in `AbstractTestDescriptor`allows the parent/child relationship to be inconsistent.  ## Deliverables  - [x] The `setParent()` method should throw an exception if the passed-in descriptor is not `null` and `this.parent` is not `null` - [x] The `removeFromHierarchy()` method should call `setParent(null)` on all children.","closed","status: stale,","kcooney","2017-09-10T00:36:00Z","2022-07-12T23:11:11Z"
"","1126","Surefire provider should ignore empty strings for includeTags and excludeTags","## Overview  The junit-platform-surefire-provider does not accept empty string for includeTags and excludeTags properties.  It is inconvenient, because I can't  use default value in pom.xml and overwrite it with -D option.   ## Detail  When I pass empty string to includeTags/excludeTags, following exception occurs:  ``` Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test failed: There was an error in the forked process [ERROR] org.apache.maven.surefire.util.SurefireReflectionException: org.junit.platform.commons.util.PreconditionViolationException: Tag name [] must be syntactically valid [ERROR] 	at org.apache.maven.surefire.util.ReflectionUtils.instantiateOneArg(ReflectionUtils.java:135) [ERROR] 	at org.apache.maven.surefire.booter.ForkedBooter.createProviderInCurrentClassloader(ForkedBooter.java:321) [ERROR] 	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:290) [ERROR] 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:242) [ERROR] 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:121) [ERROR] Caused by: org.junit.platform.commons.util.PreconditionViolationException: Tag name [] must be syntactically valid [ERROR] 	at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:285) [ERROR] 	at org.junit.platform.engine.TestTag.(TestTag.java:120) [ERROR] 	at org.junit.platform.engine.TestTag.create(TestTag.java:116) [ERROR] 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) [ERROR] 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) [ERROR] 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) [ERROR] 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) [ERROR] 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) [ERROR] 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) [ERROR] 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) [ERROR] 	at org.junit.platform.launcher.TagFilter.toTestTags(TagFilter.java:125) [ERROR] 	at org.junit.platform.launcher.TagFilter.includeTags(TagFilter.java:79) [ERROR] 	at java.util.Optional.map(Optional.java:215) [ERROR] 	at org.junit.platform.surefire.provider.JUnitPlatformProvider.getIncludeAndExcludeFilters(JUnitPlatformProvider.java:154) [ERROR] 	at org.junit.platform.surefire.provider.JUnitPlatformProvider.(JUnitPlatformProvider.java:85) [ERROR] 	at org.junit.platform.surefire.provider.JUnitPlatformProvider.(JUnitPlatformProvider.java:79) [ERROR] 	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) [ERROR] 	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) [ERROR] 	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) [ERROR] 	at java.lang.reflect.Constructor.newInstance(Constructor.java:423) [ERROR] 	at org.apache.maven.surefire.util.ReflectionUtils.instantiateOneArg(ReflectionUtils.java:131) [ERROR] 	... 4 more ```","closed","3rd-party: Maven Surefire,","tmurakam","2017-10-25T01:52:15Z","2017-11-11T22:40:37Z"
"","1430","Fix determineFullyQualifiedClassName() when ZipPath.relativize() returns paths like ../foo","## Overview  The JDK's `ZipPath.relativize()` returns paths like `../foo` when attempting to when attempting to look for test classes in packages contained in JAR files. So `determineFullyQualifiedClassName()` constructs ""fully qualified class names"" that look like `com.example.bar...foo.Someclass` instead of `com.example.foo.Someclass`. Reimplemented the method without using `relativize()`, and simplified.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [unchanged] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [unchanged] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [N/A] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [?] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","jernst","2018-05-25T04:28:51Z","2018-07-28T16:14:19Z"
"","1387","Unicode characters in Javadoc displayed as \u....","## Overview  The Javadoc comment for https://junit.org/junit5/docs/snapshot/api/org/junit/jupiter/api/Assertions.html#assertLinesMatch(java.util.List,java.util.List) displays `\u2718` instead of `✘` or `\u2502` instead of `│`.  The Javadoc syntax used to include the code snippets seems correct, though: https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java#L945  All `javadoc` commands use the `UTF-8` encoding option.  ## Deliverables  - [x] Replace example with using ASCII-only characters","closed","component: Jupiter,","sormuras","2018-04-24T11:20:38Z","2018-04-24T18:49:36Z"
"","1668","Supply invocation index for @ParameterizedTest to test author","## Overview  The invocation index of a parameterized test is accessible for templating when setting the display name of the test.  When it comes to accessing the invocation index using `TestInfo` it is not possible as it looks like the `TestInfo` implementation for `@ParameterizedTest` is of the default type. I would expect to get an `RepetitionInfo` instance so that I can access the invocation index programmatically.   ## Related Issues  - #944 - #1139 - #1884","open","theme: parameterized tests,","Gabology","2018-11-08T06:30:20Z","2021-12-05T00:39:52Z"
"","1426","Migrate from Maven Plugin to Maven Publish Plugin","## Overview  The Gradle team has recently stated that the [Maven Publish Plugin](https://docs.gradle.org/4.8-rc-1/userguide/publishing_maven.html) is now stable and should be used in favor of the ""old"" [Maven Plugin](https://docs.gradle.org/4.8-rc-1/userguide/maven_plugin.html). Since we currently use the latter, we should look into migrating to the _Maven Publish Plugin_.  ## Deliverables  - [x] Migrate to the _Maven Publish Plugin_ in the Gradle build.","closed","theme: build,","sbrannen","2018-05-20T10:00:18Z","2018-05-20T14:07:28Z"
"","1489","FilePosition.fromQuery() fails if any query parameter has a non-integer value","## Overview  The following results in an empty `Optional` with a swallowed (but logged) `java.lang.NumberFormatException: For input string: ""bar""`.  ```java FilePosition.fromQuery(""line=42&foo=bar&column=23""); ```  ## Related Issues  - #1178  ## Deliverables  - [x] Ensure that `FilePosition.fromQuery()` properly parses query strings containing key-value pairs other than the supported `line=#` and `column=#` pairs.","closed","component: Platform,","sbrannen","2018-07-06T12:18:00Z","2018-07-06T13:00:35Z"
"","1063","Illegal Reflective Access on JDK 9+","## Overview  The following components are not yet working without illegal reflective access operations.  ### Gradle 4.5.1 with Groovy `groovy-all-2.4.12.jar` ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.codehaus.groovy.vmplugin.v7.Java7$1 (file:/~/.gradle/wrapper/dists/gradle-4.5.1-bin/a5vbgfvpwtoqz8v2cdivxz28k/gradle-4.5.1/lib/groovy-all-2.4.12.jar) to constructor java.lang.invoke.MethodHandles$Lookup(java.lang.Class,int) WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.vmplugin.v7.Java7$1 ```  ## Deliverables  - [x] Update Gradle (providing Groovy) to version w/o illegal reflective access opertions. - [x] Updated AssertJ to version 3.9.1 via #1301","closed","theme: modules,","sormuras","2017-09-14T04:12:27Z","2019-07-14T12:34:49Z"
"","1059","Decide on naming convention for source code elements pertaining to acronyms","## Overview  The following comment was intended for #1052; however, the branch has been deleted in the interim making it impossible to post a comment.  ## Comments in Reply to #1052   Regarding the `UriSelector` vs `URISelector` discussion, IMHO `UriSelector` was the right choice.  Whenever you need to include acronyms as part of a type name or method name, it is best to keep the first letter of the acronym uppercase and use lowercase for the rest of the acronym. Otherwise, it becomes _impossible_ to perform camel-cased searches in IDEs, and it becomes potentially very difficult for mere humans to read and/or reason about the thing without reading documentation (if documentation even exists).  Consider for example a use case needing to support an HTTP URL. Calling the method `getHTTPURL()` is absolutely horrible in terms of usability; whereas, `getHttpUrl()` is great in terms of usability. The same applies for types `HTTPURLProvider` vs `HttpUrlProvider`.  I would therefore argue that `URIConverter` should be renamed `UriConverter` for consistency within the framework and in favor of usability.  Since it's an internal class, there is no harm in renaming it, even after 5.0 GA.  ## Deliverables  - [x] Decide on naming convention for source code elements pertaining to acronyms - [x] Document naming convention for source code elements pertaining to acronyms - [x] Rename `URIConverter` to `UriConverter`.","closed","type: task,","sbrannen","2017-09-12T14:49:10Z","2017-09-22T21:11:44Z"
"","1495","Fix ArgumentsAccessor extension function shadowing","## Overview  The extension function was being shadowed by [org.junit.jupiter.params.aggregator.get](https://github.com/junit-team/junit5/blob/master/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/ArgumentsAccessor.java#L55). This commit renames the funcion so it can be used correctly.  Issue: #1490   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","wilder","2018-07-11T03:56:49Z","2018-07-25T19:19:35Z"
"","1689","Nested assumption failures should not cause assertion failures for enclosing assertThrows()","## Overview  The effect of the `org.junit.jupiter.api.Assumptions.assume*()` family of methods depends on whether or not the call is inside an `assertThrows()` lambda or not. I think a failed assumption should always behave the same, i.e. cause the test to be aborted. I think this is a failure of `assertThrows()` to not propagate the `TestAbortedException` exception.  ## Steps to reproduce  The following test fails on the thrown exception being different from the expected, while I think it should instead be ignored:  ```java @Test void example() {     assertThrows(IOException.class, () -> assumeTrue(false)); } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit Jupiter version `5.2.0`.  - Build Tool/IDE: Maven 3.5.4, Intellij 2018.3.","closed","component: Jupiter,","chrisvest","2018-11-29T13:36:26Z","2018-11-30T12:42:54Z"
"","1045","Change license to EPL v2.0","## Overview  The Eclipse Foundation recently [announced EPL v2.0](https://www.eclipse.org/org/press-release/20170829eplv2.php).  After discussions with Eclipse Foundation's legal department, we have learned that the JUnit Team does not need to seek the permission of past contributors, unless the team wants to add in the GPL compatibility.  However, the Eclipse Foundation suggests to:  - inform downstream users of the change - ensure there is rough consensus amongst the committers that this is the right time to switch  ## Deliverables  - [x] Decide within the JUnit 5 Team if this is the right time to switch to EPL v2.0. - [x] Consider contacting all [contributors](https://github.com/junit-team/junit5/graphs/contributors) to inform them of the decision to switch to the EPL v2.0. - [x] Update all license headers in all source code (Java, Groovy, Kotlin, etc.). - [x] Update license header used by Spotless.   - `src/spotless/eclipse-public-license-1.0.java` - [x] Update Spotless license header configuration in the Gradle build. - [x] Update all `LICENSE.md` files in repository.   - [x] which should include license files included in published artifacts, but this should be verified.","closed","type: task,","sbrannen","2017-09-07T11:16:33Z","2019-07-19T19:32:43Z"
"","1199","Update IDE Support documentation","## Overview  The documentation currently says Eclipse only offers beta support for JUnit 5, however Eclipse has recently offered full production support for JUnit 5 with Eclipse Oxygen.1a (4.7.1a)","closed","component: Platform,","wkorando","2017-12-07T19:13:12Z","2018-01-14T09:19:15Z"
"","1003","Read ConfigurationParameters from properties file in classpath","## Overview  The discussion in #905 has brought to light that some test authors would like to configure different default values for the test instance lifecycle etc. without being forced to annotate each and every test class.  `ConfigurationParameters` already allows one to specify parameters for test engines. It currently uses JVM system properties as a fallback mechanism if a requested parameter is not explicitly provided when building a discovery request. However, system properties need to be specified for **every** launch configuration in an IDE, etc. which is often cumbersome and repetitive.  So, in addition to explicit parameters and system properties, we should read configuration parameters from a classpath resource called `junit-platform.properties` that could look like this:  ``` junit.jupiter.conditions.deactivate = org.junit.jupiter.* junit.jupiter.extensions.autodetection.enabled = true junit.jupiter.testinstance.lifecycle.default = per_class ```  ## Configuration Parameter Resolution   The lookup in `LauncherConfigurationParameters`for a config parameter would check the following sources in this order:  1. explicitly specified parameters 2. system properties 3. config file  So, only if a parameter is neither explicitly specified nor present as a system property, would it be read from the config file.  ## Deliverables  - [x] Read `ConfigurationParameters` from properties file in the classpath.   - [x] Ensure proper resolution order.   - [x] Log `INFO` message if properties file detected.   - [x] Update JavaDoc for `ConfigurationParameters`. - [x] Document in the User Guide. - [x] Document in the release notes.","closed","component: Platform,","marcphilipp","2017-08-04T18:59:11Z","2017-08-14T20:08:34Z"
"","1095","Provide meaningful failure messages for assertTrue() & assertFalse()","## Overview  The default failure message for `assertTrue()` and `assertFalse()` is currently `null` which means that the failure message for something like `assertTrue(false)` results in a stack trace like the following.  ``` org.opentest4j.AssertionFailedError:  	at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:48) 	at org.junit.jupiter.api.AssertFalse.assertFalse(AssertFalse.java:54) 	at org.junit.jupiter.api.AssertFalse.assertFalse(AssertFalse.java:33) 	at org.junit.jupiter.api.Assertions.assertFalse(Assertions.java:158) ```  See: https://twitter.com/vogella/status/915968398370246657  ## Deliverables  - [x] Provide meaningful failure messages for `assertTrue()`. - [x] Provide meaningful failure messages for `assertFalse()`.","closed","component: Jupiter,","sbrannen","2017-10-05T18:18:25Z","2017-11-05T17:33:03Z"
"","1849","Introduce support for finding repeatable annotations on repeatable annotations","## Overview  The current search algorithm for repeatable annotations does not find repeatable annotations if they are used as meta-annotations on other repeatable annotations. However, as a prerequisite for #1793, we need to be able to find such repeatable annotations.  ## Deliverables  - [x] Update the search algorithm in `AnnotationUtils.findRepeatableAnnotations()` to find repeatable annotations on repeatable annotations. - [x] Document this new feature in the Release Notes.","closed","component: Platform,","sbrannen","2019-04-07T13:54:08Z","2019-04-07T14:56:22Z"
"","1349","Prune Release Notes for 5.2","## Overview  The current release notes in `master` currently include:  > the _change log_ for all JUnit 5 releases since 5.0 GA.  That should be ""since 5.1 GA"".  ## Deliverables  - [x] Prune Release Notes for 5.2.","closed","theme: documentation,","sbrannen","2018-03-30T16:25:35Z","2018-04-03T12:54:44Z"
"","1114","Revise TestEngine default implementations","## Overview  The current implementation of `getArtifactId()` and `getVersion()` in interface `TestEngine` use a script-like reflection hack to retrieve the respective information. With the MRJAR support introduced this can refactored to a clean, compiled solution.  ## Deliverables  - [ ] Remove `ReflectionUtils.invokeGetters` - [ ] Implement and use `ModuleUtils.getModuleName(Class)` - [ ] Implement and use `ModuleUtils.getModuleVersion(Class)`","closed","theme: modules,","sormuras","2017-10-17T13:07:02Z","2018-01-12T13:40:37Z"
"","1132","Improve documentation of supported utilities in the User Guide","## Overview  The current content of the [Supported Utilities in Extensions](http://junit.org/junit5/docs/current/user-guide/#extensions-supported-utilities) section of the User Guide is very lacking.  ## Deliverables  - [x] Improve documentation of supported utilities in the User Guide.   - Mention `AssertionSupport` and `ReflectionSupport` specifically, pointing out the basic feature set above and beyond what the core JDK libraries have to offer.","closed","component: Platform,","sbrannen","2017-10-31T13:03:31Z","2018-01-24T11:23:39Z"
"","1115","Revise ModuleSelector handling","## Overview  The current `ModuleSelector` handling uses a special name, namely `ALL-MODULES`, to scan all resolved modules found in the boot layer configuration.  ## Deliverables  - [ ] Try an alternate solution that does not need the special name","closed","theme: modules,","sormuras","2017-10-17T13:09:58Z","2017-10-17T18:04:52Z"
"","1459","Convert annotation cache to bounded cache with LRU eviction policy","## Overview  The annotation cache in `AnnotationUtils` is currently unbounded.  I am considering converting it to a bounded cache with an LRU (least recently used) eviction policy.  ## Deliverables  - [x] Decide if we want to make this change.   - The team decided to remove the caching feature altogether. - [x] Remove annotation cache from `AnnotationUtils`.","closed","component: Platform,","sbrannen","2018-06-07T15:59:40Z","2018-06-22T14:25:37Z"
"","1725","Support File parameters in TempDirectory extension","## Overview  The `TempDirectory` extension is great but only supports `Path`. I think it does not cost much to support `File`, and it enables to get a more fluent code base for several cases where the `Path` API is not yet the first citizen.  ## Deliverables  - [x] Support `File` in addition to `Path` in the `TempDirectory` - [x] Update Javadoc for `TempDirectory` - [x] Update ""The TempDirectory Extension"" section of the User Guide - [x] Document change in the Release Notes","closed","component: Jupiter,","rmannibucau","2019-01-11T07:56:11Z","2019-01-16T16:25:48Z"
"","1690","junit-platform-suite-api should not have a dependency on junit-platform-commons","## Overview  The `junit-platform-suite-api` currently has a direct dependency on `junit-platform-commons` which it does not need.  ## Deliverables  - [x] Remove `junit-platform-suite-api`'s dependency on `junit-platform-commons`.","closed","component: Platform,","sbrannen","2018-11-29T15:46:25Z","2018-11-29T17:25:56Z"
"","1557","Check TestEngine ID for ""junit-"" prefix on registration","## Overview  The `junit-` prefix is owned by the JUnit Team. It's akin to using `org.junit` as a base package. No other entity in the world should do that.  Only two engines should use the prefix at the moment:  * `junit-jupiter` * `junit-vintage`  Source of the discussion: https://github.com/junit-team/junit5/commit/5a44da8c6145611057923a8ae46df540c566fc04#r30200049  ## Deliverables  - [x] Document in the User Guide that the JUnit Team _owns_ the `junit-` prefix for `TestEngine` IDs. - [x] Emit a warning when a `TestEngine` ID starts with `junit-`, except those published by the JUnit Team from the JUnit 5 repository for public consumption. - [x] Create follow-up ticket for ignoring all such _foreign_ engines in a future release of the Platform: #1572","closed","component: Platform,","sormuras","2018-08-20T10:25:20Z","2019-07-19T19:32:26Z"
"","1565","PR: Emit warning when TestEngine ID starts with ""junit-""","## Overview  The `junit-` prefix is owned by the JUnit Team. It's akin to using **""org.junit""** as a base package. No other entity in the world should do that. Only two engines should use the prefix at the moment:   - `junit-jupiter`  - `junit-vintage`  This commit enforces these rules.  Closes #1557  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","sormuras","2018-08-29T09:17:23Z","2018-08-31T14:04:43Z"
"","1646","Set correct class loader in ForkJoinPoolHierarchicalTestExecutorService","## Overview  The `ForkJoinPoolHierarchicalTestExecutorService` uses the default `ForkJoinWorkerThreadFactory` which in turn sets the context classloader to `ClassLoader.getSystemClassLoader()`.  ## Deliverables  - [x] Implement a custom `ForkJoinWorkerThreadFactory` that sets the current context classloader for each new `Thread` instance.","closed","component: Jupiter,","sormuras","2018-10-23T11:16:09Z","2018-11-16T20:31:04Z"
"","1932","Introduce getOrDefault() in ExtensionContext.Store","## Overview  The `ExtensionContext.Store` currently provides convenience methods such as `getOrComputeIfAbsent(...)` for getting a value or storing one if no such value is currently present in the store; however, there is no such convenience method for when you do _not_ want to store the value.  For example, if you are storing a `Boolean` value in the `Store` under a given `key`, an attempt to retrieve it via `store.get(key)` may return `null` or a `Boolean` value. In such situations, it is often desirable to default to `false` if the value is not present in the `Store`. With the status quo, however, you have to implement this as follows.  ```java Boolean flag = store.get(key, Boolean.class); flag = (flag != null && flag); ```  It would be much more convenient to do the following:  ```java boolean flag = store.getOrElse(key, boolean.class, false); // Non-null check is no longer necessary // flag = (flag != null && flag); ```  The proposed `getOrElse(...)` method is analogous to the `getOrDefault(...)` method in `java.util.Map`.  ## Deliverables  - [x] Introduce `getOrElse()` in `ExtensionContext.Store.`","closed","component: Jupiter,","sbrannen","2019-06-15T12:02:12Z","2019-06-20T09:30:09Z"
"","1950","Improve method names for event filtering in the EngineTestKit API","## Overview  The `EngineTestKit` API could be more readable by renaming `EngineExecutionResults` methods to show they are dealing with events. This was discussed in this [comment](https://github.com/joel-costigliola/assertj-core/issues/1418#issuecomment-509002192).   The methods rename suggested are:  - EngineExecutionResults.all() to `allEvents` - EngineExecutionResults.tests() to `testEvents` - EngineExecutionResults.container() to `containerEvents`   ## Deliverables  - [x] Rename methods but keep and deprecate the older version for backward compatibility - [x] Update documentation for all renamed methods","closed","component: Test Kit,","joel-costigliola","2019-07-09T11:28:14Z","2019-07-09T13:05:48Z"
"","1460","AfterAllCallback should not be invoked if exception is thrown by constructor when using @TestInstance(PER_CLASS)","## Overview  The `afterAll(ExtensionContext)` callback method from the `AfterAllCallback` interface is invoked when an exception is thrown in a constructor or static initialization block when using `@TestInstance(Lifecycle.PER_CLASS)`.  However, no other callback methods are invoked. `@BeforeAll` and `@AfterAll` methods are also not executed.  ## Code examples  ### Test Class  ```java @TestInstance(Lifecycle.PER_CLASS) @ExtendWith(LoggerExtension.class) class Example {  	Example() { 		System.out.println(""Constructor""); 		throw new RuntimeException(""Constructor exception""); 	}  	@BeforeAll 	void beforeAll() { 		System.out.println(""@BeforeAll""); 	}  	@AfterAll 	void afterAll() { 		System.out.println(""@AfterAll""); 	}  	@BeforeEach 	void beforeEach() { 		System.out.println(""\t@BeforeEach""); 	}  	@AfterEach 	void afterEach() { 		System.out.println(""\t@AfterEach""); 	}  	@org.junit.jupiter.api.Test 	void exampleTest() { 		System.out.println(""\t\t\t@Test""); 	}  } ```  ### LoggerExtenstion  ```java public class LoggerExtension implements BeforeEachCallback, AfterEachCallback, BeforeAllCallback, AfterAllCallback, 		BeforeTestExecutionCallback, AfterTestExecutionCallback {  	@Override 	public void beforeEach(ExtensionContext context) throws Exception { 		System.out.println(""\tBeforeEachCallback""); 	}  	@Override 	public void afterEach(ExtensionContext context) throws Exception { 		System.out.println(""\tAfterEachCallback""); 	}  	@Override 	public void beforeTestExecution(ExtensionContext context) throws Exception { 		System.out.println(""\t\tBeforeTestExecutionCallback""); 	}  	@Override 	public void afterTestExecution(ExtensionContext context) throws Exception { 		System.out.println(""\t\tAfterTestExecutionCallback""); 	}  	@Override 	public void beforeAll(ExtensionContext context) throws Exception { 		System.out.println(""BeforeAllCallback""); 	}  	@Override 	public void afterAll(ExtensionContext context) throws Exception { 		System.out.println(""AfterAllCallback""); 	}  } ```  ## Actual Behavior  ``` Constructor AfterAllCallback ```  The behavior is the same if `@BeforeAll` and `@AfterAll` are declared as `static`.  ## Expected Behavior  An `AfterAllCallback` should not be invoked unless a `BeforeAllCallback` is invoked, per discussion in [Gitter](https://gitter.im/junit-team/junit5).  ## Related Issues  - #359  ## Deliverables  - [ ] Ensure that `AfterAllCallback`s are **not** invoked if an exception is thrown by the test class constructor when using `@TestInstance(Lifecycle.PER_CLASS)` semantics.","closed","component: Jupiter,","beluha","2018-06-08T08:55:22Z","2018-06-10T11:17:11Z"
"","1654","Allow @TestFactory annotation to be used on static methods","## Overview  The `@TestFactory` annotation is only supported on instance methods.  However, factories are often merely functions.  The limitation of the annotation means that test factories cannot be written with convenient function or property syntax of non-Java JVM languages.  For example, in Kotlin I'd like to do the following, with the Minutest test library:  ```java @TestFactory val tests = junitTests {     test(""a test"") { ... }     ... } ```  In this code, _tests_ is compiled to a static getter.  But because `@TestFactory` is not supported on `static` methods, I have to write a lot of boilerplate code to achieve the same result.  Please allow `@TestFactory` to be used on `static` methods.","closed","status: stale,","npryce","2018-10-30T09:03:39Z","2021-06-03T20:47:27Z"
"","1758","@Execution and @ResourceLock should be @Inherited annotations","## Overview  The `@Execution` and `@ResourceLock` annotations introduced in JUnit Jupiter 5.3 for parallel execution support are not inherited within test class hierarchies, which forces the developer to redeclare such annotations on all affected subclasses.  The absence of `@Inherited` on these class-level annotations was an oversight and should be addressed.  ## Deliverables  - [x] Make `@Execution` and `@ResourceLock` `@Inherited` annotations. - [x] Document fix in Release Notes.","closed","component: Jupiter,","sbrannen","2019-02-02T16:18:13Z","2019-02-02T16:35:44Z"
"","1542","Update JUnit Jupiter Sample Projects section of User Guide","## Overview  The [JUnit Jupiter Sample Projects](https://junit.org/junit5/docs/snapshot/user-guide/#dependency-metadata-junit-jupiter-samples) section of the User Guide currently only references the `junit5-jupiter-starter-gradle` and `junit5-jupiter-starter-maven` projects; whereas, the sample repository now contains considerably more projects.  ## Deliverables  - [x] Update _JUnit Jupiter Sample Projects_ section of User Guide to reference all sample projects (or at least a selected set of highlighted projects)","closed","theme: documentation,","sbrannen","2018-08-12T14:23:33Z","2018-08-20T08:16:28Z"
"","1311","Improve Arguments documentation.","## Overview  That's an API documentation request, and a follow-up to #1307. As was discussed, it's a _non-goal_ of `Arguments` to be easily _consumed_ by the user-code. Therefore, to avoid future confusions, I propose to include such API note in the Javadoc.  ## Deliverables  - [x] Javadoc update","closed","","dmitry-timofeev","2018-02-25T08:23:04Z","2018-02-25T09:11:28Z"
"","1009","Provide AssertionsTestNG to aid migration from TestNG","## Overview  TestNG assertions take the form `assertSomething(actual, expected, [more stuff])`, whereas JUnit assertions take the form `assertSomething(expected, actual, [more stuff])`. To aid migration from JUnit to TestNG, the TestNG project includes [AssertJUnit](https://github.com/cbeust/testng/blob/master/src/main/java/org/testng/AssertJUnit.java).  With the upcoming release of JUnit 5, projects wishing to migrate from TestNG to JUnit 5 would be helped by the existence of a similar facility in JUnit 5.  Discussions among the contributors to [PrestoDB](https://prestodb.io/) indicate an interest in migrating, but nobody is keen to migrate several thousand tests in one go. Having a path for a more gradual migration would be helpful.  ## Deliverables  - [ ] A new AssertionsTestNG class that fills the same role as the existing [Assertions](https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java) class. - [ ] A new test class that asserts that the expected and actual values in AssertionFailedErrors originating from AssertionsTestNG methods are correct. - [ ] Documentation for the AssertionsTestNG class.  ## Related issues  https://github.com/junit-team/junit5/issues/623","closed","component: Jupiter,","ebd2","2017-08-07T18:08:30Z","2019-07-19T19:32:42Z"
"","1795","Test-drive JUnit 5 build on Azure Pipelines","## Overview  Test-drive our build on Azure Pipelines [1].  [1] https://azure.microsoft.com/en-us/services/devops/pipelines/  ## Deliverables  - [x] Add `azure-pipelines.yml` with minimal configuration. - [x] Does it work on Linux? - [x] Does it work on Mac? - [x] Does it work on Windows? - [x] How to configure which JDK is used? - [x] Is OpenJDK-EA supported? - [x] On failing builds, are logs easy to access and scan? - [x] Are Gradle Build Scans still published? - [x] What about speed? - [x] SNAPSHOT deployments: documentation (user-guide, javadoc) and artifacts","closed","theme: build,","sormuras","2019-02-27T07:49:51Z","2019-03-13T03:49:36Z"
"","1594","Support single dynamic node as return type","## Overview  Support single dynamic node as return type of a `@TestFactory`-annotated method.  Closes #1521   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: dynamic tests,","sormuras","2018-09-21T22:49:34Z","2018-09-25T07:57:33Z"
"","1267","Introduce @EnabledIf execution condition","## Overview  Supply a JavaScript script controlling whether the annotated container or test is executed.  Closes #219  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2018-01-26T10:41:59Z","2018-01-27T12:27:22Z"
"","1254","Feature/kotlin fail methods","## Overview  Supersedes #1213   Makes calling `fail` from Kotlin more friendly by adding methods that return [`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html).   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","sormuras","2018-01-20T15:38:33Z","2018-01-20T15:51:15Z"
"","1804","Print junit-platform.properties configuration help","## Overview  Status: proof of concept  Addresses #1803  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2019-03-08T17:02:27Z","2019-07-19T10:29:41Z"
"","1848","[#1091] Modules via `src/modules` directory","## Overview  Solve issue #1091 by introducing module descriptors in dedicated `src/modules` directory.  ## Deliverables  - [x] Make it work from the command line via `jshell`   - [x] `org.junit.jupiter`   - [x] `org.junit.jupiter.api`   - [x] `org.junit.jupiter.engine`   - [x] `org.junit.jupiter.migrationsupport`   - [x] `org.junit.jupiter.params`   - [x] `org.junit.vintage.engine`   - [x] `org.junit.platform.commons`   - [x] `org.junit.platform.console`   - [x] `org.junit.platform.engine`   - [x] `org.junit.platform.launcher`   - [x] `org.junit.platform.reporting`   - [x] `org.junit.platform.runner`   - [x] `org.junit.platform.suite.api`   - [x] `org.junit.platform.testkit` - [x] Integrate it into the Gradle build process - [x] Adopt `platform-tooling-support-tests` to expect explicit modules - similar to https://github.com/junit-team/junit5/pull/1844/commits/3842a3459458fa6992f04f583cacf9618c58f47f  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2019-04-06T05:18:42Z","2019-07-19T19:32:27Z"
"","1423","Add @Solo annotation","## Overview  Situation: I have a test class with 20 @ Test methods. I want to run only 5 of them.  Current options: * Add @ Ignore to the 15 tests and run all the class. * Run only selected tests with special command line options enumerating them. * Make the desired tests fail and rerun only failed in IDE.  Proposal:  Create a @ Solo annotation for test methods. It will serve the same purpose as the ""solo"" option in multitrack audio editing software.  * If you create an audio project and hit no solo/mute, all tracks play.   * If you create a test class with no ignores, all run. * If you hit mute on one or more tracks, all other tracks play except the muted ones.   * If you ignore one or more tests, all other run except the ignored ones. * If you hit solo on one track, only the one selected track plays.   * If you use @ Solo on myTest, only myTest gets run. * If you hit solo on two tracks and mute on three tracks, only the two solo'ed tracks are played.   * If you put @ Solo on myTest1 and myTest2 and ignore three other tests, only myTest1 and myTest2 run.  If at least one test is annotated as @ Solo, others are marked as ignored in IDEs and reports etc.  Example:      public class MyTestClass {         @Test         @Solo         public void thisTestWillRunBecauseAnnotatedAsSolo() {             ...         }          @Test         public void thisTestWillNotRun() {             ...         }          @Test         @Solo         public void thisTestWillAlsoRunBecauseAnnotatedAsSolo() {             ...         }          @Test         public void thisTestWillNotRunToo() {             ...         }     }  ## Deliverables  - [ ] The @ Solo annotation described above.","closed","component: Jupiter,","StaNov","2018-05-17T12:00:39Z","2018-05-17T18:12:16Z"
"","1064","Document optional dependency on apiguardian-api in User Guide","## Overview  Since there are no runtime dependencies on `apiguardian-api`, the focus of this issue has been changed to document that fact in the User Guide.  #1065 will _fix_ the dependency scope in the generated Maven POMs.  ## Original Input from @tyuldashev   Child of [#436 Relocate @API to a stand-alone module](https://github.com/junit-team/junit5/issues/436)  It seems that [""JUnit 5 User Guide"" dependency diagram](http://junit.org/junit5/docs/current/user-guide/#dependency-diagram)  should be updated with dependency of `junit-platform-commons` on `apiguardian-api`.  ## Deliverables  - [x] Document the `optional` dependency on `apiguardian-api` in the _Dependency Metadata_ section of the User Guide. - [x] Add related _global_ note to the release notes in the User Guide.","closed","theme: documentation,","tyuldashev","2017-09-15T11:25:50Z","2017-09-25T19:24:39Z"
"","1344","Update User Guide regarding official Mockito extension","## Overview  Since the Mockito team has released official support for JUnit Jupiter, we should update the User Guide accordingly.  ## Related Issues  - https://github.com/junit-team/junit5-samples/issues/62  ## Deliverables  - [x] Replace references to the `MockitoExtension` from the `junit5-samples` repository with references to the official `MockitoExtension` supplied by the Mockito team and revise content to align with the feature set of the official `MockitoExtension`.","closed","component: Jupiter,","sbrannen","2018-03-27T10:58:31Z","2018-04-19T19:24:34Z"
"","1488","Configure Eclipse test source sets in Gradle build","## Overview  Since Eclipse Photon supports separation of test source sets in the classpath, we should configure that within the Gradle build.  ## Workaround  The following workaround has been proposed by @howlger until Gradle and Buildship properly support the new feature in Eclipse.  ```groovy apply plugin: 'eclipse' eclipse.classpath.file.whenMerged {  	// separate output folders required to set the 'test' attribute 	entries.find { it.path == 'src/main/java' }.output = 'bin/main' 	def testSrc = entries.find { it.path == 'src/test/java' } 	testSrc.output = 'bin/test' 	testSrc.entryAttributes['test'] = 'true'  	// libraries visible for test sources only? 	entries.forEach { entry -> 		def entryIn = { it.find { file(entry.path).equals(it) } } 		if (entry.kind == 'lib') { 			entry.entryAttributes['test'] = 				entryIn(configurations.testRuntimeClasspath) && 				!entryIn(configurations.runtimeClasspath) 		} 	} } ```  ## Related Issues  - [Gradle Issue](https://github.com/gradle/gradle/issues/4802#issuecomment-396165166) - [Buildship Issue](https://github.com/eclipse/buildship/issues/689)  ## Deliverables  - [ ] Configure test source sets in the Eclipse classpath. - [ ] Update [contributor guidelines](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md) to suggest the use of Eclipse Photon.","closed","status: stale,","sbrannen","2018-07-04T09:51:03Z","2021-06-19T12:50:31Z"
"","1319","Meta-annotate @Enabled*/@Disabled* with @Test","## Overview  Since all of `@Enabled*`/`@Disabled*` are used on `@Test` methods, meta-annotate them with `@Test` prevents forgetting `@Test` annotation on target test methods.  Also, added tests for `@Enabled*` without `@Test` annotation. Couldn't come up with good test for `@Disabled*`...  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","ttddyy","2018-03-04T01:37:58Z","2018-03-04T18:46:08Z"
"","1637","Introduce @NullSource, @EmptySource, & @NullAndEmptySource for parameterized tests","## Overview  Similar to #1635, I stumbled upon a situation where I need to validate `null` in parameterized test.  ```java @ParameterizedTest @ValueSource(strings = { ""wrong-input"", """", "" "" }) void wrongInput(String input) {   ... } ```  It is certainly convenient to have a way of testing `null` use case without creating a custom provider or another test method just for `null`.  ## Original Proposal  How about adding a flag attribute to `@ValueSource` annotation such as `testNull`, `checkNull`, etc.  ```java @ParameterizedTest @ValueSource(strings = { ""wrong-input"", """", "" "" }, testNull=true) void wrongInput(String input) {   ... } ```  ## Related Issues  - Supersedes #1635   ## Deliverables  - [x] Introduce `@NullSource` that provides `null` for any reference type and throws an exception for any primitive target type. - [x] Introduce `@EmptySource` that provides an _empty_ object for supported types and throws an exception for unsupported types.   - Initial supported types: `String`, `List`, `Set`, `Map`, and arrays of any type. - [x] Introduce `@NullAndEmptySource` _composed annotation_ that combines `@NullSource` and `@EmptySource`. - [x] Document in User Guide. - [x] Document in Release Notes.","closed","type: new feature,","ttddyy","2018-10-16T20:29:49Z","2019-01-06T14:23:18Z"
"","1336","Vintage filtering is not compatible with JUnitParamsRunner","## Overview  Seems like Vintage filtering is not compatible with the [JUnitParamsRunner](https://github.com/Pragmatists/JUnitParams).   Step to reproduce:  - Add dependency `compile 'pl.pragmatists:JUnitParams:1.1.1'`  ```java import junitparams.*; import org.junit.platform.engine.*; import org.junit.platform.engine.discovery.*; import org.junit.platform.launcher.*; import org.junit.platform.launcher.core.*; import org.junit.runner.RunWith; import org.junit.Test;  public class VintageJUnitParams {     public static void main(String[] args) {         Launcher launcher = LauncherFactory.create();          LauncherDiscoveryRequestBuilder requestBuilder = LauncherDiscoveryRequestBuilder.request()                 .selectors(DiscoverySelectors.selectClass(PersonTest.class))                 .filters((PostDiscoveryFilter) descriptor -> {                     System.out.println(""Exclude: "" + descriptor.getUniqueId());                     return FilterResult.excluded(""excluded"");                 });         launcher.execute(requestBuilder.build());     }      @RunWith(JUnitParamsRunner.class)     public static class PersonTest {         @Test         @Parameters({""17, false"", ""22, true""})         public void personIsAdult(int age, boolean valid) throws Exception {             System.out.println(""This shouldn't be run!"");         }     } } ```  The tests are still executed even I exclude them in the filter. I do observe the warning `WARNING: Runner junitparams.JUnitParamsRunner (used on class VintageJUnitParams$PersonTest) was not able to satisfy all filter requests.` so I'm not sure if this is expected behavior.  Vintage version: `5.1.0`","closed","component: Vintage,","blindpirate","2018-03-20T02:23:07Z","2020-07-25T11:22:26Z"
"","1232","Introduce implicit argument conversion for UUID, URL, BigDecimal, BigInteger, File​, Path, Charset","## Overview  See original intent of #1231.  ## Related Issues  - #1218  - #1231   ## Deliverables  - [x] Introduce implicit argument conversion for `java.util.UUID`, `java.net.URL`, `java.math.BigDecimal`, `java.math.BigInteger`, and `java.io.File​` for parameterized tests. - [x] Document in Release Notes. - [x] Document in User Guide.","closed","component: Jupiter,","sbrannen","2018-01-07T14:39:12Z","2018-01-09T14:53:32Z"
"","1581","Upgrade to opentest4j 1.1.1","## Overview  See opentest4j [1.1.1 milestone](https://github.com/ota4j-team/opentest4j/milestone/5).  ## Deliverables  - [x] Upgrade to opentest4j 1.1.1 - [x] Document change in the Release Notes","closed","type: task,","sbrannen","2018-09-10T14:17:16Z","2018-09-11T05:26:26Z"
"","1035","Set final 5.0 GA values of all @API annotations","## Overview  See new compiled list at https://github.com/junit-team/junit5/pull/1035#issuecomment-325956395  **`@API(Stable)`**  - [x] jupiter test annotations, including currently maintained ones (except TestFactory) - [x] JUnitPlatform (runner) - [x] Assertions/Assumptions - [x] RepetitionInfo, TestInfo, TestReporter - [x] org.junit.jupiter.api.extension - [x] org.junit.jupiter.engine.Constants - [x] org.junit.platform.engine (hierarchical) - [x] org.junit.platform.launcher & .core   **`@API(Maintained)`**  - [x] suite api - [x] org.junit.platform.engine.support.hierarchical - [x] org.junit.platform.launcher.listeners  **`@API(Experimental)`**  - [x] DynamicContainer/… and TestFactory - [x] params (some are internal)  **`@API(Internal)`**  - [x] API - [x] JupiterTestEngine, VintageTestEngine (final) - [x] ClasspathScanningSupport  Closes #856  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","component: Vintage,","sormuras","2017-08-30T06:49:25Z","2017-08-31T15:52:14Z"
"","1754","Support @TempDir on constructor parameters","## Overview  See https://github.com/junit-team/junit5/issues/1748#issuecomment-457612952  I've started to use this feature and I miss constructor injection quite a lot. Being able to inject the directory and then creating my tester as a final field was quite what I was looking for.   I've moved that code to `@BeforeEach` but that's yet another annotation I have to add for no good reason. I actually don't need to create the tester for every test but I don't want to flag the tester static.  ## Related Issues  - #1748  - #1752","closed","status: stale,","snicoll","2019-01-28T14:10:43Z","2021-06-19T12:50:33Z"
"","1068","Publish release notes as separate document","## Overview  See discussions in #1066 for further information.  ## Related Issues  - #1066  ## Deliverables  - [x] Publish the current _release notes_ chapter of the User Guide as a separate document and link to it from the User Guide. - [x] Ensure that all existing links from the new Release Notes document to the User Guide are functional.","closed","theme: documentation,","sbrannen","2017-09-17T16:43:31Z","2018-01-24T11:24:07Z"
"","1083","Log class loading errors during classpath scanning at DEBUG level","## Overview  See discussion in #1082 for details.  ## Deliverables  - [x] Log ""Malformed class name"" exceptions during classpath scanning at `DEBUG` level.","closed","component: Platform,","sbrannen","2017-09-29T14:38:54Z","2018-01-14T11:35:04Z"
"","1183","Document support for JUnit 4 categories as tags in User Guide","## Overview  See discussion here: https://github.com/junit-team/junit5/issues/1160#issuecomment-344840875  ## Deliverables  - [x] Document support for JUnit 4 categories as tags in User Guide","closed","theme: discovery,","sbrannen","2017-11-24T14:03:28Z","2018-01-12T13:24:11Z"
"","1247","Introduce a TemporaryFolder extension","## Overview  See discussion at https://github.com/junit-team/junit5-samples/issues/4.  ### Related Issues  - #219  ## Deliverables  - [X] ~Introduce an official `TemporaryFolder` extension for JUnit Jupiter analogous to the rule support in JUnit 4.~","closed","type: new feature,","sbrannen","2018-01-18T14:44:07Z","2018-11-30T21:52:29Z"
"","1830","Improve documentation for modular testing","## Overview  Sample module descriptor: `src/test/java/module-info.java` ```java open module test {    // Read exported JUnit Jupiter API   requires org.junit.jupiter.api;    // Prevent ""unknown enum constant Status.STABLE"" + ""org.apiguardian.api.API$Status not found"" warnings   requires org.apiguardian.api;    // Prevent ""org.opentest4j.TestAbortedException not found"" when using `Assumptions`   requires org.opentest4j; } ```","closed","status: stale,","sormuras","2019-03-23T06:54:29Z","2021-06-19T12:50:34Z"
"","1096","JUnit 5 does not report test when run with maven surefire and console logging is enabled","## Overview  Running a JUnit 5 test together with maven surefire plugin does not report the test correctly if console logs are enabled. I use Maven 3.5.  Test class:  ```java import org.junit.jupiter.api.Test; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class TestLogs {  	private static final Logger logger = LoggerFactory.getLogger(TestLogs.class);  	@Test 	void test(){ 		boolean log = true; 		if (log) { 			logger.warn(""Log""); 		} 	} } ```  Output:  ``` [INFO] --- maven-surefire-plugin:2.19.1:test (default-test) @ test ---  -------------------------------------------------------  T E S T S ------------------------------------------------------- Running TestLogs 2017-10-06 12:22:57.650 WARN  [main] [TestLogs-13] - Log 6,1,TestLogs,test(),null,null,null Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.307 sec - in TestLogs  Results :  Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  If `log = false` the result is correct:  ``` [INFO] --- maven-surefire-plugin:2.19.1:test (default-test) @ test ---  -------------------------------------------------------  T E S T S ------------------------------------------------------- Running TestLogs Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.299 sec - in TestLogs  Results :  Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 ``` Pom:  ```xml   	4.0.0  	com.test 	test 	1.0-SNAPSHOT  	jar 	 		5.0.0 		1.0.0 		2.9.1 	  	 		 			org.apache.logging.log4j 			log4j-api 			${log4j2.version} 		 		 			org.apache.logging.log4j 			log4j-core 			${log4j2.version} 		 		 			org.apache.logging.log4j 			log4j-slf4j-impl 			${log4j2.version} 		 		 			org.junit.jupiter 			junit-jupiter-api 			${junit.jupiter.version} 			test 		 		 			org.junit.jupiter 			junit-jupiter-engine 			${junit.jupiter.version} 			test 		 	  	 		 			 				org.apache.maven.plugins 				maven-surefire-plugin 				2.19.1 				 					 						org.junit.platform 						junit-platform-surefire-provider 						${junit.platform.version} 					 					 						org.junit.jupiter 						junit-jupiter-engine 						${junit.jupiter.version} 					 				 			 		 	  ```","closed","theme: reporting,","sdecoppet","2017-10-06T10:37:50Z","2018-01-12T13:28:20Z"
"","1120","Rollback to Surefire 2.19.1","## Overview  Rollback to Surefire 2.19.1 because 2.20.1 does not work on Java 9.  ## Deliverables  - [x] Rollback to Surefire 2.19.1 in junit-platform-surefire-provider","closed","3rd-party: Maven Surefire,","marcphilipp","2017-10-19T19:12:08Z","2018-03-12T14:13:05Z"
"","1411","Add ability to use datasource in class with @Nested Tests","## Overview  Right now tests located in a `@Nested` class run only after tests in enclosing classes have finished their execution. Such behavior doesn't allow one to run test classes with different values.  If we run the following test class:  ```java public class StackTest {     static int number;      @ParameterizedTest     @ValueSource(ints = {1, 2, 3, 4})     @DisplayName(""is instantiated with new Stack()"")     void isInstantiatedWithNew(int numbers) {         number = numbers;     }      @Nested     @DisplayName(""when new"")     class WhenNew {          @Test         @DisplayName(""is empty"")         void isEmpty() {             System.out.println(""Is empty: "" + number);             assertTrue(true);         }          @Nested         @DisplayName(""after pushing an element"")         class AfterPushing {              @Test             @DisplayName(""it is no longer empty"")             void isNotEmpty() {                 System.out.println(""is not empty: "" + number);                 assertTrue(true);             }         }     } } ```  ... we will see that all nested tests received only the last number (4).  Is there any way to send all provided numbers to nested tests?  ## Related Issues  - #871  - #878","closed","component: Jupiter,","kiryl-naurotski","2018-05-08T13:07:33Z","2018-05-08T13:28:16Z"
"","1631","Remove reference cycles from 'junit-jupiter-engine'","## Overview  Remove reference cycles from `junit-jupiter-engine` by declaring constants in types residing in sub-packages and only refer those constants in the top-level `org.junit.jupiter.engine.Constants` class.  Addresses: #1626  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2018-10-11T09:00:36Z","2018-10-11T15:23:14Z"
"","1097","Build with JDK-9 only","## Overview  Remove JDK build matrix on Travis CI and use `--release 8` javac option.  The JUnit 5 build requires JDK-9 or higher. The JUnit 5 runtime environment needs to be Java 8 or higher.  Travis CI now sets ""-Xmx"" by default.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2017-10-08T14:17:08Z","2017-10-09T07:59:38Z"
"","1039","Refactor VintageDiscoverer","## Overview  Refactoring of the discovery. IMHO easier to understand because it has less abstractions.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","stefanbirkner","2017-08-31T06:58:37Z","2018-01-12T13:41:42Z"
"","1044","Remove Class-Path attribute from standalone JAR manifest","## Overview  RC3 ships the `junit-platform-console-standalone-1.0.0-RC3.jar` with the following `META-INF/MANIFEST.MF` file:  ``` Manifest-Version: 1.0 Implementation-Title: junit-platform-console-standalone Build-Date: 2017-08-23 Implementation-Version: 1.0.0-RC3 Built-By: JUnit Team Specification-Vendor: junit.org Specification-Title: junit-platform-console-standalone Class-Path: junit-platform-console-1.0.0-RC3.jar junit-jupiter-engine-  5.0.0-RC3.jar junit-jupiter-params-5.0.0-RC3.jar junit-vintage-engine  -4.12.0-RC3.jar junit-platform-launcher-1.0.0-RC3.jar junit-platform-  engine-1.0.0-RC3.jar junit-jupiter-api-5.0.0-RC3.jar junit-4.12.jar j  unit-platform-commons-1.0.0-RC3.jar opentest4j-1.0.0-RC1.jar hamcrest  -core-1.3.jar Implementation-Vendor: junit.org Main-Class: org.junit.platform.console.ConsoleLauncher Build-Revision: e0af182b1440da44af16a7181cd3b03d1a3fe82d Build-Time: 20:40:28.393+0200 Engine-Version-junit-vintage: 4.12.0-RC3 Created-By: 1.8.0_131 (Oracle Corporation 25.131-b11) Specification-Version: 1.0.0 Engine-Version-junit-jupiter: 5.0.0-RC3 ```  The `Class-Path` attribute refers to all jars that are shadowed into this standalone artifact. Therefore the `Class-Path` attribute should be removed from the manifest file.  ## Deliverables  - [x] Configure the Gradle jar task to exclude any class-path entry.","closed","theme: build,","sormuras","2017-09-05T15:29:29Z","2018-04-23T12:04:51Z"
"","1197","Introduce method getConfigurationParameter() in ExtensionContext","## Overview  Provide access to configuration parameters via adding method `Optional getConfigurationParameter(String key)` to interface `ExtensionContext`.  Closes #1196  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2017-12-04T20:46:13Z","2017-12-23T14:20:00Z"
"","1006","Introduce support for class-scoped parameters","## Overview  Provide a way to have values injected into a class that are created once before any test methods are created.  If your test class has constructor with a parameter annotated with `@PerClass`, then JUnit Jupiter will create it once per run of the test class, using the default constructor of the class (in Kotlin, the primary constructor). That class can have non-static methods annotated with `@BeforeAll`, `@AfterAll`, `@BeforeEach`, or `@AfterEach`.  Here's an example of a class that creates a local database:  ```java     @PerClass     public class Database {         @BeforeAll void createDatabase() {         }           @AfterAll void dropDatabase() {         }          @BeforeEach void clearDatabase() {         }          public void insert(long id, Account) }{        }     }      class DatabaseTestCase {       private final Database db;        DatabaseTestCase(@PerClass Database db) {         this.db = db;       }        @Test       public void insertAccount() {         Account account = ...         db.insert(1, account);         ...       }     } ```  You could think of this as a better version of JUnit4's `ExternalResource` rule.  This could also be used to support `@BeforeAll` in Kotlin tests  ```kt     class SimpleKotlinTestCase constructor(@PerClass db: Database) {       class Database {         @BeforeAll fun createDatabase() {         }           @AfterAll fun dropDatabase() {         }          @BeforeEach fun clearDatabase() {         }          fun insert(id: Int, account: Account) {         }       }        @Test       fun insertAccount() {         val account = ...         db.insert(1, account);         ...       }     } ```  This could also be used to support integration tests.  ## Deliverables  - [ ] ?","closed","status: stale,","kcooney","2017-08-05T02:54:31Z","2021-06-03T22:11:39Z"
"","1926","Add a @Timeout example for 'poll until' logic","## Overview  Proposing a pattern using @Timeout for ""wait until"" like tests.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","rmannibucau","2019-06-12T13:45:35Z","2019-06-30T14:12:33Z"
"","1330","[WIP] Introduce DynamicTest Builder","## Overview  Proof-of-concept and work-in-progress...  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2018-03-16T15:51:30Z","2019-07-19T19:32:24Z"
"","1719","Use fully-qualified class name as legacy reporting name for Vintage tests","## Overview  Prior to this PR VintageTestDescriptor was always using displayName for legacy reporting purposes. As a result of #1475 displayName for vintage tests was updated to be the simple class name which in turn affected test reports that are based on legacy reporting name. This PR updates VintageTestDescriptor to use fully-qualified class name for legacy reporting if that is available.  For example:  Running following vintage tests org.example.third.TestClassOneTest, org.example.second.TestClassOneTest, org.example.first.TestClassOneTest  started to produce the following output:  ``` [INFO] --- maven-surefire-plugin:2.22.1:test (default-test) @ example --- [INFO] [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running TestClassOneTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.003 s - in TestClassOneTest [INFO] Running TestClassOneTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in TestClassOneTest [INFO] Running TestClassOneTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in TestClassOneTest ``` and produces surefire report files: ``` TestClassOneTest.txt TEST-TestClassOneTest.xml ``` With proposed changes output will look like:  ``` [INFO] --- maven-surefire-plugin:2.22.1:test (default-test) @ example --- [INFO] [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running org.example.third.TestClassOneTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.003 s - in org.example.third.TestClassOneTest [INFO] Running org.example.second.TestClassOneTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in org.example.second.TestClassOneTest [INFO] Running org.example.first.TestClassOneTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in org.example.first.TestClassOneTest ```  and will produce following surefire reports: ``` org.example.first.TestClassOneTest.txt org.example.second.TestClassOneTest.txt org.example.third.TestClassOneTest.txt TEST-org.example.first.TestClassOneTest.xml TEST-org.example.second.TestClassOneTest.xml TEST-org.example.third.TestClassOneTest.xml ``` ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","MishaDemianenko","2019-01-04T12:46:30Z","2019-07-19T19:32:27Z"
"","1078","Introduce ClassFilter, an internal predicate wrapper","## Overview  Prior to this PR many methods in classes and interfaces of package `org.junit.platform.commons.util` were using the two parameters `classNameFilter` and `classTester` in their signatures their like:      ..., Predicate> classTester, Predicate classNameFilter, ...  These two parameters can now be put into a ClassFilter instance. This will reduce many method signature parts down to      ..., ClassFilter classFilter, ...  and provides a future-proof way of extending the class filter implementation without changing the method signatures again.  Closes #1077   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - Non-public change is **not** documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2017-09-27T18:44:01Z","2017-09-29T10:44:58Z"
"","1861","Add assertLinesMatch overloads taking a custom message","## Overview  Prior to this commit, `Assertions.assertLinesMatch` was the only assertion that didn't support user-supplied error messages. This commit adds overloads that take a String or Supplier as a custom message. That message is prepended to the automatically generated detail message.  This commit also improves the textual layout of the automatically generated detail message by emitting each expected and actual line into a dedicated new line.  Closes #1855  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2019-04-13T13:42:56Z","2019-05-13T07:19:38Z"
"","1610","Publish documentation snapshot only if necessary","## Overview  Prior to this commit the current documentation sources were always compiled, built, prepared, and published even if nothing was edited.  Now, the file `published-checksum.txt` containing a checksum for each documentation source asset is used to determine if a build and publish is necessary. It will show up here: https://github.com/junit-team/junit5/tree/gh-pages/docs/snapshot  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: documentation,","sormuras","2018-09-29T12:54:47Z","2018-09-29T16:21:33Z"
"","1647","Set context class loader parallel execution mode","## Overview  Prior to this commit the `ForkJoinPoolHierarchicalTestExecutorService` used the default `ForkJoinWorkerThreadFactory` which in turn sets the context class loader to `ClassLoader.getSystemClassLoader()`. In runtime environments that create and use a tailored context class loader this leads to `ClassNotFoundException` when only the `ClassLoader.getSystemClassLoader()` is available.  Now the `ForkJoinPoolHierarchicalTestExecutorService` creates `ForkJoinWorkerThread` instances that set the context class loader to the one available at creation time of the service.  Fixes #1646  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2018-10-23T14:44:59Z","2018-11-20T12:19:44Z"
"","968","Remove deprecated execute method from Launcher","## Overview  Prior to this commit the `execute(LauncherDiscoveryRequest)` method was temporarily available to restore binary compatibility with external tools using it.  Now the method is removed. External tools are now forced to recompile against the new SNAPSHOT version of the JUnit Platform.  Closes #740  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2017-07-20T13:02:15Z","2017-07-20T21:55:58Z"
"","1204","Print initial lines of failure stack traces","## Overview  Prior to this commit only the ""toString()"" representation of the failure throwable was printed.  Now some of the initial stack trace lines are printed by the console launcher to better describe the location of the failure.  Closes #1203  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2017-12-11T22:07:40Z","2017-12-23T13:42:48Z"
"","1734","Replace ISO control characters in display names","## Overview  Prior to this commit new line and other ISO control characters disrupted the layout of the tree-based test plan rendering emitted by the console launcher. Now, all ISO control characters found in display names are replaced by a single dot: '.'  Closes #1713  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2019-01-16T11:02:45Z","2019-01-21T18:17:33Z"
"","1185","Introduce Details.SUMMARY and mute output in mode NONE","## Overview  Prior to this commit a summary table of counts was printed even when the details mode `Details.NONE` was passed to the console launcher. Now, when mode `Details.NONE` is selected, nothing is printed. Unless a failure was recorded.  The new `Details.SUMMARY` mode prints the same output that was printed before when `Details.NONE` was selected.  Closes #1179  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Gradle,","sormuras","2017-11-24T21:26:38Z","2018-01-15T11:33:21Z"
"","1316","Emit helpful message when a configuration key is not unique","## Overview  Prior to this commit a bug [1] in Java 8's stream toMap() collector did report the value instead of the duplicated key in the exception message.   Now, a custom list-to-map helper always emits a helpful error message.  [1] https://bugs.openjdk.java.net/browse/JDK-8040892  Closes #1308  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2018-02-27T22:13:28Z","2018-02-28T07:25:18Z"
"","1837","Fix regression when creating human-readable test names","## Overview  Prior to this commit `Arrays.copyOf()` was used without specifying the resulting array type in order to create a human-readable names for parameterized tests. Now, type `Object[]` is passed as an argument to ensure the resulting array may contain any valid instance, here an instance of `String`.  Fixes #1836  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","sormuras","2019-03-27T10:17:42Z","2019-03-29T13:24:34Z"
"","1451","Ensure discovered descriptor graphs are acyclic","## Overview  Prior this commit only a null-check was performed by the `DefaultLauncher` against the root test descriptor returned by an engine. Other properties where not checked, especially if the graph of that root descriptor contained cycles it could lead to stack overflow errors when traversing the graph for execution.  This commit addresses this issue by explicitly checking the returned graph of the root test descriptor for cycles. If a cycle is detected a `PreconditionViolationException` is thrown.  Fixes: #1447","closed","theme: discovery,","sormuras","2018-06-05T15:51:35Z","2018-06-08T10:56:24Z"
"","1005","Make ExtensionValuesStore concurrent.","## Overview  Previously, the class was holding a lock while calling the function passed to getOrComputeIfAbsent(), which can cause problems if the function is slow or blocks. In addition, the coarse-grained locks make the class more prone to contentions when the Store is accessed from multiple threads.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","kcooney","2017-08-05T02:30:04Z","2017-09-09T07:07:38Z"
"","1256","Fix incorrect link text in User Guide","## Overview  Please describe your changes here and list any open questions you might have.  Fix incorrect link in documentation.  `org.junit.jupiter.Assertions` -> `org.junit.jupiter.api.Assertions` `org.junit.jupiter.Assumptions` -> `org.junit.jupiter.api.Assumptions`  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","blindpirate","2018-01-22T09:17:31Z","2018-01-22T14:20:37Z"
"","1553","PR: Update JUnit Jupiter Sample Projects section of User Guide","## Overview  Please describe your changes here and list any open questions you might have.  1. I added kotlin, ant and groovy projects to the JUnit Jupiter Sample Projects section. 2 files were changed.   2. Let me know if more changes needs to be done.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","sricheta92","2018-08-19T04:25:46Z","2018-08-31T14:03:25Z"
"","1329","Adding new speakers and events","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","wkorando","2018-03-16T14:47:35Z","2018-03-16T14:56:11Z"
"","1410","Upgrade to fast-classpath-scanner 2.20","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","tbence12","2018-05-06T12:07:09Z","2018-05-07T15:58:02Z"
"","1398","Create release note template for 5.3.0-M1","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","gaganis","2018-05-01T08:06:27Z","2018-05-02T16:16:29Z"
"","1390","Update gradle.properties","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","tbence12","2018-04-24T15:13:10Z","2018-04-26T17:29:28Z"
"","1328","Include talk in MadridJUG (Java User Group) by Boni Garcia on 16.01.2018","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","bonigarcia","2018-03-16T11:14:00Z","2018-03-16T12:58:34Z"
"","1321","Codecov","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","PFosterSr","2018-03-05T23:03:53Z","2018-03-06T16:24:56Z"
"","1915","Session OC1 2019","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","svenruppert","2019-06-05T08:31:05Z","2019-06-05T08:34:54Z"
"","1834","ghpages: added hamburg event next week","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","dpreussler","2019-03-25T21:47:51Z","2019-03-26T06:56:14Z"
"","1639","Marc/travis/parallel","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","rusbridger","2018-10-19T03:02:25Z","2019-04-14T13:06:30Z"
"","1343","JUnit Jupiter @Nested tests do not run when selecting enclosing class with Surefire","## Overview  Per Marc Philipp's request on Stack Overflow:  I'm trying to use JUnit Jupiter in my side project as a trial before migrating my main project. I'd like to use `@Nested` tests to make my test classes cleaner.  Everything is fine when I ran my test suite as a whole. However, as soon as I try running just a single test, `@Nested` ones are not executed.  ``` mvn -Dtest=com.mycompany.test.MyTest surefire:test ```  Using JUnit 5.1.0, JUnit platform 1.1.0  ```xml        org.apache.maven.plugins     maven-surefire-plugin     2.19.1                     org.junit.platform         junit-platform-surefire-provider         ${org.junit.platform.version}                       org.junit.jupiter         junit-jupiter-engine         ${org.junit.version}                  ```  Test class:  ``` java public class MyTest {    @Test   public void thisTestExecutes() { }    @Nested   public class NestedTests {     @Test     public void thisTestDoesnt() { }   } } ```  ## Related Issues  - #1377  - #1378","closed","3rd-party: Maven Surefire,","mwiercin","2018-03-26T08:15:56Z","2019-02-01T17:01:33Z"
"","1723","Use Tocbot for dynamic table of contents in User Guide","## Overview  Over time the amount of content in the User Guide grows and grows. Consequently, it becomes harder to actually _navigate_ the User Guide.  In order not to overwhelm the reader but simultaneously provide enough contextual information for ""where you currently are"" within the User Guide, it would be beneficial to integrate [Tocbot](https://tscanlin.github.io/tocbot/) in the JUnit 5 User Guide.  Tocbot can be integrated into Asciidoctor analogous to how the Spring Framework did in https://github.com/spring-projects/spring-framework/commit/ee3913c6d0e092ba798fb9fb4fc1d758b8692e36. Note, however, that some of the files in that initial commit have been modified over time.  To see the result of the Tocbot integration into Spring's Reference Manual, take a look at the [Testing chapter](https://docs.spring.io/spring/docs/5.1.4.RELEASE/spring-framework-reference/testing.html#testing).  ## Related Issues  - https://github.com/asciidoctor/asciidoctor/issues/699  ## Deliverables  - [x] Integrate Tocbot in the User Guide.","closed","theme: documentation,","sbrannen","2019-01-08T18:43:11Z","2019-01-27T14:55:45Z"
"","1436","Searching for nested test classes fails if class file format is invalid","## Overview  Original issue title: _Test discovery fails when encountering invalid reference in InnerClasses attribute of class file_  The following test written in Groovy and run with JUnit 5.2.0, JUnit platform 1.2.0 results in the exception below and no tests found.  The same test, annotated with org.junit.Test and run with JUnit 4.12 successfully runs the test named foo.  I think the desirable behaviour is to log the warning as below but still continue with test discovery and run what tests are found, as JUnit 4 does.  ```groovy package tests  import org.junit.jupiter.api.Test  class GroovyInnerClassFailure {     @Test     void foo() {     }      interface Foo {     } } ```  Causes the following error: ``` May 29, 2018 9:46:36 AM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests java.lang.NoClassDefFoundError: tests/GroovyInnerClassFailure$Foo$1 	at java.lang.Class.getDeclaredClasses0(Native Method) 	at java.lang.Class.getDeclaredClasses(Class.java:1867) 	at org.junit.platform.commons.util.ReflectionUtils.findNestedClasses(ReflectionUtils.java:787) 	at org.junit.platform.commons.util.ReflectionUtils.findNestedClasses(ReflectionUtils.java:777) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveContainedNestedClasses(JavaElementsResolver.java:183) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveChildren(JavaElementsResolver.java:178) 	at java.lang.Iterable.forEach(Iterable.java:75) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveClass(JavaElementsResolver.java:61) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolve$3(DiscoverySelectorResolver.java:69) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolve(DiscoverySelectorResolver.java:68) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:50) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:61) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:82) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:52) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.ClassNotFoundException: tests.GroovyInnerClassFailure$Foo$1 	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 	... 20 more  May 29, 2018 9:46:36 AM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests java.lang.NoClassDefFoundError: tests/GroovyInnerClassFailure$Foo$1 	at java.lang.Class.getDeclaredClasses0(Native Method) 	at java.lang.Class.getDeclaredClasses(Class.java:1867) 	at org.junit.platform.commons.util.ReflectionUtils.findNestedClasses(ReflectionUtils.java:787) 	at org.junit.platform.commons.util.ReflectionUtils.findNestedClasses(ReflectionUtils.java:777) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveContainedNestedClasses(JavaElementsResolver.java:183) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveChildren(JavaElementsResolver.java:178) 	at java.lang.Iterable.forEach(Iterable.java:75) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveClass(JavaElementsResolver.java:61) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolve$3(DiscoverySelectorResolver.java:69) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolve(DiscoverySelectorResolver.java:68) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:50) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:61) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ```  The cause seems to be an erroneous reference to an undefined class in the InnerClasses attribute of the class file generated by the groovy compiler. I've logged this as https://issues.apache.org/jira/browse/GROOVY-8614  ``` $ javap -v -cp out/production/classes/ tests.GroovyInnerClassFailure ... SourceFile: ""GroovyInnerClassFailure.groovy"" InnerClasses:      public #142= #141 of #2; //Foo=class tests/GroovyInnerClassFailure$Foo of class tests/GroovyInnerClassFailure      static #145= #144 of #2; //1=class tests/GroovyInnerClassFailure$Foo$1 of class tests/GroovyInnerClassFailure ```  ## Related Issues  - #1438","closed","component: Platform,","tonyabbott","2018-05-29T08:08:21Z","2018-06-03T14:55:16Z"
"","1040","Use ArrayList instead of LinkedList","## Overview  Motivated by the discussion here https://github.com/junit-team/junit5/pull/1039#discussion_r136281377 this PR replaces `LinkedList` usages with `ArrayList` where appropriate.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","sormuras","2017-08-31T10:34:59Z","2017-08-31T16:23:03Z"
"","1144","Add ClassUtils.nullSafeToString to support package","## Overview  Most third-party test engines that allow test methods with parameters will probably  need `ClassUtils.nullSafeToString(classes)` or something similar to create their unique IDs.  That's why I suggest that you create `ClassSupport.nullSafeToString(Class... classes)` and delegate to ClassUtils.","closed","component: Platform,","jlink","2017-11-05T12:36:39Z","2017-11-11T21:55:05Z"
"","1642","Do not throw NPE in assertLinesMatch() if actualLine is null","## Overview  Modified AssertLInesMatch to not throw a NullPointerException when expected has more results than actual after the fast forward matches.  Added to the unit test class to demonstrate the change is fixed.  Also updated the release notes for 5.4.0-M1.  Fixes: #1640   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","jimmorgan","2018-10-20T13:04:46Z","2018-11-20T12:18:18Z"
"","1862","Convert methods in TestWatcher API to default methods","## Overview  Methods in the `TestWatcher` API are currently abstract thereby forcing developers to implement all methods even if all events are not needed by the extension implementing the API.  ## Deliverables  - [x] Convert methods in the `TestWatcher` API to default methods. - [x] Document in the Release Notes.","closed","component: Jupiter,","sbrannen","2019-04-13T15:40:23Z","2019-04-13T16:00:41Z"
"","1186","Ignore annotations when looking for test classes","## Overview  Maven currently spits out a warning when an annotation name ends with ""Test"" -- for example, @interface JimfsTest.","closed","","zack-harrison","2017-11-25T11:54:20Z","2017-11-25T12:47:47Z"
"","1077","Introduce ClassFilter for use in reflection utilities","## Overview  Many methods in classes and interfaces of package `org.junit.platform.commons.util` are using the two parameters `classNameFilter `and `classTester` in their signature their like: ``` T method(... Predicate> classTester, Predicate classNameFilter, ...) ``` In most cases the actual values are just passed down the call-stack.  This issue proposes to introduce a wrapper named `ClassFilter` or `ClassTester` that could look like:  ```java @API(status = INTERNAL, since = ""1.1"") public class ClassFilter {  	public static ClassFilter of(Predicate> classPredicate, Predicate namePredicate) { 		Preconditions.notNull(classPredicate, ""class predicate must not be null""); 		Preconditions.notNull(namePredicate, ""name predicate must not be null"");  		return new ClassFilter(classPredicate, namePredicate); 	}  	private final Predicate> classPredicate; 	private final Predicate namePredicate;  	private ClassFilter(Predicate> classPredicate, Predicate namePredicate) { 		this.classPredicate = classPredicate; 		this.namePredicate = namePredicate; 	}  	public boolean test(Class type) { 		return classPredicate.test(type); 	}  	public boolean test(String name) { 		return namePredicate.test(name); 	} } ```  With such a type, the internal method signature will reduce to: ``` T method(... ClassTester classTester, ...) ``` and if we ever need to add another predicate, it can be done in the wrapper type w/o changing the signature of the internal methods.  ## Deliverables  - [x] Refactor internal methods to use the new class tester wrapper type","closed","component: Platform,","sormuras","2017-09-27T11:29:23Z","2019-07-19T19:32:44Z"
"","1652","Release JUnit 5.3.2","## Overview  List of fixed bugs since release 5.3.1 so far: https://github.com/junit-team/junit5/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22type%3A+bug%22+milestone%3A%225.4+M1%22+  ## Deliverables  - [x] Create 5.3.2 Milestone on GitHub. - [x] Move bug fix issues to 5.3.2 Milestone. - [x] Backport bug fixes to `5.3.x` branch.    - [x] #1591    - [x] #1600    - [x] #1603    - [x] #1640    - [x] #1643    - [x] #1646    - [x] #1665    - [x] #1666 - [x] Create `release-notes-5.3.2.adoc` based on entries in `release-notes-5.4.0-M1.adoc`. - [x] Copy release note _polishing_ from `release-notes-5.4.0-M1.adoc` on `master` into `release-notes-5.3.2.adoc`. - [x] Ensure that #1600 is documented in `release-notes-5.3.2.adoc`. - [x] Copy `release-notes-5.3.2.adoc` to `master`. - [x] Delete `release-notes-5.4.0-M1.adoc` from the `5.3.x` branch. - [x] Update `@since` and `@API` entries for backported bug fixes in `5.3.x` branch. - [x] Cherry pick updated `@since` and `@API` entries for backported bug fixes to `master` branch. - [x] Update Release Notes on `master`. - [x] Have at least one more set of eyes review the backported commits. - [x] Ensure the Travis CI builds pass. - [ ] Release Jupiter and Vintage 5.3.2 as well as Platform 1.3.2 according to the [Releasing Checklist](https://github.com/junit-team/junit5/wiki/Releasing).","closed","component: Vintage,","sormuras","2018-10-27T09:04:38Z","2018-11-25T19:46:17Z"
"","1636","Correct @API annotation link in pull request template","## Overview  Link to `@API` annotation in current [Pull Request Template](https://github.com/junit-team/junit5/blob/master/.github/PULL_REQUEST_TEMPLATE.md) in definition of done section is expired / dead.  Current link points to http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html which does not exist.  I am not sure what should be correct link, because this annotation comes from `org.apiguardian.api.API` which I believe is from `apiguardian` project.  ## Deliverables  - [x] Correct link to `@API` in Pull Request Template  **If somebody can provide a correct link, I would like to send a PR for this.**","closed","","shirishp","2018-10-16T16:33:49Z","2018-10-16T17:20:42Z"
"","1260","Avoid unnecessary lambda creation in assertions and preconditions","## Overview  Lambda objects are created on assertions. This affects performance.   This pull request removed unnecessary object creation.  Issues: #1258, #880","closed","component: Jupiter,","karayv","2018-01-25T08:33:23Z","2019-07-19T19:32:23Z"
"","1164","Add a kotlin test with a name with strange characters","## Overview  Just want to make sure that tests with names having strange characters will continue to work moving forward.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","JLLeitschuh","2017-11-16T03:43:14Z","2017-11-16T22:43:49Z"
"","1119","Add --select-module support to JUnitPlatformPlugin","## Overview  JUnit Platform now supports `--select-module` and `--scan-module-path`.  ## Deliverables  - [ ] Add `--select-module` support to our Gradle `JUnitPlatformPlugin`","closed","3rd-party: Gradle,","sormuras","2017-10-17T19:09:42Z","2017-10-22T11:15:48Z"
"","1004","Use junit.jupiter as prefix for Jupiter configuration parameters","## Overview  JUnit Jupiter currently supports the following _configuration parameters_, which misleadingly seem to apply to anything related to JUnit.  - `junit.extensions.autodetection.enabled` - `junit.conditions.deactivate`  ## Related Issues  - #905   ## Deliverables  - [x] Use `junit.jupiter` as a prefix for all configuration parameter names that are specific to JUnit Jupiter. - [x] Update `Constants`. - [x] Update User Guide. - [x] Update release notes.  Checklist:  - [x] `junit.jupiter.extensions.autodetection.enabled` - [x] `junit.jupiter.testinstance.lifecycle.default`   - to be addressed in #905. - [x] `junit.jupiter.conditions.deactivate`","closed","component: Jupiter,","sbrannen","2017-08-04T19:25:36Z","2017-08-04T20:11:22Z"
"","1576","Regression: assertThrows() ThrowingSupplier variants break existing code","## Overview  JUnit Jupiter 5.3.0 introduced new variants of `assertThrows()` that accept `ThrowingSupplier` arguments instead of `Executable` (see #1394). However, this change prevents existing code from compiling against Jupiter 5.3.0 if the code in question used a method reference for an overloaded method with a `void` return type.  Note that overloaded methods with non-void return types are not affected. For example, even though `java.util.concurrent.Future` has two `get(...)` methods, it still can be used as a method reference as `future::get` without suffering from issues with type inference since such a method can always properly be inferred to be a `ThrowingSupplier`.  ## Example  Note that `java.lang.Object` has three overloaded variants of its `wait()` method. Thus, the following example compiled against Jupiter 5.2.0 but fails to compile against Jupiter 5.3.0.  ```java @Test void test() { 	var object = new Object(); 	// Does NOT compile against Jupiter 5.3.0 	assertThrows(Exception.class, object::wait); } ```  ## Workarounds  The following two workarounds allow affected code to compile against Jupiter 5.3.0; however, this obviously requires a manual change to existing code which is an unacceptable breaking change.  ```java @Test void test() { 	var object = new Object();  	// Does NOT compile against Jupiter 5.3.0 	// assertThrows(Exception.class, object::wait);  	// Workaround #1 	assertThrows(Exception.class, () -> object.wait());  	// Workaround #2 	assertThrows(Exception.class, (Executable) object::wait); } ```  ## Analysis  Given the following test class, the code compiles ""as is"", but the invocation of `assertThrows(Exception.class, object::wait)` will fail to compile if you uncomment the `assertThrows()` variant that accepts a `ThrowingSupplier`.  ```java import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.function.Executable;  class AssertThrowsTests {  	static  T assertThrows(Class expectedType, Executable executable) { 		return Assertions.assertThrows(expectedType, executable); 	}  	//	static  T assertThrows(Class expectedType, ThrowingSupplier supplier) { 	//		return Assertions.assertThrows(expectedType, supplier); 	//	}  	@Test 	void test() { 		var object = new Object(); 		assertThrows(Exception.class, () -> object.wait()); 		assertThrows(Exception.class, (Executable) object::wait); 		assertThrows(Exception.class, object::wait); 	}  } ```  ## Proposal  In other to avoid issues with type inference for overloaded methods used as method references, we should revert the changes to all existing `assertThrows()` methods and introduce new `assertThrowsXyz()` variants that accept a `ThrowingSupplier`.  This will enforce that all existing code that invokes `assertThrows()` will use an `Executable`, and all new code compiled against the new `assertThrowsXyz()` variants will use a `ThrowingSupplier`.  What `Xyz` should be is up for debate.  ## Related Issues  - #1394  - #1401  - #1414   ## Deliverables  - [x] Remove overloaded variants of `assertThrows` that accept a `ThrowingSupplier` - [x] Revert changes to `ThrowingSupplier` - [x] Document bug fix in the Release Notes - [x] Investigate potential issue with overloaded variants of `assertDoesNotThrow` (and document workarounds if necessary) - [x] Backport fix and release notes to a new `5.3.1` branch.","closed","component: Jupiter,","sbrannen","2018-09-05T11:52:22Z","2021-03-08T17:35:07Z"
"","1534","Document how to register extensions via static fields in Kotlin","## Overview  JUnit 5 extensions can be registered programmatically.  When one wants to register extensions that support lifecycle methods, they should be registered as static fields.  In the Kotlin programming language this is normally achieved using the `@JvmStatic` annotation.  However that will not work because a private field will be generated, and private fields are filtered out by JUnit 5.  The correct approach is to use `@JvmField` instead.  This commit documents the correct approach and provides a Kotlin example analogous to the existing Java one.  Reference: #1500  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","stefano-m","2018-08-11T10:02:36Z","2018-08-11T18:02:10Z"
"","1624","Support hexadecimal values in arguments converters","## Overview  It’s a feature request: support converting argument strings containing integral literals in hexadecimal to the corresponding types on top of decimal.  ### Description Currently one cannot use hexadecimal integral values when specifying arguments, e.g., this won't work: ```java @CsvSource({     ""1"",     ""0x1"", // Won't be converted }) // CSV source for illustrative purposes: ValueSource would suite here better @ParameterizedTest void test(int v) { ```  The cases when one needs to use hex include copying values in hex from some specification; when binary representation (i.e., which bit in the value is set) matters.  ### Workaround  Use String as argument type and convert yourself with, e.g., Integer::decode.  ## Deliverables  - [ ] ...","closed","theme: parameterized tests,","dmitry-timofeev","2018-10-07T12:48:45Z","2018-10-13T18:02:15Z"
"","1629","Publish a module that combines the Jupiter API, Params, and Engine in one artifact","## Overview  It's fairly common to require `junit-jupiter-api`, `junit-jupiter-params` and `junit-jupiter-engine` when writing tests. Currently this means that any build file need three distinct imports, and possible a version property declaration to ensure version compatibility.  The currently [Maven](https://github.com/junit-team/junit5-samples/blob/c155a7f0d8683d2274856569388720e44841abcb/junit5-jupiter-starter-maven/pom.xml#L19-L36) and [Gradle](https://github.com/junit-team/junit5-samples/blob/c155a7f0d8683d2274856569388720e44841abcb/junit5-jupiter-starter-gradle-groovy/build.gradle#L13-L15) samples themselves show such a setup.  It would really help the getting started experience if a single `junit-jupiter` dependencies was available that pulled in the others transitively. The would change a Maven build from this:  ```xml  	... 	 		5.3.1 	 	 		 			org.junit.jupiter 			junit-jupiter-api 			${junit.jupiter.version} 			test 		 		 			org.junit.jupiter 			junit-jupiter-params 			${junit.jupiter.version} 			test 		 		 			org.junit.jupiter 			junit-jupiter-engine 			${junit.jupiter.version} 			test 		 	 	...  ```  to this  ```xml  	... 	 		 			org.junit.jupiter 			junit-jupiter 			5.3.1 			test 		 	 	...  ```  ## Deliverables  - [x] A new POM file.","closed","component: Jupiter,","philwebb","2018-10-09T01:35:36Z","2018-12-27T15:59:30Z"
"","1412","Support IBM AIX in @EnabledOnOs and @DisabledOnOs","## Overview  It would be great if we could ignore certain tests only on AIX by using `@DisabledOnOs(AIX)`. Due to `OS.OTHER` this change might be a breaking one.  ## Deliverables  - [x] Add AIX to OS enum and add AIX detection","closed","component: Jupiter,","epeee","2018-05-09T05:23:21Z","2018-05-09T09:28:18Z"
"","1169","Kotlin compiler chokes on jdk-10+ea-31","## Overview  It worked with build 29 and 30 of jdk-10+ea: http://jdk.java.net/10/  Blocked by https://youtrack.jetbrains.com/issue/KT-21303  ## Deliverables  - [x] Upgrade to Kotlin version that supports jdk-10+ea-31 or higher","closed","component: Kotlin,","sormuras","2017-11-17T07:25:15Z","2018-06-12T11:28:38Z"
"","1764","Mention maven-failsafe-plugin version to be considered in User Guide","## Overview  It took me some hours to understand why my integration tests run with JUnit4 provider although I configured maven surefire plugin as described in the guide. It turned out that I had to update maven-failsafe plugin version too. My pull request to the documentation reflects my learnings.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","dpolivaev","2019-02-07T11:46:21Z","2019-02-07T14:01:30Z"
"","971","Static @BeforeEach method causes entire test plan to abort","## Overview  It is probable that I've encountered a bug related to execution of batch of tests.  If one of these test classes has a `static` method annotated with `@BeforeEach`, the whole batch is skipped.  Although the case with `static` method annotated with `@BeforeEach` is an error, it must not ruin the rest of test plan.  ## Steps to Reproduce  The details are here: https://github.com/SqAutoTestTeam/possiblejunit5bug.git  ## Current behavior  - Error is written to log - No tests in batch are executed   ## Expected behavior - Error is still written to log - Execute those test classes that are well-formed (have annotations over mwthods with right modifiers) and - skip execution for those that are not.  ## Related Issues  - #242   ## Deliverables  - [x] Ensure that configuration errors related to lifecycle methods (i.e., `@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`) do not cause the entire test plan to abort prematurely.","closed","theme: diagnostics,","SqAutoTestTeam","2017-07-21T14:06:15Z","2018-12-28T14:04:31Z"
"","981","Introduce additional tests for support of generics","## Overview  Issues #333, #976, and #978 addressed the topics of generics and overridden methods in various ways; however, as conjectured in #978, we may still have lingering bugs in this regard.  ## Dedicated test class  [ReflectionUtilsWithGenericTypeHierarchiesTests](https://github.com/junit-team/junit5/blob/master/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsWithGenericTypeHierarchiesTests.java) contains a set of interesting and some unclear cases.  ## Deliverables  For each of the following, introduce additional tests across multiple-level class hierarchies using generic interfaces, generic abstract classes, etc.  In other words, try to _break_ the search algorithms.  - [ ] `ReflectionUtils.findMethod(*)` - [ ] `ReflectionUtils.findMethods(*)`","open","component: Platform,","sbrannen","2017-07-24T19:44:32Z","2022-07-01T07:12:40Z"
"","1655","[WIP] Allow static modifier on dynamic test factory methods","## Overview  Issue: #1654  Why does this work?  Why doesn't `Object instance = extensionContext.getRequiredTestInstance();` fail here?  https://github.com/junit-team/junit5/blob/dff15fb145efd34629582e469f657ad64490e22b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java#L85-L87  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2018-10-30T09:58:07Z","2018-11-19T16:51:55Z"
"","1895","Introduce support for converting from a URI of the form method: to a MethodSource","## Overview  Introduce support for converting from a URI of the form `method:` to a `MethodSource`, where FQMN is the fully qualified method name. See the Javadoc for `DiscoverySelectors.selectMethod(String)` for the supported formats for a FQMN.  See #1850 for details  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","ielatif","2019-05-24T00:32:17Z","2019-05-29T10:36:24Z"
"","1623","PR: Introduce support for assertNotEquals for primitive data types","## Overview  Introduce support for `assertNotEquals` for primitive data types short, byte, int, long, char, float and double.  Issue #1607  Notes: * Please review the JavaDocs in junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java * Please review implementations and tests especially of float and double with delta * `assertNotEquals(boolean, boolean)` is implemented, but corresponding `assertEquals(boolean, boolean)` is not present. IMHO, it should be done as a separate issue and PR. I am willing to work on PR for that.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","shirishp","2018-10-07T09:16:55Z","2018-10-21T03:07:48Z"
"","1593","[#1091] Modules via using Java 9 as release target","## Overview  Introduce module descriptors as layed out in #1091.  - [x] `org.junit.platform.commons` - [x] `org.junit.jupiter.api` - [ ] _others_  ## Caveats  - This PR also **temporarily** moves the ""javac --target"" option from **8 to 9** to enable `module-info.java` compilation. Who knows a way to remain binary compatible with Java 8?  - **Checkstyle** and **Degraph** are muted/turned off until they support Java 9+...  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Gradle,","sormuras","2018-09-21T07:33:55Z","2019-04-15T03:21:31Z"
"","1844","[#1091] Modules via extra compilation task","## Overview  Introduce explicit module descriptor compilation support as described in #1091. Find more details here: https://blog.tlinkowski.pl/2019/building-java-6-8-libraries-for-jpms-in-gradle  ### `module-info.java`  - [ ] 	org.junit.jupiter.api - [ ] 	org.junit.jupiter.engine - [ ] 	org.junit.jupiter.migrationsupport - [ ] 	org.junit.jupiter.params - [x] 	org.junit.platform.commons - [ ] 	org.junit.platform.console - [ ] 	org.junit.platform.engine - [ ] 	org.junit.platform.launcher - [ ] 	org.junit.platform.reporting - [ ] 	org.junit.platform.runner - [ ] 	org.junit.platform.suite.api - [ ] 	org.junit.platform.testkit - [ ] 	org.junit.vintage.engine  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2019-04-04T14:47:30Z","2019-04-15T03:21:11Z"
"","1691","Introduce 'junit-jupiter' aggregator module","## Overview  Introduce `junit-jupiter` aggregator module with the following Maven coordinates:  ``` org.junit.jupiter junit-jupiter 5.4.0-SNAPSHOT ```  The generated `jar` is almost empty, it only contains a `MANIFEST.MF` file and a `pom.xml` with the following dependencies:  ```xml               org.junit.jupiter       junit-jupiter-api       5.4.0-SNAPSHOT       compile                 org.junit.jupiter       junit-jupiter-params       5.4.0-SNAPSHOT       compile                 org.apiguardian       apiguardian-api       1.0.0       compile                 org.junit.jupiter       junit-jupiter-engine       5.4.0-SNAPSHOT       runtime         ```  Closes #1629  Reverts and closes #1669   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---","closed","type: new feature,","sormuras","2018-11-30T10:58:48Z","2018-11-30T18:18:46Z"
"","1272","Introduce @DisabledIf annotation","## Overview  Introduce `@DisabledIf` annotation.  - Merge logic of `@EnabledIf` and `@DisabledIf` execution condition into a single implementation. - Compile and cache compiled script instances if the selected script engine implements `javax.script.Compilable`  #### Examples  ```java @Test @DisabledIf(""java.lang.System.getProperty('os.name').toLowerCase().contains('win')"") void notOnMicrosoftWindows() { 	assertTrue(!System.getProperty(""os.name"").toLowerCase().contains(""win"")); }  @Test @DisabledIf(""java.lang.System.getProperty('os.name').toLowerCase().contains('mac')"") void notOnMacOs() { 	assertTrue(!System.getProperty(""os.name"").toLowerCase().contains(""mac"")); }  ``` ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2018-01-30T20:58:31Z","2018-02-02T12:53:35Z"
"","1244","Integrate codecov with Travis build","## Overview  Integrates codecov with Travis build.  Example result from my fork: https://codecov.io/gh/hisener/junit5  Also, adds the codecov badge to `README.md`. It looks like this: [![codecov](https://codecov.io/gh/hisener/junit5/branch/master/graph/badge.svg)](https://codecov.io/gh/hisener/junit5)  Related issue: #240   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","hisener","2018-01-15T12:56:45Z","2018-01-15T21:20:19Z"
"","1738","Support field injection in TempDirectory","## Overview  Inspired by discussions in #1731, the team has decided to introduce field injection support for `@TempDir` alongside the existing support for constructor and method injection.  ## Deliverables  - [x] Support field injection for `@TempDir` fields in the `TempDirectory` extension. - [x] Introduce tests in `TempDirectoryTests` that verify expectations regarding the scope of the temporary directory when registered via a field. - [x] Document in User Guide. - [x] Document in Release Notes.","closed","component: Jupiter,","sbrannen","2019-01-18T14:29:25Z","2019-01-22T13:34:45Z"
"","1036","Introduce @SuiteDisplayName in the platform suite API","## Overview  Inspired by a discussion in [Gitter](https://gitter.im/junit-team/junit5?at=59a6e35f8f4427b462b5b48a), it would be useful to introduce a new `@SuiteDisplayName` annotation in the `org.junit.platform.suite.api` package.  Note that we cannot re-use `@DisplayName` since it is particular to the JUnit Jupiter API.  ## Deliverables  - [x] Introduce `@SuiteDisplayName` annotation in the `org.junit.platform.suite.api` package. - [x] Update the `JUnitPlatform` runner to use the user-supplied display name for the suite if `@SuiteDisplayName` is declared on the test class. - [x] Update the User Guide. - [x] Update the release notes.","closed","theme: suites,","sbrannen","2017-08-30T17:11:39Z","2017-09-21T15:32:23Z"
"","1466","Document exception handling regarding user code and extension interactions in User Guide","## Overview  In the User Guide we have [section 5.11](https://junit.org/junit5/docs/current/user-guide/#extensions-execution-order) where the _happy path_ relative execution order is described.   During our work on #1465 and #1460 I was trying to find in the user guide what would be the expected behavior when something fails. Specifically in that case I wanted to know what is expected to run when there is an exception in the constructor of the test class.  I would have expected this information to be described in the User Guide, yet it is not or I was unable to find it.  ## Deliverables  - [ ] Document the expected execution paths and order in case of failures. - [ ] Add link to this information in `Relative Execution Order Section` of the User Guide so it easy to find.","closed","status: stale,","gaganis","2018-06-14T14:19:11Z","2021-06-19T12:50:31Z"
"","1313","Failures in lifecycle methods should take precedence over TestAbortedException","## Overview  In the following example, `abortedTest` will be reported as _aborted_, while `successfulTest` will be reported as _failed_ due to the exception in `afterEach()`.  Expected behavior: `abortedTest` should be reported as _failed_ with a suppressed `TestAbortedException`.  ```java class TestCase {  	@Test 	void abortedTest() { 		assumeFalse(true, ""abortedTest""); 	}  	@Test 	void successfulTest() { 	}  	@AfterEach 	void afterEach() { 		throw new RuntimeException(""afterEach""); 	} } ```  ## Deliverables  - [x] Let other exceptions take precedence over `TestAbortedException`.","closed","component: Platform,","marcphilipp","2018-02-25T16:50:51Z","2018-07-28T18:18:43Z"
"","1184","Third-party ParameterResolvers may potentially conflict with ParameterizedTestParameterResolver","## Overview  In the following code snippet, the Weld CDI system provides a `ParameterResolver` for the third parameter in the `parametersTakePriorityOverInjection()` method.  Since the```@TestTemplate``` ""knows"" that it's producing parameters for the first two parameters via its ```ArgumentSource```, it shouldn't call either the `supportsParameter()` or `resolvesParameter()` methods of Weld's `ParameterResolver`.  Other registered ```ParameterResolver```s should only be called for parameters with indexes greater than one.  ```java @ExtendWith(WeldJunit5Extension.class) public class ParameterizedTestCompatibilityTest {  	static final String SENTENCE = "" is a greek letter."";  	@ParameterizedTest 	@CsvSource({ 			""Alpha, 0"", 			""Beta, 1"", 			""Gamma, 2"" 	}) 	void parametersTakePriorityOverInjection(String letter, int ordinal, String sentence) { 		assertTrue(letter.length() >= 4); 		assertTrue(ordinal >= 0 && ordinal <= 2); 		assertEquals(SENTENCE, sentence); 	}  	@Produces 	@ApplicationScoped 	String produceSentence() { 		return "" is a greek letter.""; 	}  } ```  When run, this code currently throws a ```ParameterResolutionException``` with the message:  ``` Discovered multiple competing ParameterResolvers for parameter [java.lang.String arg0] in executable [void org.jboss.weld.junit5.compatibility.ParameterizedTestCompatibilityTest.parametersTakePriorityOverInjection(java.lang.String,int,java.lang.String)]: org.jboss.weld.junit5.WeldJunit5Extension, org.junit.jupiter.params.ParameterizedTestParameterResolver ```  This issue is somewhat related to #935 but occurs when additional parameters are correctly placed after those injected by the ```TestTemplate```.  ## Versions  - `junit-jupiter-api`: 5.0.1, 5.0.2, 5.1 M1 - `junit-jupiter-params`: 5.0.1, 5.0.2, 5.1 M1  ## Related Issues  - #935 - https://github.com/weld/weld-junit/issues/3 - https://github.com/weld/weld-junit/issues/13  ## Deliverables  - [ ] Parameterized tests should ignore other registered parameter resolvers for parameters that will be satisfied by an ```ArgumentSource```.","closed","component: Jupiter,","smoyer64","2017-11-24T17:04:02Z","2018-01-13T19:22:30Z"
"","1268","Conditional evaluation of Assert.assertEquals message","## Overview  In some situations it's convenient to evaluate the `message` argument of `Assert.assertEquals` only if the assertion fails, e.g.  ```java     HttpURLConnection uc = (HttpURLConnection) new URL(""http://example.org/some/rest/path"").openConnection();     uc.setRequestProperty(""Accept"", MediaType.TEXT_PLAIN);     Assert.assertEquals(String.format(""unexpected response code was %d and response text '%s'"",                 uc.getResponseCode(),                 IOUtils.toString(uc.getErrorStream(),                         Charsets.UTF_8)),             200,             uc.getResponseCode()); ```  doesn't work, because `uc.getErrorStream` returns `null` if the request was successful, but it's evaluated for constructing the `message` string and thus fails due to a `NullPointerException`. If there was a possibility to construct `message` in a callback which is only invoked if the assertion failed, the above could be used.  There might be workarounds to achieve the above, maybe even more elegant and splitting the statement with `if` is trivial, but it's intended to be an example and in other situations no such workaround might exist.  This applies to other `Assert.assert...` methods as well.  This report can be seen both as question whether such a feature exists and as feature request in case it does not.","closed","component: Jupiter,","krichter722","2018-01-28T21:15:17Z","2018-01-29T11:37:50Z"
"","1048","Implementation of AbstractExtensionContext#getRoot is wrong","## Overview  In RC3, `AbstractExtensionContext` implements `ExtensionContext#getRoot`. The documentation suggests that this method will return the top level `ExtensionContext` (in other words, the result of `getRoot` should be context independent), but the implementation is written such that it terminates after traversing one level of `ExtensionContext` at most.  Here's a unit test that fails both its tests:  ```java import static org.junit.jupiter.api.Assertions.*;  import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.api.extension.ExtensionContext; import org.junit.jupiter.api.extension.ParameterContext; import org.junit.jupiter.api.extension.ParameterResolutionException; import org.junit.jupiter.api.extension.ParameterResolver;  import com.topdesk.stanchion.ExtensionContextGetRootTest.RootExtensionContextInjector;  @ExtendWith(RootExtensionContextInjector.class) public class ExtensionContextGetRootTest { 	 	private final ExtensionContext rootExtensionContext; 	 	ExtensionContextGetRootTest(ExtensionContext rootExtensionContext) { 		this.rootExtensionContext = rootExtensionContext; 	} 	 	@Test 	void topLevelMethod(ExtensionContext shouldBeRootExtensionContext) { 		assertEquals(rootExtensionContext, shouldBeRootExtensionContext); 	} 	 	@Nested 	class NestedTest { 		 		@Test 		void nestedLevelMethod(ExtensionContext shouldBeRootExtensionContext) { 			assertEquals(rootExtensionContext, shouldBeRootExtensionContext); 		} 	} 	 	static class RootExtensionContextInjector implements ParameterResolver { 		 		@Override 		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException { 			return parameterContext.getParameter().getType() == ExtensionContext.class; 		} 		 		@Override 		public ExtensionContext resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException { 			return extensionContext.getRoot(); 		} 	} } ```  From the failure messages, it becomes clear that all three injected extension contexts have a different root:  > org.opentest4j.AssertionFailedError:  > Expected :org.junit.jupiter.engine.descriptor.JupiterEngineExtensionContext@184cf7cf > Actual   :org.junit.jupiter.engine.descriptor.ClassExtensionContext@2fd6b6c7  And  > org.opentest4j.AssertionFailedError:  > Expected :org.junit.jupiter.engine.descriptor.JupiterEngineExtensionContext@184cf7cf > Actual   :org.junit.jupiter.engine.descriptor.ClassExtensionContext@63a65a25  ## Deliverables  - [x] Add tests to test this behavior - [x] Fix the bug","closed","component: Jupiter,","VagrantBlackbird","2017-09-08T13:29:57Z","2017-09-08T14:35:31Z"
"","1417","Introduce isAnnotated(Optional, Class) in AnnotationSupport","## Overview  In order to simplify matters for extension authors, we should introduce `isAnnotated(Optional, Class)` in `AnnotationSupport` analogous to the existing method in `AnnotationUtils`.  ## Deliverables  - [x] Introduce `isAnnotated(Optional, Class)` in `AnnotationSupport`. - [x] Document in the Release Notes.","closed","component: Platform,","sbrannen","2018-05-11T12:26:17Z","2018-05-11T13:03:42Z"
"","1585","Add support for JUnit 4's AssumptionViolatedException in JUnit Jupiter","## Overview  In order to provide a smoother migration path from JUnit 4 to JUnit Jupiter, the `JupiterTestEngine` module should provide support for JUnit 4's `org.junit.AssumptionViolatedException` for failed assumptions analogous to Jupiter's support for the `org.opentest4j.TestAbortedException` from the Open Test Alliance.  ## Implementation Notes  In order to avoid a compile-time dependency on JUnit 4 within the `junit-jupiter-engine` module, we should use reflection to load the `org.junit.AssumptionViolatedException` based on a hard-coded copy of its fully qualified class name.  ## Related Issues  - #1586   ## Deliverables  - [x] Add support for JUnit 4's `org.junit.AssumptionViolatedException` in JUnit Jupiter - [x] Update User Guide - [x] Update Release Notes","closed","component: Jupiter,","marcphilipp","2018-09-14T10:46:39Z","2018-09-14T16:00:22Z"
"","1586","Add support for JUnit 4's @Ignore to junit-jupiter-migrationsupport","## Overview  In order to provide a smoother migration path from JUnit 4 to JUnit Jupiter, the `junit-jupiter-migrationsupport` module should provide support for JUnit 4's `@Ignore` annotation analogous to Jupiter's `@Disabled` annotation.  ## Related Issues  - #1585  ## Deliverables  - [x] Add support for JUnit 4's `@Ignore` annotation to `junit-jupiter-migrationsupport` -- for example, via a new `IgnoreCondition` - [x] Introduce a new `@EnableJUnit4MigrationSupport` _composed annotation_ that registers all rule migration support in addition to the new `IgnoreCondition` - [x] Introduce proper integration tests for `IgnoreCondition` - [x] Introduce empirical integration tests for `@EnableJUnit4MigrationSupport` - [x] Update User Guide - [x] Update Release Notes  - ✖️ Allow the `IgnoreCondition` to be automatically registered via the `ServiceLoader` mechanism","closed","type: new feature,","marcphilipp","2018-09-14T10:47:28Z","2018-10-18T20:52:59Z"
"","1053","Forbid special characters in tag syntax","## Overview  In order to allow for seamless integration of a _tag expression language_ in a future release (e.g., as proposed in #454), we need to proactively forbid the inclusion of special characters in _tags_.  ## Related Issues  - #454   ## Deliverables  - [x] Forbid the following special characters in tags:   - [x] `,`   - [x] `(`   - [x] `)`   - [x] `&`   - [x] `|`   - [x] `!`","closed","theme: discovery,","sbrannen","2017-09-09T12:57:52Z","2017-09-09T14:38:42Z"
"","1604","Support composition of multiple parameterResolvers","## Overview  In Mockito, we want to support injection of multiple parameters. To that end, we have to check for a multitude of acceptable annotations and then later act on that annotation. This issue appeared when working on https://github.com/mockito/mockito/pull/1503 which had to add a new annotation (`@Captor`) besides our `@Mock` injection-capabilities.  The author of the PR [wrote a CompositeParameterResolver](https://github.com/mockito/mockito/blob/d88929cf338b1acc51d3072b14a01378934394b2/subprojects/junit-jupiter/src/main/java/org/mockito/junit/jupiter/resolver/CompositeParameterResolver.java) which would support this usecase. However, it feels like this kind of solution should live in JUnit, rather than being Mockito-specific. I would suspect that other projects will run into this problem (eventually).  Therefore, I would like to request a JUnit-official implementation for the use-case of composing various resolvers into a single parameter resolver, that then can be used in the extension.  ## Related Issues  - #1802   ## Deliverables  - [ ] A means to compose multiple parameterresolvers together, such that an extension can provide a list of resolvers and pass that automatically in `resolveParameter`.","closed","status: stale,","TimvdLippe","2018-09-28T11:07:58Z","2022-07-12T23:11:05Z"
"","1378","Document how to execute static nested test classes with Maven Surefire","## Overview  In light of #1377, we should inform users that static nested test classes are supported by JUnit Jupiter but are excluded from Maven builds by default.  ## Deliverables  - [x] Document that JUnit Jupiter supports `static` nested test classes. - [x] Document how to execute `static` nested test classes in a Maven build.   - See solution [here](https://github.com/junit-team/junit5/issues/1377#issuecomment-381964988).","closed","3rd-party: Maven Surefire,","sbrannen","2018-04-17T12:07:13Z","2018-04-21T13:07:54Z"
"","1649","Including tags useJunitPlatform closure does not exclude untagged tests","## Overview  In JUnit 5.3.1 run via Gradle, when I use `includeTags` to specify the tests to run in the `useJUnitPlatform` callback, tests with the included tags are run along with any tests without tags. The behavior is not defined in the documentation for Gradle support, and documentation for the deprecated Gradle plugin implies untagged tests should not run.  ## Deliverables  - Document the intended behavior for untagged tests - Add a method to exclude untagged tests","closed","3rd-party: Gradle,","tduehr","2018-10-26T04:14:49Z","2018-10-29T23:56:18Z"
"","1209","Can't call ""fail"" in Kotlin without specifying generic type explicitly","## Overview  In java you can call `fail` like this: ```java fail(""some message""); ``` Because of how the Kotlin compiler works, the same call in kotlin becomes: ```kotlin fail(""some message"") ```  Trying to just have: ``` fail(""some message"") ```  Causes the compiler to spit out the following error: ``` Error:(155, 9) Kotlin: Type inference failed: Not enough information to infer parameter V in fun  fail(p0: String!): V! Please specify it explicitly. ```  ## Proposed Solution  Add to the existing `Assertions.kt` file something like the following:  ```kotlin fun fail(message: String) = org.junit.jupiter.api.Assertions.fail(message) ```  Similar overloads will have to be provided for the other various `fail` overloads.  ## Deliverables  - [ ] Addition of the `fail` api to the `Assertions.kt` file.","closed","","JLLeitschuh","2017-12-15T23:35:30Z","2018-01-20T15:49:09Z"
"","1712","JUnit BOM should not include scope declarations for managed dependencies","## Overview  In https://github.com/junit-team/junit5/issues/1629#issuecomment-450031271, @eggilbert brought it to our attention that the `junit-bom` released in 5.4 M1 now contains `compile` entries that cause problems. This is in contrast to previous releases of the `junit-bom` and violates ""best practices"" for dependency management in Maven BOMs.  ## Related Issues  - #1629   ## Deliverables  - [ ] Ensure that dependencies in the `junit-bom` do not include `...` declarations.","closed","component: Vintage,","sbrannen","2018-12-27T11:28:06Z","2019-01-02T18:47:29Z"
"","1033","Consider introducing top-level support for a MemoizingSupplier","## Overview  In #1005, @kcooney introduced a private `MemoizingSupplier` class in `ExtensionValuesStore` that could (eventually) prove useful in multiple scenarios.  See discussion in [commit comments](https://github.com/junit-team/junit5/commit/6316bd090e662bfbce5e46ece7d5a0bcc858f732##commitcomment-23499744).  ## Proposal  The following is a proposal for what such a generic `MemoizingSupplier` might look like.  ```java /*  * Copyright 2015-2017 the original author or authors.  *  * All rights reserved. This program and the accompanying materials are  * made available under the terms of the Eclipse Public License v1.0 which  * accompanies this distribution and is available at  *  * http://www.eclipse.org/legal/epl-v10.html  */  package org.junit.jupiter.engine.execution;  import static org.junit.platform.commons.meta.API.Usage.Internal;  import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.Supplier;  import org.junit.platform.commons.meta.API;  /**  * @since 5.0  */ @API(Internal) public class MemoizingSupplier implements Supplier {  	private final Supplier delegate; 	private final Lock lock = new ReentrantLock();  	private volatile boolean valueSet = false; 	private volatile T value;  	public static  Supplier of(Supplier delegate) { 		return new MemoizingSupplier<>(delegate); 	}  	private MemoizingSupplier(Supplier delegate) { 		this.delegate = delegate; 	}  	@Override 	public T get() { 		if (!this.valueSet) { 			this.lock.lock(); 			try { 				if (!this.valueSet) { 					this.value = this.delegate.get(); 					this.valueSet = true; 				} 			} 			finally { 				this.lock.unlock(); 			} 		} 		return this.value; 	}  } ```  ## Deliverables  - [ ] If the need arises, move `MemoizingSupplier` to a top-level class or hide it behind a factory method in a utility in `junit-platform-commons`.","closed","status: stale,","sbrannen","2017-08-27T14:24:28Z","2021-06-19T12:50:04Z"
"","1561","PR: Improve exception message for non-static ArgumentsProvider","## Overview  Improve exception message for non-static ArgumentsProvider (fixes #1455)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","hisener","2018-08-28T17:15:13Z","2018-08-31T14:03:50Z"
"","1886","Remove parentheses when generating display name with ReplaceUnderscores","## Overview  Implements the improvement suggested in #1875.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","juliette-derancourt","2019-05-19T01:06:12Z","2019-05-20T11:33:23Z"
"","1431","Introduce tooling support tests","## Overview  Implements #1429 by creating `platform-tooling-support-tests` project and integrating it as an opt-in build step into the main build process. To activate the tests, pass `platform.tooling.support.tests.enabled=true` as a system property.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2018-05-25T06:28:43Z","2018-05-27T06:45:02Z"
"","1351","Issues/1338 discover dynamic tests early","## Overview  Implemented test discovery for dynamic tests in discovery phase in case @testfactroy method is static  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mibutec","2018-03-31T05:24:13Z","2018-04-02T15:45:09Z"
"","1894","Add MethodSource.from(String, String, Class...)","## Overview  Implementation for Issue: #1893  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","leonard84","2019-05-23T13:32:37Z","2019-05-23T19:18:49Z"
"","1474","#1473 Ignore jenv specific vesion file from vcs","## Overview  Ignores `.java-version` from vcs (jenv specific file)  See #1473   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: declined,","dotCipher","2018-06-22T19:40:06Z","2018-06-23T14:55:07Z"
"","1567","TestInstanceFactory on enclosing class is not called for @Nested test class","## Overview  If I use nested classes together with a `TestIntanceFactory` on the outer class, the instance factory is not called for the inner class, unless a different factory class is used.   I would expect that I can use the same factory on the outer class and the inner class, and have it called both for outer and inner instances. Ideally the factory on the outer class would be ""inherited"" by the inner class automatically. (It's not clear from the docs if extensions are meant to be propagated to nested classes the way other things are.)  Note that the existing unit test `org.junit.jupiter.engine.extension.TestInstanceFactoryTests#instanceFactoriesInNestedClassHierarchy` (`org.junit.jupiter.engine.extension.TestInstanceFactoryTests.OuterTestCase`) uses a different factory class for the outer class and the inner class.  JUnit version: 5.3.0-RC1  ## Example Test  ```java import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.assertTrue;  import java.util.EmptyStackException; import java.util.Stack;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith;  @DisplayName(""A stack"") // NB if this is enabled, the TestInstanceFactory is never called for inner class instances @ExtendWith(JUnit5ExtensionJava.class) //@TestInstance(org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS) //@TestInstance(org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD) class TestingAStackJavaTest {      Stack stack;      @Test     @DisplayName(""is instantiated with new Stack()"")     void isInstantiatedWithNew() {         new Stack<>();     }      @Nested     @DisplayName(""when new"")     // TODO if specified on outer class, are extensions inherited?     @ExtendWith(JUnit5ExtensionJava.class)     class WhenNew {          @BeforeEach         void createNewStack() {             stack = new Stack<>();         }          @Test         @DisplayName(""is empty"")         void isEmpty() {             assertTrue(stack.isEmpty());         }          @Test         @DisplayName(""throws EmptyStackException when popped"")         void throwsExceptionWhenPopped() {             assertThrows(EmptyStackException.class, () -> stack.pop());         }          @Test         @DisplayName(""throws EmptyStackException when peeked"")         void throwsExceptionWhenPeeked() {             assertThrows(EmptyStackException.class, () -> stack.peek());         }          @Nested         @DisplayName(""after pushing an element"")         @ExtendWith(JUnit5ExtensionJava.class)         class AfterPushing {              String anElement = ""an element"";              @BeforeEach             void pushAnElement() {                 stack.push(anElement);             }              @Test             @DisplayName(""it is no longer empty"")             void isNotEmpty() {                 assertFalse(stack.isEmpty());             }              @Test             @DisplayName(""returns the element when popped and is empty"")             void returnElementWhenPopped() {                 assertEquals(anElement, stack.pop());                 assertTrue(stack.isEmpty());             }              @Test             @DisplayName(""returns the element when peeked but remains not empty"")             void returnElementWhenPeeked() {                 assertEquals(anElement, stack.peek());                 assertFalse(stack.isEmpty());             }         }     } } ```  ```java import java.util.Optional;  import org.junit.jupiter.api.extension.ExtensionContext; import org.junit.jupiter.api.extension.TestInstanceFactory; import org.junit.jupiter.api.extension.TestInstanceFactoryContext; import org.junit.jupiter.api.extension.TestInstantiationException;  import static org.junit.platform.commons.util.ReflectionUtils.newInstance;  public class JUnit5ExtensionJava implements TestInstanceFactory {      @Override     public Object createTestInstance(TestInstanceFactoryContext factoryContext,             ExtensionContext extensionContext)             throws TestInstantiationException {         try {             Optional outerInstance = factoryContext.getOuterInstance();             Class testClass = factoryContext.getTestClass();             if (outerInstance.isPresent()) {                 System.out.println(""TestInstanceFactory.createTestInstance() called for inner class"");                 return newInstance(testClass, outerInstance.get());             } else {                 System.out.println(""TestInstanceFactory.createTestInstance() called for outer class"");                 return newInstance(testClass);             }         } catch (Exception e) {             throw new TestInstantiationException(e.getMessage(), e);         }     } } ```  The logging shows that `createTestInstance()` is never called for inner class instances, unless you comment out `@ExtendWith(JUnit5ExtensionJava.class)` on the outer class.  Note that if I simply clone the extension class and use one factory class for the outer class and the other factory class for the inner class, both factories are called as expected. It's only when the same extension is specified on both classes, or perhaps ""inherited"" from the outer to the inner class, that the inner instances are skipped.  I haven't checked whether this applies to other extension types or just `TestInstanceFactory`.","closed","component: Jupiter,","seanf","2018-08-30T01:46:21Z","2018-08-31T13:49:03Z"
"","1925","RegisterExtension + Nested tests cause ParameterResolutionException","## Overview  If an extension, implementing ParameterResolver, is registered with `RegisterExtension` in a class with `Nested` test classes, parallel execution of tests from this class results in `ParameterResolutionException`s.  ## Steps to reproduce  The minimal example with instructions to reproduce is in a separate repo: https://github.com/dmitry-timofeev/junit-paramresolver-bug   Quick links to:  - [The extension](https://github.com/dmitry-timofeev/junit-paramresolver-bug/blob/master/src/main/java/dt/TestExtension.java)  - [The test](https://github.com/dmitry-timofeev/junit-paramresolver-bug/blob/master/src/test/java/dt/TestExtensionTest.java)  ### Actual behaviour  ```  [ERROR] Tests run: 13, Failures: 0, Errors: 12, Skipped: 0, Time elapsed: 0.135 s <<< FAILURE! - in dt.TestExtensionTest [ERROR] t1{String}[2]  Time elapsed: 0.018 s  <<< ERROR! java.util.ConcurrentModificationException  [ERROR] t2{String}  Time elapsed: 0.034 s  <<< ERROR! org.junit.jupiter.api.extension.ParameterResolutionException:    Discovered multiple competing ParameterResolvers for parameter [java.lang.String arg0]    in method [void dt.TestExtensionTest.t2(java.lang.String)]:    dt.TestExtension@430095d6,    dt.TestExtension@5f2eaa85 […] ```  ### Expected  No exceptions, whether the `@Nested` classes use the extension (= get parameters injected) or not (as in the example).  ## Context   - Used versions: 5.5.0-RC1  - Build Tool/IDE: any (reproducible when run via Maven and IntelliJ)  - Originally discovered in https://github.com/exonum/exonum-java-binding/pull/954 with [this test failing](https://github.com/exonum/exonum-java-binding/blob/b9b619b0a5d6ef385085dda867cd1d926498c19c/exonum-java-binding/qa-service/src/test/java/com/exonum/binding/qaservice/QaServiceImplIntegrationTest.java)  ## Deliverables  - [x] ...","closed","component: Jupiter,","dmitry-timofeev","2019-06-12T12:14:37Z","2019-06-20T09:30:02Z"
"","1158","Сlass-level @Tag annotation is not inherited","## Overview  If an abstract class is annotated with ""Tag"" annotation, it doesn't take part in group filtering as the annotation is not inherited. This is wrong according to the documentation as it says:  _Used to declare tags for filtering tests, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level._  But if you look at the declaration of the annotation:  ```java @Target({ ElementType.TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @Documented @Repeatable(Tags.class) @API(status = STABLE, since = ""5.0"") public @interface Tag ```  There is no `@Inherited` annotation.  As the result tagged classes are not filtered/excluded.  pom.xml:  ```xml ....                     org.apache.maven.plugins                     maven-surefire-plugin                     2.19.1                                                                           org.junit.platform                             junit-platform-surefire-provider                             ${junit.platform.version}                                                                                                                         default-test                                                              test                                                          test                                                              DataBaseTest                                                                                                            other-test                                                              test                                                          test                                                              DataBaseTest                                                                            ... ```  Base test class  ```java @ExtendWith(SpringExtension.class) @ContextConfiguration({ .... }) @Tag(""DataBaseTest"") public abstract class BaseDaoTest ```  ## Affected Version  - JUnit Jupiter 5.0.0-5.0.2","closed","theme: discovery,","Pazus","2017-11-13T14:50:37Z","2018-01-12T13:28:44Z"
"","1252","Ensure test classes cannot be private","## Overview  If a test class is discovered via class path or module path scanning, it cannot be `private`; however, if the test class is _selected_ explicitly (e.g. via `DiscoverySelectors.selectClass(Class)`) it can then be `private`.  The downside is that such `private` test classes will **never be executed** with a typical build configuration that relies on class path or module path scanning.  ## Deliverables  - [x] Ensure that test classes can never be `private`.","closed","component: Jupiter,","sbrannen","2018-01-19T12:52:05Z","2018-01-19T14:15:00Z"
"","1727","@RegisterExtension field is silently ignored if null at evaluation time","## Overview  If a field in a test class (either static or non-static) is annotated with `@RegisterExtension` but is never assigned a non-null value before evaluation for extension registration purposes, that situation is currently silently ignored thereby masking the user configuration error.  For example, the following test case passes without any error or warning.  ```java class RegisterExtensionWithNullFieldTestCase {  	@RegisterExtension 	BeforeEachCallback beforeEach;  	@Test 	void test() { 	}  } ```  ## Deliverables  - [x] Fail the corresponding test class or test method with an exception if a `@RegisterExtension` field is `null` at evaluation time.","closed","component: Jupiter,","sbrannen","2019-01-11T14:24:08Z","2019-07-19T19:32:27Z"
"","1695","Add Launcher execute() method that accepts the TestPlan returned by discover()","## Overview  IDEs and build tools use the `org.junit.platform.launcher.Launcher` interface to discover and run tests. However, the interface does not provide a means to run rests with a previous discovered test plan. This results, at least for IntelliJ, in that test engines will be asked twice to come up with the same test plan. See: https://youtrack.jetbrains.com/issue/IDEA-203173 for details.  Since discovery often involves classpath scanning this can be a real performance hit in large projects.  ## Proposal  Add interface method `void execute(TestPlan)` to the interface to allow reuse of already discovered test plan.  ### Alternative  If the suggestion above is difficult to realize. Cache a discovered test plan that results from an identical `LaunchDiscoveryRequest` object.  ## Deliverables  - [x] Introduce a new `void execute(TestPlan)` method in the `Launcher` API.   - [x] Implement appropriate tests. - [x] Add checks to `TestPlan` that throw an exception if the _user_ attempts to modify the state of the `TestPlan` after discovery has completed.   - [x] For the above, we will need some form of _state_ within the `TestPlan` to track if discovery has completed.   - [x] Implement appropriate tests. - [x] Document in User Guide. - [x] Document in Release Notes.","closed","theme: discovery,","jlink","2018-12-04T10:51:14Z","2021-06-05T15:45:42Z"
"","1440","Introduce support for annotation attribute overrides within annotation hierarchies","## Overview  I'm working on some tests using scenario based testing. To mark those tests I'm using an annotation `@Scenario(""Description of my scenario"")`. This results in some reports containing the scenario title and some information about execution of that scenario. The scenario title works for my custom reports, but not for JUnit reporting, since `@DisplayName` isn't set.  A possible solution would be to annotate those scenarios with `@DisplayName`, i.e.  ```java @Scenario @DisplayName(""Description of my scenario"") ```  However, that's not my favored solution, since there is one more annotation cluttering my code. I would like to be able to inherit annotations including their attributes.  A possible solution could be something like  ```java @Retention(RUNTIME) @Target(METHOD) @Test @InheritedAnnotation(inheritFrom=DisplayName.class) public @interface Scenario { 	String value(); } ```  This would lead to `@DisplayName` being found as an annotation when `@Scenario` is scanned. Since `@Scenario` declares a `value` attribute with the same type as defined in `@DisplayName`s `value` attribute, the attribute is inherited.  The default behavior for attribute inheritance would be something like: All attributes with same signature are inherited from `sourceAnnotation` to `targetAnnotation`. For all others default implementation is used.  One might think of something like:  ```java @Retention(RUNTIME) @Target(METHOD) @Test @InheritedAnnotation(inheritFrom=DisplayName.class, attributeMapper=MyCustomAttributeMapper.class) public @interface Scenario { 	String value(); } ```  to allow writing one's own attribute inheritance strategies.  ## Related Issues  - #614 - #1504 - #1543","closed","status: stale,","mibutec","2018-06-02T09:40:24Z","2021-06-19T12:50:04Z"
"","1113","Surefire provider should not build test plan per class","## Overview  I'm using a custom `TestExecutionListener` registered via `META-INF/services` which implements `testPlanExecutionStarted()` and `testPlanExecutionFinished()` to execute some custom setup and teardown which needs to be executed just once per suite/plan, and not once per class.  JUnit version: 5.0.1  ### Expected Behaviour  When running `mvn test` on a project, my listener gets invoked once before all test class executions and once after all executions.  ### Actual Behaviour  My listener gets invoked for every class, which defeats its purpose.","closed","3rd-party: Maven Surefire,","hwellmann","2017-10-17T10:31:36Z","2018-01-15T11:37:10Z"
"","1778","JUnit 5 Test Suites don't run with surefire 3.0.0-M3 under pure Maven","## Overview  I'm trying to launch test suite with surefire plugin under Maven version 3.0.0-M3. But if I do it with ```@RunWith(JUnitPlatform.class)``` annotation in pure Maven, situation ```No tests were executed!``` occurs. I figured out that this problem appears with 2.22.x version surefire, on the earlier versions all is fine. Therefore, dynamic tests with ```@TestFactory``` work fine with newer versions and do not work on 2.21.x and earlier.  ## Problem reproduction  I faced this problem during migration to JUnit 5 a part of open-source project Apache Ignite [1].  Also, for clarity, I tried to reproduce it on a small project [2]. I tried to run tests in two ways: with ```@SelectClasses``` annotation and dynamically, with  ```@TestFactory``` annotation (commented) [3]. The first approach works fine with 2.21.x version surefire and earlier and the second one is vice versa. For me, it is necessary to run the test suite ```MainSuiteTest``` under pure maven with the newest version that supports Java 11. I use command ```mvn -Dtest=MainSuiteTest test``` and get the next result:  LOG   ``` [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] [INFO] Results: [INFO] [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time:  2.472 s [INFO] Finished at: 2019-02-15T18:04:51+03:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M3:test (default-test) on project quickstart: No tests were executed!  (Set -DfailIfNoTests=false to ignore this error.) ```      From IDE both approaches work fine and it does not depend on the surefire version.  ## Context   - Surefire plugin: 3.0.0-M3  - JUpiter: 5.3.2  - Vintage: 5.3.2  - Platform launcher: 1.3.2  - Platform runner: 1.3.2  - IDE: Intellij IDEA 2018.1.7 (Ultimate)  - Maven: 3.6.0  - Java: 1.8.0_152  ## Links [1] https://github.com/apache/ignite/pull/5888/files#diff-04dc5d029560773ac79faaf3da0fbb22R134 [2] https://github.com/1vanan/quickstart/tree/Junit5 [3]https://github.com/1vanan/quickstart/blob/Junit5/src/test/java/com/quickstart/application/testSuites/MainSuiteTest.java","closed","3rd-party: Maven Surefire,","1vanan","2019-02-15T15:40:19Z","2021-12-04T09:29:35Z"
"","1663","Use ServiceLoader mechanism to load TestEngines in the Test Kit","## Overview  I'm raising this issue at @sbrannen's request from https://github.com/junit-team/junit5/issues/1662#issuecomment-435420852.  We should consider changing the API of the Test Kit so that it can easily test...uh, tests, from the JUnit Jupiter Engine. Currently, if one wants to do so, they need to depend on `JupiterTestEngine` which is `@API(Internal)`.  This issue originated from [this comment of mine](https://github.com/junit-team/junit5/issues/1662#issuecomment-435381451).  ## Proposal  Introduce support similar to that in the `Launcher` for discovering engines via Java's `ServiceLoader` mechanism and filter out all engines other than the one currently being tested (which is selected by engine ID).  ## Deliverables  - [x] Allow `TestEngine` implementations to be tested with the Test Kit without the need to instantiate the `TestEngine` directly.","closed","component: Test Kit,","jbduncan","2018-11-02T18:45:47Z","2018-11-06T13:53:21Z"
"","1940","Introduce @Requirement annotation","## Overview  I'm opening this pull request for issue #1900 to ask for some feedback about my attempt to implement the new annotation.  I orient myself at the ""@Displayname"" annotation and did the following steps  1. Defined the new annotation 2. Extended the extensionContext, testDescriptor and tesInfo interfaces for it 3. Added the new attribute to the AbstractTestDescriptor and modifided extending classes 4. Extended the XSD and the XMLWriter to write the new attribute  On the one hand side I think that should do it, on the other side I think something is missing. What's definitly missing is an updated documentation module. Havn't done that yet as I want to ask for feedback while updating the documentation in parallel.  _Nevertheless thanks to @sormuras helping me fixing IntelliJ and giving a short introduction into gradle and the junit modules_   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","Bukama","2019-06-27T19:50:26Z","2019-06-28T11:45:53Z"
"","1579","The combination of JUnit 5.3.0, maven-surefire-plugin 2.22.0 and reuseForks=false fails to find tests","## Overview  I'm not sure if this bug should be reported here or on maven-surefire-plugin's repo, but I'll give it a try here.  When using a combination of JUnit 5.3.0 together with maven-surefire-plugin 2.22.0 configured with reuseForks=false, surefire fails to find any JUnit tests.  Downgrading JUnit to 5.2.0 makes it work (i.e., tests are properly found), as does setting reuseForks=true.  The `pom.xml` file: ```xml    4.0.0   com.example   junit.jupiter.reuse-forks   jar   1.0-SNAPSHOT   junit.jupiter.reuse-forks   http://maven.apache.org                org.junit.jupiter       junit-jupiter-engine       5.3.0        test                                 org.apache.maven.plugins         maven-surefire-plugin         2.22.0                    false                           ```  A complete example (just unzip and run `mvn install`): [reuser-forks.zip](https://github.com/junit-team/junit5/files/2358751/reuser-forks.zip)  With JUnit 5.3.0, you'll see the output: ``` Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  With JUnit 5.2.0, you'll see the expected output: ``` Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 ```","closed","","mureinik","2018-09-06T21:02:25Z","2018-10-16T10:17:11Z"
"","1270","@MethodSource `value` attribute should not be mandatory","## Overview  I'm currently playing with JUnit 5, which I really like so far.  ```java static Stream test_smtp_connection() {     // ... } 	@ParameterizedTest 	@MethodSource(""test_smtp_connection"") 	void test_smtp_connection(String filePath, boolean shouldConnect, boolean shouldMail) { // ... } ```  We need `@MethodSource` extensively, but this annotation requires a value. We used a different data provider implementation so far (https://github.com/TNG/junit-dataprovider) where the equivalent of `@MethodSource` has an optional value and just uses the current test method name as method source when nothing is set. It would be great if JUnit Jupiter could allow the same behavior, or are there technical restrictions?  ## Proposal  This is what I would expect:  ```java static Stream test_smtp_connection() {     // ... } 	@ParameterizedTest 	@MethodSource 	void test_smtp_connection(String filePath, boolean shouldConnect, boolean shouldMail) { // ... } ```  ## Deliverables  - ?","closed","component: Jupiter,","nikowitt","2018-01-30T12:42:38Z","2018-02-01T14:25:13Z"
"","1425","Maven Surefire Provider should support configuration/excludeGroups directly","## Overview  I'd like to report a possible bug with the JUnit 5 vintage engine.  Versions:  - JUnit4: 4.12 - JUnit5: 5.0.3 - Maven Surefire Plugin: 2.21.0  *Observed behaviour*: In a project with mixed JUnit4 and JUnit5 tests, I am using the `maven-surefire-plugin` together with the `junit-platform-surefire-provider` to run both kind of tests. Under these circumstances the `@Category` annotation from JUnit 4 is ignored. The test runs although the category is excluded in the configuration of the plugin:  ```xml 		 			 				org.apache.maven.plugins 				maven-surefire-plugin 				2.21.0 				 					false 					tests.IntegrationTest 				  ```  *Desired behaviour*: the `excludedGroups` configuration is honored and tests annotated with `@Category(IntegrationTest.class)` are skipped.  If I delete all dependencies of the `maven-surefire-plugin` (so that the old JUnit4 test runner kicks in), the `@Category` annotation is processed as desired.  ## Steps to Reproduce  I set up a minimal project that demonstrates the bug here: [ttrelle/junit5-vintage-junit4-category](https://github.com/ttrelle/junit5-vintage-junit4-category)","closed","3rd-party: Maven Surefire,","ttrelle","2018-05-18T13:18:03Z","2018-06-16T12:40:48Z"
"","1243","Introduce file-based declarative test suite support","## Overview  I'd like to know if the equivalent exists or is in the works to match `TestNG`'s suite XML file format. I asked on Stack Overflow and was directed by @marcphilipp to open a feature request for this. Here are the details from the [original SO post](https://stackoverflow.com/q/47938209/1478636):  I've been dynamically generating TestNG XML suites in a project I'm working on. In an effort to take some initiative in migrating to JUnit 5. The TestNG specification is [very easy to find](http://testng.org/doc/documentation-main.html#testng-xml), but I cannot find the equivalent for JUnit 5.  All I can find are references that a file or URI can be specified for test discovery. Either by [command line option or URI](http://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher-options) and again under the [configuring selectors section](http://junit.org/junit5/docs/current/user-guide/#running-tests-build-gradle-selectors).  Naively, I'd like to assume that it's just the `fully.qualified.package.ClassName#methodName` format because I can find this as an example in the [MethodSelector](http://junit.org/junit5/docs/current/api/org/junit/platform/engine/discovery/DiscoverySelectors.html#selectMethod-java.lang.String-). The [UriSelector](http://junit.org/junit5/docs/current/api/org/junit/platform/engine/discovery/DiscoverySelectors.html#selectUri-java.lang.String-) and [FileSelector](http://junit.org/junit5/docs/current/api/org/junit/platform/engine/discovery/DiscoverySelectors.html#selectFile-java.io.File-) don't show what the actually expected format of the document is supposed to look like.  ## Related Issues:  - #744","closed","status: stale,","paul-nelson-baker","2018-01-15T04:50:11Z","2022-01-08T18:12:27Z"
"","1214","A POC for replacing explicit parameter null-check by an automated solution","## Overview  I'd like to contribute to *junit* by replacing existing *Preconditions.notNull()* checks with an automated solution based on *NotNull* method parameters annotations.    The job is done by the [Traute javac plugin](http://traute.oss.harmonysoft.tech/) (I'm its author) and current *PR* illustrates how it works:    1. *Traute* is configured for the *junit* project 2. Target method parameters are marked by *NotNull* annotation (a number of annotations are [supported by default](http://traute.oss.harmonysoft.tech/core/javac/#71-notnull-annotations), I used jsr305's *Nonnull* in this *PR) 3. Existing *Preconditions.notNull()* checks for the annotated method parameters are removed    E.g. here we apply the steps above to the [AbstractExtensionContext](https://github.com/denis-zhdanov/junit5/commit/c4b77d03cea8570ebf6f3c77e58b69cf3f7ee96d#diff-47d6e0008ed4935f2c5d0811c80b4e01) class. Result:    ``` javap -c ./junit-jupiter-engine/build/classes/java/main/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.class ...   public org.junit.jupiter.api.extension.ExtensionContext$Store getStore(org.junit.jupiter.api.extension.ExtensionContext$Namespace);     Code:        0: aload_1        1: ifnonnull     14        4: new           #18                 // class org/junit/platform/commons/util/PreconditionViolationException        7: dup        8: ldc           #19                 // String Namespace must not be null       10: invokespecial #20                 // Method org/junit/platform/commons/util/PreconditionViolationException."""":(Ljava/lang/String;)V       13: athrow ```   Benefits: * the code is better documented - method parameters constraints are clear either in javadocs or source * IDE support - there are nullability inspections in eclipse and intellij which highlight possible problems during development (like an attempt to give a *potentially null* reference as a *NotNull* method parameter) * source code is cleaner - explicit checks are removed  Also note *Traute* offers two more feature which might be useful for *junit*: * method return type might also be marked as *NotNull*. The plugin inserts a check for the return value then * it's possible not only mark all target method parameters by *NotNull*, but define *NotNullByDefault* and mark excludes by *Nullable* (if any) - see [NotNullByDefault](http://traute.oss.harmonysoft.tech/core/javac/#72-notnullbydefault-annotations) and [Nullable](http://traute.oss.harmonysoft.tech/core/javac/#73-nullable-annotations)    Please let me know if the team is interested in this change, I'm ok to apply the change to the whole project then. ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","denis-zhdanov","2017-12-21T19:08:49Z","2019-07-19T19:32:45Z"
"","1562","Introduce implicit conversion from fully qualified class name to Class instance in parameterized tests","## Overview  I would like to be able to pass a class name in to a parameterized test along with a set of other data points and use these parameterized values to drive/validate a test. I typically use this in a circumstance where I want to drive a test wherein a number of possible exceptions could be thrown that should result in a similar result, with that result having a number of other parameterized input parameters.  ## Related Pull Requests  - #1564   ## Deliverables  - [ ] Provide a solution such that code similar to the following example could work:  ```java @ParameterizedTest @CsvSource({""OneException.class,someName,someNumber"", ""TwoException.class,anotherName,anotherNumber""}) void anExampleTest(Class clazz, String name, String number) {   when(collaborator.doTheOtherThing(name, number)).thenThrow(class);    try {     unitUnderTest.doTheThing(name, number);   }   catch (Exception ignored) {   }    assertThat(standardOutput).contains(name + "" "" + number); } ```","closed","theme: parameterized tests,","Jitsusama","2018-08-28T18:02:59Z","2019-07-19T19:32:26Z"
"","1578","OutOfMemoryError in test suite when upgrading from JUnit 5.2 to 5.3","## Overview  I work on a large project which runs Junit 5 under Gradle (currently version 4.8).  One of our test suites which previously ran fine with a 8 GB max heap size now requires an ~11 GB heap to run without OutOfMemoryError (~12 GB to run without OutOfMemoryError AND without GC overhead slowing things down significantly).  Looking at the release notes, I see nothing that should cause such a significant increase in memory usage from Junit 5 itself, so I was surprised to see this new problem while upgrading versions.  I only found one other open issue mentioning OutOfMemoryError and it involves dynamic tests, which my suite isn't using at all.  I suppose it's possible that some small behavior change in Junit 5.3 sensitizes an issue with my test suite that increases memory consumption, but I can't think of what that might be.   Are there any changes in Junit 5.3 that are known to increase memory consumption, and thus increase risk of OutOfMemoryError while running tests?  My apologies if this issue seems more like a question and not a real bug report... but I figured it was better to raise the issue quickly after Junit 5.3 release just in case others are going to start hitting the same problem soon.  Unfortunately, I can't share my unit tests from this project.  However, I am going to try to pare down the test suite to see if I can narrow down where the memory increase is happening.  I may or may not be able to come back here later and provide more specific information, after doing that work.  ## Deliverables  **Team Decision**:  - [x] Implement the _quick fix_ mentioned by @sbrannen. - [x] Investigate other possibilities for freeing up unnecessary memory consumption in the `HierarchicalTestEngine` and related infrastructure (specifically in `NodeTestTask`). - [x] Backport fix and release notes to a new `5.3.1` branch.","closed","component: Platform,","tcfurrer","2018-09-06T18:31:05Z","2018-09-09T13:45:37Z"
"","1442","Introduce AroundEachCallback","## Overview  I wonder if there was really no request for this, but I could find no issue.  With the existing extension APIs, it is possible but clumsy to implement functions like [rerunning failing test](https://github.com/artsok/rerunner-jupiter) or things like:  ```java @Test @ExpectedException(RuntimeException.class) pulic void testException() {   throw new RuntimeException(); } ```  Something like an `AroundEachCallback` would be quite helpful. Usage should be something like this:  ```java public class RerunningExtension implements AroundEachCallback {   @Override   public void aroundTestMethod(Executable testIncludingBeforeAndAfter, ExtensionContext context) {     while (cnt++ < getMaxNumberOfExecutions && failureExists) {       try {         failureExists = false;         testIncludingBeforeAndAfter.execute();       } catch (Exception e) {         failureExists = true;       }     }   } } ```  ## Related Issues  - #20  - #157","closed","component: Jupiter,","mibutec","2018-06-02T19:37:07Z","2018-06-03T11:26:10Z"
"","1112","Repeated meta-annotations of @ArgumentsSource requires the @ArgumentsSource at test location","## Overview  I was writing up an example for https://github.com/junit-team/junit5/issues/1101 which contains an example like this:  ```java     @ParameterizedTest // still required?     @Parameter(10, ""10000"")     @Parameter(20, ""20000"")     @Parameter(30, ""30000"")     void calculate(int input, String expected) {         assertThat(Integer.toString(input*1000)).isEqualTo(expected);     } ```  Where `@Parameter` contains something like `@ArgumentsSource(ParameterSource.class)`. Running this yields an exception with `org.junit.platform.commons.util.PreconditionViolationException: Configuration error: You must provide at least one argument for this @ParameterizedTest`.  Here is an example that reproduces the issue:  * Annotation     ```java     import org.junit.jupiter.params.provider.ArgumentsSource;          import java.lang.annotation.Repeatable;     import java.lang.annotation.Retention;     import java.lang.annotation.RetentionPolicy;          @Retention(RetentionPolicy.RUNTIME)     @ArgumentsSource(MetaCustomSource.class)     @Repeatable(ExampleMetaCustomSources.class)     public @interface ExampleMetaCustomSource {       int value();     }     ``` * Repeatable annotation     ```java     import java.lang.annotation.Retention;     import java.lang.annotation.RetentionPolicy;      @Retention(RetentionPolicy.RUNTIME)     public @interface ExampleMetaCustomSources {       ExampleMetaCustomSource[] value();     }     ``` * `ArgumentsProvider` Extension implementation     ```java     import org.junit.jupiter.api.extension.ExtensionContext;     import org.junit.jupiter.params.provider.Arguments;     import org.junit.jupiter.params.provider.ArgumentsProvider;     import org.junit.platform.commons.support.AnnotationSupport;          import java.util.List;     import java.util.stream.Stream;          public class MetaCustomSource implements ArgumentsProvider {       @Override       public Stream provideArguments(final ExtensionContext context) throws Exception {         return context.getElement()                       .map(annotatedElement -> AnnotationSupport.findRepeatableAnnotations(annotatedElement, ExampleMetaCustomSource.class)).map(             List::stream)           .map(stream -> stream.map(annotation -> Arguments.of(annotation.value())))           .orElse(Stream.empty());       }     }     ``` * Test class     ```java     import org.junit.jupiter.params.ParameterizedTest;     import org.junit.jupiter.params.provider.ArgumentsSource;          class MetaCustomSourceParameterizedTestExample {       @ParameterizedTest       @ExampleMetaCustomSource(1)       void singleMetaTest(int value) {       }            @ParameterizedTest       @ExampleMetaCustomSource(1)       @ExampleMetaCustomSource(2)       @ExampleMetaCustomSource(3)       void multipleMetaTestNoArgumentsSource(int value) {       }            @ParameterizedTest       @ArgumentsSource(MetaCustomSource.class)       @ExampleMetaCustomSource(1)       @ExampleMetaCustomSource(2)       @ExampleMetaCustomSource(3)       void multipleMetaTestWithArgumentsSource(int value) {       }     }     ```  _Results_  ![Test results output](https://user-images.githubusercontent.com/1447148/31622975-95e27fc2-b263-11e7-9d20-1847a634ed82.png)  Stacktrace from IntelliJ:  ```  org.junit.platform.commons.util.PreconditionViolationException: Configuration error: You must provide at least one argument for this @ParameterizedTest  	at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:285) 	at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$6(ParameterizedTestExtension.java:58) 	at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:271) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1380) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:86) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:36) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:83) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:51) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:62) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ```  Also, in addition, IntelliJ doesn't detect meta `@ArgumentSource` implementations  ## Deliverables  - [ ] `@Repeatable` annotations containing meta-annotation of `@ArgumentsSource` should work without annotating `@ParameterizedTest` with  `@ArgumentsSource(ImplementingClass.class`","closed","component: Jupiter,","mkobit","2017-10-16T16:19:06Z","2019-07-19T10:16:13Z"
"","1571","junit-json-params","## Overview  I was thinking about the CsvSource a while back and how JSON is sometimes a more convenient / expressive format to write data in, particularly when dealing with the input and output of web based APIs. So I created a small library, [junit-json-params](https://github.com/joshka/junit-json-params), which achieves this.  I'm wondering whether this is something that would be considered for being added to the JUnit project? If not, commenting here mainly for a little visibility on the library (and a call out for ideas to make this better).","closed","3rd-party: Pioneer,","joshka","2018-08-31T07:12:16Z","2018-09-02T16:40:02Z"
"","1627","How I can run code After all tests in Parallel?","## Overview  I try to run my tests in parallel via Maven **forkCount-${threadCount}** and **reuseForks-false** but unsuccessfully.  - ( ) **Bug report.** Currently, when I use **TestExecutionListener** his method **testPlanExecutionStarted** exeute after each class. I found a little information about this problem, but I can't find the solve.   - ( ) **Feature request.** I tried to use **Runtime.getRuntime().addShutdownHook** but it works like **testPlanExecutionStarted** - after each test class.   `object ShutDownHook {     @JvmStatic     fun main(args: Array) {         Runtime.getRuntime().addShutdownHook(object : Thread() {             override fun run() {                 println(""Shutdown Hook is running !"")             }         })         println(""Application Terminating ..."")     } }`  Also I tried to use **Launcher**  and it was successfully!  But it is really uncomfortable method! I can't see tests result and always run my tests via this construction is bad idea  `object Main {     @JvmStatic     fun main(args: Array) {         val launcherConfig = LauncherConfig.builder()                 .enableTestExecutionListenerAutoRegistration(false)                 .addTestExecutionListeners(TestListener())                 .build()         val launcher = LauncherFactory.create(launcherConfig)         val request = LauncherDiscoveryRequestBuilder.request()                 .selectors(selectPackage(""test.users""))                 .configurationParameter(""junit.jupiter.execution.parallel.enabled"", ""true"")                 .filters(TagFilter.includeTags(""regress""))                 .build()         launcher.execute(request)     } }`  - ( ) **Question.** Please tell me, how I can run my code after all tests which run in parallel. Maybe JUnit has a some annotation like **@AfterAllTests**... I don't understand, why **TestNG** can do it but JUnit can't...","closed","","romsper","2018-10-08T13:39:10Z","2018-10-08T16:07:28Z"
"","1603","@DisabledOnOs does not work on Solaris","## Overview  I tired to disable a junit jupiter test on Solaris (5.10 and 5.11) using   ``` @DisabledOnOs(OS.SOLARIS) ```  but the test was still executed afterwards.  I had a quick look at the implementation and it looks like the solaris detection for Solaris seems to be the problem (org.junit.jupiter.api.condition.OS#determineCurrentOs).  'os.name' seems to return `SunOS`.  I can come up with a pr for this one later on today.","closed","component: Jupiter,","epeee","2018-09-28T08:14:01Z","2018-11-16T20:30:46Z"
"","1368","Description error in JavaDoc for TestExecutionListener interface","## Overview  I think that there is a little error in the [description of the `TestExecutionListner` interface](https://junit.org/junit5/docs/current/api/org/junit/platform/launcher/TestExecutionListener.html).  > Register an instance of **this class** with a Launcher to be notified of events that occur during test execution.   should be   > this interface   instead of   > this class","closed","theme: documentation,","roussi","2018-04-13T12:55:08Z","2018-04-13T13:04:35Z"
"","1192","Support @ParameterizedTest in conjunction with @TestFactory","## Overview  I started to write some dynamic tests, and now it would be handy to reuse some `@ParameterizedTest` functionality I already implemented.  Take a look at this example:  ```java   @ParameterizedTest(name = ""{0}"")   @ArgumentsSource(ClassArgumentsProvider.class)   @TestFactory   Stream apiGuards(Class c) {     return ApiGuardHelper.checkGuards(() -> EnhancedRandom.random(c));   } ```  This should generate some dynamic tests for each class found in the package, but sadly the `@ParameterizedTest` annotation is not supported with a `@TestFactory` method.  Kind regards, Michael  ## Related Issues  - #871 - #878","closed","theme: dynamic tests,","reitzmichnicht","2017-11-29T16:39:15Z","2020-08-08T11:11:38Z"
"","1070","Generate “Use” links in API JavaDoc","## Overview  I performed a similar task for Spring: https://jira.spring.io/browse/SPR-15427   ## Deliverables  - [x] Generate “Use” links in API JavaDoc","closed","theme: documentation,","sbrannen","2017-09-20T19:20:55Z","2017-09-22T13:52:45Z"
"","1128","Difference between JUnit 4 and Jupiter when using rules and ExternalResourceSupport","## Overview  I noticed that in Jupiter tests a rule is not picked up when a method is annotated with `@Rule` and the return type is a subclass of `ExternalResource`. Here is an example test case for JUnit Jupiter:  ```java import org.junit.Rule; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.migrationsupport.rules.ExternalResourceSupport; import org.junit.rules.ExternalResource; import org.junit.rules.TestRule;  @ExtendWith(ExternalResourceSupport.class) class RuleJUnit5Test {      @Rule     public ExampleExternalResourceRule getExampleExternalResourceRule() {         return new ExampleExternalResourceRule(""ExampleExternalResourceRule"");     }      @Rule     public ExternalResource getExternalResource() {         return new ExampleExternalResourceRule(""ExternalResource"");     }      @Rule     public TestRule getTestRule() {         return new ExampleExternalResourceRule(""TestRule"");     }      @Test     void test() {     }      public static class ExampleExternalResourceRule extends ExternalResource {          private String identifier;          ExampleExternalResourceRule(String identifier) {             this.identifier = identifier;             System.out.println(identifier + "" init"");         }          @Override         protected void before() throws Throwable {             System.out.println(identifier + "" before"");         }          @Override         protected void after() {             System.out.println(identifier + "" after"");         }     }  } ```  And an equivalent JUnit 4 test case : ```java import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExternalResource; import org.junit.rules.TestRule;  public class RuleJUnit4Test {      @Rule     public ExampleExternalResourceRule getExampleExternalResourceRule() {         return new ExampleExternalResourceRule(""ExampleExternalResourceRule"");     }      @Rule     public ExternalResource getExternalResource() {         return new ExampleExternalResourceRule(""ExternalResource"");     }      @Rule     public TestRule getTestRule() {         return new ExampleExternalResourceRule(""TestRule"");     }      @Test     public void test() {     }      public static class ExampleExternalResourceRule extends ExternalResource {          private String identifier;          ExampleExternalResourceRule(String identifier) {             this.identifier = identifier;             System.out.println(identifier + "" init"");         }          @Override         protected void before() throws Throwable {             System.out.println(identifier + "" before"");         }          @Override         protected void after() {             System.out.println(identifier + "" after"");         }     }  } ```  Console output JUnit Jupiter: ``` ExternalResource init ExternalResource before TestRule init TestRule before TestRule init TestRule after ExternalResource init ExternalResource after ```  Console output JUnit 4: ``` ExampleExternalResourceRule init ExternalResource init TestRule init TestRule before ExternalResource before ExampleExternalResourceRule before ExampleExternalResourceRule after ExternalResource after TestRule after ```  For one the rule with a return type of `ExampleExternalResourceRule` is not used in the Jupiter case. And secondly the rule methods are called twice.","closed","component: Jupiter,","BlueIce","2017-10-26T20:31:07Z","2017-11-05T17:33:43Z"
"","1454","Introduce extension APIs to handle exceptions from lifecycle callback methods","## Overview  I need to handle exceptions thrown during the execution of each `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach` method.  There are [test lifecycle callbacks](https://junit.org/junit5/docs/current/user-guide/#extensions-lifecycle-callbacks). Just for error tracking needs these callbacks are useful, but if I need to capture AUT (application under test) state (for example to take an application screenshot, log current condition) at exception time, then these callbacks are not enough, because application state is changed before execution reaches the callback.  Let's say an exception occurs in a `@BeforeEach` method. I need to take an application screenshot at this exception. The nearest callback to handle the exception is `AfterEachCallback`. So application state is changed in `@AfterEach` method, and we lose original screen of application in `AfterEachCallback`. I reference to the [diagram here](https://junit.org/junit5/docs/current/user-guide/#extensions-execution-order).  ## Proposal  Introduce the following additional _callback_ extension APIs which will be invoked after each `@BeforeAll`, `@AfterAll`, `@BeforeEach` and `@AfterEach` method. This make it possible to handle exceptions and take application screenshots at the correct point in time.  - `AfterBeforeAllCallack` - `AfterAfterAllCallback` - `AfterBeforeEachCallback` - `AfterAfterEachCallback`","closed","type: new feature,","beluha","2018-06-06T14:13:39Z","2019-06-06T08:54:08Z"
"","1127","Nest test log output under test logging tree","## Overview  I may be asking for the moon here due to technological limitations. However, I figure that I should pose this anyways.  I really love the Junit5 tree structured logging output.  However, when you have test logging scattered throughout that code it breaks how it looks.  For example: ``` │  │  ├─ runSSLinkRemovalTest2() │  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest]/[method:runSSLinkRemovalTest2()] │  │  │     parent: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest] │  │  │     source: MethodSource [className = 'com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest', methodName = 'runSSLinkRemovalTest2', methodParameterTypes = ''] │  │  │   duration: 1 ms │  │  │     status: ✔ SUCCESSFUL │  │  ├─ runSSLinkRemovalTest3() │  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest]/[method:runSSLinkRemovalTest3()] │  │  │     parent: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest] │  │  │     source: MethodSource [className = 'com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest', methodName = 'runSSLinkRemovalTest3', methodParameterTypes = ''] │  │  │   duration: 0 ms │  │  │     status: ✔ SUCCESSFUL │  │  ├─ runShortestPathFromSourceTest() │  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest]/[method:runShortestPathFromSourceTest()] │  │  │     parent: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest] │  │  │     source: MethodSource [className = 'com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest', methodName = 'runShortestPathFromSourceTest', methodParameterTypes = ''] 13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 0.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 1.5     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 3.5     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest -  13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 6.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 0.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 2.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest -  13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 4.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 5.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 0.0     13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest -  │  │  │   duration: 1 ms │  │  │     status: ✔ SUCCESSFUL │  │  ├─ runSSLinkAdditionTest1() │  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest]/[method:runSSLinkAdditionTest1()] │  │  │     parent: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest] │  │  │     source: MethodSource [className = 'com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest', methodName = 'runSSLinkAdditionTest1', methodParameterTypes = ''] │  │  │   duration: 2 ms │  │  │     status: ✔ SUCCESSFUL ```  This would look much better if It could be formatted like this instead:  ``` │  │  ├─ runShortestPathFromSourceTest() │  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest]/[method:runShortestPathFromSourceTest()] │  │  │     parent: [engine:junit-jupiter]/[class:com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest] │  │  │     source: MethodSource [className = 'com.plexxi.fitting.algorithm.shortestpath.FlowAlgorithmsModelTest', methodName = 'runShortestPathFromSourceTest', methodParameterTypes = ''] │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 0.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 1.5     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 3.5     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest -  │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 6.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 0.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 2.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest -  │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 4.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 5.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest - 0.0     │  │  │   13:02:44.153 [main] DEBUG c.p.f.a.s.FlowAlgorithmsModelTest -  │  │  │   duration: 1 ms │  │  │     status: ✔ SUCCESSFUL │  │  ├─ runSSLinkAdditionTest1() │  │  │       tags: [] ```  I'm assuming that the only way that this would be possible is if you could pass a custom logger implementation into the class under test for this to work correctly but it may be worth it for some people in order to get cleaner log outputs.  ## Deliverables  - [ ] Decision on feasibility of hijacking logged output to produce structured output. - [ ] Implementation of feature. - [ ] Updated user guide describing how to enable feature","closed","","JLLeitschuh","2017-10-25T17:16:27Z","2017-10-29T16:11:05Z"
"","1548","Set jmh's fork=1 and fix too long command line on Windows","## Overview  I have seen a jmh warning about ```fork=0``` and found the [too long command line on Windows has been fixed](https://github.com/melix/jmh-gradle-plugin/issues/107).  This patch set ```fork=1```.  Remark : I have not tested on Windows  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","fduminy","2018-08-14T19:36:32Z","2021-08-17T09:35:37Z"
"","1853","Issue: #1851 Support assertThrows() with suspending functions in Kotlin","## Overview  I have modified the assertThrows() functions to accept suspending functions as body. This means now all functions using the suspend modifier for a function can be used by this API as well. Conventional methods without suspend modifier can be passed as well, not resulting in different behaviour.  This should now be possible:  ``` suspend fun test(): Nothing = throw Exception()  assertThrows {     test() } ```  Few topics open for discussion:  - Util.kt added to provide suspending functions to assert failures, not sure if this is the most optimal place. Could be added to relevant tests as well as private functions, I am not totally sure.  Resolves #1851.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","DerkSchooltink","2019-04-09T14:50:13Z","2020-02-19T13:08:32Z"
"","1154","Introduce extension API for expression language evaluation in display names","## Overview  I have found that it would be useful if you could use argument fields as a part of parametrized test name. Right now, when using just `{0}` as described in docs, it results in injecting into a test name string in form of `ClassName(fieldName1=fieldValue1, fieldName2=fieldValue2, ...)`. But that doesn't seen readable at all especially then you have a class with more than just few fields. Now I would like to be able to use some semantics as `{0.name}` or `{0}.name` to use just name field of class used as test method argument, so I can write test name as follows:  ``` java @BeerTest class BeerConversionServiceTest {      @Autowired     private BeerConversionService beerConversionService;      private static Stream createBeers() {         return Stream.of(                 Arguments.of(new Beer(...), 25L),                 Arguments.of(new Beer(...), 50L)         );     }      @DisplayName(""Get alcohol content of a beer in mg"")     @ParameterizedTest(name = ""Alcohol content of {0.name} should be equal to {1}"")     @MethodSource(""createBeers"")     void getAlcInMg(Beer beer, long mg) {         Assertions.assertEquals(beerConversionService.getAlcInMg(beer), mg);     }  } ```  This would give users possibility to keep test names simple, yet still descriptive, as they could reference objects passed as arguments and use only parts of them which identifies test cases.  I didn't look into the source code so I cannot tell which approach would be easier to implement but I would guess that `{0.name}` seems more reasonable.  ## Deliverables  - [ ] Introduce an SPI (similar to what has been [proposed above](https://github.com/junit-team/junit5/issues/1154#issuecomment-345445625)) and provide a SpEL-based and/or OGNL-based implementation. - [ ] Ensure that display names for `@ParameterizedTest` and `@RepeatedTest` can make use of the same facility (see #2452).","open","component: Jupiter,","DcortezMeleth","2017-11-11T10:55:09Z","2022-06-20T18:20:07Z"
"","1250","JavaElementsResolver should not warn about abstract classes with test methods","## Overview  I have an [abstract base class](https://github.com/jenkinsci/analysis-model/blob/master/src/test/java/edu/hm/hafner/analysis/AbstractParserTest.java) that contains a test case. When I run the tests using maven then the class `org.junit.jupiter.engine.discovery.JavaElementsResolver` logs the warning:   ``` WARNUNG: Class 'edu.hm.hafner.analysis.AbstractParserTest' could not be resolved."" ``` Expected behavior: there should be no warning.  Versions: Java 8 Maven 3.5.2 pom.xml (relevant part):  ```xml     1.0.2     5.0.2     2.19.1                                 org.apache.maven.plugins           maven-surefire-plugin           ${surefire.maven.plugin}                                       org.junit.platform               junit-platform-surefire-provider               ${junit.surefire.provider}                                         org.junit.jupiter               junit-jupiter-engine               ${junit.version}                                    ```  ## Deliverables  - [Example project](https://github.com/jenkinsci/analysis-model/) - [Example maven log](https://ci.jenkins.io/job/Plugins/job/analysis-model/job/master/94/consoleText)","closed","3rd-party: Maven Surefire,","uhafner","2018-01-19T10:54:49Z","2018-01-19T15:08:51Z"
"","1450","Introduce support for grouping tests with @TestTemplate","## Overview  I have a `@TestTemplate` method, which tests a group of classes that are different implementations of the same `interface`. The test method is extended with multiple `TestTemplateInvocationContextProvider`-s, each providing the different implementation, with their own test cases.  I'd like to have a way give them a parent dynamically, so the different classes (`TestTemplateInvocationContextProvider`s) can show up in their own lists, without writing new test cases, for every single one of them.  My goal is to make the test results easier to handle, by grouping them together, so they are not in the same list. (especially since they can have a lot of cases)  ## Proposal  Make `TestTemplateInvocationContextProvider` have a method, (`getGroup`, or `getParent` are my suggestions) return a String which is the name used as the `display name` of the parent of every test provided by it. The parent class value for this test can either be set to nothing, the actual parent class, or the extension's class.  Returning null, results in the current behavior.","closed","status: stale,","Frontrider","2018-06-05T14:38:05Z","2021-06-03T20:47:14Z"
"","1444","Introduce Extension API for registering dynamic tests","## Overview  I currently have a JUnit 4 based [custom `Suite`](https://github.com/xwiki/xwiki-rendering/blob/2e7af2e60fd6661ec48142324cd3fe10411fe0bc/xwiki-rendering-test/src/main/java/org/xwiki/rendering/test/integration/RenderingTestSuite.java#L78) which automatically registers new tests to the JUnit runner and which allows to write very simple tests:  ```java @RunWith(RenderingTestSuite.class) public class IntegrationTests { } ```  The custom suite reads `*.test` files found in the CL's classpath and generates dynamic tests from them.  I'd like to move this to JUnit 5, but I'm a bit stuck ATM since it seems the best approach would be to use some test factory or parameterized test, but this would require each of my tests to declare a test method with something like:  ```java class IntegrationTests {     @TestFactory    Stream renderingTests() {            return RenderingTestSuite.generateStreamOfDynamicTests();    } } ```  I'd really like my tests to remain as simple as the following (and this without duplication):  ```java @ExtendWith(RenderingExtension.class) public class IntegrationTests { } ```  PS: I've also asked the question on [Gitter](https://gitter.im/junit-team/junit5?at=5b142454c712f5612555bfcc) (which contains additional details).  ## Related Issues  - #371","open","theme: dynamic tests,","vmassol","2018-06-04T08:13:14Z","2022-07-12T07:51:59Z"
"","1808","JUnit 5 ignores parameterized tests that are annotated with @MethodSource","## Overview  I am using JUnit Jupiter 5.4.0.  When I call `gradle clean test build`, JUnit doesn't run my parameterized tests that are annotated with `@MethodSource`.  It runs my other unit tests though, and I can run the parameterized tests that are annotated with `@MethodSource` from IntelliJ IDEA.  For example, this test will run when I call `gradle clean test build`: ```java     @Test     @DisplayName(""Test the parser of BuiltInArgumentType.ANY"")     void testAnyType() {         Assertions.assertEquals(             ""Croissant"",             BuiltInArgumentType.ANY.getType().getParser().parse(                 ""Croissant"",                 new String[] { ""Croissant"" },                 0             )         );     } ```  But this one won't: ```java     static Stream testBooleanTypeProvider() {         return Stream.of(             Arguments.arguments(true, ""true""),             Arguments.arguments(false, ""false""),             Arguments.arguments(null, ""Croissant"")         );     }      @ParameterizedTest     @MethodSource(""testBooleanTypeProvider"")     @DisplayName(""Test the parser of BuiltInArgumentType.BOOLEAN ({index}/3)"")     void testBooleanType(final Boolean expected, final String value) {         Assertions.assertEquals(             expected,             BuiltInArgumentType.BOOLEAN.getType().getParser().parse(                 value,                 new String[] { value },                 0             )         );     } ```  Both tests are written in the same class.  Note that I said that it just **won't run.** Not that I will get an error or something. It won't even appear in the test summary generated by Gradle.  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.4.0  - Build Tool: Gradle","closed","3rd-party: Gradle,","overmighty","2019-03-11T21:16:56Z","2019-03-12T11:58:48Z"
"","1372","Both junit-jupiter-engine and a custom registered engine are run in IDEA","## Overview  I am trying to create my own implementation of TestEngine, MyCustomExecutionEngine. I want to re-use the discovery mechanism from JupiterTestEngine and just do a custom execute() implementation. Hence, I want the test junit-jupiter-engine present as a dependency. But, I don't want the junit-jupiter-engine to run, I want only my custom engine to run.  ## Problem  - I register MyCustomExecutionEngine in META-INF/services/org.junit.platform.engine.TestEngine  - I run a test class from IDEA. The test class and my custom engine implementation are in the same project.  - Because the implemented methods in MyCustomExecutionEngine are empty I get this warning (twice): > WARNING: TestEngine with ID 'my-custom-engine' failed to discover tests - But then the tests are run after all. - When debugging, in DefaultLauncher#discoverRoot (called twice) I can see that testEngines iterable contains three engines: MyCustomExecutionEngine, JupiterTestEngine, and VintageTestEngine.  - If I completely remove junit-jupiter-engine as a dependency the problem is solved.    ## Versions  - Junit 5.1.0 - IDEA 2017.3.4","closed","status: stale,","igorstojanovski","2018-04-15T07:56:27Z","2022-07-02T11:53:06Z"
"","1062","Should ConditionEvaluationResult be a final class?","## Overview  I am in the process of prototyping a `@Retry` type annotation to run a test a certain number of times based on failures. I was looking at [`ConditionEvaluationResult`](https://github.com/junit-team/junit5/blob/0e0a3dbfb17568e3d9ce7e01552f304c78fb3354/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ConditionEvaluationResult.java) and noticed it was not a `final` class. This leaves it open for inheritance and possible breaking changes further down the line if other conditional test result types are supported (maybe Skipped?)  I wasn't sure if it was open by design or if the direction I could see it going doesn't align with what the team thinks.  ## Deliverables  - [ ] Make `ConditionEvaluationResult` a `final` class","closed","status: invalid,","mkobit","2017-09-13T20:42:31Z","2017-09-15T15:32:30Z"
"","1665","Cannot provide multidimensional array as argument with @MethodSource","## Overview  I am attempting to pass two-dimensional arrays of primitives to a parameterized test. The one-dimensional array works as expected, but JUnit complains on the second with ""Error resolving parameter at index 0"". This is on JUnit Jupiter 5.1.0.  [According to Sormuras](https://stackoverflow.com/questions/53133979/can-multidimensional-arrays-be-passed-via-methodsource-junit-5-1), on `5.4.0-SNAPSHOT`, the error message reads: `org.junit.jupiter.api.extension.ParameterResolutionException: Error converting parameter at index 0: No implicit conversion to convert object of type [I to type [[I`   see the snippet below  ## Steps to reproduce  ```java // This is ok static Stream arrayStream1(){     return Stream.of( new int[] {1}, new int[] {2}); }  @ParameterizedTest @MethodSource(""arrayStream1"") void test1(int[] par) {     assertTrue(true); }  // This is not static Stream arrayStream2(){     return Stream.of( new int[][] {{1,2}}, new int[][] {{2,3}}); }  @ParameterizedTest @MethodSource(""arrayStream2"") void test2(int[][] par) {     assertTrue(true); }    ```  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit 5.1.0  - Build Tool/IDE: Eclipse 4.9.0  ## Deliverables  - [x] Ensure that streams of multidimensional arrays (e.g., `Stream` may be returned from `@MethodSource` factory methods. - [x] Document in Release Notes","closed","theme: parameterized tests,","thauer","2018-11-03T18:32:00Z","2018-11-20T11:59:06Z"
"","1012","Bump Gradle to version 4.1","## Overview  https://docs.gradle.org/4.1/release-notes.html  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","JLLeitschuh","2017-08-08T23:53:31Z","2017-08-10T14:07:55Z"
"","1577","DisplayName with Test feature idea","## Overview  Hi, junit5 is a great piece of software. Today I realized while testing that a lot of time doing unit testing the `@DisplayName` is almost the same as a name of method. I mean there are many schools how the name of method should look like, but for example, let's take a look at this one below:  `methodName_StateUnderTest_ExpectedBehavior`  And here is my idea - create a flag, for example `Test(xxx=true)` or `Test(xxx=""_"")` or `DisplayName(xxx=""_"") `which will use the name of method. The final result may look like this:  `parse_WithEmptyString_ThrowIllegalArgumentException` will be converted to `parse with empty string throw illegal argument exception`  Let me know what you think.","closed","component: Jupiter,","rafalschmidt97","2018-09-05T16:10:45Z","2018-09-05T17:15:46Z"
"","1918","Cleaning","## Overview  Hello. I did some small cleaning in your repositories (simple and small changes) in Java code. Maybe you can use one or more. Have a nice day! List of changes: - add final keywords - remove unnecessary keywords and semicolons - simplify return statements - create negate methods - replace Optional = null by Optional.empty() - simplify:     - list initialization     - create String from bytes read from file as Files.readString(xmlFile)     - replace !Optional.isPresent() by Optional.isEmpty()     - replace String.valueOf(c) by c in String creation // char c  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","BielinskiLukasz","2019-06-05T19:50:25Z","2019-06-06T13:24:10Z"
"","1191","Support aggregation of arguments into a single object for parameterized tests","## Overview  Hello there Java testers.  I started working with JUnit 5 a few days ago because I loved the new way of creating parameterized tests.  There's `@ParameterizedTest` that allows a test to run in a parameterized fashion and `@CsvFileSource` that loads the parameters from a CSV file.  The thing is that I have too many columns in my CSV and don't want to have a huge method signature in my unit test. Let me give you an example:  ```java     @ParameterizedTest     @CsvFileSource(resources = ""/person-data.csv"")     void myTest(String p1, String p2, String p3, String p4, String p5, String p6) {         // test using parameters     } ```  It would be awesome to have some kind of annotation that would allow us to do something like this:  ```java     @ParameterizedTest     @CsvFileSource(resources = ""/person-data.csv"")     void myTest(@ConvertWith(PersonConverter.class) Person person) {         // test using parameters     }          static class PersonConverter implements AggregatingConverter {         public Person convert(Object ... params){            // a simple method that creates the Person object and inserts the params in it         }     } ```  I believe that this improvement would be much welcomed by our community.  Happy coding and stay awesome!  ## Deliverables  - [x] Decide what semantics are supported in terms of mixing indexed arguments, aggregators, and arguments resolved by other `ParameterResolver` implementations (e.g., `TestInfo`). - [x] Introduce `ArgumentsAccessor` API. - [x] Introduce `ArgumentsAggregator` API along with `@AggregateWith` annotation.    - [x] Allow `@AggregateWith` to be used as a meta-annotation.    - [x] Ensure that additional arguments (e.g., `TestInfo`) can be supplied to a parameterized test method that makes use of these aggregation features. - ❌  Consider introducing a `setIndexOffset(int)` method in `ArgumentsAccessor` that makes it easier to reuse existing position-based logic for input sets that are occasionally shifted to the right by a given _offset_ (i.e., `n` indexes). - [x] Document in Release Notes.   - [x] Documentation exists but can be improved -- for example, cross referencing sections from the User Guide. - [x] Document in User Guide.   - [x] Documentation exists but can be improved.","closed","theme: parameterized tests,","klassounski-daitan","2017-11-29T15:14:12Z","2018-04-14T23:57:31Z"
"","1465","Should static @BeforeAll/@AfterAll methods in class annotated with @TestInstance(PER_CLASS) be executed if constructor throws exception?","## Overview  Given a test class annotated with `@TestInstance(PER_CLASS)` with `static` `@BeforAll` and `@AfterAll` methods, if the constructor for the test class throws an exception, these callback methods are currently not executed.  Technically there is no restriction why these would not run (since an instance of the test class is not required to execute `static` methods in that class), so it is a matter of design what the expected behavior here would be.    - On the one hand, having a `PER_CLASS` class failing on the constructor suggests a major problem that warrants aborting everything. Also why run `@BeforeAll` of `@AfterAll` when we have run no tests?   - On the other hand, this seems inconsistent with what JUnit Jupiter does for classes that are instantiated _per method_ where a failing constructor does not affect the execution of methods annotated with `@BeforeAll` or `@AfterAll`.  So I personally consider this as unexpected behavior.  This was discussed in #1460 and refers to point _b)_ in comment https://github.com/junit-team/junit5/issues/1460#issuecomment-395965906  ## Deliverables  - [ ] Clarify what the expected behavior in this case is. - [ ] Document the expected behavior in the User Guide - [ ] Review if automated tests currently cover the expected behavior.","closed","status: stale,","gaganis","2018-06-14T11:23:19Z","2021-06-19T12:50:31Z"
"","998","Fix thread-safety issue in ExtensionValuesStore","## Overview  getOrComputeIfAbsent() was accessing the parent store's map without acquiring the parent's lock.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","kcooney","2017-07-30T20:40:58Z","2017-08-23T17:53:24Z"
"","1060","Generate parameter documentation for console launcher automatically","## Overview  Generate parameter documentation for console launcher automatically. No longer have two places where parameters and descriptions have to be maintained.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","signed","2017-09-13T00:21:38Z","2017-11-23T20:12:29Z"
"","1644","Expose selected modifier related methods from ReflectionUtils","## Overview  For the [Testcontainers extension](https://github.com/testcontainers/testcontainers-java/pull/887) I needed to use some APIs from `ReflectionUtils` to find out whether annotated fields are declared `static` or not.  Since `ReflectionUtils` is considered a private API it would be nice to have an official API for this. I decided to create a dedicated class to work with modifiers of classes and fields: `ModifierSupport`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","britter","2018-10-22T15:07:08Z","2018-10-23T10:14:54Z"
"","1130","Maven surefire provider NPE w/ the Spek TestEngine","## Overview  For some reason running tests in maven: `mvn -e test`, causes an NPE when using Spek. It works for JUnit 5 (Jupiter), are we doing something wrong when implementing the Spek `TestEngine`?  ``` [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test (default-test) on project spek-with-maven-sample: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test failed. NullPointerException -> [Help 1] org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test (default-test) on project spek-with-maven-sample: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test failed.         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)         at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356) Caused by: org.apache.maven.plugin.PluginExecutionException: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.19.1:test failed.         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:145)         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)         ... 20 more Caused by: java.lang.NullPointerException         at org.apache.maven.plugin.surefire.report.DefaultReporterFactory.printTestFailures(DefaultReporterFactory.java:346)         at org.apache.maven.plugin.surefire.report.DefaultReporterFactory.runCompleted(DefaultReporterFactory.java:137)         at org.apache.maven.plugin.surefire.report.DefaultReporterFactory.close(DefaultReporterFactory.java:106)         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:208)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1026)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:862)         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:755)         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)         ... 21 more ```  Full detail of the issue can be found here:  https://github.com/spekframework/spek/issues/303  Also a demo project can be found here: https://github.com/devonhumes/spek-kotlin-maven-error-output-null.  ## Deliverables","closed","3rd-party: Maven Surefire,","raniejade","2017-10-30T03:57:33Z","2017-11-05T17:33:58Z"
"","1346","JUnit 5 depletes heap for Maven tests","## Overview  For some reason or another, trying to run a suite of tests for a project depletes the heap in the jvm, but only when running the suite, and only when all the tests are there. For the sake of keeping the issue clean, I've created gists with code and output in them and will link where needed.  [This](https://gist.github.com/huffstler/8a6b441703e816c3e7e2df93bb1a2aa3#file-etlprops-java) is one of two test classes I have. Running the test _suite_ outputs this error currently:   ``` bash mvn -X deploy  ``` [output](https://gist.github.com/huffstler/8a6b441703e816c3e7e2df93bb1a2aa3#file-mvn-x-deploy) (Picture of ram usage to go with output) ![ram_usage](https://user-images.githubusercontent.com/9092204/37988713-a01cec0c-31cf-11e8-916b-877d1190c5aa.PNG)   _However_, running just `ETLPropsTest.java` produces [this output](https://gist.github.com/huffstler/8a6b441703e816c3e7e2df93bb1a2aa3#file-running_only_etlpropstest) instead.  TL;DR: The functions and fields need to be static.  Now, commenting out the blank tests in the first file I linked (`ETLPropsTests.java`) and leaving only the code that actually does something lets the entire suite pass.  [Like so](https://gist.github.com/huffstler/8a6b441703e816c3e7e2df93bb1a2aa3#file-commentedout-java).   I would have expected that removing tests that don't do anything wouldn't affect the memory usage when testing, but that doesn't seem to be the case.  I honestly can't tell currently if this is a Maven or JUnit issue right now (tbh, it's probably user error) so I'll open up an issue with Apache Maven and link it over for consistency.","closed","3rd-party: Maven Surefire,","huffstler","2018-03-27T19:07:16Z","2018-06-30T06:11:39Z"
"","1597","Remove junit-platform-surefire-provider","## Overview  Following-up from #1536, which deprecated the `junit-platform-surefire-provider`, it now can be removed.  ## Deliverables  - [x] Delete subproject `junit-platform-surefire-provider` - [x] Remove `junit-platform-surefire-provider` references in build scripts - [x] Remove `junit-platform-surefire-provider`-related documentation from User-Guide","closed","3rd-party: Maven Surefire,","sormuras","2018-09-24T04:14:17Z","2018-09-27T12:20:49Z"
"","1266","Enable error-prone static analysis checks","## Overview  Following issue #955 and closed PR #961, this is a PR to introduce error-prone checks to JUnit 5.  Feedback is welcome!  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jbduncan","2018-01-25T21:52:37Z","2018-03-15T01:57:17Z"
"","1863","Move PreconditionViolationException to commons base package","## Overview  Follow-up from #1857   ## Deliverables  - [x] Deprecate `PreconditionViolationException` in package `org.junit.platform.commons.util` in favor a new sibling of `JUnitException` in the exported package `org.junit.platform.commons`.","closed","theme: modules,","sormuras","2019-04-14T18:52:44Z","2019-04-29T06:52:37Z"
"","1572","Ignore non-JUnit engines that use the `junit-` prefix for their IDs","## Overview  Follow-up from #1557 which introduced a warning when a TestEngine ID starts with `junit-`, except those published by the JUnit Team from the JUnit 5 repository for public consumption.  ## Deliverables  - [ ] Ignore such engines","open","component: Platform,","sormuras","2018-08-31T09:22:28Z","2022-07-12T08:03:47Z"
"","1626","Remove cyclic package references","## Overview  Follow-up from #1437  Module `junit-jupiter-engine` contains cycles that can be avoided.  ```java case ""junit-jupiter-engine"":  ""org.junit.jupiter.engine.descriptor.TestInstanceLifecycleUtils -> org.junit.jupiter.engine.Constants"" ""org.junit.jupiter.engine.discovery.JavaElementsResolver -> org.junit.jupiter.engine.JupiterTestEngine"" ""org.junit.jupiter.engine.execution.ConditionEvaluator -> org.junit.jupiter.engine.Constants"" ""org.junit.jupiter.engine.extension.ExtensionRegistry -> org.junit.jupiter.engine.Constants"" ```  Module `junit-jupiter-params` _inherits_ cycles by shadowing an external library that contains cycles.  ```java case ""junit-jupiter-params"":  	line -> line.startsWith(""org.junit.jupiter.params.shadow.com.univocity.parsers.""))); ```  ## Deliverables  - [x] Configure `CyclesDetector` to ignore shadowed packages - [x] Remove cyclic references from `junit-jupiter-engine`","closed","component: Jupiter,","sormuras","2018-10-08T08:44:38Z","2018-10-11T15:23:15Z"
"","1531","Missing vertical bars in console tree","## Overview  Follow up from #1524: the console tree lacks vertical bars when a report entry is issued in the context of a container, i.e. not a test context.  Current output: ```text ╷ ├─ JUnit Jupiter ✔ │  ├─ BarTest ✔ │  │     2018-08-05T09:09:25.959 log = `started class  BarTest` │  │     2018-08-05T09:09:26.980 log = `finished class BarTest` │  │  ├─ testBar1(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBar1(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBar1(TestReporter, TestInfo)` │  │  └─ testBar2(TestReporter, TestInfo) ✔ │  │        2018-08-05T09:09:25.970 log = `started testBar2(TestReporter, TestInfo)` │  │        2018-08-05T09:09:26.972 log = `finished testBar2(TestReporter, TestInfo)` │  ├─ BazTest ✔ │  │     2018-08-05T09:09:25.959 log = `started class  BazTest` │  │     2018-08-05T09:09:28.989 log = `finished class BazTest` │  │  ├─ testBaz03(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBaz03(TestReporter, TestInfo)` ... ```  Expected output: ```text ╷ ├─ JUnit Jupiter ✔ │  ├─ BarTest ✔ │  │  │  2018-08-05T09:09:25.959 log = `started class  BarTest` │  │  │  2018-08-05T09:09:26.980 log = `finished class BarTest` │  │  ├─ testBar1(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBar1(TestReporter, TestInfo)` │  │  │     2018-08-05T09:09:26.972 log = `finished testBar1(TestReporter, TestInfo)` │  │  └─ testBar2(TestReporter, TestInfo) ✔ │  │        2018-08-05T09:09:25.970 log = `started testBar2(TestReporter, TestInfo)` │  │        2018-08-05T09:09:26.972 log = `finished testBar2(TestReporter, TestInfo)` │  ├─ BazTest ✔ │  │  │  2018-08-05T09:09:25.959 log = `started class  BazTest` │  │  │  2018-08-05T09:09:28.989 log = `finished class BazTest` │  │  ├─ testBaz03(TestReporter, TestInfo) ✔ │  │  │     2018-08-05T09:09:25.970 log = `started testBaz03(TestReporter, TestInfo)` ... ```  ## Deliverables  - [ ] Add missing vertical bars to console tree","closed","component: Platform,","sormuras","2018-08-10T16:36:04Z","2018-08-11T13:03:20Z"
"","1770","Add @API to modifier-related methods","## Overview  Follow up for #1763. Added `@API` annotations with correct `since` values for modifier-related methods in `ModifierSupport` and `ReflectionUtils`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","grossws","2019-02-10T03:43:13Z","2019-03-19T17:02:14Z"
"","1124","Update Spotless plugin from 3.5.2 to 3.6.0","## Overview  Fixes a bug regarding Kotlin files. See the plugin's changelog: https://github.com/diffplug/spotless/blob/master/plugin-gradle/CHANGES.md  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","stefanbirkner","2017-10-21T10:40:27Z","2017-10-21T15:38:42Z"
"","1605","PR: Fix Solaris OS detection for @[Enabled|Disabled]OnOs","## Overview  fixes #1603   This pr also detects `SunOS` as Solaris (e.g. used for `@DisabledOnOs`).   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","epeee","2018-09-28T15:38:55Z","2018-11-20T12:16:15Z"
"","1236","Fixes for XML reporting","## Overview  Fixes #1182. This pull request provides fixes related to XML reports emitted by `ConsoleLauncher`, Gradle plugin, and Maven Surefire.  1. Output class name also for dynamic tests and test template invocations 1. Suffix names with invocation indexes for dynamic tests and test template invocations 1. Output method parameter types also for Maven Surefire but as `testMethod{Type}` instead of `testMethod(Type)` due to a limitation of Surefire  Here's a reference test:  ```java class JUnit5Tests {    @Test   void myNormalTest() {}    @RepeatedTest(3)   void myRepeatedTest() {}    @ParameterizedTest   @ValueSource(strings = {     ""hello"",     ""world""   })   void myParametrizedTest(String s) {}    @TestFactory   Stream myTestFactory() {     return Stream.of(dynamicContainer(""foo"", Stream.of(dynamicTest(""bar"", () -> {}))));   }    @Nested   class MyNestedTest {      @Test     void myNormalTest() {}      @RepeatedTest(3)     void myRepeatedTest() {}      @ParameterizedTest     @ValueSource(strings = {             ""hello"",             ""world""     })     void myParametrizedTest(String s) {}      @TestFactory     Stream myTestFactory() {       return Stream.of(dynamicContainer(""foo"", Stream.of(dynamicTest(""bar"", () -> {}))));     }   } } ```  Here is its output when executed using Maven:  ```xml     ...                                            ```  And here's the output for Gradle:  ```xml   ...                                             ```  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [X] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","marcphilipp","2018-01-09T20:53:10Z","2018-01-14T15:48:49Z"
"","1172","Update documentation build instructions","## Overview  Fix described output for the html files and add a note for the requirement of the graphviz package to avoid errors on build.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","gaganis","2017-11-18T09:19:42Z","2017-11-18T11:48:17Z"
"","1559","Fix conditional link to PDF download in documentation","## Overview  Fix conditional link to PDF download  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  None of the items below are really applicable to a simple documentation typo so I'm not sure what to do with them.   - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: works-as-designed,","joel-costigliola","2018-08-21T16:21:22Z","2018-08-22T10:09:29Z"
"","1740","A few IntelliJ inspection-driven cleanups","## Overview  First time contributing to junit. When I first look at any project I usually try and do some simple cleanups as I get used to the code. Most of this was driven by intellij, but I made some other changes where I saw fit.  I'm hoping the commits are self-explanatory. Since they are small I just put them in one PR. There are other cleanups to be done but I'll stick with this for now to figure out the process. Let me know if there are changes you want to see.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","stevencrockett","2019-01-20T16:14:00Z","2019-01-28T14:05:08Z"
"","1558","Introduce support for retrying failed flaky tests","## Overview  Feature request to add native support to rerun failing flaky tests  **Feature request**   Is there any plan to support the ability of rerunning failed flaky tests? For example, it would be great to have something like `@Flaky(rerun=3)`, which would rerun a failing flaky test up to n times.  In the *past*, in Surefire/Failsafe we could use `rerunFailingTestsCount`. However, it does not work in JUnit 5. As JUnit 5.0.0 was released nearly 1 year ago, it is unclear if and when it will be supported in Maven.  And, even if it will be supported in Maven in the future, it could be good to have a special annotation to specify that only some tests are expected to be flaky, and not *all* of them.  At the moment, the workaround is to stick with JUnit 4, which is a kind of a shame as JUnit 5  has a lot of interesting features :(  (which I can only use in projects with no flaky tests)  Related [SO question](https://stackoverflow.com/questions/46181026/junit5-how-to-repeat-failed-test).","open","status: waiting-for-interest,","arcuri82","2018-08-20T20:52:30Z","2022-05-13T16:54:41Z"
"","1707","Introduce declarative mechanism for ordering extensions registered via @RegisterExtension","## Overview  Extensions registered via `@RegisterExtension` are currently ordered in a deterministic manner but not one which is controllable by the user.  ## Related Issues  - #13  - #497  - #506   ## Deliverables  - [x] Introduce a declarative mechanism for ordering extensions registered via `@RegisterExtension`, via `@Order` introduced in #13.","closed","type: new feature,","sbrannen","2018-12-21T15:22:39Z","2019-01-05T13:21:07Z"
"","1828","Simplify using `Assertions.assertDoesNotThrow` from Kotlin","## Overview  Extends original APIs added as part of https://github.com/junit-team/junit5/issues/924 by @JLLeitschuh   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - (no change, the `KotlinAssertionsDemo` is inlined into the user guide) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","mkobit","2019-03-22T16:54:24Z","2019-05-06T12:00:37Z"
"","1225","CDATA end marker in exception message of failed test must not break XML output","## Overview  Exception messages that contain the XML CDATA end marker `]]>` currently cause the XML output to be invalid, e.g. the message `` results in the following document:  ```xml    "" type=""java.lang.AssertionError""> 	at  ... ]]>    ```  ## Deliverables  - [x] Ensure exception messages that contain the CDATA end marker `]]>` result in valid XML","closed","component: Platform,","marcphilipp","2018-01-04T13:33:28Z","2018-01-12T13:24:11Z"
"","1420","Add support for testing private methods and fields","## Overview  Everytime you want to test a private method or access a private field you should add code that uses java reflexion. Can JUnit offer a reusable mean to access (read/write) private class members ?","closed","component: Jupiter,","mxhdx","2018-05-15T17:48:04Z","2018-05-15T20:25:55Z"
"","1796","[WIP] Make Azure Pipeline build work on Windows/Mac/Linux","## Overview  Enhances the build pipeline on Azure DevOps to use three agents (Windows, Linux, and Mac). Related to #1795  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---","closed","status: superseded,","brunoborges","2019-02-27T09:34:30Z","2019-03-12T07:21:43Z"
"","1087","Add ""--scan-module-path"" support on Java 9","## Overview  Enhance `junit-platform-commons` to a multi-release jar project: http://openjdk.java.net/jeps/238  Addresses #1080   ## Tasks - [x] `--select-module ` selector and console option - [x] `--scan-module-path` console option - [x] Jupiter supports new selector - [x] Include all `META-INF/versions/x/...` binaries in standalone JAR  - [x] Add tests for multi-release feature - [x] Vintage supports new selector - [x] `--release 8/9` for all subprojects (party addressed by #1097) - [x] after merging #1097, remove the `if (JavaVersion.current().isJava9Compatible())` condition from `settings.gradle`. - [x] exclude `junit-platform-commons-java-9` from javadoc - [x] configure/test build on Jenkins (cloudbees) - [x] add functional test for `ModuleUtils.findAllClassesInModule(""java.base"")` that actually finds and loads a class ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2017-09-30T08:41:25Z","2017-10-17T11:38:25Z"
"","1812","Shallow clone during Azure Pipelines CI","## Overview  Enable shallow clone during Azure Pipelines CI.  (Unfortunately, this is configurable for each individual build run, so it needs to be repeated.)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","ethomson","2019-03-12T13:01:06Z","2019-03-12T16:04:51Z"
"","1854","From project to source set","## Overview  Eliminate `junit-platform-commons-java-9` project and move overlay class `ModuleUtils` into a newly created source set.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","sormuras","2019-04-09T15:11:12Z","2019-04-15T03:20:57Z"
"","1441","Make md and adoc formatting guidelines more visible in CONTRIBUTING.md","## Overview  During my work on #1399 I have found myself missing the `.adoc` and `.md` formatting guidelines. With the proposed changes it would be more easy to spot and find the guidelines.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","gaganis","2018-06-02T16:54:28Z","2018-06-03T12:23:57Z"
"","969","Cannot select parameterized interface default method by ""fully qualified method name""","## Overview  Due to discussions in #965, I have become aware of the fact that it is currently impossible to select a method by ""fully qualified method name"" (_FQMN_) if the method is a parameterized default method from an interface implemented by a test class.  ## Failing Example  Ignoring the fact that there is no JUnit Jupiter `ParameterResolver` registered to supply the `Number` to the `test()` method below, it is currently impossible to select the `test()` method _in_ `GenericTestCaseWithDefaultMethod` using its FQMN.  ```java interface GenericTestInterface {  	@Test 	default void test(N number) { 		assertThat(number.intValue()).isGreaterThan(99); 	} }  class GenericTestCaseWithDefaultMethod implements GenericTestInterface { } ```  For example, the following...  ```java String fqmn = GenericTestCaseWithDefaultMethod.class.getName() + ""#test("" + Long.class.getName() + "")""; LauncherDiscoveryRequest request = request().selectors(selectMethod(fqmn)).build(); // execute tests using the Launcher API executeTests(request); ```  ... results in an exception like the following.  ``` org.junit.platform.commons.util.PreconditionViolationException: Could not find method with name [test] and parameter types [java.lang.Long] in class [org.junit.jupiter.engine.DefaultMethodTests$GenericTestCaseWithDefaultMethod]. 	at org.junit.platform.engine.discovery.MethodSelector.lambda$1(MethodSelector.java:170) 	at java.util.Optional.orElseThrow(Optional.java:290) 	at org.junit.platform.engine.discovery.MethodSelector.lazyLoadJavaMethod(MethodSelector.java:170) 	at org.junit.platform.engine.discovery.MethodSelector.getJavaMethod(MethodSelector.java:142) 	at  ```  ## Analysis  There is in fact no such method _visible_ in class `GenericTestCaseWithDefaultMethod` with the desired signature. There _is_ a visible method with the desired name (from the interface), but it does not have the desired type. The type in the candidate method is `N` (from `GenericTestInterface`); whereas, the desired type is `java.lang.Long` (from `GenericTestCaseWithDefaultMethod implements GenericTestInterface`).  Consequently, we will likely have to revise the predicate used in `ReflectionUtils.findMethod(Class, String, Class...)` when determining whether parameter types match. Specifically, we will have to take into account the class-level generic type information for the concrete test class and match that against the generic type information available in the interface (where the actual `default` method is declared).  ## Implementation Notes  1. `ReflectionUtils.isMethodShadowedBy(Method, Method)` already contains logic for checking parameter type compatibility in the sense of the comment ""lower is sub-signature of upper: check for generics in upper method"".  ## Related Issues  - #734  - #976   ## Deliverables  - [x] Ensure that it is possible to select a parameterized interface default method by FQMN. - [x] Enable (and complete) the `@Disabled` tests introduced in commit 84d0fd889287a04a3cdabc1c0c49511530d3eecd.","closed","theme: discovery,","sbrannen","2017-07-20T16:54:29Z","2017-07-23T14:40:53Z"
"","1510","DiscoverySelector implementations are missing custom equals() and hashCode()","## Overview  Due to an oversight of the team, implementations of `DiscoverySelector` do not currently have custom implementations of `equals()` and `hashCode()`. This is in contrast to implementations of `TestSource`, `TestDescriptor`, etc.  ## Deliverables  - [x] Implement `equals()` and `hashCode()` in all `DiscoverySelector` implementations.","closed","component: Platform,","sbrannen","2018-07-27T11:01:49Z","2018-08-03T12:30:57Z"
"","1847","[#1091] Modules via ""module"" source set","## Overview  Draft PR #1091 using a dedicated `module` source set containing `module-info.java` files.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2019-04-05T06:19:45Z","2019-04-15T03:21:07Z"
"","1380","WIP Platform Technology Compatibility Kit","## Overview  Draft of refactoring the `ExecutionRecorder` to a separate package for public consumption.  Includes event level timings on the resulting `ExecutionGraph` object returned from the call to `execute()`.  Addresses issue #1356  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Test Kit,","dotCipher","2018-04-18T17:22:34Z","2018-11-03T16:55:20Z"
"","1325","Support aggregation of multiple arguments into a single object for parameterized tests","## Overview  Draft implementation of the proposed API for #1191   Issue: #1191  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","geo-m","2018-03-11T14:14:07Z","2018-04-07T13:00:24Z"
"","1393","Introduce TestWatcher extension API for processing test execution results","## Overview  Draft implementation of a `TestWatcher`-like extension point for discussion, with a sample extension and a test case. Only supports `@Test` methods so far.  Issue: #542  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","geo-m","2018-04-25T22:55:57Z","2019-08-30T12:35:40Z"
"","1902","Remove ""Script-based Conditions"" from JUnit Jupiter","## Overview  Do the second step from ""deprecated for removal"".  ## Deliverables  - [x] Revert the addition of `-deprecation` introduced by https://github.com/junit-team/junit5/pull/1888 in `buildSrc/src/main/kotlin/java-library-conventions.gradle.kts` around line 176. - [x] Remove `@EnabledIf`/`@DisabledIf` API, documentation and implementation and tests. - [x] Reset compiler arguments to `""-Xlint""`, enabling all recommended warnings","closed","theme: modules,","sormuras","2019-05-27T08:36:11Z","2019-07-13T20:15:32Z"
"","1007","Document JavaDoc style in CONTRIBUTING.md","## Overview  Discussions in #996 brought it to our attention that some contributors do not readily discern the JavaDoc style that is used consistently throughout the code base.  In order to avoid such discussions in the future, we should document _our style_ in `CONTRIBUTING.md`, potentially providing concrete examples.  ## Deliverables  - [ ] Document JavaDoc style in `CONTRIBUTING.md`.   - see discussions in #996 for inspiration.","closed","theme: documentation,","sbrannen","2017-08-05T21:18:53Z","2020-07-25T12:14:06Z"
"","1170","Ensure that method names containing special characters can be selected by ""fully qualified method name""","## Overview  Discussion started on this PR #1164  Other JVM languages allow special characters in method names (e.g., Kotlin, Groovy, etc.) which are forbidden in Java source code. EG: 🦆   In the above noted PR I introduced a test that makes sure that the engine can call methods that aren't valid methods in Java. The test that I wrote a method that looked like this:  ```kotlin @Test fun `🦆 ~|~test with a really, (really) terrible name & that needs to be changed!~|~`() { } ```  There was a comment that this doesn't quite go far enough:  > FYI: this verifies that a test method can have such a name and that it can be executed; however, it does not verify that such a method can be selected by it's ""fully qualified method name"" as was brought up on Gitter. So we'll still need to address that. > \- @sbrannen   There should be additional tests added to ensure that tests can be selected using their fully qualified names.  ## Deliverables  - [x] Test ensuring that methods with strange characters can be selected using their ""fully qualified method name"" - [x] Remove duplication in `DiscoverySelectors` and `ReflectionUtils` regexes for matching fully qualified method names - [x] Document in Release Notes.","closed","component: Kotlin,","JLLeitschuh","2017-11-17T16:39:18Z","2018-01-22T15:58:09Z"
"","1905","Tiny cleanup in TestRuleSupport","## Overview  Details in commit messages  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","ielatif","2019-05-29T13:17:47Z","2019-05-31T10:56:24Z"
"","1023","Describe Automatic-Module-Name JAR attributes","## Overview  Describe and enumerate `Automatic-Module-Name` JAR attributes in a prominent location: `README.md`  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","theme: modules,","sormuras","2017-08-15T13:13:28Z","2017-08-15T21:09:52Z"
"","1228","selectively execute arguments from method source using only","## Overview  Debugging a single case of a parameterized test is quiet cumbersome. To make this easier this pull requests adds a new factory method `only` on `Arguments`.  As soon as at least a single Argument in a `MethodSource` is flagged as `only` only those are executed. If no Argument is flagged with `only` all elements of the MethodSource are executed.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: declined,","signed","2018-01-04T22:19:47Z","2019-08-14T21:25:57Z"
"","1026","JupiterTestEngine attempts to resolve unique IDs that belong to other engines","## Overview  Currently, the `JupiterTestEngine` needlessly attempts to resolve _Unique IDs_ that clearly belong to other test engines. This is because `JavaElementsResolver.resolveUniqueId(UniqueId)` completely ignores the _Engine ID_ and then blindly attempts to resolve the supplied Unique ID. Consequently, the `JupiterTestEngine` always logs a warning about not being able to resolve a Unique ID that it was never meant to resolve.  ## Related Issues  - #1025   ## Deliverables  - [x] Ensure that the `JupiterTestEngine` does not attempt to resolve Unique IDs that belong to other test engines.","closed","theme: diagnostics,","sbrannen","2017-08-19T14:22:25Z","2018-12-28T14:00:56Z"
"","1602","AssertAll#assertAll() should display stack trace of all failed assertions","## Overview  Currently, on failure `Assertions.assertAll()` only shows the stack trace for the `assertAll()` method itself but not for lambda expressions that actually failed.  When there are multiple failures it is hard to know which one failed if the error message is this same (multiple `assertTrue()` or similar `assertEquals()`).  In contrast, soft assertions in AssertJ display all failed stack traces but do not support lambda expressions.  ## Deliverables  - [x] Add failures in `assertAll()` as _suppressed exceptions_ in Jupiter. - [x] Document enhancement in the Release Notes.","closed","component: Jupiter,","kamkie","2018-09-28T08:04:18Z","2021-08-02T16:45:31Z"
"","1777","Exception thrown from TestExecutionListener fails the test plan","## Overview  Currently, if a `TestExecutionListener` throws an exception, that exception will propagate and cause the entire test plan to fail.  ## Deliverables  - [ ] Ensure that exceptions thrown from methods in a `TestExecutionListener` are swallowed and logged at `ERROR` level. - [ ] Update Javadoc for `TestExecutionListener` to describe the expectation that such listeners never throw exceptions and what happens if a listener throws an exception.","closed","component: Platform,","sbrannen","2019-02-15T12:34:48Z","2020-05-22T19:54:03Z"
"","1912","Improve diagnostics for private @RegisterExtension fields","## Overview  Currently, if a `@RegisterExtension` field is declared as `private`, JUnit Jupiter silently ignores it. Consequently, it can be difficult for a user to determine why the extension ""is not working"".  Since the mere presence of `@RegisterExtension` should signal that the user intended for an extension to be registered (see #1908), improper configuration should result in an error instead of being silently ignored.  ## Related Issues  - #1908   ## Deliverables  - [x] Fail the test method or test class if a `@RegisterExtension` field is `private`.","closed","theme: diagnostics,","sbrannen","2019-06-03T08:04:54Z","2019-06-03T08:16:13Z"
"","1458","Use custom method to resolve name of parameterized test invocation","## Overview  Currently we can do this to set a name in parameterized tests: `@ParameterizedTest(name=""{index}->{0}"")`  But, I have a test where I need a little more in terms of how I customize the name (if I want to make it easy to read). Preferably something like this:   ``` java @ParameterizedTest(name =     (index, arguments) -> index + "" -> "" + arguments[0].getDisplayName() ) ```  This allows us to dynamically generate the name of the test, based on something other than `toString()`.  ## Workaround  Add an extra string parameter to the test, than use that in the name.  ## Related Issues  - #1309","closed","theme: parameterized tests,","Frontrider","2018-06-07T13:06:04Z","2018-06-08T08:07:42Z"
"","1178","DynamicTest should be able to provide tags and source information to TestDescriptor","## Overview  Currently the source for dynamic tests is a always a `MethodSource` pointing to the `@TestFactory` annotated method. In case the dynamic tests are based on external files, like in a cucumber implementation, it should be possible to specify the source.  ### Example  ```gherkin Given a file ""helloword.feature"" containing   """"""   Feature: Hello World Feature      @hello @world     Scenario: Hello World Scenario         Given the user name is 'World'          When the user clicks the hello button          Then the output is 'Hello World'   """"""   When dynamic tests are created for this feature   Then the test description should have a file source of ""helloworld.feature"" line 4    And the test description should have the tags [""hello"", ""world""] ``` ## Related Issues  - #434 - #1293  - #1467   ## Deliverables  - [x] `DynamicTest` / `DynamicContainer` should have additional factory methods allowing to specify `TestSource` - ❌ `DynamicTest` / `DynamicContainer` should have additional factory methods allowing to specify `Set` - [x] The above information should be used when creating the `DynamicTestTestDescriptor` and `DynamicContainerTestDescriptor`  (The actual creation of the dynamic tests for a cucumber scenario is out of scope)","closed","theme: dynamic tests,","jhorstmann","2017-11-22T10:50:56Z","2018-06-15T08:19:15Z"
"","1088","Support methods from external classes in @MethodSource","## Overview  Currently only methods from the same class as test can be referenced. It limits possibility of reusing code, eg. if multiple tests from multiple classes need ""blank strings"" then there is no simple way of defining it once and using in all tests.  There are 2 ideas for allowing to reference external class methods.  1. Allow to provide Fully Qualified Method Name (FQMN) in `@MethodSource` annotation, like: ```java @ParameterizedTest @MethodSource(""com.example.test.StringDataFactory#blankStrings()"") void testSomething(String blankString) {     // ... } ```  2. Extend`@MethodSource` annotation with additional attribute declaring class containing referenced method source, eg. `location`: ```java @ParameterizedTest @MethodSource(value = ""blankStrings"", location = StringDataFactory.class) void testSomething(String blankString) {     // ... } ```  I think that second option is better choice as it is more type safe and easier to write. Probably IDE like IntelliJ IDEA will support FQMN references in strings, but I doubt other IDE like Eclipse or NetBeans will get such feature as well (to be honest I have no idea how advanced are those IDEs these days).  I wouldn't recommend implementing both options. IMHO two ways of achieving the same goal is not the best idea. Developers in teams would have different preferences and argue about which way should be used in project. Also having two ways of doing the same doesn't provide any additional value here (or at least I don't see it).","closed","theme: parameterized tests,","karollewandowski","2017-09-30T18:12:51Z","2018-04-01T16:31:57Z"
"","1245","Document Maven test filtering support in User Guide","## Overview  Currently it might appear to a reader that only filtering by tags is supported.  Could you consider expanding the JUnit 5 User Guide with a reference to a page in Maven Surefire documentation about filtering of tests by file name or class name?  ## Proposal  I think it may be as simple as  ```markdown ### Filtering by Tags … ### Filtering by Test File Name Please refer to [Maven Surefire documentation](https://maven.apache.org/surefire/maven-surefire-plugin/examples/inclusion-exclusion.html) to enable filtering of tests by file name or class name. ```  ## Related Issues  - #1237   ## Deliverables  - [x]  Document Maven test filtering support in the User Guide.   - [x] `-Dtest` system property support   - [x] standard Maven Surefire include and exclude support in `pom.xml`","closed","3rd-party: Maven Surefire,","dmitry-timofeev","2018-01-15T14:45:27Z","2018-01-15T15:44:30Z"
"","1187","Provide access to test instance lifecycle via ExtensionContext","## Overview  Currently extension authors can only _attempt_ to determine the test instance lifecycle, as can be seen in the `WeldJunit5Extension`:  https://github.com/weld/weld-junit/blob/84c6631f9851409cb4c9e427793a7cc9f6ae54b8/junit5/src/main/java/org/jboss/weld/junit5/WeldJunit5Extension.java#L162-L170  Such attempts are, however, fragile at best since the _default_ lifecycle may have been overridden via a system property or platform configuration parameter.  ## Deliverables  - [x] Provide access to the test instance lifecycle for the current test class via the `ExtensionContext`. - [x] Introduce tests for this new feature. - [x] Document in Release Notes.","closed","component: Jupiter,","sbrannen","2017-11-25T18:02:07Z","2018-01-12T13:27:45Z"
"","1092","Support widening conversion for parameter resolution","## Overview  Current behavior: `ParameterResolutionException`is thrown, e.g. `ParameterResolver [ParameterResolverReproducerTest$IntegerResolver] resolved a value of type [java.lang.Integer] for parameter [long arg0] in executable [void ParameterResolverReproducerTest.failing(long)], but a value assignment compatible with [long] is required`.  Desired behavior, e.g. a `long` parameter can be called with an `Integer` argument  - Version: JUnit 5.0.1 - Reproducer, see below - Java Spec: https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2  ## Example Code  ```java @ExtendWith(ParameterResolverReproducerTest.IntegerResolver.class) class ParameterResolverReproducerTest {     public static class IntegerResolver implements ParameterResolver {          @Override         public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {             return long.class.equals(parameterContext.getParameter().getType());         }          @Override         public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {             return Integer.valueOf(1);         }     }      @Test     void failing(long a) {         // nothing to do     }      @Test     void succeeding() {         failing(Integer.valueOf(1));     } } ```  I guess one way to address this would be extending `ReflectionUtils#primitiveToWrapperMap` with some more possibilities.  If you agree on this, I can try to submit this via PR.  Cheers, Andreas","closed","theme: parameterized tests,","aaschmid","2017-10-04T18:00:05Z","2018-04-01T09:41:27Z"
"","1216","Revise layout and building of multi-release JARs","## Overview  Current ""solution"" uses external `jar` tool: https://github.com/junit-team/junit5/blob/master/build.gradle#L489-L519  Better Gradle intergration presented by @melix at: https://blog.gradle.org/mrjars  ## Deliverables  - [ ] Revise layout and building of multi-release-JAR(s). Keep in mind, that the `jar` tool offers some API/ABI sanity checks when it packages the version-aware types.","closed","theme: modules,","sormuras","2017-12-22T16:41:09Z","2019-05-01T13:37:47Z"
"","1100","CsvSource does not handle trailing spaces correctly","## Overview  Copied from https://github.com/junit-team/junit5/pull/1016#issuecomment-334091550  I maybe found a bug with the CsvSource parser for empty strings. Consider the following example:  ```java @ParameterizedTest     @CsvSource({         ""  '', Content"",         ""  '',      ''"",         ""  '', ''     "",     }) void contentTest(final String one, final String two) {   Assertions.assertNotNull(two); } ```  Where in the second test the string two is, as expected an empty string, in the third test the string two is ```null```. Obviously the parser is confused by the trailing blanks of the second parameter.  I'm currently using junit jupiter version 5.0.0.  ## Deliverables  - [ ] Upgrade to `univocity-parsers` version 2.5.8 when available and remove [TODO](https://github.com/junit-team/junit5/commit/62055132ae226f7e99031d779926ed553a8ed543#diff-a25bf3dde2d64a209206c59a9742f823R26)","closed","component: Jupiter,","sormuras","2017-10-09T18:46:15Z","2017-11-05T17:33:17Z"
"","1286","Make dependency on ""javax.script"" optional","## Overview  Copied from http://mail.openjdk.java.net/pipermail/jigsaw-dev/2018-February/013581.html > [...] The more general issue is of course that you are  deploying a module that does not know what modules it depends. In these  cases you have to help the module system by specifying --add-modules to  force the modules that it depends on to be resolved. You got lucky with  the Oracle JDK build because jdk.deploy pulled in the java.scripting module.  Addresses #1282  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2018-02-06T11:19:59Z","2018-02-09T12:09:39Z"
"","1021","Level of documentation in the JavaDoc","## Overview  Copied comment from @smoyer64  in #1014:  > Looking at the section of the users guide for parameterized tests, there's a lot of great information which is exactly the sort of thing I'd like to see when my IDE pops up the javadocs for @CsvSource. Unfortunately, those javadocs simply link back to the users guide for the important stuff.  > I do think it's important to have a good users guide for those who are jumping into junit5 but I believe that those who are heavy users will appreciate the javadocs being complete and stand-alone. It's a lot more work to keep up-to-date if the information is in both places but I believe for things like this, it's important - kind of like date and regex format descriptions in the Java SE javadocs.  ## Deliverables  - [ ] Enhance Javadoc with more details, examples and other ""important stuff""","closed","status: duplicate,","sormuras","2017-08-15T06:29:18Z","2017-08-15T21:03:11Z"
"","1163","Support collections of executables in assertAll()","## Overview  Continuing the discussion that was spawned from this Twitter chat: https://twitter.com/relizarov/status/930828269611401216  To start this discussion, these are the methods exposed by [AssertAll](https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertAll.java).  The `assertAll` method does not have an overload that takes a `Collection`.  Currently to use `assertAll` from Kotlin you must first turn it into a Java8 `Stream<() -> Unit>`  This is the current example API: ```kotlin @Test fun `assertions from a stream`() {     assertAll(         ""people with name starting with J"",         people             .stream()             .map {                 // This mapping returns Stream<() -> Unit>                 { assertTrue(it.firstName.startsWith(""J"")) }             }     ) } ```  I think what @elizarov was proposing in his tweet was to change the API so you could do something like this:  ```kotlin @Test fun `assertions from a stream`() {     assertAll(         ""people with name starting with J"",         people             .map {                 // This mapping returns Stream<() -> Unit>                 { assertTrue(it.firstName.startsWith(""J"")) }             }     ) } ```  Currently the API exposes this method in kotlin: ```kotlin /**  * [Stream] of functions to be executed.  */ private typealias ExecutableStream = Stream<() -> Unit> private fun ExecutableStream.convert() = map { Executable(it) }  /**  * @see Assertions.assertAll  */ fun assertAll(executables: ExecutableStream) =     Assertions.assertAll(executables.convert())  /**  * @see Assertions.assertAll  */ fun assertAll(heading: String?, executables: ExecutableStream) =     Assertions.assertAll(heading, executables.convert()) ```  The proposed suggestion would add additional assertion methods: ```kotlin /**  * [Collection] of functions to be executed.  */ private typealias ExecutableCollection = Collection<() -> Unit> /**  * @see Assertions.assertAll  */ fun assertAll(executables: ExecutableCollection) =     assertAll(executables.stream()) /**  * @see Assertions.assertAll  */ fun assertAll(heading: String?, executables: ExecutableCollection) =     assertAll(heading, executables.stream()) ```  If the team decides that these methods make sense to be added, should be reflected in the Java API? The additions would be something like this:  ```java static void assertAll(Collection executables) {     assertAll(null, executables); }  static void assertAll(String heading, Collection executables) {     assertAll(heading, executables.stream()); } ```  ## Question for the team  Why was `void assertAll(Collection executables)` not added to the API to begin with? Do those same reasons apply here? Do they only apply to Java but not Kotlin?  ## Deliverables  - [x] Support `Collection` in Java for `assertAll()`. - [x] Document `Collection` support in Java in Release Notes. - [x] Support `Collection<() -> Unit>` in Kotlin for `assertAll()`. - [x] Document `Collection<() -> Unit>` support in Kotlin in Release Notes (if necessary). - [x] Update Kotlin examples in User Guide.","closed","component: Jupiter,","JLLeitschuh","2017-11-15T23:50:05Z","2017-11-16T20:34:13Z"
"","997","Fix Gradle consumption of junit-jupiter-engine","## Overview  Consuming the RC1 artifact of junit-jupiter-engine with Gradle fails due to an invalid POM:  ``` ▶ ./gradlew --refresh-dependencies clean build  FAILURE: Build failed with an exception.  * What went wrong: Could not resolve all files for configuration ':testRuntimeClasspath'. > Could not resolve org.junit.jupiter:junit-jupiter-engine:5.0.0-RC1.   Required by:       project :    > Could not resolve org.junit.jupiter:junit-jupiter-engine:5.0.0-RC1.       > Could not parse POM https://repo1.maven.org/maven2/org/junit/jupiter/junit-jupiter-engine/5.0.0-RC1/junit-jupiter-engine-5.0.0-RC1.pom          > Unable to resolve version for dependency 'org.jetbrains.kotlin:kotlin-stdlib-jre8:jar'  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.  BUILD FAILED in 2s 6 actionable tasks: 6 executed ```  ## Deliverables  - [x] Exclude 'test' scope dependencies from generated POM","closed","component: Kotlin,","marcphilipp","2017-07-30T20:12:04Z","2017-10-29T16:54:07Z"
"","1105","Reintroduce compile dependency on apiguardian-api in Maven POMs","## Overview  Consider reverting the changes in #1065.  See discussions on Gitter and elsewhere.  - https://youtrack.jetbrains.com/issue/IDEA-178888 - #1064  - #1065  - #1104  - #1210   ## Deliverables  - [x] Decide how to handle _optional_ dependencies such as the API Guardian and ""nullability"" annotations. - [x] Reintroduce `compile` dependency on `apiguardian-api` in generated Maven POMs. - [x] Document change in release notes and user guide as appropriate.","closed","3rd-party: Gradle,","sbrannen","2017-10-12T15:15:14Z","2018-01-15T11:38:01Z"
"","989","Add java.lang.SecurityException to blacklist","## Overview  Consider adding `java.lang.SecurityException` to the _blacklist_ in `BlacklistedExceptions`.  ## Deliverables  - [ ] Add `java.lang.SecurityException` to the _blacklist_ in `BlacklistedExceptions`. - [ ] Revise exception handling in `ReflectionUtils` accordingly.","closed","component: Platform,","sbrannen","2017-07-26T15:05:58Z","2017-07-28T12:02:33Z"
"","1677","AnnotatedElement parameter support in declaratively registered extensions' constructors","## Overview  Configuring extensions programmatically in `@RegisterExtension`-annotated static fields is fine. But sometimes we need static configuration for declaratively registered extensions, i. e. we want to initialize private final fields in `@ExtendWith`-defined extension classes.  The problem is that declaratively registered extensions are instantiated using default constructors. The proposed change adds support for constructors that accept `AnnotatedElement` as the only parameter. In this case we can extract all the information needed from other annotations on the element.  E. g. we could declare something like (see documentation/src/test/java/example/registration/ParameterizedExtensionDemo.java):  ```java @Retention(RetentionPolicy.RUNTIME) @ExtendWith(ParameterizedExtension.class) public @interface WithParameterizedExtension {     String value(); }  public class ParameterizedExtension implements ParameterResolver {     private final String parameter;     public ParameterizedExtension(AnnotatedElement annotatedElement) {         parameter = annotatedElement.getAnnotation(WithParameterizedExtension.class).value();     } .... ``` And use this extension in the following manner:  ```java @WithParameterizedExtension(""foo"") public class ParameterizedExtensionDemo {      @Test     void parameterIsPassedToExtension(String param) {         assertEquals(""foo"", param);     } } ```   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","inponomarev","2018-11-12T20:32:20Z","2018-12-04T19:20:37Z"
"","1091","Add module descriptors to all JUnit 5 modules","## Overview  Conceal internal packages by moving from Level 1 ""`Automatic-Module-Name`"" to Level 2 ""Publish modularized JAR"": https://vimeo.com/289846017#t=1298s `21:38`  ## Draft Pull Requests  * #1593 Modules via using Java 9 as release target  _outdated_ * #1844 Modules via extra compilation task * #1846 Modules via @moditect * #1847 Modules via `module` source set * #1848 Modules via `src/modules` directory using `javac` * #1857 Modules via extra compilation and jar tasks 💯   ## Deliverables  - [x] Create many drafts - [x] Select one draft and make it happen  1. `org.junit.platform.commons` 1. `org.junit.platform.console` 1. `org.junit.platform.engine` 1. `org.junit.platform.launcher` 1. `org.junit.platform.reporting` 1. `org.junit.platform.runner` 1. `org.junit.platform.suite.api` 1. `org.junit.platform.testkit` 1. `org.junit.jupiter` 1. `org.junit.jupiter.api` 1. `org.junit.jupiter.engine` 1. `org.junit.jupiter.migrationsupport` 1. `org.junit.jupiter.params` 1. `org.junit.vintage.engine`  - [x] Include `module-info.class` in https://github.com/ota4j-team/opentest4j/pull/51 - [x] Include `module-info.class` in https://github.com/apiguardian-team/apiguardian","closed","theme: modules,","sormuras","2017-10-04T10:00:40Z","2020-05-22T19:53:16Z"
"","1279","Remove unused declarations from code base","## Overview  Commit https://github.com/junit-team/junit5/commit/6cb99541c09263ced74af1bcf2eb100328a02a17 removed dead code from `AnnotationUtils`. This issues tracks more dead code - meaning unused declarations - that should be deleted. A declaration is also regarded as unused if only tests refer to it.  ## Marked For Removal  - ~Unused `private` constructor~: [ClasspathResourceSource.java#L76](https://github.com/junit-team/junit5/blob/master/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClasspathResourceSource.java#L76)   - solved by actually using it via https://github.com/junit-team/junit5/commit/0ff90a05b18f03c2866db0ace074271479243f7a  ## Deliverables  - ❌  Find more unused (only used in tests) declarations - ❌  Delete those which do not break external code","closed","type: task,","sormuras","2018-02-03T11:47:37Z","2018-02-12T15:20:09Z"
"","1065","Remove compile dependency on apiguardian-api in Maven POMs","## Overview  Commit 77c0f9a5002c52ca0f9d363a77a674137f5ae66e accidentally introduced a Maven `compile` scope dependency on the `apiguardian-api` artifact in all published JUnit artifacts; whereas, the dependency should **ideally** be listed as `optional` in the generated Maven POMs since there are in fact zero runtime dependencies on `@API` within published JUnit artifacts.  ## Related Issues  - https://youtrack.jetbrains.com/issue/IDEA-178888 - #1064  - #1105  ## Deliverables  - [x] Remove `compile` dependency on `apiguardian-api` in generated Maven POMs. - [x] Consider including an `optional` dependency on `apiguardian-api` in generated Maven POMs.   - AFAIK, it is not possible to generate an `optional` dependency with the standard Gradle infrastructure. For that we will likely have to use a third-party tool such as the [propdeps-plugin](https://github.com/spring-gradle-plugins/propdeps-plugin) from the Spring team. - ❌ Consider backporting this change to `1.0.1`, `5.0.1`, and `4.12.0.1` releases.   - Team decision: do not backport unless such branches are created due to other needs.","closed","3rd-party: Gradle,","sbrannen","2017-09-15T12:45:17Z","2019-07-19T19:32:44Z"
"","1916","Document URI TestSource support of dynamic tests in User Guide","## Overview  Closes #1903   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","ielatif","2019-06-05T15:32:38Z","2019-06-20T10:12:09Z"
"","1941","Remove script based conditions","## Overview  Closes #1902   - [x] Revert the addition of `-deprecation` introduced by https://github.com/junit-team/junit5/pull/1888 in `buildSrc/src/main/kotlin/java-library-conventions.gradle.kts` around line 176. - [x] Remove `@EnabledIf`/`@DisabledIf` API, documentation and implementation and tests. - [x] Reset compiler arguments to `""-Xlint""`, enabling all recommended warnings ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2019-07-02T11:07:25Z","2019-07-03T11:51:19Z"
"","1897","Close custom URLClassLoader","## Overview  Closes #1896  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2019-05-24T09:57:00Z","2019-05-27T08:21:51Z"
"","1889","Friendlier assertTimeout and assertTimeoutPreemptively from Kotlin","## Overview  Closes #1887  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","JLLeitschuh","2019-05-21T16:30:49Z","2019-05-23T19:19:20Z"
"","1888","Deprecate ""Script-based Conditions"" for removal","## Overview  Closes #1882  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2019-05-20T16:14:17Z","2019-05-27T11:08:03Z"
"","1881","Improve module descriptor directives","## Overview  Closes #1877  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2019-05-15T15:23:01Z","2019-05-16T10:45:45Z"
"","1598","Remove custom Surefire provider","## Overview  Closes #1597   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","sormuras","2018-09-24T04:31:19Z","2018-09-27T12:20:50Z"
"","1038","Add dependency caching to travis config","## Overview  Closes #1037  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","JLLeitschuh","2017-08-30T21:29:45Z","2017-10-25T14:16:51Z"
"","1748","TempDirectory breaks constructor parameter resolution","## Overview  Changes made in #1746 prevent test classes from having any parameters in their constructor if the `TempDirectory` extension is registered.  ## Failing Example  The following test class fails against JUnit Jupiter `5.4.0-RC1` simply because the `TempDirectory` extension is registered.  ```java @ExtendWith(TempDirectory.class) static class BrokenTestCase {  	BrokenTestCase(TestInfo testInfo) { 	}  	@Test 	void test() { 	}  } ```  ## Related Issues  - #1746 - #1747 - #1752 - #1753  ## Deliverables  - [x] Ensure that the `TempDirectory` extension does not prevent the use of constructor arguments. - [x] Consider documenting the fix in the Release Notes.","closed","component: Jupiter,","sbrannen","2019-01-25T15:18:50Z","2019-01-28T14:35:12Z"
"","1476","Allow configuring max characters per column in CSV input to @ParameterizedTest","## Overview  Cannot configure maximum characters per column for CSV input for a `@ParameterizedTest`.  ``` org.junit.jupiter.params.shadow.com.univocity.parsers.common.TextParsingException: Length of parsed input (4097) exceeds the maximum number of characters defined in your parser settings (4096).  Hint: Number of characters processed may have exceeded limit of 4096 characters per column. Use settings.setMaxCharsPerColumn(int) to define the maximum number of characters a column can have Ensure your configuration is correct, with delimiters, quotes and escape sequences that match the input format you are trying to parse ```  ## Deliverables  - Add new annotation attribute such as `maxCharsPerColumn` to `@CsvSource` - Add new annotation attribute such as `maxCharsPerColumn` to `@CsvFileSource`","closed","theme: parameterized tests,","Xuhui-Wang","2018-06-23T19:00:18Z","2020-08-16T12:16:57Z"
"","1176","BeforeAll/AfterAll-Callbacks not invoked for @ExtendWith annotation on test method","## Overview  Callbacks for `BeforeAllCallback` and `AfterAllCallback` not running when `@ExtendWith` is not at class level  - **Bug report.**  For the test: ```java public class MyTest {     @ExtendWith(MyLifecycle.class)     @Test     void test01() {} } ``` and `MyLifecycle` implementing `BeforeAllCallback` and `AfterAllCallback` the `beforeAll` and `afterAll` callbacks are not invoked.  As the developer of the extension I would expect those callbacks to run even if the `@ExtendWith` annotation is not at class level. Especially if I want to create my own test annotation that uses `@ExtendWith` as meta annotation. Also, the javadoc for the callback methods states that they will be invoked before/after all tests in the current container.  junit version: 5.0.2 junit platform version: 1.0.2 execution environmen: eclipse oxygen 4.7.1a","closed","status: works-as-designed,","flok32","2017-11-20T18:55:45Z","2017-11-21T15:54:38Z"
"","1082","Problem with malformed class name using scala + no test found","## Overview  Bug Report Using version 5.0.0 from Maven Central  Seems to be linked to this: https://github.com/junit-team/junit5/issues/401 but for scala instead of Kotlin.  I have a Play Framework project using Java but a lot of files are generated in Scala behind the scene. Junit 5 seems to be crashing because of the naming of one of these generated files.  My project compiles without problem. I have made sure there is nothing left of JUnit4 in the classpath.  Here is the full stack trace of the error:    ``` Sep 29, 2017 9:35:12 AM org.junit.platform.commons.util.ClasspathScanner logMalformedClassName WARNING: The java.lang.Class loaded from path [C:\dev\CS\trunk\target\scala-2.11\classes\views\html\clap\admin\stationView_Scope0$stationView_Scope1$stationView.class] has a malformed class name [views.html.clap.admin.stationView_Scope0$stationView_Scope1$stationView]. java.lang.InternalError: Malformed class name 	at java.lang.Class.getSimpleName(Class.java:1330) 	at java.lang.Class.isAnonymousClass(Class.java:1411) 	at org.junit.jupiter.engine.discovery.predicates.IsPotentialTestContainer.test(IsPotentialTestContainer.java:39) 	at org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests.test(IsTestClassWithTests.java:46) 	at org.junit.jupiter.engine.discovery.predicates.IsScannableTestClass.test(IsScannableTestClass.java:37) 	at org.junit.jupiter.engine.discovery.predicates.IsScannableTestClass.test(IsScannableTestClass.java:26) 	at java.util.Optional.filter(Optional.java:178) 	at org.junit.platform.commons.util.ClasspathScanner.processClassFileSafely(ClasspathScanner.java:141) 	at org.junit.platform.commons.util.ClasspathScanner.lambda$findClassesForPath$3(ClasspathScanner.java:126) 	at org.junit.platform.commons.util.ClassFileVisitor.visitFile(ClassFileVisitor.java:45) 	at org.junit.platform.commons.util.ClassFileVisitor.visitFile(ClassFileVisitor.java:28) 	at java.nio.file.Files.walkFileTree(Files.java:2670) 	at java.nio.file.Files.walkFileTree(Files.java:2742) 	at org.junit.platform.commons.util.ClasspathScanner.findClassesForPath(ClasspathScanner.java:126) 	at org.junit.platform.commons.util.ClasspathScanner.findClassesForUri(ClasspathScanner.java:110) 	at org.junit.platform.commons.util.ClasspathScanner.lambda$findClassesForUris$0(ClasspathScanner.java:99) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.platform.commons.util.ClasspathScanner.findClassesForUris(ClasspathScanner.java:102) 	at org.junit.platform.commons.util.ClasspathScanner.scanForClassesInPackage(ClasspathScanner.java:78) 	at org.junit.platform.commons.util.ReflectionUtils.findAllClassesInPackage(ReflectionUtils.java:640) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolveSelectors$1(DiscoverySelectorResolver.java:55) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:54) 	at org.junit.jupiter.engine.JupiterTestEngine.resolveDiscoveryRequest(JupiterTestEngine.java:70) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:63) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:82) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:48) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)  Sep 29, 2017 9:35:12 AM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests java.lang.IllegalAccessError: tried to access method org.junit.platform.engine.support.descriptor.ClassSource.(Ljava/lang/Class;)V from class org.junit.jupiter.engine.descriptor.ClassTestDescriptor 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:93) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:76) 	at org.junit.jupiter.engine.discovery.TestContainerResolver.resolveClass(TestContainerResolver.java:98) 	at org.junit.jupiter.engine.discovery.TestContainerResolver.resolveElement(TestContainerResolver.java:47) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.tryToResolveWithResolver(JavaElementsResolver.java:163) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.lambda$resolve$8(JavaElementsResolver.java:154) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1548) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolve(JavaElementsResolver.java:157) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.lambda$resolveForAllParents$4(JavaElementsResolver.java:128) 	at java.util.Collections$SingletonSet.forEach(Collections.java:4767) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveForAllParents(JavaElementsResolver.java:128) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveContainerWithParents(JavaElementsResolver.java:79) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveClass(JavaElementsResolver.java:56) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:1080) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolveSelectors$1(DiscoverySelectorResolver.java:55) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:54) 	at org.junit.jupiter.engine.JupiterTestEngine.resolveDiscoveryRequest(JupiterTestEngine.java:70) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:63) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:82) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:48) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)  Sep 29, 2017 9:35:12 AM org.junit.platform.commons.util.ClasspathScanner logMalformedClassName WARNING: The java.lang.Class loaded from path [C:\dev\CS\trunk\target\scala-2.11\classes\views\html\clap\admin\stationView_Scope0$stationView_Scope1$stationView.class] has a malformed class name [views.html.clap.admin.stationView_Scope0$stationView_Scope1$stationView]. java.lang.InternalError: Malformed class name 	at java.lang.Class.getSimpleName(Class.java:1330) 	at java.lang.Class.isAnonymousClass(Class.java:1411) 	at org.junit.jupiter.engine.discovery.predicates.IsPotentialTestContainer.test(IsPotentialTestContainer.java:39) 	at org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests.test(IsTestClassWithTests.java:46) 	at org.junit.jupiter.engine.discovery.predicates.IsScannableTestClass.test(IsScannableTestClass.java:37) 	at org.junit.jupiter.engine.discovery.predicates.IsScannableTestClass.test(IsScannableTestClass.java:26) 	at java.util.Optional.filter(Optional.java:178) 	at org.junit.platform.commons.util.ClasspathScanner.processClassFileSafely(ClasspathScanner.java:141) 	at org.junit.platform.commons.util.ClasspathScanner.lambda$findClassesForPath$3(ClasspathScanner.java:126) 	at org.junit.platform.commons.util.ClassFileVisitor.visitFile(ClassFileVisitor.java:45) 	at org.junit.platform.commons.util.ClassFileVisitor.visitFile(ClassFileVisitor.java:28) 	at java.nio.file.Files.walkFileTree(Files.java:2670) 	at java.nio.file.Files.walkFileTree(Files.java:2742) 	at org.junit.platform.commons.util.ClasspathScanner.findClassesForPath(ClasspathScanner.java:126) 	at org.junit.platform.commons.util.ClasspathScanner.findClassesForUri(ClasspathScanner.java:110) 	at org.junit.platform.commons.util.ClasspathScanner.lambda$findClassesForUris$0(ClasspathScanner.java:99) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.platform.commons.util.ClasspathScanner.findClassesForUris(ClasspathScanner.java:102) 	at org.junit.platform.commons.util.ClasspathScanner.scanForClassesInPackage(ClasspathScanner.java:78) 	at org.junit.platform.commons.util.ReflectionUtils.findAllClassesInPackage(ReflectionUtils.java:640) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolveSelectors$1(DiscoverySelectorResolver.java:55) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:54) 	at org.junit.jupiter.engine.JupiterTestEngine.resolveDiscoveryRequest(JupiterTestEngine.java:70) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:63) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:62) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)  Sep 29, 2017 9:35:12 AM org.junit.platform.launcher.core.DefaultLauncher handleThrowable WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests java.lang.IllegalAccessError: tried to access method org.junit.platform.engine.support.descriptor.ClassSource.(Ljava/lang/Class;)V from class org.junit.jupiter.engine.descriptor.ClassTestDescriptor 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:93) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:76) 	at org.junit.jupiter.engine.discovery.TestContainerResolver.resolveClass(TestContainerResolver.java:98) 	at org.junit.jupiter.engine.discovery.TestContainerResolver.resolveElement(TestContainerResolver.java:47) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.tryToResolveWithResolver(JavaElementsResolver.java:163) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.lambda$resolve$8(JavaElementsResolver.java:154) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1548) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolve(JavaElementsResolver.java:157) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.lambda$resolveForAllParents$4(JavaElementsResolver.java:128) 	at java.util.Collections$SingletonSet.forEach(Collections.java:4767) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveForAllParents(JavaElementsResolver.java:128) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveContainerWithParents(JavaElementsResolver.java:79) 	at org.junit.jupiter.engine.discovery.JavaElementsResolver.resolveClass(JavaElementsResolver.java:56) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:1080) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.lambda$resolveSelectors$1(DiscoverySelectorResolver.java:55) 	at java.util.ArrayList.forEach(ArrayList.java:1249) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:54) 	at org.junit.jupiter.engine.JupiterTestEngine.resolveDiscoveryRequest(JupiterTestEngine.java:70) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:63) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:62) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)   Process finished with exit code 0 Empty test suite. ```    As you can see, it also fails to find any test.  Is this a bug on Junit 5 side?  Is there something I can do to get around this while it is being fixed?  Thanks!","closed","status: invalid,","JFCote","2017-09-29T13:43:41Z","2017-09-30T13:13:59Z"
"","1681","Remove internal VERSION constant from ModuleUtils","## Overview  Both versions, the base and ""java-9"" one, of `ModuleUtils` contain a `public static final String VERSION` constant that was only introduced for testing purposes. The java compiler could (and did) inline the visible value at compile time which led to following confusing test code that succeeded on a Java 9+ runtime using the `junit-platform-commons` MRJAR:  ```java   @Test   @EnabledOnJre(JRE.JAVA_9)   void versions() {       assertEquals(""base"", ModuleUtils.VERSION); // SHOULD BE ""9""!!!?!       assertEquals(""9"", ModuleUtils.class.getField(""VERSION"").get...);   } ```  https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ModuleUtils.java#L40-L43  ## Deliverables  - [x] Remove the constant and update affected tests","closed","component: Platform,","sormuras","2018-11-19T12:14:55Z","2018-11-19T12:21:18Z"
"","1259","Issue-1258 Issue-880 Removed unnecessary creation of BooleanSupplier","## Overview  BooleanSupplier is an object that is created every time assertion is called. This affects performance. My pull request changes that. If condition comes as a boolean, that specific boolean is checked.  It's non-functional change, therefore I didn't put any tests for that. Also no other assertion classes except of AssertTrue were checked against performance.","closed","component: Jupiter,","karayv","2018-01-24T02:05:47Z","2018-01-24T13:11:37Z"
"","1621","Document Test Kit API","## Overview  Based on the significant change in formalizing and exposing the new `junit-platform-testkit` module, the User Guide should include documentation for the first version of its usage.  ## Related Issues  - #1356  - #1392 - #1662  - #1663   ## Deliverables  - [x] Write Javadoc for methods in `EventConditions` and `TestExecutionResultConditions`. - [x] Document `junit-platform-testkit` in the Release Notes. - [x] Document `junit-platform-testkit` in the User Guide.   - [x] Include in [Dependency Metadata](https://junit.org/junit5/docs/current/user-guide/#dependency-metadata).   - [x] Include in [Dependency Diagram](https://junit.org/junit5/docs/current/user-guide/#dependency-diagram).   - [x] Introduce new _JUnit Platform Test Kit_ chapter including high level overview and usage with common use cases as examples.","closed","component: Test Kit,","dotCipher","2018-10-05T22:11:25Z","2018-12-19T08:54:24Z"
"","1730","Address open issues with TestWatcher API and NodeTestTask.prepare()","## Overview  Based on feedback on the `TestWatcher` extension API by @marcphilipp in https://github.com/junit-team/junit5/pull/1393#discussion_r205951408, there are still a few issues that need to be addressed:  > I checked and `context` is indeed `null` when `prepare()` throws an exception which happens when an exception occurs creating the test instance. >  > If we want to report such failed tests to extensions as well and I think we should, we need to change `prepare` to add the exception to `ThrowableCollector` instead and add `context.getThrowableCollector().assertEmpty()` to `JupiterTestDescriptor.shouldBeSkipped()` (otherwise a test with a failing constructor could be reported as skipped). >  > One more thing I noticed: When something fails on the test class level, e.g. an exception a `@BeforeAll` method, `TestMethodTestDescriptor` never gets called. I think we should clearly document this limitation in the Javadoc of `TestWatcher`.  ## Related Issues  - #542  - #1393   ## Deliverables  - [x] Investigate and address the aforementioned issues.","closed","component: Platform,","sbrannen","2019-01-12T16:25:09Z","2020-01-02T04:13:14Z"
"","991","Enable per-class test instance lifecycle mode by default for Kotlin classes","## Overview  Based on discussions in #905, we have decided to use `@TestInstance(Lifecycle.PER_CLASS)` by default for test classes written in Kotlin.  ## Implementation Notes  The following utility (courtesy of @sdeleuze) can be added to `ReflectionUtils` for detecting Kotlin classes without any external dependencies.  ```java public static boolean isKotlinClass(Class clazz) { 	for (Annotation annotation : clazz.getDeclaredAnnotations()) { 		if (annotation.annotationType().getName().equals(""kotlin.Metadata"")) { 			return true; 		} 	} 	return false; } ```  ## Deliverables  - [x] Use `Lifecycle.PER_CLASS` as the test instance lifecycle mode by default for test classes written in Kotlin. - [x] Document in User Guide and Release Notes.","closed","component: Kotlin,","sbrannen","2017-07-28T11:57:04Z","2017-08-19T11:11:42Z"
"","1190","Document best practices for implementing ParameterResolvers","## Overview  Based on discussions in #1184 and https://github.com/weld/weld-junit/issues/3, it is apparent that we need to document _best practices_ for implementing `ParameterResolver`, particularly with regard to ""playing nicely"" with other registered `ParameterResolver` implementations.  ## Proposed Categories  After having put a bit more thought into the subject, I am tossing around the idea of categorizing `ParameterResolver` implementations by behavior as follows.  - **explicit**: support requires an annotation for disambiguation. - **implicit**: support is automatic for types _owned_ by the resolver. - **speculative**: a resolver claims it _can_ support a given parameter even if it potentially _should not_ (a.k.a., _greedy_ or _eager_).  ## Deliverables  - [ ] Document best practices for `ParameterResolver` implementations in JavaDoc.   - more succinct than the documentation in the User Guide - [ ] Document best practices for `ParameterResolver` implementations in the User Guide.   - including examples and explanations of how to avoid conflicts","open","component: Jupiter,","sbrannen","2017-11-28T16:54:28Z","2022-03-29T14:28:47Z"
"","1133","Treat non-inherited composed annotations for inherited annotations as inherited","## Overview  Based on a [discussion in Gitter](https://gitter.im/junit-team/junit5?at=59f87ebe5a1758ed0f701a15), it has come to my attention that we do not support annotation searches for single annotations and repeatable annotations consistently.  Specifically, we traverse the class hierarchy in search of an annotation **only** if the annotation is _repeatable_ **and** `@Inherited`.  ## Deliverables  - [x] Traverse class hierarchy and meta-annotation hierarchies when searching for non-repeatable annotations that are annotated with `@Inherited`.   - Algorithm located in `AnnotationUtils.findAnnotation(AnnotatedElement, Class, Set)`","closed","component: Platform,","sbrannen","2017-10-31T14:04:28Z","2018-01-15T11:30:53Z"
"","1447","Ensure discovered test descriptor graphs are acyclic","## Overview  At the moment, the `DefaultLauncher` only ensures that an engine root descriptor is non-null. If an engine implementation returns a cyclic test descriptor graph, that graph is passed without any checking to internal filtering and then back to the engine for execution. This may lead to stack overflow issues when traversing the graph without checking for cycles.  For example here:  https://github.com/junit-team/junit5/blob/19a4cde09f1e36f4e270c537f8cf9a474e1746a8/junit-platform-surefire-provider/src/main/java/org/junit/platform/surefire/provider/RunListenerAdapter.java#L116  ## Deliverables  - [x] Detect cycles in test descriptor graphs","closed","theme: discovery,","sormuras","2018-06-05T09:45:26Z","2019-07-19T19:32:25Z"
"","1196","Provide access to configuration parameters via ExtensionContext","## Overview  At the moment, only test engines have access to configuration parameters.  Copied from http://junit.org/junit5/docs/current/user-guide/#running-tests-config-params : _In addition to instructing the platform which test classes and test engines to include, which packages to scan, etc., it is sometimes necessary to provide additional custom configuration parameters that are specific to a particular test engine._  Extension authors may want to configure their extension based on such arguments as well.  ## Related issues  - #497 - #1135   ## Deliverables  - [ ] Add method `Optional getConfigurationParameter(String key)` to `ExtensionContext`","closed","component: Platform,","sormuras","2017-12-04T20:32:36Z","2017-12-23T14:19:59Z"
"","1640","AssertLinesMatch NullPointerException during FastForward evaluation","## Overview  AssertLinesMatch#matches has a bug that will cause a NullPointerException to be thrown after evaluating a FastForward match if there are more expected lines after the FastForward match then remain in the actual results.  This only manifests itself if the expected list size is equal to or larger than the actual list size.  The reason this fails is because after matching the fast forward region, the actual list is now empty but AssertLinesMatch doesn't check for that condition and sends the (null) value from the actualDeque.peek call to AssertLineMatch#matches.  The solution is to simply add a check for `null` in matches.  The return statement could be modified to: ```java return (actualLine != null) && actualLine.matches(expectedLine); ``` An example that illustrates this error can be seen in the following code: ```java List expected = Arrays.asList(""first line"", "">> fails, because final line is missing >>"", ""last line"", ""not present""); List actual = Arrays.asList(""first line"", ""first skipped"", ""second skipped"", ""last line""); Assertions.assertLinesMatch(expected, actual); // <- throws NullPointerException ```  ## Deliverables  A pull request with this issue number as the branch name will be submitted that contains the change to AssertLineMatch#matches and a test method added to AssertLineMatchAssertionsTest to illustrate the bug is fixed.","closed","component: Jupiter,","jimmorgan","2018-10-19T14:23:16Z","2018-11-16T20:30:55Z"
"","1638","Support mixed boxed and unboxed primitives in assertEquals() & assertNotEquals()","## Overview  Asserting that an `int` equals an `Integer` is not possible with `assertEquals()` due to the compiler not knowing if it should use `assertEquals(int, int)` or `assertEquals(Object, Object)`.  This results in the compile error `The method assertEquals(int, int) is ambiguous for the type Assertions` like in the following example:  ```java 	@Test 	void test_parseYear() throws Exception { 		Integer parsedYear = SeparateDateParser.parseYear(""2014""); 		Assertions.assertEquals(2014, parsedYear); // does not compile 	} ```  Instead you either have to declare another variable:  ```java 	@Test 	void test_parseYear() throws Exception { 		Integer parsedYear = SeparateDateParser.parseYear(""2014""); 		Integer expectedYear = 2014; 		Assertions.assertEquals(expectedYear, parsedYear); 	} ```  or use a custom assertion method:  ```java 	void assertEquals(Number expected, Number actual) { 		Assertions.assertEquals(expected, actual); 	} ```  We have already encapsulated this method in a utility class to reuse it in our projects, but as this is a quite common case it would be nice if the framework could provide an `assertEquals()` method like the one above.  ## Related Issues  - #1607   ## Deliverables  - [x] Support mixed boxed and unboxed primitives in `assertEquals()` - [x] Support mixed boxed and unboxed primitives in `assertNotEquals() ` - [x] Document in Release Notes","closed","component: Jupiter,","ridono","2018-10-18T13:50:01Z","2018-10-20T13:45:59Z"
"","1312","Describe non-goals of Arguments, so that users do not mis-use it.","## Overview  As was discussed in #1307, it's a non-goal of `Arguments` to be easily consumed by the user-code. Therefore, a Javadoc is updated to explicitly specify non-goals and to point users to alternatives.  Issue: #1311, #1307   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","dmitry-timofeev","2018-02-25T08:27:26Z","2018-02-25T11:24:22Z"
"","1377","Maven Surefire Plugin does not execute static nested classes","## Overview  As suggested by @sbrannen and maybe related to #1343.  Discussion on SO: https://stackoverflow.com/a/47982480/4365460  Consider this class:  ```java import org.junit.jupiter.api.Test;  class OuterTest {      @Test     void method() {         System.out.println(""OuterTest.method()"");     }      static class InnerTest {          @Test         void method() {             System.out.println(""InnerTest.method()"");         }     } } ```  The tests in `InnerTest` are picked up by Gradle (`junit-platform-gradle-plugin`) and IntelliJ IDEA, but not with the Maven Surefire Plugin.  pom.xml:  ```xml      UTF-8      1.1.0     5.1.0                 org.junit.jupiter         junit-jupiter-api         ${junit-jupiter.version}         test                                   org.apache.maven.plugins             maven-surefire-plugin             2.19.1                                                   org.junit.platform                     junit-platform-surefire-provider                     ${junit-platform.version}                                                       org.junit.jupiter                     junit-jupiter-engine                     ${junit-jupiter.version}                                              ```  The issue is reproducible with 5.0.0, 5.1.0 and 5.2.0-M1 (and related version of JUnit Platform).  ## Related Issues  - #1343","closed","3rd-party: Maven Surefire,","rweisleder","2018-04-17T11:00:58Z","2018-04-17T13:45:18Z"
"","1027","Add missing private constructors to utilities classes","## Overview  As requested by @sbrannen in https://github.com/junit-team/junit5/pull/961/files#r134089533, this PR takes a subset of the changes proposed for https://github.com/junit-team/junit5/pull/961/files and makes them a separate PR.  This is just a cleanup PR designed to add missing private constructors to various utilities classes.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","jbduncan","2017-08-19T16:48:01Z","2017-08-21T17:21:00Z"
"","1028","Polishing","## Overview  As requested by @sbrannen in https://github.com/junit-team/junit5/pull/961, I have moved some ""Polishing"" changes to this PR, whilst adding other changes that I think improve readability.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: task,","jbduncan","2017-08-21T19:19:59Z","2017-08-23T17:53:06Z"
"","1148","JUnit 4 Migration Support incorrectly registers JupiterTestEngine via ServiceLoader","## Overview  As reported in the [Eclipse issue tracker](https://bugs.eclipse.org/bugs/show_bug.cgi?id=525948#c12), the `junit-jupiter-migrationsupport` module attempts to register the `JupiterTestEngine` via the `ServiceLoader` mechanism.  This is obviously the result of a copy-n-paste error that occurred when the `junit-jupiter-migrationsupport` Gradle project was created.  ## Deliverables  - [x] Delete `/junit-jupiter-migrationsupport/src/main/resources/META-INF/services/org.junit.platform.engine.TestEngine`. - [x] Document in release notes.","closed","component: Jupiter,","sbrannen","2017-11-07T16:16:44Z","2017-11-07T16:40:45Z"
"","1656","Extend JRE enum to support Java 12","## Overview  As Java moves faster and ships a major feature release every six months, the [JRE](https://github.com/junit-team/junit5/blob/master/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/JRE.java) enum in package `org.junit.jupiter.api.condition` should be updated accordingly.   See http://jdk.java.net for all available Java versions.  ## Deliverables  Perform the following for Java 12.  - [x] Extend `enum JRE` with the new `JAVA_N` constant, with `N` being the latest feature version number. - [x] Update `EnabledOnJreIntegrationTests`, `DisabledOnJreIntegrationTests`, `EnabledOnJreConditionTests`, and `DisabledOnJreConditionTests` accordingly. - [x] Update `EnabledOnJreIntegrationTests`, `DisabledOnJreIntegrationTests`, `EnabledOnJreConditionTests`, and `DisabledOnJreConditionTests` accordingly. - [x] Test against JDK `N`. - [x] Document in Release Notes.","closed","theme: modules,","sormuras","2018-10-30T11:16:14Z","2019-02-04T19:51:15Z"
"","972","Consider breaking down Gradle build into sub-scripts for maintainability","## Overview  As I'm working on https://github.com/junit-team/junit5/pull/961, I've come to realise that the `build.gradle` file could be organised better, as I'm currently having to jump about and edit disparate lines in the file just to import error-prone and get it working properly on both JDK 8 and JDK 9.  Consider organising the Gradle build in a similar fashion to [Caffeine](https://github.com/ben-manes/caffeine)'s, where dependencies, code quality tools, publishing functions etc. are extracted into their own `gradle/*.gradle` sub-scripts, which are then imported into the project's other `.gradle` files as needed.  ## Deliverables  - [ ] ` build.gradle` is broken down into sub-scripts as appropriate.","closed","status: stale,","jbduncan","2017-07-21T14:42:32Z","2021-05-13T20:23:09Z"
"","1395","Rename ArgumentsAccessorException to ArgumentAccessException","## Overview  As documented in the JavaDoc for `ArgumentsAccessorException`:  > `ArgumentsAccessorException` is an exception thrown by an `ArgumentsAccessor` if an error occurs while accessing or converting an argument.  Thus, such exceptions specifically apply to an attempt to access a single argument, not multiple _arguments_.  ## Deliverables  - [x] Rename `ArgumentsAccessorException` to `ArgumentAccessException`.","closed","component: Jupiter,","sbrannen","2018-04-27T08:45:22Z","2018-04-27T10:49:36Z"
"","1705","Add around() to Node to allow intercepting the whole execution","## Overview  as discussed with @marcphilipp   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","leonard84","2018-12-19T12:20:50Z","2019-03-30T13:00:08Z"
"","1782","Document comment support in @CsvFileSource","## Overview  As discussed on [Stack Overflow](https://stackoverflow.com/questions/54681066/csvfilesource-junit-5-skip-line), it is possible to comment out arbitrary lines in CSV files.  The default comment character in `com.univocity.parsers.csv.CsvFormat` is `#`; however, we do not document this feature anywhere for JUnit Jupiter.  ## Deliverables  - [x] Document comment support in `@CsvFileSource` in Javadoc. - [x] Document comment support in `@CsvFileSource` in User Guide. - [x] Document comment support in `@CsvFileSource` in Release Notes. - [x] Consider documenting the same support in `@CsvSource`, if the team deems it to make sense. - [x] Introduce tests to verify the support (and serve as regression tests for the documented feature).","closed","theme: parameterized tests,","sbrannen","2019-02-17T13:18:44Z","2019-08-07T15:03:19Z"
"","1555","Document how to use CloseableResource","## Overview  As discussed in the [Gitter channel](https://gitter.im/junit-team/junit5?at=5b7717ae796f7b601d576d2e), users would greatly benefit from detailed documentation and examples regarding how to make use of `CloseableResource` in the `ExtentionContext.Store`.  ## Deliverables  - [ ] Document how to use `CloseableResource` in various scenarios, potentially via examples in the `junit5-samples` repository.","open","component: Jupiter,","sbrannen","2018-08-19T15:38:17Z","2022-06-20T18:18:38Z"
"","1814","Introduce cleanup mode in @TempDir","## Overview  As discussed in https://github.com/spring-io/initializr/issues/862, the `TempDirectory` may fail to clean up the temporary directory due to various reasons, but sometimes the user would prefer that the extension not cause the test to fail if certain files or folders within the temporary directory cannot be deleted.  Introducing a configurable clean up mode would help to support such use cases.  ## Proposal  Proposal by @marcphilipp:  > I think it should be strict by default in order to catch subtle bugs in the code under test, e.g. an unclosed stream. But changing to a lenient mode via the annotation (sth. like `@TempDir(cleanupMode = LENIENT)`) or a configuration parameter is certainly sth. we can consider for 5.4.1.  ## Deliverables  - [ ] Introduce a means to opt out of test failure when the temporary directory cannot be cleaned up automatically. - [ ] Document in Javadoc. - [ ] Document in User Guide. - [ ] Document in Release Notes.","closed","component: Jupiter,","sbrannen","2019-03-13T12:42:41Z","2021-07-03T15:43:12Z"
"","1645","Improve class-level Javadoc for support classes","## Overview  As discussed in https://github.com/junit-team/junit5/pull/1644#discussion_r227276117, the class-level Javadoc for the support classes in `org.junit.platform.commons.support` should be improved.  ## Deliverables  - [ ] Improve class-level Javadoc for classes in `org.junit.platform.commons.support`.","closed","component: Platform,","britter","2018-10-23T08:42:19Z","2018-10-23T10:53:37Z"
"","1015","Introduce support for configuration parameters in console launcher and build plugins","## Overview  As discussed in https://github.com/junit-team/junit5/issues/905#issuecomment-322001390, there is currently no native support for setting a _configuration parameter_ via the console launcher, Maven Surefire plugin, or Gradle plugin.  Thus, the only option from the build perspective is to set a system property or rely on the presence of a JUnit Platform _configuration file_ (see #1003).  For the JUnit Platform Gradle Plugin, you can set such a system property via a work-around that is discussed in https://github.com/junit-team/junit5/issues/475#issuecomment-242038043.  ## Proposal  ### ConsoleLauncher  Introduce a `--config` command line option that expects a `key=value` pair.  ```sh java -jar junit-platform-console-standalone-*.jar \      --config junit.jupiter.extensions.autodetection.enabled=true \      --config junit.jupiter.testinstance.lifecycle.default=per_class ```  ### Gradle  Align with the syntax supported for JVM system properties by Gradle tasks:  `systemProperty('java.util.logging.manager', 'org.apache.logging.log4j.jul.LogManager')`  This gives us:  ```groovy junitPlatform {   // ...   configurationParameter('junit.jupiter.extensions.autodetection.enabled', 'true')   configurationParameter('junit.jupiter.testinstance.lifecycle.default', 'per_class')   // ... } ```  Note, however, that the parentheses are optional in Groovy resulting in the following alternative syntax being supported out of the box.  ```groovy junitPlatform {   // ...   configurationParameter 'junit.jupiter.extensions.autodetection.enabled', 'true'   configurationParameter 'junit.jupiter.testinstance.lifecycle.default', 'per_class'   // ... } ```  ### Maven  Surefire does not support nested structures within `properties`, but that's not an issue if we take inspiration from Spring's support for inlined `Properties` in XML configuration, resulting in the following.  ```xml // ...               // ...                      maven-surefire-plugin             2.19                                                   integration, regression                                            junit.jupiter.extensions.autodetection.enabled = true                       junit.jupiter.testinstance.lifecycle.default = per_class                                                                                 // ...                             // ... ```  For an example of how the `configurationParameters` can be converted to a `Map` with full support for the `java.util.Properties` syntax, see https://github.com/junit-team/junit5/issues/1015#issuecomment-323584880.  ## Deliverables  - [x] Introduce support for setting configuration parameters in the console launcher. - [x] Introduce support for setting configuration parameters in the JUnit Platform Gradle Plugin. - [x] Introduce support for setting configuration parameters in the Maven Surefire Plugin. - [x] Update User Guide. - [x] Update release notes. - [X] ~Prepare sample projects.~","closed","3rd-party: Gradle,","sbrannen","2017-08-12T19:39:25Z","2017-08-22T18:04:19Z"
"","1790","Enforce findMethod to prioritize specific over generic methods","## Overview  As discussed in #981, `ReflectionUtils.findMethod` currently returns the first method that satisfies the signature requirements rather than the method with the most specific (non-generic) matching signature.  This can cause methods with matching generic signatures to be chosen over a matching non-generic signature. This test enforces that a matching non-generic signature is chosen over a matching generic signature.  This PR will fail the build until `ReflectionUtils.findMethod` prioritizes a method with non-generic parameters that satisfy the required signature over a method with generic parameters that satisfies the required signature.   I think that the issue in the search algorithm lies [here](https://github.com/junit-team/junit5/blob/311bb71a793c07d7e3000a5d32204e0cf598f590/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java#L1237-L1242), where a method with a matching signature is immediately returned, making it ordering sensitive. Perhaps instead of immediately returning the matching method, all matching methods should be saved and the most specific/non-generic method should be determined and returned?  I'd be happy to try and investigate the possibilities of such a solution.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","jadeleeuw","2019-02-21T18:57:56Z","2021-06-19T12:50:33Z"
"","1824","MethodOrderer.Random seed generation and handling improvements","## Overview  As discussed in #1805 it is hard to rerun exactly the same test if the MethodOrderer.Random has been used.   1. It used to generate the fallback seed per test execution and based on `System.nanoTime()`, which made it ""random"" through out the run. 2. It did not provide any log output to the user, to retrieve the information what seed he should use.  In this pullrequest, we change the initialization of the seed to a static one, so it will be the same seed for all tests. Additionally we log the generated seed at the beginning with an log level `CONFIG`.  During the implementation we also found an issue regarding concurrent runs with random seeds, and that we can not guarantee the order based on thread assignment. Hence that the team decided that if a test is ran with MethodOrderer.Random it will be always executed in the same thread.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: diagnostics,","aepfli","2019-03-18T16:05:17Z","2019-04-07T12:28:39Z"
"","973","Use `Optional.map` and `ArrayDeque` more consistently","## Overview  As described in the commit message:  ```txt - Use of `Optional.map` was reported by IntelliJ IDEA inspections. - `ArrayDeque` javadoc states that it is likely to be ""faster than   `LinkedList` when used as a queue"". ```  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","jbduncan","2017-07-22T16:04:34Z","2017-07-27T14:10:40Z"
"","1670","Add missing Precondition checks to published *Support methods","## Overview  As currently implemented, invocations of many of the methods in `AnnotationSupport`, `ReflectionSupport`, etc. could result in a `NullPointerException`.  ## Deliverables  - [x] Implement and document (in method-level Javadoc) preconditions in `AnnotationSupport`, `ClassSupport`, `ModifierSupport`, `ReflectionSupport`, and their corresponding `*Utils` classes. - [x] Unit test preconditions in `AnnotationSupport`, `ClassSupport`, `ModifierSupport`, `ReflectionSupport`, and their corresponding `*Utils` classes.","closed","component: Platform,","sbrannen","2018-11-08T14:34:26Z","2018-11-24T12:48:05Z"
"","1595","Add CamelCase Display Name Generator","## Overview  As a follow-up from #1588 use the `DisplayNameGenerator` SPI to turn names of test classes and test methods using camel-case notation into human-readable display names.  ## Related Issues  - #1596   ## Deliverables  - [ ] Create and implement `CamelCaseGenerator` in `org.junit.jupiter.api.DisplayNameGenerator` - [ ] Integrate this new pre-defined generator into `org.junit.jupiter.engine.descriptor.DisplayNameUtils` - [ ] Extend `org.junit.jupiter.api.DisplayNameGenerationTests` to verify the implementation","closed","type: new feature,","sormuras","2018-09-23T14:14:04Z","2020-05-22T19:55:43Z"
"","1596","Create IndicativeSentences Display Name Generator","## Overview  As a follow-up from #1588 use the `DisplayNameGenerator` SPI to turn names of test classes and test methods using camel-case and/or underscores in their notation into human-readable display names that form complete sentences.  ## Example  From ""fragments"" using `@DisplayName` for each fragment, thus duplicating the same information as encoded in the associated method name...  https://github.com/junit-team/junit5/blob/91279b2cb70636ea4c24bb4a1b5a4e976adab405/documentation/src/test/java/example/TestingAStackDemo.java#L27-L97  ...resulting in this picture...  ![fragments](https://user-images.githubusercontent.com/2319838/45813051-dc006400-bcd1-11e8-9543-ac5279c2c6c0.png)  ...to ""indicative sentences"", merging contexts and auto-prettify display names based on the method names:  ![sentences](https://user-images.githubusercontent.com/2319838/45813065-e1f64500-bcd1-11e8-9b10-717b6d1ff82e.png)  ## Related Issues  - #1595   ## Deliverables  - [ ] Create and implement `IndicativeSentencesGenerator` in `org.junit.jupiter.api.DisplayNameGenerator` - [ ] Integrate this new pre-defined generator into `org.junit.jupiter.engine.descriptor.DisplayNameUtils` - [ ] Extend `org.junit.jupiter.api.DisplayNameGenerationTests` to verify the implementation","closed","type: new feature,","sormuras","2018-09-23T14:20:10Z","2020-06-18T17:13:28Z"
"","1202","Cache downloaded external dependencies and Gradle Wrapper","## Overview  As [suggested by Travis](https://docs.travis-ci.com/user/languages/java/#Caching), cache downloaded, external dependencies and Gradle Wrapper. Subsequent builds will reuse existing files which should significantly speed up CI execution.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Gradle,","bmuschko","2017-12-11T16:36:11Z","2018-01-12T13:43:08Z"
"","1564","PR: Add implicit argument converter for String to Class","## Overview  Arguments like ""java.lang.Integer"" should be converted to `Class` by calling `Class.forName(String)`. Automatic string-to-object conversion with `FallbackStringToObjectConverter` doesn't handle that case because `Class` has a second applicable static factory method (`getPrimitiveClass(String)`).  It is thus necessary to explicitly implement the call to `forName`.  Closes #1562  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] (_not applicable_) Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] (_not applicable_) Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","nipafx","2018-08-29T08:16:25Z","2020-09-08T18:29:42Z"
"","974","Rename Spotless variables in build.gradle for clarity","## Overview  Arguably, the variables affected by this PR weren't as informatively- and intuitively-named as they could have been. This PR attempts to fix that.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jbduncan","2017-07-22T16:08:46Z","2017-07-30T18:55:43Z"
"","1540","Introduce ""Deprecated APIs"" section in User Guide","## Overview  Analogous to the existing [Experimental APIs](https://junit.org/junit5/docs/snapshot/user-guide/#api-evolution-experimental-apis) section in the User Guide, we should introduce a ""Deprecated APIs"" section as well.  ## Related Issues  - #1317  - #1536   ## Deliverables  - [x] Introduce ""Deprecated APIs"" section in User Guide","closed","3rd-party: Gradle,","sbrannen","2018-08-12T09:55:24Z","2018-08-14T10:12:23Z"
"","1174","Introduce lifecycle support for objects stored in ExtensionContext.Store","## Overview  An extension context store is bound to its extension context lifecycle. When an extension context lifecycle ends it closes its associated store. All stored values that are instances of `ExtensionContext.Store.CloseableResource` are notified by invoking their `close()` method.  Addresses https://github.com/junit-team/junit5/issues/456#issuecomment-341120548 -- enhance the ""engine level context store"" with a **cleanup** hook.  Closes #742  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2017-11-18T22:36:27Z","2017-12-28T20:11:21Z"
"","1438","JupiterTestEngine should log discovery errors instead of aborting the entire test plan","## Overview  An error reported in #1436 has made us aware that the entire test plan for JUnit Jupiter aborts whenever certain types of errors occur during the discovery phase. Consequently, a single error (e.g., an invalid class file format) can result in **zero** tests being discovered and executed.  This is, however, unacceptable behavior. The `JupiterTestEngine` should log such errors rather than abort the entire discovery process. Logging such errors allows the test plan to discover and execute as many tests as possible while still informing the user of tests that could not be properly _discovered_.  ## Proposal  One possible solution would be to add try-catch blocks to `resolveClass()`, `resolveMethod()`, and `resolveUniqueId()` in `JavaElementsResolver`. These try-catch blocks should log errors and swallow them (unless they are _blacklisted_ exceptions).  ## Related Issues  - #1436   ## Deliverables  - [x] Ensure that the `JupiterTestEngine` does not abort the entire discovery process when an exception is encountered.","closed","theme: discovery,","sbrannen","2018-05-31T13:33:14Z","2018-06-03T14:56:13Z"
"","1651","Use realistic examples in User Guide","## Overview  Although the examples in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) are technically correct, many of them are not ""good examples"" for people new to JUnit 5 and JUnit Jupiter in particular.  For example, I hear complaints about examples such as `assertEquals(2, 2)`, examples that use `foo` and `bar`, or the fact that the `assertThrows(...)` example [throws an exception directly instead of invoking user code that throws an exception](https://stackoverflow.com/questions/52825082/understanding-exception-tests-in-junit-5).  ## Guidelines  1. Avoid the use of meaningless assertions such as `assertEquals(2, 2)` or `assertTrue(true)`.    - Replace such assertions with something more meaningful such as `assertEquals(3, calculator.add(1, 2)` and `assertTrue(isPalindrome(""racecar""))`, respectively. 1. Focus on a realistic domain model throughout the examples.     - For example, we already have `example.ParameterizedTestDemo.isPalindrome(String)` (which could be relocated to something like a `StringUtils` class) and a [`Person` class](https://github.com/junit-team/junit5/blob/master/documentation/src/test/java/example/Person.java).    - The aforementioned `Calculator` is from my examples in [junit5-demo](https://github.com/sbrannen/junit5-demo/tree/master/src/main/java/demo); a `StringUtils` class exists there with the aforementioned `isPalindrome(String)` method. 1. I propose for starters that we focus on reusing `isPalindrome()`, `Person`, and `Calculator` for most examples.    - As mentioned by [@foobarjet on Twitter](https://twitter.com/foobarjet/status/1055902451902091264), _if necessary_ we can embellish tests using standard JDK libraries (e.g., `List`, etc.).    - If we need something more along the lines of ""integration testing"" examples, we can consider reusing (and enhancing, if necessary) the existing [`WebClient` demo code](https://github.com/junit-team/junit5/blob/master/documentation/src/main/java/example/registration/WebClient.java). 1. We should **not** actually implement anything complex to use as an example.    - For example, the aforementioned `WebClient` does not do anything at all, **but**... it _appears_ to do something realistic in the [examples that use it in the User Guide](https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic-static-fields), and that's our primary goal: _for the examples to appear realistic_.    - Granted, the `isPalindrome(String)` method does actually do something realistic, _but_ it was not difficult to implement. 😇   ## Deliverables  - [x] Revise examples in the User Guide (i.e., in the `documentation` project) so that the examples appear to be ""real world"" examples.    - [x] Replace assertions such as `assertEquals(2, 2)` with something more meaningful such as `assertEquals(3, calculator.add(1, 2)`.    - [x] Replace assertions such as  `assertTrue(true)` with something more meaningful such as `assertTrue(isPalindrome(""racecar""))`.    - [x] Replace _dummy_ variable names and values (e.g., `foo`, `bar`, `baz`, etc.) with something more meaningful. For example, switching to names of fruits might work out nicely, as was done for an example with `@CsvSource` (search for ""apple"").    - [x] Revise examples for `assertThrows(...)` so that it appears that user code is being tested instead of an inline lambda expression that throws an exception.","closed","component: Vintage,","sbrannen","2018-10-26T12:42:14Z","2019-01-04T14:22:41Z"
"","1110","Introduce getOrComputeIfAbsent() variant for default constructor in ExtensionContext.Store","## Overview  After gaining experience with implementing extensions that wish to store a single object a given type using the type's default constructor, I have discovered that I always copy-n-paste the following code snippet to each extension implementation (where `X` is the type of object supported by the extension).  ```java X x = store.getOrComputeIfAbsent(X.class, k -> new X(), X.class); ```  This pattern can be seen in `@TrackLogRecords.Extension.getListener(ExtensionContext)` within our own test suite as well as in the [`@CaptureSystemOutput`](https://github.com/sbrannen/junit5-demo/blob/master/src/test/java/extensions/CaptureSystemOutput.java) extension that I created yesterday.  Since the `getOrComputeIfAbsent(X.class, k -> new X(), X.class)` pattern is so common, it would be nice to introduce a convenience method in `ExtensionContext.Store` with the following signature that does the same thing behind the scenes: `public  V getOrComputeIfAbsent(Class type)`.  ## Deliverables  - [x] Introduce `public  V getOrComputeIfAbsent(Class type)` in `ExtensionContext.Store` that gets an object of type `type` (keyed by `type`) if present in the store and otherwise invokes the default constructor for `type` to generate the object.","closed","component: Jupiter,","sbrannen","2017-10-15T15:15:41Z","2017-10-15T16:18:54Z"
"","1415","JUnit 5 Theories","## Overview  Adds theories, in a form similar to JUnit 4's Theories. This will close ticket #395.  Substantial changes from JUnit 4:  - Methods allowed as sources of data points - Streams and Iterators as accepted data point types, but only when produced by methods (since both are stateful, they have to come from a method so they can be read more than once) - Suppliers system for simple data points (similar in form to parameterized tests, but allows mixing of in-line data points with class-level data points)   - Specified via the `ArgumentsSuppliedBy` meta-annotation. This ties the annotation to a supplier class   - Supplier class implements `TheoryArgumentSupplier` (or extends `AbstractTheoryArgumentSupplier` for common use cases). This class reads the annotation and produces the corresponding data points   - Examples: ``` @Theory public void myTheory(@IntValues(0, 42, 99) int someIntValue)  @Theory public void myTheory(@ByteValues(0, 42) byte somByteValue, SomeClass valueFromClassLevelDataPoint) ``` - Qualifiers directly on theory parameters. Example: ``` @DataPoints(qualifiers = ""nonZero"") private static final List GREATER_THAN_ZERO = Arrays.asList(3, 5, 7);  @DataPoint private static final Double ZERO = 0;  @DataPoint(qualifiers = ""nonZero"") private static final double NEGATIVE_NUMBER =  -4;  @Theory public void testDivisionOperator(double dividend, @Qualifiers(""nonZero"") double divisor) ```  A few (very rough) examples can be found in: junit-jupiter-theories/src/test/java/org/junit/jupiter/theories/TheoriesTestCase.java  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","nrllewellyn","2018-05-11T07:26:08Z","2018-05-16T05:11:41Z"
"","1672","[WIP] Introduce ResourceSupplier SPI","## Overview  Addresses part of #1555 by providing a new default extension handling `@New` and `@Singleton` annotations.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sormuras","2018-11-09T10:05:21Z","2019-02-05T13:12:29Z"
"","1392","Introduce JUnit Platform Test Kit","## Overview  Addresses issue #1356 by building an `ExecutionRecorder` that returns an `ExecutionsResult` from the platform run based on a provided `TestEngine`.  This should allow us to ask both micro and macro questions against the `ExecutionsResult` for answering questions like: - How many tests were skipped? What were their ids? - How many dynamic tests were registered? - What events happened when?  Replaces #1380   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Test Kit,","dotCipher","2018-04-25T18:19:22Z","2018-11-03T16:56:10Z"
"","1261","Introduce JMH-based benchmarks","## Overview  Addresses https://github.com/junit-team/junit5/pull/1260#issuecomment-360400653 _""[...] I'd like to see some micro-benchmarks that verify that this is a real issue. Can you use JMH to do that?""_  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---","closed","3rd-party: Gradle,","sormuras","2018-01-25T13:24:06Z","2018-01-28T20:31:33Z"
"","1614","[WIP] Introduce extension API for accessing arguments passed to tests","## Overview  Addresses : #1139  Adding a BeforeParameterizedTestExecutionCallback to be called prior to test method execution with a copy of the actual test arguments.  Points for discussion:  - Naming of the callback. - Currently, the arguments are resolved twice via the DefaultParameterResolver.  It would be better to do this once (and pass a copy to the callback) but this would require a change to the ExecutableInvoker API.  I'm happy to do this but thought I'd wait from feedback first.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","paul-brooks","2018-10-03T09:06:50Z","2021-09-03T15:04:38Z"
"","1143","Introduce before and after callbacks at the Jupiter engine-level","## Overview  Addresses #456   This PR is a basis for discussion. Error handling and documentation are left out on-purpose.  ### Usage ```java @BeforeEngineExecution static void before0() { 	countBefore0++; }  @BeforeEngineExecution static void before0(ExtensionContext context) { 	context.getStore(ExtensionContext.Namespace.GLOBAL).put(""alpha"", ""omega""); 	countBefore0++; }  @AfterEngineExecution static void after0(ExtensionContext context) { 	assertEquals(""omega"", context.getStore(ExtensionContext.Namespace.GLOBAL).get(""alpha"")); 	countAfter0++; }  @AfterEngineExecution void after0NonStatic(ExtensionContext context) { 	assertEquals(""omega"", context.getStore(ExtensionContext.Namespace.GLOBAL).get(""alpha"")); 	countAfter0++; } ```  ### Implementation notes  * If a single parameter `ExtensionContext` is declared in an annotated method, the root `ExtensionContext` of `JupiterEngineExecutionContext` is injected at runtime. * `@BeforeEngineExecution`-annotated methods must be `static`. * `@AfterEngineExecution`-annotated methods must be `static`. If you're using `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`, `@AfterEngineExecution`-annotated methods don't have be `static`. * ~~`@ExtendWith(AlphaOmega.class)` does **not** work at the moment.~~  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2017-11-05T10:12:22Z","2018-05-28T10:11:04Z"
"","1867","Move PreconditionViolationException to base package","## Overview  Addresses #1863  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2019-04-20T06:41:51Z","2019-04-29T06:52:35Z"
"","1588","Introduce Display Name Generator SPI","## Overview  Addresses #162   ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sormuras","2018-09-16T14:44:15Z","2019-08-05T13:53:33Z"
"","1599","Use 'java-compiler-script-engine' evaluating Java snippets","## Overview  Addresses #1481  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2018-09-25T06:28:21Z","2019-05-01T13:38:26Z"
"","1428","Add TestSource support to dynamic containers and tests","## Overview  Addresses #1178  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: dynamic tests,","sormuras","2018-05-22T16:32:21Z","2018-06-15T08:24:10Z"
"","1396","[WIP] Add tag and test source support to dynamic containers and tests","## Overview  Addresses #1178  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: dynamic tests,","sormuras","2018-04-28T08:21:04Z","2019-07-19T19:32:24Z"
"","1171","#1132 Add annotation and reflection sections to supported utilities section","## Overview  Added two sections detailing annotation and reflection support, paraphrasing the javadoc.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","component: Platform,","ghost","2017-11-18T01:41:29Z","2017-11-25T15:41:13Z"
"","1008","WIP: SonarQube configuration","## Overview  Added SonarQube (static code analysis) configuration. Tested on a local instance of SonarQube 6.5 (build 27846). Clover configuration, e.g. code coverage, has not been verified (requires license). Run with default parameters (sonar.host.url=localhost:9000, sonar.login=admin, sonar.password=admin) using command: gradlew sonarqube  Next step: - Register free account at https://about.sonarcloud.io/ and follow simple tutorial steps to integrate with CI  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","alixwar","2017-08-07T10:45:41Z","2020-04-07T21:06:35Z"
"","1385","Add link to Mockito","## Overview  Added a link to Mockito's repo.  I'm not sure if the items from Definition of Done should be checked for this case.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","wilder","2018-04-24T01:49:50Z","2018-04-27T10:38:17Z"
"","1829","[Event] Add JUnit 5 event","## Overview  Added a [JUnit 5 event](https://cfp.devoxx.fr/2019/talk/TPC-2275) at [Devoxx France 2019](https://www.devoxx.fr/).  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","juliette-derancourt","2019-03-22T22:00:34Z","2019-03-24T19:31:15Z"
"","1763","Introduce support for final modifiers in ModifierSupport and ReflectionUtils","## Overview  Added `isFinal`/`isNotFinal` methods to both `ReflectionUtils` and `ModifierSupport` to check for `final` modifier on classes or methods/fields. Methods for classes are added for symmetry with others. Tests included.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","grossws","2019-02-06T17:16:34Z","2019-03-08T12:32:04Z"
"","1949","Make maxStackTraceLines configurable in TestExecutionSummary","## Overview  Add the possibility of specifying the max stack trace when printing failures. This is for issue #1947   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - ❌ Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","arcuri82","2019-07-07T17:04:53Z","2019-07-16T14:26:08Z"
"","1034","Add program that prints usages of @API annotation","## Overview  Add program that prints usages of @API annotation.  See current result at https://gist.github.com/sormuras/2f3df0f4d35af83b625eff66d8a9f130  Addresses #856   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","3rd-party: Gradle,","sormuras","2017-08-28T19:28:09Z","2017-08-29T12:50:46Z"
"","1151","Support skip headers option for @CsvFileSource","## Overview  Add option for `skipHeaders`, or something like it to annotation `@CsvFileSource`, that would make the parser skip the first line of the csv file.  This would improve readability of the CSV files. It might even allow my non-coding-colleagues to write the test parameters.","closed","theme: parameterized tests,","jensim","2017-11-08T12:32:18Z","2022-03-22T10:21:49Z"
"","1041","Support test sharding","## Overview  Add LauncherDiscoveryRequestBuilder.visitors()  This allows users of the launcher to learn about the discovered tests before filters are applied. This is essential for build systems like Bazel that want to ""shard"" (aka partition) a test run into multiple processes while ensuring that the tests included in each ""shard"" are consistent, even if test discovery does not result in a deterministic ordering of tests (see https://goo.gl/Yj4fXL for what Bazel does to Shard JUnit4 tests today).  This change also creates a wrapper to make a TestDescription unmodifiable. This ensures that tests cannot be removed during the visit phase, and cannot be added during the filtering stage.  Finally, FilterResult is made final, so that no one can override the methods to make them inconsistent with one another.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","kcooney","2017-09-02T07:46:45Z","2020-05-28T01:57:02Z"
"","1055","Collecting launcher","## Overview  Add CollectingLauncher which provides access to TestCollection.      The TestCollection allows users of Launcher to review the test plan, do additional filtering, and execute the tests, without going through a potentially expensive discovery stage more than once.  This pull contains three commits. Please don't squash them.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","kcooney","2017-09-09T16:33:32Z","2020-07-10T13:33:28Z"
"","1221","Add argument conversions for Currency, Locale, and URI","## Overview  Add argument conversions for [Currency](https://docs.oracle.com/javase/8/docs/api/java/util/Currency.html), [Locale](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html), and [URI](https://docs.oracle.com/javase/8/docs/api/java/net/URI.html)  Related issue: #1218  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","hisener","2017-12-30T11:30:13Z","2017-12-30T14:16:55Z"
"","1544","Add `jdeps`-based cycle checks","## Overview  Add `jdeps`-based checks to `platform-tooling-support-tests` ensuring we don't introduce unwanted or cyclic module and package references.  Might replace usage of Degraph.  Addresses part of #1437  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Platform,","sormuras","2018-08-13T10:02:31Z","2018-08-19T08:58:29Z"
"","1517","Identify expected value in parameterized test arguments","## Overview  Add `expected` attribute to `@ParameterizedTest` and if present change default output to `[{index}] {input} ~> {expected}` (or similar).  ## Status Quo  When writing parameterized tests it is common to pass in input data together with the expected output, e.g.:  ```java @ParameterizedTest @CsvSource({ ""I, 1"", ""II, 2"", ""V, 5"" }) void testWithDisplayName(String roman, int arabic) { /*...*/ } ```  ``` # display names [1] I,1 [2] II, 2 [3] V, 5 ```  This is nice, but can be improved by pointing out what is input and what is expected:  ``` java @DisplayName(""Roman numeral"") @ParameterizedTest(name = ""\""{0}\"" should be {1}"") ```  ``` # display names ""I"" should be 1 ""II"" should be 2 ""V"" should be 5 ```  But... [can't somebody else do that](https://www.youtube.com/watch?v=YihiSqO4jnA&t=25s)?  ## Proposal  Add an attribute `expected` to `@ParameterizedTest` that names the parameter holding the test's expected result:  ```java @ParameterizedTest(expected = ""arabic"") @CsvSource({ ""I, 1"", ""II, 2"", ""V, 5"" }) void testWithDisplayName(String roman, int arabic) { /*...*/ } ```  If `expected` is present, Jupiter makes the new placeholders `{input}` and `{expected}` (a partition of `{arguments}`) available for naming tests and switches the default from name from `[{index}] {arguments}` to `[{index}] {input} ~> {expected}`. (All names and formats are up for bike-sheds!)  ## Related Issues  - #1309","closed","status: stale,","nipafx","2018-08-01T12:06:32Z","2021-06-03T20:47:19Z"
"","1123","Add --select-module support to Gradle JUnitPlatformPlugin","## Overview  Add --select-module support to Gradle JUnitPlatformPlugin.  Test it using jitpack: https://jitpack.io/com/github/junit-team/junit5/issues~1119-gradle-plugin-modules-support-SNAPSHOT/build.log  Closes #1119  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Gradle,","sormuras","2017-10-20T07:04:03Z","2017-10-22T11:15:49Z"
"","1093","Promote API Status of parameterized tests","## Overview  According to the user guide the following types in the `junit-jupiter-params` module are currently annotated with API Status `EXPERIMENTAL`:   `ParameterizedTest`, `ArgumentConversionException`, `ArgumentConverter`, `ConvertWith`, `JavaTimeConversionPattern`, `SimpleArgumentConverter`, `Arguments`, `ArgumentsProvider`, `ArgumentsSource`, `ArgumentsSources`, `CsvFileSource`, `CsvSource`, `EnumSource`, `MethodSource` and `ValueSource`.  Additionally the user guides gives a warning about using these types:  > Caution should be taken when relying on such APIs.  Because of this people might hesitate to start using parameterized tests in regular projects. As I feel that parameterized tests haven been tried and tested and are a valuable part of JUnit Jupiter I propose to promote the API Status to `MAINTAINED` or `STABLE`.  If you agree I can set up a pull request.  ## Deliverables  - [x] Promote API Status of types related to parameterized tests to `MAINTAINED` or `STABLE`","closed","theme: parameterized tests,","BlueIce","2017-10-04T18:29:47Z","2020-08-07T10:37:14Z"
"","1258","Certain JUnit Jupiter assertions perform slower than JUnit 4.12's","## Overview  Accidentally I found out that JUnit 5.0.3 assertion (assertTrue) worked significantly slower comparing to JUnit 4.12.  In my 2 tests I repeat the same assertion many times. One test uses old junit, other - junit5.  https://github.com/karayv/junit-perf-demo/blob/master/src/test/java/my/perftest/JUnit5Test.java ```java public class JUnit5Test {     TestRunner testRunner = new TestRunner();      @Test     void test() {         testRunner.go(Assertions::assertTrue);     } } ``` I was able to pass **288230376151711744 assertions in 1.515 sec with JUnit 4**  and only **17179869184 assertions in 3.015 sec with JUnit 5**  I created a sample repo https://github.com/karayv/junit-perf-demo where the issue can be reproduced and possibly investigated. It contains four classes: _JUnit5Test_, _OldJUnitTest_, _TestRunner_ and a imaginary super fast prod service - _Library_.  Full console output for both tests:  _JUnit5Test:_ ``` Level of load: 15, duration: PT0.195S, number of operations: 1073741824 Level of load: 16, duration: PT0.771S, number of operations: 4294967296 Level of load: 17, duration: PT3.015S, number of operations: 17179869184 ```   _OldJUnitTest:_ ``` Level of load: 26, duration: PT0.185S, number of operations: 4503599627370496 Level of load: 27, duration: PT0.383S, number of operations: 18014398509481984 Level of load: 28, duration: PT0.758S, number of operations: 72057594037927936 Level of load: 29, duration: PT1.515S, number of operations: 288230376151711744 ```","closed","component: Jupiter,","karayv","2018-01-23T23:02:21Z","2019-07-19T19:32:23Z"
"","1483","@ParameterizedTest performance deteriorates with number of parameters","## Overview  A user recently approached @sormuras with a `@ParameterizedTest` with 200 parameters that uses `@CsvFileSource` with 25,000 rows. Each invocation took about 700 ms. When using an `ArgumentsAggregator` each invocation took less than a millisecond.  While this scenario is certainly on the extreme end, I profiled it and found parameter annotation lookup to be the culprit: 99% of the time is spent in `Parameter.getDeclaredAnnotations()`. Since the annotations don't change between invocations, we only need to look them up once and pass the lookup result to each invocation context.  ## Deliverables  - [ ] Cache annotation lookup for `@ParameterizedTest` parameters.","closed","theme: parameterized tests,","marcphilipp","2018-07-01T10:29:36Z","2018-07-03T17:51:43Z"
"","1437","Add cyclic dependency checks","## Overview  A simple `jdeps junit-jupiter-api-5.3.0-SNAPSHOT.jar` results in the output listed below. Fixing the expected output and updating it when introducing new dependencies is a good measure to prevent using internal API and referring to not wanted libraries/modules.  Perhaps a [_degraph_](https://github.com/schauder/degraph/issues/87)-like check can be implemented using this future-proof foundation tool as well. What do you think @schauder ?  ```text junit-jupiter-api-5.3.0-SNAPSHOT.jar -> java.base junit-jupiter-api-5.3.0-SNAPSHOT.jar -> not found    org.junit.jupiter.api                              -> java.lang                                          java.base    org.junit.jupiter.api                              -> java.lang.annotation                               java.base    ...    org.junit.jupiter.api                              -> org.opentest4j                                     not found    org.junit.jupiter.api.condition                    -> java.lang                                          java.base    ...    org.junit.jupiter.api.condition                    -> org.junit.platform.commons.util                    not found    org.junit.jupiter.api.extension                    -> java.lang                                          java.base    ...    org.junit.jupiter.api.extension                    -> org.junit.platform.commons.util                    not found    org.junit.jupiter.api.function                     -> java.lang                                          java.base    org.junit.jupiter.api.function                     -> org.apiguardian.api                                not found ```  ## Deliverables  - [x] Add `jdeps` integration tests for all published artifacts. Via #1544. - [x] Remove `degraph` from build scripts","closed","component: Platform,","sormuras","2018-05-29T08:30:23Z","2019-07-19T19:32:24Z"
"","1807","azure-pipelines: more complete port of travis conf","## Overview  A more complete port of the Travis configuration.  I talked with @brunoborges about porting more of the CI invocation over to Azure Pipelines; this picks up from his #1796 with a few differences:  1. For the Java 11 (Linux), macOS and Windows-based builds, this runs directly on the Azure Pipelines build agents, since they have Java 11 installed. 2. For the Java 12 and Java 13 based builds, this runs within the OpenJDK docker images.  The Azure Pipelines build agents do not have a Java 12 or 13 runtime installed, so the preferred mechanism is to [run within a docker image](https://devblogs.microsoft.com/devops/cross-platform-container-builds-with-azure-pipelines/). 3. Just run gradle on the command line instead of trying to run the gradle task.  This allows us to use the same script configuration and template for both the container-based builds and the on-agent builds. 4. Only one of the builds (I chose the Java 12 Linux build) publishes test results, per @sormuras's request in #1796.  Outstanding Issues:  1. The publish steps do _not_ succeed.  (Thankfully.)  They require authentication which obviously I did not configure, as I do not have that information.  I'm happy to help configure secret variables so that we can move that forward.  Please let me know how else I can help!  😀   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","ethomson","2019-03-11T18:57:54Z","2019-03-12T19:52:16Z"
"","1332","Lifecycle callback methods in enclosing class are invoked with ExtensionContext for test executing in @Nested test class","## Overview  A comment in [SPR-15366](https://jira.spring.io/browse/SPR-15366?focusedCommentId=157903&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-157903) has made me aware of a potential bug in JUnit Jupiter's handling of `@BeforeEach` methods with regard to the `ExtensionContext` supplied to a `ParameterResolver` registered for an enclosing test class when executing a test method within a `@Nested` test class.  Specifically, Jupiter invokes a `@BeforeEach` method in the enclosing class using the `ExtensionContext` for a `@Test` method in a `@Nested` class. The same may be true for other lifecycle callback methods as well, but I have not investigated that.  ## Analysis  It would appear that the cause of this behavior is due to a combination of how `ClassTestDescriptor.invokeMethodInExtensionContext(Method, ExtensionContext, ExtensionRegistry)` and `TestMethodTestDescriptor.invokeBeforeEachMethods(JupiterEngineExecutionContext)` operate. The latter invokes each synthesized `BeforeEachMethodAdapter` using the `ExtensionContext` for the current test method instead of supplying the `ExtensionContext` for the context in which the method is declared. Consequently, if a `ParameterResolver` is asked to resolve a parameter for a `@BeforeEach` method in an enclosing class and the resolver needs the test class (or information tied to the test class via annotations) to resolve the parameter, then the resolver gets the test class for the currently executing `@Nested` test class when invoking `extensionContext.getRequiredTestClass()`.  However, this _behavior_ does not appear to apply to the invocation of `TestInstancePostProcessor` implementations as can be seen in `TestInstancePostProcessorTests`.  Similarly, the behavior is different for a `ParameterResolver` applied to the constructor of an enclosing class for the currently executing `@Nested` test class.  ## Deliverables  - [ ] Determine which lifecycle callback methods are affected by this.   - [ ] Ensure appropriate tests are in place for `@BeforeAll`   - [ ] Ensure appropriate tests are in place for `@AfterAll`   - [ ] Ensure appropriate tests are in place for `@BeforeEach`   - [ ] Ensure appropriate tests are in place for `@AfterEach` - [ ] Ensure that extensions registered and invoked for a given lifecycle callback are supplied an appropriate `ExtensionContext`.","open","component: Jupiter,","sbrannen","2018-03-17T17:02:45Z","2022-07-12T08:03:36Z"
"","1103","Disabled test classes should not be eagerly instantiated with PER_CLASS lifecycle mode","## Overview  A [discussion on Stack Overflow](https://stackoverflow.com/questions/46640046/disable-test-with-spring-and-junit5-without-context-creation) has brought to my attention that a _disabled_ test class (which is configured with `PER_CLASS` lifecycle mode) is eagerly instantiated when it should not be.   In the example on Stack Overflow (simplified below), the Spring `ApplicationContext` is loaded by the `SpringExtension` since it is invoked as a `TestInstancePostProcessor` in order to perform dependency  injection on the test instance. This in turn causes the test class to fail since a component loaded by the `ApplicationContext` throws an exception, but... the `ApplicationContext` should never have been loaded in the first place since the entire test class is _disabled_.  Note, however, that the test class is properly _disabled_ if you comment out `@TestInstance(PER_CLASS)`.  ## Example Spring Test Class  ```java import javax.annotation.PostConstruct;  import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestInstance;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  import static org.junit.jupiter.api.TestInstance.Lifecycle.*;  @SpringJUnitConfig @TestInstance(PER_CLASS) @Disabled class SpringJUnitJupiterTests {  	@Autowired 	TestComponent testComponent;  	@Test 	void test() { 	}  	@Configuration 	static class Config {  		@Bean 		TestComponent testComponent() { 			return new TestComponent(); 		} 	}  	static class TestComponent {  		@PostConstruct 		void fail() { 			throw new IllegalStateException(); 		} 	}  } ```  ## Analysis  `ClassTestDescriptor.testInstanceProvider()` will eagerly instantiate the test class ""for BeforeAllCallbacks, if necessary, and store the instance in the ExtensionContext.""  The problem is that this occurs before `HierarchicalTestExecutor.execute()` determines if the node should be _skipped_ (i.e., if the test class is _disabled_).  ## Deliverables  - [x] Ensure that _disabled_ test classes are not eagerly instantiated.   - Note that this issue applies to any `ExecutionCondition` and is not specific to the support for `@Disabled`. - [x] Update https://stackoverflow.com/q/46640046/6327046","closed","component: Jupiter,","sbrannen","2017-10-11T13:54:53Z","2017-11-05T17:36:34Z"
"","1443","Introduce TestInstanceFactory extension API","## Overview  `TestInstanceFactory` is a new extension API that allows custom creation of test instance objects.  * It must be applied at the class level. * If multiple `TestInstanceFactory` extensions are found to be registered on a test class an error is thrown. * Supports `@Nested` classes, ensuring that only one factory is registered on each level.  Issue: #672   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","kdubb","2018-06-04T03:41:53Z","2018-06-30T16:40:01Z"
"","1042","Change PostDiscoveryFilter to filter on TestIdentifier","## Overview  `TestDescriptor` is mutable, so a `PostDiscoveryFilter` could add tests or directly remove tests, which is problematic. Since `TestIdentifier` is immutable, changing `PostDiscoveryFilter` to use it solves this problem.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","kcooney","2017-09-03T05:31:57Z","2019-07-19T19:32:43Z"
"","1098","Fix Javadoc @value tag usages","## Overview  `RepeatedTest.java` uses `{@value name}` tags that are not resolved by Javadoc 9 anymore:  	 * {@value #DISPLAY_NAME_PLACEHOLDER} 	 * {@value #CURRENT_REPETITION_PLACEHOLDER} 	 * {@value #TOTAL_REPETITIONS_PLACEHOLDER}  Warnings: ``` RepeatedTest.java:132: warning - {@value #DISPLAY_NAME_PLACEHOLDER} (referenced by @value tag) is an unknown reference. RepeatedTest.java:132: warning - {@value #CURRENT_REPETITION_PLACEHOLDER} (referenced by @value tag) is an unknown reference. RepeatedTest.java:132: warning - {@value #TOTAL_REPETITIONS_PLACEHOLDER} (referenced by @value tag) is an unknown reference. ```  ## Deliverables  - ❌  Find syntax that works or replace by hard-coded values","closed","theme: documentation,","sormuras","2017-10-09T08:20:18Z","2017-11-11T23:12:04Z"
"","976","ReflectionUtils considers locally overloaded default methods as overridden","## Overview  `ReflectionUtils.isMethodShadowedBy(Method, Method)` currently contains logic related to sub-signatures and generics that incorrectly considers an inherited _overloaded_ method as _overridden_ (a.k.a., _shadowed_). Consequently, certain searches for methods via `findMethods(*)` will omit valid methods from the results.  For example, given the following interface and concrete implementation, a search for all methods named `foo` within the class will only return the method in the class. The default method from the interface is incorrectly considered to be overridden by the `foo(Double`) method in the class.  ```java interface InterfaceWithGenericDefaultMethod {  	@Test 	default void foo(N number) { 	} }  class GenericDefaultMethodTests implements InterfaceWithGenericDefaultMethod {  	@Test 	void foo(Double number) { 	} } ```  Consequently, any attempt to execute `GenericDefaultMethodTests` as a test class using JUnit Jupiter will result in the execution of only one test method instead of the expected two.  ## Related Issues  - #333   ## Deliverables  - [x] Ensure that default methods that are overloaded by local methods are not considered overridden by the overloaded method. - [x] Enabled `@Disabled` tests introduced in commit 7e1f75acc343e447c6d64e7d317979a6f83c5cc1.","closed","theme: discovery,","sbrannen","2017-07-23T12:46:41Z","2017-07-24T12:12:28Z"
"","1201","Avoid use of Gradle's internal APIs for testing","## Overview  `ProjectBuilder` should be avoided for writing functional tests. The runtime behavior has its quirks and sometimes requires [calling an internal Gradle API](https://github.com/junit-team/junit5/blob/master/junit-platform-gradle-plugin/src/test/groovy/org/junit/platform/gradle/plugin/JUnitPlatformPluginSpec.groovy#L401) (which might break if you change Gradle versions). The appropriate API to use here is TestKit.  Refactors the setup logic for TestKit and separates build logic needed for functional testing. Translates two existing tests from the use of `ProjectBuilder` to TestKit. No more internal API is required.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Gradle,","bmuschko","2017-12-10T15:26:16Z","2017-12-11T07:59:02Z"
"","1333","Introduce variant of Assertions.fail() without arguments","## Overview  `org.junit.jupiter.api.Assertions.fail` variants currently require arguments. If you simply want to fail the test and think an explanation is not not needed since it's clear from the test structure, a simple `fail()` without parameters would be nice.  ## Analysis  I work on a commercial project that uses JUnit 4 and we would like to upgrade to JUnit 5. We have a large amount of existing tests, and many of them use `fail()`. By far the most common usage is the version without parameters: http://junit.sourceforge.net/javadoc_40/org/junit/Assert.html#fail()  It would be nice if this method was provided in JUnit Jupiter as well. If it was not provided, what would happen is that we would simply go and replace all usages of `fail()` with `fail("""")`, which wouldn't really improve readability. I can understand if the parameter-less version was not included to force you to write a message, but if it's not required, it would be good to have an option without it.  ## Deliverables  - Introduce `Assertions.fail()` method without parameters","closed","component: Jupiter,","MattiasWrang","2018-03-18T08:37:23Z","2018-04-11T10:47:04Z"
"","1501","Use correct class for method-based test descriptors","## Overview  `MethodBasedTestDescriptor` and `VintageTestDescriptor` did not preserve original class of the discovered method and instead obtained it from the `java.lang.reflect.Method`. This happened to be problematic for inherited test methods. They appeared to come from the abstract class instead of the concrete class. Surefire provider failed to match such methods when executing tests matching a mask (via `-Dtest=*MaskTest`).  This PR fixes the problem by making the underlying `MethodSource` preserve the original concrete class.  Fixes: #1406  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","3rd-party: Maven Surefire,","lutovich","2018-07-19T22:14:25Z","2018-07-21T21:04:29Z"
"","993","Delete dead code","## Overview  `handleInternalError` should only be called when the class cannot be loaded because of a malformed class name. This means that the error is thrown by the `loadClass.apply` call. Therefore the `Class` object is never available when `handleInternalError` is called.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","stefanbirkner","2017-07-28T22:14:12Z","2017-07-29T12:02:06Z"
"","1506","ClassSource implementation is broken regarding equals(), hashCode(), and precondition","## Overview  `ClassSource` is broken on many levels.   - The precondition is not verified for a class name. - `equals()` is based on `javaClass` which may be `null`. - `hashCode()` is based on `javaClass` which may be `null`.  ## Deliverables  - [x] Add precondition check for class name. - [x] Fix `equals()` and `hashCode()` so that they are based on `className` instead of `javaClass`.","closed","component: Platform,","sbrannen","2018-07-21T15:43:15Z","2018-07-22T16:11:04Z"
"","1606","assertEquals(expected, actual, delta) should allow a delta of zero","## Overview  `assertEquals(expected, actual, delta)` currently throws an exception if a delta of zero is passed in.   This is a change in behavior from JUnit 4 and an unnecessary restriction. I propose that the desired behavior should be to treat delta of zero as a test for equality.  In my projects a delta of zero occurs when the test tolerance is dynamically computed. The current work around is to add EPS to the dynamic tolerance. This bloats the code and the desired test is for equality, not _nearly_ equal.  ## Proposal  Two simple modifications (once for float and double) are required.  Change the line `delta <= 0.0` to `delta < 0.0`.  ```java 	static void assertValidDelta(float delta) { 		if (Float.isNaN(delta) || delta < 0.0) { 			failIllegalDelta(String.valueOf(delta)); 		} 	} ```  That's it.","closed","component: Jupiter,","lessthanoptimal","2018-09-28T16:07:31Z","2018-10-08T19:58:44Z"
"","1235","Add support for short, byte, float, char, and Class literals in @ValueSource","## Overview  `@ValueSource` currently only supports literals of type `int`, `long`, `double`, and `String`.  Although it doesn't make sense to support literals of type `boolean` (since there are only two possible such values), it makes sense to expand the supported set of literal types to include the remaining primitive types as well as classes.  ## Deliverables  - [x] Add support for `short`, `byte`, `float`, `char`, and `Class` literals in `@ValueSource`. - [x] Document in User Guide. - [x] Document in Release Notes.","closed","theme: parameterized tests,","sbrannen","2018-01-09T15:51:36Z","2018-01-10T15:12:33Z"
"","984","Allow @MethodSource methods to be non-static","## Overview  `@MethodSource` methods are currently required to always be `static`; however, if a test class is annotated with `@TestInstance(Lifecycle.PER_CLASS)` it is conceivable that a test author would like for his or her `@MethodSource` methods to be non-static.  ## Deliverables  - [x] Allow `@MethodSource` methods to be non-static -- by executing the method against the `testInstance` (or `null`) from the current `ExtensionContext` in `MethodArgumentsProvider.provideArguments()`","closed","component: Jupiter,","sbrannen","2017-07-25T14:28:08Z","2020-04-02T17:31:21Z"
"","1129","Fix rule detection and execution order when declared using methods","## Overview  `@EnableRuleMigrationSupport` failed to recognize `@Rule` methods that returned a subtype of one of the supported `TestRule` types. Moreover, it mistakenly instantiated some rules declared using methods multiple times. Now, once enabled, it will instantiate all declared rules (fields _and_ methods) exactly once and call them in the same order used by Vintage.  Executing `RuleJUnit5Test` from #1128 now yields  ``` ExampleExternalResourceRule init ExternalResource init TestRule init TestRule before ExternalResource before ExampleExternalResourceRule before ExampleExternalResourceRule after ExternalResource after TestRule after ```  which matches the output from `RuleJUnit4Test`  ``` ExampleExternalResourceRule init ExternalResource init TestRule init TestRule before ExternalResource before ExampleExternalResourceRule before ExampleExternalResourceRule after ExternalResource after TestRule after ```  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2017-10-29T19:52:51Z","2017-11-05T17:33:43Z"
"","1212","Feature: allow comparing map recursively with precision parameter","## Overview  _Replace the following bullet points with your issue description, after answering yourself: **""What kind of issue is this?""**_  - ( ) **Question.** This issue tracker is not the place for questions. If you want to ask how to do something, or to understand why something isn't working the way you expect it to, use Stack Overflow. https://stackoverflow.com/questions/tagged/junit5  - ( ) **Bug report.** Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  - (x) **Feature request.** Start by telling us what problem you’re trying to solve. Often a solution already exists! Please, don’t send pull requests to implement new features without first getting our support.  ## Deliverables  - [ ] Maps can be compared recursively and double / big decimal values can be compared with a relative precision   We implemented this feature with the following code:  ```java      /**      * Asserts two maps are equal. big decimal values are compared with a relative epsilon      * @param message failure message      * @param expected expected value      * @param actual actual value      * @param epsilon relative epsilon.      *                the difference between the actual value      *                and the expected value divided by the expected value      *                needs to be smaller than the relative epsilon      */     public static void assertEqualsMapEpsilon(String message, Map expected, Map actual, BigDecimal epsilon) {         assertEquals(expected.size(), actual.size());         for(Map.Entry expectedValue:expected.entrySet()){             Object actualValue = actual.get(expectedValue.getKey());             assertEqualsObjectEpsilon(                 message.concat("" map value differs for key \"""").concat((String)expectedValue.getKey()).concat(""\"""")                         .concat("", expected "").concat(expected.toString()).concat("" but got "").concat(actual.toString()),                 expectedValue.getValue(),                 actualValue,                 epsilon             );         }     }      /**      * Asserts two lists are equal. big decimal values are compared with a relative epsilon      * @param message failure message      * @param expected expected value      * @param actual actual value      * @param epsilon relative epsilon.      *                the difference between the actual value      *                and the expected value divided by the expected value      *                needs to be smaller than the relative epsilon      */     public static void assertEqualsListEpsilon(String message, List expected, List actual, BigDecimal epsilon) {         assertEquals(expected.size(), actual.size());         int i = 0;         for(Object expectedValue:expected){             Object actualValue = actual.get(i);             assertEqualsObjectEpsilon(                 message.concat("" List differs ""),                 expectedValue,                 actualValue,                 epsilon             );             ++i;         }     }       /**      * Asserts two objects are equal. big decimal values are compared with a relative epsilon      * @param message failure message      * @param expected expected value      * @param actual actual value      * @param epsilon relative epsilon.      *                the difference between the actual value      *                and the expected value divided by the expected value      *                needs to be smaller than the relative epsilon      */     public static void assertEqualsObjectEpsilon(String message, Object expected, Object actual, BigDecimal epsilon) {         if (expected != null) {             assertNotNull(actual);         }          if (expected instanceof BigDecimal) {             assertEqualsBigDecimalEpsilon(                     message.concat("" BigDecimal value differs, "")                             .concat(""expected "").concat(expected.toString()).concat("" but got "").concat(actual.toString()),                     (BigDecimal)expected, (BigDecimal) actual, epsilon             );         } else if (expected instanceof Map) {             assertEqualsMapEpsilon(message, (Map) expected, (Map) actual, epsilon);         } else if (expected instanceof List) {             assertEqualsListEpsilon(message, (List)expected, (List)actual, epsilon);         } else {             assertEquals(message, expected, actual);         }     }      /**      * Asserts two decimal values are equal. big decimal values are compared with a relative epsilon      * @param message failure message      * @param expected expected value      * @param actual actual value      * @param epsilon relative epsilon.      *                the difference between the actual value      *                and the expected value divided by the expected value      *                needs to be smaller than the relative epsilon      */     public static void assertEqualsBigDecimalEpsilon(String message, BigDecimal expected, BigDecimal actual, BigDecimal epsilon) {         BigDecimal difference = expected.subtract(actual).abs();          // calculate relative difference         BigDecimal relativeDifference;         if (expected.compareTo(BigDecimal.ZERO) == 0) {             relativeDifference = difference.abs();         } else {             relativeDifference = difference.divide(expected, BigDecimal.ROUND_UP).abs();         }          // compare relative difference to epsilon         if (relativeDifference.compareTo(epsilon) > 0) {             fail(format(message, expected, actual));         }     } ```   which allows you to e.g. compare the following two maps recursively, allowing for small big decimal differences:  ```java Map map1 = new HashMap<>();         Map submap1 = new HashMap<>();         Map subsubmap1 = new HashMap<>();         List list1 = Arrays.asList(                 new BigDecimal(0.000004),                 new BigDecimal(0.000005),                 new BigDecimal(0.000006),                 new BigDecimal(0.000007)         );         List sublist1 = Arrays.asList(                 new BigDecimal(1.000004),                 new BigDecimal(2.00000500002),                 new BigDecimal(3.000006),                 new BigDecimal(4.000007)         );         map1.put(""A"", new BigDecimal(0.000004));         map1.put(""B"", submap1);         map1.put(""C"", new BigDecimal(0.000006));         map1.put(""D"", list1);         map1.put(""E"", new BigDecimal(0.000008));          submap1.put(""subA"", new BigDecimal(1.000004));         submap1.put(""subB"", subsubmap1);         submap1.put(""subC"", ""String subC"");         submap1.put(""subD"", sublist1);         submap1.put(""subE"", new BigDecimal(1.000007));         submap1.put(""subF"", subsubmap1);          subsubmap1.put(""subsubA"", new BigDecimal(2.000004));         subsubmap1.put(""subsubB"", ""String subsubB"");         subsubmap1.put(""subsubC"", new BigDecimal(2.000007));           Map map1actual = new HashMap<>();         Map submap1actual = new HashMap<>();         Map subsubmap1actual = new HashMap<>();         List list1actual = Arrays.asList(                 new BigDecimal(0.00000400005),   // <--- slight imprecision here                 new BigDecimal(0.000005),                 new BigDecimal(0.000006),                 new BigDecimal(0.000007)         );         List sublist1actual = Arrays.asList(                 new BigDecimal(1.000004),                 new BigDecimal(2.0000050000200005),  // <--- slight imprecision here                 new BigDecimal(3.000006),                 new BigDecimal(4.000007)         );         map1actual.put(""A"", new BigDecimal(0.000004));         map1actual.put(""B"", submap1actual);         map1actual.put(""C"", new BigDecimal(0.00000600005));  // <--- slight imprecision here         map1actual.put(""D"", list1actual);         map1actual.put(""E"", new BigDecimal(0.000008));          submap1actual.put(""subA"", new BigDecimal(1.000004));         submap1actual.put(""subB"", subsubmap1actual);         submap1actual.put(""subC"", ""String subC"");         submap1actual.put(""subD"", sublist1actual);         submap1actual.put(""subE"", new BigDecimal(1.00000700005));   // <--- slight imprecision here         submap1actual.put(""subF"", subsubmap1actual);          subsubmap1actual.put(""subsubA"", new BigDecimal(2.000004));         subsubmap1actual.put(""subsubB"", ""String subsubB"");         subsubmap1actual.put(""subsubC"", new BigDecimal(2.00000700005));  // <--- slight imprecision here               TestDataService.assertEqualsMapEpsilon(                     ""some message"",                     map1,                     map1actual,                     new BigDecimal(1e-3)             ); ```  Note: we have also written some unit tests to check that this feature works correctly.  Do you think this could be something that could be included in jUnit?","closed","component: Jupiter,","macjohnny","2017-12-20T11:25:57Z","2017-12-23T12:58:28Z"
"","1525","launcher","## Overview  _Replace the following bullet points with your issue description, after answering yourself: **""What kind of issue is this?""**_  - ( ) **Question.** This issue tracker is not the place for questions. If you want to ask how to do something, or to understand why something isn't working the way you expect it to, use Stack Overflow. https://stackoverflow.com/questions/tagged/junit5  - ( ) **Bug report.** Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  - ( ) **Feature request.** Start by telling us what problem you’re trying to solve. Often a solution already exists! Please, don’t send pull requests to implement new features without first getting our support.  ## Deliverables  - [ ] ...","closed","","sourabh1512","2018-08-06T06:12:58Z","2018-08-06T11:07:06Z"
"","1413","launcher filters","## Overview  _Replace the following bullet points with your issue description, after answering yourself: **""What kind of issue is this?""**_  - ( ) **Question.** This issue tracker is not the place for questions. If you want to ask how to do something, or to understand why something isn't working the way you expect it to, use Stack Overflow. https://stackoverflow.com/questions/tagged/junit5  - ( ) **Bug report.** Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  - ( ) **Feature request.** Start by telling us what problem you’re trying to solve. Often a solution already exists! Please, don’t send pull requests to implement new features without first getting our support.  ## Deliverables  - [ ] ...","closed","","beeva-sendoamoronta","2018-05-09T12:07:07Z","2018-05-09T12:07:32Z"
"","1935","Prune Release Notes for 5.5","## Overview  _Prune_ the release notes like we have done previously (see ef576cafe55e62e69a0cca8940e342c64f6d8ee5).  ## Deliverables  - [x] ~Document #1929 in the Release Notes.~ done in 9cf05a36d624535628ea31183f90d7e6eca95772 - [x] ~Document #1932 in the Release Notes.~ done in 9cf05a36d624535628ea31183f90d7e6eca95772 - [x] ~Document #1934 in the Release Notes.~ done in 9cf05a36d624535628ea31183f90d7e6eca95772 - [x] ~Document #1925 in the Release Notes.~ done in 9cf05a36d624535628ea31183f90d7e6eca95772 - [x] Prune Release Notes for 5.5.","closed","theme: documentation,","sbrannen","2019-06-15T18:50:00Z","2019-06-30T09:38:16Z"
"","1554","Use Jansi in junit-platform-console","## Overview  _Jansi is a small java library that allows you to use ANSI escape sequences to format your console output which works even on windows._  http://fusesource.github.io/jansi/  ## Picocli already shadowed  As `junit-platform-console.gradle` is configured to `shadowed('info.picocli:picocli:3.5.1')` it is possible that there is already _external_ support for ANSI coloring.  See `picocli.CommandLine.Help.Ansi.Style` for the definition of colors. Also `picocli.CommandLine.Help.ColorScheme`.  ## Deliverables  - [ ] First, try to re-use picocli's console colors types. - [ ] Replace [Color](https://github.com/junit-team/junit5/blob/master/junit-platform-console/src/main/java/org/junit/platform/console/tasks/Color.java) class and its usages with Jansi types - [ ] Shadow Jansi into `junit-platform-console` artifact","closed","component: Platform,","sormuras","2018-08-19T08:53:59Z","2021-05-28T10:22:39Z"
"","1342","Switch to JDK 10","## Overview  _Drop 9, play on 10._  This PR promotes JDK 10 to our underlying build JDK. The `--release` target is still and remains Java 8.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: modules,","sormuras","2018-03-22T20:12:08Z","2018-03-23T11:02:53Z"
"","1600","ConsoleLauncher: VerboseTreePrintingListener - format specifier in exception message throws java.util.MissingFormatArgumentException","## Overview  _Bug in `VerboseTreePrintingListener`_:  When using ConsoleLauncher with `--details` options set to `verbose` and in test method is thrown an exception with message containing format specifier (e.g. `%c` - _""My exception message with %c specifier""_) then `VerboseTreePrintingListener` throws `MissingFormatArgumentException` exception.   example test:  ```java package com.thulium.selenium;  import org.junit.jupiter.api.Test;  class VerboseTreePrintingListenerTest {      @Test     void shouldLogException() {         throw new RuntimeException(""Message with %c formatter."");     } } ```  **command (run from InteliJ)**:  `ConsoleLauncher --reports-dir /tmp/selenium --select-class com.thulium.selenium.VerboseTreePrintingListenerTest --details verbose`  **Stack trace:**  ``` java.util.MissingFormatArgumentException: Format specifier '%c' 	at java.util.Formatter.format(Formatter.java:2519) 	at java.io.PrintWriter.format(PrintWriter.java:905) 	at java.io.PrintWriter.printf(PrintWriter.java:804) 	at org.junit.platform.console.tasks.VerboseTreePrintingListener.printf(VerboseTreePrintingListener.java:159) 	at org.junit.platform.console.tasks.VerboseTreePrintingListener.printDetail(VerboseTreePrintingListener.java:183) 	at org.junit.platform.console.tasks.VerboseTreePrintingListener.lambda$executionFinished$0(VerboseTreePrintingListener.java:104) 	at java.util.Optional.ifPresent(Optional.java:159) 	at org.junit.platform.console.tasks.VerboseTreePrintingListener.executionFinished(VerboseTreePrintingListener.java:104) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry$CompositeTestExecutionListener.lambda$executionFinished$3(TestExecutionListenerRegistry.java:77) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry.notifyTestExecutionListeners(TestExecutionListenerRegistry.java:51) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry.access$100(TestExecutionListenerRegistry.java:27) 	at org.junit.platform.launcher.core.TestExecutionListenerRegistry$CompositeTestExecutionListener.executionFinished(TestExecutionListenerRegistry.java:77) 	at org.junit.platform.launcher.core.ExecutionListenerAdapter.executionFinished(ExecutionListenerAdapter.java:56) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.reportCompletion(NodeTestTask.java:154) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:76) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.executeTests(ConsoleTestExecutor.java:65) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.lambda$execute$0(ConsoleTestExecutor.java:57) 	at org.junit.platform.console.tasks.CustomContextClassLoaderExecutor.invoke(CustomContextClassLoaderExecutor.java:33) 	at org.junit.platform.console.tasks.ConsoleTestExecutor.execute(ConsoleTestExecutor.java:57) 	at org.junit.platform.console.ConsoleLauncher.executeTests(ConsoleLauncher.java:84) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:74) 	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:47) 	at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:39) ```","closed","component: Platform,","andrzejo","2018-09-25T09:58:42Z","2018-11-20T12:12:32Z"
"","1223","Improve diagnostics when Vintage test engine is missing","## Overview  _(tl;dr: I feel JUnit might be easier to use for developers if things failed more explicitly when developers make certain specific mistakes. I've got a suggestion for how to do this that I'd like to discuss. I'm willing to do much of the work if it's the right approach and if the submission would be acceptable.)_  While using JUnit 5 (excellent work by the way!) I've encountered some situations where an innocent developer error can cause tests not to be executed in ways that are easy to miss.  - When using the `@Nested` annotation with a static inner class, the class (and any tests declared within it) are not executed. No error messages of any kind that I can see are emitted. This situation is difficult to spot by visual inspection of the code, and because the tests aren't marked as skipped, catching the mistake is difficult in a larger project — one would need to take a very close look at test totals, read test results by hand, etc.  - When using the JUnit 5 platform with JUnit 4 tests, if the JUnit Vintage dependency isn't on the classpath but JUnit 4 somehow is, tests can easily get skipped. I know that this sounds theoretical but it happened to some colleagues of mine just before Christmas. It took us an hour or so to debug (once they figured out that it was happening) because it wasn't obvious to them from looking at the gradle build file or output what the cause was. Even worse, the IDE (IntelliJ in this case) was still happily running the JUnit 4 tests, so it wasn't immediately obvious that something wrong was even happening until somebody took a close look at build script output on the CI server.  There are some commonalities between these problems: - They both involve things that developers need to know, but sometimes don't. - When a mistake happens, it's difficult to diagnose just by visual inspection unless you are aware of the thing you need to know. - It can be easy to miss these mistakes if you aren't consciously looking for them.  It might be annoying to people in the short term, but ultimately I think JUnit would be safer for developers if test runs explicitly failed in both of these conditions, rather than just not executing tests.  ## Proposal I propose fixing this by causing a test run to fail whenever either of the above mistakes is made. I took a brief look at JUnit's source code, and the idea that occurred to me is some new Resolver implementations that detect each scenario and cause tests (or just the build) to fail.  I've got some ideas on how to programatically find the error conditions for each resolver: - For the ""non static `@Nested` class"" case, it should just be inverting the existing predicate (org.junit.jupiter.engine.discovery.predicates.IsNestedTestClass) and checking for inner classes annotated with the `@Nested` that don't match the predicate. - The Junit 4/5 case is a bit harder, but it should be possible to find methods annotated with `org.junit.Test` when the JUnit vintage classes are not on the runtime classpath. We could use reflection to check for the existence of the `org.junit.Test` annotation and JUnit vintage so no extra dependencies are be needed. This resolver could shorrt circuit into a no-op in cases where JUnit4 isn't present on the classpath, or JUnit4 and JUnit Vintage are both on the class path.  What wasn't immediately obvious to me was the best way for resolvers like this to cause tests (or just the whole build) to fail. I could really use some advice on this part.  ## Feedback requested: - Is guarding against these issues a desirable feature? - If so, is writing some new Resolvers the best way to go about it? - If so, what's the best way for a Resolver or associated Descriptor to emit an error message and fail the build? - If I develop a patch of appropriate quality for this, is it likely to be accepted?  ## Deliverables If all of the above is acceptable then I imagine that it might be best to open a separate PR for each case when I've got something workable.  Any and all feedback gratefully requested!","closed","status: stale,","seanjreilly","2018-01-02T11:52:33Z","2021-06-19T12:50:14Z"
"","1832","Update API status in User Guide","## Overview  @fanngrim wrote on Mar 24 20:24 at https://gitter.im/junit-team/junit5  > Hi, > I just noticed something in the documentation. > The user guide states that Dynamic Tests are still an experimental feature but when checking the Experimental APIs table they are not listed there. > Also, the TestFactory annotation is marked as MAINTAINED. Is the the documentation outdated?  ## Deliverables  - [x] Remove outdated warning from Dynamic Tests section: https://github.com/junit-team/junit5/commit/1d9541999b3a38c6aa6c6f45e524753276fdc469 - [x] Verify other sections of the User Guide are in-sync with their annotations   - [x] Capturing std out/err   - [x] Parameterized Tests   - [x] JUnit 4 `Rule` support   - [x] JUnit 4 `@Ignore` support   - [x] `@TempDir`   - [x] Parallel test execution   - [x] Test Kit","closed","theme: documentation,","sormuras","2019-03-25T10:18:41Z","2020-05-22T19:54:20Z"
"","1207","Can't filter inner classes correctly","## Overview  - Jupiter version: 5.0.2 - Vintage version: 4.12.2  I have JUnit 4 tests inside static inner classes. Vintage finds these classes if the inner class name ends with ""Test"". For example:  ```java public class OuterTest {     public static class InnerTest {         // some tests which are found     } } ```  But if the inner class name does not end with ""Test"" then it is not found.  ```java public class OuterTest {     public static class Inner {         // some tests which are *not* found     } } ```  The default filter for test classes is `^.*Tests?$`, which is why `OuterTest$InnerTest` is found and `OuterTest$Inner` is not. But I tried setting `junitPlatform.filters.includeClassNamePatterns` to `'^.*Tests?$', '^.*Tests?\$.*$'` and it didn't find `OuterTest$Inner`. It seems like the filter isn't applied against the fully qualified class name, or the '$' is confusing it somehow.","closed","3rd-party: Gradle,","ebrowne72","2017-12-14T00:52:44Z","2017-12-24T15:43:41Z"
"","1500","Document how to use @RegisterExtension for static extensions from Kotlin","## Overview  - JUnit 5 version: **`5.2.0`** - Kotlin version: **`1.2.30`**  Hello, I am trying to use the [Programmatic Extension Registration via Static Fields](https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic-static-fields) to register an extension in tests written in the Kotlin programming language.  However, I cannot get the `beforeAll` method to be called.  Note that using the `@BeforeAll` annotation works fine.  Note that to have ""static"" methods in Kotlin, one must use the `@JvmStatic` annotation inside an `object`.   ### Example 1: Working `@BeforeAll` annotation:  ```kotlin class TestBeforeAllAnnotation {     companion object {          var setMeBeforeAllTests :String? = null          @JvmStatic         @BeforeAll         fun annotatedBeforeAll() {             setMeBeforeAllTests = ""before""         }     }      @Test     fun testAnnotatedBeforeAll() {         assertEquals(""before"", setMeBeforeAllTests) // OK     } } ```  ### Example 2: Non-working `BeforeAllCallback` extension registration  ```kotlin class BeforeAllCallBackExtension : BeforeAllCallback {      val atConstructionTime = ""done""      var fromBeforAllCall: String? = null      override fun beforeAll(context: ExtensionContext?) {         println(""BEFORE ALL CALLED"")         fromBeforAllCall = ""before""     }  }  class TestProgrammaticExtension {     companion object {         @JvmStatic         @RegisterExtension         val extension = BeforeAllCallBackExtension()     }      @Test     fun filedAtConstructionTimeWorks() {         assertEquals(""done"", extension.atConstructionTime) // OK     }      @Test     fun fieldSetInCallBackFails() {         assertEquals(""before"", extension.fromBeforAllCall) // FAILS     } } ```","closed","component: Kotlin,","stefano-m","2018-07-19T11:28:59Z","2019-02-02T07:11:29Z"
"","1473","Ignore JEnv specific files from version control","## Overview  - **Feature request:** `.gitignore` [jenv](https://github.com/gcuisinier/jenv) specific local files  If you are a developer who works with multiple versions of the JDK for multiple projects and want to easily specify Java 9+/10 for JUnit5, running `jenv local 10` will create a local dotfile specifying the `JAVA_HOME` etc shims to use for the local project (dotfile is called `.java-version`).  In an effort to reduce mistakes for developers who use jenv for managing their environments, I would request that we add `.java-version` as an ignored value for JUnit5 in it's `.gitignore`.  ## Deliverables  - [ ] Ignore `.java-version` in `.gitignore`","closed","status: declined,","dotCipher","2018-06-22T19:38:33Z","2018-06-23T14:54:56Z"
"","1618","API for accessing outer test instances","## Overview  - (x) **Feature request.** Provide an API to access outer test instance  Extensions that manage test instance fields often need access to the fields declared in outer test instances. Examples for this are the [MockitoExtension](https://github.com/mockito/mockito/blob/release/2.x/subprojects/junit-jupiter/src/main/java/org/mockito/junit/jupiter/MockitoExtension.java) and the [Testcontainers extension](https://github.com/testcontainers/testcontainers-java/pull/887). The `ExtensionContext` currently does not provide access to the outer test instance:  ```java         Optional current = context.getParent();          while(current.isPresent()) {             ExtensionContext ctx = current.get();             Optional testInstance = ctx.getTestInstance()             if (testInstance.isPresent()) { // will never be true                 // do something with testInstance             }             current = ctx.getParent();         } ```  So currently extension authors have to fall back to putting test instances into the extension store and retrieve it from there. This should be more straight forward.  ## Deliverables  - [x] API for accessing outer test instances","closed","type: new feature,","britter","2018-10-04T12:50:26Z","2020-09-22T16:16:49Z"
"","1145","API for intercepting execution","## Overview  - (X) **Feature request.**  With the present  `BeforeAll, BeforeEach, AfterEach, AfterAll` extensions, it is possible to decorate test execution, but it is not possible to fully intercept it.  This is required for test frameworks like Pax Exam or Arquillian which currently use JUnit 4 runners as a test driver to first start a test container (e.g. a Java EE server or an OSGi framework) and then delegate test execution to an agent running within the container.  At the moment, the only way I see to implement equivalent functionality with JUnit 5 would be a custom test engine, which would require a lot of code duplication from `junit-jupiter-engine` since most potential hooks for overriding are package private or final.  In particular, I would like to override `HierarchicalTestEngine.execute()` or `Node.before(), Node.execute(), Node.after()`.  A JUnit extension should be able to determine whether is is running under the (outer) test driver or in the (inner) test container. When running in the container, execution should proceed as normal. When running under the driver, execution should be delegated to the container  via a suitable communication channel (e.g. a servlet request) provided by the extension.","closed","component: Jupiter,","hwellmann","2017-11-05T17:18:48Z","2019-07-19T10:09:01Z"
"","1381","Don't use human format for serialising time in XML report","## Overview  - (x) **Bug report.**  For a test running longer than roughly 17 minutes, the time in seconds will reach 4 digits and XmlReportWriter (https://github.com/junit-team/junit5/blob/master/junit-platform-console/src/main/java/org/junit/platform/console/tasks/XmlReportWriter.java#L239) will use a comma as a thousand separator. This is contrary to how for example XMLSerializer (https://w3c.github.io/DOM-Parsing/#the-xmlserializer-interface) would do that. No thousand separator or any other cultural formatting should be applied. The serialisation should rather be optimised for machine consumption.  Compare:  ```xml   ```  to XMLSerializer  ```js > p = document.createElement('p') > p.setAttribute('data-x', 1/9 * 10000) > new XMLSerializer().serializeToString(p) """" ```  ## Deliverables  - [ ] Use standard float serialisation","closed","component: Platform,","cburgmer","2018-04-20T19:11:08Z","2020-06-04T12:44:34Z"
"","1386","Attempting to rerun failing JUnit 4 Parameterized tests in IDEA fails","## Overview  - ( x) **Bug report.**  Am using version 5.1.1  In IDEA run a JUnit 4 Parameterized test class which has one test method that fails. Attempt to rerun the failing test and it fails with the following error:  org.junit.platform.commons.util.PreconditionViolationException: Could not find method with name [foo[parameter]] in class [ParameterizedTest].  Although this happens in IDEA I don't think that this is a bug in IDEA. It seems as though there is an inconsistency between how org.junit.runners.Parameterized test formats a parameterized test and how org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(java.lang.String) expects a parameterized test to be formatted.  The former uses ""class#method[parameters]"", the latter expects ""class#method(parameters)"". That results in the methodName field of the MethodSelector object being set to ""method[parameters]"" instead of ""method"" which means that the org.junit.vintage.engine.discovery.MethodSelectorResolver#resolve(...) method fails to find method.  Couple of possible approaches: 1. Change org.junit.runners.Parameterized to use (...) instead of [...]. That could be a hard coded change or maybe configurable - such as if the test is being by JUnit 5. 1. Change DiscoverySelectors#selectMethod(java.lang.String) to handle both [...] and (...). 1. Have some way for engines to handle their own parsing of a String to a MethodSelector. 1. Change MethodSelectorResolver#resolve(...) to check to see if the methodName contains a [] and if it does then extract the parameters and recreate the MethodSelector.  The latter approach seems the best one to me as it places the logic for handling JUnit 4 code in the vintage engine which is where it belongs.  ## Deliverables  - [ ] - Resolve inconsistency so can rerun failed parameterized tests in IDEA","closed","type: question,","paulduffin","2018-04-24T10:28:29Z","2019-04-10T12:31:25Z"
"","1111","Show parameter in Maven's report of failed parameterized tests","## Overview  - ( ) **Feature request.** When I'm writing parameterized tests, I'd expect Junit to tell me which parameterized test failed.   For instance, the following code should tell me that it's `""def""` that's failing.        @ParameterizedTest       @ValueSource(strings = {""abc"", ""def""})       void doSomeTest(String str) {         assertTrue(""abc"".equals(str));       }  Here's its output:  	Running hello.MyTest 	Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.123 sec <<< FAILURE! - in hello.MyTest 	doSomeTest(String)  Time elapsed: 0.013 sec  <<< FAILURE! 	org.opentest4j.AssertionFailedError:  		at hello.MyTest.doSomeTest(MyTest.java:54)   	Results :  	Failed tests:  	doSomeTest(String).doSomeTest(String) 	  Run 1: PASS 	  Run 2: MyTest.doSomeTest:54  I would expect the failed tests to show which parameters were given to the failing test.  Additionally, the ""failed tests"" list mentions `doSomeTest(String).doSomeTest(String)`, shouldn't it be `hello.MyTest.doSomeTest(String)`?  The final output should be:   	Results :  	Failed tests:  	hello.MyTest.doSomeTest(String) 	  Run 1 (""abc""): PASS 	  Run 2 (""def""): MyTest.doSomeTest:54  Here's a repository showcasing the issue: [junit5-issue1111](https://github.com/ogregoire/junit5-issue1111)","closed","3rd-party: Maven Surefire,","ogregoire","2017-10-16T11:50:13Z","2017-10-29T16:13:46Z"
"","1231","Use static factory method or constructor as fallback for implicit argument conversion","## Overview  *Original Title*: Introduce implicit argument conversion for UUID and URL  *Original Description*: In https://github.com/junit-team/junit5/issues/1218 implicit arg conversion was introduced for Locale, URI, and Currency. I'd appreciate if also `java.util.UUID` and `java.net.URL` can be supported, by e.g. `UUID.fromString(String name)` and `new URL(String)` as @hisener did in https://github.com/junit-team/junit5/pull/1221.    ## Related Issues  - #1218  - #1232   ## Current Proposal  See https://github.com/junit-team/junit5/issues/1231#issuecomment-355829162 and https://github.com/junit-team/junit5/issues/1231#issuecomment-355832818.  ## Deliverables  - [x] Use static factory method or constructor as fallback for implicit argument conversion. - [x] Document in User Guide. - [x] Document in Release Notes.","closed","theme: parameterized tests,","juergenzimmermann","2018-01-07T07:04:30Z","2018-01-09T13:43:12Z"
"","1532","Improve TestKit API","## Overview  **Refacting and polishing of the `testkit` API**:   As referenced in #1392 , the API for `testkit` has a lot of duplicate methods, non-symmetrical calls, etc.  It would be my intention to refactor the existing calls into a more concise API for accessing different parts of the underlying test's `Execution` or `ExecutionEvent`s.  To elaborate, the concepts provided from the API should follow the hierarchy (basic draft) of: - Event   - TestEvent   - ContainerEvent - Test  Every API method should maintain symmetry in terms of pluralization of the concept provided (ie `getEvents()` and `getTestEvents()` etc).  ## Deliverables  - [ ] Refactor `testkit` API for a more consistent and concise API - [ ] Documentation for all associated methods","closed","component: Test Kit,","dotCipher","2018-08-10T18:55:36Z","2019-02-10T14:27:59Z"
"","1140","Make it possible to return arbitrary Objects from @ValueSource","## Overview  **Feature request.** Make it possible to return arbitrary Objects from a `@ValueSource`.  `@ValueSource` is a nice way to write parameterized tests, but it only lets me define ints, doubles, longs or strings. However what I want to do for example is test some `LocalDate` values:  ```java @ParameterizedTest @ValueSource(objects = {     LocalDate.of(2017, 1, 1),     LocalDate.of(2017, 6, 6),     LocalDate.of(2017, 12, 31), }) void testSomethingWithLocalDates(LocalDate param){     // ... } ```  This is currently not possible and I have to fall back to dynamic tests, which are quite complex compared to `@ValueSource`  ## Deliverables  - [ ] `objects` field in `@ValueSource` to allow definition of object parameters for parameterized tests.  ## Note  I'm happy to provide a PR for this, but wanted to check first with the maintainers whether there are reasons this has not already been added (because from looking at the code of `ValueArgumentsProvider` it looks quite trivial to add this).","closed","component: Jupiter,","britter","2017-11-03T10:02:12Z","2017-11-03T11:46:54Z"
"","1446","Snapshot testing support","## Overview  **Feature request.**  When the method under test returns large text blocks it is useful to be able to store the text snapshot outside of the text class in a snapshot file.  This can be achieved outside of the test framework and can be done for Junit with something like with https://json-snapshot.github.io/  However having built-in support in the framework would allow for better developer experience. This would allow command line test runners to interactively propose updating snapshot. Similary the IDEs could provide a better integration for updating the snapshots.  In the javascript world [Jest](https://facebook.github.io/jest/docs/en/snapshot-testing.html) is an example of test framework where snapshot is built-in. This allows a great developer experience to visualize and update snapshot using either the [command line runner ](https://facebook.github.io/jest/docs/en/snapshot-testing.html#updating-snapshots) or IDEs like webstorm ([see Jest Webstorm integration](https://www.jetbrains.com/help/webstorm/running-unit-tests-on-jest.html#ws_jest_snapshot_testing)).","closed","status: declined,","sarod","2018-06-05T09:39:21Z","2018-06-06T08:53:33Z"
"","1550","JUnit XML Spec","## Overview  **Feature request.**   The JUnit XML spec allows for properties on a [testsuite](https://www.ibm.com/support/knowledgecenter/en/SSQ2R2_14.1.0/com.ibm.rsar.analysis.codereview.cobol.doc/topics/cac_useresults_junit.html) but not on individual tests.  I would like to expand this spec to support properties for each test.  For large systems, like Spotify (where I work), we are limited to what we can do with properties in the current XML spec. We can currently provide aggregate information in the test suite but if we have per-test ownership, per test performance data, etc we have to use other systems to log this. I would much rather us continue to use junit xml spec.  ## Deliverables  - JUnit XML spec offers per-test properties","closed","component: Platform,","palmerj3","2018-08-16T14:27:08Z","2018-08-16T15:29:39Z"
"","990","Surefire Plugin should evaluate @DisplayName","## Overview  **Feature request.**   Currently the surefire plugin does not evaluate `@DisplayName`  in the test reports. It would be great if Surefire would use `@DisplayName` where present.   Maven surfire output from the `junit5-maven-consumer` project: ``` Running com.example.project.FirstTest Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.115 sec <<< FAILURE! - in com.example.project.FirstTest myFirstTest(TestInfo)  Time elapsed: 0.035 sec  <<< FAILURE! org.opentest4j.AssertionFailedError: 1 + 1 should equal 2 ==> expected: <2> but was: <3>         at com.example.project.FirstTest.myFirstTest(FirstTest.java:27) ```  In contrast the output from the IntelliJ plugin using the `@DisplayName` results in more readable test names.  ![image](https://user-images.githubusercontent.com/207018/28667424-c20871f6-72cb-11e7-85b1-ae431fca598e.png)  Desired out put would be   ``` Running FirstTest Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.115 sec <<< FAILURE! - in FirstTest My 1st JUnit 5 test! 😎  Time elapsed: 0.035 sec  <<< FAILURE! org.opentest4j.AssertionFailedError: 1 + 1 should equal 2 ==> expected: <2> but was: <3>         at com.example.project.FirstTest.myFirstTest(FirstTest.java:27) ```  For parameterized Tests it would be great to have an output like in IntelliJ in the surefire plugin to. (DisplayName, Iteration and value of the argument causing a failed test)  ![image](https://user-images.githubusercontent.com/207018/28667945-0479312c-72ce-11e7-9bc1-0156359fd2a6.png)  ## Deliverables  - [ ] ...","closed","3rd-party: Maven Surefire,","mab","2017-07-27T11:18:13Z","2020-11-05T13:55:12Z"
"","985","Accessibility: Customizing colours for people with disabilities","## Overview  **Feature request.**   Console tasks are flagged with various statuses, such as `SUCCESSFUL` and `FAILED`.  These are mapped (as of #930, as `final` constants) to `GREEN` and `RED`. These may seem like reasonable choices, until you encounter people who are red-green colour blind, or completely colour blind, who may be unable to distinguish between success and failure cases at a glance, unlike the fully sighted. Worse, they may find it hard to read the text as high-contract text (green-on-black) is for them low-contrast dark-grey-on-black.  ## Deliverables  JUnit5 should allow the user to customize the `Color.ansiString` that is associated with the various status values.  At a minimum, this should allow customize the status colour, but could include: - [ ] a ANSI text attribute, such as `underline`, `bold` or `italic`. - [ ] reverse video - [ ] (forgive me) blink  This applies only to console output. An IDE will apply its own colour/style to the various test statuses.","closed","component: Platform,","AJNeufeld","2017-07-25T15:55:36Z","2022-04-22T18:37:53Z"
"","1157","Issue #1151 : Added option to skipHeaderLines in CsvFileSource","## Overview  **Feature request** @CsvFileSource skip headers option I've implemented the feature as suggested by @marcphilipp   I've not added instructions to the user guide though, is that under the gh-pages-branch?  It was less work dropping my only branch and and copying the changeSet, to get a rebase, than I-dont-know-what would be the option when rebasing while being in conflict. Old merge request: https://github.com/junit-team/junit5/pull/1156   ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jensim","2017-11-13T12:33:38Z","2017-11-13T15:38:49Z"
"","1156","Issue #1151 csvfile source skip headers option","## Overview  **Feature request** @CsvFileSource skip headers option I've implemented the feature as suggested by @marcphilipp   I've not added instructions to the user guide though, is that under the gh-pages-branch?  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jensim","2017-11-13T07:01:05Z","2017-11-16T08:30:20Z"
"","1706","Disabled @TestTemplate and @TestFactory methods not marked as skipped in IDEs","## Overview  **Expected:** The test with annotations `@ParameterizedTest`, `@CsvSource`, and `@Disabled` should be ignored by the test suite.   **Actual behavior:** The test is marked as Pass by IntelliJ.  ## Steps to reproduce  Using the following `IgnoreBugDemo` test class in IntelliJ with JUnit 5.3, run the test, and observe how the first test is ignored, but the second test is marked as Pass.  ```java  package demo;  import static org.junit.jupiter.api.Assertions.fail;  import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource;  public class IgnoreBugDemo {  	@Test 	@Disabled 	void shouldBeMarkedAsIgnored_1() { 		fail(""This should fail when run.""); 	}  	@ParameterizedTest 	@CsvSource({ ""1"" }) 	@Disabled 	void shouldBeMarkedAsIgnored_2(int i) { 		fail(""This should fail when run, but it succeeds according to IntelliJ + JUnit 5""); 	}  } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit 5.3.1 (via Maven)   - Build Tool/IDE:  ``` IntelliJ IDEA 2018.3.1 (Community Edition) Build #IC-183.4588.61, built on December 4, 2018 JRE: 1.8.0_152-release-1343-b16 amd64 JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o Windows 10 10.0 ```","closed","component: Platform,","HelgeStenstrom","2018-12-19T14:53:12Z","2019-01-04T11:49:36Z"
"","1486","Package test from Android Studio runs all the tests in a project","## Overview  **Bug report.** When you run tests for android project package from Android Studio it will run all the tests in the project.","closed","","mayowa-egbewunmi","2018-07-03T14:40:47Z","2018-07-05T07:47:21Z"
"","1104","warning: unknown enum constant Status.STABLE while compiling org.junit.jupiter.api.Test using Java9","## Overview  **Bug report.** Using the `junit-jupiter-api-5.0.0` with java version `""9"" (build 9+181)` in IntelliJ `2017.2.5`(if that might matter)  Steps to reproduce:- 1. Add a JDK9 based module to the project. 2. Add JUnit5 to the classpath using IntelliJ's shortcut. (lib folder) [`junit-jupiter-api-5.0.0.jar`] 3. Note that it brings along the `opentest4j-1.0.0.jar` along with to the lib/ folder. 4. Compile the [sample project](https://github.com/namannigam/Jigsaw/tree/master/junit5jdk9trial/src) (shared just to draw a picture of the directory structure in use) using the command  `javac --module-path lib -d ""target"" $(find src -name ""*.java"")`  Results into warnings post the compilation of the classes as -  > warning: unknown enum constant Status.STABLE >   reason: class file for org.apiguardian.api.API$Status not found > warning: unknown enum constant Status.STABLE > 2 warnings  ## Deliverables  - [x] Ensure that such warnings are not displayed out of the box.  On a side note, it would be good to know what exactly is causing these warnings to occur. Since, if I comment out the code using JUnit and execute the same command, things seems to be working fine.","closed","status: invalid,","namannigam-zz","2017-10-12T05:13:39Z","2018-06-09T15:31:05Z"
"","1229","Cannot create a @ParameterizedTest that uses @MethodSource in a @Nested test class","## Overview  **Bug report.**  Version : org.junit.jupiter:junit-jupiter-params:5.0.2  Cant create a nested parameterized test that uses `@MethodSource`. `@MethodSource` requires that it points to a static method. But you cannot have a static method from a non-static inner class. And you cant have a nested class that is a static inner class  ### Scenario 1  ```java import org.junit.jupiter.api.Nested; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  import java.util.Arrays; import java.util.stream.Stream;  import static org.junit.jupiter.api.Assertions.assertEquals;  class NestedParameterizedTest {      @Nested     class TheNesting {          @ParameterizedTest         @MethodSource(""getTestData"")         void shouldAdd(int a, int b, int c) {             assertEquals(c, a + b);         }          Stream getTestData() {             return Arrays.stream(new Arguments[]{                     Arguments.of(1, 2, 3)             });         }     } } ```  This code results to a `org.junit.platform.commons.util.PreconditionViolationException: Cannot invoke non-static method [java.util.stream.Stream NestedParameterizedTest$TheNesting.getTestData()] on a null target.`  ### Scenario 2 Making `getTestData()` static though results to a compile error `Inner classes cannot have static declarations`.  ### Scenario 3 Making `getTestData()` and `class TheNesting` static though results in `Empty test suite.`","closed","theme: parameterized tests,","franz-see","2018-01-05T13:36:07Z","2020-04-20T12:32:53Z"
"","1075","Bug: Tests don't fail under special conditions when using ExpectedExceptionSupport","## Overview  **Bug report**  I noticed that my tests don't fail anymore when using `ExpectedExceptionSupport` without an exception rule. You can check that behaviour with the appended JUnit tests.  JUnit5 version: ```      org.junit.jupiter     junit-jupiter-migrationsupport     5.0.0     test  ```  ## Deliverables  ### 1st Test: ExceptionSupportTest Actual behaviour: test succeeds. Expected behaviour: test fails.  ``` import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.migrationsupport.rules.ExpectedExceptionSupport;  @ExtendWith(ExpectedExceptionSupport.class) public class ExceptionSupportTest {      @Test     public void shouldFail() {         throw new RuntimeException();     }  } ```  ### 2nd Test: WorkingExceptionSupportTest Works as expected.  ``` import org.junit.Rule; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.migrationsupport.rules.ExpectedExceptionSupport; import org.junit.rules.ExpectedException;  @ExtendWith(ExpectedExceptionSupport.class) public class WorkingExceptionSupportTest {      @Rule     public final ExpectedException exception = ExpectedException.none();      @Test     public void failsAsExpected() {         throw new RuntimeException();     }  } ``` ### 3rd Test: More usual test case Actual behaviour: test succeeds. Expected behaviour: test fails.  ``` import org.junit.Rule; import org.junit.jupiter.api.Test; import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport; import org.junit.rules.TemporaryFolder;  import java.io.IOException;  // hint: EnableRuleMigrationSupport also enables ExpectedExceptionSupport @EnableRuleMigrationSupport public class MigrationSupportTest {      @Rule     public TemporaryFolder folder = new TemporaryFolder();      @Test     public void shouldFail() throws IOException {         // this illegal operation throws an exception but the test succeeds         folder.newFolder(""/\\"");     }  } ```","closed","component: Jupiter,","sealor","2017-09-25T14:35:55Z","2017-09-25T14:38:59Z"
"","1422","JUnit 5 Theories","## Overview  (Re-opening as a separate pull request, since first PR was corrupted by a botched Git rebase.)  Adds theories, in a form similar to JUnit 4's Theories. This will close ticket #395.  Substantial changes from JUnit 4:  - Methods allowed as sources of data points - Streams and Iterators as accepted data point types, but only when produced by methods (since both are stateful, they have to come from a method so they can be read more than once) - Suppliers system for simple data points (similar in form to parameterized tests, but allows mixing of in-line data points with class-level data points)   - Specified via the `ArgumentsSuppliedBy` meta-annotation. This ties the annotation to a supplier class   - Supplier class implements `TheoryArgumentSupplier` (or extends `AbstractTheoryArgumentSupplier` for common use cases). This class reads the annotation and produces the corresponding data points   - Examples: ``` @Theory public void myTheory(@IntValues(0, 42, 99) int someIntValue)  @Theory public void myTheory(@ByteValues(0, 42) byte somByteValue, SomeClass valueFromClassLevelDataPoint) ``` - Qualifiers directly on theory parameters. Example: ``` @DataPoints(qualifiers = ""nonZero"") private static final List GREATER_THAN_ZERO = Arrays.asList(3, 5, 7);  @DataPoint private static final Double ZERO = 0;  @DataPoint(qualifiers = ""nonZero"") private static final double NEGATIVE_NUMBER =  -4;  @Theory public void testDivisionOperator(double dividend, @Qualifiers(""nonZero"") double divisor) ```  A few (very rough) examples can be found in: junit-jupiter-theories/src/test/java/org/junit/jupiter/theories/TheoriesTestCase.java  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","nrllewellyn","2018-05-16T05:13:50Z","2018-05-21T12:12:56Z"
"","1573","Disallow TestInstanceFactory overrides in @Nested test classes","## Overview  #672 introduced a new `TestInstanceFactory` extension API with support for overriding a `TestInstanceFactory` registered on an enclosing class for an enclosed `@Nested` class. However, similar ""overriding"" support does not exist for traditional test class hierarchies (i.e., a subclass cannot override a `TestInstanceFactory` registered on a superclass).  _Team Decision_ from https://github.com/junit-team/junit5/issues/1567#issuecomment-417624234:  > Align the behavior between conventional class hierarchies and nested class structures with regard to disallowing multiple registrations of `TestInstanceFactory` extensions. Consequently, it should not be possible to override a `TestInstanceFactory` registered on an enclosing class for an enclosed `@Nested` test class.  ## Deliverables  - [x] Disallow `TestInstanceFactory` overrides in `@Nested` test classes. - [x] Update JavaDoc accordingly. - [x] Update the User Guide accordingly.","closed","component: Jupiter,","sbrannen","2018-08-31T13:48:21Z","2018-08-31T16:33:37Z"
"","1952","Compile and test on Java 12","## Overview  #1951  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2019-07-09T16:42:11Z","2019-07-13T17:06:26Z"
"","1728","Test fix for legacy reporting names for Vintage tests","## Overview  #1719 provided a fix for the regression in  legacy reporting names for the `VintageTestEngine` but did not introduce integration tests to verify the actual output from Maven Surefire and Gradle.  ## Deliverables  - [x] Introduce integration tests that verify the expected output (e.g., content and names of files) from **Maven Surefire** for Vintage test classes. - [x] Introduce integration tests that verify the expected output (e.g., content and names of files) from **Gradle** for Vintage test classes.","closed","component: Vintage,","sbrannen","2019-01-12T10:10:49Z","2019-01-19T16:35:22Z"
"","1662","Convert Test Kit to fluent API","## Overview  #1356 introduced the _Test Kit_ as a published artifact.  However, the existing API is rather static in nature.  This issue aims to improve the user experience by converting the Test Kit to a _fluent API_.  ## Scope  The existing APIs in `ExecutionEventConditions` and `TestExecutionResultConditions` are out of scope for this issue.  ## Related Issues  - #1356  - #1621   ## Considerations  1. ✅ Decide on naming for dynamically registered containers and tests, since ""test"" doesn't make sense if you've filtered by containers.    - Ideas: `dynamicRegistration()`, `dynamicNodeRegistered()`    - Team Decision: **`dynamicallyRegistered()`** 1. ❌ Introduce category-aware `Events` specializations (e.g., `SkippedEvents`, `FinishedEvents`, etc.) in order to prevent broken use cases such as `events.skipped().aborted()` -- for example, `SkippedEvents` would not provide `aborted()` as part of its API since that would not make sense.    - Team Decision: stick with the existing API. 1. ✅ Convert `Statistics` assertion API to a fluent API and thus remove the need for static imports.    - Team Decision: implement a spike to verify feasibility. 1. ❌ Split `Statistics` into `GlobalStatistics` and `FilteredStatistics`, so that statistics for tests *and* containers can be asserted together via `ExecutionResults.events()` instead of separately via `ExecutionResults.containers()` and `ExecutionResults.tests()`.    - Team Decision: hold off for now. 1. ❌ Introduce fluent API for AssertJ-based assertions for **events**, replacing the existing static factory methods with discoverable method chaining analogous to AssertJ's APIs.    - Team Decision: stick with the existing static factory methods. 1. ❌ Introduce  built-in AssertJ-based assertions for **executions** analogous to those for events.    - Team Decision: wait for community feedback. 1. ❌ Introduce  support for asserting statistics for **executions** analogous to those for events.    - Team Decision: wait for community feedback.  ## Deliverables  - [x] Introduce fluent API for filtering and accessing **events**. - [x] Introduce fluent API for filtering and accessing **executions**. - [x] Introduce fluent API for asserting statistics for **events**. - [x] Introduce support for debugging **events**. - [x] Introduce support for debugging **executions**. - [x] Introduce Javadoc for new fluent APIs. - [x] Write (and potentially rewrite) Javadoc for all public APIs in the Test Kit, excluding `ExecutionEventConditions` and `TestExecutionResultConditions` which are out of scope. - Will be documented in the Release Notes in conjunction with #1621.","closed","component: Test Kit,","sbrannen","2018-11-02T11:37:21Z","2018-11-17T14:09:34Z"
"","1619","Support  randomizing test class order","## Overview  #13 Implements support for random method order, but does not address class ordering.  The benefits of pseudo random testing are described here: https://github.com/randomizedtesting/randomizedtesting/wiki/Core-Concepts The framework is extensively used for Apache Lucene and Elasticsearch.  ## Deliverables  - [ ] A  mechanism to control how classes are ordered, similar to what we have for methods. I'm not sure what the best way to implement it would be, as I imagine it couldn't be a similar annotation.","closed","component: Jupiter,","alpar-t","2018-10-04T18:51:09Z","2020-02-13T11:56:02Z"
"","1290","Issue1191 conversion of multiple args","## Overview  #1191 : Addition of CsvFileRowConverter to convert parameterized csv file fields into an encapsulation object. Added to CsvFileSource to provide the option of using a custom converter within a test.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","ghost","2018-02-10T05:46:10Z","2018-02-13T12:54:06Z"
"","1299","Build on 4 JDK variants and test fallback for missing ""java.scripting"" module","## Overview  ### JDK Build Matrix  Four JDK variants are used on Travis CI to build:  - Oracle JDK 9.0.1+11 provided by Travis CI - OpenJDK 9.0.4+11 from http://jdk.java.net/9/ - Oracle JDK 10 jdk-10+43 http://jdk.java.net/10/ - OpenJDK 10 jdk-10+43 http://jdk.java.net/10/  ### Fallback Mode for missing ""java.scripting"" module  When running on a JRE in module-path mode it is guaranteed that the module ""java.scripting"" is available per default. For example, the default OpenJDK JRE does not make it observable by default. And a custom JRE may not include that module at all.  As the Jupiter API provides conditional test execution annotations (`@DisabledIf` and `@EnabledIf`) that rely on scripting suppport the framework may fail on the first attempt to evaluate user-provided scripts. A fallback mode that disables script-based conditional test execution evaluation is already in place. This PR adds a test for it to kick in.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2018-02-18T10:46:00Z","2018-02-18T12:50:49Z"
"","1292","Add hooks to DynamicContainer which execute beforeall/afterall tests","## Overview  ### Feature request  I'm building a very simple test framework https://github.com/mvysny/dynatest . I would like to add a simple functionality akin to `@BeforeAll`/`@AfterAll`; a code in DynamicContainer that would be run by JUnit5 before/after all nested tests are run.  Implementation proposal: the `DynamicContainer` could have two more fields, `public Runnable beforeAll = null` and `public Runnable afterAll = null`; these runnables would then be called by JUnit5 test runner as appropriate.  JUnit currently 5.0.3 lacks this capability.  Thank you very much :)","closed","theme: dynamic tests,","mvysny","2018-02-11T12:13:25Z","2018-02-28T09:45:30Z"
"","1293","Enhance DynamicNode with optional TestSource property","## Overview  ### Feature request  Hi! I'm building a very simple test framework https://github.com/mvysny/dynatest which basically constructs a tree of dynamic containers/tests. The tests are nicely run by Intellij and visualized as a tree. However, selecting any dynamically generated test in the Intellij's ""Run"" tool window does nothing. I presume that's because the `DynamicNode` lacks the reference to the test source.  Perhaps a field of type `TestSource` could be added to the `DynamicNode` class, which my framework would fill with a proper source file reference?  Thanks!","closed","component: Platform,","mvysny","2018-02-11T12:24:27Z","2018-02-12T15:51:40Z"
"","1276","Is there any workaround for using PostDiscoveryFilter on Vintage engine?","## Overview  ### Bug report  Recently I was trying to integrate JUnit 5 and Gradle and encountered a bug, which is `PostDiscoveryFilter` is ignored in `Vintage` engine (similar to #1265 but not exactly same)  ``` public class VintageBug {     public static void main(String[] args) {         Launcher launcher = LauncherFactory.create();          LauncherDiscoveryRequestBuilder requestBuilder = LauncherDiscoveryRequestBuilder.request()                 .selectors(DiscoverySelectors.selectClass(ParameterizedFoo.class))                 .filters(new PostDiscoveryFilter() {                     @Override                     public FilterResult apply(TestDescriptor descriptor) {                         if (shouldInclude(descriptor)) {                             System.out.println(""Include: "" + descriptor.getUniqueId());                             return FilterResult.included(""included"");                         } else {                             System.out.println(""Exclude: "" + descriptor.getUniqueId());                             return FilterResult.excluded(""excluded"");                         }                     }                      private boolean shouldInclude(TestDescriptor descriptor) {                         Optional source = descriptor.getSource();                         if (!source.isPresent()) {                             return true;                         }                          if (source.get() instanceof MethodSource) {                             MethodSource methodSource = (MethodSource) source.get();                             return methodSource.getMethodName().contains(""shouldBeIncluded"");                         } else if (source.get() instanceof ClassSource) {                             for (TestDescriptor child : descriptor.getChildren()) {                                 if (shouldInclude(child)) {                                     return true;                                 }                             }                         }                          return false;                     }                 });         launcher.execute(requestBuilder.build());     }      @RunWith(Parameterized.class)     public static class ParameterizedFoo {         int index;          public ParameterizedFoo(int index) {             this.index = index;         }          @Parameters         public static Collection data() {             return Arrays.asList(new Object[][]{                     {21},                     {42}             });         }          @Test         public void shouldBeIncluded() {             System.out.println(""Should be included: "" + index);         }          @Test         public void shouldBeExcluded() {             System.out.println(""Should be excluded: "" + index);         }     } } ```  And the output is:  ``` Include: [engine:junit-vintage]/[runner:VintageBug$ParameterizedFoo]/[test:%5B0%5D]/[test:shouldBeIncluded%5B0%5D(VintageBug$ParameterizedFoo)] Exclude: [engine:junit-vintage]/[runner:VintageBug$ParameterizedFoo]/[test:%5B0%5D]/[test:shouldBeExcluded%5B0%5D(VintageBug$ParameterizedFoo)] Include: [engine:junit-vintage]/[runner:VintageBug$ParameterizedFoo]/[test:%5B1%5D]/[test:shouldBeIncluded%5B1%5D(VintageBug$ParameterizedFoo)] Exclude: [engine:junit-vintage]/[runner:VintageBug$ParameterizedFoo]/[test:%5B1%5D]/[test:shouldBeExcluded%5B1%5D(VintageBug$ParameterizedFoo)] Should be included: 21 Should be excluded: 21 Should be included: 42 Should be excluded: 42 ```  `5.1M2` solved this issue. However, is there any workarounds for `Vintage` to exclude such tests? I'd like a `5.1` instead of `5.1M2` in production code.","closed","","blindpirate","2018-02-02T03:25:49Z","2018-02-02T06:40:10Z"
"","1277","Can't get method details in @Ignore class with Vintage engine","## Overview  ### Bug report  I'm trying to run `Vintage` engine on old JUnit 4 tests and encountered an issue:  ``` public class VintageIgnore {     public static void main(String[] args) {         Launcher launcher = LauncherFactory.create();          launcher.registerTestExecutionListeners(new TestExecutionListener() {             TestPlan currentTestPlan;              @Override             public void testPlanExecutionStarted(TestPlan testPlan) {                 currentTestPlan = testPlan;             }              @Override             public void executionSkipped(TestIdentifier testIdentifier, String reason) {                 System.out.println(""Skipping: "" + testIdentifier.getUniqueId());                 if (testIdentifier.getSource().isPresent() && testIdentifier.getSource().get() instanceof ClassSource) {                     System.out.println(""class: "" + testIdentifier.getUniqueId());                     currentTestPlan.getChildren(testIdentifier).stream().map(TestIdentifier::getUniqueId).forEach(System.out::println);                     System.out.println("""");                 }             }         });          LauncherDiscoveryRequestBuilder requestBuilder = LauncherDiscoveryRequestBuilder.request()                 .selectors(selectClass(JupiterTest.class), selectClass(VintageTest.class));         launcher.execute(requestBuilder.build());     }      @org.junit.jupiter.api.Disabled     public static class JupiterTest {         @org.junit.jupiter.api.Test         public void test() {         }     }      @org.junit.Ignore     public static class VintageTest {         @org.junit.Test         public void test() {         }     } } ```  With `org.junit.vintage:junit-vintage-engine:5.1.0-M2` and `org.junit.jupiter:junit-jupiter-engine:5.1.0-M2`, `Jupiter` engine can describe test methods in `@Disabled` class but `Vintage` engine can't describe test methods in `@Ignore` class.  The output is:  ``` Skipping: [engine:junit-vintage]/[runner:VintageIgnore$VintageTest] class: [engine:junit-vintage]/[runner:VintageIgnore$VintageTest]  Skipping: [engine:junit-jupiter]/[class:VintageIgnore$JupiterTest] class: [engine:junit-jupiter]/[class:VintageIgnore$JupiterTest] [engine:junit-jupiter]/[class:VintageIgnore$JupiterTest]/[method:test()] ```","closed","theme: discovery,","blindpirate","2018-02-02T05:44:55Z","2018-02-03T23:27:57Z"
"","1302","Use callable or String supplier to build assertion messages","## Overview   Future request on assertion implementation. Assertion messages should build after failure not immediately  - ( ) **Feature request.** i.e. below code block:  ``` Optional nullable = Optional.ofNullable(null);  assertFalse(""Here no nullable expected!"" + nullable.get(), nullable.isPresent()); ```   will throw:  >  java.util.NoSuchElementException  instead of assertion failure.","closed","status: works-as-designed,","buraksarac","2018-02-23T09:01:33Z","2018-02-23T09:22:42Z"
"","1519","add support for parameterized tests in JUnit XML reports","## Overview   **Feature request.**  We're a Test Management vendor for Jira and our addon (Xray) (https://marketplace.atlassian.com/apps/1211769/xray-test-management-for-jira?hosting=server&tab=overview) provides already handling of JUnit XML reports. However, our users have the need of have visibility of the results from parameterized tests so they can properly analyze them. The problem that we're facing with JUnit is that the current XML report does not provide visibility of this, so our users cannot take advantage of this information in our reports because we simply are unable to process them. With TestNG this works fine though, so some users are using it instead. Of course we want to promote also JUnit and I think if we were able to get a way of at least deal with parameterized tests in some way  Some preliminary investigation with JUnit4 allowed us to see that different runners are able to overcome this, although in slight different ways.  It seems that the output generated with JUnit4 generates a ""standard"" JUnit xml where the ""name"" attribute contains the parameters as seen below (using two different runners).  ```xml      ```   The first example was generated with the ""Parameterized"" class runner,  ```java package com.xpand.java;  import static org.junit.Assert.assertEquals;  import java.util.Arrays;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters;  @RunWith(Parameterized.class) public class Fibonacci3Test {      @Parameters(name = ""{index}: fib({0})={1}"")     public static Iterable data() {         return Arrays.asList(new Object[][] {                   { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 }            });     }      private int input;     private int expected;      public Fibonacci3Test(int input, int expected) {         this.input = input;         this.expected = expected;     }      @Test     public void testCompute() {         assertEquals(expected, Fibonacci.compute(input));     } } ```  ```xml                      ``` The second example code,  using JUnitParamsRunner class,  is:  ```java package com.xpand.java;  import static org.assertj.core.api.Assertions.assertThat;  import org.junit.Test; import org.junit.runner.RunWith;  import junitparams.JUnitParamsRunner; import junitparams.Parameters;   @RunWith(JUnitParamsRunner.class) public class PersonTest {  	@Test 	@Parameters({  	        ""17, false"",  	        ""22, true"" }) 	public void personIsAdultInline(int age, boolean valid) throws Exception { 	    assertThat((new Person(age)).isAdult()).isEqualTo(valid); 	} 	 	@Test 	@Parameters(method = ""adultValues"") 	public void personIsAdultMethod(int age, boolean valid) throws Exception { 	    //assertEquals(valid, new Person(age).isAdult()); 	    assertThat(new Person(age).isAdult()).isEqualTo(valid); 	}  	private Object[] adultValues() { 	    return new Object[]{ 	                 new Object[]{13, false}, 	                 new Object[]{17, false}, 	                 new Object[]{18, true}, 	                 new Object[]{22, true} 	            }; 	} } ```   ```xml       ``` Thanks for your help.   It would be great to uniformize this somehow. Some possible suggestions, taken the last example as an input:   - use the ""name"" attribute and put there the name of the method plus the arguments; e.g. ""personIsAdultInline(22, true)"" - a better option would be to have the name of the arguments also; e.g. ""personIsAdultInline(age: 22, valid: true)""  Some care needs to be taken though, since arguments can be potentially lengthy and have strings..  note: please see previous discussion on https://github.com/junit-team/junit5/issues/1182#issuecomment-409680219","closed","","bitcoder","2018-08-02T12:05:16Z","2019-06-19T14:41:34Z"
"","1630","add support for tags in JUnit XML reports","## Overview   **Feature request.**  As mentioned in #1182,wee're a Test Management vendor for Jira and our addon (Xray) (https://marketplace.atlassian.com/apps/1211769/xray-test-management-for-jira?hosting=server&tab=overview) provides already handling of JUnit XML reports. However, our users have the need of allowing to tag Tests with certain labels / Jira issue keys, so that their results can be mapped to the proper issues in Jira. The problem that we're facing with JUnit is that the XML report does not provide visibility of this, so our users cannot take advantage of this information in our reports because we simply are unable to process them. With TestNG this works fine though, so some users are using it instead. Of course we want to promote also JUnit as many users use it. Maybe they could be added as nested elements under the  element and that wouldn't break anything. Thanks for your help.","closed","theme: build,","bitcoder","2018-10-09T14:54:04Z","2018-12-01T15:42:23Z"
"","982","Document behavior of ""hidden"" static methods","## JUnit 4 Behavior  ```java public class A {  	@org.junit.BeforeClass 	public static void beforeClass() { 		System.out.println(""A""); 	}  	@org.junit.Test 	public void a() { 		System.out.println(""a()""); 	} } ```  ```java public class B extends A {  	@org.junit.BeforeClass 	public static void beforeClass() { 		System.out.println(""B""); 	}  	@org.junit.Test 	public void b() { 		System.out.println(""b()""); 	} } ```  Executing test class `B` with JUnit 4 results in the following:  ``` B b() a() ```  ## JUnit Jupiter Behavior  ```java class A {  	@BeforeAll 	static void beforeAll() { 		System.out.println(""A""); 	}  	@Test 	void a() { 		System.out.println(""a()""); 	} } ```  ```java class B extends A {  	@BeforeAll 	static void beforeAll() { 		System.out.println(""B""); 	}  	@Test 	void b() { 		System.out.println(""b()""); 	} } ```  Executing test class `B` with JUnit Jupiter results in the following:  ``` B a() b() ```  ## Deliverables  - [x] Write unit tests in `ReflectionUtilsTests` that verifies the current behavior within the Platform. - [x] Write an integration test in `junit-jupiter-engine` that verifies the current behavior within Jupiter. - [x] Document the current behavior in the User Guide. - [x] Document the current behavior in `ReflectionSupport`.","closed","component: Platform,","marcphilipp","2017-07-25T11:04:01Z","2017-07-26T14:16:54Z"
"","1906","Upgrade to JDK 13","## JDK 13  ""JDK 13, the reference implementation of Java 13, is now Generally Available."" as of `2019-09-17`.  https://jdk.java.net/13/  -   350: Dynamic CDS Archives -   351: ZGC: Uncommit Unused Memory -   353: Reimplement the Legacy Socket API -   354: Switch Expressions (Preview) -   355: Text Blocks (Preview)  ## Deliverables  - [ ] Upgrade to JDK 13 as the minimum to build ""JUnit 5"" - [ ] ~~Make use of Java [Text Blocks](https://openjdk.java.net/jeps/355) syntax in our test code~~ - [ ] Remove JDK 12 from the build matrix, it reached EOL","closed","theme: modules,","sormuras","2019-05-30T08:17:11Z","2019-10-21T18:28:54Z"
"","1139","Introduce extension API for accessing arguments passed to tests","## Issue  Extension methods all have `ExtensionContext` which provides us many useful information like `displayname`, `method` or `tags`. This helps  in writing custom test reports.  What I'm missing is a way to get argument instances of a `@ParameterizedTest`. When not running tests extended by a `ParameterResolver` using `ExtensionContext.Store` you can only make a workaround to get a clue of what arguments were used for the test:  - Filter displayname (objects need to override `toString()` for important informations) - get values from annotations  If parameters are simple strings, integers etc. there is no problem when parsing displayname. The problem starts when one of the parameters is an object containing lots of informations. A new instance would have to be created when analyzing the test, but this doesn't garanty an object with exact the same content like in the test and might also lead to memory issues.  Most simple way is to reimplement Parameterized Test Template, extend from each class, catch resolved parameters and store them directly in ExtensionContext.Store, but I'm not a fan of writing Wrapper classes for such small extensions in existing codes.  ## Possible Suggestions  - Provide a method `Arguments[] ExtensionContext.getArguments()` or `List ExtensionContext.getArguments()` which returns a list of all Arguments used for the test (empty list if no arguments were used). - Store arguments in `ExtensionContext.Store` with a predefined namespace in your `ParameterizedTestParameterResolver` class (then there is no need to do it in custom `ArgumentsProvider` classes) - Provide an Extension interface which is called between `BeforeTestExecutionCallback` and `@Test`. As parameters it should have `ExtensionContext` and `Arguments[]`.  ## Related Issues  - #944 - #1668 - #1884","open","theme: parameterized tests,","rumpfc","2017-11-03T09:57:59Z","2022-07-29T09:37:18Z"
"","1911","Convenient way to use static Java methods in @Enabled*/@Disabled*","## Idea  I would like to be able to easily use the logic placed in my static Java methods to determine if a given test(s) should be executed or not.  ## Rationale  In some cases it is convenient to delegate the logic in conditional test execution to custom Java code. A real life usage - determine if strong cryptography is available in JDK to [disable all related tests](https://github.com/4finance/micro-infra-spring/blob/7d77b9bda1abe6fa236c13c8ea73eb15623ad18e/micro-infra-spring-config/src/test/groovy/com/ofg/infrastructure/property/decrypt/LoadingEncryptedFromFileSystemSpec.groovy#L17-L18) and [fail just one](https://github.com/4finance/micro-infra-spring/blob/7d77b9bda1abe6fa236c13c8ea73eb15623ad18e/micro-infra-spring-config/src/test/groovy/com/ofg/infrastructure/property/decrypt/BrokenJceInstallationWarningSpec.groovy#L9-L14) to inform external contributor in meaningful way that his/her configuration is not optimal (I know it is somehow obsolete as of Java 11 and using OpenJDK all around, but at the time it was a real issue for us with Oracle JDK).  In Spock it can be easily done with:  ```groovy @IgnoreIf({ SomeUtil.isStrongEncryptionSupported() }) class BrokenJceInstallationWarningSpec extends Specification {     .... ```  In JUnit 5 it should be achievable with a few lines of Java Script and `@EnableIf` (looking at the JUnit 5 documentation) which is somehow inconvenient. In addition `@EnableIf` has been deprecated recently.  ## API proposal  As Java is more limited that Groovy it doesn't seem to be possible to get that level of API:  ```java @EnabledX(() -> MyUtil.callMyStaticMethodReturningBoolean()) // or @EnabledX(MyUtil::callMyStaticMethodReturningBoolean) ```  Therefore, it would probably be needed to use String literals:  ```java @EnabledX(method = ""com.example.MyUtil.callMyStaticMethodReturningBoolean"") // or @EnabledX(package = ""com.example"", method = ""MyUtil.callMyStaticMethodReturningBoolean"") ```  If package is omitted JUnit could try to assume the same package as enclosing class to try to resolve the method.  I would exclude an ability to pass method arguments or JUnit context to a called method.  Please note that I don't know the internal of JUnit 5, so some of the idea could be hard/problematic to implement. Feel free to choose some other (convenient) way to implement that feature.  BTW, `@EnabledX` is also a place holder which should be changed to something more meaningful.  ## Deliverables  - [x] Convenient API to use static Java methods in `@Enabled*`/`@Disabled*` - [x] Documentation update","closed","component: Jupiter,","szpak","2019-06-02T13:49:47Z","2021-07-24T10:09:04Z"
"","1914","Support test methods with Kotlin suspend modifier","## Goals  Support running suspend test in JUnit Jupiter:  ```kotlin class Kit {     @Test      suspend fun foo() {         delay(1000) // suspend call         assertEquals(1, 1)     }  } ```  Currently, such test can be written this way:  ```kotlin class Kit {     @Test      fun foo() = runBlocking {         delay(1000) // suspend call         assertEquals(1, 1)         assertThrows { /* ... */ }          Unit // test should return void, but `assertThrows` returns `Throwable`, so `foo` returns `Throwable` too      }  } ```  Also, will be nice to provide `CoroutineScope` through params, or as receiver in extension:  ```kotlin class Kit {     suspend fun foo(scope: CoroutinesScope) {  /* ... */  } // (1)     suspend fun CoroutinesScope.foo() {  /* ... */  } // (2) } ``` 1 and 2 actually the same on bytecode level. `suspend` is optional.  And finally, support for `runBlockingTest`:  ```kotlin class Kit {     suspend fun foo(scope: TestCoroutinesScope) {  /* ... */  }     suspend fun TestCoroutinesScope.foo() {  /* ... */  }  } ```  ## What can be done currently  `ParameterResolver` can be used to provide stubs for `Continuation`, `CoroutineScope` and `TestCoroutineScope`. These stub arguments can be replaced with real arguments in invocation.  ## Problems  Current extensions points not enough to implement this feature as extensions, since:  1. **Discovery**. Jupiter discovers tests that returns `void`, but `suspend fun` returns `Object`; 2. **Invocation**. `InvocationInterceptor` in 5.5-M1(SNAPSHOT) don't providing mechanism to override actual invocation, only to decoration of existing invocation. Conversion of `method` to `kotlinFunction`, and then executing using [`callSuspend`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/call-suspend.html) is necessary to execute `suspend fun`.  Also, my [slides](https://ruslan.ibragimov.by/pages/cv/speaker/kotlin-night-kiev-2019-junit.pdf) about this topic.","open","component: Kotlin,","IRus","2019-06-04T06:51:46Z","2022-06-21T02:06:14Z"
"","1866","Add Kotlin Contracts to Exposed Kotlin API","## Foreward First off, I want to thank the Junit 5 team from being so willing to officially support Kotlin as a first-class citizen in the Junit 5 library. It has been absolutely wonderful being able to use my own contributions in all of my Kotlin projects.  ## Feature Request  I believe that this API can be further enhanced with the new Kotlin 1.3 feature, [Contracts](https://kotlinlang.org/docs/reference/whatsnew13.html#contracts).  Contracts are making guarantees to the compiler that various methods have certain characteristics.  Here's an example from the Kotlin Std-Lib:  ```kotlin /**  * Throws an [IllegalStateException] if the [value] is null. Otherwise  * returns the not null value.  *  * @sample samples.misc.Preconditions.failCheckWithLazyMessage  */ @kotlin.internal.InlineOnly public inline fun  checkNotNull(value: T?): T {     contract {         returns() implies (value != null)     }     return checkNotNull(value) { ""Required value was null."" } } ```  Before Kotlin Contracts, the following code wouldn't have compiled: ```kotlin fun validateString(aString: String?): String {     checkNotNull(aString)     return aString } ```  I believe that JUnit 5 has a few places where these contracts would be valuable.  ### Examples  #### `assertNotNull`  ```kotlin @ExperimentalContracts fun  assertNonNull(actual: T?, message: String): T {     contract {         returns() implies (actual != null)     }     Assertions.assertNotNull(actual, message)     return actual!! } ```  The above would allow something like this:  ```kotlin val exception = assertThrows assertThrows(noinline message: () -> String, noinline executable: () -> Unit): T {     contract {         callsInPlace(executable, InvocationKind.EXACTLY_ONCE)     }     return Assertions.assertThrows(T::class.java, Executable(executable), Supplier(message)) } ```  Similar   This would for something like this: ```kotlin val something: Int val somethingElse: String assertDoesNotThrow {     something = somethingThatDoesntThrow()     somethingElse = gettingSomethingElse() } ```  ## Caveats  Kotlin Contracts are only supported in Kotlin 1.3 and higher. This would require a discussion regarding what version of Kotlin the Junit 5 team want's to officially support.  ## Deliverables  - [ ] Add Kotlin method `assertNotNull` - [ ] Add Contracts to Kotlin method `assertNotNull` - [ ] Add Contracts to Kotlin method `assertThrows` - [ ] Add Contracts to Kotlin method `assertDoesNotThrow`","open","component: Kotlin,","JLLeitschuh","2019-04-17T14:18:23Z","2022-07-12T07:56:08Z"
"","1418","Introduce java.time formatting support for @ParameterizedTest display names","## Feature request  The display name of the following is not very readable. Of course the real problem is that Java didn't make `DateTimeFormatter` implement `Format`; otherwise, I believe this would work out of the box.  It would be nice to provide java.time formatting for the display name. Might also be nice to allow custom formatters.   ```java     @ParameterizedTest( name = ""[{index}] {1}  is {2} from now {0}"")     @ArgumentsSource( Instants.class )     void testIsLockedOn( Instant now, Instant time, Duration duration ) {         assertThat( lockedRange.isLockedOn( time ) ).isEqualTo( SEC.equals( duration ) );     } ```","closed","status: stale,","xenoterracide","2018-05-12T06:46:47Z","2021-06-03T20:47:13Z"
"","1189","Add support to assert the content of two iterables, ignoring the element order","## Feature Request  I'd like to introduce an assertion that checks the content of two iterables, ignoring the elements order. For example, having two iterables, all currently available assertions take the order into account:   ```java        @Test     void testIterablesEquality() {         final List expected = new ArrayList<>();         expected.add(""FOO"");         expected.add(""BAR"");          final List actual = new ArrayList<>();         actual.add(""BAR"");         actual.add(""FOO"");          assertThrows(AssertionFailedError.class, () -> assertEquals(expected, actual));         assertThrows(AssertionFailedError.class, () -> assertIterableEquals(expected, actual));     } ``` A first draft of such an assertion could look like the following:   ```java      public static void assertIterableContentIgnoreOrder(Iterable expected, Iterable actual) {         Map tmpMap = new HashMap<>();          for (Object obj : expected) {             tmpMap.putIfAbsent(obj, 0);             tmpMap.compute(obj, (o, cnt) -> cnt + 1);         }         for (Object obj : actual) {             Integer count = tmpMap.get(obj);             if (count == null) {                 fail(""Occurrences of "" + obj + "" greater in actual iterable."");             }             if (count > 1) {                 tmpMap.compute(obj, (o, cnt) -> cnt - 1);             } else {                 tmpMap.remove(obj);             }         }         if (!tmpMap.isEmpty()) {             fail(""Iterables content differs."");         }     } ```","closed","component: Jupiter,","u6f6o","2017-11-28T09:25:18Z","2017-11-28T15:28:55Z"
"","1356","Introduce Test Kit for testing engines","## Feature Request  I am looking for a straightforward stable API for testing Extensions that would offer deep insights when meta-testing the Extension (think something similar to what is provided via the [SummaryGeneratingListener](https://github.com/junit-team/junit5/blob/master/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/SummaryGeneratingListener.java), but with finer grained information reported).  Context here is that testing extensions via meta-testing (having a test that tests other test runs), I found it to be super helpful for getting insights around the test executions that occur based on how my extension may or may not affect them.  [ExecutionEventRecorder](https://github.com/junit-team/junit5/blob/master/junit-platform-engine/src/test/java/org/junit/platform/engine/test/event/ExecutionEventRecorder.java) seems to have some functionality that would be helpful in getting a deep insight to what a custom Extension might be doing, but it looks like it's not published as an API to consumers?  And some digging around led me to find things like [ExecutionReportListener](https://github.com/JeffreyFalgout/junit5-extensions/blob/master/extension-testing/src/main/java/name/falgout/jeffrey/testing/junit/testing/ExecutionReportListener.java) exist in the wild (see relevant SO question: https://stackoverflow.com/questions/46841243/how-to-test-extension-implementations), but it still has some holes in it's implementation.  For example, it doesn't propagate information like test run duration, start and end times, test hierarchy, etc.  I took a stab at rolling some custom things to [test the new Junit5 extension docker-compose-rule in this branch](https://github.com/dotCipher/docker-compose-rule/tree/e2b97809e832575c7d210d8170cf263a39f45f98/docker-compose-rule-junit5/src/test/java/com/palantir/docker/compose/test) (full PR here: https://github.com/palantir/docker-compose-rule/pull/223) that include the metadata I was referring too above, but wanted to know if there was a better way of doing it, or if something was published already.  If not, I would be requesting this functionality from Junit5.  ## Related Issues  - #1621  - #1662","closed","component: Test Kit,","dotCipher","2018-04-02T19:13:29Z","2018-11-03T16:48:17Z"
"","1066","Release notes should be ordered from newest to oldest","## Feature request  As the project has produced more releases, it's pretty obvious that you have to scroll a long way past the content of the user's guide to review the most recent release notes.  ## Deliverables  - [x] Reverse the order of the published release notes.","closed","theme: documentation,","smoyer64","2017-09-15T19:22:36Z","2019-07-19T19:32:44Z"
"","1611","Introduce better support for accessing fields","## Feature Request  _Add APIs for accessing fields of test classes and instances._  When authoring an extension one often needs to access fields of a test class or instance fields of a test instance. Usually one is interested in fields of a certain type possibly annotated with a certain method. There is currently no API to do this in JUnit so one has to fall back to raw reflection code.  I see two ways to implement this:  1. Add more methods to `ReflectionSupport` - this will work but I don't think we should put more and more functionality into these helper classes  ```java /**  * Get the values of the static fields annotated with the given annotation from the given class.  */ List getAnnotatedFields(Class, Class)  /**  * Get the values of the static fields annotated with the given annotation of the given  * type from the given class.  */  List ReflectionSupport.getAnnotatedFieldsOfType(Class, Class, Class type)  /**  * Get the values of the instance fields annotated with the given annotation from the given object.  */ List ReflectionSupport.getAnnotatedFields(Object, Class)  /**  * Get the values of the instance fields annotated with the given annotation of the given  * type from the given object.  */  List ReflectionSupport.getAnnotatedFieldsOfType(Object, Class, Class type)  ```  2. Follow a more object-oriented approach and create specialized objects that help with this:  ```java /**  * A wrapper around the test class being executed.  */ public interface TestClass {      List getAnnotatedFieldValues(Class)        List getAnnotatedFieldValues(Class, Class) }  /**  * A wrapper around the test instance being executed.  */ public interface TestInstance {      List getAnnotatedFieldValues(Class)        List getAnnotatedFieldValues(Class, Class) }  ```  The specialized objects could be accessed from the `ExtensionContext`. Methods like `getRequiredTestClass` et al. could be deprecated.  ## Deliverables  - [x] Introduce API for easier access of fields inside of test classes and test instances. - [x] Document in User Guide.    - ❌ deemed unnecessary since the new features are documented in Javadoc. - [x] Document in Release Notes.","closed","component: Platform,","britter","2018-10-01T15:21:37Z","2019-01-22T16:22:01Z"
"","1024","Document code or automatically configure Jacoco with Junit 5 Gradle Plugin","## Feature (or Documentation) Request Should the Junit 5 plugin automatically configure the `junitPlatformTest` task to use Jacoco if it detects the plugin?  Currently configuring jacoco with Junit 5 requires a bit of digging into the DSL and figuring out its intricacies.  Perhaps configure the Junit5 plugin should be expanded to have a `enableJacoco` flag that will add a `jacocoJunit5TestReport` task if set to `true`? What are the teams thoughts?  ### Current solutions  Anyone looking to configure jacoco with Junit 5 using the new [Gradle Kotlin DSL](https://github.com/gradle/kotlin-dsl) you currently need to use a bit of a workaround because of a kotlin compiler bug. This code is known to work with Gradle 4.1  ```kotlin // Don't use this sample, see below afterEvaluate {     val junitPlatformTest by tasks     jacoco {         applyToHelper(junitPlatformTest)     }     task(""jacocoJunit5TestReport"") {         executionData(junitPlatformTest)         sourceSets(java.sourceSets[""main""])         sourceDirectories = files(java.sourceSets[""main""].allSource.srcDirs)         classDirectories = files(java.sourceSets[""main""].output)     } }  /**  * Workaround fix for calling [org.gradle.testing.jacoco.plugins.JacocoPluginExtension.applyTo]  *  * [Issue details here](https://github.com/gradle/kotlin-dsl/issues/458)  */ fun org.gradle.testing.jacoco.plugins.JacocoPluginExtension.applyToHelper(task : Task) {     val method = this::class.java.getMethod(""applyTo"", Task::class.java)     method.invoke(this, task) } ```  **EDIT**  Better solution with less code: ```kotlin afterEvaluate {     val junitPlatformTest : JavaExec by tasks     jacoco {         applyTo(junitPlatformTest)     }     task(""jacocoJunit5TestReport"") {         executionData(junitPlatformTest)         sourceSets(java.sourceSets[""main""])         sourceDirectories = files(java.sourceSets[""main""].allSource.srcDirs)         classDirectories = files(java.sourceSets[""main""].output)     } } ```  ## Deliverables  - [ ] Documentation about how to configure Jacoco with Gradle or add code to the plugin to do it automatically","closed","3rd-party: Gradle,","JLLeitschuh","2017-08-17T14:47:18Z","2018-03-16T14:19:07Z"
"","1580","Extend the list of available constructors for JupiterEngineDescriptor","## Extended the list of available constructors for JupiterEngineDescriptor.  When I create a custom test engine which used the `JupiterEngineDesciptor`, I have no  way to set a custom display name for this test engine.   And when I run tests in IDE, I see two different test engines with the same names.  What do you think, is it possible to make a **public** constructor to `JupiterEngineDescriptor` with ability to set a custom display name?  Also this problem can be solved by addition a **protected** constructor with an ability to set a display name. In this case I can extend the `JupiterEngineDescriptor` and set my own name in the inherited class.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [ ] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: declined,","antkorwin","2018-09-08T23:01:26Z","2018-09-10T15:26:53Z"
"","1669","Introduce runtime dependency from Jupiter API to its Engine","## Engine Implementation Artifact Hint  A test engine API should be able to hint/point to its default implementation artifact. Build tools could use that hint to dynamically resolve an engine implementation artifact and its transitive dependencies at runtime.  For example, in Gradle, it should be enough to state ``` testCompile('org.junit.jupiter:junit-jupiter-api:5.3.1') ``` From this fact, the ""missing"" `testRuntime('org.junit.jupiter:junit-jupiter-engine:5.3.1')` could be deduced.","closed","component: Jupiter,","sormuras","2018-11-08T07:43:28Z","2018-11-30T18:18:39Z"
"","1856","Add nullValue attribute to @CsvSource and @CsvFileSource","## Description  The idea is when parsing the values, null will be also returned if the value is equals to the string.  I think this parameter name could be nullValue.  Currently: 1;;20.7;6.75;9; 6.25 -> Second Value(not present) is null  In this issue, I would like to address the possibility to set an alternative to ""not present/null"" values  1;null;20.7;6.75;9; 6.25 here, if nullValue is set to ""null"", second value after parsing would be null 1;vacio;20.7;6.75;9; 6.25 here, if nullValue is set to ""vacio"", second value after parsing would be null 1;nill;20.7;6.75;9; 6.25 here, if nullValue is set to ""nill"", second value after parsing would be null  Then a test would look like this: ```java     @Test     void emptyValueIsAnEmptyWithCustomNullValueString() {         Stream arguments = provideArguments(',', """",""empty"", ""vacio , , empty , ''"");          assertThat(arguments).containsExactly(new String[] { ""vacio"", null, null, """" });     }     private Stream provideArguments(char delimiter, String emptyValue, String nullValue, String... value) {         CsvSource annotation = mock(CsvSource.class);         when(annotation.value()).thenReturn(value);         when(annotation.delimiter()).thenReturn(delimiter);         when(annotation.emptyValue()).thenReturn(emptyValue);         when(annotation.nullValue()).thenReturn(nullValue);          CsvArgumentsProvider provider = new CsvArgumentsProvider();         provider.accept(annotation);         return provider.provideArguments(null).map(Arguments::get);     } ```  It could be used like this:  ```java @CsvSource(value = {""null,null,null,null"", ""null,2,null,null"", ""1,null,null,null"", ""20,110,true,110"", ""20,110,false,20""}, nullValue = ""null"") ``` Parsed to: ```java null null null null  null 2 null null 1 null null null 20 110 true 110 20 110 false 20 ```  with the same meaning to:  ```java @CsvSource({"",,,"", "",2,,"", ""1,,,"", ""20,110,true,110"", ""20,110,false,20""}) ``` Parsed to: ```java null null null null  null 2 null null 1 null null null 20 110 true 110 20 110 false 20 ```  In case of having a custom nullValue configured. I think, in case of finding no value, should be returned null too. ```java @CsvSource(value = {"",,,"", ""null,2,null,null"", ""1,null,null,null"", ""20,110,true,110"", ""20,110,false,20""}, nullValue = ""null"") ``` Parsed to: ```java null null null null  null 2 null null 1 null null null 20 110 true 110 20 110 false 20 ``` ## Related issue https://github.com/junit-team/junit5/issues/1788","closed","theme: parameterized tests,","Ciruman","2019-04-10T06:31:56Z","2019-09-27T11:09:16Z"
"","1939","Run `jdeps --check` on all modules","## Description  Running `jdeps [...] --check org.junit.platform.commons` yields:  ``` org.junit.platform.commons (file:///Z:/junit10570588147507757156/lib/junit-platform-commons-1.5.0-SNAPSHOT.jar)   [Module descriptor]     requires mandated java.base;     requires java.compiler;     requires java.logging;     requires transitive org.apiguardian.api (@1.1.0);   [Suggested module descriptor for org.junit.platform.commons]     requires mandated java.base;     requires java.compiler;     requires java.logging;     requires transitive org.apiguardian.api;   [Transitive reduced graph for org.junit.platform.commons]     requires mandated java.base;     requires java.compiler;     requires java.logging;     requires transitive org.apiguardian.api;   [Unused qualified exports in org.junit.platform.commons]     exports org.junit.platform.commons.logging to org.junit.jupiter.migrationsupport,org.junit.jupiter.params,org.junit.platform.console,org.junit.platform.reporting,org.junit.platform.runner,org.junit.platform.suite.api     exports org.junit.platform.commons.util to org.junit.platform.suite.api ```  ### Analysis  - Directives actually compiled into the the module descriptor (`[Module descriptor]`) do match those listed below `[Suggested module descriptor for ]`. - Directives listed below `[Transitive reduced graph for ]` ignored here, as we should favor the explicite declaration of all required modules. - Directives listed below `[Unused qualified exports in ]` may be pruned from the module descriptor. Or they may stay for potential future-use.  ## Deliverables  - [ ] Add integration test checking all modules - [ ] Consult output and apply suggested directives when applicable","closed","status: stale,","sormuras","2019-06-27T19:11:24Z","2021-06-19T12:50:34Z"
"","1354","Make default test class name pattern more lenient","## Description  junit5 console application only accepts test classes with a _very specific naming convention_. (`*Test`, `*Tests`)  ## Issue  `java -jar junit-platform-console-standalone-1.0.0.jar --class-path . -c MenuTest` tests correctly with class:  ```java import static org.junit.jupiter.api.Assertions.assertEquals; import org.junit.jupiter.api.Test;  class MenuTest {  	@Test 	void testCreateMainWindow() { 		assertEquals(2, 1 + 3); 	} } ```  but does not find any tests with `java -jar junit-platform-console-standalone-1.0.0.jar --class-path . -c TestMenu` (ofc renaming class and file, re-saving and building the file)   Copied the jar into the same folder with the .java and .class files.  ## Expected  The naming of classes should not matter at all if I EXPLICITLY specify which classes contain tests. At least `Test*` should also be accepted with `--scan-class-path` (which it doesn't).  To resolve this cost me a lot of time btw. Stack overflow is full of helpless questions why the console doesn't find any tests.  ## Versions  downloaded `junit-platform-console-standalone-1.0.0.jar` from maven repo. compiled from source `junit-jupiter-api-5.2.0` and `junit-jupiter-engine-5.2.0` and used those to build the tests.","closed","theme: discovery,","CH4Code","2018-04-02T12:18:52Z","2018-04-06T11:49:55Z"
"","1879","Building JUnit 5 on JDK 13-ea fails","## Description  https://dev.azure.com/junit-team/junit5/_build/results?buildId=238 fails partially.  The underlying reason is that two integration tests in `platform-tooling-support-tests` do fail. Theses two tests try to build the following projects: - `gradle-missing-engine` - `gradle-starter`  ``` * What went wrong: Could not compile settings file '.../gradle-starter/settings.gradle'. > startup failed:   General error during semantic analysis: Unsupported class file major version 57    java.lang.IllegalArgumentException: Unsupported class file major version 57         at groovyjarjarasm.asm.ClassReader.(ClassReader.java:184)         at groovyjarjarasm.asm.ClassReader.(ClassReader.java:166)         at groovyjarjarasm.asm.ClassReader.(ClassReader.java:152)         at groovyjarjarasm.asm.ClassReader.(ClassReader.java:273)         at org.codehaus.groovy.ast.decompiled.AsmDecompiler.parseClass(AsmDecompiler.java:81) ... ```  Related commit: https://github.com/junit-team/junit5/commit/d611d0e7c8d46746ad9e4ae6acabfc15cad5a49b  Note: `gradle-kotlin-extensions` builds flawlessly.  ## Deliverables  - [x] Move from Gradle to Kotlin build scripts.","closed","3rd-party: Gradle,","sormuras","2019-05-14T02:01:04Z","2019-06-16T02:11:09Z"
"","1923","Use nohttp plugin in Gradle build","## Deliverables  - [x] Use the [nohttp](https://github.com/spring-io/nohttp) plugin in the JUnit 5 Gradle build.","closed","theme: build,","sbrannen","2019-06-11T10:04:42Z","2019-06-20T07:58:05Z"
"","1749","Merge milestone and RC release notes for 5.4","## Deliverables  - [x] Merge milestone and RC release notes for 5.4. - [x] Add special section for changes between RC2 and GA (if necessary).   - was not necessary - [x] Consider adding a note under ""general improvements"" highlighting improvements to the User Guide such as #1651 and #1723.   - opted instead to mention general improvements in the ""Scope"" of the release notes.","closed","theme: documentation,","sbrannen","2019-01-26T15:54:50Z","2019-02-04T18:55:12Z"
"","1541","Merge milestone and RC release notes for 5.3","## Deliverables  - [x] Merge milestone and RC release notes for 5.3. - [x] Add special section for changes between RC1 and GA.   - Alternatively, introduce a Wiki page for such purposes.","closed","theme: documentation,","sbrannen","2018-08-12T10:04:20Z","2018-09-03T15:03:52Z"
"","1384","Merge milestone and RC release notes for 5.2","## Deliverables  - [x] Merge milestone and RC release notes for 5.2.","closed","theme: documentation,","sbrannen","2018-04-23T12:01:10Z","2018-04-26T17:31:38Z"
"","1251","Merge milestone and RC release notes for 5.1","## Deliverables  - [x] Merge milestone and RC release notes for 5.1","closed","theme: documentation,","marcphilipp","2018-01-19T11:18:56Z","2018-04-23T12:00:07Z"
"","1076","Create releases/5.0.x branch","## Deliverables  - [x] Create releases/5.0.x branch starting from r5.0.0 tag - [x] Cherry-pick commits of all issues assigned to the 5.0.1 milestone","closed","type: task,","marcphilipp","2017-09-25T19:26:13Z","2017-09-25T20:05:39Z"
"","1240","Prepare 5.0.3 Release","## Deliverables  - [x] Cherry pick all commits from `master` that are now assigned to release 5.0.3. - [x] Create Release Notes for 5.0.3","closed","type: task,","marcphilipp","2018-01-14T08:50:34Z","2018-01-14T15:21:00Z"
"","1149","Cherry pick commits from 5.1 M1","## Deliverables  - [x] Cherry pick all commits from `master` that are now assigned to release 5.0.2.","closed","type: task,","sbrannen","2017-11-07T16:32:09Z","2017-11-11T12:20:50Z"
"","1287","Document composability of @Enabled*/@Disabled* annotations","## Deliverables  - [x] Add paragraph to JavaDoc for each `@Enabled*`/`@Disabled*` annotation explaining that only one such annotation will be discovered in the current release, etc. - [x] Add `NOTE` to User Guide for `@Enabled*`/`@Disabled*` annotations explaining that only one such annotation will be discovered in the current release, etc.","closed","component: Jupiter,","sbrannen","2018-02-06T14:46:12Z","2018-02-16T13:02:26Z"
"","1241","Prune Release Notes","## Deliverables  - [x] Add 5.0.3 release notes to `master` - [x] Update ""Date of Release"" in 5.0.3 release notes on `master` - [x] Prune all release notes sections prior to 5.0 GA","closed","type: task,","marcphilipp","2018-01-14T08:54:56Z","2018-01-19T14:27:42Z"
"","1753","Document fix for #1748 in Release Notes","## Deliverables  - [x]  Document fix for #1748 in the Release Notes.","closed","theme: documentation,","sbrannen","2019-01-27T15:09:51Z","2019-01-27T17:06:01Z"
"","1085","Merge 5.0.1 Release Notes into master when 5.0.1 is released","## Deliverables  - [ ] Merge 5.0.1 Release Notes into master when 5.0.1 is released","closed","theme: documentation,","marcphilipp","2017-09-29T20:39:40Z","2017-10-03T13:19:01Z"
"","1951","Compile and test on Java 12","## Compile and test with JDK 12  Follow-up from #775  - Java API and runtime target of all published JUnit 5 modules remains Java 8, using `--release 8`. - Java API and runtime target of Java 9 based MR-JARs remains Java 9, using `--release 9`. - Test source code may use Java 12 API.  ## Deliverables  - [x] Set minimal required Java feature version to `12` in `settings.gradle.kts` - [x] Set `testJavaVersion` in `JavaLibraryExtension` to `JavaVersion.VERSION_12` - [x] Update documentation in `README.md`, section _Building from Source_ - [x] Update `azure-pipelines.yml`, remove `11`-based jobs, promote existing `12` job - [x] Perform a _clean full build_ with verifying generated documentation, javadoc and User Guide.","closed","theme: modules,","sormuras","2019-07-09T16:18:35Z","2019-09-18T18:38:33Z"
"","1289","Cannot access `package-list` in published Javadoc","## Bug Report for JUnit 4  `javadoc -link http://junit.org/junit4/javadoc/latest` (i.e. referring JUnit 4's Javadoc pages from 3rd-party Javadoc pages) no longer works because http://junit.org/junit4/javadoc/latest/package-list disappeared.  ### Deliverables  - [x] See https://github.com/junit-team/junit5/issues/1289#issuecomment-364247470  ## Bug Report for JUnit 5  An upgrade in the JDK used to generate Javadoc for JUnit 5 caused the `package-list` file to stop being published beginning with JUnit 5.2.  In the following list, the first number is the HTTP response code.  - *200*: https://junit.org/junit5/docs/5.1.0/api/package-list - *404*: https://junit.org/junit5/docs/5.2.0/api/package-list - *404*: https://junit.org/junit5/docs/current/api/package-list  ### Deliverables  - [x] Manually copy `element-list` to `package-list` for previously released versions of JUnit 5. - [x] Automate copying of `element-list` to `package-list` in the Gradle build for future versions of JUnit 5.","closed","theme: web site,","KMGraf","2018-02-08T16:57:43Z","2020-04-29T02:27:17Z"
"","1320","Surefire provider reports @TestFactory method name with invocation index instead of display name","## Bug report The maven-surefire-plugin is able to run the JUnit 5 experimental dynamic tests but in the generate report *.xml file the test case names are not reflected.  ### Steps to reproduce - **pom.xml:** Add the required dependencies as per attachement: [pom.xml.txt](https://github.com/junit-team/junit5/files/1778698/pom.xml.txt) - Create a dynamic test as follows: ```java public class SampleDynamicTest {   @TestFactory   public Collection test_dynamic()   {     return Arrays.asList(                    dynamicTest(""DynamicTest_01"", () -> {System.out.println(""Dynamic Test 01 executed..."");}),           dynamicTest(""DynamicTest_02"", () -> {System.out.println(""Dynamic Test 02 executed..."");})         );   } } ``` - Compile the project using: **mvn clean test** - Check the surefire plugin output at: target/surefire-reports/TEST-my.pocs.junit5.SampleDynamicTest.xml - The dynamic test names are not as expected but uses the test factory method name i.e. test name appears as test_dynamic[1] instead of DynamicTest_01 and test_dynamic[2] instead of DynamicTest_02 [TEST-my.pocs.junit5.SampleDynamicTest.xml.txt](https://github.com/junit-team/junit5/files/1778706/TEST-my.pocs.junit5.SampleDynamicTest.xml.txt) - If you run the test from Eclipse IDE then the test names are as expected: ![dynamictestresults](https://user-images.githubusercontent.com/2289680/36948152-4a692530-1ffc-11e8-82a7-fe00238b1980.png)   ## Versions JUnit 5.1.0 JUnit Platform 1.1.0 Maven Surefire Plugin 2.19.1","closed","3rd-party: Maven Surefire,","ajeydudhe","2018-03-04T17:02:19Z","2020-01-01T06:02:26Z"
"","1322","Assertion invoked via reflection works abnormally in dynamic test","## Bug Report  Version: JUnit 5.1.0.  I want to implement a dynamic test where test cases are defined in a YAML file. Now I'm hitting a problem as the title.  Looking at my sample code:  ```java     @Test     public void t1() throws Exception {         java.lang.reflect.Method method = org.junit.jupiter.api.Assertions.class.getMethod(""assertEquals"", int.class, int.class);         method.invoke(null, 1, 5);     }          @TestFactory     Collection dynamicTests() {         DynamicTest[] list = new DynamicTest[1];         list[0] = DynamicTest.dynamicTest(""dt1"", new Executable() {             @Override             public void execute() throws Throwable {                 java.lang.reflect.Method method = org.junit.jupiter.api.Assertions.class.getMethod(""assertEquals"", int.class, int.class);                 method.invoke(null, 1, 50);             }         });         return Arrays.asList(list);     } ```  In the sample code, I defined a static test case t1 and a dynamic test caes dt1. In both tests, I just do a dynamic assert.  Looking at the test result, for the static test case t1, assert result is as expected:  ```   JUnit Jupiter:TestRunner:t1()     MethodSource [className = 'com.mycompany.test.TestRunner', methodName = 't1', methodParameterTypes = '']     => org.opentest4j.AssertionFailedError: expected: <1> but was: <5>        org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:52)        org.junit.jupiter.api.AssertEquals.failNotEqual (AssertEquals.java:197)        org.junit.jupiter.api.AssertEquals.assertEquals (AssertEquals.java:154)        org.junit.jupiter.api.AssertEquals.assertEquals (AssertEquals.java:149)        org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:305)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        com.mycompany.test.TestRunner.t1(TestRunner.java:82)        [...] ```  But for the dynamic test case dt1, assert result shows InvocationTargetException:   ```   JUnit Jupiter:TestRunner:dynamicTests():dt1     MethodSource [className = 'com.mycompany.test.TestRunner', methodName = 'dynamicTests', methodParameterTypes = '']     => java.lang.reflect.InvocationTargetException        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        com.mycompany.test.TestRunner$1.execute(TestRunner.java:96)        org.junit.jupiter.engine.descriptor.JupiterTestDescriptor. executeAndMaskThrowable (JupiterTestDescriptor.java:141)        org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor. execute(DynamicTestTestDescriptor.java:41)        org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor. execute(DynamicTestTestDescriptor.java:24)        org.junit.platform.engine.support.hierarchical. HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3 (HierarchicalTestExecutor.java:112)        org.junit.platform.engine.support.hierarchical.SingleTestExecutor. executeSafely(SingleTestExecutor.java:66)        [...] ```","closed","theme: dynamic tests,","evanchaoli","2018-03-06T01:51:10Z","2018-03-06T16:08:13Z"
"","1345","Annotation lookup on @Nested constructor parameter fails if test class is compiled with JDK 8","## Bug Report  Version: `junit-jupiter-api:5.1.0`  Given the following `Extension` which supports a custom `@Parameterized` annotation:  ```java public class TestExtension implements ParameterResolver {      @Override     public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {         return parameterContext.getParameter().isAnnotationPresent(Parameterized.class);     }      @Override     public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {         return new Object();     }      @Target(PARAMETER)     @Retention(RUNTIME)     public @interface Parameterized {     }  } ```  And the following usage of the extension, by annotating the constructor parameters:  ```java @ExtendWith(TestExtension.class) class ExampleTest {      private final Object bar;      ExampleTest(@TestExtension.Parameterized Object bar) {         this.bar = bar;     }      @Test     void parameter_annotation_in_root_class_does_not_throw() {         assertNotNull(this.bar);     }      @Nested     class NestedClass {         private final Object foo;          NestedClass(@TestExtension.Parameterized Object foo) {             this.foo = foo;         }          @Test         void parameter_annotation_in_nested_class_does_not_throw() {             assertNotNull(this.foo);         }     } } ```  Then when executing this class file, the test defined in `ExampleTest` will pass, but the test in `NestedClass` will fail with the following exception:    ``` /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -Dvisualvm.id=1767311736474 -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/opt/idea-IU-173.3727.127/lib/idea_rt.jar=33845:/opt/idea-IU-173.3727.127/bin -Dfile.encoding=UTF-8 -classpath /opt/idea-IU-173.3727.127/lib/idea_rt.jar:/opt/idea-IU-173.3727.127/plugins/junit/lib/junit-rt.jar:/opt/idea-IU-173.3727.127/plugins/junit/lib/junit5-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/tim/Projects/mockito/subprojects/junit-jupiter/out/test/classes:/home/tim/Projects/mockito/subprojects/junit-jupiter/out/production/classes:/home/tim/Projects/mockito/out/production/classes:/home/tim/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter-api/5.1.0/370218fbc7ce9cf0600c4b5db400bccdf0c01a48/junit-jupiter-api-5.1.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/2.9.0/5c5ae45b58f12023817abe492447cdc7912c1a2c/assertj-core-2.9.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.junit.platform/junit-platform-launcher/1.1.0/ba098edde4e59cacd9225e238ea3ad9c946684ab/junit-platform-launcher-1.1.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter-engine/5.1.0/c54b96b465bb5b49c7708d734a4180dd95422754/junit-jupiter-engine-5.1.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy/1.8.0/f7c50fcf1fab4fa3e148ecf6b329f01f733ed427/byte-buddy-1.8.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy-agent/1.8.0/feacb6818aaad11abc792a86a587e4ee5af3008c/byte-buddy-agent-1.8.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/2.6/639033469776fd37c08358c6b92a4761feb2af4b/objenesis-2.6.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.junit.platform/junit-platform-engine/1.1.0/2596bd4d909e7ea8d029272db4338075445d731b/junit-platform-engine-1.1.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.junit.platform/junit-platform-commons/1.1.0/d6aa21029f9cedfb4cc8a9e9efc0bd97987205b8/junit-platform-commons-1.1.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.apiguardian/apiguardian-api/1.0.0/3ef5276905e36f4d8055fe3cb0bdcc7503ffc85d/apiguardian-api-1.0.0.jar:/home/tim/.gradle/caches/modules-2/files-2.1/org.opentest4j/opentest4j/1.0.0/6f09c598e9ff64bf0ce2fa7e7de49a99ba83c0b4/opentest4j-1.0.0.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 -junit5 org.mockitousage.ExampleTest  org.junit.jupiter.api.extension.ParameterResolutionException: Failed to resolve parameter [java.lang.Object arg1] in executable [org.mockitousage.ExampleTest$NestedClass(org.mockitousage.ExampleTest,java.lang.Object)]  	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:221) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:174) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:82) 	at org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor.instantiateTestClass(NestedClassTestDescriptor.java:77) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.instantiateAndPostProcessTestInstance(ClassTestDescriptor.java:195) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$testInstanceProvider$0(ClassTestDescriptor.java:185) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$testInstanceProvider$1(ClassTestDescriptor.java:189) 	at java.util.Optional.orElseGet(Optional.java:267) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$testInstanceProvider$2(ClassTestDescriptor.java:188) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:81) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:58) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.prepare(HierarchicalTestExecutor.java:89) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:74) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120) 	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:65) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.ArrayIndexOutOfBoundsException: 1 	at java.lang.reflect.Parameter.getDeclaredAnnotations(Parameter.java:305) 	at java.lang.reflect.Parameter.declaredAnnotations(Parameter.java:342) 	at java.lang.reflect.Parameter.getAnnotation(Parameter.java:287) 	at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258) 	at org.mockito.junit.jupiter.TestExtension.supportsParameter(TestExtension.java:17) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$resolveParameter$0(ExecutableInvoker.java:185) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:174) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1380) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:186) 	... 66 more   Process finished with exit code 255 ```    As such, resolution of a parameter in constructor of a `@Nested` test class fails, while the same parameter resolved on the root class constructor works just fine.  I encountered this issue while testing out the capabilities of the `MockitoExtension` I was developing.  ## Deliverables  - [x] Introduce convenience methods for looking up annotations on parameters in `ParameterContext`. - [x] Document in User Guide. - [x] Document in Release Notes.","closed","component: Jupiter,","TimvdLippe","2018-03-27T11:50:47Z","2019-07-19T19:32:24Z"
"","1283","@ParameterizedTest times out unless @MethodSource factory has a side effect","## Bug Report  Using: JUnit 5.0.3  In https://github.com/GlowstoneMC/Glowstone/pull/842/files#diff-05705156f52e5f6dbc6cadca3fb637d1R31 the test suite begins reporting ""Killed"" on CircleCI if I remove the `System.err.println` call.  Maybe an ""optimization"" of side-effect-free `@MethodSource` methods is backfiring?","closed","component: Jupiter,","Pr0methean","2018-02-05T01:32:31Z","2018-02-07T09:53:09Z"
"","1496","Introduce displayName placeholder for @ParameterizedTest name","## Bug Report  Using:  ```xml 5.2.0 1.2.0 ```  Using `TestInfo.getDisplayName()` for regular tests yields the method name. Using `TestInfo.getDisplayName()`  on `@ParameterizedTest` yields the injected parameter which is not very distinctive / descriptive by itself.  Some kind of FQN for tests would be more useful especially for test NOT executed in an IDE where one has a hierarchical view which gives this information more context.  Example:  ```java package tests;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestInfo; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.EnumSource;  public class TestInfoTest {      private static enum TestEnum {         A, B, C;     }      private String testName = getClass().getSimpleName();      @BeforeEach     public void beforeEachTest(final TestInfo testInfo) {         testName = testInfo.getDisplayName();     }      @Test     public void foo() {         logTestName();     }      @Test     public void bar() {         logTestName();     }      @ParameterizedTest     @EnumSource(TestEnum.class)     public void foo(final TestEnum testEnum) {         logTestName();     }      @ParameterizedTest     @EnumSource(TestEnum.class)     public void bar(final TestEnum testEnum) {         logTestName();     }      private void logTestName() {         System.out.println(testName);     } } ```  Output: ``` bar() [1] A [2] B [3] C foo() [1] A [2] B [3] C ```  Expected Output:  ``` bar() bar() - A bar() - B bar() - C foo() foo() - A foo() - B foo() - C ```  Even better output:  ``` TestInfoTest.bar() TestInfoTest.bar(A) TestInfoTest.bar(B) TestInfoTest.bar(C) TestInfoTest.foo() TestInfoTest.foo(A) TestInfoTest.foo(B) TestInfoTest.foo(C) ```","closed","theme: parameterized tests,","ViToni","2018-07-11T12:50:49Z","2019-07-19T19:32:26Z"
"","1360","Surefire provider during integration tests gives SLF4J issues using Logback and REST Assured with Failsafe plugin","## Bug Report  Using:  - JUnit platform 1.1.0 - Jupiter engine 5.1.0 - surefire-provider 1.1.0 - failsafe-plugin 2.19.1 - JDK 8 Update 161  ## Issue  So a very specific combination of the failsafe plugin with the surefire provider and having a test using REST assured in combination with logback for logging purposes is not working. This same setup but with the surefire plugin is working, as seen in the example project below. When switching logback for SLF4J-simple, it seems to work again. It also works when just switching back to Junit 4.  For some reason SLF4J is also loading a `jdk14` library coming from the Maven plugins.  Error message:  ``` Running io.github.bonigarcia.PublicRestServicesIT SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/home/amohabir/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/home/amohabir/.m2/repository/org/slf4j/slf4j-jdk14/1.5.6/slf4j-jdk14-1.5.6.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder] Tests run: 2, Failures: 0, Errors: 2, Skipped: 0, Time elapsed: 1.122 sec <<< FAILURE! - in io.github.bonigarcia.PublicRestServicesIT testCountryService  Time elapsed: 1.107 sec  <<< ERROR! java.lang.NoSuchMethodError: org.slf4j.spi.LocationAwareLogger.log(Lorg/slf4j/Marker;Ljava/lang/String;ILjava/lang/String;Ljava/lang/Throwable;)V 	at io.github.bonigarcia.PublicRestServicesIT.testCountryService(PublicRestServicesIT.java:37)  testEchoService  Time elapsed: 0.013 sec  <<< ERROR! java.lang.NoSuchMethodError: org.slf4j.spi.LocationAwareLogger.log(Lorg/slf4j/Marker;Ljava/lang/String;ILjava/lang/String;Ljava/lang/Throwable;)V 	at io.github.bonigarcia.PublicRestServicesIT.testEchoService(PublicRestServicesIT.java:30)  ```  Code is based on: https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-rest-assured  ## Example Project  [junit5-rest-assured-example.zip](https://github.com/junit-team/junit5/files/1884057/junit5-rest-assured-example.zip)","closed","3rd-party: Maven Surefire,","amohabir","2018-04-06T13:13:10Z","2018-04-16T09:36:11Z"
"","1296","Null elements (excepts the first one) in @CsvSource are interpreted as empty elements","## Bug Report  Last null element in `@CsvSource` is interpreted as an empty element. The error arrived `junit-jupiter-params` with version `5.0.2`, just before (in versions 5.0.0 and 5.0.1) this error has not existed. To repeat the error you need one ""non null"" CSV-Line before (as a single ""null"" CSV-Line it works as designed).  This test runs under 5.0.1 but fails under 5.0.2 and later.  ```java     @ParameterizedTest     @CsvSource({         ""'', '', ''"", // empty Strings         "" , , ""       // null Strings     })     void nullsInCsvSource(String in01, String in02, String in03) {       if (in01 != null) {         assertNotNull(in01, ""in01"");         assertNotNull(in02, ""in02"");         assertNotNull(in03, ""in03"");       }       else {         assertNull(in01, ""in01"");         assertNull(in02, ""in02"");         assertNull(in03, ""in03"");       }     } ```","closed","component: Jupiter,","omints","2018-02-17T16:30:50Z","2018-02-26T19:03:18Z"
"","1781","Supply expected and actual values for failed boolean assertions","## Background  This issue was raised in the [Eclipse bug tracker](https://bugs.eclipse.org/bugs/show_bug.cgi?id=544491) by @noopur2507.  ## Status Quo  The `assertTrue()` and `assertFalse()` methods in `org.junit.jupiter.api.Assertions` do not supply the actual and expected boolean values to the `org.opentest4j.AssertionFailedError` constructor. This is inconsistent with other assertions and can cause problems for tools that rely on the presence of the actual and expected values -- such as Eclipse's support for displaying multiple failures in a pop-up window.  ## Deliverables  - [x] Ensure that appropriate `Boolean` values are supplied to the `AssertionFailedError` constructor for all `assertTrue()` and `assertFalse()` variants. - [x] Document in the Release Notes.","closed","component: Jupiter,","sbrannen","2019-02-16T13:50:11Z","2019-03-09T13:29:31Z"
"","1467","Support classpath resource for custom test source in dynamic tests","## Background  In conjunction with #1178, support was added for creating a `UriSource` from a `URI` supplied for a dynamic container or dynamic test.  In addition, the new `UriSource.from(URI)` static factory method currently supports creation of a `FileSource` or `DirectorySource` if the supplied `URI` represents a file or directory in the local filesystem. Otherwise, a `DefaultUriSource` is created by the factory.  ## Proposal  Introduce support for URIs that have a `classpath` scheme (e.g., `classpath:tests/script.js?line=23&column=42`). `UriSource.from(URI)` could then create a `ClasspathResourceSource`.  Note that `ClasspathResourceSource` does not implement `UriSource`; however, we could potentially refactor `ClasspathResourceSource` so that it implements `UriSource` where the implementation of `getUri()` would return the value returned by `ClasspathResourceSource.getClasspathResourceName()` prepended with `classpath:` (if not already present) and appended with the `FilePosition` converted to a proper query string (if the `FilePosition` is _present_).  ## Related Issues  - #1178   ## Deliverables  - [x] Add support for creating a `ClasspathResourceSource` for a dynamic test if the custom test source `URI` uses the `classpath` scheme.","closed","theme: dynamic tests,","sbrannen","2018-06-15T08:16:06Z","2018-07-06T16:06:43Z"
"","1850","Support MethodSource as custom test source in dynamic tests","## Background  #1467 and #1178 added support for dynamic containers and tests specifying a custom test source via `DynamicNode.getTestSourceUri()`.  These `URI`s can be used to link dynamic tests and containers with a `FileSource`, `DirectorySource` or `ClasspathResourceSource`.  These sources may optionally have an associated line and column number, which is indicated by using a query string in the `URI`, such as `line=23&column=12`.  ## Proposal  If a `URI` has a `classpath` scheme and a `method=myMethodName` query string then `TestFactoryTestDescriptor.fromUri(URI uri)` should create and return a `MethodSource`.  ## Use cases  I initially encountered this when using `@TestFactory` to run a test suite without switching engines. That's working (bar linking back to methods in test cases from the test tree in Eclipse), but it is not a compelling use case since suites are being addressed by #744.  However, I can envisage other cases where this would be useful, such as verifying consistent use of Hibernate annotations across Java beans. Previously I've written cumbersome custom PMD rules for this. Dynamic tests could link back to getters in the application source rather than unit tests.  ## Related issues  * #1467 * #1178  ## Deliverables  - ❌  Add support for creating a `MethodSource` for a dynamic test if the custom test source `URI` uses the `classpath` scheme and a `method=myMethodName` query string. - [x] Introduce support for converting from a URI of the form `method:` to a `MethodSource`, where FQMN is the fully qualified method name. See the Javadoc for [`DiscoverySelectors.selectMethod(String)`](https://junit.org/junit5/docs/current/api/org/junit/platform/engine/discovery/DiscoverySelectors.html#selectMethod(java.lang.String)) for the supported formats for a FQMN. - [x] Modify JavaDoc to explain supported `URI` schemas and query strings. - [x] ~Document in User Guide.~ will be addressed in #1903 - [x] Document in Release Notes.","closed","component: Jupiter,","magictractor","2019-04-08T09:40:13Z","2019-05-28T18:54:15Z"
"","1803","Print available ""junit-platform.properties"" with default values","# Print all available properties  The `ConsoleLauncher` should provide an option `--print-default-properties`. That would print all generic JUnit Platform-related and also all engine-specific options to stdout.  ## Sample output  ``` ## ## JUnit Platform ##  # Not applicable, yet.  ## ## JUnit Jupiter ##  # Description, Link to User Guider and/or Javadoc junit.jupiter.conditions.deactivate=... # ... junit.jupiter.execution.parallel.enabled=... junit.jupiter.execution.parallel.mode.default=... junit.jupiter.extensions.autodetection.enabled=... junit.jupiter.testinstance.lifecycle.default=...  ## ## JUnit Vintage ##   ...  ## ## More properties from other test engines ## ... ```","open","type: new feature,","sormuras","2019-03-08T13:04:01Z","2021-08-15T07:50:30Z"
"","1762","Enhance DynamicTest with enum-consuming stream factory","# Overview  Add `enum`-consuming stream factory to `DynamicTest` to simplify default checks for all (some by supplying a filter) constants declared within .  ```java   public static >   Stream stream(Class enumClass, Consumer consumer) {     return Stream.of(enumClass.getEnumConstants())         // .filter(...) ?         .map(constant-> dynamicTest(constant.name(), () -> consumer.accept(constant)));   } ```  ## Usage  ```java   @TestFactory   Stream state() {     return stream(Thread.State.class, state -> assertNotNull(state.name()));   } ```  ```java   @TestFactory   Stream unit() {     return stream(TimeUnit.class, this::assertUnit);   }      private void assertUnit(TimeUnit unit) {       // here be assertions...   } ```","closed","theme: dynamic tests,","sormuras","2019-02-05T05:15:34Z","2019-02-05T11:48:02Z"
"","1257","Introduce @EnabledIf execution condition","# Evaluate predicate to en- or disable test execution  Addresses #219  ## Examples  `JavaScript` examples  ```java @EnabledIf(""true"") @EnabledIf(""false"") @EnabledIf(""1 == 2"") @EnabledIf(""java.lang.Boolean.getBoolean('is-not-set')"") @EnabledIf(imports = ""java.nio.file"", value = ""Files.exists(Paths.get('dir', 'file.txt'))"") @EnabledIf(""java.lang.System.getProperty('os.name').toLowerCase().contains('win')"") @EnabledIf(""/64/.test(systemProperties.get('os.arch'))"") ```  More `Groovy`  ```java @Conditional(engine = ""groovy"", // Select Groovy as language. 	delimiter = ""\n"", // Set delimiter to Unix-style line separator. 	bindExtensionContext = false, // Not needed here. 	bindSystemProperties = false, // Not needed here, Groovy auto-imports ""java.lang.*"". 	value = { // 			""System.properties['jsr'] = '233'"", // 			""'233' == System.properties['jsr']"" }, // 	reason = ""Groovy as script language, multiple lines, self-fulfilling."") @Test void groovy() { 	assertEquals(""233"", System.getProperty(""jsr"")); } ```  ### Supported script languages  All JSR-223 ScriptEngine compatible languages, like:  - `javascript` http://openjdk.java.net/projects/nashorn/  ### Just mount the script engine at runtime...  - `groovy` http://docs.groovy-lang.org/latest/html/api/org/codehaus/groovy/jsr223/GroovyScriptEngineFactory.html - `bsh` http://beanshell.org  ### Other script languages  - `jshell` https://github.com/dmac100/JShellScriptEngine - `SpEL` https://jira.spring.io/browse/SPR-7651  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](http://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/meta/API.html) - [x] Change is documented in the [User Guide](http://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](http://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2018-01-22T20:18:15Z","2019-01-24T16:28:38Z"
"","1318","Dependency leak with maven-failsafe-plugin","# Bug report   ## Scenario  When running tests with `junit-platform-surefire-provider` under `maven-failsafe-plugin`, plugin dependencies pollute the test classpath.  This does not happen when running the same test under `maven-surefire-plugin`.  In particular, there is a dependency on `org.slf4j:slf4j-jdk14:jar:1.5.6` and `org.slf4j:jcl-over-slf4j:jar:1.5.6` which may cause `NoSuchMethodError` when the project is compiled with newer versions of these dependencies.  ## Reproduction steps  ```` git clone https://github.com/hwellmann/junit5-failsafe.git cd junit5-failsafe mvn verify  [INFO] --- maven-failsafe-plugin:2.19.1:integration-test (it) @ junit5-failsafe ---  -------------------------------------------------------  T E S T S ------------------------------------------------------- Running org.ops4j.junit5.FailsafeTest SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/home/hwellmann/.m2/repository/ch/qos/logback/logback-classic/1.0.7/logback-classic-1.0.7.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/home/hwellmann/.m2/repository/org/slf4j/slf4j-jdk14/1.5.6/slf4j-jdk14-1.5.6.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder] 19:09:54.084 [main] INFO  slf4j - logging from slf4j Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.128 sec <<< FAILURE! - in org.ops4j.junit5.FailsafeTest shouldLog  Time elapsed: 0.127 sec  <<< ERROR! java.lang.NoSuchMethodError: org.slf4j.spi.LocationAwareLogger.log(Lorg/slf4j/Marker;Ljava/lang/String;ILjava/lang/String;Ljava/lang/Throwable;)V         at org.ops4j.junit5.FailsafeTest.shouldLog(FailsafeTest.java:12) ````   ## Versions  JUnit 5.1.0 JUnit Platform 1.1.0 Maven Surefire and Failsafe Plugin 2.19.1","closed","3rd-party: Maven Surefire,","hwellmann","2018-03-03T18:30:59Z","2018-04-07T09:54:03Z"
"","1545","[Event] Add JUnit 5 event at JDD 2018","""Spock vs JUnit 5 - Clash of the Titans"" by Marcin Zajączkowski https://jdd.org.pl/lecture.html#id=47734","closed","","szpak","2018-08-14T12:54:04Z","2018-08-14T20:34:13Z"
"","1661","Separate issue templates","","closed","","marcphilipp","2018-11-01T18:49:46Z","2018-11-02T12:06:28Z"
"","1155","Use Spaces instead of Tabs","","closed","status: declined,","jaredsburrows","2017-11-12T18:46:57Z","2017-11-28T15:54:34Z"