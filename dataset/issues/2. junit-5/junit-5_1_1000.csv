"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","2526","Introduce SHORT_DISPLAY_NAME and LONG_DISPLAY_NAME in @ParameterizedTest","…rizedTest  ## Overview  By default, the display name of ```ParameterizedTest``` is similar to ```RepeatedTest#SHORT_DISPLAY_NAME```. If we want to make display name include ""method name"", we have to write string formate like ``` ""{displayName} - {arguments}""``` for all test cases. It seems to me ```RepeatedTest#LONG_DISPLAY_NAME``` is a good example and it would be better to introduce ```LONG_DISPLAY_NAME``` to ```ParameterizedTest```. The benefit is that junit 5 users can replace aforementioned string format by ""standard"" long display name.  Resolved #2525  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","chia7712","2021-01-13T09:55:08Z","2021-02-11T11:31:49Z"
"","2363","Update Asciidoctor instructions","…f the user guide  ## Overview  Hello! I was taking a look at this issue: https://github.com/junit-team/junit5/issues/2315 and I was trying to generate the pdf  version of the user guide. I had to look around a bit and noticed that the readme was missing information on generating the pdf  report. I am actually tacking the issue #2315 now but thought that it would be good to update the readme. Also some outdated stuff ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","halitanildonmez","2020-07-25T20:29:26Z","2020-07-26T15:04:49Z"
"","2696","Golden File Testing","Would be nice to make JUnit able to support **Golden File Testing**.   Golden File Testing is an excellent approach for testing huge output files, API responses... It's useful when, apart from testing all the logic of your program (this is done by unit testing itself), furthermore you also want to know that what you are outputting and giving to a client, downstream, whatever... it's fine and contains what it should. Maybe in that impasse of writing the data into a file, something is not working properly.  I thought that maybe it can be done by adding an optional when calling to JUnit like --accept in order to write the result of the test to the golden file and, when that option isn't set, execute normal golden test behavior.   I thought also about different solutions like doing a library apart from JUnit and then use the approach inside unit tests. But there's always the dependency with JUnit due to the acceptance parameter when we want the test to write into the golden file. For example, if this done through an annotation in each TestCase class, every time you want to accept the output and write it to the golden files, you will have to change each TestClass... And that is a bit painful if you have a huge project with a lot of test cases.  Some links about Golden File Testing: https://ro-che.info/articles/2017-12-04-golden-tests https://medium.com/@jarifibrahim/golden-files-why-you-should-use-them-47087ec994bf https://ieftimov.com/post/testing-in-go-golden-files/","closed","status: new,","quimpm","2021-08-20T08:43:00Z","2021-08-20T14:33:27Z"
"","2460","Reduce memory footprint","With these changes I was able to go from ~57160 to ~125205 dynamic tests with a `-Xmx64m` and the sample project provided by @ben-manes in #2450 without compromising any functionality.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-10-24T15:59:20Z","2021-01-08T19:49:26Z"
"","2334","Rename Alphanumeric Orderer to MethodName","With the introduction of `DisplayName` orderer in https://github.com/junit-team/junit5/commit/6fee44dc95b1cf49d85166d93a861ce0a9483d68, the name of the `Alphanumeric` orderer becomes ambiguous ie ""Alphanumeric of what?"". I believe then that `MethodName` would be a better name for that orderer. It is unambiguous, it clearly states what it is using for ordering the tests and it is consistent with the new orderer `DisplayName`.   ## Deliverables I guess since this has been published we would need to deprecate it add the renamed one as a delegator?  If it sounds good and the exact process of changing is clear or decided(deprecation? straight rename?) I would be happy to submit a PR for this.","closed","component: Jupiter,","gaganis","2020-06-20T20:50:42Z","2020-07-13T15:32:38Z"
"","2720","Deprecate `@UseTechnicalNames`","With the deprecation of the JUnitPlatform runner in favor of `@Suite` support (https://github.com/junit-team/junit5/commit/8ac3dfbc5fbef433a98684a4ca958fad91c1f0f4) `UseTechnicalNames` should also be deprecated.  In brief using `@UseTechnicalNames` would instruct the JUnitPlatform runner to use class and/or method names in JUnit4 test descriptions [using the information contained in the Junit5 TestIndentifiers](https://github.com/junit-team/junit5/blob/43638eb6a870e0d6c49224053dfeb39dcf0ef33f/junit-platform-runner/src/main/java/org/junit/platform/runner/JUnitPlatformTestTree.java#L111-L130).  Reasons for deprecation:  1. I do not see a usecase where other implementations that use the `junit-platform-suite-api` would benefit from UseTechnicalNames. 2. UseTechnicalNames is specific to to the Junit Platform runner and should not have been included in the suite-api. 3. The JUnit Platform Suite Engine provides `TestIndentifiers` as part of the JUnit Platform. Users of the JUnit Platform can reconstruct the technical names in the same way the JUnitPlatform runner did.","closed","theme: suites,","mpkorstanje","2021-09-16T16:24:30Z","2021-09-19T16:22:19Z"
"","2134","Ability to add @tags during runtime","With reference to this thread, https://github.com/junit-team/junit5-samples/issues/118#event-2883368068   It would be nice to have the ability to add tags during runtime (especially for Data-Driven Testing).   Use Case:  1. We are using different test data for a test case. We want to group all the positive test data as a smoke suite and add negative test data to the Regression suite.   Model Test Data:  ` {     ""testName"": ""Sample 1"",     ""tag"":""smoke"",     ""testData"":""TD""    },  {     ""testName"": ""Sample 2"",     ""tag"":""Regression"",     ""testData"":""TD12""    }`  Let me know if this is feasible!","closed","status: stale,","BChitrakannan","2019-12-18T09:28:00Z","2021-11-27T12:55:15Z"
"","2747","JUnit 5.8.0 tests does not get executed with spring boot 2.5.5","With JUnit 5.8.0, dependency test cases are not getting executed with Spring Boot 2.5.5. Test cases works well with previous version 5.7.2   ## Steps to reproduce  Below is the POM.xml   ```xml   	4.0.0 	 		org.springframework.boot 		spring-boot-starter-parent 		2.5.5 		  	 	com.example 	springboot-demo 	0.0.1-SNAPSHOT 	springboot-demo 	Demo project for Spring Boot 	 		11 	 	 		 			org.springframework.boot 			spring-boot-starter-web 		  		 			org.springframework.boot 			spring-boot-starter-test 			test 		 		 		 		    org.assertj 		    assertj-core 		    3.21.0 		    test 		 		 		 		    org.mockito 		    mockito-junit-jupiter 		    3.12.4 		    test 		 		 		 		    org.junit.jupiter 		    junit-jupiter-api 		    5.8.0 		  		 		 		    org.junit.jupiter 		    junit-jupiter-engine 		    5.8.0 		 		 		 		    junit 		    junit 		    4.13.2 		    test 		 		-->  	  	 		 			 				org.springframework.boot 				spring-boot-maven-plugin 			 		 	  ```  ## Context   - Used versions (Jupiter/Vintage/Platform):  - Build Tool/IDE: Maven, Eclipse IDE   ## Maven Output  ### Result with JUnit 5.8.0 dependency   ``` [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO]  [INFO] --- maven-jar-plugin:3.2.0:jar (default-jar) @ springboot-demo --- [INFO] Building jar: /Users/vinodkumar/Downloads/springboot-demo/target/springboot-demo-0.0.1-SNAPSHOT.jar [INFO]  ```  ### Results with JUnit 5.7.2 dependency   ``` [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running com.example.springbootdemo.SpringbootDemoApplicationTest [INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.03 s - in com.example.springbootdemo.SpringbootDemoApplicationTest [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO]  [INFO] --- maven-jar-plugin:3.2.0:jar (default-jar) @ springboot-demo --- [INFO] Building jar: /Users/vinodkumar/Downloads/springboot-demo/target/springboot-demo-0.0.1-SNAPSHOT.jar ```","closed","status: invalid,","vinodrkumars","2021-10-16T12:24:27Z","2021-10-17T10:17:58Z"
"","2830","Provide and document a way to execute tests conditionally for native images","With [Native Build Tools](https://github.com/graalvm/native-build-tools) supporting JUnit 5 testing of native images, there are more and more requests for being able to run or skip tests if running as native image or the other way around. Conceptually that seems close (but not equivalent) to existing [Java runtime environment conditions](https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution-jre).  In term of implementation, GraalVM `native-image` provides a simple and standardized way to check if the code is running or being compiled as a native image via the [`org.graalvm.nativeimage.imagecode` system property](https://github.com/oracle/graal/blob/master/sdk/src/org.graalvm.nativeimage/src/org/graalvm/nativeimage/ImageInfo.java). You can see [Spring Framework's `NativeDetector`](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/NativeDetector.java) for a concrete example and stable usage.  So I am wondering if such support could be provided by dedicated annotations like `@EnabledOnNative` and `@DisabledOnNative`.   If not possible, the more verbose `@EnabledIfSystemProperty(named = ""org.graalvm.nativeimage.imagecode"")` and `@DisabledIfSystemProperty(named = ""org.graalvm.nativeimage.imagecode"")` annotations could potentially be an option. If this is the way to support that use case, that could perhaps be documented in https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution.  This is a common use case and the system property alternative seems too verbose and not discoverable enough to me, so my preference is for `@EnabledOnNative` and `@DisabledOnNative`.","open","status: new,","sdeleuze","2022-02-15T17:32:11Z","2022-02-16T11:42:18Z"
"","2075","Fix using enforcedPlatform(""org.junit:junit-bom:5.6.0-M1"")","With 5.6.0-M1, using `enforcedPlatform(""org.junit:junit-bom:5.6.0-M1"")` in a project fails:  https://github.com/junit-team/junit5-samples/blob/master/junit5-multiple-engines/build.gradle.kts#L25  https://scans.gradle.com/s/ckk3szwlpvgvw  ## Deliverables  - [x] Check that `enforcedPlatform` works with 5.6.0-RC1","closed","theme: build,","marcphilipp","2019-10-21T20:00:11Z","2020-01-18T17:51:19Z"
"","2391","Let @Testable target any declaration element type","With #2168 being addressed in milestone 5.7 M1 by extending the set of allowed element types it is possible to also annotate field declarations in addition to classes and methods:   https://github.com/junit-team/junit5/blob/68bb2e3124da100ff00608c44fcd75dd3061f593/junit-platform-commons/src/main/java/org/junit/platform/commons/annotation/Testable.java#L73  Another use-case for `@Testable` are test modules:  ```java @Testable open module test.integration {   requires test.base; // read helper module   requires org.junit.jupiter; // read Jupiter API modules } ```  ```java module test.base {   exports test.base; // contains helpers } ```  With such an annotation attached to a module declaration, clients (like IDEs and build tools) may detect ahead of time if a module wants to be launched in a test run. Here, the `test.integration` module is annotated with `@Testable` which would yield a call like:  `junit --select-module test.integration`  In this example, the `test.base` module is not annotated with `@Testable` -- which would prevent a similar `junit` call for module `test.base`. If a client launched `junit` for `test.base`, no test containers nor tests would be found and executed:  ``` Test run finished after 1 ms [         0 containers found      ] [         0 containers skipped    ] [         0 containers started    ] [         0 containers aborted    ] [         0 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ] ```  Especially, if `--fail-if-no-tests` option is used, this may lead to surprising results.  ### Possible Solution  A forward-compatible solution is dropping the `@Target` annotation from `Testable`'s declaration. Due to...  > If an `@Target` meta-annotation is **not present** on an annotation type `T` , then an annotation of type `T` may be written as a modifier for any declaration except a type parameter declaration.  Copied from [Target](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/annotation/Target.html)'s API documentation. See also: https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.6.4.1","closed","theme: modules,","sormuras","2020-08-23T05:47:27Z","2020-12-18T09:20:27Z"
"","2869","Improve error message when FQMN in `@MethodSource` is invalid","With #1088 came support that `@MethodSource` to spec external Methods via FQMN.  It happened, that I did not carefully read the Javadoc:  > ... static factory methods in external classes referenced by fully qualified method name.  And so I put `@MethodSource(""org.junit.Foo.bar"")` on a `@Nested` test method  and consequently got this error:  ``` Could not find method [org.junit.Foo.bar] in class [org.junit.FooTest$NestedTest] ```  This needlessly lead me in the wrong direction of chasing down the cause for this until I ended up at #1088 which after reading caused me to realize that I was missing the `#`.  Hence I propose these improvements for the value(s):  **Syntactically validate it**  ATM it's possible to enter any string, and this causes always the same message:   > Could not find method [. asdjbh lkjahd jbh] in class [ ]  ideas:  - e.g. if it contains `.`, then it's an FQMN and the segment must be separated with `#` - proper FQCN if one can be extracted from the given string (in the above case the `@Nested` test class is reported which is impossible for FQMN) - report that finding in the error  **extend the jdoc to include an example**  ```java /**  * ... static factory methods in external classes referenced by fully qualified   * method name, e.g. {@code @MethodSource(""org.junit.Foo.#bar"")}  */ ```  found in v5.7.2","closed","theme: diagnostics,","elonderin","2022-03-28T12:05:51Z","2022-05-11T09:56:25Z"
"","2793","Why @MockBean Environment doesn't work in @WebMvcTest annotated controller class Junit 5","Why @MockBean Environment(Interface) doesn't work in @WebMvcTest annotated controller class Junit 5 However same thing is working fine in Service layer here service layer doesn't have @WebMvcTest annotation.  Is this a bug or i am missing something?  Jupiter Version : 5.8.1 Spring boot 2.3.4.RELEASE Java 8","closed","type: question,","arvindersinghchhabra","2021-12-12T10:16:39Z","2021-12-12T16:41:57Z"
"","2286","Improve documentation about @Execution and @ResourceLock","While working on an issue about parallel execution and for this I checked [synchronization docs](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution-synchronization) and was still unsure about **where** it is possible / needed / suggested to place the `@ResourceLock` and `@Execution(SAME_THREAD)` annotations. (_The current example only shows the test case, but it's also possible to place them at the annotations._)  @marcphilipp was so kind to answer this and I think the docs should be updated with these information, because I think they help for further understanding. So I quote his answers here:  > > 1. Annotation? What about repeatable - do they have to be at the singluar one or the plural ones? >  > If you use it as a meta-annotation on a `@Repeatable` annotation you should put it on both annotations due to the way annotation lookup works for repeatable annotations in `AnnotationSupport`.  >  > > 2. Extension implementation? What about parameter resolvers etc.? >  > Both annotations need to be present or meta-present on test methods or classes. Thus, putting them on the extension implementation class won't help.   > > 3. At test class level? What about inner classes? >  > Both annotations take effect for the whole subtree, i.e. putting `@ResourceLock(""foo"")` on a top-level test classes means all test methods in that class, all `@Nested` classes and their tests methods, recursively, require that resource. Similarly, `@ExecutionMode(SAME_THREAD)` forces the whole subtree to use the same thread.","closed","status: stale,","Bukama","2020-05-02T14:54:22Z","2021-10-10T18:12:05Z"
"","2172","Have @Tags take String[]","While there is great strength in that `@Tag` is `@Repeatable` and I'm grateful for that, I find it a bit unfortunate that `@Tags` is the containing annotation type for `@Tag`. I'd like the opportunity to write multiple tags in a single annotation in order to reduce some lines. And while it's of course possible to write `@Tags({@Tag(""a""), @Tag(""b""), @Tag(""c"")})` it looks messy and `@Tags({ ""a"" , ""b"", ""c"" })` would definitely be preferrable.  [Meta-annotations](https://junit.org/junit5/docs/current/user-guide/#writing-tests-meta-annotations) are neat when the tag values are _static_, but for instance if they are unique for each test (ticket ids, requirement ids and so forth) then that's not gonna work.  So, I'd like the `@Tags` type that exists now (i.e. the containing annotation of `@Tag`) to be named something else (`@TagContainer`?), and instead have `@Tags` taking an array of Strings. It seems natural/intutive to me and was certainly what I expected when I first saw the annotation. I realize that it would maybe lead to a kind of not so nice deprecation-scenario, but the question is how many people there are out there that actually use `@Tags` today, given that it's just a container type.","closed","status: waiting-for-interest,","mickeelm","2020-02-05T19:28:01Z","2020-02-07T14:24:46Z"
"","2438","junit-platform-commons 1.7.0 does not contain MANIFEST.MF as first JAR entry","While the JAR file specification doesn't mention this, the `java.util.jar.JarInputStream` implementation assumes that `META-INF/MANIFEST.MF` is the first or second entry in a jar file.  From the `JarInputStream` sources: > // This implementation assumes the META-INF/MANIFEST.MF entry > // should be either the first or the second entry (when preceded > // by the dir META-INF/). It skips the META-INF/ and then > // ""consumes"" the MANIFEST.MF to initialize the Manifest object.  Also the [Java Archive Tool Documentation](https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/jar.html) mentions:  > The jar tool automatically generates a manifest file entry named META-INF/MANIFEST.MF. It is always the first entry in the jar file.   Commit 5631ebc (#2217) introduced reproducible builds. Part of this is `java-repackage-jars` plugin, which sorts jar entries alphabetically. For junit-platform-commons, this results in the following first entries:  > META-INF/ > META-INF/LICENSE-notice.md > META-INF/LICENSE.md > META-INF/MANIFEST.MF  Evidently, this causes issues with any tools implemented using `JarInputStream`.  ## Steps to reproduce  - download [junit-platform-commons-1.7.0.jar](https://search.maven.org/remotecontent?filepath=org/junit/platform/junit-platform-commons/1.7.0/junit-platform-commons-1.7.0.jar) - `unzip -l junit-platform-commons-1.7.0.jar` (or list the file contents in another way)  Note: my real scenario involved [code in an Apache Sling module](https://github.com/apache/sling-org-apache-sling-installer-core/blob/master/src/main/java/org/apache/sling/installer/core/impl/Util.java#L74)  ## Desired outcome  It would be nice if `MANIFEST.MF` could be sorted to the top of the list for reproducible builds.","closed","theme: build,","jsedding","2020-10-03T20:23:53Z","2020-10-25T05:07:23Z"
"","2718","Local mocks ignored when PER_CLASS mode is used","When using the PER_CLASS mode, Mockito statements in local methods are ignored under certain conditions (see below).  I tested it with JUnit version 5.7.1 and Mockito 3.6.28; it seems, this problem already existed 2 years ago. It is also described here: https://stackoverflow.com/q/56438868/4311428  In the Stack Overflow answer the problem could not be recreated, because the mocked object was not declared as final in the tested class.  ## Steps to reproduce  ```java     package com.capgemini.cms.massmessagingservice.module.logic.impl.uc;      import static org.junit.jupiter.api.Assertions.assertEquals;     import static org.mockito.Mockito.when;     import static org.mockito.MockitoAnnotations.initMocks;      import org.junit.jupiter.api.BeforeEach;     import org.junit.jupiter.api.Test;     import org.junit.jupiter.api.TestInstance;     import org.junit.jupiter.api.TestInstance.Lifecycle;     import org.mockito.InjectMocks;     import org.mockito.Mock;      @TestInstance(Lifecycle.PER_CLASS)     public class NewTest {          @Mock         MyService service;          @InjectMocks         A a;          @BeforeEach         void setUp() {             initMocks(this);             when(service.getData()).thenReturn(25);         }          @Test // successful         void test1() {             assertEquals(""data: 25"", a.printer());         }          @Test // this test fails, method returns 25         void test2() {             when(service.getData()).thenReturn(19);             assertEquals(""data: 19"", a.printer());         }     }      interface MyService {          int getData();     }      class A {          /* This is important, if class variable is set to final the bug occurs,              if it is not set to final, everything works as expected; when using constructor injection,              those class variables are normally set to final */         final MyService service;          public A(MyService service) {             this.service = service;         }          String printer() {             return ""data: "" + service.getData();         }     } ```  We do not even have to use `@BeforeEach`, in the following example test2 will also fail, if it is executed after test1 (class A is the same as above):  ```java     @ExtendWith(MockitoExtension.class)     @TestInstance(Lifecycle.PER_CLASS)     public class NewTest {          @Mock         MyService service;          @InjectMocks         A a;          @Test // successful         void test1() {             when(service.getData()).thenReturn(25);             assertEquals(""data: 25"", a.printer());         }          @Test // fails         void test2() {             when(service.getData()).thenReturn(19);             assertEquals(""data: 19"", a.printer());         }     } ```  As described in the code comment, the bug only occurs, if the mocked variable is set to **final** in the tested class, which is normally the case in a constructor injection Spring setup. If we set it to non-final, everything works as expected.","closed","component: Jupiter,","Maxeh","2021-09-13T16:08:11Z","2021-09-14T10:40:04Z"
"","2971","Report NoClassDefFoundError during test discovery as test failure","When using the JUnit vintage engine in combination with Maven Surefire plugin it may happen that the test classpath is sometime incomplete. In our particular case some XML Unit classes were missing on the test classpath. A situation like this causes the Maven Surefire build to fail completely.  I think it would be better if the JUnit vintage engine instead catches a problem like this and reports it as a test failure instead of failing the Maven run.  For example, similar handling is done here: https://github.com/junit-team/junit5/blob/7416e56237d3eefc890d3b36164a1b4a22fd5941/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunnerExecutor.java#L50-L56   This is the stacktrace our Maven build is failing with: ``` Caused by: org.apache.maven.surefire.api.util.SurefireReflectionException: org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-vintage' failed to discover tests 	at org.apache.maven.surefire.api.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:173) 	at org.apache.maven.surefire.api.util.ReflectionUtils.invokeGetter(ReflectionUtils.java:76) 	at org.apache.maven.surefire.api.util.ReflectionUtils.invokeGetter(ReflectionUtils.java:70) 	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.getSuites(ProviderFactory.java:145) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.getSuitesIterator(ForkStarter.java:751) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.runSuitesForkOnceMultiple(ForkStarter.java:351) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:326) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:269) 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1332) 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1165) 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:929) 	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:140) 	... 11 common frames omitted Caused by: org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-vintage' failed to discover tests 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:160) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverSafely(EngineDiscoveryOrchestrator.java:134) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:80) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:110) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:78) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.discover(DefaultLauncherSession.java:81) 	at org.apache.maven.surefire.junitplatform.LazyLauncher.discover(LazyLauncher.java:48) 	at org.apache.maven.surefire.junitplatform.TestPlanScannerFilter.accept(TestPlanScannerFilter.java:56) 	at org.apache.maven.surefire.api.util.DefaultScanResult.applyFilter(DefaultScanResult.java:102) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.scanClasspath(JUnitPlatformProvider.java:167) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.getSuites(JUnitPlatformProvider.java:109) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.apache.maven.surefire.api.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:165) 	... 22 common frames omitted Caused by: java.lang.NoClassDefFoundError: org/custommonkey/xmlunit/DifferenceListener 	at java.base/java.lang.Class.getDeclaredMethods0(Native Method) 	at java.base/java.lang.Class.privateGetDeclaredMethods(Class.java:3166) 	at java.base/java.lang.Class.privateGetPublicMethods(Class.java:3191) 	at java.base/java.lang.Class.getMethods(Class.java:1904) 	at org.junit.platform.commons.util.ReflectionUtils.getDefaultMethods(ReflectionUtils.java:1518) 	at org.junit.platform.commons.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:1491) 	at org.junit.platform.commons.util.ReflectionUtils.findAllMethodsInHierarchy(ReflectionUtils.java:1433) 	at org.junit.platform.commons.util.ReflectionUtils.findMethods(ReflectionUtils.java:1417) 	at org.junit.platform.commons.util.ReflectionUtils.findMethods(ReflectionUtils.java:1403) 	at org.junit.vintage.engine.descriptor.TestSourceProvider.lambda$findMethod$1(TestSourceProvider.java:75) 	at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134) 	at java.base/java.util.Collections$SynchronizedMap.computeIfAbsent(Collections.java:2682) 	at org.junit.vintage.engine.descriptor.TestSourceProvider.findMethod(TestSourceProvider.java:75) 	at org.junit.vintage.engine.descriptor.TestSourceProvider.computeTestSource(TestSourceProvider.java:56) 	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) 	at org.junit.vintage.engine.descriptor.TestSourceProvider.findTestSource(TestSourceProvider.java:47) 	at org.junit.vintage.engine.discovery.RunnerTestDescriptorPostProcessor.addChildrenRecursively(RunnerTestDescriptorPostProcessor.java:62) 	at org.junit.vintage.engine.discovery.RunnerTestDescriptorPostProcessor.applyFiltersAndCreateDescendants(RunnerTestDescriptorPostProcessor.java:41) 	at org.junit.vintage.engine.discovery.VintageDiscoverer.discover(VintageDiscoverer.java:46) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:64) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:152) 	... 38 common frames omitted Caused by: java.lang.ClassNotFoundException: org.custommonkey.xmlunit.DifferenceListener 	at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:476) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:589) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) 	at org.apache.maven.surefire.booter.IsolatedClassLoader.loadClass(IsolatedClassLoader.java:100) 	... 59 common frames omitted ```","closed","3rd-party: Maven Surefire,","guw","2022-07-07T17:09:18Z","2022-07-08T14:27:12Z"
"","2147","Using JUnit 5 in modules production code broken since 5.5.0-RC1","When using JUnit in production code, for example, to provide a module with abstract test classes for contract tests, and the production code is using Java 9 modules, and the version of JUnit is JUnit 5.5.0-RC1, then there is a compilation issue.  Expected behavior: It is possible to create a production code module that `requires org.junit.jupiter.api` for test code reusable by other modules. This was possible until JUnit 5.5.0-M1.  Actual behavior: Since JUnit 5.5.0-RC1, this is no longer possible.  Minimal project structure to reproduce: ``` src/main/java/module-info.java src/main/java/com/example/AbstractTest.java src/test/java/com/example/ImplTest.java pom.xml ```  Source code of `src/main/java/module-info.java`: ``` module com.example {     requires org.junit.jupiter.api;     opens com.example; } ```  Source code of `src/main/java/com/example/AbstractTest.java`: ``` package com.example;  import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.fail;  public abstract class AbstractTest {     @Test     void test() {         fail(""bar"");     } } ```  Source code of `src/test/java/com/example/ImplTest.java`: ``` package com.example;  import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.fail;  abstract class AbstractTest {     @Test     void test() {         fail(""bar"");     } } ```  Versions of JUnit that work: All versions before and including 5.5.0-M1. Versions of JUnit that don't work: All versions from JUnit 5.5.0-RC1 on, including JUnit 5.6.0-RC1  JDK used: OpenJDK 13.0.1 Build tool used: Maven 3.6.3 with maven-compiler-plugin:3.8.1 and maven-surefire-plugin:3.0.0-M4.  IDE used: IntelliJ IDEA Ultimate 2019.3. Maven and IntelliJ IDEA show the same error message.  Suspected causes: * Possibility one: A change in the module configuration of JUnit has broken this use case. * Possibility two: A change in the module configuration of JUnit requires an update of the plugins in IntelliJ IDEA and Maven. * Possibility three: JUnit and the plugins are behaving correctly, and this use case must be achieved in a different way.  Error message in IntelliJ IDEA: ``` Exception in thread ""main"" java.lang.IllegalAccessError: class org.junit.platform.launcher.core.LauncherFactory (in unnamed module @0x4b9e13df) cannot access class org.junit.platform.commons.util.Preconditions (in module org.junit.platform.commons) because module org.junit.platform.commons does not export org.junit.platform.commons.util to unnamed module @0x4b9e13df 	at org.junit.platform.launcher.core.LauncherFactory.create(LauncherFactory.java:83) 	at org.junit.platform.launcher.core.LauncherFactory.create(LauncherFactory.java:67) 	at com.intellij.junit5.JUnit5IdeaTestRunner.createListeners(JUnit5IdeaTestRunner.java:46) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:31) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)  Process finished with exit code 1 ```  Error message in Maven: ``` [ERROR] There was an error in the forked processjava.lang.IllegalAccessError: class org.junit.platform.launcher.core.LauncherFactory (in unnamed module @0x27808f31) cannot access class org.junit.platform.commons.util.Preconditions (in module org.junit.platform.commons) because module org.junit.platform.commons does not export org.junit.platform.commons.util to unnamed module @0x27808f31 [ERROR] org.apache.maven.surefire.booter.SurefireBooterForkException: There was an error in the forked processjava.lang.IllegalAccessError: class org.junit.platform.launcher.core.LauncherFactory (in unnamed module @0x27808f31) cannot access class org.junit.platform.commons.util.Preconditions (in module org.junit.platform.commons) because module org.junit.platform.commons does not export org.junit.platform.commons.util to unnamed module @0x27808f31 [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:675) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:285) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:248) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1217) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1063) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:889) [ERROR]         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:210) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:156) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:148) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81) [ERROR]         at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128) [ERROR]         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305) [ERROR]         at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192) [ERROR]         at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105) [ERROR]         at org.apache.maven.cli.MavenCli.execute(MavenCli.java:957) [ERROR]         at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:289) [ERROR]         at org.apache.maven.cli.MavenCli.main(MavenCli.java:193) [ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) [ERROR]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [ERROR]         at java.base/java.lang.reflect.Method.invoke(Method.java:567) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:282) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:225) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:406) [ERROR]         at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:347) [ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) [ERROR]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [ERROR]         at java.base/java.lang.reflect.Method.invoke(Method.java:567) [ERROR]         at org.apache.maven.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:39) [ERROR]         at org.apache.maven.wrapper.WrapperExecutor.execute(WrapperExecutor.java:122) [ERROR]         at org.apache.maven.wrapper.MavenWrapperMain.main(MavenWrapperMain.java:61) [ERROR]   ```  ## Steps to reproduce  Create a project with the above structure and try to run the tests with IntelliJ IDEA or Maven. Alternatively, clone the repository given by the following URL: https://github.com/christianhujer/junit-bug-2147 and play around with it.  ## Context   - Used versions (Jupiter/Vintage/Platform): `org.junit.jupiter:junit-jupiter-api:5.5.0-M1` (works)  - Used versions (Jupiter/Vintage/Platform): `org.junit.jupiter:junit-jupiter-api:5.6.0-RC1` (fails)  - Build Tool/IDE: Maven 3.6.3 with maven-compiler-plugin:3.8.1 and maven-surefire-plugin:3.0.0-M4.  - Build Tool/IDE: IntelliJ IDEA Ultimate 2019.3  - Build Tool/IDE: OpenJDK 13.0.1","closed","3rd-party: IntelliJ IDEA,","christianhujer","2020-01-13T19:54:34Z","2021-05-15T10:55:48Z"
"","2196","Add support for printing test execution summary every X seconds","When using JUnit for integration test that can have hundreds of test with long runtimes, it will be helpful if we can configure the current execution summary (number of tests pending, executed, failed, succeeded) so far. Ideally it should be the similar nice looking summary that is printed by the ConsoleTestExecutor  That can help developers get to the failing unit tests earlier rather than having to wait for the final summary or dive through the logs to figure out what tests failed.  The frequency at which the summary so far is printed should be configurable via a property.","closed","component: Platform,","swaranga","2020-02-25T08:16:59Z","2020-05-22T19:55:52Z"
"","2126","Add support for fixed and random test delays during concurrent testing","When using JUnit 5 concurrent test functionality as a form of integration testing, I would like the ability to configure a random (with min/max bounds) or fixed delay between tests to simulate a more natural load. Currently I'm handling this with a `@BeforeEach` that calls a `Thread.sleep(...)` but would like to see configuration parameters to handle this natively.","closed","theme: concurrency,","dsbecker","2019-12-12T18:37:25Z","2019-12-20T08:17:20Z"
"","1970","@CsvFileSource cannot locate resource when used in base class","When using a relative resource path with `@CsvFileSource` — for example, `""test.csv""` as opposed to `""org/exmaple/test.csv""` — the resource is resolved against the runtime type of test class.  This is valid approach until we use inheritance.  If it happens that we have a base class test and subclass located in different packages then, the subclass test fails with cannot find resource. It runs normally if I copy the resource under same package as subclass. Obviously this is not an issue when using full path resources.    I think that when source file is resolved instead of using runtime class, the class that **declares** the method annotated with `@CsvFileSource` should be used.    ## Steps to reproduce  In order to reproduce we need 2 classes in different packages, let's assume base class Foo.  ```java package org.example.foo;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvFileSource;  public abstract class Foo {     @ParameterizedTest     @CsvFileSource(resources = ""testEquals.csv"",numLinesToSkip = 1)     public void testEquals( String a, String b ) {         Assertions.assertEquals(a,b);     } } ```  And then if we extend this class with Bar  ```java package org.example.bar;  import org.example.foo.Foo;  public class Bar extends Foo { } ```  Then the Bar test fails, while being unable to locate resource. However if we place class `Bar` in `org.example.foo` package everything works fine.  ## Context  The environment is jupiter-5.4 using gradle-5.4.1 with intelij idea 2019.2","closed","status: stale,","jbytecoder","2019-07-30T17:40:38Z","2021-06-19T12:50:06Z"
"","2218","Allow @TempDir to specify sub-directories","When using `@TempDir`, I often need to partition my temp directory into multiple sub-directories like ""input"", ""output"", ""errors"", "".camel"", etc.  So, would it be possible to add an attribute on `@TempDir` to specify sub-directories.  This would allow me to do something like:  ```java @Test public void test(@TempDir(""input"") Path input, @TempDir(""output"") Path output) { 	// test } ```  instead of:  ```java @Test public void test(@TempDir Path root) { 	Path input = Files.createDirectories(root.resolve(""input"")); 	Path output = Files.createDirectories(root.resolve(""output"")); 	// test } ```  WDYT?","closed","component: Jupiter,","kalgon","2020-03-19T07:45:39Z","2020-03-19T09:07:26Z"
"","2991","ClassNotFoundException: CleanupMode","When updating from 5.8.2 to 5.9.0, I get the following stack trace:  ``` Internal Error occurred. org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:160) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverSafely(EngineDiscoveryOrchestrator.java:134) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:80) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:110) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:57) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) 	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.lang.NoClassDefFoundError: org/junit/jupiter/api/io/CleanupMode 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:66) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:152) 	... 13 more Caused by: java.lang.ClassNotFoundException: org.junit.jupiter.api.io.CleanupMode 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) 	... 15 more ```  See https://github.com/t1/wunderbar/pull/217  As the class is clearly there, I have no idea what's happening. Other projects can update without a problem.  ## Steps to reproduce  Just checkout the PR and run the tests in the `wunderbar.junit` module from IntelliJ. Maven fails, too, but the error message is not very helpful: `TestEngine with ID 'junit-jupiter' failed to discover tests`  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.9.0  - Build Tool/IDE: Maven or IntelliJ IDEA  ## Deliverables  - [ ] ...","closed","status: waiting-for-feedback,","t1","2022-07-28T03:44:58Z","2022-07-28T16:34:35Z"
"","2137","Append module name to default display name of classes","When selecting multiple modules (e.g. via `--select-module a,b,c` within a console launcher run) users can't quickly infer from which module a test class (read: container) originates. By appending that information to the default display name its origin is presented in plain sight.  ### Example  Without module names:  ![image](https://user-images.githubusercontent.com/2319838/71246243-925c5a00-2316-11ea-8cd3-0322c45df64a.png)  With module name prepended: ![image](https://user-images.githubusercontent.com/2319838/71246299-abfda180-2316-11ea-97e5-570aa5ac644d.png)  Implementation: https://github.com/sormuras/junit5-looming/blob/master/src/test.base/test/java/test/base/PrependModuleName.java  ## Questions  - [ ] What about package names? - [ ] Is it better to generate logical nodes for container modules and packages -- like we do for classes and engines?","closed","theme: modules,","sormuras","2019-12-20T09:52:02Z","2020-07-24T10:42:44Z"
"","2698","Maven marks INFO log message as an ERROR","When running JUnit 5 tests via `mvn test` I get the following error:  ``` [ERROR] Aug 26, 2021 10:28:58 AM org.junit.platform.launcher.core.LauncherConfigurationParameters loadClasspathResource [ERROR] INFO: Loading JUnit Platform configuration parameters from classpath resource [file:/C:/Users/someUser/dev/projectDir/target/test-classes/junit-platform.properties]. ```  I have a `junit-platform.properties` in my resources directory and while the tests run just fine I get the error above.    Is this a real error or just the wrong log level being set by something?  ## Steps to reproduce  1.  Write tests 2. Use configuration pulled from `junit-platform.properties` 3. Run tests via `mvn test`  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.7.1  - Build Tool/IDE: Maven/Intellij","closed","3rd-party: Maven Surefire,","qwpnqjucz","2021-08-26T15:42:24Z","2021-08-26T15:48:19Z"
"","2664","Make mismatch reporting less noisy","When running individual test methods via Gradle in IntelliJ IDEA, JUnit logs INFO statements like the following to stderr:  ``` Jul 12, 2021 12:37:26 PM org.junit.platform.launcher.core.EngineDiscoveryOrchestrator lambda$logTestDescriptorExclusionReasons$7 INFO: 1 containers and 1 tests were Method or class mismatch ```  Since those appear in red, they are confusing and somewhat distracting.  ## Deliverables  - [x] Consider using a different log level to support this normal use case better","closed","3rd-party: IntelliJ IDEA,","marcphilipp","2021-07-12T11:00:00Z","2021-08-17T09:34:04Z"
"","2120","'mvn test' doesn't run tests with maven-surefire-plugin version 3.0.0-M4 when having cucumber 4.8.0 version","When my project pom contains below build configuration and parent pom has cucumber-4.8.0 version:                      org.apache.maven.plugins         maven-surefire-plugin         3.0.0-M4                 When I execute mvn test command it is not able to read runner.java class and it is also not able to read .features.  Always it returns: Running TestRunner Tests run: 0  ![image](https://user-images.githubusercontent.com/58452807/70018132-21454480-15ab-11ea-95b6-e1bd49e01239.png)","closed","","ramareddy88","2019-12-03T02:21:48Z","2021-11-18T14:10:30Z"
"","2159","Support disabling cleanup for @TempDir","When initially developing tests against legacy code that utilizes the filesystem extensively, I often find myself creating using `@TempDir`, which is fantastic. But oftentimes when debugging and/or initially writing the test I need to capture the outputs to get a ""golden file"" that I can regression test against on future runs. As such, currently I just use a non-TempDir folder to capture them, then need to update my test using TempDir later.  It would be super helpful if instead the TempDir annotation provided an option so that I could disable cleanup for a couple of runs then re-enable cleanup later in the development lifecycle. I'm envisioning something like the following  ```java @TempDir(cleanup=false) private Path outputFolder; ```","closed","component: Jupiter,","solter","2020-01-20T16:42:06Z","2022-06-14T10:03:32Z"
"","2284","Provide a less generic argument converter","When implementing an explicit converter via `SimpleArgumentConverter`, the signature of the `convert` method is the following: `Object convert(Object source, Class targetType)`. Some boilerplate code is then needed to check if the types of the source/target are supported.  I personally often use one converter per use case, i.e. to convert type X to type Y. Maybe we could implement a new argument converter that would take two types (one for the source and one for the target) and would do the checks for the user. The method to implement would then have a simpler signature.  ## Deliverables  - [x] An abstract converter like `TypedArgumentConverter` that would ensure that source is of type S and target of type T (Simple's already taken so... `SimplerArgumentConverter`? :P)","closed","theme: parameterized tests,","juliette-derancourt","2020-05-01T19:53:42Z","2021-08-10T17:14:48Z"
"","2330","Allow tests in local classes when using Test Kit","When I write tests using test kit, I usually have to create two tests. The actual tests and the test that is executed by the actual test. I build a few utils for myself to accommodate this pattern.  ```java @Test void actual_test() {   EngineExecutionResults results = JUnitTestKitUtil.runTest(getClass(), ""mock_test"");   results.testEvents().assertThatEvents().haveExactly(1, EventConditions.finishedWithFailure(       TestExecutionResultConditions.instanceOf(AssertionFailedError.class),       TestExecutionResultConditions.message(""EXPECTED""))); }  @MockTest void mock_test() {   Assertions.fail(""EXPECTED""); } ```  `JUnitTestKitUtil.runTest(…)` runs the given test using *Test Kit*. `@MockTest` adds a tag and ensures that the test is disabled if it is not executed using `JUnitTestKitUtil.runTest(…)`.  However, I think splitting the scenario (`mock_test`) and the assertions into two separate methods makes it more difficult to follow. Therefore, I would appreciate it if I could refactor the tests to use local classes.  ```java @Test void actual_test() {   final class Scenario {     @MockTest // Maybe I wouldn't even need to have this separate annotation anymore.     void mock_test() {       Assertions.fail(""EXPECTED"");     }   }    EngineExecutionResults results = JUnitTestKitUtil.runTest(Scenario.class);   results.testEvents().assertThatEvents().haveExactly(1, EventConditions.finishedWithFailure(       TestExecutionResultConditions.instanceOf(AssertionFailedError.class),       TestExecutionResultConditions.message(""EXPECTED""))); } ```  Unfortunately, `TestContainerResolver.resolveElement(AnnotatedElement,TestDescriptor)` filters any local classes by calling `isPotentialCandidate(clazz)`.  I would like to have an option to include such class in certain situations. I could imagine two way to enable the usage of such classes.  1. Add an option to allow the usage of local classes (and maybe other classes). 2. Accept such classes even when they don't qualify if thy where explicitly selected by a `ClassSelector` or `MethodSelector`.","closed","component: Test Kit,","JojOatXGME","2020-06-17T10:47:48Z","2020-06-19T14:52:53Z"
"","2988","Can't transform to a Result of type javax.xml.transform.stax.StAXResult","When I try to use the new Open Test report format of JUnit 5.9.0 this warning is displayed on console when starting tests:  > javax.xml.transform.TransformerException: Can't transform to a Result of type javax.xml.transform.stax.StAXResult > 	at org.apache.xalan.transformer.TransformerIdentityImpl.createResultContentHandler(TransformerIdentityImpl.java:302) > 	at org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:330) > 	at org.junit.platform.reporting.shadow.org.opentest4j.reporting.events.api.DefaultDocumentWriter.append(DefaultDocumentWriter.java:115)  The XML report file is created, but it does not contain anything in the events section.  I tried to reproduce it with the JUnit 5 sample project ""junit5-jupiter-starter-gradle"", but there it works as expected, meaning no warnings are printed to the console when starting the test and the created XML file contains entries in the events section.  I configured Open Test reporting it as it is described in the official guide.  Our project uses Gradle with multiple submodules and testFixtures, I am not sure if that is somehow related to the issue.  Am I doing anything wrong probably or is there maybe a bug existing?  This is the full stacktrace:  > createResultContentHandler:302, TransformerIdentityImpl (org.apache.xalan.transformer) > transform:330, TransformerIdentityImpl (org.apache.xalan.transformer) > append:115, DefaultDocumentWriter (org.junit.platform.reporting.shadow.org.opentest4j.reporting.events.api) > append:42, DefaultDocumentWriter (org.junit.platform.reporting.shadow.org.opentest4j.reporting.events.api) > reportInfrastructure:127, OpenTestReportGeneratingListener (org.junit.platform.reporting.open.xml) > testPlanExecutionStarted:114, OpenTestReportGeneratingListener (org.junit.platform.reporting.open.xml) > lambda$testPlanExecutionStarted$12:75, CompositeTestExecutionListener (org.junit.platform.launcher.core) > accept:-1, 1737729180 (org.junit.platform.launcher.core.CompositeTestExecutionListener$$Lambda$263) > lambda$notifyEach$19:95, CompositeTestExecutionListener (org.junit.platform.launcher.core) > accept:-1, 1212677653 (org.junit.platform.launcher.core.CompositeTestExecutionListener$$Lambda$265) > forEach:1259, ArrayList (java.util) > notifyEach:93, CompositeTestExecutionListener (org.junit.platform.launcher.core) > testPlanExecutionStarted:75, CompositeTestExecutionListener (org.junit.platform.launcher.core) > execute:89, EngineExecutionOrchestrator (org.junit.platform.launcher.core) > lambda$execute$0:55, EngineExecutionOrchestrator (org.junit.platform.launcher.core) > accept:-1, 1989509342 (org.junit.platform.launcher.core.EngineExecutionOrchestrator$$Lambda$256) > withInterceptedStreams:102, EngineExecutionOrchestrator (org.junit.platform.launcher.core) > execute:54, EngineExecutionOrchestrator (org.junit.platform.launcher.core) > execute:114, DefaultLauncher (org.junit.platform.launcher.core) > execute:86, DefaultLauncher (org.junit.platform.launcher.core) > execute:86, DefaultLauncherSession$DelegatingLauncher (org.junit.platform.launcher.core) > execute:53, SessionPerRequestLauncher (org.junit.platform.launcher.core) > processAllTestClasses:99, JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor (org.gradle.api.internal.tasks.testing.junitplatform) > access$000:79, JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor (org.gradle.api.internal.tasks.testing.junitplatform) > stop:75, JUnitPlatformTestClassProcessor (org.gradle.api.internal.tasks.testing.junitplatform) > stop:61, SuiteTestClassProcessor (org.gradle.api.internal.tasks.testing) > invoke0:-1, NativeMethodAccessorImpl (sun.reflect) > invoke:62, NativeMethodAccessorImpl (sun.reflect) > invoke:43, DelegatingMethodAccessorImpl (sun.reflect) > invoke:498, Method (java.lang.reflect) > dispatch:36, ReflectionDispatch (org.gradle.internal.dispatch) > dispatch:24, ReflectionDispatch (org.gradle.internal.dispatch) > dispatch:33, ContextClassLoaderDispatch (org.gradle.internal.dispatch) > invoke:94, ProxyDispatchAdapter$DispatchingInvocationHandler (org.gradle.internal.dispatch) > stop:-1, $Proxy19 (com.sun.proxy) > run:193, TestWorker$3 (org.gradle.api.internal.tasks.testing.worker) > executeAndMaintainThreadName:129, TestWorker (org.gradle.api.internal.tasks.testing.worker) > execute:100, TestWorker (org.gradle.api.internal.tasks.testing.worker) > execute:60, TestWorker (org.gradle.api.internal.tasks.testing.worker) > execute:56, ActionExecutionWorker (org.gradle.process.internal.worker.child) > call:133, SystemApplicationClassLoaderWorker (org.gradle.process.internal.worker.child) > call:71, SystemApplicationClassLoaderWorker (org.gradle.process.internal.worker.child) > run:69, GradleWorkerMain (worker.org.gradle.process.internal.worker) > main:74, GradleWorkerMain (worker.org.gradle.process.internal.worker)","open","status: new,","pandoras-toolbox","2022-07-27T12:01:11Z","2022-07-27T12:26:47Z"
"","2699","Allow `@Nested` test classes to be ordered","When having a `@TestMethodOrder` annotated class, I'd like to not only be able to annotate `@Test` methods, but also be able to define an order on `@Nested` inner classes. This is to avoid having to define an `@Order` on all the tests individually, which makes it harder to maintain.  For example:  ```java @TestMethodOrder(OrderAnnotation.class) class MyTests {    @Nested   @Order(1)   class MyFirstGroupOfTests {      @Test     void testA() {       ...     }      @Test     void testB() {       ...     }      @Test     void testC() {       ...     }   }    @Nested   @Order(2)   class MySecondGroupOfTests {      @Test     void testD() {       ...     }      @Test     void testE() {       ...     }      @Test     void testF() {       ...     }   }    @Nested   @Order(3)   class MyThirdGroupOfTests {      @Test     void testH() {       ...     }      @Test     void testI() {       ...     }      @Test     void testJ() {       ...     }   } } ```","closed","component: Jupiter,","mcanalesmayo","2021-08-27T01:22:37Z","2021-08-30T14:58:53Z"
"","2372","Combining Multiple Extensions into One","When developing a test library I am torn on the composition of extension. Users of the library should only need to list one extension but often that extension has multiple responsibilities that would otherwise be broken down into multiple classes.  For example, a library might perform different tasks as different stages in the life cycle as well support parameter injection for different types. It would be helpful if the library developer could implement multiple extensions, one per task/responsibility, and use a Junit natively supported way of combining those into a single extension for the user. This makes the extensions less complex, more testable, and eases maintenance because of the separation of responsibilities.  One solution could be to add a CompositeExtension class to Junit that handles multiple extensions in the same way that Junit would when multiple extensions are listed using `@ExtendWith`. Developers could extend CompositeExtension and implement some method `protected List getExtensions()` with all extensions that should be included. This gives test library developers the flexibility of small single purpose extension without expecting users to explicitly list them all.   ``` java public abstract class CompositeExtension implements  {      protected abstract List getExtensions();      @Override   public void afterEach(ExtensionContext context) throws Exception {     getExtensions().forEach(e -> e.afterEach(context));   }    // ... implement remaining methods in similar fashion } ```","closed","component: Jupiter,","ghunteranderson","2020-08-03T22:14:04Z","2020-08-05T15:42:57Z"
"","2500","ClasspathScanner.getRootUrisForPackage returns empty list when package name conflicts with module name","When developing a multi-module project that has similar package names it is possible that `getRootUrisForPackage` will fail to return a valid list.   ## Steps to reproduce  Project1.  ```java module io.litterat.pep { 	exports io.litterat.pep; 	exports io.litterat.pep.mapper; } ```  Project2.  ```java open module io.litterat.pep.test {         exports io.litterat.pep.test; 	requires io.litterat.pep; 	requires org.junit.jupiter.api; } ```  In eclipse (2020-09,2020-12 and other versions) when selecting the package `io.litterat.pep.test` no JUnit 5 tests are found or executed. In 2020-12 no errors or console output is shown.   The root cause is that `getRootUrisForPackage( ""io.litterat.pep.test"" )` results in calling `getClassLoader().getResources( ""io/litterat/pep/test"" )`. This results in calling `ClassLoaders$BootClassLoader findResources` which calls `Resources.toPackageName(""io/litterat/pep/test"" )` which results in package name `""io.litterat.pep""` (the name of the first module). The loader then resolves the name to the wrong `LoadedModule` which does not have the selected package. This results in no resources being returned.  Using Eclipse and attempting to execute all tests on either source directory or project results in all tests in the `io.litterat.pep.test` package being skipped. However, tests in sub-packages (e.g. `io.litterat.pep.test.extra`) are executed correctly.  Changing the name of the package so that the second project does not use the other module package as a base corrects the problem (e.g. `io.litterat.peptest`).  ## Context   - Used versions (Jupiter/Vintage/Platform): junit-platform-commons-1.7.0.jar  - Build Tool/IDE: Eclipse  ## Deliverables  It's not clear if this is a JDK bug or an issue with the way `getResources` is being called. Given that no output or feedback is provided this has taken quite a long time to figure out. Either issue should be documented or fixed.","closed","theme: discovery,","oobles","2020-12-20T11:26:21Z","2021-05-12T05:59:25Z"
"","2560","Test results for @Disabled @ParameterizedTest are not displayed correctly in IntelliJ","When combined with parameterized test annotations, the results are not displayed correctly. The expected `test_skip` is `@Disabled`, but is actually not reported.  ```java public class TestDisabled {  	@Disabled 	@ParameterizedTest 	@ValueSource(strings = {""test""}) 	void test_skip(Object test) { 		System.out.println(test); 	}  	@Disabled 	@Test 	void test_skip_test() { 		System.out.println(""test""); 	}  } ```","closed","","renyiwei-xinyi","2021-03-01T04:08:58Z","2021-03-05T11:33:41Z"
"","2757","Provide a MethodOrderer which enforces unique order values","When a test is annoated with `@TestMethodOrder( MethodOrderer.OrderAnnotation.class )` we want the test methods to executed in the order of the `@Order` annotation. When twei methods have the same order value the Javadoc states they ""will be sortedarbitrarily adjacent to each other"". That makes perfect sense.  Imagine this scenario: We have a tets class which contains 6 steps - each of them depends on its predecessor. Each of them is annotated by `@Order` with an incremented number. Later on we add  step between 2 and 3 and accidently copy the `@Order` annotation from another method.  This might lead to a flaky test as the same order value is used twice.  For sure this is the developer's mistake, but what about defining that each test method has to have an unique order value as we want to control the execution order deterministically?  We could have a special MethodOrderer for this purpose like `@TestMethodOrder( MethodOrderer.EnforcingOrderAnnotation.class )`  The whole test class failes if there are at least two methods with the same order value.","open","component: Jupiter,","OLibutzki","2021-10-27T15:49:04Z","2022-04-24T00:46:36Z"
"","2879","InvocationInterceptor Before/AfterEach methods should indicate which test method they apply to.","When a test fails due to something going wrong in a BeforeEach or AfterEach method, it is often useful to know which test they apply to for the purposes of generating reports or emitting metrics.  Currently, the API presents `getTarget() : Optional`  that may contain an instance of the test class, optional (from my understanding) because it will be empty when intercepting the test class constructor.  This would be an extension of that pattern.  ## Deliverables - `public Optional getTestMethod();` that returns the test method that applies to this invocation (or is empty if there isn't one).  This should only be empty for intercepted methods that apply to the whole test class.","closed","","scali-at-amazon","2022-04-08T01:37:49Z","2022-04-08T02:07:45Z"
"","2606","Failed to see parameter values on parametrized tests","What I'm looking for: displaying test parameters (the values, not the types) when looking at the list of exected tests. ![grafik](https://user-images.githubusercontent.com/11331611/116780562-dbc9c700-aa7d-11eb-9aa3-d6f1e53389e3.png)    * Using Windows 10  * Using Netbeans in version 12.2  * Using Java 11.0.11  * Using Maven in Version 3.6.3  * Using Junit 5 in version 5.8.0-M1 (api, engine and params as dependencies)  * Using Surefire in version 3.0.0-M5 (no configuration part in pom.xml)  ## Steps to reproduce  If you change the the ""6"" to a ""5"" in the test results you get following maven output (same also to my Netbeans IDE in the Junit Results Window):  ``` -------------------------------------------------------  T E S T S ------------------------------------------------------- Running magic.system.spline.matcher.ListMatcherTest Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.064 s <<< FAILURE! - in magic.system.spline.matcher.ListMatcherTest magic.system.spline.matcher.ListMatcherTest.testDemo(List, boolean)[2]  Time elapsed: 0.003 s  <<< FAILURE! org.opentest4j.AssertionFailedError: expected:  but was:  	at magic.system.spline.matcher.ListMatcherTest.testDemo(ListMatcherTest.java:110) ```  I invested now 2 hours without success to find out how I could manage to see the parameter values instead of the types (The types I can see in the method itself being completely useless in the output). From another issue somebody told you should have a look at following link: https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit-platform.html#Surefire_Extensions_and_Reports_Configuration_for_.40DisplayName  When I'm using this it does not change the effect but the normal method are not shown anymore. Instead you see ""null"".   So official documentation looks so simple but somehow I seem to miss an essential point. Btw. adding @DisplayName does not change anything (at least for me). The Named.of were also just a try because somebody told it would help but finally it did not make any difference.    The tests which should run fine (just simple demo code): ```     @ParameterizedTest(name = ""{index}: data={0}, expected:{1}"")     @MethodSource(""provideDemoTestData"")     public void testDemo(final List listData, final boolean bExpectedToFail) {         if (bExpectedToFail) {             assertFalse(listData.stream().allMatch(entry -> entry % 2 == 0));         } else {             assertTrue(listData.stream().allMatch(entry -> entry % 2 == 0));         }     }      private static Stream provideDemoTestData() {         return Stream.of(                 Arguments.of(                         Named.of(""data"", List.of(1, 3, 5)),                         Named.of(""expected to fail"", true)),                 Arguments.of(                         Named.of(""data"", List.of(2, 4, 6)),                         Named.of(""expected to fail"", false))         ); ```","closed","3rd-party: Maven Surefire,","Nachtfeuer","2021-05-01T11:05:36Z","2021-05-13T11:52:53Z"
"","2179","Latest weld-junit5 2.0.x doesn't work with junit api 5.6.0","weld-junit5 2.0.x won't work with latest junit-api 5.6.0  ## Steps to reproduce  put this on pom.xml  ```              org.junit.jupiter             junit-jupiter-api             5.6.0             test                               org.jboss.weld             weld-junit5             2.0.1.Final             test          ```  ## Context   - Used versions: Jupiter  - Build Tool/IDE: IntelliJ","closed","component: Jupiter,","fstarred","2020-02-11T11:34:46Z","2020-03-21T12:49:33Z"
"","2113","ThrowableCollector.toTestExecutionResult() is package private","We're in the process of trying to update the baseline version of Eclipse used in our `BundleEngine`. This has in turn updated the baseline version of JUnit 5 from an ancient version (5.0.0 of Jupiter and 1.0.1 of junit-platform) to something more recent.  Our `BundleEngine` used to make use of `SingleTestExecutor`, which is now deprecated. The deprecation note in `SingleTestExecutor` advises to use `ThrowableCollector.execute()` and `ThrowableCollector.toTestExecutionResult()` instead:  https://github.com/junit-team/junit5/blob/01e00d21016554dcdabd5a993a88a2f20cab6df9/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/SingleTestExecutor.java#L29-L30  However, `toTestExecutionResult()` is package private.  The code is simple enough that I can (and will) roll our own in `BundleEngine`. However, this is an annoyance and means it's not a 100% replacement for `SingleTestExecutor` (where this functionality was public).  ## Deliverables  Either: 1. make `toTestExecutionResult()` public, or 2. document a publicly-available alternative in the `SingleTestExecutor` deprecation note.","closed","component: Platform,","kriegfrj","2019-11-25T00:14:05Z","2019-12-17T08:49:35Z"
"","2298","stdout/stderr loss despite config options in JUnit Vintage test execution","We were using ant Junit4 task to run our tests and we migrated to Junit platform console launcher, but we are experiencing some stdout/stderr loss.  I added the proper configuration settings as advised in the documentation:  ```   ```   But there is still some stdout/stderr loss compared to our reports before the change. My initial assumption is that I do not have a proper test listener in place but isn’t the launcher having some default listener that receives the stdout/stderr? (we cannot use the ant junitlauncher as it does not support jacoco configuration)  What am I missing? Can I still use the launcher and get the generous stdout/stderr as in Junit4 ant task   Old ANT task:    ```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ```  New ANT task (using junit-platform-console-standalone-1.5.2.jar):  ```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ```   Sample output files:  Using the JunitPlatform with the proper config options in place (49,6 KB):  [TEST-JmsMessageIdFailoverTest-windows_JunitPlatform_stdout_stderr_options_added.txt](https://github.com/junit-team/junit5/files/4627014/TEST-JmsMessageIdFailoverTest-windows_JunitPlatform_stdout_stderr_options_added.txt)  Using the JunitPlatform without the proper config options (48,6 KB):  [TEST-JmsMessageIdFailoverTest-windows_JunitPlatform_no_sterr_stdout_options.txt](https://github.com/junit-team/junit5/files/4627016/TEST-JmsMessageIdFailoverTest-windows_JunitPlatform_no_sterr_stdout_options.txt)  Using old school junit4 ant task (378 KB):  [TEST-com.pcbsys.nirvana.nAdminAPI.cluster.failover.JmsMessageIdFailoverTest-windows_junit4_ant_task.txt](https://github.com/junit-team/junit5/files/4627015/TEST-com.pcbsys.nirvana.nAdminAPI.cluster.failover.JmsMessageIdFailoverTest-windows_junit4_ant_task.txt)","closed","status: stale,","Vazzilena","2020-05-14T08:39:19Z","2021-08-15T14:10:34Z"
"","2464","osgi: Use Bnd macro processing to avoid gradle afterEvaluate","We use late-binding to get the project description via Bnd's macro support instead of having to use afterEvaluate to early-bind to the project description in the gradle script.   (I forgot to include this change in the build updates for Bnd 5.2.0.)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---","closed","","bjhargrave","2020-10-26T21:50:14Z","2020-10-27T12:46:41Z"
"","2725","Separate the assertion utility API from the test framework API","We use exclusively Hamcrest assertions but occasionally someone will discover that JUnit has its own assertion library and put a call to that into the code.  While it is entirely possible to use tools like [Forbidden APIs](https://github.com/policeman-tools/forbidden-apis) to prevent this malpractice, it would be much simpler if JUnit simply had its assertions in a different library to the rest of the API.  It's fine for projects to like the JUnit style of assertions, and those projects can import that assertion library. But having it around on the classpath is damaging for the rest of us who have different preferences.","closed","component: Jupiter,","hakanai","2021-09-21T03:03:54Z","2021-11-04T02:54:31Z"
"","2362","Review experimental APIs and decide which to promote in 5.7","We should promote widely adopted APIs such as parameterized tests for 5.7.  See https://junit.org/junit5/docs/current/user-guide/#api-evolution-experimental-apis.","closed","component: Platform,","marcphilipp","2020-07-24T11:00:36Z","2020-08-01T12:50:13Z"
"","2385","Ask IntelliJ to support `@EnabledIf`/`@DisabledIf`","We should file an issue on [IntelliJ issue tracker](https://youtrack.jetbrains.com) to ask them to support the new `@EnabledIf`/`@DisabledIf` feature. I was testing those, and the condition methods used in the annotations are (rightfully) marked as unused, which is not ideal.  ## Deliverables  - [x] File the issue when JUnit Jupiter 5.7 is released","closed","3rd-party: IntelliJ IDEA,","juliette-derancourt","2020-08-17T11:04:56Z","2020-09-20T13:27:39Z"
"","2071","Revert build to use Java 11","We rely on tools such as Gradle, JaCoCo, Asciidoctor, and others and the past few months have shown that's it's unrealistic to expect all of them to be compatible with the latest JDK as soon as it's released. For example, we're currently stuck on JDK 12 because Asciidoctor does not yet support JDK 13. Since we don't want to compromise the safety of our contributors, we should not rely on outdated non-LTS releases. Instead, we now switch back the build to be compatible with the JDK 11 LTS release which will get security patches until JDK 17 is released.  Closes #2018. Closes #2061. Closes #1906.","closed","theme: build,","marcphilipp","2019-10-18T08:08:57Z","2019-10-18T08:50:14Z"
"","2142","Allow to run some tests isolated","We have one test that changes the global state, for example ```java @Test void localeTest() {   Locale.setDefault(Locale.FRENCH);   assertEquals(""Bunjour"", getMessage()); } ``` and hundreds of tests that reads the state: ```java @Test void someTest() {   assertEquals(""Hello"", getMessage()); } ```  After enabling parallel test execution our tests start to fail at random locations with messages like that: `[ERROR]   message 0 expected:<...Annotation.java:17: [Annotation 'AnnotationAnnotation' have incorrect indentation level 2, expected level should be 0].> but was:<...Annotation.java:17: [Die Annotation 'AnnotationAnnotation' hat eine unerwartete Einrückungstiefe von 2 (erwartet: 0)].>`  `@Execution(ExecutionMode.SAME_THREAD)` for the test `localeTest` won't help us, since the all other tests are able to run concurrent with every other test and with `localeTest` too.  This can be solved with `@ResourceLock`: ```java @Test @Execution(ExecutionMode.SAME_THREAD) @ResourceLock(value=""global"", mode=READ_WRITE) void localeTest() {   Locale.setDefault(Locale.FRENCH);   assertEquals(""Bunjour"", getMessage()); }  @Test @Execution(ExecutionMode.CONCURRENT) @ResourceLock(value=""global"", mode=READ) void test1() { }  // ...  @Test @Execution(ExecutionMode.CONCURRENT) @ResourceLock(value=""global"", mode=READ) void test100500() { } ```  but this is error prone, since adding a new Test without this annotation will produce a flaky tests which may fail.  It will be much better to mark some tests as ""incompatible with parallel execution at all"":  ```java @Test @Execution(ExecutionMode.ALONE) // no other this will be executed in parallel  void localeTest() {   Locale.setDefault(Locale.FRENCH);   assertEquals(""Bunjour"", getMessage()); } ```  As a workaround, it is possible to turn such a test into Junit 4 test, which will be executed in other universe, isolated from all other.","closed","component: Platform,","pbludov","2020-01-03T15:08:05Z","2020-08-15T14:47:34Z"
"","2713","Support for more specific and more general OS categories in DisabledOnOs/EnabledOnOs","We have many tests where we're doing this:  ```java assumeThat(OperatingSystem.getCurrent().isUnix(), is(true)); ```  Or,  ```java assumeThat(OperatingSystem.getCurrent().isLinux(), is(true)); ```  Or,  ```java assumeThat(OperatingSystem.getCurrent().isCentos(), is(true)); ```  Out of these three, one of the three can be replaced by `@EnabledOnOs`, but the other two cannot.  It would be nice if I could cover all UNIXy flavours with  ```java @EnabledOnOs(OS.UNIX) ```  and just one Linux distro with  ```java @EnabledOnOs(OS.CENTOS) ```  but obviously there are a ton of distros so that may not be the most suitable API. In the meantime I will probably leave these using `assumeThat` unless I make my own annotation.  I hit a similar thing with Mac classic vs. macOS or Windows vs. WindowsNT but I figured we won't be seeing classic or non-NT Windows anymore so I was happy to assume that all Windows is WindowsNT. ;)    ## Deliverables  - [ ] ...","open","component: Jupiter,","hakanai","2021-09-10T00:37:46Z","2021-11-01T09:11:46Z"
"","2343","Generate dynamic test nodes from Test Kit results","We have been using `EngineTestKit` to test our Jupiter extensions. I (along with others) have expressed our concerns about the clumsiness of using `Conditions` and `assertThatEvents()`, so we came up with a couple of alternative approaches.   For reference, please see https://github.com/osgi/osgi-test/blob/ce0638e30460f3a45af4ace1bf8132dc28ee6eb7/org.osgi.test.junit5/src/test/java/org/osgi/test/junit5/context/DynamicNodeGenerator.java and its calling context https://github.com/osgi/osgi-test/blob/ce0638e30460f3a45af4ace1bf8132dc28ee6eb7/org.osgi.test.junit5/src/test/java/org/osgi/test/junit5/context/BundleContextExtensionTest.java#L90-L159  In this strategy, we had a test class which we were using to drive the testkit, and all of the tests in the test kit were expected to pass (note that this strategy is not useful where you're testing some scenarios in which the tests are expected to fail). So we wrote some code to:  1. capture all of the test events from the testkit's execution run; 2. find the root TestDescriptor among the captured events; 3. traverse the captured test hierarchy and transform each `TestDescriptor` into a `DynamicContainer`/`DynamicTest` node as appropriate; *(this step provides some context to the request in #2305; see below)* 4. return the root dynamic node from a `@TestFactory` method.  I feel that this approach worked really well. It had a number of advantages:  1. The test output is more informative - you can see all the tests that testkit ran. 2. The output is more readable than asserting on events using conditions (assuming that you've used sensible names for the test classes and methods that you passed in to testkit). 3. If one of the tests fails, it will have an associated stack trace which is reported through the normal mechanisms. In most IDEs, this means that you can click on the stack trace in the test results window and be taken directly to the point in your code where the exception/assertion was generated, and start debugging straight away.  One disadvantage is that there is no direct mapping to `DynamicNode`s for `TestDescriptor`s that are both containers (ie, have their own children) and tests (ie, have their own execution result). This was the motivation for #2305. We got around this by creating `DynamicContainer` nodes and adding an extra `DynamicTest` to them to represent the execution resolve of the container itself: https://github.com/osgi/osgi-test/blob/ce0638e30460f3a45af4ace1bf8132dc28ee6eb7/org.osgi.test.junit5/src/test/java/org/osgi/test/junit5/context/DynamicNodeGenerator.java#L40  This technique will not be useful in all circumstances - for example, if you want to assert that certain tests have failed, or if you need to verify the correctness of the actual structure of the test hierarchy and not just the test results. However, there might be enough scenarios in which it could be useful that the JUnit team may wish to consider adapting it and transplanting it into the testkit implementation itself for others to use.","closed","component: Test Kit,","kriegfrj","2020-06-26T01:15:57Z","2020-06-26T10:51:19Z"
"","2837","Tests are silently skipped with Maven Surefire if @TempDir field is static final","We had some tests with a `static final` `@TempDir` fields which were silently being skipped, going unnoticed for some time (due to the large number of tests in the project, https://github.com/apache/accumulo). I now understand that it's best to keep `@TempDir` fields static and non-final.  ## Steps to reproduce  Here is an example test that illustrates the issue:  ```java public class TempdirTest {          @TempDir     private static final File tempDir = new File(System.getProperty(""user.dir""),""TempDir/"");      @Test     public void testTempDir() {         assertTrue(tempDir.isDirectory());     } } ```  When this test is run it gives the output:   `Tests run: 0, Failures: 0, Errors: 0, Skipped: 0`  It was just by chance that we noticed the tests were not being run and looked into it more.  ## Context   - For context, here is the PR that addresses the affected areas in our code: https://github.com/apache/accumulo/pull/2528   - Used versions (Jupiter/Vintage/Platform):     - junit-jupiter-api 5.8.2  - Build Tool/IDE:     - Apache Maven 3.6.3    - Java version: 11.0.13, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64    - OS name: ""linux"", version: ""5.15.23-76051523-generic"", arch: ""amd64"", family: ""unix""  ## Deliverables  - [ ] Make the tests fail when this happens","closed","3rd-party: Maven Surefire,","DomGarguilo","2022-02-28T21:03:17Z","2022-03-03T13:44:11Z"
"","2888","JUnit suite engine test class name pattern","We are using the JUnit suite engine feature to group a bunch of tests into a suite, with the `@Suite` annotation.  Currently, we have a bunch of tests with names ending with `TestIT`, e.g. `AddGlobalNumTestIT`.  It seems that these tests could not be identified due to the filter defined here:  https://github.com/junit-team/junit5/blob/43638eb6a870e0d6c49224053dfeb39dcf0ef33f/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassNameFilter.java#L41  We wonder if there is any way to do override this definition to avoid renaming our thousands of test files ending with ""TestIT"".  Thanks in advance!","closed","theme: suites,","wzrumich","2022-04-11T17:38:05Z","2022-04-11T18:07:41Z"
"","2440","Wrong encoding of standard output","We are using log4j 1.2 for loging purpose in out project. All output is produced in UTF-8. But when we executing our tests on Windows in junit 5 we have broken encoding in standard output and the junit 5 html report. It's seems junit converts stdout according to system encoding - when we change the file.encoding property (jvmArgs '-Dfile.encoding=UTF-8') all become ok. We need  some settings in junit to specify standard output encoding.","closed","component: Platform,","Romanzek","2020-10-05T16:15:46Z","2020-10-08T14:39:42Z"
"","1989","LegacyXmlReportGeneratingListener should create a Test-nnn.xml fiel for each class","We are migrating to JUnit 5 (from JUnit 4) and using the console launcher in combination with ant like described in https://github.com/junit-team/junit5-samples/blob/master/junit5-jupiter-starter-ant/build.xml  ```             ```  We cannot use junitlauncher-task because the output supports no @ParameterizedTest and so on.  After running the tests we generate a junitreport (with junitreport ant task) for the test run and a  unitth report (http://junitth.sourceforge.net/) for the last 100 test runs.  The problem is that the LegacyXmlReportGeneratingListener generates one BIG TEST-nnn.xml for a few hundred test cases. This results in a junitreport without any classes & packages. Just one big list of all tests. The ""OLD"" JUnit 4 Ant Task generated a TEST-nnn.xml for each test class. With this, junitreport & unitth can create readable reports. The report generated by LegacyXmlReportGeneratingListener is not readable and useless because it exists of one big ""TEST"" (it even looses the test class names).  ## Steps to reproduce  Run  ```  	 	   	 		 	 	  ```  with multiple test classes. You just get one big TEST-junit-jupiter.xml instead of a TEST-nnn.xml for each class.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.5.1  - Build Tool/IDE: Ant / ConsoleLauncher","open","theme: reporting,","mseele","2019-08-21T12:40:24Z","2022-07-07T13:32:14Z"
"","2062","@BeforeParameter/@AfterParameter  to do prameter level initialization","We are in a process of migrating our JUnit4 testcases to JUnit5. In JUnit4 all the tests in a class associated with one parameter in parameterized tests ran in one class. So It was possible to to use the constructor to do some initialization at each parameter level. But in JUnit5 each test case in a test class seems to be run on its own instance of the class. So we are no longer able to use the constructor to do parameter level initialization. Is there any plans of introducing any new feature/annotation to accomplish the same. Eg. code to demonstrate the required behavior in JUnit4      public ParameterizedCaseTest4(String a , String b)     {         System.out.println(""constructor"");         System.out.println(System.currentTimeMillis());     }      @Parameters     public static List testCases()     {         return Arrays.asList(new Object[][]                 {                         {""a"" , ""a""},//ID=1                         {""b"" , ""b""},//ID=1                         {""c"" , ""c""},//ID=2                 });     }       @BeforeClass     public static void init() throws Exception     {         System.out.println(""before all"");         System.out.println(System.currentTimeMillis());     }      @Test     public void test1() throws Exception     {         System.out.println(""test1 "" + expected2 + "" "" + expected);         System.out.println(System.currentTimeMillis());     }      @Test     public void test2() throws Exception     {         System.out.println(""test2"" + expected2 + "" "" + expected);         System.out.println(System.currentTimeMillis());     }      @AfterClass     public static void destroy() throws Exception     {         System.out.println(""after all"");         System.out.println(System.currentTimeMillis());     }","closed","theme: parameterized tests,","adiSuper94","2019-10-14T10:41:37Z","2019-10-14T11:11:52Z"
"","2337","Cannot use Type level and Method level DisabledIf** Annotations","Version: JUnit Jupiter 5.6.2  Issue: Unable to use both type level and method level versions of the `DisabledIfSystemProperty` annotation. I am able to stack them at the same level, but when annotations are at different targets then only the first target is evaluated (in my case this is `ElementType.TYPE`).  Sample code:  ```java @DisabledIfSystemProperty(named = ""FOO"", matches = ""foo"") public class TestSometing{      @Test     @DisabledIfSystemProperty(named = ""BAR"", matches = ""bar"")     public void test_something() {         assert true;     } } ```","closed","component: Jupiter,","st0ve","2020-06-23T00:08:07Z","2020-06-24T06:00:16Z"
"","2731","Fix seed property name documentation for ClassOrderer.Random","Version: JUnit 5.8.1  In the class description, the `ClassOrderer.Random` documentation states that the ""junit.jupiter.execution.class.order.random.seed"" configuration parameter should be used to set the custom seed.   The actual value of `RANDOM_SEED_PROPERTY_NAME` is equal to `MethodOrderer.Random.RANDOM_SEED_PROPERTY_NAME` however, which is `junit.jupiter.execution.order.random.seed`. This is documented correctly in the field description.  ## Deliverables  - [x] Change `junit.jupiter.execution.class.order.random.seed` in class description to `junit.jupiter.execution.order.random.seed`.","closed","component: Jupiter,","bnorb","2021-09-29T01:06:47Z","2021-10-02T13:47:51Z"
"","2592","@Order annotation is ignored by Maven but honored in IntelliJ IDEA","Version: 5.7.1  ```xml                      org.junit.jupiter             junit-jupiter-engine             5.7.1          ```  ## Steps to reproduce Create a test class: ```java import org.junit.jupiter.api.MethodOrderer; import org.junit.jupiter.api.Order; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestMethodOrder;  @TestMethodOrder(MethodOrderer.OrderAnnotation.class) public class OrderingTest {      @Test     @Order(2)     public void testIGoNext() {         System.out.println(""Test #2"");     }      @Test     @Order(3)     public void testMeIsTheMiddle() {         System.out.println(""Test #3"");     }      @Test     @Order(1)     public void testRunMeFirst() {         System.out.println(""Test #1"");     }      @Test     @Order(4)     public void testSecondToLast() {         System.out.println(""Test #4"");     }      @Test     @Order(5)     public void testTrailing() {         System.out.println(""Test #5"");     } } ```   ## Context  - Used versions (Jupiter/Vintage/Platform): Jupiter Engine 5.7.1  - Build Tool/IDE: IntelliJ IDEA 2020.3.3 / 2021.1  # Description If this code is executed from within IDEA (right click -> Debug), then the execution order is OK. ![image](https://user-images.githubusercontent.com/82228714/114272719-91719f00-9a17-11eb-87f5-00c5d8f480e7.png)  If however, a maven build is triggered, then the execution order is ignored. An arbitrary order seems to be used: ![image](https://user-images.githubusercontent.com/82228714/114272852-1066d780-9a18-11eb-81bb-2c7ee288bac3.png)","closed","3rd-party: Maven Surefire,","mitch-haraldsson","2021-04-10T14:17:54Z","2021-04-12T18:27:31Z"
"","2942","The thread context classloader is not reset between tests","version junit 5.8.2  ## Steps to reproduce  If a test that passes leaves the thread context classloader set, it may break a subsequent test, which itself passes if run by itself.   For example:  ```java public class ContextClassLoaderTest {     static final ClassLoader LingeringLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader());      @Test     public void testA()     {         assertThat(Thread.currentThread().getContextClassLoader(), not(sameInstance(LingeringLoader)));         Thread.currentThread().setContextClassLoader(LingeringLoader);     }      @Test void testB()     {         assertThat(Thread.currentThread().getContextClassLoader(), not(sameInstance(LingeringLoader)));         Thread.currentThread().setContextClassLoader(LingeringLoader);     } } ```  Both `testA` and `testB` pass if run by themselves, but if run together, then the second always fails.  I tried a similar test with the thread interrupted status and noted that we reset between test runs, so I think the thread context loader should also be reset.        ## Context  Failures seen in:  -- maven command line  -- Intellij IDE","closed","component: Platform,","gregw","2022-06-09T23:50:26Z","2022-06-11T14:06:19Z"
"","2529","Junit 4.13.1 version can't be parsed by JUnit4VersionCheck","Using cucumber 6.9.1 which brings junit 4.13.1 and  junit-vintage-engine 5.7.0 at some point there is a check for junit version and the JUnit4VersionCheck class can't handle x.y.z format, just x.y  I'm having this exception:  > Caused by: org.junit.platform.commons.JUnitException: Failed to parse version of junit:junit: 4.13.1 > 	at org.junit.vintage.engine.JUnit4VersionCheck.parseVersion(JUnit4VersionCheck.java:54) > 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:37) > 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:32) > 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:62) > 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:181)","closed","component: Vintage,","david-m-s","2021-01-14T08:54:49Z","2021-01-14T14:18:02Z"
"","2524","Stack trace is printed when test is aborted with TestAbortedException","Using 5.7.0  ```kotlin class AbortedTests {     @TestFactory fun test1() = DynamicTest.dynamicTest(""skip"") {         throw TestAbortedException(""abort in testfactory"")     }      @Test     fun test2() {         throw TestAbortedException(""abort in plain test"")     } } ```  Prints on the console  ``` org.opentest4j.TestAbortedException: abort in testfactory 	at dev.minutest.junit.experimental.AbortedTests$test1$1.execute(KotlinTestTests.kt:37)         ....  org.opentest4j.TestAbortedException: abort in plain test 	at dev.minutest.junit.experimental.AbortedTests.test2(KotlinTestTests.kt:42) 	.... ```  The recommended way of skipping a dynamic test is to throw the exception https://github.com/junit-team/junit5/issues/1439 but then the console prints the stack trace, making people think that something is wrong.","closed","","dmcg","2021-01-11T20:42:23Z","2021-01-11T21:26:23Z"
"","2629","Stop using custom Docker image","Use download-java and setup-java actions instead.","closed","","marcphilipp","2021-05-28T08:29:07Z","2021-05-28T08:38:32Z"
"","2249","Detecting cycles in inner class hierarchies throws exceptions even for classes not marked as @Nested","Upgrading to JUnit 5.6 is breaking a unit test I have.  ```java private class MySillyClosure(...) extends Closure(...) {      @override     RetryStrategy call(...) { return MyStrategy() }  } ```  This class is defined in my test suite and the recursive check fails even though I have not marked any of these classes as `@Nested`.  I think this is the suspect code:  https://github.com/junit-team/junit5/blob/master/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java#L46  https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java#L1007-L1008  Notice that the code looks for all nested classes (and asserts on finding a cycle) before attempting to filter out using the predicate for `@Nested`. Therefore any class that has this inner inheritance (in my case Groovy `Closure` and `WriteableClosure`) is causing an error even if they are not marked as `@Nested`.  For reference, here is the closure code and its inner class:  https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/Closure.java#L847  Is there a way for me to disable this recursion check?","closed","component: Platform,","chavan77me","2020-04-07T12:47:39Z","2020-04-09T17:16:34Z"
"","2419","Introduce configuration to disable all outbound network connections","Unit tests should not make outbound network requests, but it can be difficult to remember all of the ways code might be depending on external systems when someone is writing tests for it. Especially if there is per-developer setup that makes the tests work with the author, but not other consumers.  A straightforward configuration to disable network connections would ensure that unit tests enforce a 'no access to external dependencies' policy which would help make the tests more reliable and portable.  I recognize that this may not be the right place for such configuration, but I feel a standardized JUnit setting would be the most accessible and intuitive place to put it for most developers who are otherwise not super familiar with the nuances of network configuration.","closed","","sudo-chill","2020-09-22T19:15:50Z","2021-05-13T12:00:07Z"
"","2169","JUnit Jupiter 5.6.0 tests do not run with Maven Surefire and IntelliJ IDEA","Trying to upgrade JUnit Jupiter from 5.5.2( where everything is running fine) to 5.6.0 for Java (Spring Boot) project. Both Maven Surefire plugin (v 2.22.2) and IntelliJ IDEA (Ultimate v 2019.3) doesn't detect or run the tests  ## Steps to reproduce  Sample Code  ```java import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test;  public class SampleTest {      @Test public void testSample(){         Assertions.assertEquals(4/2, 2);     } }  ```  ## Context   - Used versions : Jupiter v5.6.0  - Build Tool/IDE: maven surefire plugin v2.22.2 and Intellij IDEA Ultimate 2019.3","closed","type: question,","prasadthotakura","2020-01-30T15:33:37Z","2020-03-26T12:51:04Z"
"","2070","Run Gradle with --parallel in GitHub Actions","Trying to speed-up GitHub Actions builds.","closed","theme: build,","marcphilipp","2019-10-18T06:39:11Z","2019-10-18T10:35:07Z"
"","2145","@Ignore'd Parameterized JUnit 4 test class with VintageTestEngine","Trying to migrate our Tests from JUnit4 to Jupiter I thought I could as a first step simply eliminate the explicit JUnit4-dependency by substituting it with the junit-jupiter-migrationsupport library (version 5.5.2). This would allow us to rewrite the tests little by little. Unfortunately we have some rather ill performing parameterized tests, which we ignore every now and then, as it comes. And here I observed the following behaviour:  When executing a parameterized JUnit4 test with maven (version 3.6.3, surefire plugin version 3.0.0-M4), the static ""parameters"" method is executed twice. The ""test"" method itself ist then executed once. Moreover, when ignoring the test either at class or at method level, the ""parameters""-method is still executed (only the test method iteself is skipped)  ## Steps to reproduce I have put some simple unit tests here: https://github.com/gabalawi/junit5-migration  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.5.2  - Build Tool/IDE: Maven 3.6.3  ## Deliverables see github link above","closed","component: Vintage,","ghost","2020-01-08T12:20:02Z","2020-01-18T17:56:36Z"
"","1982","Getting the invocation index of current parameterized test run","Trying to get the index of the current invocation count of a ParameterizedTest, the same value that can be used when declaring a custom name, i.e. `@ParameterizedTest(name = ""{index}"")` but through a parameter.  TestInfo does not provide that information, only the method name, and I would rather not try to extract this value from the method name string.  Is there any other way this index can be retrieved?  I need this to have a certain piece of test method execute only once. For example creating the data for the test. I thought about moving this logic out to the method source, but I would rather avoid doing that if I can because otherwise the test method will be cluttered with the parameters that I will have to pass from the method source.","closed","","serpro69","2019-08-14T07:47:09Z","2019-08-14T07:51:45Z"
"","1985","Disable test after executing @BeforeEach","Try implement a ConditionExtension which evaluate a condition after beforeeach.   Any idea how to do this?  Some short example code  ```java public class Tests {   public string FooBar = null;      @BeforeEach    public void before(){      FooBar = ""test"";    }     @Test    @DisableIfFooIsSet    public void test(){      fail()    } } ```","closed","component: Jupiter,","farodin91","2019-08-17T21:25:56Z","2019-08-19T13:31:38Z"
"","2769","Use value references in Javadoc to eliminate duplication","Triggered by discussion in fd93eeca94479b71ce0d06d61df874a167a3fbf7.","closed","theme: documentation,","marcphilipp","2021-11-02T19:53:29Z","2022-03-06T16:01:02Z"
"","2194","Don't cache URL when loading `junit-platform.properties` contents","Today, the code in the launcher uses the convenient input stream accessor `openStream()` provided by the `URL` class:  https://github.com/junit-team/junit5/blob/efdb9fde6ca9fbc8b6795d5438c604aadd802e57/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfigurationParameters.java#L66-L68  This implicitly caches an underlying JAR file for the current VM, if the `junit-platform.properties` file is located in a JAR file. On Windows, that means a lock is held by the VM until its associated reference is garbage collected.  When, for example, testing the launcher framework within a test method that prepares a custom class-path or module-path with generated JAR files in a temporary directory, that temporary directory can't be deleted on Windows, due the lock of the cached JAR file reference.  ## Deliverables  - [x] Use the following code to prevent caching of an underlying JAR file:  ```java URLConnection urlConnection = configFileUrl.openConnection(); urlConnection.setUseCaches(false); try (InputStream inputStream = urlConnection.getInputStream()) {  props.load(inputStream); } ```","closed","component: Platform,","sormuras","2020-02-23T09:47:55Z","2020-03-20T09:49:22Z"
"","2441","Let Gradle find Java 8 toolchain","to trigger a CI build","closed","","marcphilipp","2020-10-05T19:12:16Z","2020-10-06T06:04:30Z"
"","2559","Provide a way to find out arguments in parameterized tests in setup methods (@BeforeEach and @BeforeAll)","To the best of my knowledge, arguments in parameterized tests are injected into `@Test` methods, but it is not possible to know these values in the previous stages of the test lifecycle (i.e., in `@BeforeEach` and `@BeforeAll`). I face some use cases in which this is desirable. Would it be possible to implement some mechanism to find out the value of these arguments before the actual test?  As a possible alternative, we could have an enhanced version of `@TestInfo` providing some accessor for arguments in parameterized tests. A `@TestInfo` parameter, injected at  `@BeforeEach` or `@BeforeAll` methods, could do the trick.","closed","theme: parameterized tests,","bonigarcia","2021-02-25T16:16:46Z","2021-02-26T09:02:42Z"
"","2035","Remove fetch depth when cloning Git repo","To resolve errors when building PRs.","closed","theme: build,","marcphilipp","2019-09-28T12:18:01Z","2019-09-28T12:38:30Z"
"","2892","Set merge strategy to `union` for release note files","This would avoid merge conflicts on release note files.","closed","","juliette-derancourt","2022-04-14T18:24:00Z","2022-04-16T11:34:10Z"
"","2439","Use Gradle’s new toolchain feature","This simplies using a different compiler and test launcher.","closed","","marcphilipp","2020-10-04T12:19:09Z","2020-10-04T12:49:47Z"
"","2710","Parameterized Test with @ArgumentSource attribute only runs once even though I have more data in the stream","This seems to be a problem with Jupiter as I have used two different IDEs, and in both cases the unit test does not have the value that should come from the method I am testing. This only happens during debugging. The same values give the expected result when I create a test client in the class's main method. The file name for the unit test is KdTreeTest.java. The entire project is [here](https://github.com/bitflame/Streams).  Thanks The part I believe is relevant to my question is:   ```java import edu.princeton.cs.algs4.Point2D; import edu.princeton.cs.algs4.RectHV; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.extension.ExtensionContext; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.*;  import java.io.File; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Scanner; import java.util.stream.Stream;  class KdTreeTest {     static class KdTreeArgumentsProvider implements ArgumentsProvider {         final static File folder = new File(""src/test/resources/kdtests/"");         // read the data for each test from the files in a directory that contains the points, rectangle(s), and the expected result(s)         // create the kdtree and add points to it by reading two double values from a file. I wonder how I should design the         // input data file. Ideally I want all the points first, then I want to create a rectangle, but it would be nice to         // have one file that results in multiple test instances with the same KdTree but different rectangles and expected         // results         // create a rectangle by reading four double values from a file. May be possible to put the data in the same file         // that way one file has all the data for one test instance         //RectHV r = new RectHV(0.1, 0.1, 0.5, 0.6);         // Just adding two points to expected points for now, but it can be expanded.          // pass the tree instance and the rectangle along with the expected results to a test method to validate the result         // the expected results are a set of Points         @Override          public Stream provideArguments(ExtensionContext extensionContext) throws Exception {              Object[] instanceData;             List l = new ArrayList<>();             for (final File fileEntry : folder.listFiles()) {                 instanceData = new Object[4];                 String fileName = fileEntry.getName().toUpperCase();                 if (fileName.endsWith("".TXT"")) {                     Scanner scanner = new Scanner(fileEntry);                      KdTree kt = new KdTree();                     RectHV r = null;                     String s = """";                     while (scanner.hasNext() && (!(s = scanner.next()).equals(""|""))) {                         double x = Double.parseDouble(s);                         double y = scanner.nextDouble();                         Point2D p = new Point2D(x, y);                         kt.insert(p);                     }                     s = """";                     while (scanner.hasNext() && (!(s = scanner.next()).equals(""|""))) {                         double xmin = Double.parseDouble(s);                         double ymin = scanner.nextDouble();                         double xmax = scanner.nextDouble();                         double ymax = scanner.nextDouble();                         r = new RectHV(xmin, ymin, xmax, ymax);                     }                     int j = 0;                     Point2D[] expectedPoints = new Point2D[5];                     while (scanner.hasNext()) {                         double x = scanner.nextDouble();                         double y = scanner.nextDouble();                         Point2D p = new Point2D(x, y);                         expectedPoints[j++] = p;                         if (j > (expectedPoints.length / 2)) resizeArray((2 * expectedPoints.length), expectedPoints);                     }                     instanceData[0] = fileEntry.getName();                     instanceData[1] = kt;                     instanceData[2] = r;                     instanceData[3] = expectedPoints;                     l.add(instanceData);                     scanner.close();                 }              }             return l.stream().map(Arguments::of);         }          Object[] resizeArray(int newSize, Object[] oldInstanceDataArray) {             Object[] newArray = new Object[newSize];             for (int i = 0; i < oldInstanceDataArray.length; i++) {                 newArray[i] = oldInstanceDataArray[i];             }             return newArray;         }     }      @DisplayName(""should create a rectangle with the given coordinates and test KdTree's range() function"")     @ParameterizedTest(name = ""{index}=> file: {0}, rectangle ={2}, expectedPoints = {3}"")     @ArgumentsSource(KdTreeArgumentsProvider.class)     void range(String filename, KdTree kdtree, RectHV rect, Point2D[] expectedPoints) {         HashMap actualRange = new HashMap<>();         int i = 0;         for(Point2D p: kdtree.range(rect)) {             actualRange.put(i++,p);         }         for(Point2D point: expectedPoints){             if (point!=null) Assertions.assertTrue(actualRange.containsValue(point) && i == actualRange.size());         }     } } ```","closed","theme: parameterized tests,","bitflame","2021-09-02T22:49:54Z","2021-09-10T13:22:06Z"
"","2135","Add support for using any()/none() in tag expressions","This removes the special handling of `any()` and `none()` and makes it possible to use them in tag expressions in all places regular tags can be used.","closed","","marcphilipp","2019-12-18T10:10:23Z","2019-12-19T14:47:57Z"
"","2236","Move versions to gradle.properties","This reduces Gradle script recompilation, and it enables to specify dependency versions from the command line.  fixes #2234  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","vlsi","2020-04-03T11:40:53Z","2020-04-04T16:19:05Z"
"","2008","Finish Azure Pipelines to GitHub Actions migration","This PRs adds the jobs to publish documentation, snapshots, and code coverage. The builds for JDK 13 and 14 are moved to a separate workflow and use a custom Docker image so that Gradle client and daemon can run with JDK 12 but for compilation and test execution JDK 13 and 14 are used, respectively.  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","marcphilipp","2019-09-13T19:13:44Z","2019-09-13T19:41:34Z"
"","2251","Avoid inner class cycle detection for non-matching predicate","This PR is incomplete with regard to documentation in the release notes, but it is ready for peer review.  Fixes #2249   ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sbrannen","2020-04-07T14:28:34Z","2020-04-09T17:18:50Z"
"","2182","Use Gradle Enterprise server to upload scans and as remote build cache","This PR configures the Gradle Enterprise plugin to use the https://ge.junit.org Gradle Enterprise server to publish build scans. Build scans are now always published if the user is [authenticated](https://docs.gradle.com/enterprise/gradle-plugin/#authenticating_with_gradle_enterprise). I will create individual users for all core team members so you can create your own access keys for publishing.  The hostname and IP addresses of local builds are now cleared before the build is being published and CI builds always use ""github"" as their user name to make the [scans list](https://ge.junit.org/scans) more consistent.  Moreover, the build is now configured to use the remote build cache that is built-in to the Gradle Enterprise server so that local builds can reuse task outputs of that have been stored in the remote build cache. Only CI builds are configured to push entries to the remote cache. Since our CI agents are ephemeral, the local build cache is now deactivated for them.  The [default custom user data script](https://github.com/gradle/gradle-build-scan-snippets/blob/master/guided-trials-default-custom-user-data/default-custom-user-data.gradle) for build scans is applied. It adds tags for the operating system, IDE, CI/LOCAL as well as custom links from the build scan to the commit on GitHub and the GitHub Actions that executed it (if any).","closed","theme: build,","marcphilipp","2020-02-14T13:27:43Z","2020-02-15T09:18:24Z"
"","2581","Enable Test Distribution","This PR applies the `com.gradle.enterprise.test-distribution` plugin that uses Test Distribution (TD) agents connected to ge.junit.org to execute tests remotely. TD is disabled by default and can be enabled by setting the `enableTestDistribution` project property to `true`. In order to use Test Distribution, the user running the build needs an account on ge.junit.org with the TD role and an access key. All JUnit 5 team members can use TD locally via their existing access keys used to publish build scans.  On CI, an access key for a technical user is injected via the `GRADLE_ENTERPRISE_ACCESS_KEY` environment variable. Since secrets are only injected into builds on the main repo, PR builds cannot use TD. Builds originating in the main repo will use TD for the Linux and the JDK 17 jobs. The Windows and macOS jobs currently don't use TD since there are no Windows/macOS TD agents connected to ge.junit.org and we want to keep running the tests, not just the build, on those operating systems.","closed","","marcphilipp","2021-03-26T13:13:02Z","2021-04-01T15:35:15Z"
"","2210","Test suites fail with NoSuchMethodError if com.googlecode.json-simple:json-simple:1.1.1 is imported","This one took me some while to figure out. I'll try to provide an accurate description here and have a test project that reproduces this bug 100% of the time.  **Issue**  If you try to run a Test Case Suite to run JUnit 5 test cases while the project imports `com.googlecode.json-simple:json-simple:1.1.1`, the following error message is displayed:  ``` java.lang.NoSuchMethodError: org.junit.runner.Description.createSuiteDescription(Ljava/lang/String;Ljava/io/Serializable;[Ljava/lang/annotation/Annotation;)Lorg/junit/runner/Description; 	at org.junit.platform.runner.JUnitPlatformTestTree.createJUnit4Description(JUnitPlatformTestTree.java:108) 	at org.junit.platform.runner.JUnitPlatformTestTree.buildDescription(JUnitPlatformTestTree.java:95) 	at org.junit.platform.runner.JUnitPlatformTestTree.lambda$buildDescriptionTree$0(JUnitPlatformTestTree.java:86) 	at java.lang.Iterable.forEach(Unknown Source) 	at java.util.Collections$SynchronizedCollection.forEach(Unknown Source) 	at java.util.Collections$UnmodifiableCollection.forEach(Unknown Source) 	at org.junit.platform.runner.JUnitPlatformTestTree.buildDescriptionTree(JUnitPlatformTestTree.java:86) 	at org.junit.platform.runner.JUnitPlatformTestTree.generateSuiteDescription(JUnitPlatformTestTree.java:72) 	at org.junit.platform.runner.JUnitPlatformTestTree.(JUnitPlatformTestTree.java:50) 	at org.junit.platform.runner.JUnitPlatform.generateTestTree(JUnitPlatform.java:139) 	at org.junit.platform.runner.JUnitPlatform.(JUnitPlatform.java:124) 	at org.junit.platform.runner.JUnitPlatform.(JUnitPlatform.java:117) 	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) 	at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) 	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) 	at java.lang.reflect.Constructor.newInstance(Unknown Source) 	at org.junit.internal.builders.AnnotatedBuilder.buildRunner(AnnotatedBuilder.java:31) 	at org.junit.internal.builders.AnnotatedBuilder.runnerForClass(AnnotatedBuilder.java:24) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:57) 	at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:29) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:57) 	at org.junit.internal.requests.ClassRequest.getRunner(ClassRequest.java:24) 	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.createUnfilteredTest(JUnit4TestLoader.java:90) 	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.createTest(JUnit4TestLoader.java:76) 	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.loadTests(JUnit4TestLoader.java:49) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:526) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) ```  To reproduce this, here is my project setup. The following setup will reliably fail to run the test case suite (via ""Run as JUnit Test) while the import of `'com.googlecode.json-simple:json-simple:1.1.1'` is enabled in the build.gradle, and succeed if that line is commented out.  **Project Setup**  * Eclipse 4.14.0 * Gradle Project  build.gradle: ``` /*  * This file was generated by the Gradle 'init' task.  *  * This generated file contains a sample Java Library project to get you started.  * For more details take a look at the Java Libraries chapter in the Gradle  * User Manual available at https://docs.gradle.org/6.0/userguide/java_library_plugin.html  */  plugins {     // Apply the java-library plugin to add support for Java Library     id 'java-library' }  repositories {     // Use jcenter for resolving dependencies.     // You can declare any Maven/Ivy/file repository here.     jcenter() }  dependencies {     // This dependency is exported to consumers, that is to say found on their compile classpath.     api 'org.apache.commons:commons-math3:3.6.1'      // This dependency is used internally, and not exposed to consumers on their own compile classpath.     implementation 'com.google.guava:guava:28.0-jre'      // Use JUnit test framework     testRuntime(""org.junit.jupiter:junit-jupiter-engine:5.5.2"")     testRuntime(""org.junit.platform:junit-platform-runner:1.5.2"") 	 	//This breaks the test suite 	compile 'com.googlecode.json-simple:json-simple:1.1.1' } ```  Class gradleTestProject.Addition:  ``` package gradleTestProject;  public class Addition { 	public static int add(int summand1, int summand2) { 		return summand1 + summand2; 	} } ```   Class gradleTestProject.Subtraction:  ``` package gradleTestProject;  public class Subtraction { 	public static int subtract(int summand1, int summand2) { 		return summand1 - summand2; 	} } ```  Test Class AdditionTest  ``` package gradleTestProject;  import static org.junit.jupiter.api.Assertions.*;  import org.junit.jupiter.api.Test;  class AdditionTest {  	@Test 	void addShouldReturnCorectResult() { 		int result = Addition.add(1,2); 		assertEquals(3, result); 	}  } ```  Test Class SubtractionTest  ``` package gradleTestProject;  import static org.junit.jupiter.api.Assertions.*;  import org.junit.jupiter.api.Test;  class SubtractionTest {  	@Test 	void subtractShouldReturnCorectResult() { 		int result = Subtraction.subtract(3,2); 		assertEquals(1, result); 	}  } ```  Test Suite Class   ``` package testCaseSuites;  import org.junit.platform.runner.JUnitPlatform; import org.junit.platform.suite.api.SelectPackages; import org.junit.runner.RunWith;  @RunWith(JUnitPlatform.class) @SelectPackages(""gradleTestProject"")  public class testCaseSuite {  } ```","closed","component: Platform,","Kira-Cesonia","2020-03-10T08:45:05Z","2020-03-10T11:04:32Z"
"","2201","Introduce new `DisplayNameGenerator` named `Simple`","This new generator extends `Standard` and removes parenthesis at the end of method names if they have no parameters.  Resolves #1961.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","juliette-derancourt","2020-02-27T21:13:49Z","2020-03-17T20:22:11Z"
"","2200","Update link to AssertJ API documentation","This link https://joel-costigliola.github.io/assertj/core-8/api points to the wrong (out of date) version:  https://github.com/junit-team/junit5/blob/9db860622517e077f2dbc21c34d585e170b19159/documentation/documentation.gradle.kts#L84  Correct target: https://javadoc.io/doc/org.assertj/assertj-core/3.14.0  The version in the link must match the one defined in `Versions.kt`:  https://github.com/junit-team/junit5/blob/9db860622517e077f2dbc21c34d585e170b19159/buildSrc/src/main/kotlin/Versions.kt#L17","closed","component: Platform,","sormuras","2020-02-27T08:25:15Z","2020-04-08T20:17:38Z"
"","2476","It should be possible to select inherited methods as tests","This issue is caused by https://github.com/spockframework/spock/issues/1235  It used to be possible to select an inherited tests in a child class.  `./gradlew test --tests *ChildSpec.parent`  My guess is that it is probably that line here `return matcher.matchesTest(methodSource.getClassName(), methodSource.getMethodName());`  https://github.com/gradle/gradle/blob/46d60a4c6d72ce8880882e76a73d8db25d8aed9a/subprojects/testing-junit-platform/src/main/java/org/gradle/api/internal/tasks/testing/junitplatform/JUnitPlatformTestClassProcessor.java#L179  Comment by @marcphilipp  > The `MethodSource` is supposed to contain the declaring class, hence ""source"", and was introduced to allow IDE navigation. The filtering code could check for the parent descriptor's `ClassSource` in this case instead of using the `MethodSource`'s class name.  ## Deliverables  - [ ] Enhance the filter code to allow to select inherited methods","closed","3rd-party: Gradle,","leonard84","2020-11-16T16:10:31Z","2020-11-17T10:14:33Z"
"","2633","Download JUnit's API Documentation","this is not feature request, but perhaps a silly and embarrasing question.  how to get the junit api documentation offline, the download link. what you do with junit user guide, i really thanks for that. it is a pdf format.  - [ ] ...","closed","theme: documentation,","f8chicken","2021-05-31T06:20:51Z","2021-05-31T09:35:12Z"
"","1987","Class selectors should support explicit ClassLoader","This is a specific sub-issue of #806.  I've been adapting JUnit Platform to run in an OSGi environment as part of the Bndtools project (see bndtools/bnd#3145). This project consists of a `BundleEngine` which discovers test bundles in the running OSGi framework, and then delegates to other TestEngines it finds in the environment for each such bundle that it finds.  It became apparent during this implementation that the discovery selectors that do class loading (eg, selectClass(String) and selectMethod(String, String)) ideally needed variants that allowed you to explicitly specify the classloader, rather than always using the default classloader. I had to write a fair bit of code to work around the lack of such a feature when I implemented `BundleEngine`.  The call to `ReflectionUtils.tryToLoadClass(String)`:  https://github.com/junit-team/junit5/blob/cfe9a9928a6c040e8fd6edf96ed70e7eaac94a80/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java#L74-L76  ...could then simply be replaced with a call to the `ReflectionUtils.tryToLoadClass(String, ClassLoader)` variant (and possibly update the precondition error message to indicate which classloader it used to try and load the class).  For backwards compatibility, if the classloader is not explicitly specified, simply use the default classloader (current behaviour).","closed","status: stale,","kriegfrj","2019-08-20T01:17:37Z","2021-06-19T12:50:35Z"
"","2107","[DiscoverySelectors] Add selectClass()/selectMethod() variants that take a ClassLoader","This is a sample implementation of #1987.  It probably needs a bit of javadoc tidy-up, but before I invested too much time on that I wanted approval/feedback from the core team for the basic concept and the way I've implemented it.  Note that the first commit is shared in common with #2106.","closed","status: stale,","kriegfrj","2019-11-20T07:24:03Z","2021-06-19T12:50:36Z"
"","2634","Provide access to ConfigurationParameters via the TestPlan","This is a PR for #2631.  Once approved, I will document the new feature in the user guide and release notes.  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sbrannen","2021-06-01T14:27:41Z","2021-06-02T16:34:08Z"
"","1990","Ability to register extensions for framework provider","This is a follow up to   https://github.com/junit-team/junit5/issues/1938 Jmockit used to call into internal API to register it's extension. Now JMockit changed their code to set the Systemproperty  `junit.jupiter.extensions.autodetection.enabled=true` which is kind of official API but also is a lot worse.  - It' my decision as a user whether i want autodetection or not ,an external framework shouldn't invalidate my choice - autodetection will pick up anything thats on the classpath, especially things i am not aware of and don't need or want.   But the root cause seems to me that junit5 doesn't seem to provide a straighforward API for jmockit (and other frameworks) to globally register their (and only their) extension. So you can't really blame jmockit to much on there choice.  ## Deliverables Sort of: Being able to to insert a single extension in a controlled way into the extension registry.","closed","status: stale,","TheGoesen","2019-08-23T08:15:59Z","2021-06-19T12:50:35Z"
"","2925","Allow @RepeatedTest to stop after a certain number of failures","This idea is similar to [issue #2119](https://github.com/junit-team/junit5/issues/2119)  I think the function mentioned in [issue #2119](https://github.com/junit-team/junit5/issues/2119) could be extended to allow users to define tolerable number of failures, by introduce something like `tolerableFailureNumber` attribute (which is an `integer`)  ```java  @RepeatedTest(10, tolerableFailureNumber = 2)	// this test will terminate after five failures  ```  This can not only fulfill the requirements in [issue #2119](https://github.com/junit-team/junit5/issues/2119) by setting `tolerableFailureNumber` to 1, but also provide richer functionality.","open","status: new,","YuanPeiqi","2022-05-25T14:32:21Z","2022-05-26T10:08:35Z"
"","2322","Replace ""blacklisted"" with ""unrecoverable"" exceptions","This commit replaces the oppressive term ""blacklist"" [1] with a more descriptive, domain-specific one. Exceptions that are rethrown by the new `UnrecoverableExceptions.rethrowIfUnrecoverable` method, are _unrecoverable_, i.e. they should always terminate test plan execution immediately instead of being caught and potentially wrapped in another exception.  To support running newer engines on an older Platform, the existing class is deprecated instead of deleted for now.  [1] https://tools.ietf.org/id/draft-knodel-terminology-00.html#rfc.section.1.2","closed","type: task,","marcphilipp","2020-06-14T15:04:31Z","2020-06-15T08:42:56Z"
"","2382","Introduce global default lock to facilitate isolated test execution","This commit introduces a new global resource lock ""__global__"" that all test descriptors that are children of the engine descriptor acquire by default in READ mode. Using the `@Isolated` annotation in the Jupiter API causes the mode to be changed to READ_WRITE.  Will eventually resolve #2142.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling   - [x] Add tests for `@Isolated` on test classes and in `@Nested` tests - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-08-13T15:05:01Z","2020-08-16T10:47:02Z"
"","2143","Upgrade to junit:junit:4.13","This changes `junit-vintage-engine`, `junit-jupiter-migrationsupport`, and `junit-platform-runner` to compile against 4.13 but adds extra test tasks that run it against 4.12. In the OSGi metadata, we now import the packages from junit:junit with `@4.12` which means `[4.12,5.0)`. That's done because there's no OSGi bundle for 4.13, yet. The published POM and Gradle Module Metadata require 4.13, though, to stop Maven to consume any potential future pre-release (e.g. 4.14-rc-1 or similar).  ---  Original description:  > Unfortunately, it doesn't work yet, due to an OSGi error: >  > > Task :junit-platform-runner:verifyOSGi FAILED Resolution failed. Capabilities satisfying the following requirements could not be found:     [<>]       ⇒ osgi.identity: (osgi.identity=junit-platform-runner)           ⇒ [junit-platform-runner version=1.6.0.SNAPSHOT]               ⇒ osgi.wiring.package: (&(osgi.wiring.package=org.junit.runner)(version>=4.13.0)) >  > More details and stacktrace: https://scans.gradle.com/s/er4ytskvf5qqs/failure?openFailures=WzBd&openStackTraces=WzRd#top=0","closed","","marcphilipp","2020-01-04T20:24:39Z","2020-01-06T09:16:36Z"
"","2612","ClasspathScanner#determineSubpackageName sometimes resolves to wrong subpackageName starting with '...'","This bug was introduced in JUnit `5.7.1`. `5.7.0` have no such a problem.  Example:   ```java Path baseDir = ""/com/fasterxml/jackson/core/base/""; Path classFile = ""/com/fasterxml/jackson/core/base/ParserMinimalBase.class""; String subpackageName = determineSubpackageName(baseDir, classFile); // subpackageName now equals ""...base"" ```  The bug is probaby due to commit https://github.com/junit-team/junit5/pull/2531 (Fix package path computation in ClasspathScanner )  I got this bug because I use `ReflectionSupport#findAllClassesInPackage` inside my JUnit Jupiter plugin.  ## Steps to reproduce  To reproduce the bug is quite a trick. So project https://github.com/jlrosa/testwithresources was created. Here the steps to do 1) Clone the project, execute `mvn clean install`, and open the project in IDE. 2) Setup a breakpoint in `ClasspathScanner#processClassFileSafely` line 131. 3) Run the test `InjectResourcesTest` in debug mode. 4) Java debugger will stop. Check the value of the variable `fullyQualifiedClassName`. It will be something like: ""com.adelean.inject.resources.junit.jupiter....jupiter.WithJacksonMapper""  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit 5.7.1  - Build Tool/IDE: Intellij  ## Deliverables  - [ ] ...","closed","component: Platform,","hosuaby","2021-05-10T14:38:36Z","2021-05-12T05:59:25Z"
"","2222","Broken Link in User Guide, Example Projects","This affects the current User Guide linked from the website (junit.org/junit5)  ## Steps to reproduce  - Click on any of the links in the section 1.4.3 (Example Projects) - A 404 error will be the result","closed","theme: documentation,","broeser","2020-03-23T05:20:37Z","2020-03-23T10:14:29Z"
"","2409","Introduce @CombineTestTemplates support","This adds support for combining multiple TestTemplate providers together, in a product style, so that an implementer can use the benefits of multiple extensions together.  Issue: #1224  ## Overview  This is a fix for #1224. I had some free time so I thought I would take a look at how hard it would be. This will almost certainly not work for everyone so I have made it opt-in with a new annotation, @CombineTestTemplates. This will allow those who need this feature to use it, and everything will be normal for others.  Using the Maven test sample as a quick test we get the following test output (happy to hear suggestions for better test names):  ![image](https://user-images.githubusercontent.com/1029558/93200151-f2b1e800-f73e-11ea-8c15-a5c863e1a099.png)  I have not yet had a chance to write test cases but I'm gonna have a crack at that later in the week if this seems interesting.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","danielhodder","2020-09-15T10:34:38Z","2022-07-08T00:42:27Z"
"","2058","Added additional test cases for issue #981","This adds addition test cases as specified in #981    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","codechaos","2019-10-12T12:09:46Z","2019-10-12T14:25:51Z"
"","2112","Add disposal method for cleansing-required resolved parameter","There seems, currently, no direct way to cleanse resolved parameters through `ParameterResolver`.  ```java     @Override     public boolean supportsParameter(final ParameterContext parameterContext,                                      final ExtensionContext extensionContext)             throws ParameterResolutionException {         final Parameter parameter = parameterContext.getParameter();         final Class type = parameter.getType();         return parameter.isAnnotationPresent(TempFile.class)                 && (type == File.class || type == Path.class);     }      @Override     public Object resolveParameter(final ParameterContext parameterContext,                                    final ExtensionContext extensionContext)             throws ParameterResolutionException {         method = extensionContext.getTestMethod().orElse(null);         try {             file = createTempFile(null, null);         } catch (final IOException e) {             throw new RuntimeException(e);         } //        getRuntime().addShutdownHook(new Thread(() -> { //            try { //                final boolean deleted = deleteIfExists(file); //                log.debug(""temp file deleted: {} {}"", deleted, file); //            } catch (final IOException ioe) { //                throw new RuntimeException(ioe); //            } //        }));         if (parameterContext.getParameter().getType() == File.class) {             return file.toFile();         }         return file;     }      @Override     public void afterEach(final ExtensionContext extensionContext) throws Exception {         if (method == null || !method.equals(extensionContext.getTestMethod().orElse(null))) {             return;         }         try {             final boolean deleted = deleteIfExists(file);             log.debug(""temp file deleted: {} {}"", deleted, file);         } catch (final IOException ioe) {             throw new RuntimeException(ioe);         }     }      private transient Method method;      private transient Path file;  ```  ## Deliverables  - [ ] Add `disposeParameter(ParameterContext, ExtensionContext, Object)` for disposing parameters.","closed","status: declined,","onacit","2019-11-24T09:08:57Z","2019-11-24T13:12:29Z"
"","2255","Document JUnit 5 Platform Idea","There is hardly any _official_ documentation about how to use and add to the JUnit 5 platform. This might be useful for users of JUnit, for possible contributors of engines and for IDE and tools developrs.  ## Deliverables  The follow list is just a first attempt at enumerating useful documents:  - [ ] What is the JUnit Platform all about? - [ ] How to discover and run platform tests from any engine - [ ] How to write and test a test engine for the JUnit platform - [ ] How to enhance platform reporting and tooling  I guess the whole platform topic is too specific for the general JUnit 5 user guide","closed","status: stale,","jlink","2020-04-11T10:12:59Z","2021-06-03T19:47:37Z"
"","2397","Could not set test case name with '@ParameterizedTest' as expected","There is a scenario, where I will run multiple tests with 'parameterizedTest', all work well except for the test case naming. Consider the following code snippet: ~~~     static List parse() {         String url = ""https://xxx.tears.mpd"";         Arguments a = Arguments.of(url, ""testTunnelModePlayback"");         List res = new ArrayList<>();         res.add(a);         return res;     } ~~~ ~~~     @ParameterizedTest(name = ""{1}"")     @MethodSource(""xxx.yyy#parse"")     void testPlayback(String url, String caseName) {         // Some test logic        // Play stream with this url, in real tests, it's more complicated than this.     } ~~~  The issue is, when I run this test, the test case will be naming as `testPlayback(String, String): testTunnelModePlayback`. This is not what I've been expecting, I wish the test case name to be **EXACT** `testTunnelModePlayback`.  Could you help with this issue, or am I missing other methods  to achieve my goal?","closed","3rd-party: Gradle,","Moriarty16","2020-09-03T06:07:56Z","2020-09-10T10:49:22Z"
"","2205","Provide a definition of ""container"" in the User Guide","The word `container` is used more than 50 times in the current Guide https://junit.org/junit5/docs/current/user-guide/  This term wasn't used in JUnit4 and is new to many JUnit users. In the development industry we have just too many different containers to leave this to ""common sense"" understanding.  Please just add the definition of JUnit5 ""container"" in the User Guide.","closed","component: Platform,","vinogradoff","2020-03-03T11:14:08Z","2022-07-04T17:54:12Z"
"","2816","Provide mechanism for managing engine-level resources","The Platform should provide an extensible mechanism (`ServiceLoader`?) so that user code can create ""closeable resources"" that are injected as part of the context received by `TestEngine` implementations.  This feature is analogous to the `ExtensionContext.Store` concept from Jupiter but takes it to the Platform level. Moreover, it allows to reuse the same resource across multiple executions in a `LauncherSession`. We should advocate that resources stored in such a key-value store be immutable until their destruction. If such resources implement `AutoCloseable` they will get closed immediately before the `LauncherSession` they belong to is closed.","open","theme: suites,","marcphilipp","2022-01-28T13:50:27Z","2022-01-28T13:51:06Z"
"","2745","Use new Codecov GitHub Action","The old uploader will be sunset in Feb, 2022.","closed","","marcphilipp","2021-10-13T15:26:19Z","2021-10-13T19:14:44Z"
"","2484","Introduce utility method for processing all destroyed test instances","The new utility method helps to ensure all test instances are processed by a `TestInstancePreDestroyCallback` when used in conjunction with `@Nested` tests.  Resolves #2430.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-11-28T15:38:52Z","2020-12-13T13:30:04Z"
"","2164","Use platform subproject to manage dependencies","The new `dependencies` subproject declares dependency contraints that are imported in all other subprojects using an `internal` configuration that is _not_ published in the dependency management section of the generated POMs nor in Gradle Module Metadata.","closed","","marcphilipp","2020-01-26T13:16:19Z","2020-01-28T15:36:52Z"
"","2788","Make console launcher --classpath argument parser work like java's when referring to a jar directory","The junit-platform-console-standalone  --classpath option requires you to list all the jars in a directory; for example, `-cp ""testlib/mockito-core-4.1.0.jar:testlib/byte-buddy-1.12.3.jar:testlib/byte-buddy-agent-1.12.3.jar:testlib/objenesis-3.2.jar:classes`.  This is different than Java's --classpath, which supports the more compact `-cp ""testlib/*`.  Coming from java and javac, this was unexpected behavior from junit.  As far as I can tell, the difference is not documented.  ## Deliverables  - [ ] Update documentation to specify syntax of PATH (section 4.3.1 of User Guide) - [x] #2789 - [ ] Update -cp processing to support the same syntax as javac and java.","open","type: new feature,","mbucc","2021-12-08T13:26:19Z","2022-04-23T11:11:42Z"
"","2166","Helpful error message when TestTemplateInvocationContextProvider provides an empty stream","The javadoc of `TestTemplateInvocationContextProvider# provideTestTemplateInvocationContexts` says: ""This method is only called by the framework if `#supportsTestTemplate` previously returned `true` for the same `ExtensionContext`. Thus, this method must not return an empty `Stream`.""  But if an implementation fails to do so and actually returns a non-empty stream, the exception thrown is not very helpful: ""org.junit.platform.commons.PreconditionViolationException: No supporting TestTemplateInvocationContextProvider provided an invocation context""  ## Deliverables  One of these: - `TestTemplateTestDescriptor#execute` checks the stream of all providers (instead of filtering on `isPresent`) and throws an error message like "" provided an empty stream"" where `` is the name of the provider (if we want to stick to the requirement that empty streams are forbidden). - Change the javadoc of `TestTemplateInvocationContextProvider` to allow for empty streams; and `TestTemplateTestDescriptor#validateWasAtLeastInvokedOnce` throws with a message ""None of the providers [...] has provided a non-empty stream"" where `[...]` is the list of valid providers (if we want to stick to the current behavior of actually allowing empty streams).  I could work on a PR, if the decision about which way to go was made.","closed","component: Jupiter,","t1","2020-01-27T09:41:13Z","2020-02-07T11:10:40Z"
"","2288","Incorrect Javadoc in BeforeTestExecutionCallback","The Javadoc for `BeforeTestExecutionCallback` states: https://github.com/junit-team/junit5/blob/c4e0a26deb6194c0221410d9fa8261cf3ffd3719/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/BeforeTestExecutionCallback.java#L18-L23  I think that should read ""user-defined _setup_ methods"" instead of ""user-defined teardown methods"".  ## Deliverables  - [x] Correct Javadoc","closed","component: Jupiter,","BlueIce","2020-05-05T21:12:36Z","2020-05-09T13:46:34Z"
"","2914","Private lifecycle methods should cause an exception","The JavaDoc contains the following sentences:  > `@BeforeEach` methods must have a void return type, must not be private, and must not be static. `@BeforeEach` methods are inherited from superclasses as long as they are not overridden. Furthermore, `@BeforeEach` methods from superclasses will be executed before `@BeforeEach` methods in subclasses.  Private methods are executed, even though they should not be (?). The JavaDoc prohibits private methods but does not explain what will happen.  Java defines overriding methods as: https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8.1, the JavaDoc uses the term ""overridden"" with a different meaning than Java. JLS even says:   > Note that methods are overridden or hidden on a signature-by-signature basis. If, for example, a class declares two public methods with the same name ([§8.4.9](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.9)), and a subclass overrides one of them, the subclass still inherits the other method.  In the previous issue #2390, it was suggested to also include mention of shadowing - which I think is also wrong. JLS already defines shadowing - https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.4.1.  Both instances should be either fixed to be compliant with the documentation, or the documentation should be updated.  Other annotations (`@BeforeAll`, `@AfterAll`, and `@AfterEach`) are expected to be affected too.  ## Steps to reproduce  Let's imagine two packages and a class in each:  ```java package sup;  public class Sup {     @BeforeEach     MODSUP void before() {         System.out.println(""Before in Sup"");     } }  package sub; import sup.Sup;  public class Sub extends Sup {     @BeforeEach     void before() {         System.out.println(""Before in Sub"");     }      @Test     MODSUB void test() {         System.out.println(""Test"");     } } ```  We can then write a table of expected behavior based on the modifiers:  Sub \ Sup | public | protected | none | private -- | -- | -- | -- | -- public | Before in SubTest | Before in SubTest | Before in SupBefore in SubTest (*) | Before in SubTest protected | compilation error | Before in SubTest | Before in SupBefore in SubTest (*) | Before in SubTest none | compilation error | compilation error | Before in SupBefore in SubTest (*) | Before in SubTest private | compilation error | compilation error | Before in SupTest (*) | Test (*)  The combinations with (*) instead produce:  ``` Before in Sub Test ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.2  - Build Tool/IDE: Gradle, Java 11","closed","component: Jupiter,","juriad","2022-05-12T19:12:07Z","2022-07-04T17:53:28Z"
"","2742","Silently skipped tests when last line of Kotlin test method returns a coroutine","The issue I'm seeing is with JUnit 5 and Kotlin.  When I have a unit test like the following, JUnit 5 skips the test and outputs nothing to indicate that it has been skipped.  I've seen this issue in a real codebase were about 10 unit tests were skipped in this way.  The example below is a contrived one.  When I've seen it happening for real, it was a call to a Kotlin version of Mockito's `verify()` method that was causing the issue.  The method call was the last line in the test and the method call being verified just happened to return a Kotlin coroutine (which is what the `verify()` method then returns).    ```kotlin     @Test     // Function is missing an explicit return type     fun `will silently be skipped`() = runBlocking {         // Last step is something that returns a Kotlin coroutine         launch { doSomething() }     } ```  I'm using JUnit v5.8.1, the latest version  ## Steps to reproduce  Here's a minimal reproduction repo, including a GitHub actions build that archives a copy of the JUnit test report that shows the issue.    https://github.com/simondean/kotlin-junit-run-blocking-issue  Here's an example test report: https://github.com/simondean/kotlin-junit-run-blocking-issue/suites/3996726768/artifacts/100745995  ## Context   - Used versions (Jupiter/Vintage/Platform): org.junit:junit-bom:5.8.1 - see https://github.com/simondean/kotlin-junit-run-blocking-issue for more info  - Build Tool/IDE: Gradle from command line and IntelliJ  ## Deliverables  - [ ] ...","closed","status: new,","simondean","2021-10-08T11:58:03Z","2021-10-08T12:16:38Z"
"","2020","Please publish the list of the official release PGP keys","The idea is project page should provide clear steps to verify if the release is official. I'm afraid I've no standard way of doing that, however it would be nice if you could mention the official PGP key ids in the Download section.  Moving from 4.12 to 5.5.1 gives the following:  ``` > Checksum/PGP violations detected on resolving configuration :src:jorphan:testCompileClasspath     No trusted PGP keys are configured for group org.apiguardian:       org.apiguardian:apiguardian-api:1.1.0 (pgp=[85911f425ec61b51], sha512=[computation skipped])     No trusted PGP keys are configured for group org.junit.jupiter:       org.junit.jupiter:junit-jupiter-api:5.5.1 (pgp=[85911f425ec61b51], sha512=[computation skipped])     No trusted PGP keys are configured for group org.junit.platform:       org.junit.platform:junit-platform-commons:1.5.1 (pgp=[85911f425ec61b51], sha512=[computation skipped])     No trusted PGP keys are configured for group org.opentest4j:       org.opentest4j:opentest4j:1.2.0 (pgp=[85911f425ec61b51], sha512=[computation skipped]) ```  See also https://github.com/spring-projects/spring-framework/issues/23434#issuecomment-523882229  See also https://github.com/jacoco/jacoco/issues/937  See also https://gitlab.ow2.org/asm/asm/issues/317884  Sample implementation for Apache JMeter: https://jmeter.apache.org/download_jmeter.cgi As you see, it refers KEYS file and links to the page with gpg commands to verify the signatures.  PS. I don't really expect that everybody would start verifying their downloads, however making the official key ID publicly available would help for automated verifications as well.  PS. Thanks for JUnit!","closed","component: Vintage,","vlsi","2019-09-22T13:36:46Z","2019-09-28T19:54:37Z"
"","2041","Gradle test runner does not display names for parameterized tests","The full name of `@ParameterizedTest` is never printed in Gradle output.  Reproducer: https://github.com/junit-team/junit5-samples/pull/116  That really hurts. I can add relevant information to the `Assertions.assert...(..., message=...)`, however, it won't be printed in case the test fails with NPE in the middle :-/","closed","3rd-party: Gradle,","vlsi","2019-10-04T21:21:14Z","2019-10-23T10:34:31Z"
"","2209","TestInstancePreDestroyCallback does not follow the wrapping behavior of callbacks in lifecycle PER_CLASS","The extension `TestInstancePreDestroyCallback` does not follow the wrapping behavior of Extensions if the lifecycle is `PER_CLASS`, as described in https://junit.org/junit5/docs/snapshot/user-guide/#extensions-execution-order-wrapping-behavior  ### The expected order with lifecycle PER_CLASS  - Extension1.postProcessTestInstance - Extension2.postProcessTestInstance - Extension1.beforeAll - Extension2.beforeAll - Extension2.afterAll - Extension1.afterAll - Extension2.preDestroyTestInstance - Extension1.preDestroyTestInstance  ### The order using JUnit 5.6.0. with lifecycle `PER_CLASS`  - Extension1.postProcessTestInstance - Extension2.postProcessTestInstance - Extension1.beforeAll - Extension2.beforeAll - Extension2.afterAll - Extension1.afterAll - **Extension1.preDestroyTestInstance** - **Extension2.preDestroyTestInstance**  ### The order using JUnit 5.6.0. with lifecycle `PER_METHOD` is as expected  - Extension1.beforeAll - Extension2.beforeAll - Extension1.postProcessTestInstance - Extension2.postProcessTestInstance - Extension2.preDestroyTestInstance - Extension1.preDestroyTestInstance - Extension2.afterAll - Extension1.afterAll   ## Steps to reproduce  ```java @TestInstance(TestInstance.Lifecycle.PER_CLASS) @ExtendWith({ Dummy2Test.Extension1.class, Dummy2Test.Extension2.class }) public class Dummy2Test {     private static final Logger LOG = Logger.getLogger(Dummy2Test.class.getName());          @Test     public void justATest() {         LOG.fine(""@Test"");     }          public static class Extension1 implements BeforeAllCallback, AfterAllCallback , TestInstancePostProcessor,TestInstancePreDestroyCallback {          @Override         public void beforeAll(ExtensionContext ec) throws Exception {             LOG.warning(""Extension1.beforeAll"");         }          @Override         public void afterAll(ExtensionContext ec) throws Exception {             LOG.warning(""Extension1.afterAll"");         }                  @Override         public void postProcessTestInstance(Object o, ExtensionContext ec) throws Exception {             LOG.warning(""Extension1.postProcessTestInstance"");         }          @Override         public void preDestroyTestInstance(ExtensionContext ec) throws Exception {             LOG.warning(""Extension1.preDestroyTestInstance"");         }              }          public static class Extension2 implements BeforeAllCallback, AfterAllCallback , TestInstancePostProcessor, TestInstancePreDestroyCallback {          @Override         public void beforeAll(ExtensionContext ec) throws Exception {             LOG.warning(""Extension2.beforeAll"");         }          @Override         public void afterAll(ExtensionContext ec) throws Exception {             LOG.warning(""Extension2.afterAll"");         }                  @Override         public void postProcessTestInstance(Object o, ExtensionContext ec) throws Exception {             LOG.warning(""Extension2.postProcessTestInstance"");         }          @Override         public void preDestroyTestInstance(ExtensionContext ec) throws Exception {             LOG.warning(""Extension2.preDestroyTestInstance"");         }     } } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.6.0  - Build Tool/IDE: maven","closed","component: Jupiter,","joerg1985","2020-03-09T14:45:16Z","2020-03-12T14:35:42Z"
"","2719","Use @JvmField instead of @JvmStatic in Kotlin / @RegisterExtension","The documentation says:  >The Kotlin programming language does not have the concept of a static field. However, the compiler can be instructed to generate a private static field using the @JvmStatic annotation in Kotlin. If you want the Kotlin compiler to generate a public static field, you can use the @JvmField annotation instead.  But the example shows the use of `@JvmStatic`, which is not working with, e.g. WireMock:  ```kotlin companion object {     @RegisterExtension     @JvmStatic     val wireMock = WireMockExtension.newInstance().options(wireMockConfig().dynamicPort()).build() } ```  Gives  ``` org.junit.platform.commons.PreconditionViolationException: Failed to register extension via @RegisterExtension field [private static final com.github.tomakehurst.wiremock.junit5.WireMockExtension a.b.c.ClientTest.wireMock]: field must not be private. ```  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","madhead","2021-09-15T13:24:17Z","2021-09-16T12:21:45Z"
"","2056","Add generation of additional javadoc for jupiter-api only","The documentation build generates separate javadoc that contains only API now. The new docs will be published to github pages under /docs/current/jupiter-api.  This was done by duplicating the previous javadoc goal, with no optimizations. I removed the asciidoc dependency because I saw now use for it in the code and building locally works fine without it.  I tried to apply the DoD to the gradle file as good as possible - hope that's good enough. Do you write tests for your gradle code?   Resolves Issue: #676  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x ] There are no TODOs left in the code - [-] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [-] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [-] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [-] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: blocked,","joergsesterhenn","2019-10-11T00:19:23Z","2020-01-19T18:25:32Z"
"","2605","@Isolated annotation doesn't work properly when @ResourceLock annotations are also used","The documentaion for `@Isolated` states  >`@Isolated` is used to declare that the annotated test class should be executed in isolation from other test classes. >When a test class is run in isolation, no other test class is executed concurrently. This can be used to enable parallel test execution for the entire test suite while running some tests in isolation (e.g. if they modify some global resource).  The `@Isolated` annotation is implemented as a global lock. At a glance, it looks like it's just shorthand for ```java @ResourceLock(""org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY"") ``` This has a very surprising and I would argue buggy implication: if you use a `@ResourceLock(""something"")` annotation on one test and `@Isolated` on another, the `@Isolated` test will run in parallel with the `@ResourceLock`ed test, violating the ""no other test class is executed concurrently"" part of the `@Isolated` contract.  ## Steps to reproduce Put this in your `src/test/resources/junit-platform.properties` file ``` junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent ``` Define 3 test classes like this in some package: ```java @Isolated class IsolatedTest {      @Test     void test() throws InterruptedException {         System.out.println(""Started isolated test"");         Thread.sleep(5000);         System.out.println(""Finished isolated test"");     } } ``` ```java @ResourceLock(""something"") class ResourceLock1Test {      @Test     void test() throws InterruptedException {         System.out.println(""Started ResourceLock1Test"");         Thread.sleep(5000);         System.out.println(""Started ResourceLock1Test"");     } } ``` ```java @ResourceLock(""something"") class ResourceLock2Test {      @Test     void test() throws InterruptedException {         System.out.println(""Started ResourceLock2Test"");         Thread.sleep(5000);         System.out.println(""Started ResourceLock2Test"");     } } ``` ### Expected Behavior I expect none of these tests to interleave - The `@ResourceLock(""something"")` tests acquire the read-write lock, so they should not interleave with each other, and the `@Isolated` test has the behavior that ""no other test class is executed concurrently"", so it should not interleave with either of the other tests.  ### Actual Behavior The `@Isolated` test runs in parallel with the `@ResourceLock(""something"")` tests  ## Context   - Used versions (Jupiter/Vintage/Platform): `junit-jupiter-api:5.7.1`  - Build Tool/IDE: Confirmed behavior in Maven 3.8.1 and Intellij 2021.1","closed","component: Jupiter,","n-miles","2021-04-30T15:01:13Z","2021-05-15T08:28:21Z"
"","2635","Support `class` scheme for ClassSource and dynamic test source URIs","The current set of schemes for [URI Test Sources for Dynamic Tests](https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests-uri-test-source) is missing support for test instances that work out their own location by walking the stack trace.  The answers to [this relevant stackoverflow question](https://stackoverflow.com/questions/58788085/how-can-i-create-a-junit-5-dynamictest-testsourceuri-from-a-stacktraceelement) fall short:  * Top-rated answer, of using the `method:` scheme:    * You cannot get method arguments from a `StackTraceElement`    * Scheme does not support line number information, so you loose the distinction between multiple tests instances created in the same method    * Does not support test instances created in constructors  * Accepted answer, of constructing a `file:` URI from the `StackTraceElement`, leaves you making unsafe assumptions about how the project source and build directories are organised (e.g.: maven vs gradle conventions, multi-module projects, instances defined in dependency jars, etc)  ## Deliverables  - [x] Test source URI scheme that can be constructed from the data available in a StackTraceElement","closed","theme: dynamic tests,","therealryan","2021-06-01T16:27:05Z","2021-06-07T10:10:43Z"
"","2714","Streaming discovery of tests and containers","The current `LauncherDiscoveryRequest` only supports discovery using fixed selectors, like selecting on a class. The maven-surefire-plugin, when using a `forkCount > 1`, streams the classes to be tested to the forks one by one. Using the current API, this can only be implemented by creating a `LauncherDiscoveryRequest` for every class, executing that request and fetching the next class. This has the unwanted side effect that extensions like the Arquillian extension initialize and tear down the entire runtime for every class to be executed. This introduces a significant overhead in running these tests.  The Arquillian extension registers its integration in the `Store` of the root `ExecutionContext`. When selecting multiple classes at once, these classes will all share this root context. However, when a new `LauncherDiscoveryRequest` is executed separately for every class, the root will be a new one for every test class.  The problematic code in surefire can be found in [JUnitPlatformProvider.execute](https://github.com/apache/maven-surefire/blob/master/surefire-providers/surefire-junit-platform/src/main/java/org/apache/maven/surefire/junitplatform/JUnitPlatformProvider.java#L177). The then branch of the if works fine, however in the else branch, when the test classes are streamed (and cannot be fetched eagerly), the recreation of the request creates the problem. A corresponding ticket is also filed at [SUREFIRE-1935](https://issues.apache.org/jira/browse/SUREFIRE-1935), but it seems this cannot be fixed without support in JUnit Platform.","open","status: new,","papegaaij","2021-09-10T20:02:22Z","2021-09-11T11:42:25Z"
"","2048","Please consider moving gh-pages to another repository and/or reduce the size of the branch","The clone of https://github.com/junit-team/junit5 takes a lot. It downloads ~500MiB+, and the resulting repository is full of various pdf files.  Here are the top consumers:  ``` hash bytes path fffea6e6616e 3812203 docs/5.5.1/user-guide/index.pdf d3f697d9c019 3812203 docs/5.5.0/user-guide/index.pdf 30d099b3af05 3812203 docs/5.5.2/user-guide/index.pdf 6267c2a59eb1 3812011 docs/snapshot/user-guide/index.pdf ... ```  and so on.  It does impact both regular development experience (as everybody is used to just `git clone $url`), and it does impact GitHub Actions CI: it takes 1minute for the ""checkout action"".  Note: GitHub Action could probably be improved to skip `gh-pages` branch, however, the issue for humans would sill be there.  1) Are PDFs required? Could they be pushed somewhere else? Do all the snapshots need to be stored in the main repository?  2) Could you please consider the use of `noTimestamp` for the `javadoc`? It will avoid printing the timestamps, thus it would reduce the changes in the html files. See https://github.com/gradle/gradle/pull/8619  Sample: ```kotlin withType().configureEach {                 (options as StandardJavadocDocletOptions).apply {                     noTimestamp.value = true ```","open","theme: build,","vlsi","2019-10-07T11:38:45Z","2022-07-12T07:57:37Z"
"","2517","Make TreePrintingListener available for custom engines","The class and the constructor of TreePrintingListener are not public and cannot be used by custom test engines. Code of listener: https://github.com/junit-team/junit5/blob/main/junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreePrintingListener.java  I'm working on my own HierarchicalTestEngine and would like to reuse this listener instead of re-implementing it. Would it be possible to allowing access to it so that a custom engine can use it?  ## Deliverables  - [ ] Make class public - [ ] Make constructor public","closed","component: Platform,","mythsunwind","2021-01-06T14:56:44Z","2021-01-08T09:48:23Z"
"","2405","Argument truncation breaks parameterized test with parameter having null toString","The argument truncation introduced in 5.7.0 breaks tests with parameters having null `toString()`:  Failing test: https://github.com/joel-costigliola/assertj-core/blob/378648a6ed95859274e36f21bf2472b5556e91e0/src/test/java/org/assertj/core/error/DescriptionFormatter_format_Test.java#L46-L54  https://github.com/joel-costigliola/assertj-core/runs/1114125071?check_suite_focus=true#step:5:6710  ## Steps to reproduce  Stripped example:  ```java   @ParameterizedTest   @MethodSource(""parameters"")   void test(Object object) {   }    private static Stream parameters() {     return Stream.of(new Object() {       @Override       public String toString() {         return null;       }     });   } ```  ``` org.junit.platform.commons.JUnitException: The display name pattern defined for the parameterized test is invalid. See nested exception for further details.  	at org.junit.jupiter.params.ParameterizedTestNameFormatter.format(ParameterizedTestNameFormatter.java:54) 	at org.junit.jupiter.params.ParameterizedTestInvocationContext.getDisplayName(ParameterizedTestInvocationContext.java:38) 	at org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor.(TestTemplateInvocationTestDescriptor.java:48) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.createInvocationTestDescriptor(TestTemplateTestDescriptor.java:131) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$1(TestTemplateTestDescriptor.java:104) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$11$1.accept(ReferencePipeline.java:442) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:411) 	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:107) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:42) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53) Caused by: java.lang.NullPointerException 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.truncateIfExceedsMaxLength(ParameterizedTestNameFormatter.java:106) 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.makeReadable(ParameterizedTestNameFormatter.java:99) 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.formatSafely(ParameterizedTestNameFormatter.java:61) 	at org.junit.jupiter.params.ParameterizedTestNameFormatter.format(ParameterizedTestNameFormatter.java:49) 	... 87 more ```","closed","theme: parameterized tests,","scordio","2020-09-14T21:28:16Z","2020-10-04T07:33:22Z"
"","2381","Provide a concise test feed details mode for the ConsoleLauncher","The ability to have a good report (tree) does not prevent to have some real time hints about executed tests. Currently, these requirements are not fulfilled OOTB by the console launcher. Would be great to have a listener logging each test being executed (a bit like surefire does ""Running X"") + the global report at the end.","open","component: Platform,","rmannibucau","2020-08-13T10:14:40Z","2022-03-23T07:25:04Z"
"","1993","Auto-detect enum type from method signature","The `value` parameter of the `EnumSource` annotation is now optional. When omitted, the declared type of the first method parameter is used. The test will fail if it does not reference an enum type.  Resolves #1973.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","marcphilipp","2019-08-28T18:57:13Z","2019-09-01T18:08:19Z"
"","2398","Document that ParameterizedTest passes raw arguments to MessageFormat","The `ParameterizedTest` name states the supported placeholder ""{0}, {1}, etc.: an individual argument (0-based)"" may be formatted with a `MessageFormat` pattern, ""For the latter, you may use `java.text.MessageFormat` patterns to customize formatting."" However, the argument passed to the pattern are not the arguments the method excepts but the argument supplied by the argument provider.  This can be seen in this silly test:                                                    ```java     @ParameterizedTest(name = ""{0,number,#.00}"")     @ValueSource(ints = { 10, 20 })     @CsvSource(value = { ""30"", ""40"" })     void silly(double value)     {         // ValueSource - OK         // CsvSource - FAILS with Exception     }  ```  It seems that the format is called before any conversation, whether implicit or explicit.   Not sure if this is a bug as such but the documentation should specify what argument is formated.","closed","theme: parameterized tests,","johnsoneal","2020-09-06T18:56:10Z","2020-09-12T09:32:11Z"
"","2772","Overview of shadowed dependencies in standalone JAR","The `META-INF/MANIFEST.MF` file stored in `junit-platform-console-standalone` artifact includes following lines:  ```text Manifest-Version: 1.0 ... Engine-Version-junit-jupiter: 5.8.1 Engine-Version-junit-vintage: 5.8.1 Implementation-Title: junit-platform-console-standalone Implementation-Version: 1.8.1 ... ```  However, there's no information which other artifacts are shadowed ""as-is"" (without renaming their packages) into this standalone (uber) JAR.  Let's generate an overview of all those artifacts and include it as `META-INF/shadowed-artifacts`: ``` ... junit:junit:4.13.2 org.hamcrest:hamcrest-core:2.2 ... org.junit.jupiter:junit-jupiter:5.8.1 org.junit.jupiter:junit-jupiter-api:5.8.1 org.junit.jupiter:junit-jupiter-engine:5.8.1 org.junit.jupiter:junit-jupiter-params:5.8.1 org.junit.platform:junit-platfom-commons:1.8.1 org.junit.platform:junit-platfom-console:1.8.1 ... org.junit.vintage:junit-vintage-engine:5.8.1 ... ```  Perhaps, that listing should also be included in the User Guide under https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher","closed","component: Platform,","sormuras","2021-11-05T07:46:01Z","2021-11-07T09:52:16Z"
"","2380","Prevent multiple executions of a TestPlan","The `Launcher` now fails with a descriptive error message when a previously executed `TestPlan` is attempted to be executed again. The Javadoc of `Launcher` now clearly states that a TestPlan must not be executed more than once.  Resolves #2379.  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-08-11T18:53:46Z","2020-08-12T06:52:34Z"
"","2557","JUnit Platform Console Standalone identifies as Kotlin module","The `junit-platform-console-standalone` artifact entered the club of `kotlin.stdlib.jdk8` impostors. This is perhaps related to #2551 -- but could also stem from a separate issue when building the uber JAR file.  ## kotlin.stdlib.jdk8    1. `com.github.hopshackle:NTBEA` -> [`0.1`, `0.2`, `0.2.1`] 1. `com.github.patrick-mc:twipe` -> [`1.0.3`] 1. `com.mparticle:smartype-generator` -> [`1.2.0`, `1.2.1`] 1. `com.notkamui.libs:keval` -> [`0.7.1`] 1. `com.orange.ccmd:hurl` -> [`1.0.39`, `1.0.40`, `1.0.41`, `1.0.42`] 1. `com.orange.ccmd:hurlfmt` -> [`1.0.39`, `1.0.40`, `1.0.41`, `1.0.42`] 1. `de.jensklingenberg.cabret:cabret-compiler-plugin-native` -> [`1.0.2`] 1. `de.jensklingenberg.cabret:cabret-compiler-plugin` -> [`1.0.2`] 1. `dev.zacsweers.ticktock:ticktock-compiler` -> [`0.2.0`, `0.2.1`, `1.0.0-2020d`, `1.1.0-2020f`] 1. `io.github.baharmc:bedrock-edition` -> [`1.0`, `1.1`, `1.2`] 1. `io.github.baharmc:java-edition` -> [`1.0`, `1.1`, `1.2`] 1. `io.github.baharmc:network-common` -> [`1.0`, `1.1`, `1.2`] 1. `io.github.portlek:patty` -> [`1.1`] 1. `io.github.shiruka:common` -> [`1.0`, `1.2`, `1.3`] 1. `io.github.shiruka:conf-common` -> [`1.1`] 1. `io.github.shiruka:conf-json` -> [`1.1`] 1. `io.github.shiruka:conf-yaml` -> [`1.1`] 1. `io.github.shiruka:network` -> [`1.3`] 1. `io.tatum:tatum-java` -> [`1.0.6`, `1.0.7`, `1.0.8`, `1.0.9`] 1. `io.teamif:comcigan-lib` -> [`1.0`] 1. `net.lz1998:pbbot-spring-boot-starter` -> [`0.0.2`, `0.0.3`] 1. `org.jetbrains.dokka:dokka-cli` -> [`1.4.10.2`, `1.4.20-dev-65`] 1. `org.jetbrains.dokka:kotlin-analysis-compiler` -> [`1.4.10.2`, `1.4.20-dev-65`] 1. `org.jetbrains.dokka:kotlin-analysis-intellij` -> [`1.4.10.2`, `1.4.20-dev-65`] 1. `org.jetbrains.kotlin:kotlin-stdlib-jdk8` -> [`1.4.0-rc`, `1.4.0`, `1.4.10`, `1.4.20-M1`, `1.4.20-RC`, `1.4.20`, `1.4.21`, `1.4.30-M1`, `1.4.30-RC`, `1.4.30`] 1. `org.junit.platform:junit-platform-console-standalone` -> [`1.8.0-M1`]","closed","theme: modules,","sormuras","2021-02-25T14:44:19Z","2021-04-16T13:06:56Z"
"","2803","junit-jupiter-api imports exported packages","The `junit-jupiter-api` OSGi bundle imports its exported packages.  ## Steps to reproduce  Among others `junit-jupiter-api` OSGi bundle imports the following packages through the `Import-Package` manifest header:  - `org.junit.jupiter.api` - `org.junit.jupiter.api.extension` - `org.junit.jupiter.api.function` - `org.junit.jupiter.api.parallel`  See `junit-jupiter-api-5.8.2.jar/META-INF/MANIFEST.MF`. However these are also exported though the `Export-Package` manifest header. OSGi does not support split packages, this therefore looks like an error.  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.8.2  - Build Tool/IDE: OSGi","open","status: new,","marschall","2021-12-27T17:32:20Z","2021-12-27T17:33:00Z"
"","2109","Consider support for PostDiscoveryFilters in EngineTestKit","The `EngineTestKit` is able to execute an `EngineDiscoveryRequest`.  This implies that a `PostDiscoveryFilter` is not respected since such filters are not applied by the `EngineTestKit`. Such filters are only applied by the `Launcher` when executing multiple test engines.  For example, `TagFilter.includeTags(...)` and `TagFilter.excludeTags(...)` are not supported by the `EngineTestKit`, and if they are registered via a `LauncherDiscoveryRequest` that is passed to the `EngineTestKit`, they are silently ignored.  This issue serves as a place to discuss the options for supporting `PostDiscoveryFilter` in EngineTestKit-based integration tests.","closed","component: Test Kit,","mmerdes","2019-11-21T13:47:52Z","2020-05-22T19:52:22Z"
"","2011","Provide class-based TestEngine support","The [AbstractClassBasedTestEngine](https://github.com/sormuras/mainrunner/blob/master/src/de.sormuras.mainrunner.engine/main/java-8/de/sormuras/mainrunner/engine/AbstractClassBasedTestEngine.java) already implements the base logic needed to support a (Java) class-based `TestEngine`. Derived classes only have to specify what a test class and what a test method is, and all ""communication"" with the JUnit Platform is handled under the hood.  ## Deliverables  - [ ] Decide if JUnit Platform should provide such abstract `TestEngine` support class - [ ] Another abstract support class `AbstractAnnotationBasedTestEngine` that handles a custom method annotation.","closed","status: stale,","sormuras","2019-09-14T18:40:23Z","2021-06-19T12:50:15Z"
"","2889","Set a custom extension for `@TempDir` via a configuration parameter","Test suites using `@TempDir` usually pay a performance penalty due to the file system interaction. While this might be ok for a few tests, the penalty becomes more visible when the number of tests increases, like with AssertJ's [`Path`](https://github.com/assertj/assertj-core/tree/main/src/test/java/org/assertj/core/internal/paths) and [`File`](https://github.com/assertj/assertj-core/tree/main/src/test/java/org/assertj/core/internal/files) assertions tests.  Hitting the file system is probably not always needed, especially when working locally. An in-memory file system implementation might provide sufficient confidence and would run much faster, while the CI could verify the actual integration with a real file system.  For this reason, it would be nice if a custom extension could be set globally for the `@TempDir` annotation via a configuration parameter, similarly to the [Default Display Name Generator](https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-name-generator-default). Also, I'm not sure if this might be a different way to address #2400.  Supporting a custom extension would allow the use of in-memory file systems like [memoryfilesystem](https://github.com/marschall/memoryfilesystem) or [jimfs](https://github.com/google/jimfs), and setting that with a configuration parameter would not require the rewriting of existing test classes and methods which already rely on `@TempDir`.  I tried alternative strategies based on inheritance or test interfaces but I couldn't come up with something really satisfying, hence this feature request.   ## Deliverables  - [ ] A custom extension for the `@TempDir` annotation can be set globally via a configuration parameter.","closed","component: Jupiter,","scordio","2022-04-11T22:45:15Z","2022-04-12T13:27:15Z"
"","2402","Fix VintageMavenIntegrationTests","Test is currently disabled, because it needs to consume maven.repo system property instead of downloading from Sonatype snapshot repo or Maven local repo.","closed","theme: build,","marcphilipp","2020-09-13T13:53:33Z","2020-10-04T12:14:48Z"
"","2302","ConsoleLauncher's output in verbose mode interleaves with actual test output","Team, when running JUnit tests using the console launcher in standalone mode with `--detail verbose`, the output of the  `VerboseTreePrintingListener` gets interleaved with the test output which makes it harder to read the output.  Here is a minimal test that reproduces the problem:  ``` import org.junit.jupiter.api.Test;  import org.junit.jupiter.api.BeforeAll;  class AppTest {     @BeforeAll     public static void setupClass() {         for (int i = 0; i < 10; i++) {             System.out.println(""class setup"");         }     }      @Test     void testApp() {         for (int i = 0; i < 10; i++) {             System.out.println(""test output"");         }     } } ```  I ran this with command `java -jar junit-platform-console-standalone-1.6.2.jar -cp target/classes -cp target/test-classes --scan-classpath --details verbose` and got the following output:  ``` Thanks for using JUnit! Support its development at https://junit.org/sponsoring  Test plan execution started. Number of static tests: 1 ╷ ├─ JUnit Jupiter │  ├─ AppTest class setup class setup class setup class setup class setup class setup class setup class setup class setup class setup │  │  ├─ testApp() │  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:com.swaranga.junit5.demo.AppTest]/[method:testApp()] │  │  │     parent: [engine:junit-jupiter]/[class:com.swaranga.junit5.demo.AppTest] │  │  │     source: MethodSource [className = 'com.swaranga.junit5.demo.AppTest', methodName = 'testApp', methodParameterTypes = ''] test output test output test output test output test output test output test output test output test output test output │  │  │   duration: 15 ms │  │  │     status: ✔ SUCCESSFUL │  └─ AppTest finished after 36 ms. └─ JUnit Jupiter finished after 65 ms. ├─ JUnit Vintage └─ JUnit Vintage finished after 2 ms. Test plan execution finished. Number of all tests: 1  Test run finished after 91 ms [         3 containers found      ] [         0 containers skipped    ] [         3 containers started    ] [         0 containers aborted    ] [         3 containers successful ] [         0 containers failed     ] [         1 tests found           ] [         0 tests skipped         ] [         1 tests started         ] [         0 tests aborted         ] [         1 tests successful      ] [         0 tests failed          ] ```   This is a toy example but if my tests have some problem that prints some exceptions at startup those gets interleaved with all the test case tree details from the listener.  I think this problem occurs because the `VerboseTreePrintingListener` effectively calls `System.out.println` via a `PrintWriter` to print each line of the tree summary separately. If the actual tests are also printing things to the console, they get all mixed up.  If instead we could collect the entire summary in a `StringBuilder` and finally send it to the output stream then this problem may not occur. Another solution could be to print this summary before any test execution is started. Let me know what you think.  On a related note, the reason I am using `verbose` mode for my tests is because if a test throws any exception, JUnit 5 prints the entire stacktrace only in the verbose mode. Would it be reasonable to require other modes too to print to the console? If so, I can submit an another issue for that.","closed","component: Platform,","swaranga","2020-05-16T05:34:06Z","2020-06-06T12:26:08Z"
"","2758","Try to find root cause of failing test on Windows CI agent","tbd","closed","","marcphilipp","2021-10-29T09:52:11Z","2021-10-29T12:46:05Z"
"","2351","Reduce wait time to speed up tests","tbd","closed","","marcphilipp","2020-07-05T14:20:57Z","2020-07-19T11:05:29Z"
"","2309","Upgrade to bnd 5.1.0","tbd","closed","","marcphilipp","2020-06-02T18:22:01Z","2020-06-02T18:51:48Z"
"","2202","Upgradle to 6.2.1","tbd","closed","","marcphilipp","2020-02-29T20:03:24Z","2020-03-01T08:55:18Z"
"","2609","Make @TempDir restore mint permissions before closing context to avoid `AccessDeniedException`","Suppose the following test which throws an `AccessDeniedException`:  ```java void givesNullIfFolderNotExecutable(@TempDir Path tempFolder) throws IOException { 	Path testFile = Files.createFile(tempFolder.resolve(""test-file.txt"")); 	tempFolder.toFile().setExecutable(false);  	String result = new MyObjectUnderTest().analyzeFile(testFile);  	assertThat(result).isEqualTo(null);   // file info could not be retrieved } ```  To make this test functional i'll have to change the last line to: ``` java 	try { 		assertThat(result).isEqualTo(null); 	} finally { 		tempFolder.toFile().setExecutable(true); 	} ```  But this introduces 4 additional lines of bloat, hence decreasing brevity and readability of an otherwise simple test.  So my basic feature suggestion is to restore initial permissions on the tempFolder before trying to delete it. Bonus feature would be to have that done to any entities *within* it recursively as well, though i see a potential performance overhead concern. However, at the end of the day it would be a real win not having to think about restoring the initial state ""manually"" like i currently need to do.  Maybe there are reasons why this feature is a really bad idea, but i can't point my finger on it and am thankful for your reviews.   I am filing this as a feature rather than a bug b/c this was the default behavior in Junit4, as there is currently no standard Java API available that allows deleting a folder with such permissions.  ---  One thing to add (unrelated to feature request): Junit5 Doc explicitly encourages to provide feedback for this feature so it can be promoted, so i'd like to support that by saying i really like it b/c it provides a much better encapsulated scope than the old JUnit4-rule. It  made me discover and utilize the whole `nio` package where i enjoy the much leaner API (imho, now that i have wrapped my head around it). Hence i'd love to see it promoted to `MAINTAINED`. And *pleeaase* don't remove it, and i'm not only saying this b/c i just reworked a large test suite from Junit4 to Jupiter, but i guess that'd also be a real bummer. :wink:","closed","component: Jupiter,","Philzen","2021-05-05T20:12:08Z","2021-08-17T09:46:01Z"
"","2040","Include parameter names in default name of @ParameterizedTest","Suppose I have a test:  ```java     @ParameterizedTest     @MethodSource(""implementationsAndIps"")     public void test(String httpImplementation, String targetHost, InetAddress sourceIp,                      WireMockServer server, JMeterVariables vars) throws SocketException { ```  The result looks unreadable:  ``` [3] HttpClient4, 127.0.0.1, /127.0.0.1 [1] HttpClient4, 127.0.0.1, /fe80:0:0:0:0:0:0:1%lo0 [7] Java, 127.0.0.1, /fe80:0:0:0:0:0:0:1%lo0 [4] HttpClient4, [::1], /fe80:0:0:0:0:0:0:1%lo0 [5] HttpClient4, [::1], /0:0:0:0:0:0:0:1%lo0 [8] Java, 127.0.0.1, /0:0:0:0:0:0:0:1%lo0 [10] Java, [::1], /fe80:0:0:0:0:0:0:1%lo0 ```  It does not really help if the test fails. That means every time I use `@ParameterizedTest` I have to declare test name explicitly. That is sad.  What if JUnit generated something like  ``` [3] httpImplementation=HttpClient4, targetHost=127.0.0.1, sourceIp=/127.0.0.1 [1] httpImplementation=HttpClient4, targetHost=127.0.0.1, sourceIp=/fe80:0:0:0:0:0:0:1%lo0 ... ``` ?  It would make lots of tests and test failures easier to understand. I'm OK if it is `{arguments_with_names}`. Then I could create `@ParameterizedTestWithArgNames` annotation that uses detailed name.   PS. I've seen https://github.com/junit-team/junit5/issues/1154, however, I don't really want to deal and/or declare resolvers.","closed","theme: parameterized tests,","vlsi","2019-10-04T18:53:24Z","2019-12-05T14:38:44Z"
"","2674","Support assertDoesNotThrow() with suspending functions in Kotlin","Support for suspending functions was added for the `assertThrows()` counterpart (see #1851), but it seems like calling suspending functions in an `assertDoesNotThrow()` block is currently not supported.  ## Deliverables  - [x] Add support for calling suspending functions for all variants of `assertDoesNotThrow()`.","closed","component: Kotlin,","williamboman","2021-07-27T19:21:51Z","2021-08-17T14:57:18Z"
"","2401","Javadoc Generation for Kotlin Methods","Support for generating JavaDocs for Kotlin methods is now supported in Dokka.  I don't really have the cycles to add this myself, but I wanted to make the JUnit team aware as this question came up when the Kotlin methods were introduced.  https://github.com/Kotlin/dokka/issues/211  If this is a low/no priority issue, feel free to close this. I just wanted to make the JUnit team aware.","closed","status: stale,","JLLeitschuh","2020-09-10T18:52:53Z","2022-07-12T23:11:10Z"
"","2096","Support additional module path entries in console launcher","Support additional or alternate `--module-path` entries, similar to the already available `-cp` option:  https://github.com/junit-team/junit5/blob/master/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java#L74-L80  ## Use case  Given a directory `lib/` that contains all required modules and a _test_ module named `it`, this would allow the Console Launcher to be started like:  `java --module-path lib --module org.junit.platform.console --module-path build/test/modules --select-module it`  This enhancement is especially useful for 3rd-party tools, that make use of `""junit""` tool provider introduced via #2034 (related issue: #797).  ``` var junit = ToolProvider.findFirst(""junit""); int code = junit.run(..., ""--module-path=build/test/modules"", ""--select-module=it""); ```  ### Work-around  Create the module path a-priori using `java` options ... and spawn a new JVM for each test run:  `java --module-path lib:build/test/modules --add-modules it --module org.junit.platform.console --select-module it`  ## Deliverables  - [ ] Add option `--module-path` to [`AvailableOptions.java`](https://github.com/junit-team/junit5/blob/master/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java) - [ ] Parse passed values and create and use a custom [`ModuleLayer`](https://docs.oracle.com/javase/9/docs/api/java/lang/ModuleLayer.html) at runtime.","closed","status: stale,","sormuras","2019-11-12T10:06:34Z","2021-06-03T19:47:21Z"
"","2133","Reproduce and fix path-related warnings","Superseded by https://github.com/junit-team/junit5/commit/c7a5192d49b6e54bd067d29c45b6e4f7276a8138","closed","component: Platform,","sormuras","2019-12-18T09:21:21Z","2019-12-19T07:29:48Z"
"","2820","Document how to manage JUnit version in Spring Boot Gradle/Maven builds","Starting point: https://stackoverflow.com/a/54605523/6327046  ## Deliverables  - [x] Add subsections or notes about overriding versions in Spring Boot builds to the Gradle and Maven sections of ""Running Tests > Build Support"" in the user guide.","closed","3rd-party: Gradle,","marcphilipp","2022-02-04T11:56:58Z","2022-07-01T12:26:42Z"
"","2977","Why was #1866 closed by stalebot even though the issue was commented on?","stalebot warning: https://github.com/junit-team/junit5/issues/1866#issuecomment-1159803398 comment to keep alive: https://github.com/junit-team/junit5/issues/1866#issuecomment-1160795948 stalebot close: https://github.com/junit-team/junit5/issues/1866#issuecomment-1180830211","closed","type: question,","ephemient","2022-07-11T20:47:04Z","2022-07-12T07:56:37Z"
"","2188","Provide DynamicTestExecutor.executeSilently","Spock 2.x provides data driven tests and decided to unroll (report every child) per default. However, users have requested to be able to get the old behavior, i.e., that a data-driven tests is only reported as a single one, since they'd get thousands of test entries.  For this we would need a new method on the `DynamicTestExecutor`, @marcphilipp suggested the name `executeSilently`. This method would take care of correctly executing the task, but I wouldn't report the individual executions to the platform listener (maybe `NoOpListener`).  Failures would need to be reported to the container/parent test in some way, so that they could be properly marked as failed.  Furthermore, since the test is marked as failed if any one child failed it would be nice to kill any pending executions.  ## Deliverables  - [ ] `DynamicTestExecutor.executeSilently` - [ ] cancel all pending child executions for a failed test - [ ] communicate result to parent","closed","component: Platform,","leonard84","2020-02-17T19:55:03Z","2020-04-19T14:59:21Z"
"","2315","User Guide PDF should support special characters","Special characters (e.g., emoji from custom display names and glyphs used with `unicode` mode for the `ConsoleLauncher`) are currently broken in the generated PDF.  See discussion in https://github.com/asciidoctor/asciidoctor-pdf/issues/323.  See https://github.com/junit-team/junit5/issues/770#issuecomment-296403960.  ## Deliverables  - [x] All special characters are displayed correctly in the PDF version of User Guide","closed","theme: documentation,","marcphilipp","2020-06-05T17:52:05Z","2020-08-02T18:56:03Z"
"","2855","Feature request: Condition for headless environment","Sometimes we need to write unit tests for UI. The problem is that they will fail in a headless environment. We need a way to suppress them. One possibility is to use assumptions: ```java     @BeforeAll     static void beforeAll() {         boolean isHeadless = GraphicsEnvironment.isHeadless();         Assumptions.assumeFalse(isHeadless, ""This test is incompatible with headless environment"");     } ```  The more elegant way is to use [conditions](https://junit.org/junit5/docs/current/user-guide/#extensions-conditions). Something like  ```java @DisabledIfSystemProperty(named = ""java.awt.headless"", matches = ""true"") public class UITest { } ```  Unfortunately, this approach will not work when such property isn't set. The default value of ""headless"" property is platform dependent. On Linux, there must be ""DISPLAY"" among the environment variables, on Mac it depends on presence of the process named ""WindowServer"", on Windows there is something similar.  ## Deliverables - [ ] Implement two new JUnit conditions, `@EnabledOnHeadlessEnvironment` and `@DisabledOnHeadlessEnvironment` to easily disable some tests in a headless CI environment.","closed","type: new feature,","pbludov","2022-03-20T12:28:32Z","2022-05-29T16:11:08Z"
"","2622","Add new AnnotationBasedArgumentsProvider","Sometimes an arguments provider needs to be initialised with an annotation externally before you can call `provideArguments`. It has to implement something like `Consumer` or [`AnnotationConsumer`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.params/org/junit/jupiter/params/support/AnnotationConsumer.html). It'd be nice to have an extension point that merged `ArgumentsProvider` with `AnnotationConsumer` (something like `AnnotationBasedArgumentsProvider` so I could call `provideArguments(ExtensionContext extensionContext, A annotation)` instead of `accept(A annotation)` and then `provideArguments(ExtensionContext extensionContext)`.  An example extension that consumes an annotation is [CsvArgumentsProvider](https://github.com/junit-team/junit5/blob/main/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java). It seems `AnnotationConsumer` is only used by `ArgumentsProvider` implementations (?).  Maybe this is too simple and doesn't add much value, other than a bit of convenience.  EDIT: Another option is to not constrict the `ArgumentsProvider` in such a way (i.e.: `AnnotationConsumer` can only consume annotations) and have a more generic type parameter. This way the `ArgumentsProvider` can be initialised with anything - I recently used this approach with `Parameter`.  ## Deliverables  - [ ] A new (very simple) extension point merging `AnnotationConsumer` and `ArgumentsProvider` - [ ] Alternatively: A new extension point merging `Consumer` and `ArgumentsProvider`.","open","theme: parameterized tests,","Michael1993","2021-05-22T10:44:21Z","2022-08-02T13:01:48Z"
"","2044","Improve handling of duplicate Descriptions","Some runners don't memoize Description instances and even pass different instances when invoking testStarted and testFinished. This makes it particularly difficult when there are multiple equal Description instances in a Runner.  Prior to this commit, such cases were deemed unresolvable which lead to multiple dynamic TestDescriptors with the same unique ID being reported which is a violation of the contract of TestExecutionListener.  Now, we assume the testStarted/testSkipped event for a Description with multiple equal Descriptions is referring to the first Description that hasn't yet been started or skipped. The corresponding TestDescriptor is then reported as started/skipped. When testFinished is called for such a Description, we check whether the same thread has previously reported an equal Description as started. If so, we report the corresponding TestDescriptor as finished.  Fixes #2021.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","marcphilipp","2019-10-06T15:39:27Z","2019-10-10T18:25:15Z"
"","2800","Global configuration of the `DisplayNameGenerator`","Some config options (e.g. `@DisplayNameGeneration`) could offer a way to be configured globally.   I'm thinking `.properties` file or package-level annotations","closed","component: Jupiter,","crizzis","2021-12-20T14:29:57Z","2021-12-21T16:15:40Z"
"","2077","Reports Generate [1][34][21] Instead of DisplayName","So when using dynamic tests with nested containers, the TestSuite, Test Case DisplayName output of junit xml reporting is formatted as:  [n][n][n]  e.g., testRunner()[1][4][21]…  So when the reports are generated, there's no correlation with the Test Suite or Test Case Display Name.   This makes any of the output that worked with previous version of JUnit useless for us.","closed","component: Platform,","kirkpabk","2019-10-22T17:11:40Z","2019-10-23T17:53:43Z"
"","2022","assumptions that fail on success","So I think this might actually be a number of features. Note that assumptions might be the wrong thing, this may be a new thing entirely.  My use case is that I am developing against a spec (FHIR), I know what *should* pass, but currently some things cannot pass, I'd like to write tests for them anyways, should they someday pass I'd like to be alerted that they are passing so I can mark them as not an assumption. Currently I'm just disabling the tests. The only way I can think to do this is fail on passing assumptions (globally) so that we can know if the test is now passing.","closed","status: superseded,","xenoterracide","2019-09-23T16:37:39Z","2019-09-25T15:33:31Z"
"","2301","A way to provide the arguments ""name"" without actually having it as an argument.","So I have a parameterized test, and each parameter is a List of Beans where each bean represents a line in a csv file (opencsv). What I want for the actual ""parameterized name"" is the filename.  I'm thinking something like return   ```java Arguments.of( Named.by(file.getName()), new ArrayList<>() );  @ParameterizedTest @ArgumentsSource(MyArgumentsProvider.class) void test( List verifications ) ```  Obviously the workaround is to simply pass it as the first parameter and include it as an unused argument. I just have a dislike of unused arguments.  ```java @ParameterizedTest @ArgumentsSource(MyArgumentsProvider.class) void test( String filename, List verifications ) ```","closed","theme: parameterized tests,","xenoterracide","2020-05-15T20:00:35Z","2021-11-21T18:17:04Z"
"","2890","Support ParallelExecutionConfigurationStrategy with Turkish locale","Since Turkish have special characters as ""ı"" and ""İ"", uppercase convertion here causes all test methods to finish with exit code -1. Because uppercase of ""i"" is ""İ"" in Turkish and that breaks the code. ""dynamic"" > ""DYNAMİC""   There is a special comment for Turkish characters on reference documentation of java.lang.String:  https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#toUpperCase(java.util.Locale)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---","closed","component: Platform,","eocak","2022-04-12T14:54:38Z","2022-05-15T17:42:59Z"
"","2072","Add JDK cross-version tests for JDK >= 12","Since the main build now runs on JDK 11, we renamed cross-version workflow now compiles and tests with JDK 12, 13, and 14 using a dedicated Docker image each.","closed","","marcphilipp","2019-10-18T09:17:45Z","2019-10-18T09:30:41Z"
"","2502","Add JFR events for test discovery","Since test discovery can take a considerable amount of time, we now also report JFR events on the launcher and engine level.","closed","theme: discovery,","marcphilipp","2020-12-21T17:07:11Z","2020-12-23T16:41:12Z"
"","2443","Remove custom env vars for toolchains","Since Gradle supports SDKMAN out of the box.","closed","","marcphilipp","2020-10-06T16:51:35Z","2020-10-10T15:14:13Z"
"","2340","Provide the possibility to load spring context before class execution condition evaluation","Since `@EnabledIf` was removed from the pool of available conditions with its `loadContext()` property, it seems like there is no way to create the **test class** condition, that will be evaluated after context loading.[ It seems](https://stackoverflow.com/questions/62539203/is-there-any-way-in-junit-5-6-0-to-load-context-before-class-execution-conditi) like using deprecated annotation is the only way to bypass this restriction right now. Or using the same custom annotation on each test method.  ## Deliverables  - Writing clear context-driven conditions","closed","component: Jupiter,","CalmTechie","2020-06-25T07:28:22Z","2020-06-26T06:52:09Z"
"","2789","List observable test engines and show their properties","Similar to what `java --list-modules` prints, let's introduce a `junit --list-engines` option to the console launcher that prints an overview of observable test engines.","closed","type: new feature,","sormuras","2021-12-08T16:01:18Z","2022-04-23T11:11:42Z"
"","2926","Add Assumptions.assumeInstanceOf","Similar to the case descirbed in [issue #2482](https://github.com/junit-team/junit5/issues/2482), I also hope to skip large tests if the target object is even not of expected type, I suggest that ``assumeInstanceOf`` should be introduced.  Before conducting further tests, a validation for expected type with ``assumeInstanceOf`` can skip the tests that produce an unneccessary exception due to the wrong type. For a value potentially of several different types, using such assumptions can flexibly abort those tests not suitable for some type of the value. So it would be better if  ``Assumptions.assumeInstanceOf`` is available here similar to ``Assertions.assertInstanceOf``.  I'm quite willing to work on this feature myself and upload my pull request if accepted : )","closed","component: Jupiter,","HeaDHeaD0820","2022-05-27T13:10:00Z","2022-06-16T08:59:20Z"
"","2678","TempDir fails to cleanup x-only directory","Similar to #2171 but that bug was supposedly fixed for 5.7. I can reproduce this in 5.7.2 and 5.8.0-M1 on MacOS. I'd expect this to also work in Linux, but maybe not Windows.  If a directory within the TempDir is set x-only (ie not readable or writeable), then junit will throw an exception while cleaning up the TempDir.  ```java class ScratchTest {     @Test     void test(@TempDir Path root) throws IOException {         Path c = Files.createDirectories(root.resolve(""a/b/c""));         Files.setPosixFilePermissions(c, PosixFilePermissions.fromString(""--x--x--x""));         assertTrue(true);     } } ``` ```Jul 29, 2021 3:37:41 PM org.junit.jupiter.engine.execution.JupiterEngineExecutionContext close SEVERE: Caught exception while closing extension context: org.junit.jupiter.engine.descriptor.MethodExtensionContext@11758f2a java.nio.file.AccessDeniedException: /var/folders/1b/hmmcgv8x3wdf2zlpblp35nsh0000gn/T/junit7695927448445683366/a/b/c 	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:84) 	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102) 	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107) 	at sun.nio.fs.UnixFileSystemProvider.newDirectoryStream(UnixFileSystemProvider.java:407) 	at java.nio.file.Files.newDirectoryStream(Files.java:457) 	at java.nio.file.FileTreeWalker.visit(FileTreeWalker.java:300) 	at java.nio.file.FileTreeWalker.next(FileTreeWalker.java:372) 	at java.nio.file.Files.walkFileTree(Files.java:2706) 	at java.nio.file.Files.walkFileTree(Files.java:2742) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:192) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:180) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$closeAllStoredCloseableValues$3(ExtensionValuesStore.java:68) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList.forEach(ArrayList.java:1259) 	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395) 	at java.util.stream.Sink$ChainedReference.end(Sink.java:258) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.closeAllStoredCloseableValues(ExtensionValuesStore.java:68) 	at org.junit.jupiter.engine.descriptor.AbstractExtensionContext.close(AbstractExtensionContext.java:74) 	at org.junit.jupiter.engine.execution.JupiterEngineExecutionContext.close(JupiterEngineExecutionContext.java:53) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:222) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.cleanUp(TestMethodTestDescriptor.java:148) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.cleanUp(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$cleanUp$10(NodeTestTask.java:167) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.cleanUp(NodeTestTask.java:167) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:98) 	at java.util.ArrayList.forEach(ArrayList.java:1259) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.util.ArrayList.forEach(ArrayList.java:1259) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) ```","closed","component: Jupiter,","kjherron","2021-07-29T19:47:37Z","2021-07-30T10:05:55Z"
"","2171","TempDir fails to cleanup if directory was made read-only","Similar to #2046, but this is on Linux with JUnit 5.6.0.  If the temporary directory is read-only and not empty, then the cleanup fails.  ```java @Test public void readOnly(@TempDir File tempDir) throws IOException {     File file = tempDir.toPath().resolve(""file"").toFile();     assumeTrue(file.createNewFile());     assumeTrue(tempDir.setReadOnly());     assumeTrue(file.setReadOnly()); } ```  ``` Feb 05, 2020 12:58:01 PM org.junit.jupiter.engine.execution.JupiterEngineExecutionContext close SEVERE: Caught exception while closing extension context: org.junit.jupiter.engine.descriptor.MethodExtensionContext@62885131 java.io.IOException: Failed to delete temp directory /tmp/junit3696186363144558023. The following paths could not be deleted (see suppressed exceptions for details): , file 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.createIOExceptionWithAttachedFailures(TempDirectory.java:249) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:182) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.closeAllStoredCloseableValues(ExtensionValuesStore.java:61) 	at org.junit.jupiter.engine.descriptor.AbstractExtensionContext.close(AbstractExtensionContext.java:73) 	at org.junit.jupiter.engine.execution.JupiterEngineExecutionContext.close(JupiterEngineExecutionContext.java:53) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:222) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:57) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$cleanUp$9(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.cleanUp(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:83) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124) 	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418) 	Suppressed: java.nio.file.DirectoryNotEmptyException: /tmp/junit3696186363144558023 		at java.base/sun.nio.fs.UnixFileSystemProvider.implDelete(UnixFileSystemProvider.java:247) 		at java.base/sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:105) 		at java.base/java.nio.file.Files.delete(Files.java:1141) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:206) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.postVisitDirectory(TempDirectory.java:201) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.postVisitDirectory(TempDirectory.java:192) 		at java.base/java.nio.file.Files.walkFileTree(Files.java:2742) 		at java.base/java.nio.file.Files.walkFileTree(Files.java:2796) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:192) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:180) 		... 44 more 	Suppressed: java.nio.file.AccessDeniedException: /tmp/junit3696186363144558023/file 		at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:90) 		at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111) 		at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116) 		at java.base/sun.nio.fs.UnixFileSystemProvider.implDelete(UnixFileSystemProvider.java:249) 		at java.base/sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:105) 		at java.base/java.nio.file.Files.delete(Files.java:1141) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:206) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.visitFile(TempDirectory.java:196) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.visitFile(TempDirectory.java:192) 		at java.base/java.nio.file.Files.walkFileTree(Files.java:2724) 		at java.base/java.nio.file.Files.walkFileTree(Files.java:2796) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:192) 		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:180) 		... 44 more 		Suppressed: java.nio.file.AccessDeniedException: /tmp/junit3696186363144558023/file 			at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:90) 			at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111) 			at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116) 			at java.base/sun.nio.fs.UnixFileSystemProvider.implDelete(UnixFileSystemProvider.java:249) 			at java.base/sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:105) 			at java.base/java.nio.file.Files.delete(Files.java:1141) 			at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.makeWritableAndTryToDeleteAgain(TempDirectory.java:223) 			at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:215) 			... 50 more ```","closed","component: Jupiter,","OrangeDog","2020-02-05T13:09:19Z","2020-04-19T14:57:39Z"
"","2262","Fix dirMode and fileMode for JARs","Signed-off-by: Sebastian Davids   ## Overview  Fix https://github.com/junit-team/junit5/issues/2261 ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sdavids","2020-04-17T14:32:00Z","2020-04-19T06:57:35Z"
"","2101","do not merge","Signed-off-by: Raymond Augé   ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","rotty3000","2019-11-16T01:51:24Z","2019-11-18T19:00:33Z"
"","2499","Add an `assertInstanceOf` to Jupiter's assertions","Signed-off-by: Jan Bernitt   ## Overview   This PR adds the new assertion `assertInstanceOf`.   It is essentially a substitute for `assertTrue(obj instanceof X)` that provides a more helpful error message.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","jbee","2020-12-18T20:10:52Z","2021-01-05T08:52:13Z"
"","2131","Duplicate annotations are swallowed by AnnotationSupport","Seems to be feature we wanted?  https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java#L217-L219  This use case triggered the question:  https://github.com/junit-pioneer/junit-pioneer/pull/133/files#diff-e173b19bdf682fe079028644b4dccc43R168-R171  ## Deliverables  - [ ] Working as intended? - [ ] Bug?","closed","status: stale,","sormuras","2019-12-17T19:45:14Z","2021-06-03T19:47:30Z"
"","2153","Official Gradle Wrapper Validation GitHub Action","See: https://github.com/gradle/wrapper-validation-action","closed","","JLLeitschuh","2020-01-15T22:31:42Z","2020-01-16T03:35:23Z"
"","2152","Official Gradle Wrapper Validation GitHub Action","See: https://github.com/gradle/wrapper-validation-action","closed","","JLLeitschuh","2020-01-15T20:09:44Z","2020-01-16T03:48:11Z"
"","2513","Javadoc stylesheet is broken when using JDK 15 toolchain","see https://junit.org/junit5/docs/snapshot/api/  We should adjust the CSS stylesheet to work with JDK 15.","closed","theme: documentation,","marcphilipp","2021-01-04T13:36:46Z","2021-02-13T14:53:04Z"
"","2489","Expect only non-static methods in extension composability tests","See https://bugs.openjdk.java.net/browse/JDK-8159746 for details.","closed","","sormuras","2020-12-09T11:23:01Z","2020-12-09T14:41:05Z"
"","2810","Document new failure message argument position in JUnit 4 migration tips","See #2809.  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","rob93c","2022-01-15T15:51:15Z","2022-01-17T09:26:13Z"
"","2228","Upgrade ArchUnit to 0.13.1","See #2226   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","juliette-derancourt","2020-03-28T21:33:19Z","2020-03-29T14:05:41Z"
"","2227","Upgrade Picocli to 4.2.0","See #2226","closed","","juliette-derancourt","2020-03-28T12:32:48Z","2020-03-28T13:41:10Z"
"","2904","Running JUnit 3 test suite with JUnit Vintage engine with Gradle","Running a JUnit 3 test annotated to be run with the `AllTests` runner using JUnit 5 may not actually run the test.  ## Steps to reproduce  In our project we have quite a few JUnit 3 tests looking like:  ```java @RunWith(AllTests.class) public class JUnit3Test extends TestCase {      public static TestSuite suite()     {         var suite = new TestSuite(""JUnit 3 style test suite"");         suite.addTest(new JUnit3Test(""JUnit 3 style test"") {             @Override             protected void runTest() {                 testSomething();             }         });         return suite;     }      public void testSomething() {         ...     }      ... } ```  Currently, we're executing them using JUnit 4, but I'm trying to move to JUnit 5. When I change to `useJUnitPlatform()` in the Gradle build file these tests are no longer executed.  There's a full working example in https://github.com/ulrikls/junit-vintage-alltests  Any of these changes will successfully execute the JUnit 3 test: * Switching to JUnit 4 - i.e. `useJUnit()`  instead of `useJUnitPlatform()`. * Changing the name of the test from `JUnit 3 style test` to `testSomeLibraryMethodReturnsTrue`. * Removing the `@RunWith(AllTests.class)` annotation and the `suite()` method.  I don't know if this example is even supposed to work in JUnit 5, there doesn't seem to be a lot of documentation on running JUnit 3 tests with JUnit 5. But migrating all our JUnit 3 tests is also not trivial, as the tests currently do various stuff in the `suite()` method.   ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.2 / 4.13.2  - Build Tool/IDE: Gradle 7.4.2","open","status: new,","ulrikls","2022-05-03T12:30:38Z","2022-05-03T13:06:48Z"
"","2611","Repeated Tests should report amount of failures and succesful runs to make it more valuable","Right now it is possible to repeat tests for several iterations. It is even possible to get a lot of conect information from RepetionInfo.   In a lot of trainings and according to my own experience   something really relevant seams to be missing: Please add a possibility to get a summary or information on how many invocations are succesful and how many failed. This would be extremly useful for integration testing unreliable external systems, to get and idea of how many calls failed. Perhaps it would be nice to be able to specifiy the needed success rate, like 7 of 10 have to be successful to be considered as test pass.    Please contact me for more information: michael_inden@hotmail.com  ## Deliverables  - [ ] ...","closed","","Michaeli71","2021-05-07T19:21:17Z","2021-05-13T17:53:33Z"
"","2013","JUnit Platform Release Notes","Right now [release notes are combined](https://junit.org/junit5/docs/current/release-notes/index.html#release-notes). There is a number of issues with this approach:  * when using a custom `TestEngine` users don’t really care about JUnit changes, but care very much about platform changes; * there is no per-version changes for platform components — for example, `junit-platform-launcher` was updated to `1.5.2` recently but there is no way to find out what was changed from `1.5.1`; * relates to the previous point but it is a bit weird to see `5.x` and `1.x.x` together which is confusing for new people (it fades away once you start thinking about the platform and Jupiter / Vintage as different-level things).  Also, it might be useful to actually split all the documentation into two blocks — one is for the platform, another one for Jupiter / Vintage. I think a lot of people don’t really care about the platform since their user interactions are based around engines built on it.","closed","theme: documentation,","arturdryomov","2019-09-18T06:13:10Z","2021-03-23T05:45:42Z"
"","2063","Revise module declarations","Revise module declarations for wrong, unnecessary and superfluous directives and modifiers.  Related issue: #1939   ## Deliverables - [x] Check if `transitive` is really needed for each `requires` directive that declares it - [x] All internal packages are hidden, i.e. not exported - [x] All modules are `required` explicitly when an exported package is used directly","closed","theme: modules,","sormuras","2019-10-14T19:37:53Z","2020-01-06T09:36:06Z"
"","2369","Revert ""Fix special characters in PDF version of User Guide""","Reverts junit-team/junit5#2367 since it breaks `asciidoctorPdf`: https://ge.junit.org/s/y63ytju5pv2xa/console-log?task=:documentation:asciidoctorPdf","closed","","marcphilipp","2020-08-02T08:51:11Z","2020-10-11T07:34:44Z"
"","2939","chore: Set permissions for GitHub actions","Restrict the GitHub token permissions only to the required ones; this way, even if the attackers will succeed in compromising your workflow, they won’t be able to do much.  - Included permissions for the action. https://github.com/ossf/scorecard/blob/main/docs/checks.md#token-permissions  https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#permissions  https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs  [Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)  Signed-off-by: nathannaveen <42319948+nathannaveen@users.noreply.github.com>","open","","nathannaveen","2022-06-08T01:00:11Z","2022-07-05T13:37:37Z"
"","2956","Allow scanning classpath concurrently","Resolves #2952.","closed","","marcphilipp","2022-06-25T17:09:36Z","2022-06-26T11:09:00Z"
"","2943","Add a public factory method to instantiate ExecutionRequest","Resolves #2912","closed","component: Platform,","juliette-derancourt","2022-06-11T14:46:47Z","2022-06-18T14:25:34Z"
"","2773","Add list of shadowed artifacts to JAR and user guide","Resolves #2772.","closed","","marcphilipp","2021-11-06T18:08:09Z","2021-11-07T06:15:01Z"
"","2743","Introduce IterationSelector","Resolves #2738.","closed","type: new feature,","marcphilipp","2021-10-08T15:37:04Z","2021-11-02T16:12:04Z"
"","2684","Inline lambdas passed to assertDoesNotThrows to support suspending functions","Resolves #2674.  ## Overview  Support for suspending functions was added for the assertThrows() counterpart (see #1851), but it seems like calling suspending functions in an assertDoesNotThrow() block is currently not supported.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Kotlin,","williamboman","2021-08-11T00:26:42Z","2021-08-17T14:57:37Z"
"","2373","Document composed extension annotations","Resolves #2372.","closed","component: Jupiter,","marcphilipp","2020-08-04T15:51:32Z","2020-10-11T07:34:46Z"
"","2371","Truncate arguments in display name if they exceed max length","Resolves #2358.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","marcphilipp","2020-08-02T16:22:48Z","2020-08-03T16:08:14Z"
"","2293","Ignore implicit config params in EngineTestKit by default","Resolves #2285.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Test Kit,","marcphilipp","2020-05-10T18:01:39Z","2020-06-01T12:20:03Z"
"","2346","Introduce `TypedArgumentConverter` as a more specific `ArgumentConverter`","Resolves #2284.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","juliette-derancourt","2020-06-29T20:33:42Z","2021-08-10T17:15:18Z"
"","2639","Forbid redundant TempDir declarations","Resolves #2219.  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2021-06-07T19:58:17Z","2021-11-01T08:59:57Z"
"","2387","Close resource in inverse order of addition","Resolves #2211.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-08-18T19:31:11Z","2020-08-20T20:00:50Z"
"","2242","Reuse Launcher orchestration in EngineTestKit","Resolves #2109.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-04-05T15:06:32Z","2020-04-19T15:00:27Z"
"","2681","Change `@TempDir` to create a separate dir per declaration","Resolves #1967.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2021-08-06T10:51:38Z","2021-08-15T08:19:04Z"
"","2045","Introduce API to select and execute individual tests in inherited nested classes","Resolves #1913  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","juliette-derancourt","2019-10-06T20:45:54Z","2019-10-15T17:01:32Z"
"","2214","Introduce `@EnabledIf`/`@DisabledIf` annotations","Resolves #1911.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","juliette-derancourt","2020-03-13T19:34:50Z","2020-04-14T10:33:53Z"
"","2442","junit-platform-commons 1.7.0 does not contain MANIFEST.MF as first JAR entry (#2438)","Resolves  #2438  ## Overview  - always sort ""META-INF/"" and ""META-INF/MANIFEST.MF"" entries first  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jsedding","2020-10-06T10:13:59Z","2020-10-25T05:09:49Z"
"","2424","Tweak HTML syntax","Replace inline script by standard `...` element.","closed","","sormuras","2020-09-25T10:02:44Z","2020-09-25T15:20:29Z"
"","2047","Remove read-only files under TempDir","Removal of read-only files fails (e.g. for Windows), so the engine should try making the file writable first.  see #2046  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","vlsi","2019-10-07T10:35:52Z","2019-10-13T18:41:18Z"
"","2098","Avoid INFO logs when JUnit 4 is present in the classpath but Hamcrest is not","Related to #2004, when running Spring Framework tests in IntelliJ IDEA which now uses Gradle to run tests by default, I see this error in red each time I run tests in the `spring-webflux` modules that transitively needs JUnit 4 even if the tests are executed with JUnit Jupiter.  ``` Nov 13, 2019 5:45:42 PM org.junit.jupiter.engine.support.OpenTest4JAndJUnit4AwareThrowableCollector createAbortedExecutionPredicate INFO: Failed to load class org.junit.internal.AssumptionViolatedException: only supporting org.opentest4j.TestAbortedException for aborted execution. Note that org.junit.internal.AssumptionViolatedException requires that Hamcrest is on the classpath. java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing 	at java.base/java.lang.ClassLoader.defineClass1(Native Method) 	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016) 	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174) 	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:802) 	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:700) 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:623) 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	at org.junit.platform.commons.util.ReflectionUtils.lambda$tryToLoadClass$9(ReflectionUtils.java:779) 	at org.junit.platform.commons.function.Try.lambda$call$0(Try.java:57) 	at org.junit.platform.commons.function.Try.of(Try.java:93) 	at org.junit.platform.commons.function.Try.call(Try.java:57) 	at org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(ReflectionUtils.java:742) 	at org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(ReflectionUtils.java:698) 	at org.junit.jupiter.engine.support.OpenTest4JAndJUnit4AwareThrowableCollector.createAbortedExecutionPredicate(OpenTest4JAndJUnit4AwareThrowableCollector.java:51) 	at org.junit.jupiter.engine.support.OpenTest4JAndJUnit4AwareThrowableCollector.(OpenTest4JAndJUnit4AwareThrowableCollector.java:40) 	at org.junit.jupiter.engine.support.JupiterThrowableCollectorFactory.createThrowableCollector(JupiterThrowableCollectorFactory.java:34) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:102) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:82) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:78) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:132) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:412) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 	at java.base/java.lang.Thread.run(Thread.java:834) Caused by: java.lang.ClassNotFoundException: org.hamcrest.SelfDescribing 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	... 56 more ```  In my case, the JUnit 4 dependency comes from `com.squareup.okhttp3:mockwebserver` where `MockWebServer` extends `org.junit.rules.ExternalResource` (fairly non conventional usage I think, but that's outside of the scope of this issue), so I can't exclude the JUnit 4 dependency. But even if I could exclude this dependency, I am pretty sure there are various use cases when both JUnit Jupiter and JUnit 4 will be in the classpath without Hamcrest, so I would suggest to refine this behavior.  Could you change the log level to `DEBUG` instead of `INFO` in `OpenTest4JAndJUnit4AwareThrowableCollector`, and even maybe test the presence of the class to skip the creation of the stacktrace?","closed","theme: diagnostics,","sdeleuze","2019-11-13T16:58:09Z","2019-11-14T13:03:43Z"
"","2842","Add way to get test result in `@AfterEach`","Reference Stack Overflow: https://stackoverflow.com/questions/71354431/junit5-get-results-from-test-in-aftereach?noredirect=1#comment126124314_71354431  It makes sense to me to have some way to get the result of the test that was run in the `@AfterEach`. Pass/Fail status would be bare minimum, but would love to be able to get the exception that was thrown.  Having some object I could have as a parameter to the `@AfterEach` to give these would be fantastic.","open","status: new,","GregJohnStewart","2022-03-04T16:53:42Z","2022-03-08T20:52:06Z"
"","2081","Add typed accessor to Arguments","Recently I needed to fetch values from an `Arguments` object sourced from another method.  ```java static Stream sourceSome() {     return OtherClass.sourceOther().map(a -> {         return Arguments.of(new Some((Casted) a.get()[0]),                             new Other((Casted) a.get()[1]));     }); } ```  It will be much better if we have `Arguments#get(int index, Class type)`.  ## Deliverables  - [ ] Add typed accessor to `Arguments`.","closed","status: waiting-for-interest,","onacit","2019-10-24T01:44:20Z","2019-10-25T14:36:28Z"
"","2579","Add ability for InvocationInterceptor to intercept argument providers","Quarkus needs to run tests in its own `ClassLoader`, and it achieves this by intercepting all methods through `InvocationInterceptor` and redirecting them to a new test instance loaded from the Quarkus `ClassLoader`.   This works really well with the exception of `@MethodSource` based parameters. As there is no way to intercept that the method is invoked on the original instance, and the parameters may be loaded from the wrong `ClassLoader`.  It would be great if we could have some additional methods added to `InvocationInterceptor` to intercept this invocation as well.  ## Related Issues  - #1139 - #2191","open","status: new,","stuartwdouglas","2021-03-23T06:42:56Z","2022-07-06T20:35:33Z"
"","2682","`TypedArgumentConverter` does not support conversion of `null` source value","Providing an empty value in `@CsvSource` which will be converted using `@ConvertWith(MyCustomConverter.class)` triggers a `ParameterResolutionException` due to a `NullPointerException` in the `isAssignableFrom()` checks:  https://github.com/junit-team/junit5/blob/4cc14ee4aef0ac3e22a692bd804a2e7fe0555fd7/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/TypedArgumentConverter.java#L39-L47  ## Steps to reproduce  ```java @ParameterizedTest @CsvSource(value = { 		"","", }) public void testFoo(@ConvertWith(NoConverter.class) String input, @ConvertWith(NoConverter.class) String expectedResult) { 	Assertions.assertEquals(input, expectedResult); }  public static class NoConverter extends TypedArgumentConverter {  	protected NoConverter() { 		super(String.class, String.class); 	}  	@Override 	protected String convert(String source) throws ArgumentConversionException { 		return source; 	}  } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): junit-jupiter 5.7.2, maven-surefire-plugin 3.0.0-M5  - Build Tool/IDE: Maven/IntelliJ","closed","theme: parameterized tests,","overheadhunter","2021-08-10T08:36:15Z","2021-08-10T16:37:06Z"
"","2608","Add pre and post functions to DynamicContainer. so user have access over DynamicContainerTree execution lifecycle.","Provide the possibility to add functors before and after execution of each DynamicContainer in the dynamic test tree, so users have access to the execution life cycle e.g. populate and clean database for each DynamicContainer (generated test suite).","closed","status: stale,","yaroslav-prokipchyn","2021-05-05T09:37:54Z","2022-06-09T11:40:58Z"
"","2012","Cache methods to improve performance of TestSource creation","Prior to this commit, we scanned the hierarchy of a test class for methods once for every test method. This lead to quadratic runtime behavior and was problematic for large test classes. Now, the new `TestSourceProvider` caches the methods of a class so that we only need to filter that list once for every test method.  ## Before    ## After     Resolves #1965.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","marcphilipp","2019-09-15T09:16:32Z","2019-10-05T15:36:00Z"
"","2614","Acquire global read lock in presence of other exclusive resources","Prior to this commit, the global read lock was not acquired for test classes with `@ResourceLock` annotations causing `@Isolated` tests to run in parallel.  Fixes #2605.","closed","","marcphilipp","2021-05-13T16:23:13Z","2021-05-15T08:28:23Z"
"","2316","Always call pre-destroy callbacks if instance was created","Prior to this commit, pre-destroy callbacks were not called when an instance was created but post-processing it failed. Now, they are always called if the instance was created, regardless if any subsequent step failed.  We previously had a test that asserted the old behavior. However, IMHO the new behavior is more consistent and changing it is ok since `TestInstancePreDestroyCallback` is still experimental.  Resolves #2312.","closed","component: Jupiter,","marcphilipp","2020-06-06T12:24:14Z","2020-07-03T10:19:16Z"
"","2533","Allow publishing build scans to scans.gradle.com","Prior to this commit, only members of the JUnit team were able to publish build scans because ge.junit.org was configured as server and requires authentication. Now, CI builds for external branches publish scans to scans.gradle.com and contributors can manually publish scans by specifying Gradle's `--scan` option and accepting Gradle's terms and conditions.","closed","","marcphilipp","2021-01-16T19:37:21Z","2021-01-16T19:55:17Z"
"","2490","Ensure consistent top-level test class legacy reporting names","Prior to this commit, legacy reporting names of JUnit 3 suites were not the fully-qualified test class name but rather some textual description of the test suite (e.g. ""TestSuite with 42 tests [example: ...]""). Now, the legacy reporting name of top-level test classes reported by the Vintage engine is always the fully-qualified test class name.","closed","","marcphilipp","2020-12-11T12:26:49Z","2020-12-11T12:50:48Z"
"","2549","Make SummaryGeneratingListener thread-safe","Prior to this commit, concurrently reported failures were stored in an unguarded `ArrayList` which caused a race condition that sometimes caused failures to get lost and hence not reported. Now the list of failures is wrapped in `synchronizedList` to make it thread-safe.  Fixes #2546.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","marcphilipp","2021-02-10T21:46:55Z","2021-02-11T11:09:15Z"
"","2275","Replace illegal chars with their char reference","Prior to this commit, characters not allowed according to the XML 1.0 spec where written to the XML reports if present in exception messages etc. Now, we detect them and replace them with their character reference.  Fixes #2269.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-04-26T08:47:50Z","2020-12-27T16:36:32Z"
"","2094","Support repeatable annotations for built-in conditions","Prior to this commit, built-in conditions could not be declared multiple times for a given annotated element (i.e., class or method). This prevents users from specifying multiple system properties or environment variables for which an element should be enabled or disabled.  This commit introduces repeatable annotation support for @EnabledIfEnvironmentVariable, @DisabledIfEnvironmentVariable, @EnabledIfSystemProperty, and @DisabledIfSystemProperty.  Closes: #1793  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sbrannen","2019-11-08T17:52:40Z","2019-11-10T15:36:49Z"
"","2501","Report containers as JFR events","Prior to this commit only tests were reported as JFR events. However, it's also useful to see events for containers, e.g. test classes, in particular when they require expensive setup that causes other JFR events such as garbage collection.  Moreover, this commit adds an integration test using the new JfrUnit Jupiter extension.","closed","component: Platform,","marcphilipp","2020-12-21T09:45:18Z","2020-12-21T11:21:40Z"
"","2542","Fix container failure XML reporting","Please see individual commits.  Fixes #2537.","closed","","marcphilipp","2021-01-31T15:51:57Z","2021-02-01T18:30:35Z"
"","2728","Use JDK 17 toolchain for compilation and tests","Please refer to individual commits.","closed","type: task,","marcphilipp","2021-09-24T14:54:16Z","2021-10-12T15:09:04Z"
"","2084","Build error in Intellij","Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  ## Steps to reproduce Open project in IntelliJ Ultimate EAP 2019.3. Select Build -> Rebuild project. Observe the error  Please insert a code snippet or a link to another repo along with instructions how to reproduce the issue here. > Execution failed for task ':junit-platform-commons:jar'.  No value present  ## Context   - Used versions (Jupiter/Vintage/Platform): latest from **master** branch  - Build Tool/IDE:  IntelliJ IDEA 2019.3 EAP (Ultimate Edition) Build #IU-193.4778.7, built on October 23, 2019 IntelliJ IDEA EAP User Expiration date: November 21, 2019 Runtime version: 1.8.0_212-release-b1596 x86_64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o","closed","theme: build,","IgorGanapolsky","2019-10-25T19:56:28Z","2019-10-28T13:43:02Z"
"","2085","Console standalone failed to detect test class whose name prefix is the name of another test class.","Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  ## Steps to reproduce Consider the following project   ``` . ├── pom.xml ├── src     ├── main     │   ├── java     │   │   └── test     │   │       ├── ParserTest.java     │   │       └── ParserTestSample.java     │   └── resources     └── test         └── java  ```   ```java package test;  import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*;  public class ParserTest {      @Test     void onePlusOne() {         assertEquals(1+1, 2);     } } ```  ```java package test;  import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.assertEquals;  public class ParserTestSample {     @Test     void twoPlusTwo() {         assertEquals(2+2, 4);     } }  ```  Note that `ParserTest` is a prefix of `ParserTestSample`. `mvn clean package` the project, and run the console standalone junit jar on it: ``` java -jar ~/junit-platform-console-standalone-1.6.0-M1.jar -cp junit-test-1.0-SNAPSHOT.jar --scan-classpath ```  ``` Thanks for using JUnit! Support its development at https://junit.org/sponsoring  ╷ ├─ JUnit Jupiter ✔ │  └─ ParserTest ✔ │     └─ onePlusOne() ✔ └─ JUnit Vintage ✔  Test run finished after 61 ms [         3 containers found      ] [         0 containers skipped    ] [         3 containers started    ] [         0 containers aborted    ] [         3 containers successful ] [         0 containers failed     ] [         1 tests found           ] [         0 tests skipped         ] [         1 tests started         ] [         0 tests aborted         ] [         1 tests successful      ] [         0 tests failed          ]  ```  It's very clear that `ParserTestSample` is not detected.  `-c test.ParserTestSample` doesn't work either. `ParserTestSample` is always completely  ignored anyway.  ## Context   - Used versions (Jupiter/Vintage/Platform): ```xml     org.junit.platform     junit-platform-console-standalone     1.6.0-M1 ```","closed","","cedric-sun","2019-10-25T20:22:46Z","2019-10-25T21:16:14Z"
"","2208","Provide a utility class which allows to create TempDir programmatically in code.","Please provide a utility class which allows me to create TempDir programmatically.   I am working on a file system watching library. All my tests operates on a directory created by ```@TempDir``` extension. I mostly create some scenarios in which I create/modify some files. My scenarios started to complicate when I tried to cover symlink to different temp directory.   For now I decided to use JDK API directly: ```Path secondDirectory = Files.createTempDirectory(name);```  Utility method like bellow would be very useful in situations like mine: ```Path secondDirectory = TempDir.create();```  ## Deliverables  - TempDir utility class which creates a directory consistently with ```@TempDir``` annotation. Perfectly being aware about test context and clean the directory at the end of the test if possible.","closed","","mielecmichal","2020-03-07T13:27:46Z","2020-05-15T10:42:11Z"
"","2086","Add Arguments#append(Arguments[])","Please forgive me if I 'm missing anything already explained or provided.  I recently required to merge two instances of `Arguments` from different method sources.  ```java static Stream source1() { }  static Stream source2() { }  static Stream source3() {     return source1().flatMap(args1 -> {         return source2().map(args2 -> {             final Object[] args3 = copyOf(args1.get(), args1.get().length + args2.get().length);             arraycopy(args2.get(), 0, args3, args1.get().length, args2.get().length);             return Arguments.of(args3);         });     }); } ```   ## Deliverables  - [ ] Add `Arguments#append(Arguments...)` which returns a new instance of `Arguments` whose internal object array is a merged(concatenated) one of internal object arrays of all specified arguments.","closed","","onacit","2019-10-27T05:08:36Z","2019-10-27T06:29:25Z"
"","2100","OSGi capability namespace for TestEngines","Pending the resolution of #2095:  I would also like to see us leverage the OSGi capability mechanism in some way to define dependency relationships between test bundles and test engine bundles. That way, the resolver can help with making sure that the correct engines are included in the set of run bundles. For example, the test engine bundle could declare something like this:  ``` Provide-Capability: org.junit.platform.engine;     org.junit.platform.engine.id='junit-jupiter;version=""[5.5.1]""' # By convention, make this == TestEngine.getId()     version=5.5.1 ``` ...then the test bundle can declare its dependency on a particular versions of particular engines by (eg) the following:  ``` Require-Capability: org.junit.platform.engine;    org.junit.platform.engine.id='junit-jupiter;version=""[5.5,6)"",junit-vintage;version=4.12,org.myorg.my-test-engine;version=1.0' ```  Now the resolver will be able to ensure that the test bundles are paired with the correct versions of the correct test engines. The syntax might need a bit of tweaking (I'm not an expert in this area), but hopefully the idea makes sense.  ## Deliverables  - A specification for the capability namespace for test engine implementations. - Add the appropriate `Provide-Capability` metadata to the `junit-jupiter-engine` and `junit-vintage-engine` OSGi manifests.","closed","","kriegfrj","2019-11-15T03:38:43Z","2021-05-13T14:48:05Z"
"","1965","Test discovery is very slow with scalatest","Our tests are written in scalatest and run by adding the annotation `@RunWith(classOf[JUnitRunner])` and using the maven surefire plugin. In one test class we have 14.000 tests. These tests take roughly 4 seconds to execute but 11 minutes to discover.  The issue seems to be connected with `VintageTestDescriptor`. It tries to find the method of a test using `VintageTestDescriptor.findMethod` which in turn enumerates all methods to find the one of the test.  I see two possible solutions:  * Do not call into `ReflectionUtils.findMethods` _for every test_. This means enumerating ~14.000 methods of that class (plus suplerclass methods) 14.000 times. If we could reuse the computed `List` of a class instead of recomputing it, that would solve the problem.  * Do not enumerate all methods to find one. This would mean changing `List findMethods(Class clazz, Predicate predicate, HierarchyTraversalMode traversalMode)` and `List findAllMethodsInHierarchy(Class clazz, HierarchyTraversalMode traversalMode)` to work all the way with `Stream`s instead of `Lists`s so that we do not need to continue enumerating methods once we have found the method, by leveraging the `Stream.findFirst` method. This would help in our particular case. Most of the time is actually spent in `ReflectionUtils.isMethodShadowedByLocalMethods`, which is only called for superclass methods. All of our tests are defined in the concrete class, so we would never need to enumerate that far.  I will attach a profile of `mvn test` during the test discovery phase for a better analysis.","closed","theme: discovery,","sherfert","2019-07-24T07:55:45Z","2020-05-22T19:52:50Z"
"","2807","Please help","org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-vintage' failed to discover tests 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:160) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverSafely(EngineDiscoveryOrchestrator.java:134) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:80) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:110) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:78) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.discover(DefaultLauncherSession.java:81) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.discover(SessionPerRequestLauncher.java:46) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.(JUnit5TestReference.java:46) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestLoader.createUnfilteredTest(JUnit5TestLoader.java:76) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestLoader.createTest(JUnit5TestLoader.java:66) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestLoader.loadTests(JUnit5TestLoader.java:53) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:526) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) Caused by: org.junit.platform.commons.JUnitException: Failed to parse version of junit:junit: 4.13.2 	at org.junit.vintage.engine.JUnit4VersionCheck.parseVersion(JUnit4VersionCheck.java:54) 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:37) 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:32) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:62) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:152) 	... 15 more","closed","component: Vintage,","Nandhini3090","2022-01-05T15:10:41Z","2022-01-05T17:05:25Z"
"","2564","Improve documentation on tags in User Guide","Opening issue as requested here: https://github.com/spockframework/spock/issues/1288#issuecomment-792803341  I mean this part:   ![Screenshot_20210310_171335](https://user-images.githubusercontent.com/2794994/110660582-fbeab180-81c3-11eb-8998-8e7d24dcb532.png)  The way it is written suggests tags are a Jupiter feature, not a platform one.   I think something like:   > Jupiter test classes and methods can be tagged via the `@Tag` annotation. Other engines can support different ways like for example category annotation or configuration file or naming convention or cyclomatic complexity of a method or data about previous runs and so on. The engine translates whatever means it sees fit to a platform tag on which you then can filter.  (source https://github.com/spockframework/spock/issues/1288#issuecomment-792136881)  would make it much more clear. (Style probably needs to be improved though)","closed","component: Platform,","jakub-bochenski","2021-03-10T16:18:16Z","2021-08-15T15:49:05Z"
"","1969","Getting the values of parameters for ParameterizedTests in TestExecutionListener","On method execution of `executionStarted(...)`, `executionFinished(...)` in the `TestExecutionListener` class, it seems it's not possible to get the value of the parameters for `ParameterizedTest`, but using `displayName` attribute in the `TestIdentifier`.   **Feature request**: Add the capability to have `parameters` to the `TestIdentifier` class in order to obtain those values.  *Related to*: https://stackoverflow.com/questions/56319857/getting-the-values-of-parameters-for-parameterizedtests-in-testexecutionlistener","closed","status: stale,","drodriguezhdez","2019-07-29T15:20:58Z","2022-07-11T20:21:36Z"
"","2352","[wiki] Broken link on Third-Party Extensions page","On [this Wiki page](https://github.com/junit-team/junit5/wiki/Third-party-Extension), in the paragraph ""Engine authors may also add a minimal working example to the junit5-multiple-engines project"", the junit5-multiple-engines project link 404s. Sorry I don't know where it is supposed to link otherwise I'd have submitted a patch.","closed","","kriegfrj","2020-07-06T01:25:49Z","2020-07-06T01:51:19Z"
"","2733","Missing symmetric extension for TestInstancePreDestroyCallback (TestInstancePreCreateCallback?)","Ok, so this may sound weird but I actually do have a need for a hook that is invoked prior to test instances being created (before the test instance factory or the default machinery actually creates the test instance). This would be a symmetric counterpart to the TestInstancePreDestroyCallback extension, which seems to be missing now.  The reason for this is that I have a custom parameter resolver which takes into account the context of when it's injected. So, essentially, it'd change value when it's injected during:  - class initialization level (static initializer) and beforeall hooks - before instance constructor (or factory), - beforeeach hooks - test methods - aftereach hooks - afterall hooks  I can intercept nearly all of the above using JUnit5 extensions except for the moment prior to when new instances are created (constructor call).  A longer explanation is that I'm looking at moving the randomizedtesting framework (https://github.com/randomizedtesting/randomizedtesting) to JUnit5. I desperately try to avoid writing a custom test engine (so that I don't have to reimplement all of jupiter's extensions, etc.) but some of the new infrastructure doesn't cover the required needs. The parameter resolver above injects the randomization seed and this should be hierarchical.   I peeked at the code and it seems like this should be fairly easy to implement in ClassBasedTestDescriptor - much like the current  pre-destroy callback is implemented (or the instance post-processor). Would this be something you consider acceptable if I provided a patch?","closed","type: new feature,","dweiss","2021-09-29T09:12:18Z","2022-05-15T17:49:53Z"
"","2667","Added before and after all classes callback","Now we can add extensions for executing before all test classes and after all test classes https://github.com/junit-team/junit5/issues/456","closed","","SergKhram","2021-07-20T06:34:16Z","2021-09-25T10:06:11Z"
"","2313","Switch to Rouge as Asciidoctor syntax highlighter","Now that https://github.com/asciidoctor/asciidoctorj/issues/429 is resolved, we can switch to Rouge, assuming it works on Windows.  @sormuras Could you please run `./gradlew asciidoctor asciidoctorPdf` to check the result on Windows?  Resolves #777.","closed","","marcphilipp","2020-06-04T17:00:36Z","2020-06-04T19:01:35Z"
"","2310","Dummy change to trigger LGTM build","Nothing to see here...","closed","","marcphilipp","2020-06-02T18:58:35Z","2020-06-02T19:48:48Z"
"","2125","Consider removing bin/ build/ out/ and */out/* patterns from .gitignore","Note: `.gitignore` patterns are not tied to the location of `.gitignore` file by default.  In other words, `build/` ignores `build` folders in all the possible subfolders. In other words, if one day someone creates `org.junit.build.tools` Kotlin/Java package, then it would be excluded as well.  It might result in sad stories up to the point when the code might be lost (e.g. developer thinks the code is kept in Git, but in fact it is not there).  In the same way, `*/out/*` duplicates `out/` pattern.  Git enables to specify paths ""relative to .gitignore location"" by prefixing the patterns with `/`  So I suggest to use the following:  ``` /build/ /*/build/  /out/ /*/out/  /bin/ /*/bin ```  See also https://twitter.com/phillip_webb/status/1202820013905727488","closed","theme: build,","vlsi","2019-12-11T18:35:45Z","2019-12-14T13:18:08Z"
"","2979","Spring MockMvc Only Pass Get Method request other method(POST,PATCH,PUT,DELETE) denied","My Unittest Code   ```java = @WebMvcTest(value = BankAcctController.class) class BankAcctControllerTest {     private HttpSessionCsrfTokenRepository httpSessionCsrfTokenRepository;     private CsrfToken csrfToken ;     @Autowired     private MockMvc mockMvc;     @Autowired     private WebApplicationContext webApplicationContext;     @BeforeEach     public void setup()     {         //Init MockMvc Object and build         mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();         httpSessionCsrfTokenRepository = new HttpSessionCsrfTokenRepository();         csrfToken=httpSessionCsrfTokenRepository.generateToken(new MockHttpServletRequest());     }     @MockBean     private BankAcctService bankAcctService;     @Test     void allBank_accts() throws Exception{//Pass         String URI = ""/api/bank_accts"";         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         User _user2 =new User(2,""user2"",""user2@mail.com"",""user2"",""user2"",""user2"",false,""001"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);         Bank_acct b2=new Bank_acct(1,_bankType,""001"",_user2);          List bankList = new ArrayList();         bankList.add(b1);         bankList.add(b2);         String jsonInput = this.convertToJson(bankList);          Mockito.when(bankAcctService.findAll()).thenReturn(bankList);         MvcResult mvcResult = this.mockMvc.perform(MockMvcRequestBuilders.get(URI).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON))                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();         System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""List Test Complete"");     }      @Test     void getBank_acctByUsername() throws Exception {//Pass         String username = ""user1"";         String URI = ""/api/back_acct/username/""+username;         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);          String jsonInput = this.convertToJson(b1);          Mockito.when(bankAcctService.getBank_acctByUsername(""user1"")).thenReturn(new ResponseEntity<>( b1, HttpStatus.OK));         MvcResult mvcResult = this.mockMvc.perform(MockMvcRequestBuilders.get(URI).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON))                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Get By Username Test Complete"");     }      @Test     void getBank_acctById() throws Exception {//Pass         String Id = ""1"";         String URI = ""/api/bank_acct/""+Id;         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);          String jsonInput = this.convertToJson(b1);          Mockito.when(bankAcctService.getBank_acctById(1)).thenReturn(new ResponseEntity<>( b1, HttpStatus.OK));         MvcResult mvcResult = this.mockMvc.perform(MockMvcRequestBuilders.get(URI).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON))                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Get By Id Test Complete"");     }      @Test     void createBank_acct() throws Exception {         String URI = ""/api/back_acct"";         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acctDTO bank_acctDTO = new Bank_acctDTO(1,""000"",1);         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);          String InputDTO = this.convertToJson(bank_acctDTO);         String jsonInput = this.convertToJson(b1);          Mockito.when(bankAcctService.createBank_acct(any())).thenReturn(new ResponseEntity<>(b1, HttpStatus.CREATED));         MvcResult mvcResult = this.mockMvc.perform(post(URI)                         .accept(MediaType.APPLICATION_JSON)                         .content(InputDTO)                         .contentType(MediaType.APPLICATION_JSON))                 .andDo(print())                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Complete Test Create Bank Acct"");     }      @Test     void patchBank_acct() throws Exception {         String Id = ""1"";         String URI = ""/api/back_acct/""+Id;         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);         String jsonInput = this.convertToJson(b1);          Mockito.when(bankAcctService.patchBank_acct(1,b1)).thenReturn(new ResponseEntity<>(b1, HttpStatus.OK));         MvcResult mvcResult = this.mockMvc. perform(MockMvcRequestBuilders.patch(URI)                         .accept(MediaType.APPLICATION_JSON)                         .content(jsonInput).contentType(MediaType.APPLICATION_JSON)                         .sessionAttr(""UNITTEST"", csrfToken)                         .param(csrfToken.getParameterName(), csrfToken.getToken()))                         .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput); //        assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Complete Test Patch Bank Acct"");     }      @Test     void patchUserBankAcct() throws Exception {         String URI = ""/api/back_acct/user"";         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acctDTO bank_acctDTO = new Bank_acctDTO(1,""000"",1);         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);          String InputDTO = this.convertToJson(bank_acctDTO);         String jsonInput = this.convertToJson(b1);           Mockito.when(bankAcctService.patchUserBankAcct(bank_acctDTO)).thenReturn(new ResponseEntity<>(b1, HttpStatus.OK));         MvcResult mvcResult = this.mockMvc. perform(MockMvcRequestBuilders.patch(URI).accept(MediaType.APPLICATION_JSON).content(InputDTO).contentType(MediaType.APPLICATION_JSON))                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Complete Test Patch Bank Acct By User"");     }      @Test     void updateBank_acct() throws Exception {         String Id = ""1"";         String URI = ""/api/back_acct/""+Id;         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acctDTO bank_acctDTO = new Bank_acctDTO(1,""000"",1);         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);          String InputDTO = this.convertToJson(bank_acctDTO);         String jsonInput = this.convertToJson(b1);           Mockito.when(bankAcctService.updateBank_acct(1,b1)).thenReturn(new ResponseEntity<>(b1, HttpStatus.OK));         MvcResult mvcResult = this.mockMvc. perform(MockMvcRequestBuilders.put(URI).accept(MediaType.APPLICATION_JSON).content(jsonInput).contentType(MediaType.APPLICATION_JSON))                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Complete Test Put Bank Acct By Id"");     }      @Test     void delete() throws Exception {         Long LongId= Long.valueOf(1);         String Id = ""1"";         String URI = ""/api/back_acct/""+Id;         Role _role = new Role(1,""User"");         User _user1 =new User(1,""user1"",""user1@gmail.com"",""user1"",""user1"",""user1"",false,""000"",new HashSet(),null);         Bank_type _bankType = new Bank_type(1,""Test1Bank"",""001"");         Bank_acctDTO bank_acctDTO = new Bank_acctDTO(1,""000"",1);         Bank_acct b1=new Bank_acct(1,_bankType,""000"",_user1);          String jsonInput = this.convertToJson(""Delete Complete"");          Mockito.when(bankAcctService.deleteById(LongId)).thenReturn(new ResponseEntity<>(""Delete Complete"",HttpStatus.OK));         MvcResult mvcResult = this.mockMvc. perform(MockMvcRequestBuilders.delete(URI).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON))                 .andDo(print())                 .andReturn();         MockHttpServletResponse mockHttpServletResponse = mvcResult.getResponse();         String jsonOutput = mockHttpServletResponse.getContentAsString();          System.out.println(""Input:""+jsonInput);         System.out.println(""Output:""+jsonOutput);         assertThat(jsonInput).isEqualTo(jsonOutput);         System.out.println(""Complete Test Delete Bank Acct By Id"");     }      private String convertToJson(Object bankAcct) throws JsonProcessingException {         ObjectMapper objectMapper = new ObjectMapper();         return objectMapper.writeValueAsString(bankAcct);     } } ```  ----  The Testing Result of DELETE  ----  ``` bash =   MockHttpServletRequest:       HTTP Method = DELETE       Request URI = /api/back_acct/1        Parameters = {}           Headers = [Content-Type:""application/json"", Accept:""application/json""]              Body =      Session Attrs = {}  Handler:              Type = null  Async:     Async started = false      Async result = null  Resolved Exception:              Type = null  ModelAndView:         View name = null              View = null             Model = null  FlashMap:        Attributes = null  MockHttpServletResponse:            Status = 404     Error message = null           Headers = []      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = [] Input:""Delete Complete"" Output:  ```  But it is very strange Unittest only can access all the Get method but POST PUT PATCH DELETE cannot access all of them will reply 404","closed","status: invalid,","fan9704","2022-07-15T06:40:05Z","2022-07-15T08:18:11Z"
"","2088","Provide support for setting a custom parent directory for @TempDir","My project requires that I do not write to `/tmp` or whichever location it is when I use the [`TempDirectory` extension](https://junit.org/junit5/docs/current/user-guide/#writing-tests-built-in-extensions-TempDirectory). So right now I have no choice but to still use [`junit-pioneer`'s implementation](https://junit-pioneer.org/docs/temp-directory/), e.g. like this:   ```java @RegisterExtension Extension tempDirectory = TempDirectory.createInCustomDirectory(() -> Paths.get(""build""));   @BeforeEach void setup(@TempDir Path testProjectDir) {     // Do something with ""testProjectDir"". } ```  But it would be nicer if I could just use stock JUnit 5 for this. JUnit 4 supported setting the parent dir, so I find the JUnit 5 way a bit too limiting.  Thanks in advance.","open","status: waiting-for-interest,","rkrisztian","2019-10-29T18:38:35Z","2022-07-27T12:35:19Z"
"","1979","Move LegacyReportingUtils to junit-platform-reporting","Moved LegacyReportingUtils from junit-platform-launcher to junit-platform-reporting as being more appropriate. Old implementation in the launcher package left in place for compatibility with 3rd party code, but deprecated for future removal. Resolves #1978.  Left the old unit test in-place to guard against regressions. Future dev should be done in the new copy.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","theme: reporting,","kriegfrj","2019-08-12T12:18:21Z","2020-03-02T23:59:19Z"
"","2969","DisplayNameGenerator should be able to fall back to default","Motivation :   Having the configuration can be useful to fallback on the default DisplayNameGenerator      Example :   ```java @DisplayNameGeneration(MyTest.MyDisplayNameGenerator.class) public class MyTest {      @Test     @MyDisplayName(""My display name"")     public void test1() {         // a test     }      @Test     public void test2() {         // a test     }      static class MyDisplayNameGenerator implements DisplayNameGenerator {          @Override         public String generateDisplayNameForClass(Class testClass, JupiterConfiguration configuration) {             return configuration.getDefaultDisplayNameGenerator().generateDisplayNameForClass(testClass, configuration);         }          @Override         public String generateDisplayNameForNestedClass(Class nestedClass, JupiterConfiguration configuration) {             return configuration.getDefaultDisplayNameGenerator().generateDisplayNameForNestedClass(nestedClass, configuration);         }          @Override         public String generateDisplayNameForMethod(Class testClass, Method testMethod, JupiterConfiguration configuration) {             Optional optional = findAnnotation(testMethod, MyDisplayName.class);             return optional.map(MyDisplayName::value)                     .orElseGet(() -> configuration.getDefaultDisplayNameGenerator().generateDisplayNameForMethod(testClass, testMethod, configuration));         }              }  } ```","open","theme: discovery,","d-william","2022-07-06T19:12:46Z","2022-07-09T19:00:22Z"
"","2968","DisplayNameGenerator methods should have class test instance as parameter","Motivation :  Having this instance can be useful to generate dynamic display name.      Example :  ```java @DisplayNameGeneration(MyTest.MyDisplayNameGenerator.class) public class MyTest {          @Test     public void test() {         // a test     }          public String displayName() {         return ""a dynamic test name"";     }          public static class MyDisplayNameGenerator extends DisplayNameGenerator.Standard {                  @Override         public String generateDisplayNameForMethod(Class testClass, Method testMethod, Object testClassInstance) {             MyTest myTest = (MyTest) testClassInstance;             return myTest.displayName();         }              }      } ```  Or maybe we could customize the DisplayNameGenerator via its constructor ?","closed","component: Jupiter,","d-william","2022-07-06T19:05:29Z","2022-07-07T05:43:05Z"
"","2546","MutableTestExecutionSummary.failures is not thread safe","module: junit-platform-launcher version: 1.7.1  When running test in multiple threads, the failures recorded might be less than the actual failures.  As a workaround, I could implement my own ConcurrentSummaryListener, like below  ``` java public class ConcurrentSummaryListener extends SummaryGeneratingListener {      private ReentrantLock reentrantLock = new ReentrantLock();      @Override     public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {         boolean needLock = testExecutionResult.getStatus() == TestExecutionResult.Status.FAILED;          try {             if (needLock) {                 reentrantLock.lock();                 super.executionFinished(testIdentifier, testExecutionResult);             }         } finally{             if (needLock) {                 reentrantLock.unlock();             }         }     } } ```","closed","component: Platform,","DuanYuePeng","2021-02-07T03:47:20Z","2021-02-11T11:41:22Z"
"","2779","[reflection] ReflectionSupport to return Streams","Methods like `ReflectionSupport.findField` currently return a `List`.  Under-the-hood, the utils typically use streams and then copy all the elements into a list to return.  Very often, users of `findfield()` only need to iterate once through the returned list of fields (in some of my implementations, I've called stream() or forEach() on the result). Storing the stream of fields in an intermediate `List` is unnecessary buffering overhead in those cases.  ## Deliverables  * A set of methods with a signature like `Stream findFieldsAsStream()`. * Refactor the existing `List findFields()` to delegate to its equivalent streaming method and call `toList()` on the stream. * Refactor existing usage in the JUnit 5 codebase where the stream interface would be more appropriate and efficient.  Thoughts?","open","component: Platform,","kriegfrj","2021-11-12T02:04:27Z","2021-11-30T10:51:39Z"
"","2119","Allow @RepeatedTest to stop upon failure","Many a times when a particular test is a failing once in a while (i.e. not consistently), I use the `@org.junit.jupiter.api.RepeatedTest` with a relatively high number like `10`:  ``` @RepeatedTest(10) ``` and trigger the tests to try and reproduce the issue. Some of these 10 runs will fail (as expected). However, the only reason I used the `@RepeatedTest` was to reproduce a failure and once that failure has occurred, I'm not really interested in running the remaining number of ""count"" that was passed to it.  Would it be a good idea to introduce something like `stopOnFailure` attribute (which can be set to `true`, but defaults to `false`) to this `@RepeatedTest` so that it considers the `value` count as the maximum number of times to run the test and if `stopOnFailure` is set to `true` then stops as soon as the first run within those 10 runs fails?","open","status: waiting-for-interest,","jaikiran","2019-12-03T01:57:28Z","2022-05-25T21:11:40Z"
"","2033","Module org.junit.platform.launcher does not read module java.logging","Manual testing shows that module `org.junit.platform.launcher`'s missing a `requires java.logging;` directive.  ``` Caused by: java.lang.IllegalAccessError:  class org.junit.platform.launcher.listeners.LoggingListener (in module org.junit.platform.launcher)  cannot access class java.util.logging.Level (in module java.logging) because module org.junit.platform.launcher does not read module java.logging 	at org.junit.platform.launcher@1.5.2/org.junit.platform.launcher.listeners.LoggingListener.forJavaUtilLogging(LoggingListener.java:49) 	at integration@1/integration.Main.run(Main.java:38) ```  ## Deliverables  - [x] Add `requires java.logging;` directive - [x] Verify no other directive is missing ~~(by implementing #1939 ?)~~","closed","theme: modules,","sormuras","2019-09-27T00:50:20Z","2019-09-27T11:35:55Z"
"","2551","POM of Jupiter Engine 5.8.0-M1 depends on Kotlin","Loading ""JUnit 5.8.0-M1"" via IDEA's libraries support for Maven-based artifacts shows... ![image](https://user-images.githubusercontent.com/2319838/107858799-5d726700-6e36-11eb-95aa-88e31ef4a367.png)  ...that `org.junit.jupiter:junit-jupiter:5.8.0-M1` has a hard dependency on **Kotlin** (stdlib, stdlib-7, stdlib-8, stdlib-common) and also **JetBrains Annotations**.  ## Deliverables  - [x] Remove the following lines from the generated [`pom.xml`](https://search.maven.org/remotecontent?filepath=org/junit/jupiter/junit-jupiter-engine/5.8.0-M1/junit-jupiter-engine-5.8.0-M1.pom)  ```xml    org.jetbrains.kotlin   kotlin-stdlib-jdk8   1.4.20   compile  ```","closed","component: Jupiter,","sormuras","2021-02-13T19:09:38Z","2021-02-13T20:16:14Z"
"","2136","Create module API overview page","Like can be seen at the [API of JDK 11](https://docs.oracle.com/en/java/javase/11/docs/api):  > ![image](https://user-images.githubusercontent.com/2319838/71244332-8b334d00-2312-11ea-965c-e421b70d0601.png)  `javadoc` supports creating a modular overview page. At the moment, we prevent that page from being created via `--no-module-directories`.  JUnit's overview page could look like:  ``` | All Modules | Jupiter | Platform | Vintage | +-------------+---------+----------+---------+--- | Module                  Description +------------------------------------------------ | org.junit.jupiter       The aggregator module of the JUnit Jupiter API. | org.junit.jupiter.api   JUnit Jupiter API for writing tests. | ... +------------------------------------------------ ```  Might supersed #2056  ## Deliverables  - [x] Drop `--no-module-directories` and get the overview page generated and uploaded.","closed","theme: modules,","sormuras","2019-12-20T09:26:49Z","2020-01-19T18:23:53Z"
"","2596","Update ArchUnit to 0.18.0","just waiting for CI's verdict...","closed","","marcphilipp","2021-04-15T07:18:31Z","2021-04-15T18:05:11Z"
"","2400","Support custom file system for `@TempDir`","Jupiter's `@TempDir` does not allow the configuration of custom file systems. It would be nice if it would.  A key motivation for me to open this issue is that custom file systems are the only thing that Pioneer's `@TempDir` can do that Jupiter's can't. Since Jupiter's is quite a bit more powerful than ours now, we'd like to remove our extension (this also prevents confusion for users), but we don't feel comfortable doing that as long as there's a feature we offer that you don't.  If Jupiter isn't fundamentally opposed to such a feature, we could implement it and open a PR.","open","status: waiting-for-interest,","nipafx","2020-09-08T19:09:22Z","2022-05-23T05:30:38Z"
"","2198","JUnit4VersionCheck fails on a version string ""4.12.0.redhat-003""","junit-vintage-engine does not recognize junit4 built under a version ""4.12.0.redhat-003"" and fails fast in JUnit4VersionCheck [1].  ## Steps to reproduce 1. In a maven project, include junit of version ""4.12.0.redhat-003"" on classpath together with junit-vintage-engine as test dependencies.  2. mvn test -> as a result, no tests are run  Additional information: based on maven-surefire-plugin version, either no hint is given at all (surefire version 2.22.1) or a stacktrace (2.22.2 and above) is provided, clearly leading to [1].  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.5.2  - Build Tool/IDE: maven  ## Deliverables  Expected: parse the aforementioned version string, discover the junit4 engine on classpath and run tests.  [1] https://github.com/junit-team/junit5/blob/master/junit-vintage-engine/src/main/java/org/junit/vintage/engine/JUnit4VersionCheck.java#L54","closed","component: Vintage,","rsynek","2020-02-25T14:54:03Z","2020-10-26T19:21:19Z"
"","2877","Vintage tests annotated with both @Category and @UseModules should not activate @UseModules when Category is excluded","junit-vintage-engine 5.8.2   Code contains a test (including Jukito code) annotated as follows:  ``` @Category(SystemTests.class) @UseModules(SomeModule.class) public class SomeTest { ... }   ``` Maven has a rule that excludes SystemTests, for example:  ```                                      org.apache.maven.plugins                     maven-surefire-plugin                     3.0.0.M5                                                                           mypackage.SystemTests                                                                 ```  ## Steps to reproduce Under a plan JUnit4 environment, the test is excluded and there are no errors. Running the same code under jupiter vintage generates errors from the class SomeModule, which is attempting to run Sytem Tests in a context not intended for that. In other words if a test is excluded the @UseModules annotation should not invoke the Module code.    ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.2  - Build Tool/IDE: maven command line  ## Deliverables  - [ ] ...","open","status: new,","rsivan","2022-04-05T18:19:51Z","2022-04-12T16:46:41Z"
"","2983","passing parameterised test arguments into @BeforeEach fails when run in parallel","junit-version: 5.8.2 junit-launcher-version: 1.8.2  I'm using the solution from https://code-case.hashnode.dev/how-to-pass-parameterized-test-parameters-to-beforeeachaftereach-method-in-junit5 to pass @ParameterizedTest arguments into @BeforeEach  I'm doing this to be able to create a test where I can use an annotation to specify one or more browsers for a selenium test. Full code can be found here: https://github.com/jflorez-planittesting/junit5-parallel-multibrowser-bug  ## Steps to reproduce 1. Clone https://github.com/jflorez-planittesting/junit5-parallel-multibrowser-bug  2. set properties->parallel-test to false in the pom.xml  3. run mvn test. This will show you the expected behaviour4.  4. set properties->parallel-test to true in the pom.xml 5. run mvn test. This will demonstrate the problem when running in parallel  ## Context  - junti-plaform version: 1.8.2 - IDE vscode but example of the bug can be run with maven - JDK 17 - maven 3.8.6  ## Deliverables  - https://github.com/jflorez-planittesting/junit5-parallel-multibrowser-bug","closed","component: Jupiter,","jflorez-planittesting","2022-07-25T09:24:50Z","2022-08-01T07:56:48Z"
"","2390","JUnit 5 computes overrides relationships incorrectly","junit-platform-commons:1.6.0  ```java package foo;  import org.junit.jupiter.api.BeforeEach;  public class Foo {     @BeforeEach     final void beforeEach() {         System.out.println(""foo"");     } } ```  ```java package bar;  import foo.Foo; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test;  class Bar extends Foo {     @BeforeEach     final void beforeEach() {         System.out.println(""bar"");     }      @Test     final void test() { } } ```  This outputs  ``` bar ```  but should output  ``` foo bar ```  The reason it does not output `foo` is because `ReflectionUtils.isMethodShadowedBy` is used to compute overrides while scanning for all methods in a class hierarchy. That considers only the signature of the method which is not sufficient according to the language specification, https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8.1  The reason why I care about this is because I want to declare a `@BeforeEach` method in a super class and always have it execute regardless of what subclasses are doing.","closed","","tjwilson90","2020-08-22T01:30:39Z","2022-05-10T13:04:30Z"
"","2355","@ParameterizedTest does not fire any events in TestWatcher","JUnit version: 5.6.0  ## Steps to reproduce Our team develops a reporting tool (ReportPortal) and for sake of reporting we need to know when JUnit 5 skips tests. For regular `@Test` methods we can use `org.junit.jupiter.api.extension.TestWatcher.testDisabled` to catch disabled tests, but `@ParameterizedTest` does not trigger any methods in TestWatcher.  A test example: ```java package junit5.features.parameters;  import org.junit.jupiter.api.Disabled; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.EnumSource;  public class EnumParametersTest {  	public enum TestParams { 		ONE, 		TWO 	}  	@Disabled(""my disable reason"") 	@ParameterizedTest 	@EnumSource(TestParams.class) 	public void testParameters(TestParams param) { 		System.out.println(""Test: "" + param.name()); 	} }  ```  ## Context   - Used versions:    - org.junit.jupiter:junit-jupiter-api:5.6.0    - org.junit.jupiter:junit-jupiter-params:5.6.0    - org.junit.jupiter:junit-jupiter-engine:5.6.0    - org.junit.platform:junit-platform-launcher:1.6.0    - org.junit.platform:junit-platform-runner:1.6.0  - Build Tool/IDE:    - IntelliJ IDEA","closed","component: Jupiter,","HardNorth","2020-07-13T13:06:53Z","2020-07-29T08:51:19Z"
"","2358","Excessively long argument values in parameterized display names should be truncated","JUnit provides a nice way to configure test names, however, the names might become too long unexpectedly.  Here's a case for JUnit4:  https://github.com/pgjdbc/pgjdbc/blob/aa190cce2c27ac5f5d4fa33f5d156f8bf04cbe0c/pgjdbc/src/test/java/org/postgresql/core/UTF8EncodingTest.java#L29-L33  ```java   @Parameterized.Parameters(name = ""string={1}, encoding={0}"")   public static Iterable data() {     final StringBuilder reallyLongString = new StringBuilder(1024 * 1024);     for (int i = 0; i < 185000; ++i) {       reallyLongString.append(i);     } ```  I guess the same is relevant for JUnit5 as well.  It would be great if JUnit could detect such cases, and it could trim the sub-parts before it produces a single multi-megabyte test name.  For instance, in the case like above JUnit could produce something like `string=012345678910111213...truncated...sha1=12312312123, encoding=utf-8`  It turns out the long test names consume disk space as Gradle records all the test outputs, and it does make `remote build cache` slower, as the build cache has to keep all the long test names (so it impacts `cache space consumption`, `cache store latency` and `cache retrieval latency`).  Of course, users can truncate test names on their own, however, I believe it would be better if JUnit prevented ""unexpectedly long test name"" issue automatically.  In other words:  1) If use is using placeholder-like pattern, then JUnit should trim all the parameters. 2) If the user returns test name via programmatic API (I'm not sure if that exists at all, but I assume it does :) ), then JUnit could truncate the full string. 3) There should probably be a configuration option for the default limit of the parameter value.  WDYT?  Relevant Gradle Build Cache issue: https://github.com/gradle/gradle/issues/13608#issuecomment-660874776","closed","theme: parameterized tests,","vlsi","2020-07-20T08:37:32Z","2020-08-03T16:53:09Z"
"","2603","org.junit.platform.testkit is not compatible with latest version of AssertJ","Junit Platform 1.7.1, AssertJ 3.19.0 ->  ``` java.lang.NoSuchMethodError: org.assertj.core.api.SoftAssertions.fail(Ljava/lang/String;)V  	at org.junit.platform.testkit.engine.Events.checkCondition(Events.java:455) 	at org.junit.platform.testkit.engine.Events.assertEventsMatchLoosely(Events.java:420) 	at org.junit.platform.testkit.engine.Events.assertEventsMatchLoosely(Events.java:301) ```","closed","component: Test Kit,","jlink","2021-04-27T12:53:36Z","2021-05-13T13:36:12Z"
"","2029","Not able to create multiple @TempDir in a testcase","JUnit annotation @TempDir does not create multiple temporary directories. After initialization of two or more variables annotated with @TempDir all of them hold one and the same reference to a temporary path in the filesystem – actually only one temporary diectory has been created.  ## Steps to reproduce  Just implement a sample code snippet as follwing (no difference between non-private field in a test class or a parameter in a lifecycle method):  Example 1: public class MyTest { @TempDir Path one;  @TempDir Path two; ... }  Example 2: @Test public void myTest(@TempDir Path one, @TempDir Path two) {...}  ## Context - Used versions (Jupiter/Vintage/Platform):  	org.junit.jupiter 	junit-jupiter-api 	5.5.2 	test   	org.junit.jupiter 	junit-jupiter-engine 	5.5.2 	test   - Used versions (Jupiter/Vintage/Platform):   - Build Tool/IDE: Apache Maven 3.6.0 Spring Tool Suite 4.4.0.RELEASE (Eclipse)  ## Deliverables  - [ ] ...","closed","component: Jupiter,","joh-ku","2019-09-26T07:40:05Z","2019-09-26T08:24:26Z"
"","2114","JUnit Vintage distributes tests very unevenly between forks, causing poor parallelism","Junit 5.6.0-M1  ## Steps to reproduce  Run the following test case with `mvn clean verify`: [junit-5-vintage-bug.zip](https://github.com/junit-team/junit5/files/3891165/junit-5-vintage-bug.zip)  Observe output like the following: ```[INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running My7Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.017 s - in My7Test [INFO] Running My9Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.983 s - in My9Test [INFO] Running My4Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.998 s - in My4Test [INFO] Running My8Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.999 s - in My8Test [INFO] Running My6Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.001 s - in My6Test [INFO] Running My1Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1 s - in My1Test [INFO] Running My5Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.999 s - in My5Test [INFO] Running My3Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.997 s - in My3Test [INFO] Running My2Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1 s - in My2Test [INFO] Running My0Test Test in process 32569 [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.999 s - in My0Test ```  Notice how all the tests are being run on the same process. This is wrong because there should be 5 forks - and the tests should be evenly distributed between them.  If Junit4 is used instead of Junit5+vintage (see the commented dependency in `pom.xml`) then this issue does not occur.  Thanks for any help :cake:","closed","3rd-party: Maven Surefire,","Dretch","2019-11-26T10:01:31Z","2019-11-26T10:53:20Z"
"","2231","Tests count is 1 if there is  failure in @BeforeAll setup method","Junit 5.6.0 maven-surefire-plugin --> 2.22.0  ## Steps to reproduce  @TestInstance(TestInstance.Lifecycle.PER_CLASS) public class MultipleTests {  	@BeforeAll 	public static void beforeAll() {  		System.out.println(""beforeAllFirstTest() executed!"");  		assertTrue(false);  	}  	@Test 	public void testMethod1() { 		System.out.println(""testMethod1() executed!""); 	}  	@Test 	public void testMethod2() { 		System.out.println(""testMethod2() executed!""); 	}  	@AfterEach 	public void tearDown(TestInfo testInfo) throws Exception { 		System.out.println(""tearDown executed!""); 		System.out.println(""<-- tearDown executed!"" +"" --> "" +testInfo.getDisplayName()); 		 		 	}  	@AfterAll 	public static void afterAll() {  		System.out.println(""afterAllFirstTest() executed!""); 		  	}    Actual Result:  ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running org.siddu.cases.group.MultipleTests beforeAllFirstTest() executed! afterAllFirstTest() executed! [ERROR] Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.031 s <<< FAILURE! - in org.siddu.cases.group.MultipleTests [ERROR] org.siddu.cases.group.MultipleTests  Time elapsed: 0.03 s  <<< FAILURE! org.opentest4j.AssertionFailedError: expected:  but was:   	at org.siddu.cases.group.MultipleTests.beforeAll(MultipleTests.java:21) [INFO]  [INFO] Results: [INFO]  [ERROR] Failures:  [ERROR]   MultipleTests.beforeAll:21 expected:  but was:  [INFO]  [ERROR] Tests run: 1, Failures: 1, Errors: 0, Skipped: 0 [INFO]  [ERROR] There are test failures.  With this test count issue, in Jenkins we are getting variations in the total count on each run. We can mark the tests inside the class container as failed or skipped. Expected Result:  1. [ERROR] Tests run: 2, Failures: 2, Errors: 0, Skipped: 0 OR 2. [SKIPPED] Tests run: 2, Failures: 0, Errors: 0, Skipped: 2","closed","3rd-party: Maven Surefire,","ksiddu","2020-04-02T02:11:30Z","2020-04-02T07:41:54Z"
"","2030","Vintage Parameterized Tests are more than two orders of magnitude slower","JUnit 5.5.2  ## Steps to reproduce  Run the following empty test. With JUnit 4 it takes about 2 seconds to run, with the JUnit 5 vintage engine it takes about 250 seconds to run.  https://github.com/marschall/junit5-Segment-hashCode/blob/master/src/test/java/com/github/marschall/junit5/segmenthashcode/ReproducerTest.java  ## Context  We have a JUnit 4 Parameterized test with about 70'000 total tests. 3 Tests with about 20'000 parameters. The test runs massively slower with the JUnit 5 vintage engine compared to the the JUnit 4 engine.  Profiling highlights the following hot spots:  - `TestRun#getInProgressTestDescriptorsWithSyntheticStartEvents` has a bad complexity (probably O(N²)) because every time it iterates over all started descriptors, it gets slower the more tests you have - `UniqueId#hashCode` is not memoized  - `UniqueId#toString` is not memoized  See the following flight recording","closed","component: Vintage,","marschall","2019-09-26T10:36:27Z","2019-10-05T09:47:13Z"
"","2963","Adding org.junit.platform:junit-platform-console-standalone dependency causes failure in tests discovery","JUnit 5 version: 5.7.0  When adding org.junit.platform:junit-platform-console-standalone dependency (runtimeOnly), we get a failure in tests discovery (when running on intellij): org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests  (Once we remove this dependency - tests are running as expected) Please advise how to overcome this.  Thanks","closed","theme: discovery,","MeravYa","2022-07-05T05:32:47Z","2022-07-05T11:28:57Z"
"","2348","Tests not found by maven-failsafe-plugin or in error in a newly created Spring Boot project","JUnit 5 tests are not found by the `maven-failsafe-plugin` (JUnit `5.6.1`)  or fail to find correct annotations on newly initialized Spring Boot project test (JUnit `5.5.2`):  Using JUnit `5.6.1`: ```shell script [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ spring-boot-failsafe-maven-plugin --- [INFO] Building jar: E:\WORK\git\spring\spring-boot-failsafe-maven-plugin\target\spring-boot-failsafe-maven-plugin-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- maven-failsafe-plugin:3.0.0-M5:integration-test (default) @ spring-boot-failsafe-maven-plugin --- [INFO] [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] [INFO] Results: [INFO] [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] [INFO] --- maven-failsafe-plugin:3.0.0-M5:verify (default) @ spring-boot-failsafe-maven-plugin --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ ```  Using JUnit `5.5.2`: ```bash gbootfailsafemavenplugin.SpringBootFailsafeMavenPluginApplicationIT] [ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.226 s <<< FAILURE! - in io.florianlopes.springbootfailsafemavenplugin.SpringBootFailsafeMavenPluginApplicationIT [ERROR] io.florianlopes.springbootfailsafemavenplugin.SpringBootFailsafeMavenPluginApplicationIT  Time elapsed: 0.226 s  <<< ERROR! java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test  [INFO] [INFO] Results: [INFO] [ERROR] Errors: [ERROR]   SpringBootFailsafeMavenPluginApplicationIT » IllegalState Unable to find a @Sp... [INFO] [ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0 [INFO] [INFO] [INFO] --- maven-failsafe-plugin:3.0.0-M5:verify (default) @ spring-boot-failsafe-maven-plugin --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE ```  The annotation is indeed present (extract of the test class): ```java @SpringBootTest class SpringBootFailsafeMavenPluginApplicationIT {     @Test     void contextLoads() {     } } ```  Of course, the `maven-failsafe-plugin` is correctly configured to run `*IT` classes (as it works without the `@ContextConfiguration` annotation):  ```xml  	org.apache.maven.plugins 	maven-failsafe-plugin 	3.0.0-M5 	 		 			**/*IT.java 		 	 	 		 			 				integration-test 				verify 			 		 	  ```  Selecting the `surefire-junit-platform` provider as suggested [here](https://stackoverflow.com/questions/29099264/maven-failsafe-plugin-doesnt-pick-up-testng-tests#comment46472667_29099264) changed nothing.  ## Steps to reproduce  Here is a project to reproduce this issue: https://github.com/f-lopes/spring-boot-failsafe-maven-plugin-issue  Two commands to reproduce:  `docker run flopes/spring-boot-failsafe-maven-plugin-issue:junit-5-6-1` `docker run flopes/spring-boot-failsafe-maven-plugin-issue:junit-5-5-2`  ## Context  Versions used: - JUnit `5.5.2` / JUnit `5.6.1` - Spring Boot `2.2.6` - Maven Failsafe plugin `3.0.0-M5`  Build scans:  - JUnit `5.5.2`: https://gradle.com/s/gwxbtdna7m6jk - JUnit `5.6.1`: https://gradle.com/s/lfq2uyod6noge  ## Deliverables Example project: https://github.com/f-lopes/spring-boot-failsafe-maven-plugin-issue  **UPDATE:**   I have run some tests in debug mode and found that the `maven-failsafe-plugin` test scanner did find my test class. However, when passing it to the JUnit provider, it fails to be found/executed.","closed","3rd-party: Maven Surefire,","f-lopes","2020-07-02T16:32:41Z","2020-07-05T14:11:14Z"
"","2055","how to use assert to confirm two jsonString equals","junit 4 : code: `   @Test     public void testToJSONString(){         String text = ""{\n"" +                 ""    \""userName\"":\""张三\"",\n"" +                 ""    \""gender\"":1,\n"" +                 ""    \""email\"":\""920331569@qq.com\"",\n"" +                 ""    \""age\"":20,\n"" +                 ""}"";         PersonDTO personDTO = new PersonDTO();         personDTO.setUserName(""张三"");         personDTO.setGender(1);         personDTO.setEmail(""920331569@qq.com"");         personDTO.setAge(20);         String json = JSON.toJSONString(personDTO);         System.out.println(json);         System.out.println(text);         System.out.println(text.equals(json));              }` result json String: `{""age"":20,""email"":""920331569@qq.com"",""gender"":1,""userName"":""张三""} {     ""userName"":""张三"",     ""gender"":1,     ""email"":""920331569@qq.com"",     ""age"":20, }` the two json key and value are all the same,but the location has some different.I mean that the two json is equal,but I use assertEqual(json,text) return false","closed","type: question,","danishlyy","2019-10-09T09:24:34Z","2019-10-09T21:07:09Z"
"","2616","Add JBang catalog","JBang now has an [AppStore](https://www.jbang.dev/appstore/) that makes it nice and short to run Java executables. We should add a small wrapper and a JBang catalog to make the Console Launcher available through that.  ## Deliverables  - [ ] Add a `junit-team/jbang-catalog` repo and make it possible to run the Console Launcher via `jbang cli@junit-team`","open","status: in progress,","marcphilipp","2021-05-14T10:53:37Z","2021-11-26T14:32:51Z"
"","2806","add saturate-Predicate to ParallelExecutionConfiguration","Java 17 did some internal changes to `ForkJoinPool` which e.g. affects the combination of JUnit 5 + Selenium 4 + parallel execution.  see https://github.com/SeleniumHQ/selenium/issues/10113, https://github.com/junit-team/junit5/issues/1858  https://stackoverflow.com/questions/69768534/why-does-java-17-throw-a-rejectedexecutionexception-when-adding-tasks-to-a-forkj suggest to define saturation-predicate.  ## Deliverables  - [ ] Enhance `ParallelExecutionConfiguration` with a default-method for providing `saturate`-`Predicat`. The default-implementation returns null to keep the existing default-behaviour. This may be overridden on a per-project-base.","closed","status: new,","christophs78","2022-01-02T08:52:01Z","2022-01-02T09:00:41Z"
"","2290","Overload assertLinesMatch with Stream variants","Java 11 introduced the [`String#lines()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#lines()) method, which _""returns a stream of lines extracted from this string, separated by line terminators""_.  To better support that form of ""ordered strings"", overloads of `assertLinesMatch` in class `org.junit.jupiter.api.Assertions` with `Stream` variants should be added. Those new methods should only delegate to the existing `List` methods by collecting a strings returned by the streams.  ## Usage examples  ```java assertLinesMatches(Stream.of(""first"", ""second""), ""first\nsecond"".lines()); ```   ```java assertLinesMatches(Stream.of(""one"", ""two""),     """"""     one     two"""""".lines()); ```   ## Deliverables  - [x] Add `assertLinesMatches(Stream, Stream)` - [x] Add `assertLinesMatches(Stream, Stream, String)` - [x] Add `assertLinesMatches(Stream, Stream, Supplier)`","closed","component: Jupiter,","sormuras","2020-05-08T09:51:49Z","2020-05-29T12:55:56Z"
"","2573","Assert Reflection Equals","It would be useful if it was a method to compare two objects by reflection.  I suppose to have this class: ```java public class Person {     private long id;     private String name;     private String surname;      public long getId() {         return id;     }      public void setId(long id) {         this.id = id;     }             public long getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getSurname() {         return surname;     }      public void setSurname(String surname) {         this.surname = surname;     } } ```  In ordet two check if two objects are equals I can create the test in this way: ```java @Test void myTest() {     Person person1 = new Person();     person1.setId(1L);     person1.setName(""name1"");     person1.setName(""surname1"");      Person person2 = new Person();     person2.setId(2L);     person2.setName(""name1"");     person2.setName(""surname1"");      Assertions.assertEquals(person1, person2); } ```  This test would work just if I implement the equals method in the class `Person`. I think that a new method can be added to `Assertions`: ```java public static void assertReflectionEquals(Object expected, Object actual, String... excludeFields) {     // check by reflection  } ``` This new method executes the equals method for each field having the same name between two objects. If at least one field is not equal, the assertion fails and the different fields are printed.  This would work also for objects having different types.","closed","component: Jupiter,","frascu","2021-03-17T15:26:20Z","2021-03-17T21:52:12Z"
"","2477","Add non-null return type to assertNotNull method","It would be sweet if the `assertNotNull(actual:)` method returned the object that is passed into it back out as a non-null type.  This would help with writing JUnit 5 tests in Kotlin big time and avoid the need to force unwrap properties like this:  ``` assertNotNull(myObject?.myProperty) val myProperty = myObject!!.myProperty assertEquals(""Foo"", myProperty.someOtherProperty) ```  Instead, tests like the above code snippet could be simplified to the following:  ``` val myProperty = assertNotNull(myObject?.myProperty) assertEquals(""Foo"", myProperty.someOtherProperty) ```  Note that the [kotlin-test](https://kotlinlang.org/api/latest/kotlin.test/) library already offers this mechanism in its [assertNotNull](https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/assert-not-null.html) method, and Apple offers a similar [XCTUnwrap](https://developer.apple.com/documentation/xctest/3380195-xctunwrap) method in their [XCTest](https://developer.apple.com/documentation/xctest) framework.","open","component: Jupiter,","adil-hussain-84","2020-11-20T15:51:13Z","2021-08-15T07:50:32Z"
"","2141","More Concise Error Message In Tests","It would be really useful to be able to add an additional argument to the `@Test` annotation to assert an error was thrown with a certain message instead of instantiating a new class and then calling a method on it.  ExpectedException is an okay workaround but it would be much more concise as   ```java @Test (expected = RuntimeException.class, message = ""Employee ID is null"") public void shouldThrowRuntimeExceptionWhenEmployeeIDisNull() { ... } ```  as discussed here: https://stackoverflow.com/questions/2469911/how-do-i-assert-my-exception-message-with-junit-test-annotation","closed","status: declined,","stevewhitmore","2019-12-31T15:18:40Z","2019-12-31T15:33:56Z"
"","2903","Introduce assertions for java.util.Optional","It would be nice to have some tests for Optional values that would check to see if the value is present or is empty.  If it is present then it should return the value.  Additional tests would have messages too.  Here is a sample. ```java     public static void assertIsEmpty(@Nonnull Optional optionalValue) {         Assertions.assertNotNull(optionalValue);         Assertions.assertTrue(optionalValue.isEmpty());     }      public static  T assertIsPresent(@Nonnull Optional optionalValue) {         Assertions.assertNotNull(optionalValue);         Assertions.assertTrue(optionalValue.isPresent());         return optionalValue.get();     }  ```","closed","component: Jupiter,","catshow","2022-04-26T21:54:33Z","2022-05-02T12:20:28Z"
"","2395","Introduce a reason for the @(Enabled|Disabled)(If|On|For)(Jre|Os|SystemProperty|EnvironmentVariable) annotations","It would be nice if we could include a `reason()` on the annotations described in the issue title indicating why a test is disabled on these cases.","closed","component: Jupiter,","gastaldi","2020-08-27T16:08:16Z","2020-08-30T16:08:30Z"
"","2097","Support @Tag as meta-annotation.","It would be nice if `@Tag` could be used as meta annotation so that one can create a custom annotation without having to repeat a certain string/tag value, while being able to read the value via `ExtensionContext#getTags()` when evaluating an `ExecutionCondition`.  ```java @Tag(""condition""); public @interface RequiresMyConditionToBeMatched {  } ```","closed","status: invalid,","christophstrobl","2019-11-13T10:04:11Z","2019-11-13T10:31:28Z"
"","2561","Dynamic parameters for Parameterized tests","It would be great, if it would be possible to pass dynamic argument to the method that provides data for parameterised test.  For example, there is following class with methods, which provides test data:  ```java public class MyTestData {     public static Stream someDataProvider() {         return Stream.of(                 Arguments.of(""Jake"", 63, 31, 32, 0),                 Arguments.of(""Mike"", 81, 41, 32, 2),                 Arguments.of(""Jake"", 63, 31, 32, 0),                 Arguments.of(""Mike"", 81, 41, 32, 2),                 Arguments.of(""Jake"", 63, 31, 32, 0),                 Arguments.of(""Mike"", 81, 41, 32, 2),                 Arguments.of(""Jake"", 63, 31, 32, 0),                 Arguments.of(""Mike"", 81, 41, 32, 2),                 Arguments.of(""Mike"", 20, 21, 19, 0));     } } ```  There is a class with a test:  ```java class MyTestRun {   private String someName;    @BeforeEach   void setUp() {     someName = ""Jake"";   }    @ParameterizedTest()   @MethodSource(""com.example.MyTestData#someDataProvider"")   void someTest(String name, int a, int b, int c, int d) {     System.out.println(name);   } } ```  I would like from `someTest` method pass `someName` variable to `someDataProvider` method. And inside `someDataProvider` method filter values. As a result, `someTest` method would receive data only, where name equals ""Jake"".","closed","theme: parameterized tests,","arturmkr","2021-03-02T13:38:14Z","2021-03-05T11:19:15Z"
"","2732","Add a way for TestInstanceFactory implementations to use any existing ParameterResolver extensions","It would be great if the API provided a way for custom test instance factories to leverage the existing infrastructure for processing constructor parameters (what ExecutableInvoker does, internally). Otherwise you're forced to recreate the same functionality so that parameter resolvers work, for example. In fact, I'm not even sure it'd be possible to recreate it in an identical way (because the extension registry is not available)?","closed","component: Jupiter,","dweiss","2021-09-29T08:43:02Z","2021-09-29T08:55:24Z"
"","2809","JUnit 4 migration tips should document switched assertion failure message argument position","It would be good if the ""Migration Tips"" section of the user guide mentioned the switched assertion message position: - JUnit 4 has the assertion message as first argument: `assertTrue(String message, boolean condition)` - JUnit 5 has the assertion message as last argument: `assertTrue​(boolean condition, String message)`  I assume eventually users will figure out why some of their tests are failing with confusing messages after migration. But it might be good to warn them beforehand.","closed","component: Jupiter,","Marcono1234","2022-01-05T22:14:40Z","2022-05-15T17:45:28Z"
"","2067","Test Data Container for DynamicTest","It would be convenient if there was a class for test data to use it as a container for dynamic tests. In the dynamic test, there are incoming parameters and the expected result, and for convenience, you could still include the name of the test case. For example ```java public class TestData {     private final String nameTest;     private final I inData;     private final O outData; } ```  ## Deliverables","closed","theme: dynamic tests,","RuslanSafa","2019-10-16T08:17:03Z","2019-10-19T11:48:32Z"
"","2764","Fix intermittent module-path ordering issue in MultiReleaseJarTests.checkDefault","It seems the `junit-platform-maven-plugin` sometimes uses a wrong version of junit-platform-engine:  https://ge.junit.org/s/aqfcubud4haew/tests/:platform-tooling-support-tests:test/platform.tooling.support.tests.MultiReleaseJarTests/checkDefault()?anchor=e30&focused-execution=1&top-execution=1#L71","closed","status: new,","marcphilipp","2021-10-31T17:38:52Z","2021-11-01T13:09:17Z"
"","2374","Add overload of DynamicTest.stream(…) that accepts a Stream","It feels weird having to hand an `Iterator` to `DynamicTest.stream(…)`. Creating `Iterator`s usually requires an additional step from usual sources (collections, streams) that are usually easily createable via an `of(…)` factory method. So it would be cool if one could just write this:  ```java var source = Stream.of(…); // or List.of(…)  return DynamicTest.stream(source, …); ```  instead of   ```java var source = Stream.of(…); // or List.of(…)  return DynamicTest.stream(source.iterator(), …); ```","closed","theme: dynamic tests,","odrotbohm","2020-08-05T21:20:49Z","2020-08-08T09:26:06Z"
"","2916","Track already visited pairs of Iterables to avoid stack overflow","Issue: #2915  ## Overview  The visited `Iterable` are tracked and the assert fails if a already visited `Iterable` is visited again. This avoids a StackOverflowError.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","thomaszub","2022-05-13T06:31:37Z","2022-06-19T13:12:50Z"
"","2591","Introduce Named.named() as an alias for Named.of()","Issue: #2587  ## Overview  This PR adds Named.named as a more static import friendly alternative to Named.of.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","helpermethod","2021-04-09T11:45:12Z","2021-04-19T09:19:15Z"
"","2528","Allow rows in @CsvSource to start with a number sign (#)","Issue: #2527  ## Overview  This change relates to the `@CsvSource` annotation and how its rows are parsed. The underlying library supports comments, by default with the number sign (#), and the support for them was left enabled for the `@CsvSource`. This does not make sense in that the tests just throw a `PreconditionViolationException` in case the number sign is used at the start of a row. So, this pull request disables comment processing for  `@CsvSource` but leaves it enabled for  `@CsvFileSource`, as not to disturb existing, documented functionality.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - ✓ There are no TODOs left in the code - (N/A) Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - ✓ [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - ✓ Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - (N/A) Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - (Release notes: ✓) Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - (✓) All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","ZeroOne3010","2021-01-13T13:39:26Z","2021-02-11T11:41:05Z"
"","2320","Introduce getJavaClass() and getJavaMethod() in MethodSource","Issue: #2294  ## Overview  I saw there was some discussion about the issue reporter's working on a PR, but it had been almost a month so I hope I'm not stepping on any toes!  I added a getJavaMethods() method as well, because I was unsure what to do about overloaded methods. I see there is a methodParameterTypes field, which I imagine I could use to find the exact specified method. But I'm unsure about the format of the field and how consistent that format would be. Also does a null methodParameterTypes field mean there are no arguments, or just that no arguments were specified?  Also I made getJavaMethod() throw exceptions if there are 0 or >1 methods with the given name. Unsure if this is the desired behavior.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","cberes","2020-06-11T05:58:17Z","2020-06-16T13:10:04Z"
"","2184","Add JRE.currentVersion() for accessing the current JRE version","Issue: #2176  Expose public static method for accessing the current `JRE`.  I was not sure whether I need to add something to the release notes about this or not.   ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","filiphr","2020-02-15T15:46:40Z","2020-04-17T11:04:20Z"
"","2488","Introduce support for ordering test classes","Issue: #1948  ## Overview  Introduce support for class ordering through the addition of a new configuration parameter: * `junit.jupiter.testclass.order.default` accepting a fully-qualified class-name implementing the newly introduced `org.junit.jupiter.api.ClassOrderer` interface  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","ledoyen","2020-12-08T19:56:55Z","2021-01-30T22:51:45Z"
"","2102","Activate GitHub Actions Cache","Issue #1826  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2019-11-16T13:42:15Z","2020-07-19T08:22:01Z"
"","2640","Display message output ExecutionCondition in test report.","Is there any way the message written in `return ConditionEvaluationResult.enabled(String.format(""Environment variable [%s] does not exist"", name));` for any `ExecutionCondition` can be displayed in some test report to show why a specific test was disabled.","closed","theme: reporting,","guptapavan31","2021-06-08T08:48:18Z","2021-06-08T15:35:45Z"
"","2860","How to pass each single file line as argument","Is there any equivalent of CsvFileSource for raw text files. I mean something like `@TextFileSource` or just `@FileSource` where input lines isn't parsed before pass as test method argument?  workaround 1: `@CsvFileSource(resources = ""/foo.csv"", delimiterString = ""\t\t\t\t"")` where `delimiterString` is string that never occur   workaround 2: `@MethodSource(""fileLineProvider"")` with `Files.readAllLines().stream()` inside","closed","component: Jupiter,","kosaa","2022-03-21T17:25:16Z","2022-03-21T17:30:16Z"
"","2066","Make (Dis|En)ableIfEnvironmentVariableCondition public","Is there a reason why `DisabledIfEnvironmentVariableCondition.java` and `EnabledIfEnvironmentVariableCondition.java` are not public?  I would like to extend these classes and override `getEnvironmentVariable` to be able to get the variable from [java-dotenv](https://github.com/cdimascio/java-dotenv) instead of `System.getenv`  I could open a PF for that is that's OK.  ## Deliverables  - [ ] `DisabledIfEnvironmentVariableCondition` is public - [ ] `EnabledIfEnvironmentVariableCondition` is public","closed","component: Jupiter,","Brunomachadob","2019-10-16T08:10:52Z","2019-10-18T11:20:34Z"
"","2532","Make default parameterized display name template configurable","Introduce `junit.jupiter.params.displayname.default` configuration parameter to configure the default display name template for all parameterized tests.  ## Overview  according to the comment (https://github.com/junit-team/junit5/pull/2526#issuecomment-760898928)  The new configuration ```junit.jupiter.params.displayname.default``` enables us to configure the display name for all parameterized test. With this new configuration, we don't need to write duplicate pattern (like ```{displayName} - {arguments}```) to all test case.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","chia7712","2021-01-16T17:46:29Z","2021-08-17T09:48:45Z"
"","2230","Publish to standalone file repo instead of mavenLocal()","Instead of polluting the local Maven repository and being potentially influenced by its other contents, we now publish to a standalone file repo in build/repo and use it in our Maven/Gradle integration tests.","closed","theme: build,","marcphilipp","2020-04-01T19:53:57Z","2020-04-02T16:17:16Z"
"","2010","Run Gradle/Maven/Ant tests with Java 8","Instead of disabling the tests on Java 14, we now run tests for Gradle/Maven/Ant builds with JDK 8. Not only does that remove the need for Gradle to support the latest EA release, it also provides basic coverage that ensures that we can run on Java 8.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","marcphilipp","2019-09-14T12:07:15Z","2019-09-14T16:50:14Z"
"","2000","Move to GitHub Actions","Initial tests using workflows introduced by GitHub Actions are looking very promising.  `@AfterAll`, it's still Azure Pipelines under the hood, ain't it?","closed","","sormuras","2019-09-03T07:03:48Z","2019-09-14T18:23:38Z"
"","2156","Update cache triggers for snapshot API uploads","Include missing API documentation source files that are relevant for generating the page uploaded to https://junit.org/junit5/docs/snapshot/api/  ## Deliverables  - [x] Update [publishDocumentationSnapshotOnlyIfNecessary.sh](https://github.com/junit-team/junit5/blob/HEAD/src/publishDocumentationSnapshotOnlyIfNecessary.sh) - [x] All `module-info.java` files below `src/module` directories - [x] `junit-overview.html` in documentation project - [x] Add missing trigger for _new_ subproject ` junit-platform-reporting` - [x] Files in below `src/main9`, unless the have a base match in its `src/main` directory","closed","component: Vintage,","sormuras","2020-01-19T19:15:52Z","2020-07-10T13:33:29Z"
"","2104","loadRequiredParameterType() should use ClassLoader for the supplied Class","In this code here:  https://github.com/junit-team/junit5/blob/b4fef4a8a01c0bfeb8f008a331ec5dc5a9df0869/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java#L1208-L1215  ... the `tryToLoad(String)` method uses the default classloader to attempt to load the parameter class. It would probably make more sense to use the `tryToLoad(String, ClassLoader)` variant, and use `clazz.getClassLoader()` instead, because the test class' methods should resolve from the perspective of the test class itself.  Related to #1987.  ## Steps to reproduce  I intend to submit a PR to demonstrate the issue (hopefully along with a fix).  ## Context   - Test discovery clients that use `selectMethod(Class...)` variants for methods with parameters.  ## Deliverables  * `selectMethod(Class, String, String)` should work across classloaders.","closed","status: stale,","kriegfrj","2019-11-19T02:49:54Z","2021-06-19T12:50:35Z"
"","2859","CI builds time out on Mac OS","In recent weeks, the CI builds were hit by timeouts when trying to download artifacts from external sources, for example from https://archive.apache.org/dist/maven/maven-3/  A stacktrace reads like: ```     java.io.UncheckedIOException: download failed         at app//de.sormuras.bartholdy.Bartholdy.download(Bartholdy.java:61)         at app//de.sormuras.bartholdy.Bartholdy.install(Bartholdy.java:72)         at app//de.sormuras.bartholdy.Bartholdy.install(Bartholdy.java:66)         at app//de.sormuras.bartholdy.tool.Maven.install(Maven.java:17)         at app//platform.tooling.support.Request.maven(Request.java:47)         at app//platform.tooling.support.tests.MultiReleaseJarTests.mvn(MultiReleaseJarTests.java:84)         at app//platform.tooling.support.tests.MultiReleaseJarTests.checkDefault(MultiReleaseJarTests.java:68)          Caused by:         java.net.ConnectException: Operation timed out             at java.base@17.0.2/sun.nio.ch.Net.connect0(Native Method)             at java.base@17.0.2/sun.nio.ch.Net.connect(Net.java:579)             at java.base@17.0.2/sun.nio.ch.Net.connect(Net.java:568)             at java.base@17.0.2/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:588)             at java.base@17.0.2/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)             at java.base@17.0.2/java.net.Socket.connect(Socket.java:633)             at java.base@17.0.2/sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:299)             at java.base@17.0.2/sun.security.ssl.BaseSSLSocketImpl.connect(BaseSSLSocketImpl.java:174)             at java.base@17.0.2/sun.net.NetworkClient.doConnect(NetworkClient.java:183)             at java.base@17.0.2/sun.net.www.http.HttpClient.openServer(HttpClient.java:498)             at java.base@17.0.2/sun.net.www.http.HttpClient.openServer(HttpClient.java:603)             at java.base@17.0.2/sun.net.www.protocol.https.HttpsClient.(HttpsClient.java:266)             at java.base@17.0.2/sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:380)             at java.base@17.0.2/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:189)             at java.base@17.0.2/sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1242)             at java.base@17.0.2/sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1128)             at java.base@17.0.2/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:175)             at java.base@17.0.2/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1665)             at java.base@17.0.2/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1589)             at java.base@17.0.2/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:224)             at java.base@17.0.2/java.net.URL.openStream(URL.java:1161)             at app//de.sormuras.bartholdy.Bartholdy.download(Bartholdy.java:55)             ... 6 more ```  ❌ Timed out with: https://github.com/junit-team/junit5/runs/5626012955?check_suite_focus=true ```  + Eclipse Temurin JDK 17.0.2+8      | Location:           /Users/runner/hostedtoolcache/Java_Temurin-Hotspot_jdk/17.0.2-8/x64/Contents/Home      | Language Version:   17      | Vendor:             Eclipse Temurin      | Architecture:       x86_64      | Is JDK:             true      | Detected by:        Current JVM ```  ✅ Worked with Oracle JDK: https://github.com/junit-team/junit5/runs/5630294877?check_suite_focus=true ```  + Oracle JDK 17.0.2+8-LTS-86      | Location:           /Users/runner/hostedtoolcache/Java_jdkfile_jdk/17/x64/Contents/Home      | Language Version:   17      | Vendor:             Oracle      | Architecture:       x86_64      | Is JDK:             true      | Detected by:        Current JVM ```","closed","status: new,","sormuras","2022-03-21T16:19:07Z","2022-03-22T18:29:46Z"
"","2566","Use JDK 11 to run Gradle","In preparation for the toolchain upgrade to JDK 16, we now run the build with the JDK 11 LTS version again.","closed","","marcphilipp","2021-03-11T19:35:36Z","2021-03-18T14:25:24Z"
"","2212","Create DisplayName MethodOrderer to order tests by their display name","In order to sort the tests by the display name attribute attached to tests, create an implementation of `MethodOrderer` that provides this functionality,  ## Deliverables  An implementation of `MethodOrderer`, with a sensible fallback, e.g.  ```java public class DisplayNameOrderer implements MethodOrderer {      public void orderMethods(MethodOrdererContext context) {         context.getMethodDescriptors().sort(Comparator.comparing(DisplayNameOrderer::getDisplayName));     }      private static String getDisplayName(MethodDescriptor descriptor) {         return descriptor             .findAnnotation(DisplayName.class)             .map(DisplayName::value).orElse(""""); // Something better than this     } } ```  Which can then be used on test classes, as per `@TestMethodOrder(DisplayNameOrderer.class)`.  It's something I've been using where I'm performing some data sequencing tests, i.e. integration rather than unit, but it's been quite handy + satisfies my OCD.   Happy to do the work + raise a PR if no objections if this was deliberately omitted.","closed","type: new feature,","dylan-asos","2020-03-11T17:46:35Z","2020-03-30T08:55:11Z"
"","1995","Drop java.compiler dependence in org.junit.platform.commons","In order to reduce the surface of required modules, let's follow @lukaseder advice:  https://twitter.com/lukaseder/status/1167087138246184960 > The implementation is relatively simple, I usually use Character.isJavaIdentifierStart() and Character.isJavaIdentifierPart() directly, instead.  https://github.com/junit-team/junit5/blob/master/junit-platform-commons/src/module/org.junit.platform.commons/module-info.java#L12  ## Deliverables  - [x] Implement own `isJavaName(String s)` method and drop `java.compiler`","closed","theme: modules,","sormuras","2019-08-30T19:55:55Z","2019-09-10T13:09:03Z"
"","2602","Enable stalebot","In order to close obsolete issues without having to manually go through issues, we should enable [Stalebot](https://github.com/probot/stale) to comment on issues that haven't been updated in a certain timeframe. If nobody responds or attaches a certain label, i.e. the issue is no longer relevant, the bot will close it.  ## Proposed config  ```yml # Configuration for probot-stale - https://github.com/probot/stale # Configuration options apply to both Issues and Pull Requests. # We configure those individually to match our workflow (see `pulls:` and `issues:`)  pulls:   # Number of days of inactivity before a Pull Request becomes stale   daysUntilStale: 60    # Number of days of inactivity before a Pull Request with the stale label is closed.   # Set to false to disable. If disabled, Pull Request still need to be closed manually, but will remain marked as stale.   daysUntilClose: 21    # Comment to post when marking as stale. Set to `false` to disable   markComment: >     This pull request has been automatically marked as stale because it has not had recent activity.     Given the limited bandwidth of the team, it will be closed if no further activity occurs.     If you intend to work on this pull request, please reopen the PR.     Thank you for your contributions.   # Comment to post when closing a stale Pull Request.   closeComment: >     This pull request has been automatically closed due to inactivity.     If you are still interested in contributing this, please ensure that     it is rebased against the latest branch (usually `main`), all review     comments have been addressed and the build is passing. issues:   daysUntilStale: 365    # Number of days of inactivity before an Issue with the stale label is closed.   # Set to false to disable. If disabled, issues still need to be closed manually, but will remain marked as stale.   daysUntilClose: 21    # Comment to post when marking as stale. Set to `false` to disable   markComment: >     This issue has been automatically marked as stale because it has not had recent activity.     Given the limited bandwidth of the team, it will be automatically closed if no further     activity occurs.     Thank you for your contribution.   # Comment to post when closing a stale Issue.   closeComment: >     This issue has been automatically closed due to inactivity. If you have a good use case for this     feature, please feel free to reopen the issue.  # Only issues or pull requests with all of these labels are check if stale. Defaults to `[]` (disabled) #onlyLabels: []  # Issues or Pull Requests with these labels will never be considered stale. Set to `[]` to disable exemptLabels: []  # Set to true to ignore issues in a project (defaults to false) exemptProjects: false  # Set to true to ignore issues in a milestone (defaults to false) exemptMilestones: false  # Set to true to ignore issues with an assignee (defaults to false) exemptAssignees: false  # Label to use when marking as stale staleLabel: ""status: stale""  # Comment to post when removing the stale label. # unmarkComment: > #   Your comment here.  # Limit the number of actions per hour, from 1-30. Default is 30 limitPerRun: 30  # Limit to only `issues` or `pulls` # only: issues ```  ## Deliverables  - [x] Enable the bot using the above config","closed","type: task,","marcphilipp","2021-04-24T16:00:41Z","2022-07-13T22:03:52Z"
"","2771","Support Kotlin top level functions as test methods","In Kotlin, functions are first class citizens and do not need the context of a class definition. Idiomatic Kotlin often tries to avoid as much code as possible. The current implementation of JUnit Jupiter does not allow to execute such top level functions as tests. As Kotlin top level functions are compiled to static JVM methods with a predictable class name and an annotation identifying the generated class as a Kotlin class, it should be possible to add such support.  Complete example of tests without a class definition:  ````kotlin import org.junit.jupiter.api.Assertions.assertTrue import org.junit.jupiter.api.Test   @Test fun failure() = assertTrue(false)  @Test fun success() = assertTrue(true)  ````  Careful thought about possible limitations to life-cycle methods might be in order.   ## Deliverables  - add ability to execute Kotlin top level functions as tests","open","component: Kotlin,","mmerdes","2021-11-04T20:31:22Z","2021-11-05T12:25:54Z"
"","2187","Parameterized Extension support","In JUnit4, since parameterized tests are at class level, parameters can be used for `TestRule`s. Here are some examples where this is useful: - Using `TempDir` Extension with a custom path provided by parameters. - Setting up a MockWebServer with different network ports based on parameters. This needs to be an extension since server needs to be shutdown after tests.  With JUnit 5, it is not possible to do this. Parameterized tests are only at method level. And programmatic Extension support is only at class level (needs to be a field).","closed","theme: parameterized tests,","tasomaniac","2020-02-15T21:39:53Z","2020-02-16T17:15:13Z"
"","2841","Dynamic computation of timeouts?","In JUnit4, it was possible to create a dynamic timeout by placing a `@Rule` on a method that returned a `Timeout` object. This provided the ability to set a timeout based on factors in the environment.  See [this Apache Accumulo integration test class](https://github.com/apache/accumulo/blob/4b66b96b8f6c65c390fc26c11acf8c51cb78d858/test/src/main/java/org/apache/accumulo/harness/AccumuloITBase.java#L83-L115) for example.  There does not seem to be an equivalent capability in JUnit5. If there is, how is this done? If there isn't, please add such a capability. As many of our integration tests are very resource-intensive, it is crucial for our use case of being able to scale our timeouts for when we run them in resource-constrained environments (like a developer laptop) to reduce false positives.","open","status: waiting-for-interest,","ctubbsii","2022-03-03T15:29:49Z","2022-05-13T11:00:12Z"
"","2480","Passing TestExecutionListener to engine launched by EngineTestKit","In junit-pioneer/junit-pioneer#375, we failed to write an integration test for an extension because it includes a `TestExectionListener` and the test run we launch with `EngineTestKit` didn't pick it up (at least it didn't call methods like `reportingEntryPublished` and `executionFinished` for the tests executed by that engine). Is that behavior intentional?  If so and it can't be changed (it would be somewhat weird to have an execution listener that listens to both the actual Jupiter run, but then also to the engine launched during one of those tests), it would be nice if we'd be able to register a listener explicitly. The `EngineExecutionListener` comes close, but I didn't find a way to register our own implementation.","closed","component: Test Kit,","nipafx","2020-11-24T20:06:42Z","2020-11-27T11:39:10Z"
"","2626","Document best practices for test method and test class visibility","In JUnit Jupiter, the `public` modifier is optional in test classes and methods.  I see test classes in JUnit, Spring projects, etc apply this no `public` modifier pattern. Once I get used to this style, it feels very redundant when I encounter tests that have `public` all over.  I believe this is a good practice to follow.  However, in JUnit documentation, I only find this line regarding the `public` modifier:  >  Test classes, test methods, and lifecycle methods are not required to be public, but they must not be private.    It would be great if JUnit documentation mentions that leaving off the `public` modifier is preferred unless visibility is required. (e.g. base class shared by different packages)  I understand this is a bit of _opinionated_ aspect, but it would be nice to mention the principle of _[""less is more""](https://stackoverflow.com/questions/55215949/why-junit-5-default-access-modifier-changed-to-package-private/55230350#55230350)_ in the documentation. So that, a person like me can encourage this pattern to other devs with the backup of JUnit good practice.","closed","component: Jupiter,","ttddyy","2021-05-28T05:02:27Z","2021-06-17T16:24:32Z"
"","2470","Programmatic equivelant of junit.jupiter.extensions.autodetection.enabled","In Junit 5 how can I register an extension programmatically without doing it per-test. I'm currently using the java services mechanism which is activated by the system property junit.jupiter.extensions.autodetection.enabled, but I'm trying to achieve the same as a JVM system wide without using the services mechanism.  ```kotlin import mockwebserver3.MockWebServer import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.junit.jupiter.api.extension.RegisterExtension import org.junit.jupiter.engine.JupiterTestEngine import org.junit.platform.console.options.Theme import org.junit.platform.engine.TestEngine import org.junit.platform.engine.discovery.DiscoverySelectors.selectClass import org.junit.platform.launcher.Launcher import org.junit.platform.launcher.LauncherDiscoveryRequest import org.junit.platform.launcher.PostDiscoveryFilter import org.junit.platform.launcher.TestExecutionListener import org.junit.platform.launcher.core.LauncherConfig import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder import org.junit.platform.launcher.core.LauncherFactory import org.junit.platform.launcher.listeners.SummaryGeneratingListener import java.io.PrintWriter import kotlin.system.exitProcess  class MySampleTest {   @Test   fun failingTest(server: MockWebServer) {     assertThat(""hello"").isEqualTo(""goodbye"")   } }  fun main() {   System.setProperty(""junit.jupiter.extensions.autodetection.enabled"", ""true"")    val summaryListener = SummaryGeneratingListener()    val jupiterTestEngine = JupiterTestEngine()    val config = LauncherConfig.builder()     .enableTestExecutionListenerAutoRegistration(false)     .enableTestEngineAutoRegistration(false)     .enablePostDiscoveryFilterAutoRegistration(false)     .addTestEngines(jupiterTestEngine)     .addTestExecutionListeners(summaryListener, DotListener)     .build()   val launcher: Launcher = LauncherFactory.create(config)    val request: LauncherDiscoveryRequest = LauncherDiscoveryRequestBuilder.request()     // TODO replace junit.jupiter.extensions.autodetection.enabled with API approach. //    .enableImplicitConfigurationParameters(false)     .selectors(selectClass(MySampleTest::class.java))     .build()    val result = launcher.execute(request)    val summary = summaryListener.summary   summary.printTo(PrintWriter(System.out))    exitProcess(if (summary.testsFailedCount != 0L) -1 else 0) } ```","open","status: new,","yschimke","2020-10-31T12:19:26Z","2022-05-23T08:17:55Z"
"","2920","Ask IntelliJ to add `IterationSelector` support","In https://github.com/junit-team/junit5/issues/2738, `IterationSelector` was introduced to allow IDEs to let users select which iterations of another selector, e.g. a test method, they would like to execute. We should open a feature request for IntelliJ IDEA to add support now that 5.9 M1 is released.","closed","3rd-party: IntelliJ IDEA,","marcphilipp","2022-05-20T10:11:05Z","2022-06-19T13:10:45Z"
"","2492","Add an `assertInstanceOf` to Jupiter assertions","In cases where `assertThrows` cannot be used as the test setup is more intricate than a single operation there is still the need to assert that expected exceptions are of a certain `instanceof` type.   The naive way to test this would be for example: ```java assertTrue(e instanceof IllegalStateException); ``` as I had used it here https://github.com/jbee/purejin/pull/137/files#diff-567a735adbd51f614bf6f2beb67d86ff5ec9d3c7933d59cd0a49b89a6742e39eR68-R71  The downside of this is clearly that the message of this assertion isn't useful. A custom message could be assembled to improve that but I basically would want to rebuild what `assertThrows` already does https://github.com/junit-team/junit5/blob/7f5e22536b26a99b310f565de7df9d8a0518b079/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertThrows.java#L63-L65  So I think this could be extracted to a method in the API either especially for exceptions or more generally to assert that a value is an instance of some specific type.  For completeness the API I imagine would be: ```java void assertInstanceOf(Class expected, Object actual); // and/or void assertExceptionOfType(Class expected, Throwable actual); ```","closed","component: Jupiter,","jbee","2020-12-11T18:23:52Z","2021-01-05T08:52:13Z"
"","2331","Introduce InstanceSelector (that can be used with Test Kit)","In addition to the `ClassSelector`, I would like to have an `InstanceSelector`. In contrast to `ClassSelector`, the test is already instantiated. The instance within this selector shall also not be filtered by `TestContainerResolver.isPotentialCandidate(Class)`. This would be very helpful in combination with Test Kit.  Lets look at the example I used in #2330.  ```java @Test void actual_test() {   EngineExecutionResults results = JUnitTestKitUtil.runTest(getClass(), ""mock_test"");   results.testEvents().assertThatEvents().haveExactly(1, EventConditions.finishedWithFailure(       TestExecutionResultConditions.instanceOf(AssertionFailedError.class),       TestExecutionResultConditions.message(""EXPECTED""))); }  @MockTest void mock_test() {   Assertions.fail(""EXPECTED""); } ```  `JUnitTestKitUtil.runTest(…)` runs the given test using *Test Kit*. `@MockTest` adds a tag and ensures that the test is disabled if it is not executed using `JUnitTestKitUtil.runTest(…)`.  Using an `InstanceSelector`, we could rewrite the test like this:  ```java @Test void actual_test() {   EngineExecutionResults results = JUnitTestKitUtil.runTest(new Object() {     @Test     void mock_test() {       Assertions.fail(""EXPECTED"");     }   });    results.testEvents().assertThatEvents().haveExactly(1, EventConditions.finishedWithFailure(       TestExecutionResultConditions.instanceOf(AssertionFailedError.class),       TestExecutionResultConditions.message(""EXPECTED""))); } ```  Since most test methods in one class often have the same annotations, using lambdas might make it even simpler.  ```java @FunctionalInterface interface SimpleJUnitTestMethod {   @Test   void test(); }  @Test void actual_test() {   EngineExecutionResults results = JUnitTestKitUtil.runTest((SimpleJUnitTestMethod) () -> {     Assertions.fail(""EXPECTED"");   });    results.testEvents().assertThatEvents().haveExactly(1, EventConditions.finishedWithFailure(       TestExecutionResultConditions.instanceOf(AssertionFailedError.class),       TestExecutionResultConditions.message(""EXPECTED""))); } ```  I took a short look into the implementation of JUnit. It looks like some parts of the implementation assume that selections of any selector are instances of `AnnotatedElement`. Therefore, it might need some refactoring to implement an `InstanceSelector`.","closed","component: Test Kit,","JojOatXGME","2020-06-19T11:30:09Z","2020-10-31T18:59:00Z"
"","2292","Add support for local files to CsvFileSource","In addition to classpath resources, CsvFileSource now supports files from the local file system.  Resolves #2281.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","marcphilipp","2020-05-09T13:21:06Z","2020-05-31T19:12:43Z"
"","2353","JUnit BOM should define fixed version ranges","In a large projekt we made the experience that in some situation no test will run. It looks that this was illegal combination of platform version and junit version. I guess there exists only a few correct combinations. This end with junit 5.6 and runner 1.5 for example. So I think that in the junit-bom the should be a range [5.6.0, 5.7) and platform [1.6.0, 1.7).  Then maven should show explicitly the conflict.","closed","component: Vintage,","opensource21","2020-07-06T06:20:18Z","2020-08-10T14:04:50Z"
"","2985","Use suite events for more accurate reporting","In 4.13 testSuiteStarted/Finished were introduced. While top-level test class events were already reported at the appropriate time, events for intermediate levels such as iterations of the `Parameterized` runner or classes executed by the `Suite` runner were created synthetically when the first test was started and the last test was finished, respectively.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2022-07-26T13:57:58Z","2022-07-26T14:13:16Z"
"","2507","Characters not allowed according to XML 1.0 spec are double-escaped","In #2275, we have replaced characters not allowed according to the XML 1.0 spec with their character reference, e.g. `\0` becomes `�`. However, that's still illegal according to [section 4.1 of the spec](https://www.w3.org/TR/REC-xml/#sec-references):  > Characters referred to using character references MUST match the production for Char.  Thus, we either filter them out completely or double-escape them like [Surefire does](https://issues.apache.org/jira/browse/SUREFIRE-456), e.g. `\0` becomes `&#0;`. Since the former would omit information, I think we should do the latter.  ## Deliverables  - [x] Illegal XML characters are ""double-escaped""","closed","theme: reporting,","marcphilipp","2020-12-27T15:18:28Z","2021-01-01T13:59:09Z"
"","2748","Handle Kotlin Function Names Correctly","In ""normal"" cases Kotlin function names map directly onto Java method names. However, there are a few cases where the Kotlin source name of a function will be different than the generated method name in byte code:  1. in internal classes 2. with parameters of specific types present - e.g. UInt, UShort etc. 3. There might be more...   As a test engine writer I stumble upon this problem in a few classes: - `org.junit.platform.engine.discovery.MethodSelector` which - when called from IntelliJ's test runner - provides the correct Kotlin function name, but cannot resolve the underlying Java method. - `org.junit.platform.engine.support.descriptor.MethodSource` which cannot differentiate between `methodName` and `getJavaMethod()`   ## Deliverables  - Implement `MethodSelector` so that it works correctly with all Kotlin function names - Implement `MethodSource` so that it will correctly produce `methodName` (Kotlin name) and `getJavaMethod()`.  Alternatively, allow a test engine to change the behaviour of `MethodSelector` and `MethodSource`.  ### Addendum  A similar problem may exist with Kotlin class names, e.g. internal or inner classes, but I haven't checked.","open","component: Kotlin,","jlink","2021-10-17T10:11:13Z","2022-05-07T07:59:44Z"
"","2001","Access to the Include-/Exclude-ClassnameFilters","If you are writing a custom TestEngine, the discovery method will be the entrance for the selection of the TestClasses. If you want to select a package and you are using an IDE ( IntelliJ in my case) the IDE will give you a ClasspathRooSelector in combination with an Include- and / ExcludeClassnameFilter.  `request.getFiltersByType(ClassNameFilter.class);` is not enough, because the implementing classes are not public.  ## Deliverables - [ ] access to the pieces of information to build a proper TestDescriptor","closed","theme: discovery,","svenruppert","2019-09-03T07:27:04Z","2019-09-14T18:43:26Z"
"","2359","Wrong name and class name in XML report for parameterized tests","If I have an inner type in a parameterized test the index is dropped from the testcase name in the xml report.  ```          ``` I expect  ```          ``` If I move Inner to a top level class this behaves as expected.    ## Steps to reproduce   ``` class MyTest {     private static Stream innerSource() {         return Stream.of(             Arguments.of(new Inner()),             Arguments.of(new Inner()),             Arguments.of(new Inner())         );     }         @ParameterizedTest     @MethodSource(""innerSource"")     void inner(final Inner inner) {     }      static class Inner {      } } ```   ## Context   - Used versions (Jupiter/Vintage/Platform):  Juipter: 5.7.0-M1 surefire: 3.0.0-M4  - Build Tool/IDE: Intellij/maven/surefire  ## Deliverables Parameterized tests with inner types in the arguments displays correctly  ```          ```","closed","3rd-party: Maven Surefire,","thespags","2020-07-20T19:14:38Z","2020-07-25T17:21:08Z"
"","2219","Multiple declarations of `@TempDir` in same parameter list or class declaration should fail","If a test/lifecycle method has multiple parameters annotated with `@TempDir` or a test class has multiple fields annotated with `@TempDir`, the corresponding test class/method should fail in order to prevent user errors that stem from assuming them to be different directories.  ## Deliverables  - [x] Multiple parameters of the same callable must not inject the same temp dir - [x] Multiple `static` fields must not inject the same temp dir - [x] `static` field temp dir cannot be injected again in instance field - [x] Multiple instance fields must not inject the same temp dir - [x] `static` or instance field temp dir cannot be injected again as parameter","closed","status: superseded,","marcphilipp","2020-03-19T11:56:25Z","2021-08-17T09:42:13Z"
"","2433","@DisplayNameGenerator - not working with Surefire","I've searched everywhere for a step by step explanation for this but to no avail. The requirement is simple and clear  I have a demo test class in AppTest.java and I am using Junit 5 for this I am using the @DisplayNameGenerator with a custom Generator static class But no changes are showing in the termnial I am not sure what it is I need to do further. Can someone help me please? Here is the code so far I have got:  ## Steps to reproduce ```package learnjunit;  /* assertions and junit 5 core annotation imports */ import static org.junit.jupiter.api.Assertions.*; import org.junit.jupiter.api.*; import java.lang.reflect.Method;   @DisplayNameGeneration(AppTest.ReplaceCamelCase.class) public class AppTest {   @BeforeAll   public static void test_beforeAll() {     System.out.println(""@BeforeAll - Executing"");   }    @BeforeEach   public void test_beforeEach() {     System.out.println(""@Before - Executing"");   }    @Test     public void test_testOne() {     System.out.println(""@Test - Executing for test_testOne()"");   }    @Test   public void test_testTwo() {     System.out.println(""@Test - Executing for test_testTwo()"");   }    @AfterEach     public void test_afterEach() {     System.out.println(""@AfterEach - Executing"");   }    @AfterAll   public static void test_afterAll() {     System.out.println(""@AfterAll - Executing"");   }      static class ReplaceCamelCase extends DisplayNameGenerator.Standard {       @Override       public String generateDisplayNameForClass(Class testClass) {           /* -> this I can see in the terminal */ System.out.println(super.generateDisplayNameForClass(testClass));           /* -> this has no effect */ return super.generateDisplayNameForClass(testClass) + ""__YES"";       }        @Override       public String generateDisplayNameForNestedClass(Class nestedClass) {           return replaceCamelCase(super.generateDisplayNameForNestedClass(nestedClass));       }        @Override       public String generateDisplayNameForMethod(Class testClass, Method testMethod) {           return this.replaceCamelCase(testMethod.getName()) +              DisplayNameGenerator.parameterTypesAsString(testMethod);       }        String replaceCamelCase(String camelCase) {           StringBuilder result = new StringBuilder();           result.append(camelCase.charAt(0));           for (int i=1; i","closed","3rd-party: Maven Surefire,","sricharankrishnan","2020-10-02T11:53:02Z","2020-10-06T08:31:16Z"
"","2545","Provide more options to configure ForkJoinPoolHierarchicalTestExecutorService's ForkJoinPool","I've recently encountered a problem similar to https://github.com/junit-team/junit5/issues/1675 , but a bit worse: provided that all tests use Future.get() at some point and there's enough of them, a user can run into situation where tests start failing with  RejectedExecutionException thrown by ForkJoinPool's tryCompensate() method.  This can be avoided by tuning the parameters of ForkJoinPool used in JUnit's ForkJoinPoolHierarchicalTestExecutorService - there are several ways,and I'm using custom ForkJoinWorkerThreadFactory implementation that keeps track of running workers.  The problem is, ForkJoinPoolHierarchicalTestExecutorService and other classes are not very open for such modifications.  I have no way to inject custon thread factory via config. I can not inject already created FJP at construction time, or override a constructor, due to how FJP creation is made in private method called in a constructor. This goes even further: ForkJoinPoolHierarchicalTestExecutorService parses the configuration with DefaultParallelExecutionConfigurationStrategy.getStrategy() method which is package-private, and JupiterTestEngine has its own share of private methods and is final, so no overriding there.  This results in a situation, where in order to change one argument sent to FJP's constructor, I have to either: a) provide my own implementations of HierarchicalTestExecutorService, TestEngine and some other classes, which is a bit ridiculous because of how I want to change literally one parameter. b) copy JUnit's default implementations to my code and change that argument there, which is also not so good due to excessive code and the need to license the copied code under EPL-2.0 c) use Reflection API to modify ForkJoinPoolHierarchicalTestExecutorService at runtime, replacing its FJP, or changing FJP's i internal variables. This is the most effective solution, but it is rather brittle due to all that reflection stuff.  The point is, is there any possibility for JUnit to provide more options to configure ForkJoinPoolHierarchicalTestExecutorService and its pool, or, at least, to make the API more open to subclassing and modification? I totally understand that these APIs can and will be unstable and experimental, but it could potentially improve using JUnit with any tests that rely on code using Future - like Java's new HTTP API that runs all http requests this way.","open","component: Platform,","tmirzoev","2021-02-05T14:55:55Z","2022-01-02T09:16:09Z"
"","2176","Expose JRE.CURRENT_VERSION for public access","I've recently been fiddling with Junit Jupiter in order to migrate some of our custom Junit 4 runners into appropriate Jupiter extensions.  Due to different reasons we need to write custom `ExecutionCondition` which would enable or disable running of certain tests under different JREs. We can't use the `@DisabledOnJre` feature since we are using a `@TestTemplate` which based on the passed information would later on decide if it can execute the test on the current JRE.  In our case we are running some compiler tests with Eclipse JDT and Javac. When running under Java 11 we need to disable the Eclipse JDT tests. We are using a template since the same test is executed twice, once with Eclipse and once with Javac.  Current workaround is to do  ```java  static final JRE CURRENT_VERSION;      static {         JRE currentVersion = JRE.OTHER;         for ( JRE jre : JRE.values() ) {             if ( jre.isCurrentVersion() ) {                 currentVersion = jre;                 break;             }         }          CURRENT_VERSION = currentVersion;     } ```  However, it would be better if this can be provided by the `JRE` class itself. for example `JRE.currentVersion()`.  If the JUnit team is OK with such addition to the `JRE` API I can provide a PR for adding it  ## Deliverables  - [ ] ...","closed","component: Jupiter,","filiphr","2020-02-08T14:12:35Z","2020-02-18T11:08:12Z"
"","1973","Smarter @EnumSource implementation","I've just started using `@EnumSource` in a parameterized test. Very handy.  However, after having used it with a few methods, it occurred to me that it could be a little handier and a little DRYer.  Consider:  ```java @ParameterizedTest @EnumSource(MyEnum.class) public void myTestMethod(MyEnum param) { } ``` We have to specify the enum type twice. This seems to be needless repetition and a possible source of errors.  My proposal is in two parts:  1. The ""value"" parameter of the `@EnumSource` annotation should be inferred by the engine based on the type of the parameter. 2. As a further enhancement, if there is no other configuration needed for the `@EnumSource` annotation, then it would be nice if it were possible to omit it altogether.  ## Deliverables  ### Proposal part 1  Ability to write tests as follows:  ```java @ParameterizedTest // Equivalent to @EnumSource(MyEnum.class) @EnumSource  public void myTestMethod(MyEnum param) { } ```  ```java @ParameterizedTest // Equivalent to @EnumSource(value = MyEnum.class, names = {""VAL1"", ""VAL2""})) @EnumSource(names = { ""VAL1"", ""VAL2"" })  public void myTestMethod(MyEnum param) { } ```  ### Propsal part 2  Ability to write tests as follows:  ```java @ParameterizedTest // Equivalent to @EnumSource(MyEnum.class) public void myTestMethod(MyEnum param) { } ```","closed","theme: parameterized tests,","kriegfrj","2019-08-07T00:16:07Z","2019-09-01T18:08:35Z"
"","2305","DynamicContainer to support an optional Executable","I've just had my first attempt to use `TestFactory` ""in anger"". The idea is to take the output from EngineTestKit, rebuild the `TestDescriptor` hierarchy generated by the testkit run, and transform that hierarchy into a series of dynamic tests and containers. In this way, individual failures inside the testkit run will be directly reported in the top-level testing framework rather than swallowed up in the low-level test run and only reported ""in aggregate"" at the top-level.  Anyway, while implementing this I discovered that while `TestDescriptor`s in a JUnit Platform test hierarchy can be _both_ a container and a test, in the dynamic testing interface these are mutually exclusive - a DynamicNode can be ~both~ either  a `DynamicTest` or a `DynamicContainer`, but not both. It seems to me to be a bit of a capability gap in the dynamic testing interface that it can't generate dynamic test nodes that cover the full gamut of functionality available in `TestDescriptor`s.   For a real-world example of a test hierarchy with a TestDescriptor that is both a container and a test, consider the case in Jupiter (or JUnit 4) where a test class has several test methods that all pass, but then it has an `@AfterAll/@AfterClass`-annotated method that throws an exception (this is the exact real-world situation I encountered in my experiment above and led to this feature request).   In my case, I have a workaround - to add a `DynamicTest` child to the `DynamicContainer` that represents my `TestDescriptor` container, which carries the execution state of the `TestDescriptor` container. However, IMO it is visually not quite as nice as how (eg) a failed `@AfterAll` method is represented in the regular hierarchy, and (again IMO) it would be nice if testing developers had the option.  ## Deliverables  A few of options: * Add an optional `Executable` property to `DynamicContainer`. * Add optional children property to `DynamicTest`. * Come up with a third class `DynamicContainerTest` that requires both properties. If `DynamicTest` and `DynamicContainer` had been interfaces this could have simply been through multiple inheritance (which would probably have been the best option) but I think that ship has sailed...  _Edit: fixed potentially confusing typo_","open","status: waiting-for-feedback,","kriegfrj","2020-05-25T06:13:12Z","2021-11-01T09:05:23Z"
"","2216","Allow ParameterResolver to tell apart parameters with a Source in a ParameterizedTest","I've got a `ParameterResolver` that I'm very keen of that injects any parameter in a test class or method with a fresh mock. My problem is that I'm trying to include some ParametererizedTests in my suite and now JUnit is telling me that:  ``` Discovered multiple competing ParameterResolvers for parameter [float arg0] in method [public final void com.package.TestClass.testMethod(float, boolean, MyClass)]: MyTestExtensionClass@33b5ad8e, org.junit.jupiter.params.ParameterizedTestParameterResolver@44b312e ```  In my extension, I have this method to filter parameters  ```kotlin     override fun supportsParameter(parameterContext: ParameterContext, extensionContext: ExtensionContext): Boolean     // We just support regular parameters             = !parameterContext.parameter.isImplicit             && !parameterContext.parameter.isSynthetic             && !parameterContext.parameter.isVarArgs ```  but I'm seeing nothing in `parameterContext.parameter` to filter by parameters that will be supplied by a Source (in my case `@CsvSource`, but it could be any other).  My workaround is going to be to filter out Int, Boolean, String, etc. (I'm using Kotlin), as I'm not going to mock those basic types, but I wonder if I'm overlooking something or if this can be included in a future version, as other extensions may not be able to leverage such a crude solution.  Thanks!","closed","theme: parameterized tests,","serandel","2020-03-16T12:39:50Z","2020-03-17T10:47:03Z"
"","2539","Document concurrency considerations for TestExecutionListener implementations","I've been looking at some documentations to see if there is any thread safety semantics to consider when implementing a `org.junit.platform.launcher.TestExecutionListener`. I haven't found any, so asking here.  More specifically, is there ever a case where the same instance of `TestExecutionListener` could get invoked by multiple threads (simultaneously), such that these implementations need to handle any thread safety issues? If so, is it only for certain methods or do all methods on that interface's implementation need to take into account this aspect? For example, in theory, I wouldn't expect more than one thread invoking the `testPlanExecutionFinished` method.","open","component: Platform,","jaikiran","2021-01-24T05:02:30Z","2022-07-13T13:52:13Z"
"","2378","Allow customization of parameterized test argument names","I've a parameterized test that receives a parameter of type [kotlin.reflect.KFunction](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-function/). For each execution of this test, I'd like to show the simple name of the `KFunction`, not the FQN that currently shoots out of the screen. I've seen the discussion in https://github.com/junit-team/junit5/issues/2301 and https://github.com/junit-team/junit5/issues/2375, but not clear how the `Named` solution proposed there would help my case. If I could get hold of the actual argument passed to the test method, then I could get the simple name out very easily. I think this problem holds for a Java `Method` too, so Kotlin or `KFunction` isn't the use issue.","closed","theme: parameterized tests,","asarkar","2020-08-11T08:03:35Z","2020-08-11T09:26:19Z"
"","2873","TestExecutionResult is Successful when ParameterResolver throws ParameterResolutionException","I'm writing a `ParameterResolver` and trying to test it using `junit-platform-testkit`.  When testing a failure condition, the `TestExecutionResult` object shows the test as pass.  ## Steps to reproduce 1.  Create ParameterResolver that simulates ParameterResolutionException 2. Create test that uses parameter resolver.  3. Use `EngineTestKit` to run test and check `TestExecutionResult` object  Expected Result:  `TestExecutionResult` reports failure with the correct throwable cause  Actual Result:  `TestExecutionResult` reports success/failure based on the assertions in the test.  If I force pass it will report success.  If I force fail, it will report failure but with an AssertionError instead of a `ParameterResolutionException`.  ## Context   - Used versions (Jupiter/Vintage/Platform): junit 5.8.2, junit-platform-testkit 1.8.2  - Build Tool/IDE: Maven + IntelliJ","closed","component: Test Kit,","uchagani","2022-03-30T17:07:29Z","2022-04-01T08:09:31Z"
"","2787","Extend ParallelExecutionConfiguration to specify a predicate for determing if a pool is saturated","I'm working on the Apache Camel project which uses parallel execution on a module with a large number of test cases (over 2400 classes and over 6000 tests.) After upgrading to 5.7.2 or later we were getting RejectedExecutionException which we solved by using a custom configuration with a large value for maxPoolSize.  The cause appears to be that the Tasks for the test classes all call `ForkJoinPool.managedBlock` and the tests themselves can take up to a few seconds to run. Fairly quickly all threads in the ForkJoinPool are busy and therefore each new call to managedBock causes a new thread to be allocated up to the maxPoolSize. Each of these new threads usually runs only 1 or 2 tests.  I found that by providing a predicate for _saturated_ when creating the ForkJoinPool, and having it return true, it was possible to run all the tests with a much smaller maxPoolSize.  Currently it's not possible to control this parameter using a custom implementation of `ParallelExecutionConfiguration`.  So I propose to add a method to the interface such as the following:  ```java /**  * Get the predicate called when there the ForkJoinPool has reached MaxPoolSize  * and there are no threads available, or null. The predicate should return true if the  * blocking thread should try again. If the predicate is null or returns false a  * RejectedExcecutionException is thrown.  * @return a Predicate accepting a ForkJoinPool as the parameter or null.  */ Predicate getSaturatePredicate(); ```  The `DefaultParallelExecutionConfiguration` would return null.  The class `ForkJoinPoolHierarchicalTestExecutorService` would use `configuration.getSaturatePredicate()` when creating the `ForkJoinPool`.","closed","component: Platform,","klease","2021-12-05T21:45:31Z","2022-05-15T17:53:31Z"
"","2083","Provide a way to skip test execution from an extension","I'm working on [QuickPerf](https://github.com/quick-perf), a tool to create performance related test with JUnit. For QuickPerf, we need to be able to launch a test on a different JVM instance, so we need to be able to fork a JVM from within an extension.  My current implementation is to fork the VM inside the extension in `interceptTestMethod` method: https://github.com/quick-perf/quickperf/blob/master/junit5/src/main/java/org/quickperf/junit5/QuickPerfTestExtension.java#L49  Doing this, the method is executed twice (once on each VM), so I would like to be able to skip the test method execution is the host VM but the `Invocation` must be proceed or I have an error.  Today I invoke twice the test methods, what I would like is to have a way to skip a test invocation.  A possible implementation would be to add a `skip` method to the `Invocation` so we can skip it's execution.  ## Deliverables Modify the `Invocation` to be able to skip it. I can provide a PR for this.","closed","component: Jupiter,","loicmathieu","2019-10-25T12:25:38Z","2019-11-10T15:45:25Z"
"","2376","Support @ExtendWith at package level","I'm working a longer time on an extension and thought about the `@ExtendWith` annotation. For my own extension it would make sense to define it on a package level but that does not work, cause `@ExtendWith` is limited to TYPE and METHOD level only.   If `@ExtendWith` would support defining on a package level it could make usage simpler in some situations. This means it could be defined for a number of classes within a package or within the subpackages.  Is there a good reason not to do that? Or did I miss a thing ?  WDYT?","closed","component: Jupiter,","khmarbaise","2020-08-10T07:55:42Z","2020-08-10T08:15:05Z"
"","2256","ParameterizedTest with varargs","I'm using parameterized tests for quite a while now and for the most part they work really intuitive . However today I stumbled upon one thing that felt like it should work, but to my initial surprise didn't. Basically I expected this code to work (in my case it was a `@CsvFileSource`, but doesn't matter): ``` @ParameterizedTest @CsvSource({""1,a"", ""1,a,b,c""}) void testAbc(int arg1, String... elements) {     System.out.println(Arrays.toString(elements)); } ```  I had a quick look at the implementation of the source suppliers and it looks like this ultimately boils down on how an `Argument` instance is ""spread"" to the individual test method arguments. And from my testing it seems like any additional arguments are just cut off. I'd really like to see sort of smart behaviour here: If the last argument of a method is an array (aka varargs) it should try to stuff any trailing arguments into this parameter instead of treating it as a normal object. I must admit that I don't really know what the implications of such a change are. I can imagine that this might break an extension or two that rely on the current behaviour, but overall I think this could be a quality of life improvement, especially if the varargs argument has a different type than String, like java.time or some other more complex type so the dev doesn't have to manually implement a conversion method.  ### Alternative EDIT: I just learned about argument aggregators, which is more or less the thing I'm describing below (pleasant surpsrise tbh 😅), but I still couldn't find a built-in way of splitting a string and potentially auto-converting it to something else.   I came up with a different solution for my particular problem that goes a little bit further, but allows for consistent behaviour and even more complex argument structures.  Think of a fixed example of my previous code: ``` @ParameterizedTest @CsvSource({""1,a"", ""1,a:b:c""}) void testAbc(int arg1, String elements) {     System.out.println(Arrays.toString(elements.split("":""))); } ```  Basically I ended up splitting the variable arguments on my own, but what if there was an annotation similar to `@ConvertWith`, let's call it `@Split` that accepts an optional separator to further subdivides any argument passed to it? So my example would look like this: ``` @ParameterizedTest @CsvSource({""1,a"", ""1,a:b:c""}) void testAbc(int arg1, @Split(':') String[] elements) {     System.out.println(Arrays.toString(elements)); } ```  The benefit of making such a step explicit is that it allows to use this behaviour more than once inside a method. If we go one step further in the example we could even allow for nesting to get n dimensional structures: ``` @ParameterizedTest @CsvSource({""1,a"", ""1,a.0:b.1:c.3""}) void testAbc(int arg1, @Split(value = ':', sub= @Split('.')) String[][] elements) {     System.out.println(Arrays.toString(elements)); } ``` Note that in all cases `@Split` is just a special `@ConvertWith` annotation, so they should be interchangeable.  ### Conclusion  I ended up writing a custom ArgumentConverter that accepts a string and splits it accordingly, but it would still be nice if JUnit-Params offered such a behaviour out-of-the-box","open","theme: parameterized tests,","RoiEXLab","2020-04-11T13:36:03Z","2022-05-24T02:37:33Z"
"","2127","@Timeout does not work when the test prints infinite output to stdout","I'm using JUnit to grade coding exams. Students get points for each passing test, so it's important to me that failures from a single test are isolated - I don't want students' mistakes in one part of the code to affect other tests and cause them to lose more points than they should. Such mistakes sometimes include infinite loops in their code, meaning I need timeouts. And sometimes mistakes include printing text to stdout within an infinite loop...  ## Steps to reproduce  Run the following test:  ```java import org.junit.jupiter.api.*; import java.util.concurrent.*;  class Example {     @Test     @Timeout(value = 2, unit = TimeUnit.SECONDS)     void test() throws InterruptedException {         while(true) System.out.println(""Hello"");     } } ```  The test hangs, despite the timeout.  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter  - Build Tool/IDE: Gradle  On Ubuntu 18.04.3, using Gradle 6.0.1 (latest as of this report) and the following build.gradle:  ``` plugins {     id 'java' }  repositories {     jcenter() }  dependencies {     // JUnit 5 ""Jupiter""     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.5.2'     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.5.2' }  test {     useJUnitPlatform() } ```  I run tests with `./gradlew build`.  Note that replacing the `while(true)` loop above with `Thread.sleep(60 * 1000)` causes the test to fail with a `TimeoutException`, as expected.  ## Deliverables  - [ ] Make `@Timeout` work even when the test prints infinite output to stdout","closed","component: Jupiter,","SolalPirelli","2019-12-13T16:32:06Z","2019-12-14T13:14:32Z"
"","2325","no argument constructor causes super classes @BeforeAll to no be invoked","I'm using JUnit 5.6.2.  If my test class has a no argument constructor the parent classes @BeforeAll method is not invoke.  ## Steps to reproduce  Create a test class that has a no argument constructor.  ``` public class MyTest extends IntegrationTestParent {     public String aVar = null;     public MyTest() { // edited to remove typo.          aVar = ""hi"";     } }  public class IntegrationTestParent {     @BeforeAll     public static void beforeIntegrationTests() {         System.out.println(""super class"");    }      } ```  It does not appear I can workaround this by calling the super class's `@BeforeAll` method manual.  It appears that the presence of the constructor in the test class causes `@BeforeAll` to not be invoked at all.  IE, this will not work around the problem.  ``` @BeforeAll      public static void setupMyTest() {         IntegrationTestParent.beforeIntegrationTests();     } ```  I'll default to `@BeforeEach`, it's wasteful but it's a workaround. ## Context   - JUnit 5.6.2  - IntelliJ and Gradle 5.6.","closed","component: Jupiter,","donahchoo","2020-06-15T20:41:41Z","2020-06-16T15:23:14Z"
"","2399","InvocationInterceptor.interceptDynamicTest does not provide access to the invocation context","I'm using JUnit 5.6.2.  I work on an extension that needs to have access on  the invoked test method.  For standard tests, the `InvocationInterceptor.interceptTestMethod` gives access to a `ReflectiveInvocationContext` that gives access to the test method.  For dynamic tests, the `InvocationInterceptor.interceptDynamicTest` don't include any `ReflectiveInvocationContext` so we cannot access the test method.  Note that a `ReflectiveInvocationContext` is provided in almost all intercept methods except the dynamic test one.  An alternative would be to give access to the `DynamicTest` object itself.","closed","theme: dynamic tests,","loicmathieu","2020-09-07T12:32:59Z","2020-10-25T16:22:44Z"
"","2578","Expose a 'tearDown' method for custom ArgumentsProvider","I'm using a custom ArgumentsProvider to inject a limited resource (a session object on external hardware that has a limited number of sessions). The ArgumentsProvider allows me to inject multiple implementation types of external hardware, depending upon what is connected to the machine at the time the test suite is run. It also ensures I fetch a new session for each test case (which is important as the external systems love to save state within a local session).   This all seems to work well for now, it's both flexible and fast, but as the number of test cases increases I'm expecting there will come a time when we start running out of sessions on some of the external systems. The external tool API provides an explicit logout method I can use to revoke the current session, but I can't figure out how to wire up a custom ArgumentsProvider with any type of JUnit teardown method.   While I'm sure I may be hitting an edge case, I wonder if there is value in offering a general purpose `recycle(Arguments)` method. Alternatively, perhaps such an API exists and I'm just unaware of it","closed","theme: parameterized tests,","hamiltont","2021-03-20T00:34:51Z","2021-03-20T14:57:51Z"
"","2199","Enhance tag filtering to support filtering on presence of only specific tag(s) without needing to explicitly name all excluded tags","I'm trying to run all JUnit5 test methods which are tagged as ""Special"" and NOT tagged with any other tags.  I'm trying to avoid the need to hardcode/discover the superset of all tags, just so that I can form an exclude tag expression to accomplish this.  It should be possible to form a tag expression that says: everything tagged ONLY with 'special' (i.e. the 'special' tag is present AND no other tags are present).","closed","status: stale,","tcfurrer","2020-02-25T19:58:12Z","2021-06-19T12:50:15Z"
"","2657","Get unique ID from TestInfo","I'm trying to create a unique folder per test (including parameterized tests) in a specific location, so I wanted to use the test unique ID (assuming it's unique also for each parameterized test) but it is not available in TestInfo. Should it be there or could it be added?  Thanks.","closed","status: new,","xtaixe","2021-07-03T12:55:48Z","2022-07-26T22:38:32Z"
"","2487","Filter DisabledIfEnvironmentVariable by OS.","I'm looking for a way to scope `DisabledIfEnvironmentVariable` to a particular OS in order to disable certain unreliable tests when run in CI. I see there is a `DisabledOnOs` annotation available but it doesn't seem it can be used in combination with `DisabledIfEnvironmentVariable` for this purpose.","closed","component: Jupiter,","jameshilliard","2020-12-07T23:23:57Z","2021-02-02T19:14:21Z"
"","2970","New extension with test templates","I'm creating an **extension** for running tests to different instances.   The test class has an annotation that has all information to discover which instances should be tested. The annotation is a consul service name. I discover all the instances with the ```BeforeAllCallback``` and save them for later in the store that is in the ```ExtensionContext```. (step 1)  The test class has a ```@TestTemplate``` test. With the ```TestTemplateInvocationContextProvider``` I generate a stream of ```TestTemplateInvocationContext```Objects. In the object I have overridden the ```getDisplayName(final int invocationIndex)```. The stream is based on the list of environments I have created in step 1. (Let's call this step 2).   Then what happens is that the class will be instantiated with the ```TestInstanceFactory``` interface. The method ```createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext)``` is called; but here starts the problem: I have no indication for which test-(template-)instance the class is instantiated, so I have no reference for which environment this object is instantiated. (Step 3). I need to know why the object is to be instantiated, so I can call the constructor with the consul-information from step 1.  At first I made a 'dirty hack' to just have an internal counter to give every construction another environment; which works okay for 1 ```@TestTemplate```, but if you have more than one and do it multithreaded, the environments are divided totally wrong: Test1-Env1 gets Env1, Test2-Env1 get Env2, Test2-Env2 gets Env3, Test1-Env2 gets Env4.  To run the test I use ```interceptTestTemplateMethod(Invocation invocation, ReflectiveInvocationContext invocationContext, ExtensionContext extensionContext)``` because I need to have initialization around the actual run of the test method.  What I need and can't find is that I need some sort of connection between the stream of tests that are created in step 2 and the construction of the test object for that specific test in step 3.   ```java @ServiceName(""myservice"") @ExtendWith(ConsulExtension.class) @Execution(ExecutionMode.CONCURRENT) class ExtensionTest  {   private static final Logger logger = LoggerFactory.getLogger(ExtensionTest);    private final ConsulTestContext consulTestContext;    public ExtensionTest(final ConsulTestContext ctx) {     logger.info(""Constructor with ConsulTestContext: "" + ctx);     consulTestContext = ctx;   }    @TestTemplate   public void myTestTemplate() {     final long wait = Math.round(Math.random() * 3_000d) + 1_000L;     logger.info(""TestTemplate test "" + consulTestContext.getMachine() + "" class = "" + this + "": waiting "" + wait + "" ms"");     try {       Thread.sleep(wait);     } catch (final InterruptedException ignored) {     }   } } ```  ## Deliverables  - [ ] PR to provide the right ExtensionContext (the MethodExtensionContext instead of the ClassExtensionContext) to the constructor if it is instantiated by a @Test or @TestTemplate - https://github.com/junit-team/junit5/pull/2961","open","status: new,","svenkost","2022-07-07T08:41:45Z","2022-07-07T09:37:46Z"
"","2016","Allow tests to be enabled or disabled on a range of JREs","I'd like to test some code that behaves in different ways depending on the version of the JRE on which it's running. In my particular case, the code behaves in one way on Java 12 and earlier and in another on Java 13 and later. We have CI jobs that test on Java 8, 11, 12, and 13 (we'll probably drop 12 soon due to it being superseded by 13).  As CI jobs on new JREs are added and removed, I'd prefer for it not to be necessary to change the code to make sure that the right tests are enabled. As far as I can tell, even if `@EnabledOnJre` and `@DisabledOnJre` were repeatable, this goal would not be met. Instead, what I'd really like to be able to do is specify a (possibly open-ended) range of JREs on which a test should be enabled or disabled. In my particular case being able to enable a test on JRE 12 and earlier and another on JRE 13 and later would be sufficient, but I'm sure there are other use cases that would benefit from support for closed ranges.  ## Deliverables  - [x] Support for enabling or disabling a test on a range of JREs","closed","component: Jupiter,","wilkinsona","2019-09-19T10:43:44Z","2019-11-08T17:43:39Z"
"","2702","Implicit conversion from integral numbers to byte array","I'd like to propose the addition of implicit conversion from integral numbers (`byte`, `short`, `int`, `long`) to byte array. The concrete use case is code dealing with bitwise operations, mostly related to cryptography.  My wish is to write something like this:  ```java   @ParameterizedTest   @ValueSource(ints = {Integer.MIN_VALUE, 0, 0xFF, 0xFFFF, 0xFFFFFF, Integer.MAX_VALUE})   void test(byte[] byteArray) {     assertThat(byteArray).hasSize(4);   } ```  where I can leverage binary and hexadecimal literals which are automatically converted to a byte array using a [`ByteBuffer`](https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html) with Big Endian order.  I put together [a small poc](https://github.com/scordio/junit5-playground/tree/master/src/test/java/com/github/scordio/junit/jupiter/params/converter) with a custom argument converter. If the proposal is accepted, I'm happy to raise a PR about it.  ## Deliverables  - [ ] A new implicit conversion from `byte` / `short` / `int` / `long` to `byte[]`","open","theme: parameterized tests,","scordio","2021-09-01T19:50:51Z","2021-12-30T13:59:10Z"
"","2761","Introduce MATCHES_NONE selection mode in @EnumSource","I would like to exclude constants using a regex but found that although you can exclude by name, you can't exclude by regex.  Negating a regular expression is rather cumbersome and unreadable (something like this: `^((?!foo).)*$`).  I propose to extend the `EnumSource.Mode` with `MATCHES_NONE`:  ```java enum Mode { 	INCLUDE_NAMES((name, names) -> names.contains(name)), 	EXCLUDE_NAMES((name, names) -> !names.contains(name)), 	MATCHES_ALL((name, expressions) -> expressions.stream().allMatch(name::matches)), 	MATCHES_ANY((name, expressions) -> expressions.stream().anyMatch(name::matches)), 	MATCHES_NONE((name, expressions) -> expressions.stream().noneMatch(name::matches));     } ```","closed","theme: parameterized tests,","hjohn","2021-10-29T12:36:47Z","2021-11-04T13:13:58Z"
"","2482","Add Assumptions.assumeDoesNotThrow","I wish to skip some of my larger integration tests, if the target environment is not available/healthy.  For that I have to perform a http call.  If the environment is not available/running/health, I get an exception. If it is healthy I get an OK-Health status with some additional metadata I slightly care about.  Currently I use the following construct for my assumption check.  ````java try {     List services = cluster.listServices();     assumeThat(services)             .isNotEmpty()             .contains(testServiceName);     [...] } catch (IncompleteExecutionException e) {     throw e; } catch (Exception e) {     throw new TestAbortedException(""Cluster not properly configured or not available"", e); } ````  I would like to be able to use the `Assumptions` here similar to the `Assertions.assertDoesNotThrow(...)`.  ````java List services = assumeDoesNotThrow(cluster::listServices, ""Cluster not properly configured or not available""); assumeThat(services)         .isNotEmpty()         .contains(testServiceName); ````  I'm willing to PR this feature, if it gets accepted.","open","status: waiting-for-interest,","ST-DDT","2020-11-26T13:15:25Z","2022-04-24T11:26:45Z"
"","2285","TestEngineKit by default picks up settings for parallel execution","I was working on [JUnit-pioneer #131](https://github.com/junit-pioneer/junit-pioneer/issues/131), which is about making some extensions thread safe, e.g. due using the `@ResourceLock` annotation.   For testing purposes I set the execution to the most parallel execution possible (Test classes and methods inside each class are executed in parallel):  ```properties #  Enable parallel execution of JUnit tests junit.jupiter.execution.parallel.enabled=true # Run all tests methods inside a class in parallel as default junit.jupiter.execution.parallel.mode.default=concurrent # Run all tests classes in parallel as default junit.jupiter.execution.parallel.mode.classes.default=concurrent # Explicit set the execution strategy to dynamic (default strategy) junit.jupiter.execution.parallel.config.strategy=dynamic # Explicit set the factor of dynamic strategy to its default value  junit.jupiter.execution.parallel.config.dynamic.factor=1 ```  It seems that by current default the `TestEngineKit` also picks up those settings for parallel execution(_, which results in a large amount of flaky tests, when you verify your tests using the engine kit_). @marcphilipp thinks this is unexpected, when using EngineTestKit and JUnit should not do this be default. So he [asked](https://github.com/junit-pioneer/junit-pioneer/issues/131#issuecomment-622953047) me to open an issue for further investigation and decision.  Note: He also mentioned that a workaround for the current behavior is so disable the parallel execution at the `TestEngineKit` using `.configurationParameter(""junit.jupiter.execution.parallel.enabled"", ""false"")`.","closed","component: Test Kit,","Bukama","2020-05-02T14:44:52Z","2020-06-15T12:13:18Z"
"","2311","Better diagnostics for orphaned selectClass() on a nested class","I was trying to write a test for a custom extension using EngineTestKit and I was using small inner classes as fodder to feed the extension to verify that it does the right thing. This has been working for me for a while.  Unfortunately, when I started a new top-level class, I didn't notice that I had forgotten the `static` keyword on the the first inner class that I created in this new top-level class. I was calling selectClass() on this inner class and passing it in to EngineTestKit, and then wondering why the engine wasn't discovering any tests. It was especially confusing because I new that I had used the same technique elsewhere. It wasn't until I stepped through the resolution line-by-line with the debugger that I figured out what was going on. This obviously wasted a significant amount of my time for what turned out to be a trival issue.  It makes perfect sense that the resolver would not be able to resolve the tests in a nested, non-static class where the enclosing class has not been included. However, the way that this manifests is confusing to the user. I think it would be better if some kind of precondition violation was thrown in this situation as it is much more likely to be a programming mistake that needs attention than it is to be a legitimate scenario.","closed","theme: diagnostics,","kriegfrj","2020-06-03T03:38:02Z","2020-06-05T10:40:32Z"
"","2651","Support ordering between @ExtendWith and @RegisterExtension","I was trying to write a [Micronaut test](https://micronaut-projects.github.io/micronaut-test/latest/guide/#junit5) using the `@MicronautTest` annotation. This annotaiton is a meta-annotation that includes `@ExtendWith(MicronautJunit5Extension)`. However, I also needed to start up some other services with random port numbers and add those ports to Micronaut's configuration. I tried doing so with `@Order(1) @RegisterExtension MyOtherService service`, but that didn't work. The MicronautExtension is still called first and fails because calling `getPort` on my service can't be done until it has started.  It would be great if `@Order` worked together with `@ExtendWith`, so that I could push my service in front of Micronaut's startup.  Workaround:  Don't use `MicronautTest` with all its convenience and instead use `ApplicationContext.run(EmbeddedServer.class, properties)`.  ## Deliverables  - [ ] ...","open","status: new,","oehme","2021-06-21T15:28:49Z","2021-08-03T15:55:18Z"
"","2486","Documentation Request - Improvement to Extension Order Documentation","I was looking for a complete list of all extension interfaces and the order in which they are executed, but I the closest thing I was able to find was the [User code and extension code](https://github.com/junit-team/junit5/blob/main/documentation/src/docs/asciidoc/user-guide/extensions.adoc#extensions-execution-order-diagram) which is missing several extension user implementable extension interfaces. For example, as far as I can tell, `TestInstancePostProcessor` happens after `@BeforeEach` but before `@Test`. If these details exist in a java doc and I simply missed the documentation please point me to the right place in a comment and close.  ## Deliverables  - [ ] Update [Extensions Doc](https://github.com/junit-team/junit5/blob/main/documentation/src/docs/asciidoc/user-guide/extensions.adoc) to include all stable and user facing extension interfaces. - [ ] Consider documenting Experimental Interfaces such as `TestInstancePreDestroyCallback` - [ ] Update acceptance requirements to include new extension interfaces in the execution order documentation when merged or migrated to `status = STABLE`","open","component: Jupiter,","JKomoroski","2020-12-01T23:58:14Z","2021-08-15T07:50:32Z"
"","2893","Jupiter static @TempDir behaves unexpected when subclasses are run in parallel","I wanted to supply an MCVE, but I was not able to, as I was not able to find a way to influence the order in which the `@TempDir` handling extension initializes classes. Even a static initializer in the affected classes is executed after (!?!) the extension injected the static fields, but I try to describe the problem.  If you have a construct like  ```java @Execution(CONCURRENT) abstract class Base {     @TempDir     static Path tempDir;      @Test     void foo() {} }  class A extends Base {} class B extends Base {} ```  and now run `A` and `B` in parallel, the extension creates one temp directory for `A` and one temp directory for `B`. Then it sets the `Base.tempDir` field for the one that happens to execute first, let's call it `SubFirst`. Then it sets the same field for the one that happens to execute second, let's call it `SubSecond`, and thus overwrites the value written for `SubFirst` as it is a static field in `Base`.  Now A and B both work with the same temporary directory. This can already mean problems of course.  In my case it did not yet cause problems, as the test created a further subdirectory depending on the actual class name, so there was no conflict in the actual files created and verified.  But then, if `SubSecond` is finished first, its temp directory is deleted, and now `SubFirst` has a problem if he still used the temporary directory as suddenly its files and even the folder might be deleted already.  I guess this is hard to ""do right"", but it is at least majorly confusing.  I actually exepected the scope of the `tempDir` to be for `A` and `B` and the directory only getting deleted after all subclasses are finished executing which would have been exactly what I needed. (I solved it differently now).  Another possibility might be to either disallow static tempdir fields in concurrent specs, or to automatically add some read-write resource so that the test classes are not run in parallel.","open","status: new,","Vampire","2022-04-18T16:47:30Z","2022-04-24T14:36:34Z"
"","2538","Ability to discover test classes multiple times and load them using different classloaders","I want to run a set of tests where each test is executed multiple times and each time the test class would be loaded using a different classloader. That is, given test classes A, B and C, I want to create two executions for each class where I would load them with a different, custom classloader for one of those executions.  One way to achieve this is to implement a test engine that would delegate discovery and execution to an existing test engine and to intercept the discovery phase (where the test classes are loaded).  Given I have an `EngineDiscoveryRequest` with some class selectors, in the test engine's `discover` method, I can call the target engine's `discover(request, id)` multiple times, giving a unique id for each execution that I want to create. I can then aggregate the returned test descriptors and the tests will be executed multiple times.  For the classloading part, the test classes are loaded in `ClassSelector` lazily whenever `getJavaClass()` is called, which happens when the engine is discovering tests. If the class selectors that arrive to my custom test engine have only class names set, the classes will not have been loaded yet and there I can influence the classloader to use by setting it using `Thread.currentThread().setContextClassLoader(...)` before delegating the discovery. This works just for one execution though as the loaded classes will be cached in the current discovery request. From here, in order to create the second execution and have the classes loaded using a different classloader, I have to create a new `EngineDiscoveryRequest` based on existing one and create new `ClassSelectors` from existing ones using `DiscoverySelectors.selectClass(selector.getClassName())`. There doesn't seem to be an API to create a new discovery request based on existing one for such use case. One alternative that works is to decorate an existing `EngineDiscoveryRequest` by implementing `EngineDiscoveryRequest` and delegating everything but `getSelectorsByType(...)` to the existing request.  While I seem to be able to achieve what I'm after in the end, I am wondering if this can be simplified. For example, if the `ClassSelector` would not cache the loaded test class itself, I would be able to reuse the existing discovery request by setting the classloader on the current thread for each discovery iteration. Or perhaps an API could be exposed that would allow setting the classloader for a discovery request and then to create a new discovery request based on an existing one - something along the lines of `DiscoveryRequests.from(existingRequest).withClassLoader(...).build()`.","closed","status: stale,","rieske","2021-01-19T16:10:48Z","2022-02-25T11:22:59Z"
"","2435","Why are strange characters in console output?","I use org.junit.platform.console.ConsoleLauncher as an eclipse run config.  Output:  ``` Test plan execution started. Number of static tests: [34m2 [0m[36m╷ [0m├─[36m JUnit Vintage[0m └─[36m JUnit Vintage[0m finished after 3 ms. ├─[36m JUnit Jupiter[0m │  ├─[36m MyExampleJUnit5UnitTest[0m │  │  ├─[34m abc() [0m│  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:testing.junit.MyExampleJUnit5UnitTest]/[method:abc()] │  │  │     parent: [engine:junit-jupiter]/[class:testing.junit.MyExampleJUnit5UnitTest] │  │  │     source: MethodSource [className = 'testing.junit.MyExampleJUnit5UnitTest', methodName = 'abc', methodParameterTypes = ''] test1 │  │  │   duration: 13 ms │  │  │     status: [32m✔ SUCCESSFUL [0m│  │  ├─[34m cba() [0m│  │  │       tags: [] │  │  │   uniqueId: [engine:junit-jupiter]/[class:testing.junit.MyExampleJUnit5UnitTest]/[method:cba()] │  │  │     parent: [engine:junit-jupiter]/[class:testing.junit.MyExampleJUnit5UnitTest] │  │  │     source: MethodSource [className = 'testing.junit.MyExampleJUnit5UnitTest', methodName = 'cba', methodParameterTypes = ''] test2 │  │  │   duration: 2 ms │  │  │     status: [32m✔ SUCCESSFUL [0m│  └─[36m MyExampleJUnit5UnitTest[0m finished after 27 ms. └─[36m JUnit Jupiter[0m finished after 42 ms. Test plan execution finished. Number of all tests: [34m2 [0m Test run finished after 69 ms [         3 containers found      ] [         0 containers skipped    ] [         3 containers started    ] [         0 containers aborted    ] [         3 containers successful ] [         0 containers failed     ] [         2 tests found           ] [         0 tests skipped         ] [         2 tests started         ] [         0 tests aborted         ] [         2 tests successful      ] [         0 tests failed          ]   ```   What's that? -> ``   ???","closed","component: Platform,","jayjupdhig","2020-10-02T13:58:58Z","2020-10-05T10:25:25Z"
"","2412","SuiteTestEngine and JUnitPlatform Runner ignore tests without ""Test"" in class name","I use org.junit.platform 1.6.2 with org.junit.jupiter 5.6.2 and have two classes with integration tests `FooIT` and `TestBarIT`.  This is my configuration:  ```java     @RunWith(JUnitPlatform.class)     @SelectClasses({ FooIT.class, TestBarIT.class })     public class SuiteIT { } ```  However, tests in `FooIT` will be ignored if I don't add word `Test` (for example `TestFooIT`). But I don't want to add word `Test` as we have a strict naming convention for tests.   I think this is the wrong behavior because Test classes are set explicitly - a developer sets list of classes but JUnit filters it. So, who knows better what classes to use - the developer or JUnit?  Can anyone suggest a workaround for a now to make JUnit suite accept classes without `Test` in their names or to configure it use `IT` for class checking?","closed","theme: suites,","PashaTurok","2020-09-18T13:22:05Z","2021-08-11T14:18:03Z"
"","2279","How to mark a test as 'error'","I understand when to mark a test as 'pass', 'fail' or 'skip', but I'm wondering how to mark a test as 'error'. Demo test result: `testsuite name=""MainTest"" tests=""5"" failures=""0"" errors=""0"" skipped=""0"" time=""102.631"".`  Since there is a `errors=""0""`, maybe it's possible to mark as 'error'? There is a special scenario I need to mark a test as 'error', how am I supposed to do that?","closed","status: works-as-designed,","Moriarty16","2020-04-29T09:44:21Z","2020-05-09T11:53:49Z"
"","2014","Introduce @FieldSource for parameterized tests","I understand that for memory/performance you probably want to recommend everyone use a Stream-returning method and `@MethodSource`, but given that an `@ArraySource` would be easier to use without having to convert all test data into methods, this would be a nice-to-have.","closed","status: stale,","ktkopone","2019-09-18T22:15:27Z","2022-07-11T20:21:41Z"
"","2434","How to start a JUnit test from Eclipse console with JUnit as an application with main() method?","I tried at least 10 different parameter combinations - nothing works:  ![Unbessdsdnannt](https://user-images.githubusercontent.com/42765391/94926757-8fa3ad80-04c1-11eb-8623-197ab7564066.jpg)  And when i look at https://stackoverflow.com/questions/52373469/how-to-launch-junit-5-platform-from-the-command-line-without-maven-gradle/52373592#52373592 or https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher i can't find any useful (concrete) examples...  ...just things like: `java -jar junit-platform-console-standalone-.jar `  - that can also be shown with -help-paramter on ""java -jar JUnit.jar ...""  Thank you for your feedbacks.   With kind regards, Jan","closed","component: Platform,","jayjupdhig","2020-10-02T13:14:08Z","2020-10-05T10:57:04Z"
"","2760","Allow EnumSource to provide arguments","I think `EnumSource` is one of the best tools currently available for parameterized tests, being type safe and using the name of the enum to describe the test data, for example:  ```java     enum DataSet {        SMALL(Set.of(""a"", ""b"", ""c""), 3),        LARGE( ... , 3000),        EMPTY(Set.of(), 0);         private Set set;        private int expectedCount;         DataSet(Set set, int expectedCount) {            this.set = set;            this.expectedCount= expectedCount;        }         public Set getSet() {            return set;        }         public int getExpectedCount() {             return expectedCount;        }     } ```  However, I think the `@ParameterizedTest` itself could be invoked a bit nicer.  Instead of having:  ```java      @ParameterizedTest      @EnumSource(DataSet.class)      void shouldHaveExpectedCount(DataSet dataSet) {           assertEquals(dataSet.getExpectedCount(), dataSet.getSet().size());      } ```  ...it would be much nicer if one could write:  ```java      @ParameterizedTest      @EnumSource(DataSet.class)      void shouldHaveExpectedCount(Set set, int expectedCount) {           assertEquals(expectedCount, set.size());      } ```  In other words, the parameter names should be examined (`set` and `expectedCount`), and be checked to see if they have matching getters in the given `EnumSource`.  If so, then provide those parameters directly.","closed","type: new feature,","hjohn","2021-10-29T11:50:08Z","2021-11-26T11:30:35Z"
"","2871","Add ArgumentAccessor#from(Arguments)","I still found myself keep failing by writing following code.  ```java Stream a1() { } Stream a2() {     return a1().map(a -> {         ArgumentAccessor accessor = new DefaultArgumentAccessor(a); // should be a.get();     }); } ```  Please add `ArgumentAccessor#from(Arguments)` as once mentioned https://github.com/junit-team/junit5/issues/2081#issuecomment-545964383.  ## Deliverables  - [ ] Add `ArgumentAccessor#from(Argument)`","open","status: new,","onacit","2022-03-30T12:52:50Z","2022-03-30T15:16:23Z"
"","2234","Consider moving dependency versions to gradle.properties (and remove Versions from buildSrc)","I see you've moved the versions to dependency constraints (which I think is nice), however, it looks like there's no point in having `Versions` in `buildSrc`.  The problems with `Versions` object are: 1) Every time `Versions` is updated the whole thing is rebuilt 2) The only option to try a new version is to edit the build scripts.  What do you think if the versions are moved to `gradle.properties` instead? For instance:  gradle.properties: ```properties apiguardian-api.version=1.1.0 picocli.version=4.2.0 ... ```  Then dependency constraints can be created as follows:  ```kotlin val String.v: String get() = rootProject.extra[""$this.version""] as String  fun DependencyConstraintHandlerScope.apiv(     notation: String,     versionProp: String = notation.substringAfterLast(':') ) =     ""api""(notation + "":"" + versionProp.v)  dependencies {     (constraints) {         apiv(""org.apiguardian:apiguardian-api"")         apiv(""info.picocli:picocli"")         ...     } } ... ```  It would 1) Consolidate the versions in `gradle.properties` 2) Enable testing with newer versions via `-Ppicocli.version=5.0.0` 3) Avoid recompilation when `Versions` is updated","closed","theme: build,","vlsi","2020-04-03T10:09:49Z","2020-04-04T16:18:47Z"
"","2237","Kotlin style: official or not?","I see you often use `tabs` for Kotlin code which looks weird in GitHub diffs.  Is it accidental or a deliberate choice?  Kotlin official style guide suggests using 4 spaces for indentation: https://kotlinlang.org/docs/reference/coding-conventions.html#formatting","closed","","vlsi","2020-04-04T09:37:42Z","2020-05-22T19:55:21Z"
"","2516","ConfigurationParameters values does not appear to be comprehensively documented","I searched https://junit.org/junit5/docs/current/user-guide/#running-tests-config-params and the surefire plugin (which seems to have some different values from what I found in the user-guide. Could you please add a comprehensive list to this section of documentation?","open","theme: documentation,","xenoterracide","2021-01-05T23:41:08Z","2021-08-15T07:50:32Z"
"","2038","Surprisingly limited parallel test execution with ResourceLock and ResourceAccessMode.READ","I observed the following behavior as detailed below, where test methods using resource lock with READ mode appear to be unnecessarily sequenced.  Even though ResourceLock documents that `[...] the annotated element _may_ be executed concurrently with other test classes or methods [...]` (emphasis mine), the observed test executions are somewhat a surprise to me.  ## Steps to reproduce  Consider the following MWE:  ```java import static org.junit.jupiter.api.Assertions.assertEquals;  import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.IntStream;  import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;   //@ResourceLock(value = ""sharedResource"", mode = ResourceAccessMode.READ) class ResourceLockTest { 	private static AtomicInteger executingRead = new AtomicInteger(); 	private static AtomicInteger maxRead = new AtomicInteger();  	@AfterAll 	static void afterAll() { System.out.println(""max executing reads = "" + maxRead); }  	@ParameterizedTest 	@MethodSource(""ints"") //	@ResourceLock(value = ""sharedResource"", mode = ResourceAccessMode.READ) 	void test(final int arg) { rememberMax(); }  	@Test //	@ResourceLock(value = ""sharedResource"", mode = ResourceAccessMode.READ) 	void test2() { rememberMax(); }  	@Test //	@ResourceLock(value = ""sharedResource"", mode = ResourceAccessMode.READ) 	void test3() { rememberMax(); }  	@Test //	@ResourceLock(value = ""sharedResource"", mode = ResourceAccessMode.READ) 	void test4() { rememberMax(); }  	@Test //	@ResourceLock(value = ""sharedResource"", mode = ResourceAccessMode.READ_WRITE) 	void testWrite() { assertEquals(0, executingRead.get()); }  	private void rememberMax() { 		final int active = executingRead.incrementAndGet(); 		maxRead.getAndUpdate(v -> v > active ? v : active); 		try { 			Thread.sleep(50); 		} 		catch (final InterruptedException e) {} 		executingRead.decrementAndGet(); 	}  	private static IntStream ints() { return IntStream.rangeClosed(1, 100); } } ```   ### Results  * Baseline to check correct junit concurrency config, running with resource lock commented out: consistently results in _max executing reads_ of 8 (on my machine), and `testWrite` can fail. **Expected**.  * Enable ResourceLocks *on methods*:     - normal test methods with READ run usually in parallel. **Expected**.     - the parameterized test has consistently a max read of 1. **Correct, but unexpected**.  * Enable ResourceLock on class: consistently a max read of 1. **Correct, but very unexpected**.  Especially the last point I find surprising. With many test methods, it makes sense to move the lock to the class (and not have it on each method). Such change seems valid but results in degraded execution time.  ## Context  junitJupiterVersion = '5.5.2'  ``` Gradle 5.6.2 Build time:   2019-09-05 16:13:54 UTC Revision:     55a5e53d855db8fc7b0e494412fc624051a8e781  Kotlin:       1.3.41 Groovy:       2.5.4 Ant:          Apache Ant(TM) version 1.9.14 compiled on March 12 2019 JVM:          12.0.2-BellSoft (BellSoft 12.0.2-BellSoft+11) OS:           Mac OS X 10.15 x86_64 ```  junit.platform.properties  ``` junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent junit.jupiter.execution.parallel.mode.classes.default = concurrent junit.jupiter.execution.parallel.config.dynamic.factor = 1 ```  ## Deliverables  - [ ] Clarify if the current performance behavior of the built-in ResourceLock is intended","closed","component: Jupiter,","bmalinowsky","2019-10-03T14:19:27Z","2022-06-26T11:14:11Z"
"","2428","XyzTest or XyzTests?","I noticed that the JUnit 5 own test classes are named like XyzTests using the plural. But in the JUnit 5 examples the singular is used, like XyzTest. And that was until now the common convention to name them with the singular.  Do you now recommend to use the plural? Logically it makes more sense to do that. On the other hand, class names have the convention to be a singular noun.  Technically both naming conventions work of course. But which one do you suggest to use?","closed","type: question,","pandoras-toolbox","2020-09-28T11:00:27Z","2020-09-28T11:56:13Z"
"","2625","Define an offical XSD for JUnit XML test reports","I maintain a project used to output tests reports for .Net code into the junit format. In trying to provide this capability, we keep bumping up against the question of what, exactly, is the junit format. For example https://github.com/spekt/junit.testlogger/issues/41 asks for `system-out` to recorded per test case, and not at the end of the file. The user who opened that issue pointed to the jenkins schema you used in this repo for some unit testing. But the standard we adopted for our logger was the Ant unit schema (which I picked b/c of comments suggesting it was the de-facto standard which I found a while ago in this or the junit4 repo/docs).  Among the .Net community, the junit format is used extensively with CICD tools like gitlab, circleCI... And if you look at the gitlab docs https://docs.gitlab.com/ee/ci/unit_test_reports.html you will see quite a lot of tooling exists to produce junit reports. So, I'm sure i'm sure mine is not the only project that has run into this question.   The Jenkins schema looks like an improvement over the ant one, at least when it comes to `system-out`, but swapping schemas on my end will be a breaking change for some of my users whose CICD systems are doing strict validation against an XSD. I'm reluctant to start adding feature flags to let users choose which schema they want.   Note, I also saw #373 is looking at creating a new format, but i'm really interested in what the current format is, and probably having a version number or something on the format. I also saw that the discussions on that issue are talking about switching to json, yml or other formats. Please keep in mind what a big ecosystem of users there who are using this format.   ## Deliverables  Please produce or select an XSD as the official one. Since it looks like you are doing all you internal unit tests against the jenkins format, it seems like that might be the answer. But a definite answer would be great one way or the other.","closed","theme: build,","Siphonophora","2021-05-26T20:27:52Z","2021-05-28T10:21:00Z"
"","1967","Multiple @TempDirs should result in multiple directories","I just got bitten by the (IMHO counter-intuitive) behavior of `@TempDir`: When using it in multiple places, each injection point gets the **same** directory injected. That is, the following does not do what one would intuitively expect:  ```java void test(@TempDir File source, @TempDir File target) {     ... } ```  Both `source` and `target` point to the same directory!  Of course, you can work around this:  ```java void test(@TempDir File tempDir) {     File source = new File(tempDir, ""source"");     File target = new File(tempDir, ""target"");     ... } ```  But this feels unnecessarily complex for this, IMHO, rather common use case.  If, on the other hand, injecting the same temporary directory in multiple places is _really_ what is desired, one can even imagine the following API to still support that use case:  ```java @TempDir(""id"") Path samePath;  void test(@TempDir(""id"") File sameDir) {     ... } ```  ## Deliverables  - [x] An update to `TemporaryDirectory` which sets up (and tears down) a new temporary directory at each injection point.","closed","component: Jupiter,","sewe","2019-07-26T08:28:53Z","2021-08-17T09:33:51Z"
"","2794","Support multiple `junit-platform.properties` on the classpath","I implemented a [`ClassOrderer` for Quarkus](https://github.com/quarkusio/quarkus/blob/2.6.0.CR1/test-framework/junit5/src/main/java/io/quarkus/test/junit/util/QuarkusTestProfileAwareClassOrderer.java) and the idea was to enable that orderer by default for all Quarkus users (and also for the Quarkus CI). But I overlooked the fact that `junit-platform.properties` is only expected once on the classpath and if there already is a project-specific properties file (e.g. with `junit.jupiter.extensions.autodetection.enabled`) there are many warnings issued by this code: https://github.com/junit-team/junit5/blob/r5.8.2/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfigurationParameters.java#L232-L236  Btw, that orderer is configurable, so the original idea also was to just add (as a Quarkus user) a custom `junit-platform.properties` to your project _with only the respective property_ (_without_ repeating `junit.jupiter.testclass.order.default`).  It would come in very handy if _all_ `junit-platform.properties` on the classpath would be merged, in the order as they appear on the cp. I'm not sure whether a flag to go back to the previous behavior would be required, which is a bit of a chicken and egg situation I guess (where to put it?).","open","component: Platform,","famod","2021-12-12T21:20:25Z","2021-12-13T07:48:54Z"
"","2661","Allow to intercept DynamicContainer#getChildren via InvocationInterceptor","I hereby agree to the terms of the JUnit Contributor License Agreement.  The Creation of DynamicNodes can be intercepted via InvocationInterceptor# interceptTestFactoryMethod, the execution of DynamicTests can be intercepted via InvocationInterceptor#interceptDynamicTest. IMHO there is a gap between where the DynamicContainers are (if existing) evaluated.  In order to have an API which is consistent an method   InvocationInterceptor#interceptDynamicContainter should be added.","open","status: waiting-for-feedback,","BerndFarkaDyna","2021-07-06T18:51:39Z","2022-05-20T10:39:01Z"
"","2019","Fix link to LICENSE.md","I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: documentation,","seachicken","2019-09-21T13:57:07Z","2019-10-11T19:13:08Z"
"","1998","Remove misleading comment","I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","rweisleder","2019-09-02T09:14:25Z","2019-09-02T19:36:34Z"
"","2831","Allow for BeforeAllCallback and AfterAllCallback extensions methods to be executed only on root class","I have the following extension: ```java  import org.junit.jupiter.api.extension.AfterAllCallback; import org.junit.jupiter.api.extension.AfterEachCallback; import org.junit.jupiter.api.extension.BeforeAllCallback; import org.junit.jupiter.api.extension.BeforeEachCallback; import org.junit.jupiter.api.extension.ExtensionContext;  public class TestExt implements BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback {    @Override   public void afterAll(ExtensionContext context) throws Exception {     System.out.println(""================== EXT AFTER ALL"");   }    @Override   public void afterEach(ExtensionContext context) throws Exception {     System.out.println(""================== EXT AFTER"");   }    @Override   public void beforeAll(ExtensionContext context) throws Exception {     System.out.println(""================== EXT BEFORE ALL"");   }    @Override   public void beforeEach(ExtensionContext context) throws Exception {     System.out.println(""================== EXT BEFORE"");   } }  ``` Which is used in the following test. ```java  import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestInstance; import org.junit.jupiter.api.TestInstance.Lifecycle; import org.junit.jupiter.api.extension.ExtendWith;  @ExtendWith(TestExt.class) @TestInstance(Lifecycle.PER_CLASS) public class ProvaIT {    @BeforeAll   public static void beforeAll() {     System.out.println(""================== BEFORE ALL"");   }    @BeforeEach   public void before() {     System.out.println(""================== BEFORE"");   }    @AfterAll   public static void afterAll() {     System.out.println(""================== AFTER ALL"");   }    @AfterEach   public void after() {     System.out.println(""================== AFTER"");   }    @Nested   @DisplayName(""Nested test 1"")   public class Nested1Test {      @Test     @DisplayName(""Test 1"")     public void test1() {       System.out.println(""================== TEST 1"");     }      @Test     @DisplayName(""Test 2"")     public void test2() {       System.out.println(""================== TEST 2"");     }    }    @Nested   @DisplayName(""Nested test 2"")   public class Nested2Test {      @Test     @DisplayName(""Test 3"")     public void test3() {       System.out.println(""================== TEST 3"");     }      @Test     @DisplayName(""Test 4"")     public void test4() {       System.out.println(""================== TEST 4"");     }    }  } ``` The standard output result is: ``` ================== EXT BEFORE ALL ================== BEFORE ALL ================== EXT BEFORE ALL ================== EXT BEFORE ================== BEFORE ================== TEST 3 ================== AFTER ================== EXT AFTER ================== EXT BEFORE ================== BEFORE ================== TEST 4 ================== AFTER ================== EXT AFTER ================== EXT AFTER ALL ================== EXT BEFORE ALL ================== EXT BEFORE ================== BEFORE ================== TEST 1 ================== AFTER ================== EXT AFTER ================== EXT BEFORE ================== BEFORE ================== TEST 2 ================== AFTER ================== EXT AFTER ================== EXT AFTER ALL ================== AFTER ALL ================== EXT AFTER ALL ```  As far as I could understand from googling, reading docs and from stackoverflow, there's no actual way to tell jUnit to execute the extension's `beforeAll` and `afterAll` methods only on the root class instead of executing them for each nested class. This could be a nice-to-have feature which imho would improve extensions flexibility. My problem arose when I tried using nested classes with an extension which initialized a `MockServer` instance on its `beforeAll` method: tests were failing due to the fact that the `beforeAll` method was called once for the root class and once for every nested class, which lead to a `RuntimeException` because the port was already binded by the previous MockServer instance.  Some solutions that I came up with include:  - checking that the enclosing test class is null and, if it is, only then initialize the `MockServer` instance - checking that the `MockServer` wasn't already initialized and, if it is, don't initialize it again  but these feel like hacks to me.","closed","component: Jupiter,","apontini","2022-02-16T09:13:15Z","2022-03-01T10:03:35Z"
"","2791","Support JDK concrete types for `List`, `Set` and `Map` in `@EmptySource` / `EmptyArgumentsProvider`","I have tests targeting a legacy library, which unfortunately exposes parameters with concrete types of collections (e.g., `ArrayList`, `HashSet`, etc.) instead of the corresponding interfaces.  Currently, the `EmptyArgumentsProvider` implementation targets only interfaces:  https://github.com/junit-team/junit5/blob/4cd1fc064c6864d01ccacf08c4117c7c39d05e0a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptyArgumentsProvider.java#L47-L55  so a test like the following doesn't work:  ```java @ParameterizedTest @EmptySource void test(ArrayList list) {    ...    legacyService.call(list);    ... } ```  The workaround is a `@MethodSource` taking care of the instantiation of the concrete type.  Would you accept enhancing the implementation of `EmptyArgumentsProvider` to also support the concrete types of the JDK? If yes, happy to raise a PR about it.  ## Deliverables  - [ ] `@EmptySource` provides an empty instance of the JDK concrete types for `List`, `Set` and `Map`","open","status: new,","scordio","2021-12-09T13:00:38Z","2022-03-11T16:53:01Z"
"","2669","Improve documentation on Parallel Test Execution","I have some comments regarding configuring tests for parallel execution following reading: https://junit.org/junit5/docs/snapshot/user-guide/index.html#writing-tests-parallel-execution  Identifying all the relevant properties and the defaults for the properties in `junit-platform.properties` needs to be more obvious. They can be deduced from the narrative but perhaps should just be stated explicitly.  Also, a gentle approach for enabling parallelism should be suggested along with suggested mitigations when things don't work, as a sequence of steps that projects can evolve upon while still getting some parallelization benefit. An example for the `Execution` annotation would be useful as well. Non-parallel test execution could be considered a form of technical debt and a suggested approach for whittling away at that debt to make incremental progress towards as-parallel-as-practical execution. ie. help people figure out where they are now and what their next step should be along with necessary validation checks for each step.","open","component: Jupiter,","bondolo","2021-07-21T21:19:45Z","2022-06-16T17:13:48Z"
"","2584","Add concrete steps to ""Migrating from JUnit 4"" docs section.","I have some code that uses jUnit 4.  I want to update it to use jUnit 5.  The first thing I did was try to find out which dependency to add: 1. Go to https://junit.org/junit5/ 1. Click ""User Guide"" 1. Read through the overview. 1. Reach section [1.4.1. Downloading JUnit Artifacts](http://junit.org/junit5/docs/current/user-guide/#overview-getting-started-junit-artifacts) 1. Click [Dependency Metadata](http://junit.org/junit5/docs/current/user-guide/#dependency-metadata) 1. Stare in confusion at the 19 different JAR files available. 1. Go back and continue through the document.  The first example uses an `org.junit.jupiter` import.  I guess jUnit is now called Jupiter.  Why would they change the name? 1. Skip down to [""3. Migrating from JUnit 4""](http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4).  I'm hoping to find concrete info.  Instead, I find:    - Annotations are in `org.junit.jupiter.api`.  What about the other bits of jUnit?  Matchers?  Do I still need to use hamcrest which hasn't been updated in 2 years?    -  The [""3.3 Limited JUnit 4 Rule Support""](https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rule-support) section says that jUnit 5 doesn't support jUnit 4 rules, then it says that it does.  This is so confusing.    - Finally, the [""3.4. JUnit 4 @Ignore Support""](http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-ignore-annotation-support) tells me something actionable: depend on `junit-jupiter-migrationsupport` and annotate the class with `@EnableJUnit4MigrationSupport`.  And there's an example!  I wish they were all written this way.  ## Deliverables  - Update [3. Migrating from JUnit 4](http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4) to have concrete imperative steps:   - Depend on these JARs: ... (include JAR with matchers)   - Change these things in your tests to get them to run under jUnit 5: ...   - Change these things so you can start using the new features: ...   - You can use the new API to replace crufty code like ... with shiny code like ... .   - Link to javadocs for various packages.   - Full working example showing off various features. - Update the [Dependency Metadata](http://junit.org/junit5/docs/current/user-guide/#dependency-metadata) section to state which dependencies most people need.  Say ""Most people only need dependency X and Y"" or ""If you're unsure then just depend on X."" - Make the prose more concise.  Use active voice.    - Example:       - Change this sentence: ""The following are topics that you should be aware of when migrating existing JUnit 4 tests to JUnit Jupiter.""       - Into this: ""When migrating jUnit 4 tests to jUnit Jupiter, be aware of:""    - Example:       - Change this: ""While the JUnit team encourages reusable extensions to be packaged and maintained in separate libraries, the JUnit Jupiter API artifact includes a few user-facing extension implementations that are considered so generally useful that users shouldn’t have to add another dependency.""       - Into this: ""`junit-jupiter-api` artifact includes these extensions.  Other extensions are in ``.""","open","theme: documentation,","mleonhard","2021-04-05T05:25:07Z","2021-10-31T12:00:26Z"
"","2677","Add ExclusiveResource programmatically","I have several test classes, each with multiple test methods inside. Some of those classes are injected with a parameter, and when running classes in parallel those classes should not run parallel. If I understand correctly, the `@ResourceLock` annotation can help here, but it would be very inconvenient to manually add that annotation to hundereds of tests. Ideally a extension could take a look at the class, see that it has this parameter and somehow add the ExclusiveResource to it.  My JUnit execution parameters:  ``` -Djunit.jupiter.execution.parallel.enabled=true -Djunit.jupiter.execution.parallel.mode.default=same_thread -Djunit.jupiter.execution.parallel.mode.classes.default=concurrent -Djunit.jupiter.execution.parallel.config.strategy=fixed -Djunit.jupiter.execution.parallel.config.fixed.parallelism=8 ```","open","component: Jupiter,","U1F984","2021-07-29T14:06:37Z","2021-12-18T14:38:28Z"
"","2252","Where are your own test suites?","I have searched on google and in this repository, by to no avail.  Where can I find the tests to for example junit-api and so on?  TIA and thanks for the tremendous work you are doing. Be well!","closed","type: question,","silkentrance","2020-04-07T19:27:17Z","2020-04-07T19:39:19Z"
"","2257","DisabledOnOs annotation does not disable on the OS environment","I have disabled a particular test which will fail on Windows with the annotation `@DisabledOnOs(OS.WINDOWS)`  However, that particular test case runs in Windows and it fails (as the test case written for other OS except for Windows).   Looking forward to your early response on this.  I tried JUnit 5.6.2  Please find the below code that I ran:  ### build.gradle  ```groovy dependencies {     testCompile 'org.testng:testng'     testImplementation('org.junit.jupiter:junit-jupiter:5.6.2') } ```  ### Test.java  ```java     @Test(description = ""some description"")     @DisabledOnOs(WINDOWS)     public void testDisabledOnWindows() throws IOException {         // my code      } ```","closed","component: Jupiter,","parkavi11","2020-04-14T09:06:06Z","2020-04-14T12:01:03Z"
"","2361","Using JUnit 5 parallelism support and Maven Surefire retry mechanism produces test log files containing tests that should not belong inside","I have configured my tests to run in parallel with the following config: ``` junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = same_thread junit.jupiter.execution.parallel.mode.classes.default = concurrent junit.jupiter.execution.parallel.config.strategy = fixed junit.jupiter.execution.parallel.config.fixed.parallelism = 6 ``` My junit-jupiter-version is 5.6.2 and junit-platform-version is 1.6.2  I'm running these tests with the maven surefire plugin (3.0.0-M4) and specifying the flag `surefire.rerunFailingTestsCount` to rerun failed tests.  I've run into a test results bug when I get a test failure, and the test gets rerun and passes on the retry.  When I look into the `TEST*.xml` files for each test class, I see some tests that belong to another test class, but show up in another test class's xml file. In the scenario above, I would see the result of `TestClassA#testA` in 2 different `TEST*.xml` files. In one test xml file, it would show up as failure, and in another it would show up as success (the rerun).  This messes up the reporting that happens when you look at the test reports in Jenkins when these XML files are archived by the junit plugin. It double counts the test in this case, and marks the build as unstable.  Is this a byproduct of running things in parallel and retrying test cases in surefire?","closed","3rd-party: Maven Surefire,","aaronq","2020-07-24T05:09:12Z","2020-07-25T11:20:10Z"
"","2993","Unable to run parameterized test when method source is available from two interfaces","I have a working test in Junit 5.8.2 that sees a method source on an interface, but that same method source can be seen from two interfaces that my test implements, because one interface implements the other interface.  After updating to 5.9.0 I now have an exception that ""Several factory methods named [xxxx] were found in class [yyyy]""  ## Steps to reproduce ```java import org.junit.jupiter.api.Assertions; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  import java.util.stream.Stream;  public class Junit5BugTest implements A, B {      @ParameterizedTest     @MethodSource(""methodSource"")     void test(String param) {         Assertions.assertTrue(true);     } }  interface A {     static Stream methodSource() {         return Stream.of(Arguments.arguments(""abc""), Arguments.arguments(""def""));     } }  interface B extends A {  } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Junit Jupiter 5.9.0  - Build Tool/IDE: IntelliJ IDEA 2022.2 (Ultimate Edition)  - Java: OpenJDK Runtime Environment Temurin-17.0.3+7 (build 17.0.3+7)   ## Deliverables  - [stacktrace.txt](https://github.com/junit-team/junit5/files/9251475/stacktrace.txt)","open","theme: parameterized tests,","jamieredding","2022-08-03T12:58:33Z","2022-08-03T15:43:07Z"
"","2883","TempDir deletion throws StackOverflowError","I have a unit test that creates some files in a temporary directory. Notably it's a Docker container that is creating the files. The test passes locally on my machine (running on a Mac) but fails in GitHub actions: https://github.com/andrewparmet/buf-gradle-plugin/runs/5959677186?check_suite_focus=true with a StackOverflowError as it's trying to clean up:  ``` java.lang.StackOverflowError 	at java.base/sun.nio.fs.UnixNativeDispatcher.unlink0(Native Method) 	at java.base/sun.nio.fs.UnixNativeDispatcher.unlink(UnixNativeDispatcher.java:156) 	at java.base/sun.nio.fs.UnixFileSystemProvider.implDelete(UnixFileSystemProvider.java:236) 	at java.base/sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:105) 	at java.base/java.nio.file.Files.delete(Files.java:1142) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.resetPermissionsAndTryToDeleteAgain(TempDirectory.java:250) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:238) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.visitFile(TempDirectory.java:218) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.visitFile(TempDirectory.java:199) 	at java.base/java.nio.file.Files.walkFileTree(Files.java:2725) 	at java.base/java.nio.file.Files.walkFileTree(Files.java:2797) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.resetPermissionsAndTryToDeleteAgain(TempDirectory.java:247) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:238) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.postVisitDirectory(TempDirectory.java:223) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.postVisitDirectory(TempDirectory.java:199) 	at java.base/java.nio.file.Files.walkFileTree(Files.java:2743) 	at java.base/java.nio.file.Files.walkFileTree(Files.java:2797)  // etc. ```  I'm also wondering what kind of IOException is triggering the recursive code, as it's [completely swallowed](https://github.com/junit-team/junit5/blob/main/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java#L291).  What's also interesting is that I have other tests in this project that have files generated by a Docker container and none of them fail.  ## Steps to reproduce  This is pretty esoteric and I don't have a smaller example, but running the CI on the PR always reproduces the error.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.2  - Build Tool/IDE: Gradle 7.4.1  ## Deliverables  - [ ] The PR should succeed!  Thanks!","closed","component: Jupiter,","andrewparmet","2022-04-10T07:09:41Z","2022-04-10T20:52:52Z"
"","1991","Execute `@BeforeAll`/`@AfterAll` once for each path in `@Nested` hierarchy","I have a series of tests which are rather expensive to set up and build on each other. ATM, I use nested tests like so:  ```java @DisplayName(""An empty repository"") class RepositoryTest {    @BeforeEach   void setUpEmptyRepository() { /* expensive I/O */ }    @DisplayName(""has no revisions"")   void testGetRevisions() { ... }    @DisplayName(""has no files in head revision"")   void testGetFiles() { ... }    @Nested   @DisplayName(""after adding a file"")   class WhenFileAdded {      @BeforeEach     void addFile() { /* expensive I/O */ }      @DisplayName(""has a single revisions"")     void testGetRevisions() { ... }      @DisplayName(""has the file in its head revision"")     void testGetFiles() { ... }        @Nested       @DisplayName(""after removing the file again"")       class WhenFileRemovedAgain { /* expensive @BeforeEach */ ... }        @Nested       @DisplayName(""after adding another file"")       class WhenAnotherFileAdded { /* expensive @BeforeEach */ ... }   } } ```  This works, but does expensive set-up operations along each path in the `@Nested` hierarchy over and over again, once for each test method:  - `RepositoryTest`     - `testGetRevisons`     - `testGetFiles`     - `WhenFileAdded`         - `testGetRevisons`         - `testGetFiles`         - `WhenFileRemovedAgain`             - `testGetRevisons`             - `testGetFiles`         - `WhenAnotherFileAdded`             - `testGetRevisons`             - `testGetFiles`  Executing `WhenAnotherFileAdded.testGetRevisons` performs the `@BeforeEach` set up for `RepositoryTest`, `WhenFileAdded`, and `WhenAnotherFileAdded`. And  `WhenAnotherFileAdded.testGetFiles` does so **again** – even though the test methods are ""read only"" (only the set up does heavy I/O).  Unfortunately, switching to `@BeforeAll` for the set-up methods does not work, as in that case the set-up methods are just executed once, not once for each path in the `@Nested` hierarchy.  For example, when executing `WhenAnotherFileAdded.testGetRevisons` it might be that the set-up methods executed are, in this order:  1. `RepositoryTest.setUpEmptyRepository` 2. `WhenFileAdded.setUp` 3. `WhenFileRemoveAgain.setUp` 4. `WhenAnotherFileAdded.setUp`  This is obviously wrong: `WhenFileRemovedAgain.setUp` was meant for a different _branch_ of the `@Nested` hierarchy. Thus the assumption that, say, `WhenAnotherFileAdded.testGetFiles` makes no longer hold, as some file was removed.  It would hence be nice if the behavior of `@BeforeAll`/`@AfterAll` were changed (or at least tweakable) for `@Nested` tests.  I am aware that some amount of set-up work needs to be duplicated, e.g., as both the tests in `RepositoryTest.WhenFileAdded.WhenFileRemovedAgain` and `RepositoryTest.WhenFileAdded.WhenAnotherFileAdded` have some overlap in their nesting context, but it would be nice to at least avoid the set-up for all tests that share the same nesting context (for lack of a better term).  ## Deliverables  - [ ] Either switch the behavior of `@BeforeAll` and `@AfterAll` to be executed once for each nesting context (rather than once for each class, regardless of nesting context) - [ ] Or introduce a new `TestInstance.Lifecycle` constant to switch to such a behavior.","open","component: Jupiter,","sewe","2019-08-27T09:40:44Z","2022-06-22T12:00:54Z"
"","1992","Test method not be executed","I have a question, the test method name does not starts with `test` can not be executed. IDEA run the testcase OK. but the test case was skipped when I use `mvn test -B` to run the testcase .  junit4 does not have this problem.  ## Steps to reproduce ``` public class DemoTest {     @Test     public void helloWorldTest() {         System.out.println(""hello"");     } }  ``` ## Context ```       4.0.0               org.sonatype.oss         oss-parent         9           com.bestvike     linq-perf     1.0.0     jar      linq-perf     Benchmark for LINQ to Objects (Java)     https://github.com/timandy/linq-perf                            Apache License, Version 2.0             https://www.apache.org/licenses/LICENSE-2.0.txt             repo                             https://github.com/timandy/linq         scm:git:https://github.com/timandy/linq-perf.git         scm:git:https://github.com/timandy/linq-perf.git                                 TimAndy             xuchonglei@126.com             https://github.com/timandy                                          org.openjdk.jmh             jmh-core             1.21                               org.openjdk.jmh             jmh-generator-annprocess             1.21                                com.bestvike             linq             2.0.1                               org.junit.jupiter             junit-jupiter             5.5.1             test                                                           org.apache.maven.plugins                 maven-compiler-plugin                 3.8.0                                      1.8                     1.8                                                            org.apache.maven.plugins                 maven-shade-plugin                 3.2.1                                                               package                                                      shade                                                                               linq-perf                                                                                                   org.openjdk.jmh.Main                                                                                                                                                                                                      *:*                                                                              META-INF/*.SF                                         META-INF/*.DSA                                         META-INF/*.RSA                                                                                                                                                                                                ```","closed","3rd-party: Maven Surefire,","timandy","2019-08-28T07:26:39Z","2019-08-29T00:48:47Z"
"","2509","Introduce assertThrowsExactly() in Jupiter assertions","I have a method which I am testing as below:  ```java     @Test     void testHttpErrorCodeException() {         assertThrows(HttpResponseException.class, () -> reThrowSpecificException(500));         assertThrows(RuntimeException.class, () -> reThrowSpecificException(404));      }      public void reThrowSpecificException(int httpsStatusCode) {         if (httpsStatusCode == 500) {             throw new HttpResponseException();         } else {             throw new RuntimeException();         }     } ```  Now if someone modifies the code as below, I feel the second assertion should fail.  ```java     private void reThrowSpecificException(int httpsStatusCode) {         throw new HttpResponseException();     } ``` But the second assertion is not failing as the JUnit checks it using `instanceof`. Seems we can add an `assertThrowsExactly(Class expectedType, Executable executable)` to assert on the particular type of exception.","closed","component: Jupiter,","govi20","2020-12-28T03:55:04Z","2021-06-20T19:27:08Z"
"","2459","Junit 5 - BeforeEach, BeforeAll, AfterAll, AfterEach are completly ignored","I have a maven project that I have loaded in Eclipse. I have setup a test class with a test method that gets executed when I right click the project and say Run as Junit test. So the tests work.  I now want to add a ```@BeforeAll ``` to my tests so that I can initailize stuff. I create a new class in the src/test/java directory and that class is called TestSuiteTest. I add the follwoing lines:  ``` @BeforeAll 	static void setup() { 		System.out.println(""@BeforeAll executed""); 	}  	@BeforeEach 	void setupThis() { 		System.out.println(""@BeforeEach executed""); 	}          // Without this test beforeall and such aren't even found         @Test 	public void test_intest() { 		System.out.println(""In Test executed""); 	}  	@AfterEach 	void tearThis() { 		System.out.println(""@AfterEach executed""); 	}  	@AfterAll 	static void tear() { 		System.out.println(""@AfterAll executed""); 	} ``` Without the test_intest method the other methods are never called! It only works if I have 1 method in the class that has a ``` @Test ``` annotation and even then the behaviour is really really wierd.   I see this is in the output:  ``` testing test_myFirstTest // This is my test in another class which is executed before the BeforeAll. How is that possible??? @BeforeAll executed @BeforeEach executed In Test executed @AfterEach executed @AfterAll executed ```  This is in my maven dependencies:  ```                 			org.junit.jupiter 			junit-jupiter-api 			5.5.2 			test 		  		 			org.junit.jupiter 			junit-jupiter-engine 			5.5.2 			test 		  		 			org.junit.platform 			junit-platform-runner 			1.5.2 			test 		 ```  Even the order of the tests is complety wrong. How is this possible?","closed","","martijnhiemstra","2020-10-23T10:28:49Z","2020-10-23T10:41:46Z"
"","2326","java.lang.UnsupportedOperationException: Reflective setAccessible(true) disabled","I have a Java Vertx3 RESTful API application which runs perfectly fine on Windows 10. However, when I run `mvn test` with JUnit5, it crashes with the following full stack trace: ``` java.lang.UnsupportedOperationException: Reflective setAccessible(true) disabled         at io.netty.util.internal.ReflectionUtil.trySetAccessible(ReflectionUtil.java:31)         at io.netty.util.internal.PlatformDependent0$4.run(PlatformDependent0.java:233)         at java.base/java.security.AccessController.doPrivileged(AccessController.java:312)         at io.netty.util.internal.PlatformDependent0.(PlatformDependent0.java:227)         at io.netty.util.internal.PlatformDependent.isAndroid(PlatformDependent.java:289)         at io.netty.util.internal.PlatformDependent.(PlatformDependent.java:92)         at io.netty.channel.nio.NioEventLoop.newTaskQueue0(NioEventLoop.java:279)         at io.netty.channel.nio.NioEventLoop.newTaskQueue(NioEventLoop.java:150)         at io.netty.channel.nio.NioEventLoop.(NioEventLoop.java:138)         at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:146)         at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:37)         at io.netty.util.concurrent.MultithreadEventExecutorGroup.(MultithreadEventExecutorGroup.java:84)         at io.netty.util.concurrent.MultithreadEventExecutorGroup.(MultithreadEventExecutorGroup.java:58)         at io.netty.util.concurrent.MultithreadEventExecutorGroup.(MultithreadEventExecutorGroup.java:47)         at io.netty.channel.MultithreadEventLoopGroup.(MultithreadEventLoopGroup.java:59)         at io.netty.channel.nio.NioEventLoopGroup.(NioEventLoopGroup.java:86)         at io.netty.channel.nio.NioEventLoopGroup.(NioEventLoopGroup.java:81)         at io.netty.channel.nio.NioEventLoopGroup.(NioEventLoopGroup.java:68)         at io.vertx.core.net.impl.transport.Transport.eventLoopGroup(Transport.java:153)         at io.vertx.core.impl.VertxImpl.(VertxImpl.java:143)         at io.vertx.core.impl.VertxImpl.vertx(VertxImpl.java:92)         at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:40)         at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:32)         at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:27)         at io.vertx.core.Vertx.vertx(Vertx.java:75)         at io.vertx.junit5.VertxParameterProvider.newInstance(VertxParameterProvider.java:45)         at io.vertx.junit5.VertxParameterProvider.newInstance(VertxParameterProvider.java:31)         at io.vertx.junit5.VertxExtension.lambda$resolveParameter$0(VertxExtension.java:108)         at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$0(ExtensionValuesStore.java:81)         at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:182)         at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:84)         at org.junit.jupiter.engine.execution.NamespaceAwareStore.getOrComputeIfAbsent(NamespaceAwareStore.java:53)         at io.vertx.junit5.VertxExtension.resolveParameter(VertxExtension.java:107)         at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:216)         at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:183)         at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:144)         at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:96)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeBeforeAllMethods$8(ClassBasedTestDescriptor.java:375)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeBeforeAllMethods(ClassBasedTestDescriptor.java:373)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:193)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:78)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:132)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)         at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)         at java.base/java.util.ArrayList.forEach(ArrayList.java:1510)         at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)         at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)         at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)         at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)         at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)         at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)         at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)         at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:154)         at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:127)         at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:377)         at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:138)         at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:465)         at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:451) 08:24:23.325 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Bits.unaligned: available, true 08:24:23.327 [main] DEBUG io.netty.util.internal.PlatformDependent0 - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable java.lang.IllegalAccessException: class io.netty.util.internal.PlatformDependent0$6 cannot access class jdk.internal.misc.Unsafe (in module java.base) because module java.base does not export jdk.internal.misc to unnamed module @76c3e77a         at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:376)         at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:647)         at java.base/java.lang.reflect.Method.invoke(Method.java:556)         at io.netty.util.internal.PlatformDependent0$6.run(PlatformDependent0.java:347)         at java.base/java.security.AccessController.doPrivileged(AccessController.java:312)         at io.netty.util.internal.PlatformDependent0.(PlatformDependent0.java:338)         at io.netty.util.internal.PlatformDependent.isAndroid(PlatformDependent.java:289)         at io.netty.util.internal.PlatformDependent.(PlatformDependent.java:92)         at io.netty.channel.nio.NioEventLoop.newTaskQueue0(NioEventLoop.java:279)         at io.netty.channel.nio.NioEventLoop.newTaskQueue(NioEventLoop.java:150)         at io.netty.channel.nio.NioEventLoop.(NioEventLoop.java:138)         at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:146)         at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:37)         at io.netty.util.concurrent.MultithreadEventExecutorGroup.(MultithreadEventExecutorGroup.java:84)         at io.netty.util.concurrent.MultithreadEventExecutorGroup.(MultithreadEventExecutorGroup.java:58)         at io.netty.util.concurrent.MultithreadEventExecutorGroup.(MultithreadEventExecutorGroup.java:47)         at io.netty.channel.MultithreadEventLoopGroup.(MultithreadEventLoopGroup.java:59)         at io.netty.channel.nio.NioEventLoopGroup.(NioEventLoopGroup.java:86)         at io.netty.channel.nio.NioEventLoopGroup.(NioEventLoopGroup.java:81)         at io.netty.channel.nio.NioEventLoopGroup.(NioEventLoopGroup.java:68)         at io.vertx.core.net.impl.transport.Transport.eventLoopGroup(Transport.java:153)         at io.vertx.core.impl.VertxImpl.(VertxImpl.java:143)         at io.vertx.core.impl.VertxImpl.vertx(VertxImpl.java:92)         at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:40)         at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:32)         at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:27)         at io.vertx.core.Vertx.vertx(Vertx.java:75)         at io.vertx.junit5.VertxParameterProvider.newInstance(VertxParameterProvider.java:45)         at io.vertx.junit5.VertxParameterProvider.newInstance(VertxParameterProvider.java:31)         at io.vertx.junit5.VertxExtension.lambda$resolveParameter$0(VertxExtension.java:108)         at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$0(ExtensionValuesStore.java:81)         at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:182)         at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:84)         at org.junit.jupiter.engine.execution.NamespaceAwareStore.getOrComputeIfAbsent(NamespaceAwareStore.java:53)         at io.vertx.junit5.VertxExtension.resolveParameter(VertxExtension.java:107)         at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:216)         at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:183)         at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:144)         at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:96)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeBeforeAllMethods$8(ClassBasedTestDescriptor.java:375)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeBeforeAllMethods(ClassBasedTestDescriptor.java:373)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:193)         at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:78)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:132)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)         at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)         at java.base/java.util.ArrayList.forEach(ArrayList.java:1510)         at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)         at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)         at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)         at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)         at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)         at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)         at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)         at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)         at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)         at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:154)         at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:127)         at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:377)         at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:138)         at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:465)         at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:451) ``` ## Context   - Used versions (Jupiter/Vintage/Platform): Windows 10, Java 14.0.1  - Build Tool/IDE: Spring Tool Suite 4.6.2-Release ``` 		 		    io.vertx 		    vertx-junit5 		    4.0.0-milestone5 		    test 				      			 		 	        org.junit.jupiter 	        junit-jupiter 	        5.6.0 	        test 	     	   	 	      org.junit.platform 	      junit-platform-launcher 	      1.6.0 	      test 	     ```","closed","status: invalid,","khteh","2020-06-16T00:33:14Z","2021-02-17T13:39:00Z"
"","2582","Exception in close of ExtensionContext.Store.CloseableResource swallows exception from test","I have a custom written extension with a CloseableResource in the ExtensionContext. When the resource throws an exception while attempting to close it, exceptions thrown in the test are swallowed. In my specific case there is too little information in the exception thrown in the close-method because it could be a follow-up problem from the exception thrown in the test. Therefore i need to see both exceptions in the test-result.  ## Steps to reproduce  ```java @ExtendWith(MyExtension.class) class TestExceptionInExtension {      @Test     void test() {         throw new RuntimeException(""Exception in Test."");     } }  class MyExtension implements BeforeEachCallback {      private static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace.create(MyExtension.class);      @Override     public void beforeEach(ExtensionContext context) {         context.getStore(NAMESPACE).put(""myResource"", (ExtensionContext.Store.CloseableResource) () -> {             throw new RuntimeException(""Exception in Extension."");         });     } } ```  ## Context   - Used versions (Jupiter): 5.8.0-M1  - Build Tool/IDE: IntelliJ IDEA 2020.3.2","closed","component: Jupiter,","markus-popp","2021-04-02T10:40:16Z","2021-08-17T09:34:09Z"
"","2966","Fix display name and improve assertions for `@TempDir` test case","I guess this:  https://github.com/junit-team/junit5/blob/7416e56237d3eefc890d3b36164a1b4a22fd5941/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java#L412-L419  was originally inspired by:  https://github.com/junit-team/junit5/blob/7416e56237d3eefc890d3b36164a1b4a22fd5941/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java#L786-L797  but the former is not really verifying what the display name says.  This is my attempt to fix it.","open","component: Jupiter,","scordio","2022-07-05T22:24:48Z","2022-07-23T09:20:14Z"
"","2306","TestSkippedException is treated as failure","I found the `org.opentest4j.TestSkippedException` as neighbor of the `org.opentest4j.TestAbortedException` with common parent `org.opentest4j.IncompleteExecutionException`.  I thought in some situations in the Spock engine it might be more appropriate to throw `TestSkippedException` than `TestAbortedException`, for example when evaluating the `@IgnoreIf` closure which is done right before the test itself is done. A similar use-case would be to check assumption at the start of the test before the real test, which currently typically is done using `AssumptionViolationException` or `TestAbortedException`. But also there if the assumptions are checked in the beginning, it might semantically be more appropriate to throw a `TestSkippedException` instead.  From its JavaDoc I would have interpreted that `TestSkippedException` is meant for exactly situations I depcited above. But if I use the `TestSkippedException`, JUnit treats it like any other exception that is not `TestAbortedException` and treats it as failure instead.  I would have expected the test to be recorded as `skipped` or at least as `aborted`, but not as `failed`. Maybe it should even be `TestSkippedException` => skipped `IncompleteExecutionException` => aborted  ## Context   - Used versions: 5.7.0-M1 / 1.7.0-M1  - Build Tool/IDE: Gradle","closed","","Vampire","2020-05-26T10:24:39Z","2020-09-14T10:38:13Z"
"","2437","Cannot find junit-platform-commons pom in maven repository","I found a bunch of Bazel examples (like the following) that ends up referring to a pom file in maven that does not exist. https://github.com/junit-team/junit5-samples/tree/main/junit5-jupiter-starter-bazel  ""... depends on @maven//:org_junit_jupiter_junit_jupiter_api in repository @maven which failed to fetch. no such package '@maven//': Error while fetching artifact with coursier: Resolution error: Error downloading org.junit.jupiter:junit-platform-commons:1.7.0   not found: https://repo1.maven.org/maven2/org/junit/jupiter/junit-platform-commons/1.7.0/junit-platform-commons-1.7.0.pom  The junit-platform-commons path does not exist.","closed","","danbosnichill","2020-10-03T19:46:52Z","2020-10-03T19:49:38Z"
"","2660","LauncherDiscoveryRequest can't find spock unit tests in a jar","I followed this [document](https://junit.org/junit5/docs/current/user-guide/#launcher-api-execution) to discovery and execute spock unit tests, and in IDEA everything is ok, but when I packaged the code to jar, and use `java -cp xx.jar `, the number of found tests is **0**. No error is reported and test class exists in jar.","closed","component: Platform,","chansonzhang","2021-07-06T10:21:02Z","2021-10-31T11:09:23Z"
"","2896","@AfterAll swallows exceptions","I expected to see a failure when running the following code, but the error is not propagated up. My use case: I want to aggregate some data generated from a `@ParameterizedTest` and have an assertion in the `@AfterAll` method (maybe there is a better way to achieve this... open to suggestions).  ```java class Example {     @AfterAll     static void afterAll() {         throw new RuntimeException(""does not fail the test"");     } } ``` For comparison, the following does fail as expected.  ```java     @AfterEach     void tearDown() {         throw new RuntimeException(""fails the test"");     } ```   Using: ```xml                      org.junit.jupiter             junit-jupiter             5.8.2             test          ```","closed","status: new,","armandino","2022-04-23T06:25:31Z","2022-04-24T01:24:07Z"
"","2666","TestExecutionExceptionHandler does not handle/intercept After*Callbacks","I expect a TestExecutionExceptionHandler to handle exceptions originating from an afterEach/All extension. 2 Reasons: 1. The TestExecutionExceptionHandler is invoked for ParameterResolutionExceptions so it would be inconsistent, to not invoke it for exceptions originating from other extension callbacks 2. I am writing an extension myself. It is working fine, but in order to write a test case, testing my extension, I need to verify that my custom extension is actually throwing an exception. I am using the TestExecutionExceptionHandler to verify that behavior. If there is a better alternative to achieve my goal, I'm happily adjusting my path. Nevertheless, I think 1. still applies here.  ## Steps to reproduce Execute the following test and extension collection: ```kotlin @ExtendWith(SwallowAllExceptions::class, ResolveParameters::class, FailAfterFailInAfterTestCase::class) class BugOrFeatureTest {     @Test     fun failInTest() { throw TheExceptionToSwallow(""TestCase"") }      @Test     fun failInParameterResolver(theParameter: String) { fail(""This should not be executed"") }      @Test     fun failInAfterEachCallback() { println(""Happy go lucky test case without happy ending"") } }  class TheExceptionToSwallow(source: String) : Exception(""The exception to swallow from ${source}"")  class SwallowAllExceptions : TestExecutionExceptionHandler {     override fun handleTestExecutionException(ctx: ExtensionContext, t: Throwable) { println(""Yum yum ${t.message}"") } }  class ResolveParameters : ParameterResolver {     override fun supportsParameter(p: ParameterContext, c: ExtensionContext): Boolean { return true }     override fun resolveParameter(pc: ParameterContext?, c: ExtensionContext?): Any { throw TheExceptionToSwallow(""ParameterResolver"") } }  class FailAfterFailInAfterTestCase : AfterEachCallback {     override fun afterEach(context: ExtensionContext) {         if (context.testMethod.map { it.name == ""failInAfterEachCallback"" }.orElse(false)) {             throw TheExceptionToSwallow(""FailAfterFailInAfterEachCallback"")         }     } } ```   ## Expected Behavior I expect all test cases to pass since the SwallowAllExceptions TestExecutionExceptionHandler is written so that it swallows all exceptions.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.7.2  ```                   org.junit                 junit-bom                 5.7.2                 pom                 import               ```  - Build Tool/IDE: Intellij IDEA  ## Deliverables - A pizza, but that one was good and has nothing to do with this bug","open","status: waiting-for-feedback,","staenker","2021-07-19T10:01:16Z","2021-12-03T15:10:36Z"
"","2930","Add a parameter to allow @TestMethodOrder to enforce unique order","I encountered the same problem as #2757 , in some scenarios I hope that the order I fill in is different, but in fact when faced with a large number of tests, sometimes I can't guarantee this, so I hope to get a boolean switch to detect all of this. At the same time I don't want to do it by adding a class as described in the previous issue, because it actually means that if I have other sorting methods in the future that I also want to have this functionality, I have to add an extra for this sorting method A class for the enforce state. So I tried adding a boolean enforceUniqueOrder switch to do it, I guess it's easier to manage and use","open","status: new,","fll02020","2022-05-28T21:13:07Z","2022-05-28T21:13:48Z"
"","2278","#1289 the package-list error in the JavaDocs is still an issue","I downloaded and added to NetBeans 11.0 with Java 8: JUnit 5.6.2 Jupiter JUnit 5.6.2 Vintage JUnit 1.6.2 Platform  ## Steps to reproduce Adding the documentation jars to the library still produces the following error:   **_Invalid Javadoc root {path to doc jar file}  The Javadoc root does not contain the package-list file._**   ## Context  - Used versions (Jupiter/Vintage/Platform): Jupiter 5.6.2 Vintage 5.6.2 Platform 1.6.2   - Build Tool/IDE: Apache NetBeans 11.0     Is there any chance this will be fixed in the next version?","closed","theme: modules,","jmccay-work","2020-04-28T21:53:11Z","2020-07-19T11:00:50Z"
"","2708","`@ParameterizedTest` with `Object[]` test parameter and `Stream` factory method fails","I detected the issue with a [parameterized test](https://github.com/assertj/assertj-core/blob/ccc03aca55236e0efa4eb38054e174d5c9c59db6/src/test/java/org/assertj/core/internal/StandardComparisonStrategy_areEqual_Test.java#L249-L269) that has one `Object` parameter and a `@MethodSource` with a factory method that returns `Stream`.  The factory method provides one `Object[]` and several primitive type arrays. All the primitive type arrays are injected correctly into the method parameter, but for the `Object[]` only its first element is injected as a single instance.  Instead, the test runs correctly if the factory method returns `Stream`, although it's not so nice to read due to the cast needed for the `arguments` vararg.  I'm not sure if this is really a bug or if I'm doing something wrong. Any advice is highly appreciated!  If you think it's a bug, I'm happy to work on fixing it.  ## Steps to reproduce  After some analysis, I realized that the issue also happens and is more obvious with a `Stream` factory method and an `Object[]` test parameter, so I simplified the example.  Having:  ```java @ParameterizedTest @MethodSource(""arrays"") void should_inject_object_array(Object[] actual) { } ```  this factory method works:  ```java static Stream arrays() {   return Stream.of(     arguments((Object) new Object[] { new Object(), new Object() }),     arguments((Object) new Object[] { new Object(), new Object() })   ); } ```  but this one:  ```java static Stream arrays() {   return Stream.of(     new Object[] { new Object(), new Object() },     new Object[] { new Object(), new Object() }   ); } ```  causes:  ``` org.junit.jupiter.api.extension.ParameterResolutionException: Error converting parameter at index 0: No implicit conversion to convert object of type java.lang.Object to type [Ljava.lang.Object;  	at org.junit.jupiter.params.ParameterizedTestMethodContext.parameterResolutionException(ParameterizedTestMethodContext.java:273) 	at org.junit.jupiter.params.ParameterizedTestMethodContext.access$200(ParameterizedTestMethodContext.java:44) 	at org.junit.jupiter.params.ParameterizedTestMethodContext$Converter.resolve(ParameterizedTestMethodContext.java:238) 	at org.junit.jupiter.params.ParameterizedTestMethodContext.resolve(ParameterizedTestMethodContext.java:165) 	at org.junit.jupiter.params.ParameterizedTestParameterResolver.resolveParameter(ParameterizedTestParameterResolver.java:64) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:216) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:183) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:144) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:96) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:212) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:192) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:139) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:107) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$11$1.accept(ReferencePipeline.java:442) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1655) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1655) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:107) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:42) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: org.junit.jupiter.params.converter.ArgumentConversionException: No implicit conversion to convert object of type java.lang.Object to type [Ljava.lang.Object; 	at org.junit.jupiter.params.converter.DefaultArgumentConverter.convertToTargetType(DefaultArgumentConverter.java:127) 	at org.junit.jupiter.params.converter.DefaultArgumentConverter.convert(DefaultArgumentConverter.java:104) 	at org.junit.jupiter.params.converter.SimpleArgumentConverter.convert(SimpleArgumentConverter.java:30) 	at org.junit.jupiter.params.ParameterizedTestMethodContext$Converter.resolve(ParameterizedTestMethodContext.java:235) 	... 110 more ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.7.2 / 5.8.0-RC1  - Build Tool/IDE: Maven / IntelliJ  ## Deliverables  - [ ] `Stream` factory method should work with a `@ParameterizedTest` having an `Object[]` parameter. - [ ] [This test](https://github.com/assertj/assertj-core/blob/ccc03aca55236e0efa4eb38054e174d5c9c59db6/src/test/java/org/assertj/core/internal/StandardComparisonStrategy_areEqual_Test.java#L249-L269) should still pass once the `Object[]` parameter is uncommented.","open","status: new,","scordio","2021-09-05T09:20:14Z","2021-09-07T19:10:16Z"
"","2504","Point failed assertion to external resource instead of Java test","I come across an interesting question which seems to be unanswered both in documentation and source code.  I have a set of dynamic tests which are really about going over XML document and comparing binary input with expected XML output created out of hex stream. Thanks to `testSourceUri` parameter I am able to hint IDE where to look for tests (`?line=&column=`), now I seek for second step - assertion errors.  When any of my test fails I would like to point at least to location where it started to fail. Currently stack traces are closely related to Java and test itself. Reason why I would like to ease is due to fact that suite XML can be pretty long and involve multiple steps. Navigating over it to can be sometimes trouble. It really boils down to ""how to throw"" an error so it gets different location than one in Java stack trace.  Here is example element used to create assertion: https://github.com/apache/plc4x/blob/develop/protocols/ads/src/test/resources/protocols/ads/AdsDiscoverySerializerTest.xml#L77L108   I managed to achieve partial result by manipulating exception stack trace, yet IDE doesn't feel lucky when I point xml file instead of java one. It still opens exception class file instead of stack trace file location (set to XML). I know this is super ugly hack, but couldn't hold myself from checking it.","closed","theme: dynamic tests,","splatch","2020-12-23T10:42:08Z","2021-06-07T08:55:50Z"
"","1994","@Before* in outer and @Nested classes interaction","I can't compose a single thought of what I can't get working, so I've prepared a test case in Kotlin that will describe what I am trying to do and the problems are highlighted with `fixme` comments. There is only one problem here that is repeated 4 times but I think it may be useful for you to look at the whole picture. Please, notice, that all classes here use `TestInstance.Lifecycle.PER_CLASS` strategy. ```kotlin import org.junit.jupiter.api.BeforeAll import org.junit.jupiter.api.MethodOrderer import org.junit.jupiter.api.Nested import org.junit.jupiter.api.Order import org.junit.jupiter.api.Test import org.junit.jupiter.api.TestInstance import org.junit.jupiter.api.TestMethodOrder  class EntityRepo {     fun save(entity: String): String {         println(""saving $entity"")         return entity     } }  class RequestSender {     fun send(request: String) = println(""sending $request"") }  //some annotations and stuff //todo check up on @Nested https://github.com/spring-projects/spring-framework/issues/19930 abstract class AbstractIntegrationTest  @TestInstance(TestInstance.Lifecycle.PER_CLASS) @TestMethodOrder(MethodOrderer.OrderAnnotation::class) abstract class StatefulIT : AbstractIntegrationTest()  abstract class ClearsDbBeforeAllIT : StatefulIT() {     @BeforeAll     fun clearDbBeforeAll() {         println(""clear db"")     } }  class StartEntityIT : StatefulIT() {      val requestSender = RequestSender()     val entityRepo = EntityRepo()      @Nested     inner class `given a STOPPED entity in DB` : ClearsDbBeforeAllIT() {          lateinit var stoppedEntity: String          @BeforeAll         fun setUp() {             stoppedEntity = entityRepo.save(""stopped entity"")         }          @Test         fun `get entity -- returned with STOPPED status`() {             requestSender.send(""GET /api/entities/{id} for $stoppedEntity"")             //assert returned status is STOPPED         }          @Nested         inner class `given STOPPED in Vendor` : ClearsDbBeforeAllIT() {              @BeforeAll             fun setUp1() {                 //fixme stopped entity is not saved                 println(""making vendor api have STOPPED status and accept 'start'"")             }              @Test             fun `start -- success`() {                 requestSender.send(""PUT /api/entities/{id}/start for $stoppedEntity"")             }         }          @Nested         inner class `given DISABLED in Vendor` : ClearsDbBeforeAllIT() {              @BeforeAll             fun setUp() {                 //fixme stopped entity is not saved                 println(""making vendor api have DISABLED status and reject 'start'"")             }              @Order(1)             @Test             fun `start -- reject`() {                 requestSender.send(""PUT /api/entities/{id}/start for $stoppedEntity"")             }              @Order(2)             @Test             fun `entity in DB has synchronized with Vendor to have DISABLED status`() {                 requestSender.send(""GET /api/entities/{id} for $stoppedEntity"")                 //assert returned status is DISABLED             }         }     }      @Nested     inner class `given a STARTED entity in DB` : ClearsDbBeforeAllIT() {          lateinit var startedEntity: String          @BeforeAll         fun setUp() {             startedEntity = entityRepo.save(""started entity"")         }          @Nested         inner class `given STOPPED in Vendor` : ClearsDbBeforeAllIT() {              @BeforeAll             fun setUp() {                 //fixme started entity is not saved                 println(""making vendor api have STOPPED status and accept 'start'"")             }              @Test             fun `start -- success`() {                 requestSender.send(""PUT /api/entities/{id}/start for $startedEntity"")             }         }          @Nested         inner class `given STARTED in Vendor` : ClearsDbBeforeAllIT() {              @BeforeAll             fun setUp() {                 //fixme started entity is not saved                 println(""making vendor api have STARTED status and accept 'start'"")             }              @Test             fun success() {                 requestSender.send(""PUT /api/entities/{id}/start for $startedEntity"")             }         }     } } ```  Jupiter version: 5.5.1  this may or may not be connected with #1991  --- Here is the output:  ``` clear db saving stopped entity  sending GET /api/entities/{id} for stopped entity  clear db making vendor api have STOPPED status and accept 'start'  sending PUT /api/entities/{id}/start for stopped entity  clear db making vendor api have DISABLED status and reject 'start'  sending PUT /api/entities/{id}/start for stopped entity   sending GET /api/entities/{id} for stopped entity  clear db saving started entity clear db making vendor api have STOPPED status and accept 'start'  sending PUT /api/entities/{id}/start for started entity  clear db making vendor api have STARTED status and accept 'start'  sending PUT /api/entities/{id}/start for started entity  ```","closed","component: Jupiter,","Sam-Kruglov","2019-08-30T12:09:15Z","2020-05-22T19:56:07Z"
"","2986","Fix documentation typo","I assume `AssertJ` and not `AspectJ` was originally meant to be listed as one of the testing libraries included by `spring-boot-starter-test` 🙂","closed","theme: documentation,","scordio","2022-07-26T22:31:01Z","2022-07-27T11:40:00Z"
"","2393","Allow extensions to leverage registered ParameterResolvers for method and constructor invocations","I am working on an extension for tests to be able to react to failed tests or tests that end in exception by including a method annotated with `@OnFailure`.    My specific high-level ""requirement"" is to be able to rebuild a Hibernate `SessionFactory` in these cases.  That method needs access to the `SessionFactory` to be rebuilt.  Actually it is a `SessionFactoryScope` class that manages a `SessionFactory` and exposes it via a `ParameterResolver`.  E.g.  ```java @SessionFactory public class MyTest {     @Test     public void theTest(SessionFactoryScope scope) {         // ...     } } ```  If this test fails, I'd like to be able to access the `SessionFactoryScope` to trigger it to release its `SessionFactory` and build a new one.  To do that it needs access to the `SessionFactoryScope`.  I.e.:  ```java     @OnFailure     public void rebuild(SessionFactoryScope scope) {         // ...     } ```  Currently, JUnit Jupiter does not allow access to registered ParameterResolvers nor any way to invoke such ""extension methods"" with resolved parameter arguments.  Seems like a generally useful feature.","closed","type: new feature,","sebersole","2020-08-25T13:57:30Z","2022-02-04T19:05:47Z"
"","2091","JUnit and Surefire are calling JUnit3 static suite() method twice","I am using JUnit 5.5.1 and Surefire 2.22.2.  I noticed that Surefire is calling my JUnit3 static suite() method twice.  This is an issue for me as my suite() method is creating tests dynamically and it is expensive.  I dumped a stacktrace inside Surefire for each and noticed some differences.  From the two calls, we can see the section of the stack trace in the whitespace (inside surefire) is different.  ```java 	at com.clear2pay.jetqarun.junit3.JUnit3Suite.suite(JUnit3Suite.java:17) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.internal.runners.SuiteMethod.testFromSuiteMethod(SuiteMethod.java:35) 	at org.junit.internal.runners.SuiteMethod.(SuiteMethod.java:24) 	at org.junit.internal.builders.SuiteMethodBuilder.runnerForClass(SuiteMethodBuilder.java:11) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) 	at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:26) 	at org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder.runnerForClass(DefensiveAllDefaultPossibilitiesBuilder.java:56) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) 	at org.junit.vintage.engine.discovery.ClassSelectorResolver.resolveTestClass(ClassSelectorResolver.java:66) 	at org.junit.vintage.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:47) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:129) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1359) 	at java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:126) 	at java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:498) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:485) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:464) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:174) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:120) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:87) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:80) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:112) 	at org.junit.vintage.engine.discovery.VintageDiscoverer.discover(VintageDiscoverer.java:42) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:62) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:177) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:164)  	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:120) 	at org.apache.maven.surefire.junitplatform.TestPlanScannerFilter.accept(TestPlanScannerFilter.java:56) 	at org.apache.maven.surefire.util.DefaultScanResult.applyFilter(DefaultScanResult.java:102) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.scanClasspath(JUnitPlatformProvider.java:143) 	 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124) 	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418) ```  ```java 	at com.clear2pay.jetqarun.junit3.JUnit3Suite.suite(JUnit3Suite.java:17) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.internal.runners.SuiteMethod.testFromSuiteMethod(SuiteMethod.java:35) 	at org.junit.internal.runners.SuiteMethod.(SuiteMethod.java:24) 	at org.junit.internal.builders.SuiteMethodBuilder.runnerForClass(SuiteMethodBuilder.java:11) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) 	at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:26) 	at org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder.runnerForClass(DefensiveAllDefaultPossibilitiesBuilder.java:56) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) 	at org.junit.vintage.engine.discovery.ClassSelectorResolver.resolveTestClass(ClassSelectorResolver.java:66) 	at org.junit.vintage.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:47) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:129) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1359) 	at java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:126) 	at java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:498) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:485) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:464) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:174) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:120) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:87) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:80) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:112) 	at org.junit.vintage.engine.discovery.VintageDiscoverer.discover(VintageDiscoverer.java:42) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:62) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:177) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:164)  	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150) 	 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124) 	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418) ```  In JUnitPlatformProvider, we can see  ```java else if ( forkTestSet == null )             {                 invokeAllTests( scanClasspath(), runListener );             } ```  This one line of code is calling suite() twice, once from scanClasspath, and once from invokeAllTests.  Is it possible to tell from the stack trace if this is a JUnit issue or Surefire issue?  To me it sounds like a JUnit issue as ""discover"" should find the suite() method, not call it. But I could easily be wrong...","closed","3rd-party: Maven Surefire,","k1w1m8","2019-11-01T00:30:27Z","2019-11-06T08:59:12Z"
"","2317","No tests run at all with maven!","I am using JUnit 5 to test my Vert.x application with maven. It doesn't discover or run any test at all! JUnit5: ``` 		 		    io.vertx 		    vertx-junit5 		    4.0.0-milestone5 		    test 				      			 		 	        org.junit.jupiter 	        junit-jupiter 	        5.7.0-M1 	        test 	     ``` Maven Sure-fire plugin: ```                  	            org.apache.maven.plugins 	            maven-surefire-plugin 	            3.0.0-M4 	         	                         org.apache.maven.plugins                 maven-failsafe-plugin                 3.0.0-M4              ``` Maven version: ``` C:\>mvn --version Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: C:\Program Files\apache-maven-3.6.3\bin\.. Java version: 14.0.1, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk-14.0.1 Default locale: en_US, platform encoding: Cp1252 OS name: ""windows 10"", version: ""10.0"", arch: ""amd64"", family: ""windows"" ``` `mvn test` output: ```  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running com.restapi.vertx.test.SimpleHttpVerticleTests [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 s - in com.restapi.vertx.test.SimpleHttpVerticleTests [INFO] Running com.restapi.vertx.test.SimpleRESTVerticleTests [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in com.restapi.vertx.test.SimpleRESTVerticleTests [INFO] [INFO] Results: [INFO] [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time:  5.513 s [INFO] Finished at: 2020-06-06T21:34:35+08:00 [INFO] ------------------------------------------------------------------------ ```","closed","status: works-as-designed,","khteh","2020-06-06T13:51:13Z","2020-06-15T15:53:48Z"
"","2813","Support `@Suite` classes in JUnit Platform standalone ConsoleLauncher","I am trying to run Test Suite using JUnit 5.  Individual file runs fine. But the Test Suite is not running when executed from command line.  I am using `junit-platform-console-standalone-1.6.0.jar` to run tests.  My Test class:  ```java package demo;  import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.Test;  public class TestDemoClass1 {      @Test     public void test1() throws Exception {         System.out.println(""Test 1 from DemoClass 1"");     }      @Test     public void test2() throws Exception {         System.out.println(""Test2 from DemoClass 1"");     } ```  My Suite class:  ```java package demo;  import org.junit.platform.suite.api.SelectClasses; import org.junit.platform.suite.api.Suite;  @Suite @SelectClasses({ TestDemoClass1.class }) public class TestSuite {  } ```  The command I am using to run from command lines:   ``` java -jar target/junit-platform-console-standalone-1.6.0.jar -cp .;target/test-classes/ -c demo.TestSuite   ```  Output of this command is:  ``` Thanks for using JUnit! Support its development at https://junit.org/sponsoring  ←[36m.←[0m ←[36m+--←[0m ←[36mJUnit Jupiter←[0m ←[32m[OK]←[0m ←[36m'--←[0m ←[36mJUnit Vintage←[0m ←[32m[OK]←[0m  Test run finished after 72 ms [         2 containers found      ] [         0 containers skipped    ] [         2 containers started    ] [         0 containers aborted    ] [         2 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ] ```  It says no tests found. If same java command is use with the test class it runs fine","closed","component: Platform,","apathan123","2022-01-19T19:04:29Z","2022-04-08T10:10:50Z"
"","2375","Support named sources for DynamicTest.stream(…)","I am trying to create a `Stream` from a set of different sources (read: different types) and the way that generics work makes this quite cumbersome. Here's an example from Spring HATEOAS:  ```java Links links = Links.NONE; Link link = Link.of(""/foo""); 		 List sources = Arrays.asList( 		NamedLinks.of(""via varargs"", links.and(link)), 		NamedLinks.of(""via Iterable"", links.and(Arrays.asList(link))), 		NamedLinks.of(""via Stream"", links.and(Stream.of(link))));  return DynamicTest.stream(sources.iterator(), NamedLinks::getName, 		it -> assertThat(it.links.getRequiredLink(IanaLinkRelations.SELF)).isNotNull()); ```  The test is supposed to verify that *different parameter types* (here: some object, an `Iterable` of objects, and a stream) handed to the `Links.and(…)` method lead to a certain result. Ideally, I would like to treat those as sources but that would just hand in the common supertype to the `ThrowingConsumer`, so that I cannot call `links.and(…)` anymore as those expect the concrete types. To work around this limitation I call the method beforehand and end up with `Links` consistently but am then unable to produce test names in the second parameter as I cannot distinguish the individual `Links` instances anymore.  I created `NamedLinks` myself to be able to already eagerly bind a name to use in the setup of `Dynamic.stream(…)` but I wonder if that could be made available by JUnit OOTB providing a simple value type `NamedSource` that exposes a name and source `T`and an overload of `DynamicTest.stream(Stream> sources, ThrowingCallable callback)`.","closed","theme: dynamic tests,","odrotbohm","2020-08-05T21:34:59Z","2021-02-09T21:00:20Z"
"","2246","org.junit.jupiter.api.AssertThrows.assertThrows(expectedType, executable, messageOrSupplier) should be accessible for extension purposes","I am trying to add additional exception/throwable related assertions. And I do not want to reimplement what was already implemented in (see summary).  I would want you to make the currently private method a package protected and thus accessible method for implementations of additional asserts for exceptions.  ``` 	private static  T assertThrows(Class expectedType, Executable executable, 			Object messageOrSupplier) { ```  should be package protected so that extensions can make use of it.","closed","","silkentrance","2020-04-06T20:19:58Z","2020-04-06T20:34:50Z"
"","2670","Support method reference in `@EnabledIf`/`@DisabledIf`","I am studying how to write tests by looking at the [junit5 User Guide](https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution-custom).  For `@EnabledIf`, can you provide a function to dynamically determine true/false as a return value for a method rather than setting a property?  Below is my code (kotlin):  ```kotlin @TestInstance(TestInstance.Lifecycle.PER_CLASS) class Exercise04 {      private val elements = listOf(""apple"", ""banana"")     private val logger = KotlinLogging.logger {}      @Test     @EnabledIf(""conditionalElementOnList"")     fun doTestConditionalByAppleString() {         logger.info { ""apple test code exec"" }     }      @Test     @EnabledIf(""conditionalElementOnList"")     fun doTestConditionalByBananaString() {         logger.info { ""banana test code exec"" }     }      fun conditionalElementOnList(): Boolean {         val element = elements.shuffled().first()         logger.info { ""shuffled element : [$element]"" }         return element.startsWith(""a"")     } } ```  Additional code (kotlin):  ```kotlin @TestInstance(TestInstance.Lifecycle.PER_CLASS) class Exercise04 {      private val logger = KotlinLogging.logger {}      @Test     @EnabledIf(""conditionalElementOnList"")     fun doTestConditionalByAppleString() {         logger.info { ""apple test code exec"" }     }      @Test     @EnabledIf(""conditionalElementOnList"")     fun doTestConditionalByBananaString() {         logger.info { ""banana test code exec"" }     }      companion object {         private val elements = listOf(""apple"", ""banana"")          @JvmStatic         fun conditionalElementOnList(): Boolean {             val element = elements.shuffled().first()             println ( ""shuffled element : [$element]"" )             return element.startsWith(""a"")         }     } } ```  When I read  issue #1911, it seems that the current function is being provided.  Can you please confirm if I am using it wrong?","closed","component: Jupiter,","pasudo123","2021-07-24T07:44:27Z","2021-07-25T02:16:01Z"
"","2483","[IJ IDE] JUnit Jupiter Assumptions do not work in @BeforeAll methods","I am still seen this issue on intelliJ  org.junit.jupiter junit-jupiter-api 5.7.0 test IntelliJ IDEA 2020.2.4 (Community Edition) Build #IC-202.8194.7, built on November 24, 2020 Runtime version: 11.0.9+11-b944.49 x86_64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o. macOS 10.16 GC: ParNew, ConcurrentMarkSweep Memory: 725M Cores: 8  ![image](https://user-images.githubusercontent.com/49316187/100390917-8b929880-2ff7-11eb-8140-11858f9c5c81.png)","closed","","Diego11914","2020-11-26T20:56:28Z","2020-11-27T11:28:32Z"
"","2115","Console does not associate with tests reliably in parallel mode","I am enjoying the parallelism features provided by JUnit 5. While developing using test driven development, it is useful to run as many tests as possible as frequently as possible.  I have been using IntelliJ to run the entire test package of my project frequently and using the JVM options:  ``` -ea -Djunit.jupiter.execution.parallel.enabled=true -Djunit.jupiter.execution.parallel.mode.default=concurrent ```  The issue is the console output is not readable. It gets jumbled together and spread accross many methods. It is useful to monitor the console output of various tests, especially to see what led up to a failure.  I assume the issue can only be alleviated by printing to a JUnit specific logger or providing forked process parallelism options.  JUnit 5.5.1 and IntelliJ 2019.2  Example test results:  [Test Results - us_ihmc_games_zombieDice_in_games_games-test_main1.html.txt](https://github.com/junit-team/junit5/files/3893261/Test.Results.-.us_ihmc_games_zombieDice_in_games_games-test_main1.html.txt)","closed","3rd-party: IntelliJ IDEA,","calvertdw","2019-11-26T17:48:21Z","2022-03-11T06:35:57Z"
"","2396","Provide information about the current ExecutionMode in ExtensionContext","I am contributing to a bunch of JUnit 5 extensions that rely on a form of field injection to achieve their goals.  Field injection, if done in a `@BeforeEach` callback, works well for both parallel and sequential testing. It also works well for both `PER_CLASS` and `PER_METHOD` lifecycle semantics. However, it does not work very well if you're combining parallel execution with `PER_CLASS` lifecycle semantics, as the parallel execution threads for each test method will each inject their own instances into the single test class instance and clobber each other, interfering with the tests running in other threads. In such situations, it is necessary to inject into a `ThreadLocal` container instead.  Accordingly, I would like my extensions to be able to give fail-fast-and-loud behaviour in these circumstances - throwing an `ExtensionConfigurationException` if it finds it is being asked to run in an environment where it is being asked to run `CONCURRENT` and `PER_CLASS` at the same time, and informing the user that they should use a `ThreadLocal` in such a case.  The problem: the `ExtensionContext` that is passed to the extension's lifecycle methods has a method for telling you which class instance lifecycle mode is in force. However, it doesn't seem to give you a way to easily determine the execution mode. This can be inferred by manually examining the annotations and the global execution mode, but I feel that this breaks encapsulation a little bit - I don't have to do the same for the lifecycle.  ## Deliverables  Method `ExecutionMode getExecutionMode()` in `ExtensionContext`.  Possibly a pair of methods - one that returns the value annotated on the class, and one that returns the *actual* execution mode in force (taking into account any global setting). The latter would be more directly useful to my use case.","closed","component: Jupiter,","kriegfrj","2020-08-31T01:14:59Z","2021-09-15T11:01:40Z"
"","2840","Sort test execution by position in source code 'aka' MethodOrderer.SourceCode.class","I always wanted to get the test executed by JUnit in the order they appear in the source code of the Java class, that way I dont have to fix the order logic with an `@Order(number)` annotation which is boring to manage once the list of test expands itself.  I searched around, and it seems that everyone is suggesting that Reflection can't find this information, but annotation processing can do but it requires to write the gathered datas in the resources of the modules (disk access), and then they are read at runtime.  I found the solution of someone on internet that works with Reflection, he used to test this on JDK7/8 and me I just tested this on Openjdk 11 and it still works few years later.  Do you think work of `Reflect.java` could be borrowed to offer a way of ordering test execution based on the method position in source code ? Don't you think this would be a cool feature to bring to JUnit 5 ? I do !  Reflect.java credits : Warren MacEvoy @wmacevoy  https://stackoverflow.com/a/38929813/16912476 https://github.com/wmacevoy/kiss/blob/master/src/main/java/kiss/util/Reflect.java  Below is a fully functionnal example, annotate your test class with   `@TestMethodOrder(TestMethodOrderer.SourceCode.class)`  And all the tests will be executed in the source code order  ```java public interface TestMethodOrderer extends MethodOrderer {   class SourceCode implements MethodOrderer   {     private final MethodDescriptorOrder sourceCodeComparator = new MethodDescriptorOrder();      @Override     public void orderMethods(MethodOrdererContext context)     {       MethodDescriptorOrder.methodsInSourceCodeOrder = Reflect.getDeclaredMethodsInOrder(context.getTestClass());       context.getMethodDescriptors().sort(sourceCodeComparator);     }      private static class MethodDescriptorOrder implements Comparator     {       static Method[] methodsInSourceCodeOrder;        @Override       public int compare(MethodDescriptor methodDescriptor1, MethodDescriptor methodDescriptor2)       {         Method method1 = methodDescriptor1.getMethod();         Method method2 = methodDescriptor2.getMethod();         int index1 = Arrays.asList(methodsInSourceCodeOrder).indexOf(method1);         int index2 = Arrays.asList(methodsInSourceCodeOrder).indexOf(method2);         int index = 0;         if (index1 > index2)         {           index = 1;         }         else if (index1 < index2)         {           index = -1;         }         return index;       }     }   } } ```  ```java public class Reflect {   /**    * Get the underlying class for a type, or null if the type is a variable type.    *    * @param type the type    * @return the underlying class    */   private static Class getClass(Type type)   {     if (type instanceof Class)     {       return (Class) type;     }     else if (type instanceof ParameterizedType)     {       return getClass(((ParameterizedType) type).getRawType());     }     else if (type instanceof GenericArrayType)     {       Type componentType = ((GenericArrayType) type).getGenericComponentType();       Class componentClass = getClass(componentType);       if (componentClass != null)       {         return Array.newInstance(componentClass, 0).getClass();       }       else       {         return null;       }     }     else     {       return null;     }   }    /**    * Rarified code used to discover event listeners for generic Generator    *     * Almost verbatim from:    *     * http://www.artima.com/weblogs/viewpost.jsp?thread=208860    */   public static  List> getTypeArguments(Class baseClass, Class childClass)   {     Map resolvedTypes = new HashMap<>();     Type type = childClass;     // start walking up the inheritance hierarchy until we hit baseClass     while (!getClass(type).equals(baseClass))     {       if (type instanceof Class)       {         // there is no useful information for us in raw types, so just keep going.         type = ((Class) type).getGenericSuperclass();       }       else       {         ParameterizedType parameterizedType = (ParameterizedType) type;         Class rawType = (Class) parameterizedType.getRawType();          Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();         TypeVariable[] typeParameters = rawType.getTypeParameters();         for (int i = 0; i < actualTypeArguments.length; i++)         {           resolvedTypes.put(typeParameters[i], actualTypeArguments[i]);         }          if (!rawType.equals(baseClass))         {           type = rawType.getGenericSuperclass();         }       }     }      // finally, for each actual type argument provided to baseClass, determine (if possible)     // the raw class for that type argument.     Type[] actualTypeArguments;     if (type instanceof Class)     {       actualTypeArguments = ((Class) type).getTypeParameters();     }     else     {       actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();     }     List> typeArgumentsAsClasses = new ArrayList<>();     // resolve types by chasing down type variables.     for (Type baseType : actualTypeArguments)     {       while (resolvedTypes.containsKey(baseType))       {         baseType = resolvedTypes.get(baseType);       }       typeArgumentsAsClasses.add(getClass(baseType));     }     return typeArgumentsAsClasses;   }    private static class MethodOffset implements Comparable   {     MethodOffset(Method _method, int _offset)     {       method = _method;       offset = _offset;     }      @Override     public int compareTo(MethodOffset target)     {       return offset - target.offset;     }      Method method;     int offset;   }    static class ByLength implements Comparator   {      @Override     public int compare(Method a, Method b)     {       return b.getName().length() - a.getName().length();     }   }    /**    * Grok the bytecode to get the declared order    */   public static Method[] getDeclaredMethodsInOrder(Class clazz)   {     Method[] methods = null;     try     {       String resource = clazz.getName().replace('.', '/') + "".class"";        methods = clazz.getDeclaredMethods();        InputStream is = clazz.getClassLoader().getResourceAsStream(resource);        if (is == null)       {         return methods;       }        java.util.Arrays.sort(methods, new ByLength());       ArrayList blocks = new ArrayList<>();       int length = 0;       for (; ; )       {         byte[] block = new byte[16 * 1024];         int n = is.read(block);         if (n > 0)         {           if (n < block.length)           {             block = java.util.Arrays.copyOf(block, n);           }           length += block.length;           blocks.add(block);         }         else         {           break;         }       }        byte[] data = new byte[length];       int offset = 0;       for (byte[] block : blocks)       {         System.arraycopy(block, 0, data, offset, block.length);         offset += block.length;       }        String sdata = new String(data, StandardCharsets.UTF_8);       int lnt = sdata.indexOf(""LineNumberTable"");       if (lnt != -1)       {         sdata = sdata.substring(lnt + ""LineNumberTable"".length() + 3);       }       int cde = sdata.lastIndexOf(""SourceFile"");       if (cde != -1)       {         sdata = sdata.substring(0, cde);       }        MethodOffset[] mo = new MethodOffset[methods.length];         for (int i = 0; i < methods.length; ++i)       {         int pos = -1;         for (; ; )         {           pos = sdata.indexOf(methods[i].getName(), pos);           if (pos == -1)           {             break;           }           boolean subset = false;           for (int j = 0; j < i; ++j)           {             if (mo[j].offset >= 0 && mo[j].offset <= pos && pos < mo[j].offset + mo[j].method.getName().length())             {               subset = true;               break;             }           }           if (subset)           {             pos += methods[i].getName().length();           }           else           {             break;           }         }         mo[i] = new MethodOffset(methods[i], pos);       }       java.util.Arrays.sort(mo);       for (int i = 0; i < mo.length; ++i)       {         methods[i] = mo[i].method;       }     }     catch (Exception ex)     {       ex.printStackTrace();     }      return methods;   }  } ```","open","status: new,","class101","2022-03-03T15:28:17Z","2022-03-18T13:12:49Z"
"","2656","@DataJpaTest in a multi module project","https://stackoverflow.com/questions/67863862/datajpatest-in-a-multimodule-maven-project   Hi everyone ,  It's been one month , didn't get any replies . Please help ! I have a multi module project containing module A and module B . Module A has the server main class and hence has Module B as dependency . Now i'm trying to write a @DataJpaTest in my module B , but this annotation is looking for @ContextConfiguration which is in main class, for that i need to add Module A as dependency in module B and hence due to this a dependency cycle problem appears. Please suggest me how should i resolve it . Above screenshot shows the exception i'm getting .","closed","type: question,","ankisinha3005","2021-07-01T05:08:36Z","2021-07-03T10:27:05Z"
"","2307","Is there a way to use the unicode theme via the Gradle plugin?","https://stackoverflow.com/q/62054470/206466 (I also asked on the gradle slack)  is there any way to use the unicode theme (are there others?) via the gradle plugin? if not is there an API I can tell them about as a request to enable it?","closed","3rd-party: Gradle,","xenoterracide","2020-05-28T16:26:10Z","2020-05-31T19:36:07Z"
"","2565","Candidate JEP 400: UTF-8 by Default","https://openjdk.java.net/jeps/400 's summary reads: > Use UTF-8 as the JDK's default charset, so that APIs that depend on the default charset behave consistently across all platforms and independently of the user’s locale and configuration.  If this JEP is integrated (into Java 17), it may impact at least the following code line:  https://github.com/junit-team/junit5/blob/0d6d21f0d8bcc3d06e1524b87b7dcdd3f308941a/junit-platform-console/src/main/java/org/junit/platform/console/options/CommandLineOptions.java#L38  Where else does JUnit Platform, Jupiter, and Vintage refer to and rely on the default charset?","closed","component: Platform,","sormuras","2021-03-11T01:32:32Z","2022-06-26T14:24:54Z"
"","2498","How to set up a build with junit 4 or junit 5","https://github.com/navikt/bidrag-cucumber-nais  an application which runs cucumber tests.  when building, I hava two profiles: - default: runs surefire junit 5 plugin - cucumber: (activated with `men test -Dtest=cuce`, which should run junit4 (and therefore also cucumber tests)  this do not work... the cucumber profile do not discover junit4 tests.  I have also asked this question on stack overflow: https://stackoverflow.com/questions/65341427/how-to-set-up-cucumber-with-main-class-and-maven-build","closed","3rd-party: Maven Surefire,","jactor-rises","2020-12-18T16:12:38Z","2020-12-22T15:20:28Z"
"","2754","Remove OSS from integration test project examples","https://github.com/junit-team/junit5/blob/3e17b934ad1b9e1d5f443db78b03d6570a4b6627/platform-tooling-support-tests/projects/maven-starter/pom.xml#L68-L77","closed","status: new,","sormuras","2021-10-26T16:40:11Z","2021-10-31T11:55:19Z"
"","2485","When calling assertThrows, why isn't it checking the message when its expectedType is an instance of the catched object?","https://github.com/junit-team/junit5/blob/177d808f886355fac552aee9495212a4041c0316/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertThrows.java#L59","closed","","leobastiani","2020-12-01T20:27:36Z","2020-12-02T06:35:05Z"
"","2263","Add requires to module ""org.hamcrest""","https://github.com/junit-team/junit5/blob/040037dfb08a0e61b7cb9e485196b0ba3758e756/junit-vintage-engine/src/module/org.junit.vintage.engine/module-info.java#L19  JUnit 4 mandates Hamcrest to be available at runtime and Hamcrest 2.2 (or earlier) claimed `org.hamcrest` as its stable module name.  https://github.com/hamcrest/JavaHamcrest/blob/5dd6a622c73daf716c6e8f33efa712be8dbb42ed/hamcrest/hamcrest.gradle#L16","closed","status: stale,","sormuras","2020-04-18T05:54:44Z","2021-06-03T19:59:28Z"
"","2394","Is there an assertStringsEqualIgnoreEOL() or something?","Hi. I want to assert two Strings be equals ignore EOL, as CR, LF, CRLF. If there exist such a feature?  And if not, I can implement it, I have experience in doing that. Is it acceptable?","closed","component: Jupiter,","XenoAmess","2020-08-27T06:14:02Z","2020-12-06T18:34:45Z"
"","2300","Add ability to set up custom logging","Hi.  We ran into a situation where our test extension does this:  ```     static {         System.setProperty(""java.util.logging.manager"", ""org.jboss.logmanager.LogManager"");     } ```  Which sets up the Java Util Logging to use our own logger.  Except JUnit initialises Java Util Logging before our extension is loaded, via its `LoggerFactory.DelegatingLogger`, which forbids us from setting up our own log manager, because it can only be set before anybody tries to access it.  Is there a way for an extension point to get called before creating a `LoggerFactory.DelegatingLogger`?  If not, is there a way to point JUnit to our own implementation of its `Logger`? I see the interface you created, but I don't understand if it's possible to point JUnit to anything else than a JUL delegating logger?  Thanks for your help!","closed","component: Platform,","FroMage","2020-05-14T15:00:13Z","2020-05-15T12:35:42Z"
"","2213","junit 5 console launcher throwing an error “Caused by: java.lang.ClassNotFoundException: com.build.Info”","Hi, I'm using the complied library of jars of a java project and trying to run a junit 5 test via console launcher. Same test works when i right click and run as junit test but via console runner it throws the below error.  This is what i'm using to compile the program and it complies without errors ![image](https://user-images.githubusercontent.com/46818025/76557764-8645eb80-6472-11ea-97d2-59dbf1407373.png)  and this is how I run the tests ![image](https://user-images.githubusercontent.com/46818025/76558049-feacac80-6472-11ea-866c-9f4fd82de759.png)  Error: Thanks for using JUnit! Support its development at https://junit.org/sponsoring  . +-- JUnit Jupiter [OK] |     '-- buildTests [X] com.build.Info '-- JUnit Vintage [OK]  Failures (1): JUnit Jupiter:buildTests ClassSource [className = 'com.toolkit.buildTests', filePosition = null] => java.lang.NoClassDefFoundError: com.build.VersionInfo    java.lang.Class.getDeclaredFields(Class.java:868)    org.junit.platform.commons.util.ReflectionUtils.getDeclaredFields(ReflectionUtils.java:1334)    org.junit.platform.commons.util.ReflectionUtils.findAllFieldsInHierarchy(ReflectionUtils.java:1092)    org.junit.platform.commons.util.ReflectionUtils.findFields(ReflectionUtils.java:1080)    org.junit.platform.commons.util.AnnotationUtils.findAnnotatedFields(AnnotationUtils.java:371)    [...]  Caused by: java.lang.ClassNotFoundException: com.build.VersionInfo    java.net.URLClassLoader.findClass(URLClassLoader.java:610)    java.lang.ClassLoader.loadClassHelper(ClassLoader.java:935)    java.lang.ClassLoader.loadClass(ClassLoader.java:880)    java.net.FactoryURLClassLoader.loadClass(URLClassLoader.java:1225)    java.lang.ClassLoader.loadClass(ClassLoader.java:863)    [...]    Test run finished after 73 ms   [         3 containers found      ]   [         0 containers skipped    ]   [         3 containers started    ]   [         0 containers aborted    ]   [         2 containers successful ]   [         1 containers failed     ]   [         1 tests found           ]   [         0 tests skipped         ]   [         0 tests started         ]   [         0 tests aborted         ]   [         0 tests successful      ]   [         0 tests failed          ]","closed","","ArthiIreddy","2020-03-12T19:06:11Z","2020-03-12T19:47:27Z"
"","2144","Support parameter resolution in kotlin test method name","Hi, I would like to create a test name with resolved parameters like in [Spock](http://spockframework.org/spock/docs/1.1-rc-1/all_in_one.html#_method_unrolling). Example:  ```kt @ParameterizedTest @ValueSource(strings = [""some text"", ""   s o m e  ""]) fun `should pass non blank string validation for: {0}`(input: String) {     validateNonBlank(input, field)         .throwErrorOnInvalid() } ```  I know I could use: ```kt @ParameterizedTest(name = ""should pass non blank string validation for: {0}"") ``` but I would like to avoid copy pasting.","closed","component: Jupiter,","pmendelski","2020-01-05T15:59:09Z","2020-01-06T21:04:59Z"
"","2037","Support timeouts for extensions","Hi, I tried to set up timeouts for extension methods (`BeforeAllCallback` or `AfterEachCallback`) by using the `@Timeout` annotation with it, but it didn't work.  Also I've tried to set global timeouts such us `junit.jupiter.execution.timeout.aftereach.method.default`, and this also hasn't worked.   It would be great to see this feature in JUnit 5 next releases.","closed","status: stale,","dartyuhov","2019-10-01T12:09:49Z","2022-07-11T16:23:54Z"
"","2580","Add attributes of expected & actual in AssertionFailedError","Hi,   I am currently working on a small project where I would like to display the differences from a foreign set of run JUnit Tests.  So, someone has Tool A and runs it on Project B with Unit tests, and Tool A gives you nice info.   I would like to give a test-overview similar to what is existing, but also include information how far some of the tests where off if that is possible (depending on the datatype, such as double).   At the moment, I will need to get such information out of the ErrorMessage,  which is not ... super complex, but I was wondering that the AssertionFailedExceptionhas 0 attributes except the ErrorMessage.   ## Deliverables  - [ ] Add fields `Optional<> expected` and `Optional<> actual` to AssertionFailedException - [ ] Default them to `Optional.empty` - [ ] Add them when possible/applicable to the assertion methods - [ ] (Maybe) Add an Enum Value which assertion generated the Exception (EQUALS; NOTNULL; etc.) - [ ] (Maybe) Type of the originating test (Test, ParameterizedTest,RepeatedTest, etc. )  I can see that adding the actual values especially for objects might cause side-effects or higher memory consumption,  but I think that adding a few fields can help many people who programmatically work with JUnit Output.    I would also like to get your general thoughts about this.  Was it not done for a purpose?  Would this break something somewhere I don't know?","closed","status: waiting-for-feedback,","lapplislazuli","2021-03-24T14:22:35Z","2021-04-01T05:56:04Z"
"","2161","platform console standalone from cmd issue scan and noclassdeffounderror","Hi, I'm trying to run my tests from command prompt with the platform console standalone 1.5.2. I'm facing two issues:  1. scanning the project folder for the junit tests 2. noclassdeffounderror for library which is fetched through maven  -1 starting out from the project root directory, where the junit-platform-console-standalone-1.5.2.jar is located,  i tried: java -jar junit-platform-console-standalone-1.5.2.jar -cp . --scan-classpath which doesn't detect the junit jupiter 5.5.1 test called TestDummy Only when using -cp C:\Users\\eclipse-workspace\Winium_test\target\test-classes -classpath , it runs my test.  -2 After reading @sormuras comment in https://stackoverflow.com/questions/54409727/junit5-consolelauncher-noclassdeffounderror  I tried  -cp C:\Users\\eclipse-workspace\Winium_test\lib\jPowershell-3.3.1.jar:out -cp C:\Users\\eclipse-workspace\Winium_test\target\test-classes --scan-classpath  and  -cp C:\Users\\eclipse-workspace\Winium_test\lib\jPowershell-3.3.1.jar:C:\Users\\eclipse-workspace\Winium_test\target\test-classes:out --scan-classpath  however, the first command still gives me the noclassdeffound error and the second one doesn't detect the junit test....    I also added the library in a lib folder and the build path, instead of fetching it from maven.  Thanks for helping me out.  Directory output: . ├── .classpath ├── .project ├── .settings │   ├── org.eclipse.core.resources.prefs │   ├── org.eclipse.jdt.core.prefs │   └── org.eclipse.m2e.core.prefs ├── junit-platform-console-standalone-1.5.2.jar ├── lib │   ├── jPowerShell-3.1.1-sources.jar │   └── jPowerShell-3.1.1.jar ├── pom.xml ├── src │   ├── main │   │   ├── java │   │   │   └── test │   │   │       ├── Anyconnect.java │   │   │       ├── TreeNode.java │   │   │       ├── TreeNodeIter.java │   │   │       └── winium_test.java │   │   └── resources │   └── test │       ├── java │       │   └── testcase │       │       └── TestDummy.java │       └── resources └── target     ├── classes     │   ├── META-INF     │   │   ├── MANIFEST.MF     │   │   └── maven     │   │       └── com.Winium_test     │   │           └── Winium_test     │   │               ├── pom.properties     │   │               └── pom.xml     │   └── test     │       ├── Anyconnect.class     │       ├── TreeNode.class     │       ├── TreeNodeIter$ProcessStages.class     │       ├── TreeNodeIter.class     │       └── winium_test.class     └── test-classes         └── testcase             └── TestDummy.class","closed","3rd-party: Maven Surefire,","finndesolace","2020-01-23T15:43:05Z","2020-01-25T17:57:38Z"
"","2345","Remove validation of proceed call count for InvocationInterceptor","Hi,  org.junit.jupiter.engine.execution.InvocationInterceptorChain.ValidatingInvocation#markInvokedOrSkipped prevents to implement some retry like interceptors and I'm not sure what this validation intends so my request is to drop that validation or at least enable interceptors to disable it to avoid to have to use getExecutable().invoke() which bypasses interceptor chain.  Romain","closed","status: stale,","rmannibucau","2020-06-27T16:09:45Z","2022-07-12T23:11:12Z"
"","2479","Allow fields, methods, and constructors in Jupiter to be private","Hi,  In java there is no real reason to support package scope member but not private ones so let's drop that constraint in next release please.  Romain","closed","component: Jupiter,","rmannibucau","2020-11-22T13:46:02Z","2020-11-27T15:50:51Z"
"","2165","Using the JUnit logo","Hi,  I'm working on adding support for JUnit to a [Jenkins plugin](https://github.com/jenkinsci/warnings-ng-plugin) that allows you to inspect your code using different tools. This Jenkins plugin has support to display an icon for the tool that's being used and I was wondering if we could use the JUnit logo from Github ([https://camo.githubusercontent.com/049cbfc3f4c820fe5aa0b376a703a975ab75181a/68747470733a2f2f6a756e69742e6f72672f6a756e6974352f6173736574732f696d672f6a756e6974352d6c6f676f2e706e67](https://camo.githubusercontent.com/049cbfc3f4c820fe5aa0b376a703a975ab75181a/68747470733a2f2f6a756e69742e6f72672f6a756e6974352f6173736574732f696d672f6a756e6974352d6c6f676f2e706e67)) for this purpose.  I'm asking this since I couldn't find any information regarding the license of the logo. If it's not allowed to use the logo that's okay as I can simply leave it empty.","closed","type: question,","Gyanesha","2020-01-26T20:46:24Z","2020-01-27T15:51:13Z"
"","2854","Add an option to list all test found by Console Launcher","Hi,  I'm wondering if it'd be possible to add an option to list all tests found by the Console Launcher.  For example, Google Test [can](http://google.github.io/googletest/advanced.html#listing-test-names) print all tests using `--gtest_list_tests` option.","open","theme: discovery,","VasilyFomin","2022-03-16T16:29:12Z","2022-03-28T18:59:07Z"
"","2427","TempDir is cleaned before AfterAll is executed","Hi,  I'm using JUnit 5 (5.7.0). In a test, I need to create some files in a temp dir, and init stuff that will lock some files in the temp dir (on Windows). The issue is that the test can't end correctly, since I get an error when JUnit is trying to clean the directory.  ```java class MyTests {    static MyCloseableStuff closeable;    @BeforeAll   static void init(@TempDir Path temp) {     closeable = init(temp); // Creates some files in temp, and keep them open (=locked on Windows)   }    @AfterAll   static void stop() {     closeable.close(); // Close the open files descriptors   }  } ```  I'm receiving this exception: ``` Sep 28, 2020 8:49:39 AM org.junit.jupiter.engine.execution.JupiterEngineExecutionContext close SEVERE: Caught exception while closing extension context: org.junit.jupiter.engine.descriptor.ClassExtensionContext@5bfc79cb java.io.IOException: Failed to delete temp directory C:\Users\VSSADM~1\AppData\Local\Temp\junit15147163024233421499. The following paths could not be deleted (see suppressed exceptions for details): , xxx, yyy, ... 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.createIOExceptionWithAttachedFailures(TempDirectory.java:262) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:182) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$closeAllStoredCloseableValues$3(ExtensionValuesStore.java:68) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at java.base/java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:395) 	at java.base/java.util.stream.Sink$ChainedReference.end(Sink.java:258) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:485) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.closeAllStoredCloseableValues(ExtensionValuesStore.java:68) 	at org.junit.jupiter.engine.descriptor.AbstractExtensionContext.close(AbstractExtensionContext.java:74) 	at org.junit.jupiter.engine.execution.JupiterEngineExecutionContext.close(JupiterEngineExecutionContext.java:53) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:222) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:57) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$cleanUp$9(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.cleanUp(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:87) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)  ``` Seems to me that the TempDir is tried to be cleaned before my AfterAll method is called. Is there a way for me to fix that?","closed","component: Jupiter,","henryju","2020-09-28T09:04:35Z","2020-09-29T08:54:21Z"
"","2224","Ability to capture any exception raised during test execution","Hi,  I'd like to implement a JUnit5 extension that would capture any exception raised during test execution,  including exceptions raised in other Extensions. My goal is to help in debugging integration and functional tests when they fail by displaying environmental information in the CI. For example to execute:  ```         if (System.getenv(""JENKINS_HOME"") != null || Boolean.parseBoolean(System.getProperty(""inCI""))) {             LOGGER.info(""Environment information to help debug the failing test:"");             LOGGER.info(RuntimeUtils.run(""top -b -n 1""));             LOGGER.info(RuntimeUtils.run(""lsof -i -P -n ""));             LOGGER.info(RuntimeUtils.run(""docker ps -a""));             LOGGER.info(RuntimeUtils.run(""docker events --since '15m' --until '0m'""));         } ```  I first tried writing an extension implementing `TestExecutionExceptionHandler` to find that it'll only trigger inside a `@Test`(see https://github.com/junit-team/junit5/blob/86277defc09e76e37de7c053461346b1881adf4b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java#L217).  I then checked the code and found that https://github.com/junit-team/junit5/blob/29aedcd74487f083cf97b0d37206c0d78fc77f6e/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java#L131 shows that it's currently not possible to have an extension catching any raised exception since https://github.com/junit-team/junit5/blob/29aedcd74487f083cf97b0d37206c0d78fc77f6e/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java#L149 will raise any collected exception.  It would be nice to be able to write an extension implementing some interface and have `throwableCollector.assertEmpty()` call these extensions before it raises the exception. That would allow me to implement my use case above.  WDYT?  Thanks!","closed","","vmassol","2020-03-25T12:10:41Z","2020-03-25T13:36:55Z"
"","2556","Document fully qualified method name syntax for custom conditions","Hi,  I am studying JUnit5 by looking at the official documentation.  While studying, I have a question for custom condition method.  The documents says ""Condition methods located in external classes must also be static."", but it does not work .  What did i do wrong?  ```java public class CustomConditionalTest {      //this code don't work     @Test     @EnabledIf(""eCustomCondition"")     void enabled() {       }      @Test     @DisabledIf(""customCondition"")     void disabled() {      }      boolean customCondition() {         return true;     }    } class ExternalClass {       static boolean eCustomCondition() {         return true;     } } ```  In my opinion, it can't seem to find the condition method.  ``` Failed to evaluate condition [org.junit.jupiter.api.condition.EnabledIfCondition]: Could not find method [eCustomCondition] in class [dev.donghyeon.junitstudy.conditional.CustomConditionalTest] ```   [code](https://github.com/DaeAkin/JUnit5-Study/blob/junit5-q/src/test/java/dev/donghyeon/junitstudy/conditional/CustomConditionalTest.java)","closed","component: Jupiter,","DaeAkin","2021-02-24T01:57:50Z","2021-03-21T18:37:33Z"
"","2093","IDEA  is unavailable in junit 5.5.2","Hi!  jupiter tests didn't show `""""` reference  It's working for junit:junit:4.12 ```     @Test     void ok() {         var expected =                 java.util.Collections.singletonList(                         java.util.Map.ofEntries(                                 java.util.Map.entry(""type"", ""BASE""),                                 java.util.Map.entry(""name"", ""owner-base""),                                 java.util.Map.entry(""pretty_name"", ""pretty-name-1"")                          )                 );          var actual =                 java.util.Collections.singletonList(                         java.util.Map.ofEntries(                                 java.util.Map.entry(""type"", ""BASE""),                                 java.util.Map.entry(""name"", ""owner-base""),                                 java.util.Map.entry(""pretty_name"", ""pretty-name-2"")                          )                 );          //junit:junit:4.12         org.junit.Assert.assertEquals(expected, actual);     } ``` output: ``` expected:<[{pretty_name=pretty-name-1, name=owner-base, type=BASE}]> but was:<[{pretty_name=pretty-name-2, name=owner-base, type=BASE}]> Expected :[{pretty_name=pretty-name-1, name=owner-base, type=BASE}] Actual   :[{pretty_name=pretty-name-2, name=owner-base, type=BASE}]  ```  but for org.junit.jupiter:junit-jupiter-api:5.5.2 it's not  ```     @Test     void differenceIsGone() {         var expected =                 java.util.Collections.singletonList(                         java.util.Map.ofEntries(                                 java.util.Map.entry(""type"", ""BASE""),                                 java.util.Map.entry(""name"", ""owner-base""),                                 java.util.Map.entry(""pretty_name"", ""pretty-name-1"")                          )                 );          var actual =                 java.util.Collections.singletonList(                         java.util.Map.ofEntries(                                 java.util.Map.entry(""type"", ""BASE""),                                 java.util.Map.entry(""name"", ""owner-base""),                                 java.util.Map.entry(""pretty_name"", ""pretty-name-2"")                          )                 );          //org.junit.jupiter:junit-jupiter-api:5.5.2         org.junit.jupiter.api.Assertions.assertEquals(expected, actual);     } ``` output: ``` expected: <[{type=BASE, name=owner-base, pretty_name=pretty-name-1}]> but was: <[{type=BASE, name=owner-base, pretty_name=pretty-name-2}]> org.opentest4j.AssertionFailedError: expected: <[{type=BASE, name=owner-base, pretty_name=pretty-name-1}]> but was: <[{type=BASE, name=owner-base, pretty_name=pretty-name-2}]> 	at org.junit.jupiter.api.AssertionUtils.fail(         ....         at java.base/java.lang.Thread.run ```  Environment: IntelliJ IDEA 2019.2.4 (Ultimate Edition) Build #IU-192.7142.36, built on October 29, 2019  Java: open jdk-11.0.2   macOS 10.14.6 (18G103) Kernel Darwin 18.7.0","closed","3rd-party: IntelliJ IDEA,","romeme","2019-11-07T10:10:57Z","2019-11-07T11:37:35Z"
"","2132","JUnit throws SIGBUSes when used from c++?","Hi!  I'm using CLion with a c++ project (cmake), which starts a jvm. The java part is built with gradle. The project works, but I'm having a problem with debugging.  When I start the JVM, I immediately get a SIGSEGV. I understand that it's normal, it comes from the jvm itself, and there's no workaround except ignoring SIGSEGV. A bit annoying but not too bad as it only happens once per session.  BUT, after that, I continue debugging, and I get constant SIGBUS signals with this stack trace:  ```  0x000000011f108385  0x000000011761dca7  0x000000011761dca7  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x0000000117614849 JavaCalls::call_helper(JavaValue*, methodHandle const&, JavaCallArguments*, Thread*) 0x000000010bf3a582 StackWalk::fetchFirstBatch(BaseFrameStream&, Handle, long, int, int, int, objArrayHandle, Thread*) 0x000000010c227cac StackWalk::walk(Handle, long, int, int, int, objArrayHandle, Thread*) 0x000000010c2278fc JVM_CallStackWalk 0x000000010bfb14a2  0x0000000117623950  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x000000011761da00  0x0000000117614849 JavaCalls::call_helper(JavaValue*, methodHandle const&, JavaCallArguments*, Thread*) 0x000000010bf3a582 InstanceKlass::call_class_initializer(Thread*) 0x000000010bf22af7 InstanceKlass::initialize_impl(Thread*) 0x000000010bf2244f Reflection::invoke_constructor(oopDesc*, objArrayHandle, Thread*) 0x000000010c1ebdbb JVM_NewInstanceFromConstructor 0x000000010bfc14f6  0x0000000117623950  0x000000011761da00  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x000000011761da00  0x000000011761dae2  0x000000011761dae2  0x000000011761dcec  0x000000011761da00  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x000000011761da00  0x000000011761dae2  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x000000011761da00  0x0000000117614849 JavaCalls::call_helper(JavaValue*, methodHandle const&, JavaCallArguments*, Thread*) 0x000000010bf3a582 jni_invoke_static(JNIEnv_*, JavaValue*, _jobject*, JNICallType, _jmethodID*, JNI_ArgumentPusher*, Thread*) 0x000000010bf7e2af jni_CallStaticVoidMethodV 0x000000010bf81c69 JNIEnv_::CallStaticVoidMethod(_jclass*, _jmethodID*, ...) jni.h:1521 main main.cpp:80 start 0x00007fff6f6563d5 start 0x00007fff6f6563d5 ```  It doesn't stop in my code. I don't understand why this is happening, or if it's possible to avoid them, aside from ignoring all SIGBUSs.  I minimized my code and created the most simple example which reproduces the issue. Basically I created a cpp project which starts a jvm with **org/junit/platform/console/ConsoleLauncher** as main, with one simple test class. And the SIGBUS happens. It happens before my test even run. If I put my code as main instead of JUnit, it doesn't happen.  You can get a simple project which demonstrate the issue here: https://github.com/tallavi/sigbus-reproduction  Another thing I noticed. This example gives a single SIGBUS. If I put two test classes, I get two SIGBUSes, if I put 3, I get 3.  Thus, I suspect something within JUnit.  My environment: MacOS 10.14.6 Clion 2019.3 Java 11.0.4 2019-07-16 LTS JUnit versions I tried: 1.5.1, 1.5.2, 1.6.0-M1  Thanks!","closed","","tallavi","2019-12-17T20:12:40Z","2020-01-21T16:50:34Z"
"","2587","Add static method `named` to the `Named` interface","Hi!  First of all, great work! JUnit 5 is my favorite testing library of all time!  I've just discovered that JUnit 5.8 will provide a `Named` interface, which is a great addition! But the thing I don't quite like about is that I have to use `Named.of(...)` to construct such an instance. I'd rather use a more descriptive method which I could statically import, like `Named.named(...)`, so I could write something like  ```java     arguments(named(""me"", new User())) ```  Wdyt?  ## Deliverables  - Add a static method `named` to the `Named` interface.  P.S. I'd love to provide a PR for this!","closed","component: Jupiter,","helpermethod","2021-04-08T07:28:13Z","2021-04-09T14:11:14Z"
"","2432","Which jars are required for a minimal and backward compatible (-> ""vintage"") junit 5 environment?","hi there  there are A LOT of jars on junit page - which ones are required for a MINIMAL backward compatible (-> ""vintage"") junit 5 environment?  Thank you for your feedbacks.   With best regards, Jan","closed","","jayjupdhig","2020-10-01T15:42:04Z","2020-10-02T13:09:28Z"
"","2848","Support architecture in @EnabledOnOs and @DisabledOnOs","Hi team,  In Spring Boot we [had the issue](https://github.com/spring-projects/spring-boot/issues/30082) that some of our tests don't run on Linux when using an AArch64 architecture. I then added a [custom annotation](https://github.com/spring-projects/spring-boot/blob/24a68fc5953f7de1c485b70692e65002782f4d70/spring-boot-project/spring-boot-tools/spring-boot-test-support/src/main/java/org/springframework/boot/testsupport/junit/DisabledOnOs.java) and the [condition](https://github.com/spring-projects/spring-boot/blob/24a68fc5953f7de1c485b70692e65002782f4d70/spring-boot-project/spring-boot-tools/spring-boot-test-support/src/main/java/org/springframework/boot/testsupport/junit/DisabledOnOsCondition.java) to disable the tests on Linux AArch64. This could be something that JUnit Jupiter provides out of the box.   What do you think?  Another note: This could lead to making the annotations repeatable, as maybe a test doesn't work on Linux aarch64 and on MacOS x86, which you could not do without repeating the annotation.  ## Deliverables  - [ ] Introduce `architecture` attribute in the `@EnabledOnOs` and `@DisabledOnOs` annotations.","closed","component: Jupiter,","mhalbritter","2022-03-08T10:46:44Z","2022-07-04T17:53:36Z"
"","2749","@Suite example usage","Hi Team,  I recently upgraded the Junit5 version with 5.8.1. Also, I have added junit-platform-suite v1.8.1 to create test suites.   Please find the sample example I created...  ```java package com.ABC.audit;  import org.junit.jupiter.api.DisplayName; import org.junit.platform.suite.api.IncludeClassNamePatterns; import org.junit.platform.suite.api.SelectPackages; import org.junit.platform.suite.api.Suite;  @Suite @DisplayName(""Junit first test suite"") @SelectPackages(""com.ABC.XYZ"") @IncludeClassNamePatterns("".*Tests"") public class AuditTestSuite { } ```  However, when I try to run the test suite, it says no tests were found from IntelliJ. I have been using the below property to run tests... I am able to trigger. `junit.jupiter.testinstance.lifecycle.default = per_class`  Can someone please assist me in running the suites? Is there any specific configuration that am I missing?!   Also, please assist me in running Test Suites in Parallel.  Thank you.","closed","3rd-party: IntelliJ IDEA,","praveenreddynarala","2021-10-22T17:44:34Z","2021-10-29T07:29:28Z"
"","2752","How to run Junit 5 @Suite tests through maven command line","Hi Team,  I am unable to run Junit 5 Test Suite (@Suite) using the Maven command line. It always says, Total tests 0. I have tried various options/configurations from the maven-surefire plugin v3.0.0-M5.  **Sample Test Suite:** ``` package com.test.testsuites;  import com.test.qa.junit5.MCTest; import junit5.tags.ArchiveSuite; import org.junit.platform.suite.api.IncludeClassNamePatterns; import org.junit.platform.suite.api.IncludeTags; import org.junit.platform.suite.api.SelectPackages; import org.junit.platform.suite.api.Suite; import org.junit.platform.suite.api.SuiteDisplayName;  @Suite @SuiteDisplayName(""Junit first test suite"") @SelectPackages(         {                 ""com.test.archive"",                 ""com.test.legalhold""         }) @IncludeClassNamePatterns("".*Tests"") @IncludeTags(""Archive"") @ArchiveSuite public class ArchiveTestSuite extends MCTest {  } ```  **1 Option:** I have used Junit 5 Paralallism configuration inside the Surefire plugin as below to run all the tests from inside the test suite in parallel. None of the tests was picked up. It says no tests to run.   ```                               maven-compiler-plugin                 ${maven.compiler.plugin}                                      ${java.version}                     ${java.version}                                                            maven-surefire-plugin                 ${surefire.plugin.version}                                      false                                              **/*TestSuite.java                         **/*TestSuites.java                                                                   ${Tags}                         Skip, WIP                                                                               junit.jupiter.conditions.deactivate = *                             junit.jupiter.extensions.autodetection.enabled = true                             junit.jupiter.execution.parallel.enabled = true                             junit.jupiter.execution.parallel.mode.default = concurrent                             junit.jupiter.execution.parallel.config.strategy=fixed                             junit.jupiter.execution.parallel.config.fixed.parallelism=6                             junit.jupiter.testinstance.lifecycle.default = per_class                                                                                                                      COMPAT                                                    ```  **2nd Option:** Using Maven Surefire Forks to run the tests inside the test suite in parallel with the below configuration from the POM.xml file.   And used **mvn -Dgroups=Test** command to run the tests using Tags. No tests were detected.   **Response from Maven** ``` [INFO] --- maven-surefire-plugin:3.0.0-M5:test (default-test) @ api-archive --- [INFO]  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  **POM.XML** ```                  maven-surefire-plugin                 ${surefire.plugin.version}                                      false                     4                     true                     suiteAndClasses                                              **/*TestSuite.java                         **/*TestSuites.java                                                                   ${Tags}                         Skip, WIP                                                                                             COMPAT                                                    ```  **3rd Option:** I have used the same configuration as like above POM.xml, but I have used Test Cases Tag name instead of Test Suite Tag name. Now the test cases were run in sequential, however, the test suite still shows 0 Total Test Cases.   Thank you. Praveen","closed","status: new,","praveenreddynarala","2021-10-26T12:55:27Z","2021-10-26T14:18:12Z"
"","2756","Console logs are misleading when Tests run in parallel using Junit 5 parallelism","Hi Team,  I am running into an issue where the console logs are misleading when the test failed. I am running our Junit 5 tests (3 test classes) in Parallel using Junit 5 configuration properties. With this configuration, the tests classes run concurrently using different **|ForkJoinPool-1-worker-9, |ForkJoinPool-1-worker-1, |ForkJoinPool-1-worker-7** threads etc.   When there is a test failure, I can see different loglines from multiple threads. Sometimes, I can't even see expected test associated logs. This is misleading during test failure analysis.  I have tried the below options to segregate the logs based on test level...  **Step 1:** I have created one ConsoleOutputListener class which IMPLEMENTS TestExecutionListener class and overridden reportingEntryPublished like below in my test project  ``` public class ConsoleOutputListener implements TestExecutionListener {      @Override     public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {         entry.getKeyValuePairs().values().forEach(c -> System.out.println(""Captured output: "" + c));         TestExecutionListener.super.reportingEntryPublished(testIdentifier, entry);     }  } ``` **Step 2:** Registered above class in Services at below location `src/test/resources/META-INF/services/org.junit.platform.launcher.TestExecutionListener`  **Step 3:** Added above classpath in the above file like below `test.ConsoleOutputListener`  **Step 4:** Added stdout & stderr in Maven Surefire Configurations as below   ```                              junit.jupiter.conditions.deactivate = *                             junit.jupiter.extensions.autodetection.enabled = true                             junit.jupiter.execution.parallel.enabled = true                             junit.jupiter.execution.parallel.mode.default = concurrent                             junit.jupiter.execution.parallel.config.strategy=fixed                             junit.jupiter.execution.parallel.config.fixed.parallelism=6                             junit.jupiter.testinstance.lifecycle.default = per_class                             junit.platform.output.capture.stdout = true                             junit.platform.output.capture.stderr=true           ```  **Step 5:** I ran the tests using mvn -DTags=SampleTestsTag  **Actual Result:** Still I am seeing logs from different threads at the class level  Note: I am using Lg4j2 to log the events and also, I have log4j2.xml file in from src/test/resources  ```                                                                                           ``` Using JUnit 5.8.1  ```              org.junit.jupiter             junit-jupiter             5.8.1             compile          ```  Maven Surefire **v3.0.0-M5**  Kindly assist me if I am making any mistakes or anything is missed from my setup & configuration.   Thanks Praveen","closed","3rd-party: Maven Surefire,","praveenreddynarala","2021-10-27T08:43:26Z","2021-10-27T09:10:05Z"
"","2223","How Get result of singole childrens test from a @TestFactory (DynamicTest)?","Hi all,   if I have a `@TestFactory` method that runs 20 sub-tests with different parameters with summary, how can I get ALL test results?  ```java    SummaryGeneratingListener listener = new SummaryGeneratingListener();    LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()                 .selectors(selectMethod(cls,m))                 .build();          Launcher launcher = LauncherFactory.create();         launcher.registerTestExecutionListeners(listener);         launcher.execute(request);         TestExecutionSummary summary = listener.getSummary(); ````  I can get only Number total tests of Success and Fail test, and there is only `List testsFail= summary.getFailures();`, but I want ALL results also Successful tests.  Is there a function that returns a MAP of  ??  thanks Regards","closed","type: question,","enaud1984","2020-03-23T16:14:12Z","2020-03-23T16:22:35Z"
"","2215","Running tests from a jar file: summary return 0 test found","Hi all, I am trying to run tests that are in  a jar file (sr/java/main/test/jarfile.jar directory ). The launcher does not find any test.  From intellij, in source of project when i runTesT is all ok, so no problem in actual tests.  TestProject: ```  Test_Road  ├── src  │   ├── test  │   │      ├── java  │   │      └── package_test  │   └──resource          │  │                        └── ConfigurationControllerTest.java  └── pom.xml ``` pom.xml is this: ```       4.0.0      it.almaviva     TestSuite     1.0-SNAPSHOT                             com.fasterxml.jackson.core             jackson-databind             2.10.3                                log4j             log4j             1.2.17                                org.projectlombok             lombok             1.18.12             provided                                com.vaadin.external.google             android-json             0.0.20131108.vaadin1             test                               org.junit.jupiter             junit-jupiter-engine             5.6.0             test                               org.junit.platform             junit-platform-runner             1.5.2             test                               org.junit.platform             junit-platform-suite-api             1.6.0             test                               org.junit.platform             junit-platform-runner             1.6.0                               io.rest-assured             rest-assured             3.0.3                                                             maven-compiler-plugin                 3.8.1                                           maven-surefire-plugin                 2.22.2                                           maven-failsafe-plugin                 2.22.2                                           org.apache.maven.plugins                 maven-compiler-plugin                                      8                     8                                                ````  ``` public class ConfigurationControllerTest {     private static final Logger log = Logger.getLogger(ConfigurationControllerTest.class);      private static Properties properties = PropertyUtil.getProperties(""/test.properties"");         @Test     public void smartRoadRegistryTest(){         String endpoint = properties.getProperty(""smart-road.api.configuration-controller.endpoint.registry"");          try {             expect().                     statusCode(200).                     contentType(ContentType.JSON).             when().                     get(endpoint);         } catch(AssertionError e){             log.error(""Smart Road Registry test has failed ... \n"");             Assertions.fail(e.getMessage());         }     } } ```  If i run smartRoadRegistryTest method it work well.  Now i have create a new project TestSuiteLoader where i load jar inspect class and method with @Test and after i run a method called.  ``` src  └── main       └── java             ├── packageRunTest             │      └── TestsuiteApplication.java             └── pakageTest 		   └──TestClass.jar ```  My function is this:  ``` public void runOne(String jar_file,String class_name, String test_name,SummaryGeneratingListener listener) {          File file = new File(""src\\main\\java\\test\\""+ jar_file);         URL[] urls = {new URL(""jar:file:"" + file + ""!/"")};         URLClassLoader cl = URLClassLoader.newInstance(urls);          Class cls=cl.loadClass(class_name);         Method m=cls.getMethod(test_name);         LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()                 .selectors(selectMethod(cls,m))                 .build();          Launcher launcher = LauncherFactory.create();         launcher.registerTestExecutionListeners(listener);         launcher.execute(request);         TestExecutionSummary summary = listener.getSummary();          StringWriter out = new StringWriter();         summary.printTo(new PrintWriter(out));         System.out.println(out);     } ```  In console i read: ` c.runOne(""TestSuite.jar"",""SmartRoadApiTest.ConfigurationControllerTest"",""smartRoadRegistryTest"", new SummaryGeneratingListener());`  Test run finished after 63 ms [         1 containers found      ] [         0 containers skipped    ] [         1 containers started    ] [         0 containers aborted    ] [         1 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ]  0 Test Found!!  my pom.xml is:  ```      4.0.0              org.springframework.boot         spring-boot-starter-parent         2.2.5.RELEASE                    it.anas.TestSuiteLoader     testsuite     0.0.1     testsuite     Servizi per Caricamento Test Suite               1.8                                 org.springframework.boot             spring-boot-starter                                org.springframework.boot             spring-boot-devtools             runtime             true                               org.projectlombok             lombok             true                               org.springframework.boot             spring-boot-starter-test             test                                                   org.junit.vintage                     junit-vintage-engine                                                             org.junit.jupiter             junit-jupiter-engine             5.6.0                               org.junit.platform             junit-platform-launcher             1.2.0                               org.reflections             reflections             0.9.12             test                                         org.testng             testng             7.1.0             test                                org.springframework.boot             spring-boot-starter-web                               org.reflections             reflections             0.9.12             compile                               org.junit.jupiter             junit-jupiter-api             5.6.0                               org.junit.vintage             junit-vintage-engine         4.12.0-M4                                                       org.springframework.boot                 spring-boot-maven-plugin                                           org.apache.maven.plugins                 maven-compiler-plugin                                      1.8                     1.8                                                                     maven-surefire-plugin                     2.22.2                                                       maven-failsafe-plugin                     2.22.2                                   ```   Thanks Regards Giuseppe","closed","3rd-party: Maven Surefire,","enaud1984","2020-03-14T14:23:18Z","2020-03-14T15:36:48Z"
"","2990","Impose an order in @BeforeEach methods","Hi all,  I just wanted  to know if there's a possibility we can impose a particular order in execution of methods annotated with `@BeforeEach`. If so, which interface should I implement or which class should I touch?   For me it would be very useful since I use several `beforeEach` methods to improve readability of my tests.  Thanks in advance.  Regards.","open","status: new,","Cs4r","2022-07-27T15:39:50Z","2022-07-27T15:41:06Z"
"","1976","Issue with @-file when classpath includes spaces in folder name","Hi   I'm using Junit 5 version 5.3.2 on Spring Tools Suite (STS) version 4.2.0 on Windows 10. I have my STS installed on a folder on my c drive called 'spring tools'.   When running a Junit test within a project with a short enough classpath that an @-file is not generated, my tests run fine. I believe this is because the classpath is enclosed in double quotes.  But on a project that has a long enough classpath that an @-file is generated when running a JUnit test, I get a 'No tests found with test runner 'JUnit 5' and a message in the console saying  ""Error: Could not find or load main class tools\sts-4.2.0.RELEASE\configuration\org.eclipse.osgi\233\0\.cp;C:\spring Caused by: java.lang.ClassNotFoundException: tools\sts-4/2/0/RELEASE\configuration\org/eclipse/osgi\233\0\/cp;C:\spring""  The issue is that when I look into the @-file that is generated, the file does not generate with the classpath enclosed in double quotes so when the Picocli parser reads the classpath it falls over when encountering the white space in 'spring tools'.  I've attached an example @-file. [temp-CsvToJsonConverterTest-classpath-arg-1565169103897.txt](https://github.com/junit-team/junit5/files/3476560/temp-CsvToJsonConverterTest-classpath-arg-1565169103897.txt)","closed","","cdl-locp","2019-08-07T10:35:42Z","2019-08-09T08:17:14Z"
"","2245","Console launcher does not execute JUnit Jupiter test with --select-class option","Hey,  We have a huge database with junit4 tests and we want to start using junit5.   I have configured an ant task that uses the junit console launcher directly. I am able to successfully run using the junit platform vintage engine a pure old-school junit4 test case, but I am not able to run any junit5 tests although I have listed both engines in the ant task:     ```xml           ```  To eliminate the ant layer, I tried doing the same using command line only. Here is my command:  ```shell java -jar junit-platform-console-standalone-1.6.0-RC1.jar --disable-ansi-colors --details-theme=ascii --select-class=com.pcbsys.nirvana.nAdminAPI.JmxConnectionTest1 --classpath=C:\10.7.0.x\jars\nServer10.7.0.0.1.jar;C:\10.7.0.x\jars\nJUnitTests10.7.0.0.1.jar;C:\10.7.0.x\jars\integration-test-ext10.7.0.0.1.jar;C:\10.7.0.x\jars\nPlugin10.7.0.0.1.jar;C:\10.7.0.x\jars\nProtocols10.7.0.0.1.jar;C:\10.7.0.x\jars\nAdminAPI10.7.0.0.1.jar;C:\10.7.0.x\jars\nClient10.7.0.0.1.jar;C:\10.7.0.x\jars\nEnterpriseManager10.7.0.0.1.jar;C:\10.7.0.x\jars\nJMS10.7.0.0.1.jar;C:\10.7.0.x\jars\testServerFramework10.7.0.0.1.jar;C:\10.7.0.x\jars\umExtensions10.7.0.0.1.jar;C:\10.7.0.x\jars\umModules10.7.0.0.1.jar;C:\10.7.0.x\jars\umTools10.7.0.0.1.jar;C:\10.7.0.x\jars\umSampleApplications10.7.0.0.1.jar;C:\10.7.0.x\build\nirvana-dependencies\junit5\junit-platform-console-standalone-1.6.0-RC1.jar;C:\10.7.0.x\build\nirvana-dependencies\junit5\junit-platform-engine-1.6.0-RC1.jar;C:\10.7.0.x\build\nirvana-dependencies\junit5\junit-platform-launcher-1.6.0-RC1.jar;C:\10.7.0.x\build\nirvana-dependencies\junit5\junit-platform-runner-1.6.0-RC1.jar;C:\10.7.0.x\build\nirvana-dependencies\junit5\junit-platform-commons-1.6.0-RC1.jar;C:\10.7.0.x\build\nirvana-dependencies\junit5\junit-platform-suite-api-1.6.0-RC1.jar ```  The test class `com.pcbsys.nirvana.nAdminAPI.JmxConnectionTest1` uses only junit 5 and lives in `C:\10.7.0.x\jars\nJUnitTests10.7.0.0.1.jar`.  The output I get is:   ``` Thanks for using JUnit! Support its development at https://junit.org/sponsoring  . +-- JUnit Jupiter [OK] '-- JUnit Vintage [OK]  Test run finished after 24 ms [         2 containers found      ] [         0 containers skipped    ] [         2 containers started    ] [         0 containers aborted    ] [         2 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ] ```  The test is not executed although it seems to be detected somehow (I do not know how to interpret the output - my test has 3 methods while it says 2 containers detected)  The same command works perfectly well when I supply another test class that uses junit4 only – obviously picked up by the vintage execution.  What am I doing wrong?","closed","theme: discovery,","Vazzilena","2020-04-06T18:39:23Z","2020-10-15T14:00:06Z"
"","2280","Is the JUnit 4 Timeout rule supported with the Vintage engine?","Hey,  Is junit4 timeout rule supported with the vintage engine?   We are experiencing an issue similar to https://github.com/junit-team/junit5/issues/1742 when we started migrating to junit5 runners and switched to junit-platform-console-standalone-1.6.0-RC1.jar.   My impression is that old junit4 tests will be working out of the box with the junit vintage engine.   What we observe:  JUnit4's FailOnTimeout rule would create a separate thread group and thread to run the test in (including any other rule's before()/after()) : https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java  JUnit5 does it differently, and it would try to run rule's after() statements on its own (in its own main thread). This results in rule's before() and after() statements run in separate threads and run in parallel which must not happen and eventually causes `IllegalThreadStateException `in our tests.  Is there a way to workaround this without having to migrate all the tests to junit5?","closed","component: Vintage,","Vazzilena","2020-04-30T07:10:43Z","2020-05-05T20:20:50Z"
"","2872","How to run @BeforeEach with parameter in junit 5?","Hey team! I am new to junit 5 and still learning features in junit 5. Recently I came across a situation where I want to run same test for different sets of data. I used parameterization for that. Now as per new requirement, I have to run few steps before each test using parameter that test is using. I am thinking to setup @BeforeEach hook with parameter, so that for a parameter I can run few steps and then for same parameter, I can run actual test. I did some research and found that `ParameterResolver` can be one solution to achieve that. But can't understand how that works. If I get some help to understand how to use that OR if someone can suggest any other way, that will be very helpful. Here I am adding sample code to explain what I am trying to achieve:  ```  import org.junit.jupiter.api.BeforeEach  import org.junit.jupiter.api.DisplayName  import org.junit.jupiter.params.ParameterizedTest  import org.junit.jupiter.params.provider.MethodSource    class SampleTest {        companion object {          @JvmStatic          fun getParameter(): List {              return listOf(                  ""Parameter 1"",                  ""Parameter 2"",                  ""Parameter 3"",                  ""Parameter 4"",              )          }      }        @BeforeEach      @MethodSource(""getParameter"") // As per my search, I think this may not possible. Just adding this to demonstrate what I am trying to achieve in @BeforeEach hook      fun beforeEveryParameterizedHooksTest(parameter: String) {          System.out.println(""Running before hooks for: $parameter"")      }        @DisplayName(""Parameterized hooks test 1"")      @MethodSource(""getParameter"")      @ParameterizedTest      fun testParameterizedHooksFirst(parameter: String) {          System.out.println(""Test 1 running for: $parameter"")      }            @DisplayName(""Parameterized hooks test 2"")      @MethodSource(""getParameter"")      @ParameterizedTest      fun testParameterizedHooksSecond(parameter: String) {          System.out.println(""Test 2 running for: $parameter"")      }  } ``` Desired Output: ``` Running before hooks for: Parameter 1 Test 1 running for: Parameter 1 Running before hooks for: Parameter 2 Test 1 running for: Parameter 2 Running before hooks for: Parameter 3 Test 1 running for: Parameter 3 Running before hooks for: Parameter 4 Test 1 running for: Parameter 4  Running before hooks for: Parameter 1 Test 2 running for: Parameter 1 Running before hooks for: Parameter 2 Test 2 running for: Parameter 2 Running before hooks for: Parameter 3 Test 2 running for: Parameter 3 Running before hooks for: Parameter 4 Test 2 running for: Parameter 4 ``` As per suggestion, I asked same question on [gitter](https://gitter.im/junit-team/junit5#:~:text=Hello!%20I%20am%20trying%20to%20figure%20out%20how%20can%20I%20create%20%40BeforeEach%20with%20some%20parameter%20in%20my%20parameterized%20test.%20Basically%2C%20I%20want%20to%20run%20something%20before%20each%20test%20using%20parameter%20for%20that%20test.%20Here%20I%20am%20adding%20Sample%20code%20which%20explains%20what%20I%20am%20trying%20to%20achieve) and [stack overflow](https://stackoverflow.com/questions/71669293/how-to-run-beforeeach-with-parameter-in-junit-5), but haven't get any response yet so adding same question here. Thanks in advance for your help team!","closed","theme: parameterized tests,","PatelJigarK","2022-03-30T14:11:49Z","2022-03-30T15:52:42Z"
"","1988","mvn test fails to execute tests with jupiter 5.5.1 and junit-platform 1.5.1","Hello, I'm working in [Apache James](https://github.com/apache/james-project) and we just upgraded our junit5 from 5.2.0 to  5.5.1. But some of our modules fails to run tests, basically this is the dependency list of those failing modules, they inherit parent dependecies (jupiter 5.5.1 and platform 1.5.1) ```                      org.junit.jupiter             junit-jupiter-engine             test                               org.junit.platform             junit-platform-launcher             test                               org.junit.vintage             junit-vintage-engine             test          ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter/Vintage 5.5.1 and Platform 1.5.1  - Build Tool/IDE: maven  ## Deliverables Some error logs: ``` WARNING: TestEngine with ID 'junit-vintage' failed to discover tests java.lang.NoSuchMethodError: org.junit.platform.commons.util.ReflectionUtils.tryToReadFieldValue(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Object;)Lorg/junit/platform/commons/function/Try; 	at org.junit.vintage.engine.support.UniqueIdReader.apply(UniqueIdReader.java:47) 	at org.junit.vintage.engine.support.UniqueIdReader.apply(UniqueIdReader.java:28) 	at java.util.function.Function.lambda$andThen$1(Function.java:88) 	at java.util.stream.Collectors.lambda$groupingBy$45(Collectors.java:907) 	at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) 	at org.junit.vintage.engine.discovery.RunnerTestDescriptorPostProcessor.addChildrenRecursively(RunnerTestDescriptorPostProcessor.java:46) 	at org.junit.vintage.engine.discovery.RunnerTestDescriptorPostProcessor.applyFiltersAndCreateDescendants(RunnerTestDescriptorPostProcessor.java:39) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.vintage.engine.discovery.VintageDiscoverer.discover(VintageDiscoverer.java:48) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:62) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:130) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:117) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:82) 	at org.apache.maven.surefire.junitplatform.TestPlanScannerFilter.accept(TestPlanScannerFilter.java:56) 	at org.apache.maven.surefire.util.DefaultScanResult.applyFilter(DefaultScanResult.java:102) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.scanClasspath(JUnitPlatformProvider.java:129) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.getSuites(JUnitPlatformProvider.java:100) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189) 	at org.apache.maven.surefire.util.ReflectionUtils.invokeGetter(ReflectionUtils.java:76) 	at org.apache.maven.surefire.util.ReflectionUtils.invokeGetter(ReflectionUtils.java:70) 	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.getSuites(ProviderFactory.java:145) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.getSuitesIterator(ForkStarter.java:699) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.runSuitesForkPerTestSet(ForkStarter.java:403) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:293) 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:245) 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1194) 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1022) 	at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:868) 	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137) 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208) 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154) 	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146) 	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117) 	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81) 	at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56) 	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128) 	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305) 	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192) 	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105) 	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:954) 	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288) 	at org.apache.maven.cli.MavenCli.main(MavenCli.java:192) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289) 	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229) 	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415) 	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356) ```","closed","3rd-party: Maven Surefire,","trantienduchn","2019-08-21T11:14:10Z","2019-08-28T06:11:08Z"
"","2117","Introduce TestTemplateInvocationContextBuilder","Hello, everyone! I'm just starting to contribute, so if I'm making any mistakes, please tell me how to do it right :)  ## Overview I'm enjoying using TestTemplateInvocationContextProvider in conjuction with @ExtendsWith and @TestTemplate - it's a powerful tool that helps to bring all test invocation configuration in one place, do some fine tuning without using TestBase classes. And it helps to avoid tons of annotations above test methods. All of which greatly increases readability and maintainability of the tests.  ## Proposal Introduce TestTemplateInvocationContextBuilder, which contains following methods:  - withDisplayName(String displayName)  self explanatory  - withDisplayNamePrefix(String displayNamePrefix) - withDisplayNamePostfix(String displayNamePostfix)  this allows grouping of display names which makes them more readable   - addExtension(Extension extension)  adds extension at the end of the extension list, which makes it first or last among others, depending on type  [Docs reference](https://junit.org/junit5/docs/current/user-guide/#extensions-execution-order-wrapping-behavior)  - addExtension(int index, Extension extension)  adds extension at certain place in list of extensions to force certain order of execution  - addParameterResolver(Class parameterType, T value)  syntactic sugar for adding ParameterResolver if test method parameters contains only one parameter with T type  - addParameterResolver(Class parameterType, T value, String parameterName)  syntactic sugar for adding ParameterResolver if test method parameters contains one or more parameters with T type and they need to be distinguished.  - build()  returns TestTemplateInvocationContext with displayName and extensions  ## Deliverables Speeding up of test creation, ease of maintenance, increase in readability","closed","status: stale,","AOreshin","2019-11-27T12:46:38Z","2021-06-19T12:50:15Z"
"","2541","Logs get dumped to console all at once when the execution is over, instead of being printed in real time","Hello,  I'm working on a test automation project using Maven (with Surefire plugin) and JUnit 5. Since I have very long-running UI scripts (up to 20 minutes), I make intensive use of logging to the console. This is crucial to me, at least in the developing phase of each script. However, logs gets dumped all at once at the end of the execution, instead of being printed in real-time. I realize this makes perfect sense in case of parallel execution (to avoid overlapping issues), but I would like a way to disable this when executing in a serial fashion. I've searched both Surefire and JUnit documentations, but I can't seem to find a way. Any help would be appreciated. This is a very simple dummy project to reproduce the issue:  `projectRoot/pom.xml`:  ```xml       4.0.0     org.example     project     1.0              11         11         UTF-8                                                                      org.apache.maven.plugins                     maven-surefire-plugin                     3.0.0-M5                                                                       org.junit.jupiter             junit-jupiter-engine             5.7.0             test                ```  `projectRoot/src/test/java/DummyTest.java`:  ```java import org.junit.jupiter.api.Test;  public class DummyTest {     @Test     public void ConsoleLoggingTest() {         System.out.println(""STARTING TEST..."");         try { Thread.sleep(30000); } catch (Exception ignored) { } //SIMULATE LONG-RUNNING TASK         System.out.println(""TEST IS FINISHED!"");     } } ```  I use to execute tests with the `mvn test` command in my IDE (IntelliJ IDEA). Please note that I used `System.out.println()` for the sake of simplicity, but I get the same behavior using any logging library, like log4j.","closed","3rd-party: Maven Surefire,","PataviniMa","2021-01-26T17:09:24Z","2021-01-27T10:17:41Z"
"","2189","assertThrows should close returned AutoCloseable in case of failing assert","Hello,  I have encountered a subtle problem with the [`assertThrows` API](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html#assertThrows(java.lang.Class,org.junit.jupiter.api.function.Executable)).  The API accepts an `Executable`, which conceptually is a void invocation run internally by JUnit, and an exception of a specified type is expected to be thrown, and thus caught. There is really no need to keep any returned value from the operation encapsulated by the `Executable`, because it is _expected_ to throw.  However, there are times when some attention should be given to a returned value, if the assertion that it throws an exception actually fails, and the `Executable` manages to successfully execute: methods returning `InputStream`, `OutputStream`, and really any instance of `AutoCloseable`.  Say you have a method with the following signature: ```java InputStream getData(); ``` And you are testing an error scenario like this: ```java assertThrows(UnableToGiveDataException.class, () -> getData()); ```  In the case of this test failing (i.e. `getData()` successfully executes with no exception), the returned `InputStream` will not be closed, and this may introduce problems for any remaining tests in a suite.   One solution to this is of course to not use `assertThrows` with methods returning an `AutoCloseable` instance. But this is not evident when one knows and appreciates the `assertThrows`-methods, as there is nothing preventing you from using it, and it is admittedly a bit subtle why one should avoid this. It may not manifest as an actual problem in your particular test suite.  Would it be a viable solution to adapt the API to offer overloads of `assertThrows` which accept for instance a [`ThrowingSupplier`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/function/ThrowingSupplier.html), so JUnit can actually access the returned value in the case of a failing assert? JUnit could then inspect the returned value to see if it is an `AutoCloseable`, and in that case invoke `close()`, and then finally throw the appropriate AssertionError because the expected exception was not thrown. This should also enable generating more informative test failure messages, as `assertThrows(..)` can then fail with information about the value which was returned instead of an expected exception being thrown.  What are your thought on this? 🙂","closed","component: Jupiter,","runeflobakk","2020-02-19T16:47:41Z","2020-02-21T20:03:31Z"
"","2846","How to define AfterTestExecutionCallback in `pom.xml`","Hello,  Can we define AfterTestExecutionCallback class in pom.xml using the surefire-plugin ?   Roy","closed","3rd-party: Maven Surefire,","roydekleijn","2022-03-07T11:48:42Z","2022-03-07T13:14:20Z"
"","2221","Missing test launcher?","Hello! i am getting similar error, when i am trying to execute jUnit test from code. ``` ERROR - llij.ide.plugins.PluginManager - Cannot create Launcher without at least one TestEngine; consider adding an engine implementation JAR to the classpath  org.junit.platform.commons.PreconditionViolationException: Cannot create Launcher without at least one TestEngine; consider adding an engine implementation JAR to the classpath 	at testController.MainTestController.runAllTests(MainTestController.java:34) 	at pluginCommunicationHandler.RunTestButton.actionPerformed(RunTestButton.java:14) 	at com.intellij.openapi.actionSystem.ex.ActionUtil$1.run(ActionUtil.java:266) 	at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(ActionUtil.java:283) 	at com.intellij.openapi.actionSystem.impl.ActionMenuItem$ActionTransmitter.lambda$actionPerformed$0(ActionMenuItem.java:294) 	at com.intellij.openapi.wm.impl.FocusManagerImpl.runOnOwnContext(FocusManagerImpl.java:263) 	at com.intellij.openapi.wm.impl.IdeFocusManagerImpl.runOnOwnContext(IdeFocusManagerImpl.java:77) 	at com.intellij.openapi.actionSystem.impl.ActionMenuItem$ActionTransmitter.actionPerformed(ActionMenuItem.java:284) 	at java.desktop/javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:1967) 	at com.intellij.openapi.actionSystem.impl.ActionMenuItem.lambda$fireActionPerformed$0(ActionMenuItem.java:112) 	at com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(TransactionGuardImpl.java:83) 	at com.intellij.openapi.application.TransactionGuardImpl.lambda$submitTransaction$1(TransactionGuardImpl.java:107) 	at com.intellij.openapi.application.TransactionGuardImpl.submitTransaction(TransactionGuardImpl.java:116) 	at com.intellij.openapi.application.TransactionGuard.submitTransaction(TransactionGuard.java:121) 	at com.intellij.openapi.actionSystem.impl.ActionMenuItem.fireActionPerformed(ActionMenuItem.java:112) 	at java.desktop/javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2308) 	at java.desktop/javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:405) 	at java.desktop/javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:401) 	at java.desktop/javax.swing.AbstractButton.doClick(AbstractButton.java:369) 	at java.desktop/com.apple.laf.ScreenMenuItemCheckbox.itemStateChanged(ScreenMenuItemCheckbox.java:198) 	at java.desktop/java.awt.CheckboxMenuItem.processItemEvent(CheckboxMenuItem.java:396) 	at java.desktop/java.awt.CheckboxMenuItem.processEvent(CheckboxMenuItem.java:364) 	at java.desktop/java.awt.MenuComponent.dispatchEventImpl(MenuComponent.java:375) 	at java.desktop/java.awt.MenuComponent.dispatchEvent(MenuComponent.java:363) 	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:781) 	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:727) 	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:721) 	at java.base/java.security.AccessController.doPrivileged(Native Method) 	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:85) 	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:95) 	at java.desktop/java.awt.EventQueue$5.run(EventQueue.java:751) 	at java.desktop/java.awt.EventQueue$5.run(EventQueue.java:749) 	at java.base/java.security.AccessController.doPrivileged(Native Method) 	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:85) 	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:748) 	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:906) 	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:779) 	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$8(IdeEventQueue.java:422) 	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:698) 	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:421) 	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203) 	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124) 	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113) 	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109) 	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101) 	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90) ``` Can someone help me?  Here is my gradle file ``` plugins {     id 'java'     id 'org.jetbrains.intellij' version '0.4.16' }  group 'org.example' version '1.0-SNAPSHOT'  sourceCompatibility = 1.8  repositories {     mavenCentral() }  dependencies {     // https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher     compile group: 'org.junit.platform', name: 'junit-platform-launcher', version: '1.6.0'     // https://mvnrepository.com/artifact/org.junit.platform/junit-platform-runner     compile group: 'org.junit.platform', name: 'junit-platform-runner', version: '1.6.0'     // https://mvnrepository.com/artifact/org.junit.platform/junit-platform-engine     compile group: 'org.junit.platform', name: 'junit-platform-engine', version: '1.6.0'     // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api     compile group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.6.0'     // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine     compile group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.6.0' }     test {         useJUnitPlatform()     }    // See https://github.com/JetBrains/gradle-intellij-plugin/ intellij {     version '2019.3' } patchPluginXml {     changeNotes """"""       Add change notes here.       most HTML tags may be used"""""" } ``` Executing code ```         LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()                 .selectors(                         //selectPackage(""test""),                         //selectClass(FirstUnitTest.class),                         selectMethod(UnitTests.class,""whenSomething_thenSomething"")                 )                 .build();         Launcher launcher = LauncherFactory.create(); //MainTestController.java:34 her exception occur         SummaryGeneratingListener listener = new SummaryGeneratingListener();         launcher.registerTestExecutionListeners(listener);         launcher.execute(request);         TestExecutionSummary summary = listener.getSummary();         long result = summary.getTestsSucceededCount();         System.out.println(result); ```","closed","","williambrach","2020-03-19T17:46:37Z","2020-03-31T15:08:54Z"
"","2826","Improve documentation about registering a `LauncherSessionListener`","Hello JUnit team.  Thanks for your work.  ## Steps to reproduce  * Clone the following repository: https://github.com/jabby/junit5-launcher-session-listener-problem * run `mvn test` * check the following output  ``` ~/git/github/junit5-launcher-session-listener-problem   main  mvn test [INFO] Scanning for projects... [INFO]  [INFO] -------< fr.jabbytechs:junit-launcher-session-listener-problem >-------- [INFO] Building junit-launcher-session-listener-problem 0.1.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO]  [INFO] --- maven-enforcer-plugin:3.0.0-M2:enforce (enforce-bytecode-version) @ junit-launcher-session-listener-problem --- [INFO] Adding ignore: module-info [INFO] Adding ignore: module-info [INFO]  [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ junit-launcher-session-listener-problem --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /home/jabberwock/git/github/junit5-launcher-session-listener-problem/src/main/resources [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ junit-launcher-session-listener-problem --- [INFO] No sources to compile [INFO]  [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ junit-launcher-session-listener-problem --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] Copying 1 resource [INFO]  [INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ junit-launcher-session-listener-problem --- [INFO] Nothing to compile - all classes are up to date [INFO]  [INFO] --- maven-surefire-plugin:3.0.0-M5:test (default-test) @ junit-launcher-session-listener-problem --- [INFO]  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- launcherSessionOpened launcherSessionClosed launcherSessionOpened [INFO] Running fr.jabbytechs.ExampleTest testName [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.033 s - in fr.jabbytechs.ExampleTest launcherSessionClosed [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time:  2.088 s [INFO] Finished at: 2022-02-07T16:48:00+01:00 [INFO] ------------------------------------------------------------------------ ```  `SetupTeardownLauncherSessionListener` is execute twice.  As a non-native english speaker, I think the [documentation here](https://junit.org/junit5/docs/current/user-guide/#launcher-api-launcher-session-listeners-custom) is not clear.  In fact I thought this morning that there is a bug in JUnit. After reading more carefully the documentation and especially the sample code, I realize it's not a bug.  For me, the following sentence:   > Registered implementations of [LauncherSessionListener](https://junit.org/junit5/docs/current/api/org.junit.platform.launcher/org/junit/platform/launcher/LauncherSessionListener.html) are notified when a [LauncherSession](https://junit.org/junit5/docs/current/api/org.junit.platform.launcher/org/junit/platform/launcher/LauncherSession.html) is opened (before a [Launcher](https://junit.org/junit5/docs/current/api/org.junit.platform.launcher/org/junit/platform/launcher/Launcher.html) first discovers and executes tests) and closed (when no more tests will be discovered or executed).  means the code will be executed as follow:   - LauncherSessionListener#launcherSessionOpened - start discovering test - end discovering test - start running tests - stop running tests - LauncherSessionListener#launcherSessionClosed  but it seams that the code is actually executed like this:  - LauncherSessionListener#launcherSessionOpened - start discovering test - end discovering test - LauncherSessionListener#launcherSessionClosed - LauncherSessionListener#launcherSessionOpened - start running tests - stop running tests - LauncherSessionListener#launcherSessionClosed  Moreover, as I said the current behavior is clearer when you read correctly / understand the sample code.  My suggestion is to improve current documentation.  ## Context   - Used versions (Jupiter/Vintage/Platform): `5.8.2`  - Build Tool/IDE: `Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)`  Thanks for your time. Have a nice day.","closed","component: Platform,","jabby","2022-02-07T16:06:02Z","2022-06-19T13:58:56Z"
"","2775","apiguardian-api version mismatch between source code and published POM","Hello friends, I found something interesting that I couldn't find an explanation for. I wish someone more experienced with the code would take a look at it and try to figure out why.  The POM on Central for junit-jupiter-api:5.7.2 depends on apiguardian-api:1.1.0 while the source code on tag r5.7.2 declares version 1.1.1.  https://search.maven.org/artifact/org.junit.jupiter/junit-jupiter-api/5.7.2/jar https://github.com/junit-team/junit5/blob/r5.7.2/gradle/libs.versions.toml  Maybe the version gets overridden by some other transitive dependency? If the version number declared in libs.version would be important, it might be a problem that the published POM doesn't follow it.  Thank you for your attention to this issue and for your other contributions to this extremely useful project.","closed","theme: build,","e-ts","2021-11-09T07:24:04Z","2021-11-09T15:45:18Z"
"","2111","JUnit working with Gradle and Java Modules","Hello everyone,  I'm dealing with the following issue: I have got a JavaFX JDK 11 project with two modules: main and test. Main holds all the source code and the source code resources. And test holds all the JUnit tests and the related resources. Everything used to work fine before when I ran ""gradlew test"" with the useJUnitPlatform() command. But as soon as I added a module-info to my main module things started going downhill.  For a start, I would like to point out that adding this module-info.java file is a required part of building my application, so the solution of ""just remove it!"" would work to get the tests back working, but sadly isn't possible.  Following days of research I am not able to solve the issue myself and I have been stuck on the same set of errors for days:    > C:\...\src\test\java\module-info.java:1: error: module name FP.EDM.test does not match expected name FP.EDM.main open module FP.EDM.test {      ^ C:\...\src\test\java\module-info.java:3: error: cyclic dependence involving FP.EDM.main     requires FP.EDM.main;                    ^ error: cannot access module-info   cannot resolve modules warning: module name in --add-reads option not found: FP.EDM.main 3 errors 1 warning   I have got the following module-info.java file in my main module:  ``` open module FP.EDM.main {     //Exposes the main class for distribution     exports edm;      //Exposes all tested classes to the test module     exports edm.utilities;     exports edm.model.enumerations;     exports edm.writers;     exports edm.model;     exports edm.handlers;     exports edm.readers.importFileReaders;     exports edm.model.interfaces;      //JavaFX requirements     requires javafx.graphics;     requires javafx.controls;     requires javafx.fxml;      //Required for getting desktop metadata     requires java.desktop;      //Reading JSON files     requires json;      //Reading excel files     requires poi;     requires poi.ooxml;     requires xmlbeans;     requires jdk.charsets;      //Ribbon     requires fxribbon;      //Reading CSV files     requires commons.csv;      //Required for doing automatic timestamp calculations     requires org.apache.commons.lang3; } ```  And the module-info.java below is part of the test module:  ```  open module FP.EDM.test {     requires org.junit.jupiter.api;     requires FP.EDM.main; } ```   The thing of which I believe causes the issue is the fact that useJUnitPlatform uses the main module whenever I print the module above the test command. So I have been looking for a way to set the module to the test module, but have been unable to find such a thing. That's the reason why I believe the issue belongs here on GitHub rather than any other help website.  Please feel free to request additional information, for a start I have also included my build.gradle below.  ``` plugins {     id 'application'     id 'org.openjfx.javafxplugin' version '0.0.8'     id 'org.beryx.jlink' version '2.16.4' }  version '1.0.0' sourceCompatibility = 11  repositories {     maven { url ""https://dl.bintray.com/dukke/maven"" }     maven { url ""https://repo.maven.apache.org/maven2/"" } }  dependencies {     testCompile group: 'junit', name: 'junit', version: '4.12'     testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.6.0-M1'     testRuntime('org.junit.jupiter:junit-jupiter-engine:5.4.2')     compile group: 'org.apache.commons', name: 'commons-collections4', version: '4.0'     compile 'com.pixelduke:fxribbon:1.2.1'     compile group: 'org.json', name: 'json', version: '20160810'     compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.9'     compile group: 'org.apache.commons', name: 'commons-collections4', version: '4.4'     compile group: 'org.apache.commons', name: 'commons-compress', version: '1.19'     compile group: 'org.apache.commons', name: 'commons-csv', version: '1.7'     compile group: 'org.apache.poi', name: 'poi', version: '4.1.1'     compile group: 'org.apache.poi', name: 'poi-ooxml', version: '4.1.1' }  jlink {     mergedModule {         requires ""java.xml""         requires ""javafx.controls""     }     addExtraDependencies(""javafx"")     launcher {         name = 'gPROMS EDM'     } }  tasks.jlink.doLast {     copy {         from('src/main/resources')         into(""$buildDir/image/bin/src/main/resources"")     } }  test {     println(moduleName)     useJUnit() }  javafx {     version = ""11.0.2""     modules = [ 'javafx.controls', 'javafx.fxml' ] }  application {     mainClassName = 'FP.EDM.main/edm.Main' } ```","closed","3rd-party: Gradle,","SSchepers","2019-11-22T14:07:03Z","2019-11-25T15:47:26Z"
"","2225","Temporary Folder not being deleted","Hello I'm not sure if this is a bug in JUnit or no, so feel to correct me if I'm wrong  I'm using a temporary folder in my unit test using the @Rule of JUnit. The folder is not being deleted after the tests finish  Java version : 1.8  JUnit version: 4.12  Os windows 10  I'm creating a file.csv under a temp folder in order to edit it using CSVPrinter from org.apache.commons  ``` public class MyService {  public void createCSVFile(String basePath) {         try (FileWriter out = new FileWriter(format(""%s/file.csv"", basePath));              CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT.withHeader(HEADERS))) {             //printer.PrintRecord(args);         } catch (IOException e) {             log.error(""Failed to create file.csv under "" + basePath, e);         }     } } ```  The test:  ```     @Rule     public TemporaryFolder folder = new TemporaryFolder();     private String folderPath;     private MyService myService;      @Before     public void setup() throws IOException {         folder.newFile(""file.csv"");         folderPath = folder.getRoot().getPath();     }       @Test     public void testing_myService() {         myService.createCSVFile(folderPath);         //Assert      } ```  When i open the folder ex: *C:\Users\me\AppData\Local\Temp\junit2290989758736528709* I can still see the file.csv as it was not deleted  I tried to migrate the create of the file to become in the tests. It did not fix it ```     @Test     public void testing_myService() {         folder.newFile(""file.csv"");         myService.createCSVFile(folder.getRoot().getPath());         //Assert      }  ```  I added an @After method to delete the folder  ```     @After     public void cleanup() throws IOException {         //Tried several ways to delete the folder and file as well         //FileUtils.forceDelete(folder.getRoot().getAbsoluteFile());         //folder.getRoot().delete();         //FileUtils.deleteDirectory(folder.getRoot());         //new File(folderPath +""/file.csv"").delete();          //All methods did not delete neither the direcotry (with exception can't delete file.csv) nor deleted the file.csv     } ```  I also tried to call the `folder.create();` and `folder.delete();` myself without using the @Rule But the folder wasn't deleted as well  The file.csv is marked as **read-only** when viewing the properties on windows  This could be the reason, if so how do I solve it?  any other reason for this behavior?  can you please advise","closed","","NedK123","2020-03-25T20:42:01Z","2020-03-25T21:41:44Z"
"","2911","Support instance fields as source for `@ValueSource`","Having following code:  ```java @AllArgsConstructor class Car {   int year;   String model; }  class CarTest {   Car carOne = new Car(2021, ""X3"");   Car carTwo = new Car(2005, ""M5"");    @ParameterizedTest   @ValueSource   void testCar(Car car) {     System.out.println(car.model);   } } ```  I would like to pass into `testCar()` method objects `carOne` and `carTwo` using `@ValueSource`.  Currently, there is no such option.  I have to create separate method, which returns `Stream` with `carOne` and `carTwo`.  It would be great to have an option to specify objects using `@ValueSource`, without creating additional method, something like this: `@ValueSource(objects = {carOne,carTwo})`.","closed","component: Jupiter,","arturmkr","2022-05-09T12:51:17Z","2022-05-20T10:44:35Z"
"","2002","Improve @TestInstance documentation regarding @Nested test classes","Having `@TestInstance` on a toplevel test class changes the lifecycle of this class.   My simple assumption would be, that the lifecycle of all nested `@Nested` test classes are changed accordingly.  This is not the case, they also need to be configured.  While I find this behaviour irritating and would expect all classes down the hierarchy to share the lifecycle of the container class, I also can life with configuring it.  It would be important to document this however.   Sometimes one notices, sometimes don't.   Documentation can be in form of docs (apparently), but a warning log maybe helpful, too.  On a side note, current docs state:  > Used to configure the test instance lifecycle for the annotated test class. Such annotations are inherited.  Now, ""inherited"" of course refers to annotation inheritance with `@Inherited` which only applies to  real inheritance, but to a causal reader it could seem that an outer class actually inherits its lifecycle.","closed","status: stale,","michael-simons","2019-09-05T14:09:31Z","2022-07-11T20:21:38Z"
"","2818","Parametrized test with Methodsource using arguments(Named.Of) not extracting payload","Greetings,  Today i wanted to name the parameterized test using the Named.of taken from [https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-display-names](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-display-names)  Running example in documentation in JUnit 5.8.2 or even 5.8.0 where it was introduced.  ```java         @DisplayName(""A parameterized test with named arguments"") 	@ParameterizedTest(name = ""{index}: {0}"") 	@MethodSource(""namedArguments"") 	void testWithNamedArguments(File file) { 	}  	static Stream namedArguments() { 		return Stream.of(arguments(Named.of(""An important file"", new File(""path1""))), 				arguments(Named.of(""Another file"", new File(""path2"")))); 	} ```  When running the test case the following error is thrown:    ``` org.junit.jupiter.api.extension.ParameterResolutionException: Error converting parameter at index 0: No implicit conversion to convert object of type org.junit.jupiter.api.Named$1 to type java.io.File 	at org.junit.jupiter.params.ParameterizedTestMethodContext.parameterResolutionException(ParameterizedTestMethodContext.java:273) 	at org.junit.jupiter.params.ParameterizedTestMethodContext.access$200(ParameterizedTestMethodContext.java:44) 	at org.junit.jupiter.params.ParameterizedTestMethodContext$Converter.resolve(ParameterizedTestMethodContext.java:238) 	at org.junit.jupiter.params.ParameterizedTestMethodContext.resolve(ParameterizedTestMethodContext.java:165) 	at org.junit.jupiter.params.ParameterizedTestParameterResolver.resolveParameter(ParameterizedTestParameterResolver.java:64) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameter(ExecutableInvoker.java:216) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:183) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.resolveParameters(ExecutableInvoker.java:144) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:96) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:139) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.lambda$execute$2(TestTemplateTestDescriptor.java:107) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$11$1.accept(ReferencePipeline.java:373) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:107) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:42) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) Caused by: org.junit.jupiter.params.converter.ArgumentConversionException: No implicit conversion to convert object of type org.junit.jupiter.api.Named$1 to type java.io.File 	at org.junit.jupiter.params.converter.DefaultArgumentConverter.convertToTargetType(DefaultArgumentConverter.java:127) 	at org.junit.jupiter.params.converter.DefaultArgumentConverter.convert(DefaultArgumentConverter.java:104) 	at org.junit.jupiter.params.converter.SimpleArgumentConverter.convert(SimpleArgumentConverter.java:30) 	at org.junit.jupiter.params.ParameterizedTestMethodContext$Converter.resolve(ParameterizedTestMethodContext.java:235) 	... 114 more ```   Changing the test methjod to accept `Named` as input works as expected since the type is the same.  ```java  	@DisplayName(""A parameterized test with named arguments"") 	@ParameterizedTest(name = ""{index}: {0}"") 	@MethodSource(""namedArguments"") 	void testWithNamedArguments(Named namedObj) { 		File file = (File) namedObj.getPayload(); 		System.out.print(file.getName()); 	}  	static Stream namedArguments() { 		return Stream.of(arguments(Named.of(""An important file"", new File(""path1""))), 				arguments(Named.of(""Another file"", new File(""path2"")))); 	}  ```  The following POM dependencies are used:  ```xml    	    org.junit.jupiter 	    junit-jupiter 	     5.8.2 	    test 	             org.junit.jupiter         junit-jupiter-engine          5.8.2         test      	 	 	    uk.org.webcompere 	    system-stubs-jupiter 	    2.0.0 	    test 	 	 	 	 	    org.junit.platform 	    junit-platform-runner 	    1.8.2 	    test 	 	 	 	 	 	    org.junit.jupiter 	    junit-jupiter-api 	    5.8.2 	    test 	 	 	 	 	    org.junit.jupiter 	    junit-jupiter-params 	    5.8.2 	    test 	 	 	 	 	 	    org.junit.platform 	    junit-platform-suite-engine 	    1.8.2 	 	 	 	 	    org.junit.platform 	    junit-platform-suite-api 	    1.8.2 	    test 	 	 	 	 	    org.junit.platform 	    junit-platform-suite-commons 	    1.8.2 	    runtime 	 	 	 	 	    org.junit.platform 	    junit-platform-commons 	    1.8.2 	 	 	 	 	    org.junit.platform 	    junit-platform-launcher 	    1.8.2 	    test 	 	 	 	 	    org.junit.platform 	    junit-platform-engine 	    1.8.2 	    test 	 	 	 	 	 	 	    org.junit.platform 	    junit-platform-surefire-provider 	    1.3.2 	    test 	  	 	 	    org.junit.platform 	    junit-platform-console 	    1.8.2 	    test 	        org.junit.platform     junit-platform-reporting     1.8.2            org.apache.maven.plugins         maven-surefire-plugin         3.0.0-M5                    ${surefire.skipTests}                        ${surefire.include}                                   ${surefire.exclude}                      ${surefire.forkCount}           true           ${surefire.groups}           ${surefire.excludedGroups}                        ${project.build.directory}/surefire-fork/${surefire.forkNumber}/                                                      ```  - Build Tool used: Eclipse  - Version: 2020-09 (4.17.0) - Build id: 20200910-1200  Please let me know if I missed some information.   Not sure if I am missing a step or the documentation is on the topic is simply not correct.  Kind regards,","closed","3rd-party: Eclipse,","stephan-bosch","2022-02-03T10:53:28Z","2022-02-04T17:02:39Z"
"","2527","@CsvSource fails when values start with the number sign (#)","Greetings,  I'm using **junit-jupiter-api** and **junit-jupiter-params** version **5.7.0**. I was developing a method to parse hexadecimal color strings, such as #BFFF00, into their red/green/blue components. I figured the `@CsvSource` would be a great way to do this:  ```java   @ParameterizedTest   @CsvSource({       ""#ff0000,1,0,0"",       ""#00ff00,0,1,0"",       ""#0000ff,0,0,1""   })   void hexToColor(final String input, final float expectedRed, final float expectedGreen, final float expectedBlue) {     // assert stuff   } ```  As it stands, however, even the stub test above just crashes before it is ever executed, printing out the error message **org.junit.platform.commons.PreconditionViolationException: Line at index 0 contains invalid CSV: ""#ff0000,1,0,0""**. I dug into the matter and found out that the # sign is considered a comment character by default by the underlying `com.univocity.parsers.csv.CsvParser` CSV parser.   Now, in this case when I'm just supplying a static set of strings **I would expect that all of my lines were parsed**. It is a different business with the `@CsvFileParser` annotation, but that is out of scope for the issue at hand. The comment character used by the underlying library could be changed, but there is no use for that feature with the `@CsvSource` annotation and the `CsvArgumentsProvider`, as it just throws an error in case it encounters a commented-out line anyway.  I have prepared a change that would enable the usage of the number sign in the context of the `@CsvSource` annotation, while preserving the existing functionality of ignoring commented-out lines in the context of a `@CsvFileSource`. This is not even a breaking change but just a bug fix, as nobody could have possibly used the number sign with the `@CsvSource` before.","closed","status: superseded,","ZeroOne3010","2021-01-13T13:25:46Z","2021-01-13T14:46:22Z"
"","2919","Failed assumption in @BeforeEach gets suppressed by exception in @AfterEach","Greetings! I tried to conditionally suspend a set of tests by adding a failing assumption into a method annotated with the `@BeforeEach` annotation, but much to my surprise the test set failed anyway. Taking a closer look revealed the it was due to an `@AfterEach` annotated method throwing an exception and suppressing the `TestAbortedException` thrown by `@BeforeEach`.   ## Steps to reproduce  Please try the following minimal test class:  ```java import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.fail; import static org.junit.jupiter.api.Assumptions.assumeFalse;  class AssumptionTest {      private List strings;      @BeforeEach     void setup() {         assumeFalse(strings == null);     }      @AfterEach     void teardown() {         System.out.println(""There were this many strings: "" + strings.size());     }      @Test     void test() {         // This test correctly does not get executed but is still marked as failed due to an exception thrown in the `teardown` method.         fail();     } } ```  In the end the `test` is marked as failed because the `teardown` method throws a `NullPointerException`, and the stack trace (wildly cut here) says the `TestAbortedException` is ""Suppressed"":  ``` java.lang.NullPointerException: Cannot invoke ""java.util.List.size()"" because ""this.strings"" is null 	at AssumptionTest.teardown(AssumptionTest.java:19) 	Suppressed: org.opentest4j.TestAbortedException: Assumption failed: assumption is not false ```  ## Expected behavior  I would expect that in case a `@BeforeEach` method aborts, an `@AfterEach` annotated method would not be executed. After all, after _what_ would it run, when there was no test executed? It seems like it isn't currently true to its name.  Alternatively, I would expect the exceptions to be other way around: there could have been a `TestAbortedException` with a suppressed `NullPointerException`.  Third alternative would be to allow for some configurability to `@AfterEach` methods, something like `@AfterEach(runIfBeforeMethodFailsOrAborts=false)`.  The fourth option, of course, is that the current behavior is due to deliberate and careful consideration and must not be changed, in which case I just need to be educated and this issue closed. :)   ## Other considerations  If this issue causes any action to be taken in the code base, I would expect `@BeforeAll` and `@AfterAll` methods would need to be reworked to conform to whatever was decided for `@BeforeEach` and `@AfterEach`, including a situation where a `@BeforeEach` would fail and could cause an `@AfterAll` method to not get executed.  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit Jupiter API 5.8.2  - Build Tool/IDE: IntelliJ IDEA 2022.1.1 (Ultimate Edition) Build #IU-221.5591.52, built on May 10, 2022","closed","component: Jupiter,","ZeroOne3010","2022-05-19T08:42:13Z","2022-05-20T08:54:33Z"
"","2621","KingShaggy listed as author of junit-jupiter BOM in GitHub Dependency graph","Good afternoon,  I am working on a group project and noticed under the dependency graph that [KingShaggy](https://github.com/KingShaggy) is the author for **org.junit.jupiter:junit-jupiter**. My question is, is this normal? I am viewing other dependencies and noticed that they have their respective author teams. This seems misleading.  ![2021-05-18 15_07_43-](https://user-images.githubusercontent.com/34862811/118666757-51a69000-b7eb-11eb-8f53-dad21b806fef.png)","closed","","alexsikorski","2021-05-18T14:12:51Z","2021-05-18T17:59:03Z"
"","2601","NPE from RunnerTestDescriptor.lambda$logIncompleteFiltering$2","Given `pom.xml`  ```xml      4.0.0              org.jenkins-ci.plugins         plugin         4.18                   demo     1.0-SNAPSHOT     hpi              2.277.3         8         5.7.1                                                 org.junit.jupiter                 junit-jupiter-api                 ${junit5.version}                 test                                                                                 org.apache.maven.plugins                 maven-surefire-plugin                                                               org.junit.vintage                         junit-vintage-engine                         ${junit5.version}                                                                                            repo.jenkins-ci.org             https://repo.jenkins-ci.org/public/                                         repo.jenkins-ci.org             https://repo.jenkins-ci.org/public/                ```  and `src/main/resources/index.jelly`  ```xml        XXX  ```  then  ```bash mvn -f /tmp/junit-npe clean verify -e ```  passes  ``` [INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.021 s - in InjectedTest ```  yet  ```bash mvn -f /tmp/junit-npe clean verify -e -Dtest=InjectedTest ```  fails with  ``` Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M4:test failed: java.lang.NullPointerException     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:148)     at … Caused by: org.apache.maven.surefire.util.SurefireReflectionException: java.lang.NullPointerException     at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray (ReflectionUtils.java:177)     at … Caused by: java.lang.NullPointerException     at org.junit.vintage.engine.descriptor.RunnerTestDescriptor.lambda$logIncompleteFiltering$2 (RunnerTestDescriptor.java:118)     at org.junit.platform.commons.logging.LoggerFactory$DelegatingLogger.nullSafeGet (LoggerFactory.java:182)     at org.junit.platform.commons.logging.LoggerFactory$DelegatingLogger.log (LoggerFactory.java:146)     at org.junit.platform.commons.logging.LoggerFactory$DelegatingLogger.warn (LoggerFactory.java:95)     at org.junit.vintage.engine.descriptor.RunnerTestDescriptor.logIncompleteFiltering (RunnerTestDescriptor.java:117)     at org.junit.vintage.engine.descriptor.RunnerTestDescriptor.prune (RunnerTestDescriptor.java:111)     at org.junit.platform.engine.TestDescriptor.accept (TestDescriptor.java:249)     at org.junit.platform.engine.TestDescriptor.lambda$accept$0 (TestDescriptor.java:251)     at java.lang.Iterable.forEach (Iterable.java:75)     at org.junit.platform.engine.TestDescriptor.accept (TestDescriptor.java:251)     at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.lambda$acceptInAllTestEngines$8 (EngineDiscoveryOrchestrator.java:167)     at java.util.LinkedHashMap$LinkedValues.forEach (LinkedHashMap.java:608)     at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.acceptInAllTestEngines (EngineDiscoveryOrchestrator.java:167)     at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.prune (EngineDiscoveryOrchestrator.java:158)     at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover (EngineDiscoveryOrchestrator.java:93)     at org.junit.platform.launcher.core.DefaultLauncher.discover (DefaultLauncher.java:92)     at org.junit.platform.launcher.core.DefaultLauncher.discover (DefaultLauncher.java:67)     at org.apache.maven.surefire.junitplatform.TestPlanScannerFilter.accept (TestPlanScannerFilter.java:56)     at org.apache.maven.surefire.util.DefaultScanResult.applyFilter (DefaultScanResult.java:102)     at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.scanClasspath (JUnitPlatformProvider.java:146)     at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.getSuites (JUnitPlatformProvider.java:104)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray (ReflectionUtils.java:169)     at … ```  Seems to be some sort of missing null check in https://github.com/junit-team/junit5/blob/ddaec1bb07b6a3ed3afd318bc9412d9e848b499f/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java#L117-L119  The situation here is admittedly unusual: a JUnit 3 `target/generated-test-sources/injected/InjectedTest.java` created by a custom Maven plugin. Normally works fine in Surefire with JUnit 4 in the classpath, but seems to confuse the JUnit 5 vintage engine.","closed","theme: discovery,","jglick","2021-04-23T20:15:42Z","2021-04-24T14:28:05Z"
"","2655","DiscoverySelectors#selectPackage does not select packages from JAR","Fundamentally I am facing the same issue : https://github.com/junit-team/junit5/issues/1493  Thought I do not know if the underlying cause is same. I checked that issue and also ensured that my jdk is above 141. But still Junit is unable to resolve the package selector.  With package, I get 'containsTests' as false. ![image](https://user-images.githubusercontent.com/3054787/123893652-6d6c8c80-d97a-11eb-8330-f08327811cb8.png)  Whereas when I give a class in the same package, it works just fine :  ![image](https://user-images.githubusercontent.com/3054787/123893831-c2a89e00-d97a-11eb-83ba-e8a951560784.png)  ![image](https://user-images.githubusercontent.com/3054787/123894049-216e1780-d97b-11eb-8ff6-23d5f81b3145.png) In the above screenshot you can see that the testing class is part of the same package mentioned.  ## Context I am using this Junit dependency jar : https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.8.0-M1/junit-platform-console-standalone-1.8.0-M1.jar  OS :  centos-release-7-7.1908.0.el7.centos.x86_64 jdk :  openjdk version ""1.8.0_232"" OpenJDK Runtime Environment (build 1.8.0_232-b09) OpenJDK 64-Bit Server VM (build 25.232-b09, mixed mode)  ## Deliverables  What is the recommended way to tackle this? Should we be providing all the list of testing class names?","closed","status: waiting-for-feedback,","umapriyadarsi","2021-06-30T02:49:13Z","2021-07-02T05:25:52Z"
"","2547","API Guardian should be optionally imported in OSGi metadata","From: https://github.com/junit-team/junit5/pull/2095#pullrequestreview-314557992:  > 2\. API guardian must not be imported (as previously discussed in #1353).  From #1353:  > > As https://github.com/apiguardian-team/apiguardian is also a compile-time dependency, does it also be OSGi-fied? >  > No, that should not be necessary since it's not a runtime dependency.  My question: if API guardian is not intended to be a runtime dependency, then why is it defined with `RUNTIME` retention? I feel that if it has runtime retention, users would be entitled to expect it to be available at runtime.  Therefore, I feel that for consistency reasons, we should do one of the following: * either API Guardian should be osgi-ified and it should be imported by bundles that use it (can be an optional import as the bundle will run without it), or * we should consider changing the retention of `@API` to `CLASS`.  Thoughts?","closed","component: Vintage,","kriegfrj","2021-02-08T02:58:17Z","2021-06-23T05:58:12Z"
"","2148","Difference between ""Jupiter 5.5.2"" and ""Vintage 5.5.2""  ??","Found here, what's the difference? -> https://junit.org/junit5/  Thx for feedback.  Regards, Jan","closed","type: question,","jayjupdhig","2020-01-14T12:10:40Z","2020-01-14T13:41:34Z"
"","2967","The class org.junit.jupiter.api.AssertionUtils and its methods should be public","For our own purposes, we have implemented additional assertion methods (`assert...(...)`) in a test utility class. Motivated by reusing existing functionality, this class makes use of the static methods of  `org.junit.jupiter.api.AssertionUtils`; mostly for throwing assertion errors and for formatting error messages. `AssertionUtils` and most of its methods, however, are package-protected. In order to make them visible to our class, we have put it in the same package `org.junit.jupiter.api`. Now that we are using Java's module system, we can no longer proceed this way since Java's module system does not allow to have the same package in more than one module. Therefore I would like to propose to make `org.junit.jupiter.api.AssertionUtils` public as well as all its methods that are currently package-protected.  Note that there are a couple of other utility classes in `org.junit.platform.commons.util` that are already public; though `org.junit.jupiter.api.AssertionUtils` is in `junit-jupiter-api` while `org.junit.platform.commons.util` is in `junit-platform-commons`. I'm not necessarily proposing to also relocate `AssertionUtils` into `junit-platform-commons`: But if that makes sense, it seems better. `junit-platform-commons` is already a compile dependency of `junit-jupiter-api`.  ## Deliverables  - [ ] Pull request?","closed","component: Jupiter,","twwwt","2022-07-06T06:54:04Z","2022-07-17T16:28:04Z"
"","1978","Move LegacyReportingUtils to junit-platform-reporting","For historical reasons, `org.junit.platform.launcher.listeners.LegacyReportingUtils` is really in the wrong package and in the wrong module. Its purpose is reporting related, not launching related.  Proposal:  1. Copy it to `org.junit.platform.reporting.legacy` package in `junit-platform-reporting` module. 2. Deprecate the version in `junit-platform-launcher` with appropriate commentary, for future removal.","closed","theme: reporting,","kriegfrj","2019-08-12T12:02:36Z","2019-12-05T17:16:55Z"
"","2473","Add overloads for all methods in EventConditions that take Condition","For consistency with `container(Condition)` we should add `test(Condition)`, `nestedContainer(Condition)` etc. to allow use cases such as `test(displayName(""foo""))`.  ## Deliverables  - [x] Add the overloads","closed","component: Test Kit,","marcphilipp","2020-11-13T12:10:05Z","2020-11-20T16:10:10Z"
"","2456","Add @FieldSource for @ParameterizedTest","For @ParameterizedTest we can use @MethodSource. Consider the following example: ```  @TestInstance(TestInstance.Lifecycle.PER_CLASS) public class Test {           private List sources;          @BeforeAll     public void prepareSources() {         //adding values to sources     }         @ParameterizedTest     @MethodSource(""provideSources"")     public void testIt(String str) {         //....     }          public List provideSources() {         return sources;     } } ```  So, maybe we should add @FieldSource that will allow to have a reference to field?  ``` @TestInstance(TestInstance.Lifecycle.PER_CLASS) public class Test {           private List sources;          @BeforeAll     public void prepareSources() {         //adding values to sources     }         @ParameterizedTest     @FieldSource(""sources"")     public void testIt(String str) {         //....     } } ```","closed","type: new feature,","PashaTurok","2020-10-21T17:48:04Z","2020-10-21T17:55:00Z"
"","2891","Ask IntelliJ to update `@MethodSource` support","Following #2191, we should ask IntelliJ to modify its support for `@MethodSource`.  The following example raises a warning: `Method source 'factoryMethod' should have no parameters`. This should no longer be the case, since we now support factory methods with parameters.  ```java @ParameterizedTest @MethodSource(""factoryMethod"") void test(String argument) {     // ... }  static Stream factoryMethod(int parameter) {     return Stream.of(); } ```  ## Deliverables  - [x] When #2191 is done, open an issue on [IntelliJ issue tracker](https://youtrack.jetbrains.com/issues/idea) to update `@MethodSource` support.","closed","3rd-party: IntelliJ IDEA,","juliette-derancourt","2022-04-14T17:23:01Z","2022-05-22T15:24:01Z"
"","2886","TempDir fails to clean up for certain files","Follow-up for #2883.  TempDir is failing to delete `Test.java` following a test (GenerateTest). This is a partial listing of the contents of the temporary directory including the problematic file:  ``` ./bufbuild/generated/java/com/parmet/buf/test/v1: total 20 -rw-r--r-- 1 root root 17332 Apr 10 21:30 Test.java ```  In a separate test (PublishTest), `image.json` is also generated from a call to Docker but TempDir has no trouble deleting it:  ``` ./bufbuild: total 4 -rw-r--r-- 1 root root 974 Apr 10 21:30 image.json ```  These logs are from build https://github.com/andrewparmet/buf-gradle-plugin/pull/59/checks?check_run_id=5963791559.  ## Steps to reproduce  Run CI on https://github.com/andrewparmet/buf-gradle-plugin/pull/59.  ## Context   - Used versions (Jupiter/Vintage/Platform): c8fa9c371106ef5ab5d87d68abde4ead27a0ea5a  - Build Tool/IDE: Gradle 7.4.1  cc @marcphilipp","closed","component: Jupiter,","andrewparmet","2022-04-10T21:44:44Z","2022-04-11T18:08:20Z"
"","2261","Fix dirMode & fileMode for reproducible builds","Follow up to https://github.com/junit-team/junit5/pull/2217  ## Context  build.gradle.kts ``` 	tasks.withType().configureEach { 		isPreserveFileTimestamps = false 		isReproducibleFileOrder = true  		dirMode = Integer.parseInt(""0755"", 8)                 fileMode = Integer.parseInt(""0644"", 8) 	} ```  See the corresponding in Gradle's build file:  https://github.com/gradle/gradle/blob/c28a59f06bae758fa610a35e23793e682b339c2e/build.gradle.kts#L309-L314  Also see  https://github.com/gradle/gradle/issues/10900","closed","","sdavids","2020-04-17T14:14:37Z","2020-04-19T06:57:18Z"
"","2571","Remove package name validation from classpath scanning","Fixes: https://github.com/junit-team/junit5/issues/2570","closed","","paplorinc","2021-03-16T16:26:08Z","2021-03-19T16:57:57Z"
"","2080","Evaluate @TempDir in enclosing classes of the test class as well.","Fixes: #2079  ## Overview  `@TempDir` annotation are now evaluated in the test class and all enclosing classes of the test class.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling","closed","component: Jupiter,","okuhn","2019-10-23T20:00:25Z","2019-12-17T09:30:31Z"
"","2646","Fix enclosing class bug in `IndicativeSentences`","Fixes #2645  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sbrannen","2021-06-16T17:01:43Z","2021-06-17T16:01:11Z"
"","2515","Allow parallel execution of child nodes if only read locks are acquired","fixes #2423  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","leonard84","2021-01-04T21:08:13Z","2021-01-12T11:49:25Z"
"","2357","Report disabled TestTemplate methods to TestWatchers","Fixes #2355.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","marcphilipp","2020-07-19T11:28:22Z","2020-07-29T08:51:11Z"
"","2206","Upgrade to bnd 5.0.0","fixes #2203  Signed-off-by: Raymond Augé   ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","rotty3000","2020-03-05T15:16:47Z","2020-04-17T11:03:10Z"
"","2266","Delete files in read-only dirs by making them writable","Fixes #2171.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-04-19T12:30:26Z","2020-04-19T14:57:42Z"
"","2150","Bad version range in Import-Package","fixes #2149  Signed-off-by: Raymond Augé   ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","rotty3000","2020-01-15T17:56:57Z","2020-01-15T19:28:26Z"
"","2122","Make ThrowableCollector.toTestExecutionResult() public","Fixes #2113.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","kriegfrj","2019-12-09T07:28:08Z","2019-12-17T11:31:24Z"
"","2106","[ReflectionUtils] Use class' classloader to load method params","Fixes #2104, along with corresponding test case.  ## Overview  `ReflectionUtils.loadRequiredParameterType()` will now use class' classloader to resolve parameter type names into `Class` objects.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","kriegfrj","2019-11-20T03:36:07Z","2021-06-03T19:46:48Z"
"","2095","Provide JARs with OSGi metadata","fixes  #195  Signed-off-by: Raymond Augé   ## Overview  Provide JARs with OSGi metadata  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","rotty3000","2019-11-08T19:20:37Z","2019-11-18T19:43:21Z"
"","2006","Report engine discovery/execution errors to listeners","Exceptions thrown by test engines during discovery and execution are now reported to `TestExecutionListeners` by reporting the engine descriptor as failed when executed.  Resolves #1909.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2019-09-08T14:24:59Z","2019-09-12T18:38:23Z"
"","2052","Improve error reporting for exceptions thrown by SelectorResolvers in EngineDiscoveryRequestResolution","Exceptions thrown by custom `SelectorResolvers` for test discovery are not propagated back to the `TestEngine` when using the `EngineDiscoveryRequestResolver`, therefore also not the `Launcher` and consequently also not the user. Currently if discovery in a `SelectorResolver` fails, JUnit only reports that no tests were found.  I am building a custom `TestEngine`, because I have some domain-specific needs, that Jupiter does not fulfill. To reduce the workload for coding the discovery phase of the engine I started using the `EngineDiscoveryRequestResolver` suggested in #1739 and introduced with #1798. If Tests are malformed, i. e. my `SelectorResolver` checks whether the Tests have been specified correctly, discovery in my engine should outright fail by throwing an exception. Suggested in #1909 and introduced with #2006 exceptions thrown by the `TestEngine` are reported to the `TestExecutionListeners` and potentially provide the user with feedback why the discovery has failed. Unfortunately that is not the case for the `EngineDiscoveryRequestResolver` respectively the `EngineDiscoveryRequestResolution`. As far as I can tell the class just [catches all `Throwables`](https://github.com/junit-team/junit5/blob/d6c023e10349109d7e57d642b4191e2ba5e156fd/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java#L95) and simply logs them internally. The user never gets to see the reason why the Test Discovery failed or rather why no tests could be found.  Might it be possible to let the `Exceptions` caught in the `EngineDiscoveryRequestResolver` respectively the `EngineDiscoveryRequestResolution` to not be caught in that class, but to let them travel up the hierarchy to the `TestEngine` to be then caught by the `Launcher` and as a result to be propagated back to the user? Or is there any other way to communicate the reason for failed test discovery back to the user?  ## Deliverables  - [ ] Propagate exceptions thrown by `SelectorResolvers` to the `TestEngine`","closed","theme: diagnostics,","bernwaldl","2019-10-07T23:59:04Z","2019-10-21T14:10:48Z"
"","2386","ExceptionInInitializerError in static block with BeforeAll present causes test to be ignored instead of FAILED","ExceptionInInitializerError in static block causes test to be ignored instead of FAILED if BeforeAll present. Is there something special about BeforeAll that alters the nature of this error which makes this a feature, not a bug? IMO an error in anyway should fail a test.  Run the class test target:  ``` import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test;  public class BugSimple {      static {         if (true)             throw new RuntimeException(""Error in static block"");     }      @BeforeAll     static void beforeAllLogSomething() {         //noop     }      @Test     public void testNoop(){         //noop     } } ```  Gets: ``` Test ignored.  java.lang.ExceptionInInitializerError ```  `[INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in snip.BugSimple`  The test will be ignored. It should instead be failed.  But, if you comment out the `@BeforeAll` annotation, and it will fail as expected, instead of being ignored.  Expected: ```[INFO] Running snip.BugSimple [ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.002 s <<< FAILURE! - in snip.BugSimple [ERROR] snip.BugSimple.testNoop  Time elapsed: 0 s  <<< ERROR! java.lang.ExceptionInInitializerError 	at snip.BugSimple.(BugSimple.java:10) ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.7.0-M1 junit-jupiter-engine   - Build Tool/IDE: Maven and IntelliJ IDEA  P.s., Love you work.","closed","3rd-party: Maven Surefire,","astubbs","2020-08-18T13:07:15Z","2020-08-21T11:50:59Z"
"","2540","Enable dependency verification","Enable Gradle's dependency verification feature.","closed","","marcphilipp","2021-01-24T14:54:11Z","2021-11-01T09:00:19Z"
"","2076","Improve documentation for writing tests and contional test execution","During the implementation of #2016 we could see that crucial information regarding conditional test execution was missing within the documentation.  Although the information is present in the [Extensions](https://github.com/junit-team/junit5/blob/master/documentation/src/docs/asciidoc/user-guide/extensions.adoc#L243-L247) section of the User Guide ...  > When multiple `ExecutionCondition` extensions are registered, a container or test is disabled as soon as one of the conditions returns _disabled_. Thus, there is no guarantee that a condition is evaluated because another extension might have already caused a container or test to be disabled. In other words, the evaluation works like the short-circuiting boolean OR operator.   ... this kind of information is missing within the [Writing Tests](https://github.com/junit-team/junit5/blob/master/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc#L334) section, which can lead to confusion when people start using multiple `ExecutionCondition`s.  ## Deliverables  - [x] Update User Guide to present or link crucial information","closed","component: Jupiter,","aepfli","2019-10-22T09:54:08Z","2019-10-23T07:13:32Z"
"","2232","Usage of junit5 testsuite","Does junit5 not have the functionality of testsuite in junit4? Include testsuite within testsuite Running parameterized test cases with @runwith (junit platform.class) results in errors in intellij idea reports. I want the functionality of testsuite in junit4","closed","status: duplicate,","objectBoolean","2020-04-02T07:32:31Z","2020-04-02T07:37:42Z"
"","1968","@SelectPackages not working with Maven CLI","Didn't get a response on SO so reposting here to see if I have any better luck  https://stackoverflow.com/questions/57136247/selectpackages-not-working-with-maven-cli","closed","type: question,","steppinrazor","2019-07-28T16:25:14Z","2019-07-30T18:47:00Z"
"","2481","Test class with name Junit 5 do not appear at Suite","Description: If I name a test class ending with the name Junit5, Junit Suite ( @RunWith(JUnitPlatform.class) ) will ignore this class at results. Removing this suffix It will appear again.  Example: If I name a test class public class StackTestJunit5 it will not appear,  but if I rename the file and the class to public class StackTest it will work normally  Using: Junit 5 Eclipse  /snap/eclipse/48/plugins/org.junit.jupiter.api_5.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.jupiter.engine_5.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.jupiter.migrationsupport_5.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.jupiter.params_5.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.platform.commons_1.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.platform.engine_1.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.platform.launcher_1.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.platform.runner_1.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.platform.suite.api_1.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.junit.vintage.engine_5.5.1.v20190826-0900.jar /snap/eclipse/48/plugins/org.opentest4j_1.2.0.v20190826-0900.jar /snap/eclipse/48/plugins/org.apiguardian_1.1.0.v20190826-0900.jar  ## Steps to reproduce - Name a test class called StackTestJunit5 Example code: ``` public class StackTestJunit5 {         @Test 	public void testEmptyStack() { 		assertEquals(2, 1+1, ""Example""); 	} } ``` ``` @RunWith(JUnitPlatform.class) @SelectPackages(""com.path.to.package"") public class StackSuite {  } ```","closed","theme: suites,","alissontenorio","2020-11-25T21:34:09Z","2020-11-26T13:03:15Z"
"","2051","Support multiple nesting levels with EventConditions#nestedContainer in Test Kit","Demonstrates and possibly resolves #2049  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Test Kit,","pietrygamat","2019-10-07T22:32:30Z","2019-10-25T14:00:23Z"
"","2585","Please delete this issue.","DELETED","closed","","mleonhard","2021-04-05T05:51:41Z","2021-04-06T06:15:30Z"
"","2815","Remove Jitpack usage and config","Delete https://github.com/junit-team/junit5/blob/main/.jitpack.yml, https://github.com/junit-team/junit5-samples/blob/main/junit5-jupiter-starter-maven/pom-JITPACK.xml and others","closed","theme: build,","marcphilipp","2022-01-21T11:45:27Z","2022-01-23T15:17:29Z"
"","2389","Junit5 & Wiremock & Multiples tests cause failure","Dear all,  I obtain a test failure with the **java.io.IOException: Failed to bind to /0.0.0.0:8081** exception.  Please find the project structure below :   ProjectBase + src   + main    | + java    |  |+ com.mypackage    |  |   + MockApplication.java    | + Resources    |    + application.properties   + Test      + java         + com.mypackage            + AbtractTestClass            + Unit1Test.class            + Unit2Test.class  The whole project is built and tested with maven and JUnit. The Junit-jupiter-engine version is 5.6.2.  The AbstractTestClass.java :  ` public abstract class AbstractTestClass{   protected static int PORT = 8081;   protected static MockApplication mockApi;      @BeforeAll @SneakyThrows   public static void init(){     mockApi = new MockApplication(PORT);     mockapi.init().start();   } } `  The two other classes are very semblable :   ` @DisplayName(""Unit1Test"") @DirtiesContext public class Unit1Test extends AbstractTestClass{    @Test     public void test1(){       HttpGet get = new HttpGet(MOCK_API_URL);       HttpResponse response = httpClient.execute(get);       assertEquals(HttpStatus.OK.value(), response.getStatusLine().getStatusCode());    } } ` If I ran tests separately, everything is fine. but if I try to run it by maven or intelliJ, the first-class runs perfectly, but the second fails with the **java.io.IOException: Failed to bind to /0.0.0.0:8081** .  Any advice?  Thanks,  Cyril GERMAIN","closed","component: Jupiter,","CyrilGermain","2020-08-21T23:02:37Z","2020-09-13T11:43:24Z"
"","2607","Add a way to repeat all test suit","Currently, the JUnit has the option of using the @RepeatedTest to allow a test to run multiple times.  Using the JITWatch, we can see how the application is behaving, so using the test suit would be a great way to get this information. However, running the tests one time each we cannot give the JIT enough time to really optimize.  In summary, to achieve this, now I'm replacing all `@Test()` with `@RepeatedTest(4500)` and running the test suit via console, like: ``` mvn package -DskipTests java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=mylogfile.log  -jar ~/Downloads/junit-platform-console-standalone-1.8.0-M1.jar --class-path ""..."" --scan-classpath ```  This way, after running the test suit, I get the ""mylogfile.log"" with a lot of JIT decisions. I'd like to know if would be of use to have an option that could repeat all the tests instead of having to do a search and replace in the test suit.  (Background: https://github.com/junit-pioneer/junit-pioneer/issues/472)","closed","","Thihup","2021-05-04T11:23:57Z","2021-05-13T12:12:06Z"
"","2191","Use registered ParameterResolver(s) when invoking @MethodSource factory methods","Currently, the `MethodSource` methods are supposed to not have any parameters, however, it'll help to have parameters to be resolved in these methods if registered similar to Before/After methods.  Along with #2190, this will give access to `MethodSource` methods to possibly use `Extension.Store` and store any initialized details, which could be purged in `@AfterAll` methods  Also, in case of creating dynamic tests using details from a resolved Object, `ParameterResolver` can enhance abilities of `MethodSource` by a fair bit.  Currently, the way to achieve the same is to have a class implementing `ArgumentsProvider` and possibly manage the value of the object there, or have it in the `MethodSource` method itself statically initializing it in test class.","closed","type: new feature,","nishantvas","2020-02-20T10:43:45Z","2022-05-13T11:02:06Z"
"","2341","Provide a synchronization mechanism for dynamic tests","Currently, it looks like synchronization is only made available through the annotation ResourceLock.  As far as I can see, there is no way to do this for dynamic tests.  Perhaps there should be an overloaded dynamicTest method which can supply the same information?  It would also be useful to synchronize all tests within a dynamicContainer such that multiple containers run in parallel but tests within the containers run sequentially.","closed","","rupert-madden-abbott","2020-06-25T18:51:20Z","2020-06-26T07:20:14Z"
"","2233","Describe mismatches found by assertLinesMatch","Currently, in `AssertLinesMatch` on `main`, I see:  ```java 	private final static int MAX_SNIPPET_LENGTH = 21; 	private final static int MAX_LINES_IN_FAILURE_MESSAGE = 42; ```  Please create some way to allow the user of JUnit 5 to configure these parameters, with a value of zero meaning ""unlimited"".  The usefulness of `assertLinesMatch` degrades when the snippets are too short to show the problem that needs to debugged, and when the relevant lines are omitted.  The numbers 21 and 42 are certainly not ""one size fits all"" parameters.  Recent releases of IntellJ IDEA have a really nice feature parses the output of `assertLinesMatch` fails and shows the results in a graphical diff window.  The omitted lines make that feature far less valuable than it could be as well.  I think a static knob would be fine. I see no need for these to be changed dynamically during test suite execution.  How about just a simple system property for each of those two parameters?  Thanks!","closed","component: Jupiter,","tcfurrer","2020-04-02T17:09:08Z","2020-08-03T16:05:18Z"
"","2181","Introduce mechanism to deactivate TestExecutionListeners","Currently, if any of the dependencies or transitive dependencies wishes to add a `TestExecutionListener`, it can do so by adding `org.junit.platform.launcher.TestExecutionListener` in `META-INF/services`.  However, sometimes, we need a dependency for the features it provides, but we do not want its `TestExecutionListener` to get registered.  Is it possible to have a similar construct like that of `junit.jupiter.conditions.deactivate` to be able to provide a pattern to disable or I suppose in this context de-register the listeners?","closed","type: new feature,","nishantvas","2020-02-12T12:16:38Z","2020-03-29T10:38:49Z"
"","2852","stop .asc.${checksums} publication to Central repository","currently, for each artifact published to Central repository, there are many additional files published: checksums and signature see for example: https://repo1.maven.org/maven2/org/junit/jupiter/junit-jupiter/5.8.2/  most of the files that I see follow expected  Maven2 repository layout: https://maven.apache.org/repository/layout.html perfect  there is only one series of checksum files that I'm surprised of: each `.asc` file is currently complemented by checksum files `.asc.md5`+`.asc.sha1`+`.asc.sha256`+`.asc.sha512`  These files are not a Central requirement: see for example https://repo1.maven.org/maven2/org/codehaus/plexus/plexus-utils/3.4.1/  Is there a deliberate choice to add checksums for `.asc` files? Are these checksums found useful for something that I did not imagine?  I'd personally would think that these files should not be published.","closed","theme: build,","hboutemy","2022-03-15T09:48:10Z","2022-03-21T17:59:55Z"
"","2423","Allow parallel execution of child nodes if only read locks are acquired","Currently, child nodes are forced to `SAME_THREAD` execution if the parent has any locks.   If the parent only has `READ` locks, then it would be valid for the child nodes to execute concurrently. This would also alleviate the issues of #2038 and we partly have this logic already for the isolated execution of #2142   ## Deliverables  - [x] Don't force child nodes to `SAME_THREAD` execution if only `READ` locks are acquired","closed","component: Platform,","leonard84","2020-09-24T12:46:16Z","2021-05-15T08:37:05Z"
"","2193","Allow @RepeatedTest to be configured with a variable number of repititions","Currently you need to hardcode the number of repetitions of a @RepeatedTest in source code. However sometimes it would be desirable to compute the number of repetitions dynamically based on some external conditions (System properties, Env vars, Database etc...)  Our use case is that for our alpha, beta stages we would like to run our tests multiple times but in production stages we would only run it once or twice. This ensure that our tests and features are stable before we push them to all the production stages and regions.  Alternatively, if there is a way to do this via the extension model please let me know. I looked around but could not figure it out. Any pointers will be helpful.","closed","component: Jupiter,","swaranga","2020-02-23T03:47:25Z","2020-02-24T14:03:40Z"
"","2798","Allow defining scope in the @TempDir annotation","Currently you can choose the scope globally, but not on individual tests.  Some tests may require unique directories, and some may require shared ones.","closed","component: Jupiter,","OrangeDog","2021-12-17T11:08:02Z","2021-12-18T14:32:29Z"
"","1997","Add a possibility to add custom PostDiscoveryFilter via SPI or configuration property","Currently we are working on solution that will allow users to select tests to run from web UI. Every test is already marked by custom `@TestId` annotation, so we only missing possibility to register a custom `PostDiscoveryFilter` via SPI or some kind of configuration property.   Currently the only way to add `PostDiscoveryFilter` is to manually create `LauncherDiscoveryRequest` but that's seems to be hard for users (imagine, they will need to switch from maven/gradle integrations to custom plugin)  I know there is possibility to run tests via className/method name or uniqueId but this values may be changed during test refactoring but they will still related to same entity in test management system. Thats why we are using custom annotation `@TestId` to store this relation.  The solution I have in mind is to implement custom `PostDiscoveryFilter`, register it via SPI, and then enable/configure it via environment variable (system property).","closed","theme: discovery,","baev","2019-09-01T13:37:15Z","2021-11-07T09:26:15Z"
"","2146","Support FilePosition in discovery selectors","Currently there is no good way to discover and execute a single test when using a file based test system like Cucumber. So I would like to request support for a file position in `UriSelector`, `FileSelector` and `ClasspathResourceSelector`.  **Deliverables**  Support for a file position when using:  - URI selectors  - File selectors  - Classpath resource selectors  **Motivation**  Cucumber executes feature files written in Gherkin. A feature file consists of multiple scenarios organized in a hierarchical structure. A project may contain multiple feature files, typically organized in some directory structure.  For example: ``` |- src/main/java/com/example | |- App.java |- src/test/java/com/example | |- StepDefinitions.java |- src/test/resource/com/example/ | |- single.feature | |- rule.feature | |- outline.feature ```  Contents of `outline.feature`: ```feature Feature: A feature with scenario outlines    Scenario: A scenario     Given a scenario     When it is executed     Then is only runs once    Scenario Outline: A scenario outline     Given a scenario outline     When it is executed     Then  is used      Examples: With some text       | example |       | A       |       | B       |      Examples: With some other text       | example |       | C       |       | D       | ```  `outline.feature`  contains 5 tests in a hierarchy:  ``` A feature with scenario outlines |- A scenario |- A scenario outline | |- With some text | | |- Example #1 | | |- Example #2 | |- With some other text | | |- Example #1 | | |- Example #2 ``` Now suppose I would like select both tests (`Example #1`, `Example #2`) nested under the example  `With some text` on line 17.  Currently JUnit discovery selectors (`ClasspathRootSelector`, `ClasspathResourceSelector`, `PackageSelector`, `FileSelector`, `DirectorySelector`) only allow me to discover all tests in a single directory or file.  The `UniqueIdSelector` could be used to select the `With some text` container but requires reproducing the unique id which is rather complicated and quite possibly an implementation detail that should not be relied upon.  Cucumbers  current`TestEngine` implementation currently allows for a `line` query parameter to be added in when parsing using the `UriSelector`. For example:    - `classpath:/com/example/outline.feature?line=17`   - `file:/home/mpkorstanje/projects/cucumber/src/test/resources/com/example/outline.feature?line=17`  Since this is not formalized I suspect other test engines that consume the `UriSelector` may crash on the query parameter and so I would like something safer.   For IDEs being able to use a `FileSelector` with a file position would also simplify the complexity of providing support for file based test engines. Naively allowing the user to select any line in a file and execute the discovered tests for that line would provide for a minimal implementation without knowing any details about the underlying implementation of the test engine.  The same reasoning applies to `ClasspathResourceSelector`.","closed","theme: discovery,","mpkorstanje","2020-01-12T15:55:03Z","2020-05-22T21:06:06Z"
"","2610","Make `assertTimeout()` more valuable","Currently there is nearly not functional distinction between `assertTimeout()` and `assertTimeoutPreemptively()`.  `assertTimeout()` is waiting to complete the execution. Therefore it seems to be natural that you can access the result to check it even if timeout exceeded.  Would be great to see that it produces the correct result and is in time or has a timeout.  Perhaps a new type of ""error"" has to be invented.   In this way you can fine tune performance and have a look at correctness.  Please contact me for more information: michael_inden@hotmail.com","closed","theme: reporting,","Michaeli71","2021-05-07T19:13:30Z","2022-05-16T11:01:28Z"
"","2128","Add expectedMessage to assertThrows","Currently the way to check for an expected message is `assertEquals(""the exception message"", assertThrows(SomeException.class, () -> some.operationThatThrows()).getMessage());`  That's repeated boilerplate, and after a while it gets kind of annoying. You could add:  `assertThrows(SomeException.class, () -> some.operationThatThrows(), ""the exception message"");`  Except you can't, because that signature is already taken to provide a way to specify a failure message. So you'd either need a new method name, like `assertThrowsWithExpectedMessage`, or some ugly thing like a new provider similar to the Supplier for failure messages. I'd lean towards a new method name.  Related: https://github.com/junit-team/junit5/issues/2129","closed","component: Jupiter,","jimshowalter","2019-12-13T18:42:41Z","2019-12-20T08:17:43Z"
"","2849","The JUnit Platform does not receive first-class support","Currently the user-guide states:  > First-class support for the JUnit Platform also exists in popular IDEs (see [IntelliJ IDEA](https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-intellij-idea), [Eclipse](https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-eclipse), [NetBeans](https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-netbeans), and [Visual Studio Code](https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-vscode)) and build tools (see [Gradle](https://junit.org/junit5/docs/current/user-guide/#running-tests-build-gradle), [Maven](https://junit.org/junit5/docs/current/user-guide/#running-tests-build-maven), and [Ant](https://junit.org/junit5/docs/current/user-guide/#running-tests-build-ant)).  However of these I know that:  - IDEA     - https://youtrack.jetbrains.com/issue/IDEA-276463    - https://youtrack.jetbrains.com/issue/IDEA-276477    - https://youtrack.jetbrains.com/issue/IDEA-227508    - https://youtrack.jetbrains.com/issue/IDEA-292853    - https://youtrack.jetbrains.com/issue/IDEA-292662   - Eclipse    -  No issue exists.   - Maven Surefire    -  https://issues.apache.org/jira/browse/SUREFIRE-1724   - Gradle    - https://github.com/gradle/gradle/issues/4773   do not support the use of all discovery selector primitives (either directly or indirectly) and don't fully use the hierarchal test concept (often limited to the extent needed to support JUnit 4). As such I don't believe we can claim these IDEs and build tools have _first-class_ support for the JUnit Platform. At best I believe we may claim some support for JUnit Jupiter.","open","status: new,","mpkorstanje","2022-03-08T23:01:34Z","2022-04-24T17:45:37Z"
"","2570","Remove PackageUtils package name validation","Currently the primitive type names aren't considered keywords, even though they can't be package names: ```groovy org.junit.platform.commons.util.PackageUtils.JavaNameUtils.isJavaName('int') Result: true ```  based on https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-Identifier, `int` shouldn't be allowed in package names: ![image](https://user-images.githubusercontent.com/1841944/111344251-7f047f80-867c-11eb-8967-c39b4c4e3bda.png)","closed","theme: discovery,","paplorinc","2021-03-16T16:24:59Z","2021-08-17T09:34:36Z"
"","2089","Links in the docs to CI are referencing to 404","Currently the links within the README.md file on Github to the continuous integration are both showing 404 error pages.  ``` ## Continuous Integration Builds  [![CI Status](https://github.com/junit-team/junit5/workflows/CI/badge.svg)](https://github.com/junit-team/junit5/actions) [![Cross-Version Status](https://github.com/junit-team/junit5/workflows/Cross-Version/badge.svg)](https://github.com/junit-team/junit5/actions) ```  https://github.com/junit-team/junit5/#continuous-integration-builds are currently showing pages with 404 error messages.","closed","theme: build,","khmarbaise","2019-10-30T20:09:10Z","2019-10-31T21:13:05Z"
"","2321","Move Assertions.fail example to Assertions.fail(String)","Currently the explanation for the return value of `Assertions.fail` and an example for it exists for `Assertions.fail(String, Throwable)`: https://github.com/junit-team/junit5/blob/be2aa2497a75dedceb37bc3297276e230fb4f293/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java#L117-L128  However, the example does not fit because it does not use the `fail(String, Throwable)` overload. Would it therefore make sense to move the return value explanation and the example to `fail(String)` and link to that from the other `fail` overloads instead?","closed","component: Jupiter,","Marcono1234","2020-06-13T13:58:41Z","2020-06-15T12:11:18Z"
"","2583","JUnit Jupiter Engine has a dependency to kotlin-stdbli-jdk8","Currently the 5.8.0-M1 version of `junit-jupiter-engine` has an explicit dependency to `kotlin-stdblib-jdk8`.  ```xml            org.jetbrains.kotlin       kotlin-stdlib-jdk8       1.4.20       compile      ``` Is this really necessary?  ## Context   - 5.8.0-M1  - Build Tool/IDE:  -  Maven / IDEA IntelliJ","closed","status: duplicate,","khmarbaise","2021-04-02T17:42:03Z","2021-04-02T18:41:21Z"
"","2641","Update junit-vintage-engine dependency to junit version to 4.13.2 due to vulnerability in the current 4.13","Currently junit-vintage-engine 5.7.2 requires version 4.13 of junit and should change the dependency to junit 4.13.2.  See this link for the vulnerability https://ossindex.sonatype.org/component/pkg:maven/junit/junit@4.13","closed","dependencies,","marioja","2021-06-08T20:34:16Z","2021-06-10T05:17:00Z"
"","2304","JUnit jupiter should support @Test methods that return Void","Currently JUnit Jupiter ignores the following test:  ```java    @Test     public Void myTest() {        ...         return null;     } ```  I am sure, that such test must be supported as this is totally to java language specs. Or I misunderstand something?","closed","component: Jupiter,","PashaTurok","2020-05-20T09:05:19Z","2020-05-20T11:44:02Z"
"","2912","Open up ExecutionRequest creation for external usage","Currently I'm working on a test engine that delegates work to other test engines.  Everything works great, except I have to use `ExecutionRequest`'s constructor which is marked as internal.  https://github.com/junit-team/junit5/blob/80bf93fd3cb841e76fc017dc759d8ef0df158d49/junit-platform-engine/src/main/java/org/junit/platform/engine/ExecutionRequest.java#L39-L41  So please add a _public_ way to instantiate `ExecutionRequest` or replace it with an interface like `EngineDiscoveryRequest`.  This will make variations of suite engine possible.  The other possibility is to directly test the `TestEngine#execute` method without using an internal API.","closed","component: Platform,","alopukhov","2022-05-09T13:43:30Z","2022-06-18T14:25:33Z"
"","2254","Mark Preconditions class as MAINTAINED or STABLE","Currently I stumbled another time about the thing that the class `Preconditions` is marked as part of the `INTERNAL` API, but it would be helpful for authors of extensions to make it `MAINTAINED` or `STABLE` so it can be used very easily otherwise it could happen that you change the `Preconditions` class and my own extensions do not work anymore (This is of course the idea of an INTERNAL API). Maybe others have observed the same thing.  The `Precondition` class and its methods are very helpful in cases where you write a `ExecutionCondition` like `Disabled.*` or `Enabled.*` etc. and it is not limited to this.","closed","component: Platform,","khmarbaise","2020-04-10T19:01:20Z","2020-04-23T10:43:31Z"
"","2197","ReflectionUtils.getDeclaredConstructor() should ignore synthetic constructors","Currently `org.junit.platform.commons.util.ReflectionUtils.getDeclaredConstructor` method doesn't check if constructor is synthetic or not: ```java public final class ReflectionUtils {  	// ...  	public static  Constructor getDeclaredConstructor(Class clazz) { 		Preconditions.notNull(clazz, ""Class must not be null""); 		try { 			Constructor[] constructors = clazz.getDeclaredConstructors(); 			Preconditions.condition(constructors.length == 1, 				() -> String.format(""Class [%s] must declare a single constructor"", clazz.getName()));  			return (Constructor) constructors[0]; 		} 		catch (Throwable t) { 			throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t)); 		} 	}  	// ...  } ```  I suggest we filter out synthetic constructors.  The reason behind the suggestion is there are some apt tools and bytecode processor that can add synthetic constructors and it makes sense not to take them into consideration.","closed","component: Platform,","remal","2020-02-25T12:30:30Z","2020-02-25T15:20:41Z"
"","2129","Provide way to specify that the root cause should be checked in assertThrows","Currently `assertThrows(SomeRootCause.class, () -> some.operationThatUsesReflectionToInvokeSomethingThatThrows);` fails, because it tries to match `SomeRootCause.class` to the outermost exception, which in this case is `InvocationTargetException.class`.  The workaround is to not use `assertThrows` and instead write a try/catch block that calls `some.operationThatUsesReflectionToInvokeSomethingThatThrows`, catch `InvocationTargetException`, and get the inner exception oneself, all without framework support.  It would be nicer if the framework provided something like `assertThrowsInnermost(SomeRootCause.class, some.operationThatUsesReflectionToInvokeSomethingThatThrows);`, or `assertThrows(SomeRootCause.class, some.operationThatUsesReflectionToInvokeSomethingThatThrows, true);`, where the new `boolean` overload tells the framework to get the innermost exception instead of the outermost exception.  Related: https://github.com/junit-team/junit5/issues/2128","closed","component: Jupiter,","jimshowalter","2019-12-13T18:46:56Z","2019-12-20T08:17:40Z"
"","2508","Document constant value for ExclusiveResource.GLOBAL_KEY","Cucumber integrates with the JUnit Platform by implementing a test engine. This engine extends the `HierarchicalTestEngine` and inherits its support to lock resources. Because Cucumber uses plain text files we can not references constants from a class e.g:  ``` @ResourceLock(ExclusiveResource.GLOBAL_KEY) ``` but instead have to [reference the plain text value in a configuration file](https://github.com/cucumber/cucumber-jvm/tree/main/junit-platform-engine#running-tests-in-isolation):  ``` cucumber.execution.exclusive-resources.isolated.read-write=org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY ```  Currently the value of `ExclusiveResource.GLOBAL_KEY` is not documented in the Javadoc and not part of the API. As such Cucumber and other non-java based engines can't depend on this value to run tests in isolation.  Note: The same is also true for all constants in `Resources`. And I somewhat would expect `GLOBAL_KEY` to be documented here rather then in `ExclusiveResource`.  ## Deliverables  - [ ] Document the value of `ExclusiveResource.GLOBAL_KEY` in the JavaDoc using `{@value}` in `Resources`. - [ ] Optionally document the values of `Resources.*` in the JavaDoc using `{@value}`.","closed","component: Platform,","mpkorstanje","2020-12-27T21:05:00Z","2021-02-11T11:44:21Z"
"","2116","Console Launcher doesn't see the classes from src/ of the same package as the Test class","Console launcher fails if you don't explicitly import classes of the same package from src/  Given this abstracted structure of a maven project _src/main/x/y/z/Service.java test/java/x/y/zServiceTest.java_  And JUnit 5 version  +- org.junit.jupiter:junit-jupiter:jar:5.5.2:test [INFO] |  |  +- org.junit.jupiter:junit-jupiter-api:jar:5.5.2:test [INFO] |  |  |  +- org.apiguardian:apiguardian-api:jar:1.1.0:test [INFO] |  |  |  +- org.opentest4j:opentest4j:jar:1.2.0:test [INFO] |  |  |  \- org.junit.platform:junit-platform-commons:jar:1.5.2:test [INFO] |  |  +- org.junit.jupiter:junit-jupiter-params:jar:5.5.2:test [INFO] |  |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.5.2:test [INFO] |  |     \- org.junit.platform:junit-platform-engine:jar:1.5.2:test  _ServiceTest.java_  file has a test like    @Test   @DisplayName(""is empty when no book is added to it"")   void shelfEmptyWhenNoBoookAdded(TestInfo testInfo) {     Service service = new Service();     List books = service.getBooks();     assertTrue(books.isEmpty(), () -> ""BookShelf should be empty"");   }  When try to execute it with: _java -jar junit-platform-console-standalone-1.6.0-M1.jar -cp ./target/test-classes -cp ./target/classes --select-package x.y.x_ It fails with java.lang.NoClassDefFoundError: x/y/z/Service  If explicitly import the Service inside the ServiceTest class then it doesn't fail  I should not explicitly import classes of the same package as the test file/class","closed","","Phenomendx","2019-11-27T02:03:53Z","2019-11-27T03:14:48Z"
"","2496","BeforeAll block failed and test failed as well","Configuration:  ```xml    org.junit  junit-bom  5.7.0  pom  import      org.apache.maven.plugins  maven-surefire-plugin  3.0.0-M5 ```  ### Code example  We've got `BeforeAll` extension in the project  ```java class BeforeAll : BeforeAllCallback {     override fun beforeAll(extensionContext: ExtensionContext) {         Logger         StandHealthCheck         UsersHelper     } } ```  and a test  ```java class SwaggerTest {      @Test       fun swaggerHealthCheck() {         swagger()     } } ``` For some reasons `BeforeAll` block may fail and this is valid for us. But than we expect all the tests in the run will be skipped, but they not.   There are two different behaviors:  1. Run single test with RUN button. Error message is:  ``` Test ignored.  java.lang.AssertionError: 1 expectation failed. Expected status code <200> but was <422>. ``` 2. Run test with `mvn clean -Dtest=SwaggerTest#swaggerHealthCheck test`  Message is:  ``` [ERROR] Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 5.392 s <<< FAILURE! - in api.platform.qa.swagger.SwaggerTest [ERROR] api.platform.qa.swagger.SwaggerTest  Time elapsed: 5.392 s  <<< FAILURE! java.lang.AssertionError:  1 expectation failed. Expected status code <200> but was <422>. [INFO]  [INFO] Results: [INFO]  [ERROR] Failures:  [ERROR]   SwaggerTest 1 expectation failed. Expected status code <200> but was <422>. [INFO]  [ERROR] Tests run: 1, Failures: 1, Errors: 0, Skipped: 0 ```  The question is for second situation - Is there any way to skip all tests after `BeforeAll` block fails and NOT to set failed message to them(`Expected status code <200> but was <422>` - in our example)?","closed","","LenaShev","2020-12-18T06:48:49Z","2020-12-22T15:47:20Z"
"","2558","No module descriptor in standalone console JAR","Closes #2557","closed","","sormuras","2021-02-25T15:45:15Z","2021-04-16T13:07:13Z"
"","2446","Build test code with Java 15","Closes #2406","closed","","marcphilipp","2020-10-10T16:07:03Z","2020-10-11T07:25:03Z"
"","2392","Let Testable annotation target any declaration element type","Closes #2391  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2020-08-23T06:17:01Z","2020-09-09T14:36:06Z"
"","2015","Change Devoxx Belgium talk date","Changing Devoxx ""Junit: time to shift into 5th gear"" event date since the schedule has been released.","closed","","julien-topcu","2019-09-19T06:04:37Z","2019-09-19T06:25:46Z"
"","2962","Bump com.gradle.enterprise.test-distribution from 2.3.3 to 2.3.5","Bumps com.gradle.enterprise.test-distribution from 2.3.3 to 2.3.5.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise.test-distribution&package-manager=gradle&previous-version=2.3.3&new-version=2.3.5)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-07-04T05:39:01Z","2022-07-04T06:11:39Z"
"","2940","Bump com.gradle.enterprise.test-distribution from 2.3.2 to 2.3.3","Bumps com.gradle.enterprise.test-distribution from 2.3.2 to 2.3.3.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise.test-distribution&package-manager=gradle&previous-version=2.3.2&new-version=2.3.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-06-09T12:34:25Z","2022-06-09T12:57:00Z"
"","2923","Bump com.gradle.enterprise.test-distribution from 2.3.1 to 2.3.2","Bumps com.gradle.enterprise.test-distribution from 2.3.1 to 2.3.2.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise.test-distribution&package-manager=gradle&previous-version=2.3.1&new-version=2.3.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-05-21T09:00:27Z","2022-05-21T09:25:43Z"
"","2908","Bump com.gradle.enterprise.test-distribution from 2.3 to 2.3.1","Bumps com.gradle.enterprise.test-distribution from 2.3 to 2.3.1.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise.test-distribution&package-manager=gradle&previous-version=2.3&new-version=2.3.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-05-05T10:53:05Z","2022-05-05T15:23:33Z"
"","2981","Bump com.gradle.enterprise from 3.10.2 to 3.10.3","Bumps com.gradle.enterprise from 3.10.2 to 3.10.3.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise&package-manager=gradle&previous-version=3.10.2&new-version=3.10.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-07-18T05:27:35Z","2022-07-20T15:12:36Z"
"","2941","Bump com.gradle.enterprise from 3.10.1 to 3.10.2","Bumps com.gradle.enterprise from 3.10.1 to 3.10.2.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise&package-manager=gradle&previous-version=3.10.1&new-version=3.10.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-06-09T12:34:25Z","2022-06-09T12:46:41Z"
"","2922","Bump com.gradle.enterprise from 3.10 to 3.10.1","Bumps com.gradle.enterprise from 3.10 to 3.10.1.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.enterprise&package-manager=gradle&previous-version=3.10&new-version=3.10.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-05-21T09:00:25Z","2022-05-21T09:16:12Z"
"","2937","Bump common-custom-user-data-gradle-plugin to 1.7.2","Bumps com.gradle.common-custom-user-data-gradle-plugin from 1.7 to 1.7.2.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.common-custom-user-data-gradle-plugin&package-manager=gradle&previous-version=1.7&new-version=1.7.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-06-06T05:28:32Z","2022-06-27T08:00:08Z"
"","2921","Bump com.gradle.common-custom-user-data-gradle-plugin from 1.6.5 to 1.7","Bumps com.gradle.common-custom-user-data-gradle-plugin from 1.6.5 to 1.7.   [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.gradle.common-custom-user-data-gradle-plugin&package-manager=gradle&previous-version=1.6.5&new-version=1.7)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)","closed","dependencies,","dependabot[bot]","2022-05-21T09:00:24Z","2022-05-21T09:19:39Z"
"","2447","Bump junit from 4.12 to 4.13.1 in /platform-tooling-support-tests/projects/vintage","Bumps [junit](https://github.com/junit-team/junit4) from 4.12 to 4.13.1.  Release notes Sourced from junit's releases.  JUnit 4.13.1 Please refer to the release notes for details. JUnit 4.13 Please refer to the release notes for details. JUnit 4.13 RC 2 Please refer to the release notes for details. JUnit 4.13 RC 1 Please refer to the release notes for details. JUnit 4.13 Beta 3 Please refer to the release notes for details. JUnit 4.13 Beta 2 Please refer to the release notes for details. JUnit 4.13 Beta 1 Please refer to the release notes for details.    Commits  1b683f4 [maven-release-plugin] prepare release r4.13.1 ce6ce3a Draft 4.13.1 release notes c29dd82 Change version to 4.13.1-SNAPSHOT 1d17486 Add a link to assertThrows in exception testing 543905d Use separate line for annotation in Javadoc 510e906 Add sub headlines to class Javadoc 610155b Merge pull request from GHSA-269g-pwp5-87pp b6cfd1e Explicitly wrap float parameter for consistency (#1671) a5d205c Fix GitHub link in FAQ (#1672) 3a5c6b4 Deprecated since jdk9 replacing constructor instance of Double and Float (#1660) Additional commits viewable in compare view      [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=junit:junit&package-manager=maven&previous-version=4.12&new-version=4.13.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/configuring-github-dependabot-security-updates)  Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---   Dependabot commands and options   You can trigger Dependabot actions by commenting on this PR: - `@dependabot rebase` will rebase this PR - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it - `@dependabot merge` will merge this PR after your CI passes on it - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it - `@dependabot cancel merge` will cancel a previously requested merge and block automerging - `@dependabot reopen` will reopen this PR if it is closed - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself) - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself) - `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language - `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language - `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language - `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language  You can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/junit-team/junit5/network/alerts).","closed","dependencies,","dependabot[bot]","2020-10-13T11:42:18Z","2020-10-14T18:27:23Z"
"","2296","Let TestReporter publish entries with values not being strings","Background: I tried to implement an extension to make it possible measuring the duration of test executions. So I created an extension like the one in the JUnit5 User Guide. Everything seemed fine when I checked the example implementation provided there (""TimingExtension""). **But** there, the duration is just logged. However, I need to include the results in a report created by implementing a custom TestExecutionListener. Looking at the ExtensionContext interface, I thought I could use the instance provided as an argument to the beforeTestExecution/afterTestExecution methods (defined in BeforeTestExecutionCallback and AfterTestExecutionCallback, respectively) to publish entries containing the time a test is started/is finished. But, at a second glance I saw that the report entries has to be consumed by a EngineExecutionListener, which is, in my case, sadly no supertype of TestExecutionListener. So, there seems no easy way to publish those points in time to my own listener. Sadly, I found no documentation for the EngineExecutionListener in the user guide, so I don't expect the reports are internally received and passed further, such that they are also avaible in execution listeneres. So two questions arise: * A compound value type holding the start time of test execution and the end time of test execution published through my extension for further use in the listener would be a good fit. Sadly, only publishing the string representation of these times seem to be possible. Therefore, the duration of actual test execution, if not published additionally also as a string representation (which would be kinda redundant in my opinion), has to be computed in the listener after first parsing the time points' string representations. Why isn't it simply possible to publish non-string keys? * How can I publish results from an extension to an execution listener?  Thanks to you in advance for any response.","open","theme: reporting,","oprb","2020-05-13T13:15:31Z","2021-08-15T07:50:31Z"
"","2833","Noinspection for !isPresent()","Avoiding ""Can be replaced with 'isEmpty()'"" hint, which can't be use here since it's not part of Java 8. The method isEmpty() was added to Optional in Java 11: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Optional.html#isEmpty()  ## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: invalid,","mklose","2022-02-18T19:18:06Z","2022-02-21T07:27:43Z"
"","2195","Support custom `junit-platform.properties` location","At the moment, the JUnit Platform properties are loaded from the first (and sole) resource named `junit-platform.properties` available via the `ClassLoader` resource-loading facility.  Internally, the JUnit Platform `Launcher` already supports by-passing this logic by providing an explicit location of a `junit-platform.properties` file or stream.  ## Deliverables  - [ ] Introduce a new launcher system property, like `junit.platform.properties.location`, that lets users specify an alternate location of the JUnit Platform properties file to load.","closed","status: stale,","sormuras","2020-02-24T09:00:34Z","2022-07-11T20:21:44Z"
"","2774","[FR] Mark tests preconditions / dependencies","Assume you are testing a FIFO-Queue.   In that case you can  imagine writing these two abstract test cases:  ```java  testPush:   q = Queue()    q.push(1)   // do some testing, assertions   testPull:   q = Queue()   q.push(1)   // finished the setup      e = q.pull()   // test the desired behavior ```  Lets assume that push is faulty. The test results would indicate that both testcases are faulty. The report is not conclusive about what tested behavior is faulty. Without reading and inspecting the tests no real conclusions could be made.  ### Proposal:  Therefore I propose the following behavior.  ```java  @DependsOn(""testPush"")  testPull:   [...] ```  The annotation I propose kinda behaves like the conditional execution already implemented. And the resolution of the test should also be implemented as `MethodSource` uses the same behavior.  ### The desired behavior  A test annotated with this annotation should only run if the tests it depends on are successful. If that's not the case this one shouldn't be executed and should be marked as ""skipped due to its dependencies aren't meet"".   ### Advantages:  Reading the test report is clear. A test marked as failed indicates that the tested behavior is faulty. A test marked as ""skipped due to [...]"" is precise.  Finding and fixing the root cause of the failing tests is also easier. Look  at the test, fix all the failing ones, rerun.  This is advantageous to the current state, because as of now, you need to look through all the failing tests, figure out which ones is truly faulty and fix those.","closed","component: Jupiter,","Hu1buerger","2021-11-07T18:15:49Z","2021-11-08T15:03:38Z"
"","2824","Fail test discovery if an `IncludeEngines` filter is configured and doesn't match any engine","As stated in #2819, it would be useful to make a build fail when engine filters are not well configured.  ## Deliverables  - [x] Fail test discovery if an `IncludeEngines` filter is configured and doesn't match any engine. - [x] Log a warning if all engines have been filtered out by an exclude filter. - [x] ~Log a warning (instead of config) in case no engine is on the classpath (in `ServiceLoaderTestEngineRegistry`).~ `SuiteLauncher` and `DefaultLauncher` already throw an exception in that case  Issue opened following decision taken in https://github.com/junit-team/junit5/issues/2819#issuecomment-1029910273.","closed","theme: discovery,","juliette-derancourt","2022-02-06T17:25:20Z","2022-05-15T17:52:21Z"
"","2461","Make DefaultParallelExecutionConfiguration public","As requested in https://github.com/spockframework/spock/pull/1207/files#r511436053   ## Deliverables  - [ ] make `org.junit.platform.engine.support.hierarchical.DefaultParallelExecutionConfiguration` public","open","component: Platform,","leonard84","2020-10-24T19:52:47Z","2021-08-15T07:50:32Z"
"","2377","NoClassDef in ClassSelectorResolver","As reported in https://github.com/openzipkin/zipkin/issues/3159 , starting from surefire/failsafe 3.0.0-M5 we have tests crashing. We're unsure if the issue lies in junit or surefire, but since the exception is generated by junit code reporting it first here.   ## Steps to reproduce  * git clone https://github.com/openzipkin/ * cd openzipkin * mvn --also-make --projects zipkin-tests clean install   ``` Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: /home/linuxbrew/.linuxbrew/Cellar/maven/3.6.3_1/libexec Java version: 13.0.2, vendor: N/A, runtime: /home/linuxbrew/.linuxbrew/Cellar/openjdk/13.0.2+8_2/libexec Default locale: en_US, platform encoding: UTF-8 OS name: ""linux"", version: ""5.4.0-42-generic"", arch: ""amd64"", family: ""unix""  ....  [INFO] Zipkin Interop Tests ............................... FAILURE [  7.828 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time:  36.880 s [INFO] Finished at: 2020-08-10T22:05:06+02:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal org.apache.maven.plugins:maven-failsafe-plugin:3.0.0-M5:verify (verify) on project zipkin-tests: There are test failures. [ERROR]  [ERROR] Please refer to /home/heymjo/src/zipkin/zipkin-tests/target/failsafe-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream. [ERROR] org.apache.maven.surefire.booter.SurefireBooterForkException: There was an error in the forked process [ERROR] TestEngine with ID 'junit-jupiter' failed to discover tests [ERROR] 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:733) [ERROR] 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:305) [ERROR] 	at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:265) ``` Dump file:  ``` # Created at 2020-08-10T21:42:45.607 org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:189) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:168) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:124) 	at org.apache.maven.surefire.junitplatform.TestPlanScannerFilter.accept(TestPlanScannerFilter.java:56) 	at org.apache.maven.surefire.api.util.DefaultScanResult.applyFilter(DefaultScanResult.java:102) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.scanClasspath(JUnitPlatformProvider.java:147) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:128) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:428) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:162) 	at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:562) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:548) Caused by: org.junit.platform.commons.JUnitException: NestedClassSelector [enclosingClassNames = [zipkin2.storage.ITInMemoryStorage], nestedClassName = 'zipkin2.storage.ITInMemoryStorage$ITDependencies'] resolution failed 	at org.junit.platform.launcher.listeners.discovery.AbortOnFailureLauncherDiscoveryListener.selectorProcessed(AbortOnFailureLauncherDiscoveryListener.java:39) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:102) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:82) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:113) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:45) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:69) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:181) 	... 10 more Caused by: java.lang.NoClassDefFoundError: zipkin2/storage/StorageComponent$Builder 	at java.base/java.lang.Class.getDeclaredMethods0(Native Method) 	at java.base/java.lang.Class.privateGetDeclaredMethods(Class.java:3167) 	at java.base/java.lang.Class.privateGetPublicMethods(Class.java:3192) 	at java.base/java.lang.Class.getMethods(Class.java:1905) 	at org.junit.platform.commons.util.ReflectionUtils.getDefaultMethods(ReflectionUtils.java:1440) 	at org.junit.platform.commons.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:1413) 	at org.junit.platform.commons.util.ReflectionUtils.findAllMethodsInHierarchy(ReflectionUtils.java:1355) 	at org.junit.platform.commons.util.ReflectionUtils.findMethods(ReflectionUtils.java:1339) 	at org.junit.platform.commons.util.ReflectionUtils.findMethods(ReflectionUtils.java:1325) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.lambda$toResolution$12(ClassSelectorResolver.java:136) 	at org.junit.platform.engine.support.discovery.SelectorResolver$Match.expand(SelectorResolver.java:646) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$enqueueAdditionalSelectors$1(EngineDiscoveryRequestResolution.java:109) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.Collections$2.tryAdvance(Collections.java:4747) 	at java.base/java.util.Collections$2.forEachRemaining(Collections.java:4755) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.enqueueAdditionalSelectors(EngineDiscoveryRequestResolution.java:108) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:94) 	... 15 more Caused by: java.lang.ClassNotFoundException: zipkin2.storage.StorageComponent$Builder 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:602) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	... 39 more ```  ## versions  The junit / junit-vintage / jupiter versions are all declared in the root pom:  https://github.com/openzipkin/zipkin/blob/52a1943581446d3b21759cef65cd471cdc5e6ca3/pom.xml#L77","closed","3rd-party: Maven Surefire,","jorgheymans","2020-08-10T20:08:12Z","2020-08-11T13:21:13Z"
"","2462","[junit-platform] Add interrupt/cancellation support","As part of the Bndtools project we've been working on an interactive OSGi testing environment based on JUnit Platform. It supports hot re-deployment of code (both application code and test code) and re-running of the tests without having to restart the framework. This is extremely useful for speeding up the development cycle for integration tests of code in the framework when that framework has a long startup time. It makes the Test-Driven Development cycle much more feasible and efficient.  While it is clear that JUnit was not originally designed with interactivity in mind, nevertheless it seems to work pretty well for the most part. But there is one major feature missing from JUnit Platform that would make it work even better, and that's the lack of a reliable cancellation mechanism - once the launcher has started executing a `TestPlan`, there is no reliable way to stop it. In an interactive scenario, I have often found that I start a new test run only to notice that the tests all start failing due to some bug I introduced. I find and fix the bug, but then I still have to wait a minute or so for the test plan to finish executing before I can run the tests again. Alternatively, I have to terminate the container and restart it (which is usually even slower). What I would really like is to be able to cancel the test run once I notice the first few failures so that I don't have to wait before restarting it with the fix included.  It seems to me that this would not be a difficult feature to add, although it probably couldn't be implemented in the platform alone - it would need each individual engine to support it too. As a quick idea:  * `Launcher.execute()` will require an asynchronous variant that returns an object representing the current execution (`LauncherExecutionHandle`, perhaps). This interface implemented by this object would contain (among possible other things) a `cancel()` method. * `TestEngine` will likewise require an asynchronous variant that returns an object representing the current engine execution (`EngineExecutionHandle`). This too would contain a `cancel()` method. * It is possible that the execution handles could simply extend or contain a `Future` to facilitate this.  An alternative is to assume that a `Launcher` and a `TestEngine` can only have one concurrent execution, and simply add the `cancel()` method to these interfaces.  Thoughts?","closed","","kriegfrj","2020-10-26T02:21:33Z","2020-10-26T13:37:17Z"
"","2825","Document that test engines should use a unique namespace for their properties","As mentioned in https://github.com/junit-team/junit5/issues/2819#issuecomment-1029910273, all test engines should prefix the names of their configuration properties with their engine id.  We should document that recommendation in the test engine section of the user guide.","closed","component: Platform,","juliette-derancourt","2022-02-06T17:29:54Z","2022-03-06T14:37:05Z"
"","2976","Support timeouts for extensions","As https://github.com/junit-team/junit5/issues/2037 was closed as stale and I did not want to ping a random person of the junit team there, I decided to create a new issue. Feel free to close this one and open the old one if you want to proceed the discussion there.  The feature request is to unify the definition of timeouts for extensions with the definition of timeouts in the test classes. - Using `@Timeout` for extension methods (Before/AfterEach/AllCallback) - Using global timeouts such as `junit.jupiter.execution.timeout.beforeall.method.default` applies to extension methods   (maybe add a new property like `junit.jupiter.execution.timeout.extension.beforeall.default` which would make backwards compatibility easier.  While one can workaround with assertTimeoutPreemptively, it would be great if extensions follow the same timeout principles of being able to configure global default timeouts and overwriting them on specific methods if necessary. From the above 2 points the second point is the more important one (the other one would still be great for consistency reasons). Currently it is not possible to avoid stuck CI builds entirely by defining global timeout properties and all extensions need to carefully implement timeouts themselves (which is desired, but global timeouts for safety would be great).","open","status: new,","SgtSilvio","2022-07-11T16:23:46Z","2022-07-11T16:24:41Z"
"","2594","Discover tests in suites packaged into jars, e.g. TCKs","As discussed [in the discussions](https://github.com/junit-team/junit5/discussions/2589), we need a way to package a test suite into a jar and run it for several implementations. This is a common requirement when building Technology Compatibility Kits. There are generally three artifacts:  1. `api` contains some interfaces and a `ServiceLoader` (or similar IoC mechanism) to load an implementation of the api interfaces. 2. `impl1` containing one implementation (sometimes called a reference implementation `ri`) of the `api`; includes the `services` files for the `ServiceLoader`. 3. `tck` the test suite to check that an implementation of the api is compliant.  You can run the tests in the `tck` by adding a `runtime` dependency on `impl1`. But the tck should be usable by any other implementation as well: I want the `impl1` to load the `tck`-jar and run it, not the other way around. The `tck` should be a library of tests that the implementations can include as a `test` dependency. The dependency should be `impl1→tck` not `tck→impl1`.  I assume that scanning all jars for tests would result in unacceptable performance, so we probably need some way to specify the jars to scan, or even better to mark a jar to be a test-suite.  I currently need this for an open source project: https://github.com/t1/smallrye-graphql It's about the TCK in the client. But I've also built a minimal, reproducible example that may be easier to play around with: https://github.com/t1/junit-tck-mre.  ## Deliverables  - [ ] A mechanism to specify the jars to scan for tests - [ ] Update to the User Manual","closed","status: stale,","t1","2021-04-12T06:26:30Z","2022-07-02T11:53:17Z"
"","2819","Feedback when Suite does not contain tests or IncludeEngines does not find engine","As a user I want to use the Junit5 way to start a cucumber engine test by using a Suite and I want to get feedback from Junit when I made a configuration mistake.  Example code:   ```java import static io.cucumber.core.options.Constants.GLUE_PROPERTY_NAME; import static io.cucumber.core.options.Constants.PLUGIN_PROPERTY_NAME;  import org.junit.platform.suite.api.ConfigurationParameter; import org.junit.platform.suite.api.IncludeEngines; import org.junit.platform.suite.api.SelectClasspathResource; import org.junit.platform.suite.api.Suite;  @Suite @IncludeEngines(""cucumber"") @SelectClasspathResource(""com/somepackage"") @ConfigurationParameter(key = GLUE_PROPERTY_NAME, value = ""com.somepackage"") @ConfigurationParameter(key = PLUGIN_PROPERTY_NAME, value = ""pretty"") public class RunCucumberTest {  }  // Old Junit4 style: // // import org.junit.runner.RunWith; // // import io.cucumber.junit.Cucumber; // import io.cucumber.junit.CucumberOptions; // // @RunWith(Cucumber.class) // @CucumberOptions(plugin = ""pretty"", features = ""classpath:com/somepackage"") // public class RunCucumberTest { // // Makes JUnit run all JUnit tests // } ```  ## Deliverables  It would be very useful to make a build fail when: - Suite does not run any tests at all. - IncludeEngines fails to find the correct engine, e.g. when I enter 'cucumper' for which there is no engine on the classpath. - SelectClasspathResource fails to find the resource folder - ConfigurationParameter defines a parameter which is not used (this is maybe too much to ask)  In my case: - I failed to configure the cucumber engine correctly in my maven dependencies but I was not warned that less unit tests were running. - I am afraid that if someone refactors a feature file resource folder the test might no longer be executed, the empty suite could warn me.","closed","theme: suites,","escay","2022-02-03T16:11:38Z","2022-02-06T17:32:45Z"
"","2520","Add capability to get all configuration parameters","As a test engine provider I'd like to check if users trying to provide the engine with parameters use the correct parameter keys and warn about unknown keys or potential spelling errors. In order to check that, I need some way to get at all configuration parameters - or at least those specified in file `junit-platform.properties` - with my engine's prefix, e.g. ""jqwik."".   The signiature could look like:  `Set ConfigurationParameters.allWithPrefix(String prefix)`  Maybe class `org.junit.platform.engine.support.config.PrefixedConfigurationParameters` is the better place for such a method?","closed","theme: discovery,","jlink","2021-01-09T10:56:39Z","2022-05-15T17:50:52Z"
"","2344","Provide more direct access to actual results in EngineExecutionResults","As a follow-up to #2343:  In our `DynamicNodeGenerator` implementation, we had to jump through some hoops to re-create the test hierarchy, as the information is not directly provided by the testkit's `EngineExecutionResults`. I think it would be useful if `EngineExecutionResults` provided access to the following:  1. Access to the root `TestDescriptor` generated by the execution run; 2. A mapping function which, when supplied with a `TestDescriptor` instance, will return the corresponding `TestExecutionResult` instance generated for that test.  For example:  ```java public class EngineExecutionResults {   public TestDescriptor getRootDescriptor() {...}    public TestExecutionResult getResultFor(TestDescriptor test) {...}    // Although we didn't have a need for it, the following two would be useful in other cases too:   public ReportEntry getReportEntryFor(TestDescriptor test) {...}    public String getSkippedReasonFor(TestDescriptor test) {...} } ```  In this way, rather than the meta-test needing to be concerned about verifying the order and correctness of low-level test events (something that I believe that `ExecutionRecorder` should handle directly), they can be more concerned about examining and asserting on the the actual test results (which are more likely to be of interest to a higher-level test). Assertion frameworks like AssertJ and Truth can then also come up with their own custom assertions that operate directly on the test results.","closed","status: stale,","kriegfrj","2020-06-26T02:09:16Z","2022-07-12T23:11:06Z"
"","2023","Introduce declarative mechanism for failing a test if it does not throw an exception","Annotation based Assumptions, e.g. ``` @Test @Assumption(failOnPass=true) ``` So that we don't have to rewrite all the assumeThat's to assertThat's and perhaps more importantly so that all test frameworks (assertj, spring, etc) don't have to implement an assume for everything.","closed","status: stale,","xenoterracide","2019-09-23T16:43:19Z","2022-07-12T23:11:09Z"
"","2024","Add missing 'not' in @Timeout documentation","Although I haven't verified the behaviour in code, the context of the sentence indicates that the 'not' is missing. If that is not the case, then the sentence is confusing as it is.  ## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","davidburstrom","2019-09-23T17:52:20Z","2019-09-24T09:36:38Z"
"","2277","TELs 'reportingEntryPublished' not triggered from extension context","After chatting with @sormuras  on Gitter he asked me to open an issue:  Background: My goal is to create an annotation and create a report where the name of a test, it's result and the value of the annotation is published. @marcphillip suggested to use a `TestExecutionListener` for creating the report.  So whats done so far is:  1. Created an annotation (okay I used an existing from our project) which publishes the values into the extension context (`context.publishReportEntry(...)`).   This is a simple extension, which publishes the annotations values into the extensions context:  ``` 	@Override 	public void beforeEach(ExtensionContext context) throws Exception { 		PioneerAnnotationUtils 				.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class) 				.peek(ReportEntryExtension::verifyKeyValueAreNotBlank) // Not shown, but you get it by the name 				.forEach(entry -> context.publishReportEntry(entry.key(), entry.value())); 	} ```    This is a test method of the extension:  ```   @Test   void explicitKey_keyAndValueAreReported() {     List> reportEntries = executeTestMethod(ReportEntriesTest.class, ""explicitKey"")         .publishedTestReportEntries();      assertThat(reportEntries).hasSize(1); // Line 31     Map reportEntry = reportEntries.get(0);     assertThat(reportEntry).hasSize(1);     assertThat(reportEntry).containsExactly(TestUtils.entryOf(""Crow2"", ""While I pondered weak and weary""));   }    ``` with executes the following test  ```   static class ReportEntriesTest {    @Test   @ReportEntry(key = ""Crow2"", value = ""While I pondered weak and weary"")   void explicitKey() {   } }  ```   This works fine. The test checks the published entries inside if they are correctly published and they are.  2. I than created a `TestExecutionListener` (TEL), registered it in META-INF and implemented the `executionStarted`, `reportingEntryPublished` and `executionFinished` with simple `System.out.printlin()` to check if they are called the way the docs say  ``` public class PioneerReportListener implements TestExecutionListener {    @Override   public void executionStarted(TestIdentifier testIdentifier) {      if(null != testIdentifier) {       String msg = ""Starte: "" + testIdentifier.getDisplayName();       System.out.println(msg);     }   }      @Override   public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {     String msg = String.format(""Entry %s for test %s was published"", entry.toString(), testIdentifier.getLegacyReportingName());      System.out.println(msg);    }      @Override   public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {      if(testIdentifier.isTest()) {       String result = String.format(""test %s result is %s"", testIdentifier.getLegacyReportingName(), testExecutionResult.getStatus().toString());        System.out.println(result);     }    } } ```  The `executionStarted` and `executionFinished` are work fine, but the `reportingEntryPublished` does not. When an report entry is published via an extension context the callback method is **NOT** called. It's only called when the test method uses a `TestReporter` parameter (@sormuras asked me to test the same using a `TestReporter`) and publishes an entry via `testreporter.publishEntry()`.  When taken the test method above the console output is:  > Starte: explicitKey_keyAndValueAreReported() >  > test explicitKey_keyAndValueAreReported() result is SUCCESSFUL >  > Starte: JUnit Jupiter > Starte: ReportEntryExtensionTest  As seen the `reportingEntryPublished` is not called.  If I change the indirectly called test method to:  ``` 		@Test 		@ReportEntry(key = ""Crow2"", value = ""While I pondered weak and weary"") 		void explicitKey(TestReporter reporter) { 			reporter.publishEntry(""Hello Junit!""); 		} ```  the output is:  > Starte: explicitKey_keyAndValueAreReported() >  > test explicitKey_keyAndValueAreReported() result is FAILED >  >  > java.lang.AssertionError:  > Expected size:<1> but was:<0> in: > <[]> >  > 	at org.junitpioneer.jupiter.ReportEntryExtensionTest.explicitKey_keyAndValueAreReported(ReportEntryExtensionTest.java:31) >  > Starte: JUnit Jupiter > Starte: ReportEntryExtensionTest   Again the `reportingEntryPublished` is not called and the `assertThat(reportEntries).hasSize(1);` failes. This seems odd, as I would have expected two published report entries but not zero.  When the `TestReporter` is used on the test method which is actually executed (instead on using it on the indirectly test method:  ``` 	@Test 	void explicitKey_keyAndValueAreReported(TestReporter reporter) { 		reporter.publishEntry(""Hello Junit!"");      		List> reportEntries = executeTestMethod(ReportEntriesTest.class, ""explicitKey"") 				.publishedTestReportEntries();  		assertThat(reportEntries).hasSize(1); 		Map reportEntry = reportEntries.get(0); 		assertThat(reportEntry).hasSize(1); 		assertThat(reportEntry).containsExactly(TestUtils.entryOf(""Crow2"", ""While I pondered weak and weary"")); 	}     		@Test 		@ReportEntry(key = ""Crow2"", value = ""While I pondered weak and weary"") 		void explicitKey() { 		} ```  the output is the following:  > Starte: explicitKey_keyAndValueAreReported(TestReporter) >  > Entry ReportEntry [timestamp = 2020-04-27T14:08:16.277396800, value = 'Hello Junit!'] for test explicitKey_keyAndValueAreReported(TestReporter) was published > timestamp = 2020-04-27T14:08:16.277396800, value = Hello Junit!test explicitKey_keyAndValueAreReported(TestReporter) result is SUCCESSFUL  > Starte: JUnit Jupiter > Starte: ReportEntryExtensionTest  As seen the callback is called but only for the published entry of the `TestReporter` not for the entry of the extension.","closed","component: Jupiter,","Bukama","2020-04-27T12:17:10Z","2020-05-03T17:11:27Z"
"","2544","Add Provide-Capability OSGi header to engine bundles","Adds * `Provide-Capability: org.junit.platform.engine;org.junit.platform.engine=junit-vintage;version:Version=""${project.version}""` to `junit-vintage-engine` * `Provide-Capability: org.junit.platform.engine;org.junit.platform.engine=junit-jupiter;version:Version=""${project.version}""` to `junit-jupiter-engine`  Fixes #2100.  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","kriegfrj","2021-02-04T07:19:12Z","2021-05-14T12:02:54Z"
"","2770","Introduce TestInstancePreCreateCallback extension point","Addresses #2733  ----  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","dweiss","2021-11-04T09:22:11Z","2021-11-14T12:38:08Z"
"","2750","Use Gradle Build Action","Additionally, this commit adds build scan tags to all main builds.","closed","","marcphilipp","2021-10-24T15:56:28Z","2021-10-29T07:27:00Z"
"","2007","[Event] Add talk at Devoxx Belgium","Adding a talk for upcoming Devoxx in Antwerp","closed","","juliette-derancourt","2019-09-12T20:38:30Z","2019-09-12T22:37:43Z"
"","1981","Make LegacyXmlReportGeneratingListener configurable","Added ability to change the behavior of when XML files are written. Implements #1980.  This is a sample implementation (as mentioned in #1980) using a `Function<>` member rather than a protected method.  Happy to change this to use a protected method if this is considered a superior solution.","closed","","kriegfrj","2019-08-12T13:33:47Z","2019-09-18T19:13:50Z"
"","2792","Allow specifying ForkJoinPool saturate predicate","Add the method getSaturatePredicate to the interface ParallelExecutionConfiguration. This allows a custom configuration to supply a predicate to handle the case where the ForkJoinPool has reached the maximum pool size but all threads are currently blocked. Add a constructor to DefaultParallelExecutionConfiguration allowing to speciy the predicate and modify the existing constructor to specify null for the predicate. Modify DefaultParallelExecutionConfigurationStrategyTests to check the saturate predicate value in the default and custom configurations.  Issue: #2787 ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","component: Platform,","klease","2021-12-10T22:18:15Z","2022-04-10T20:46:26Z"
"","2415","Run code before all / after all tests","Add ability to run a code before all tests and after all tests. For example, it could be needed to prepare data before test run or clean data after the whole test run. Annotation BeforeAll is executed only before a class, but it's needed to run code before all test run. Similar to TestNG - BeforeSuite annotation.  As you can it's really popular issue: https://stackoverflow.com/questions/43282798/in-junit-5-how-to-run-code-before-all-tests/51556718#51556718  People try to solve this issue by introducing variable boolean started = false; But it's not useful, when it's needed to clean the whole db, after all tests.","closed","status: duplicate,","arturmkr","2020-09-21T14:11:50Z","2020-09-21T14:22:09Z"
"","2823","Add `failIfNoTests` attribute to `@Suite`","Add `failIfNoTests` attribute to `@Suite`. The default value should be `true` since that would benefit more users in the future.  Issue opened following decision taken in https://github.com/junit-team/junit5/issues/2819#issuecomment-1029910273.","closed","theme: suites,","juliette-derancourt","2022-02-06T17:19:33Z","2022-04-08T10:35:13Z"
"","2933","Add @DisabledIf example for headless environments to User Guide","Add `@DisabledIf(value = ""java.awt.GraphicsEnvironment#isHeadless"", disabledReason = ""headless environment"")` as an example in the User Guide.  We could consider adding `@EnabledIf` and `@DisabledIf` examples side by side for comparison.  See #2855 for background.","closed","component: Jupiter,","sbrannen","2022-05-29T16:09:37Z","2022-06-05T14:09:18Z"
"","2510","Remove Codecov token","According to their docs, GH Actions workflows don't require a token.","closed","","marcphilipp","2020-12-28T08:10:21Z","2020-12-28T09:06:05Z"
"","2628","EclipseRunner creates fresh root ExtensionContext per package","According to https://stackoverflow.com/questions/49532885/with-junit-5-how-to-share-information-in-extensioncontext-store-between-test all subsequent tests of one test run should share the same extension context. The eclipse runner (and maybe also others) seems to create a new ExtensionContext every time a new package is entered.  This meens that instances cannot be shared via root context store, since even the context is not shared.  ## Steps to reproduce    [bugs.zip](https://github.com/junit-team/junit5/files/6559233/bugs.zip) Running attached tests with the eclipse junit 5 runner results in following output  ``` ------------------------------ org.junit.jupiter.engine.descriptor.JupiterEngineExtensionContext@1aafa419:Optional[class com.enbw.eop.constructors.bugs.package1.Test1] ------------------------------ ------------------------------ org.junit.jupiter.engine.descriptor.JupiterEngineExtensionContext@55182842:Optional[class com.enbw.eop.constructors.bugs.package2.Test2] ------------------------------ ```  Thus there are different root context in the same test run.   ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit 5.7.2 (Jupiter + Platform)  - Build Tool/IDE: Eclipse  ## Deliverables [bugs.zip](https://github.com/junit-team/junit5/files/6559236/bugs.zip)","closed","3rd-party: Eclipse,","almondtools","2021-05-28T07:59:12Z","2021-05-28T08:42:36Z"
"","2878","AllBooleanCombinationsSource arguments provider","A common use case we have is a test that take a bunch of boolean flags a check very slightly (mostly in expected value) based on this flag. Classic for a ParameterizedTest, which is what we use today, but for the source we currently use CsvSource with the boolean options: ``` @ParameterizedTest @CsvSource({    ""true, true"",    ""true, false"",    ""false, true"",    ""false, false"" }) public void testMethod(boolean flag1, boolean flag2) ``` Which is annoying, verbose and error-prone. So I wanted to implement an annotation like `@AllBooleanCombinationsSource(int)` that takes the number of boolean params and generate all possible combinations. Though this might be a bit too specific, so wanted to get your opinion, is that something that you think belongs in Junit?","open","status: new,","tomerr90","2022-04-07T13:49:25Z","2022-05-27T14:38:47Z"
"","2074","A DynamicTest should support annotations just like @Test methods","A `DynamicTest` should support Annotations just as any other Test -- for example, `@Disabled`.  I'd expect that the Test Results should show the items Passed, Failed, and Skipped (as in Disabled).  Unless there's already a way to do this and I missed it...   Thanks all!!","closed","component: Jupiter,","kirkpabk","2019-10-21T18:10:40Z","2019-11-03T13:55:36Z"
"","2417","ParameterizedTest formatting is Locale-sensitive","`ParameterizedTest` with name pattern specified relies on `Locale.getDefault()`. This results in test names that possibly changing:  ``` public class SimplifiedExample {     @BeforeAll     static void before_all() { Locale.setDefault(Locale.US); }      @BeforeEach     void before_each() { Locale.setDefault(Locale.UK); }      @ParameterizedTest(name = ""{0,number,currency}"")     @ValueSource(ints = { 1_000, 2_000 })     void test1(int a)     {         // Test names with locale change:         // $1,000.00         // £2,000.00     } }  ``` It seems the first `MessageFormat` is created after the call to `BeforeAll` and before the call to `BeforeEach`. As the `Locale` cannot be set for a `ParameterizedTest` your stuck with whatever the environments current default is.   It seems that the limited formatting is already down the ""rabbit hole"" @marcphilipp #1154  Add to this that the arguments formatted are those supplied by the provider before implicit or explicit conversion and not those supplied to the method then formatting is not very useful and certainly breaks the principle of least surprise.  As such I propose that formatting should support only place holders '{0} {1} etc...' until such time that @sbrannen #1154 support for formatting API is added.","closed","theme: parameterized tests,","johnsoneal","2020-09-22T08:40:53Z","2020-10-30T11:53:02Z"
"","1980","LegacyXmlReportGeneratingListener to have configurable roots","`LegacyXmlReportGeneratingListener` generates one xml report file per root `TestIdentifier` instance in the in the `TestPlan` being executed. The file name is of the form `Test-nnnn.xml` where `nnn` is the name of the root node.  I recently encountered a situation where I would have liked to be able to change both the number of files generated, and the algorithm used to derive their filenames. Unfortunately, `LegacyXmlReportGeneratingListener` has been written in such a way to make this impossible without extensive use of reflection, as the necessary methods that need to be overridden are all private:  https://github.com/junit-team/junit5/blob/7dc2df5cede39eafe17f0cc026f7dfdcc96215ee/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListener.java#L102-L127  `executionFinished()` (and `executionSkipped()`) both call `writeXmlReportInCaseOfRoot()` to do the (optional) writing of an xml file. It would be ideal to simply tap into it here somewhere, but being private makes it impossible without reflection.  ## Proposal  1. Combine the functionality of `isRoot()` and the code that extracts the root name in `writeXmlReportInCaseOfRoot()`. This could be done by having a single method which returns an `Optional` - empty indicates a non-root (no file to be written), a string indicates the name to use in the test file. Say we call it `getRootFileName(TestIdentifier)`. 2. Make it possible to override `getRootFileName(TestIdentifier)`, either by:    1. making it `protected` method and thereby allowing a subclass to override it, or else    2. by making it a field of type `Function, TestIdentifier>` and initializing it to the current implementation in the constructor by default.","closed","theme: reporting,","kriegfrj","2019-08-12T13:09:36Z","2019-09-19T20:22:14Z"
"","2457","Add possibility to register launcher-discovery listeners via SPI","`LauncherDiscoveryListeners` can now be registered via Java's `ServiceLoader` mechanism in addition to those passed as part of each `LauncherDiscoveryRequest` and the default one.  ## Overview    The idea of this PR is to enable registering `LauncherDiscoveryListener` through an SPI. I am creating this PR in order to hear the opinion of the JUnit Team. Is something like this acceptable for you? If it is I am going to add add the documentation and finish whatever needs to be finished from your feedback.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","filiphr","2020-10-21T18:06:15Z","2021-02-11T11:40:35Z"
"","2003","Some published artifacts contain module-info.class instead of module-info.java","`junit-platform-commons-1.5.1-sources.jar` downloaded from Maven Central has `module-info.class` instead of `module-info.java`.  This same problem might occur in other files & other versions.","closed","component: Vintage,","rgoldberg","2019-09-07T02:11:09Z","2019-09-07T15:32:38Z"
"","2338","InvocationInterceptor does not intercept @ParameterizedTest methods","`InvocationInterceptor` does not intercept methods annotated with `@ParameterizedTest`, but works fine on `@Test` methods with parameters and a custom `ParameterResolver`.  Is there a way to intercept `@ParameterizedTest` method?  ## Steps to reproduce  ```java class EveryTestFails implements Extension, InvocationInterceptor {     @Override     public void interceptTestMethod(         Invocation invocation,         ReflectiveInvocationContext invocationContext,         ExtensionContext extensionContext     ) throws Throwable {         Assertions.fail();     } }  @ExtendWith(EveryTestFails.class) public class StreamTest {      @Test     void failsAsExpected() {          // THIS FAILS     }      @ValueSource(ints = {1,2,3})     @ParameterizedTest     void failsAsExpected(final int x) {         // THIS DOES NOT FAIL     } } ```  ## Context   - Used versions (Jupiter/Vintage/Platform):  5.7.0-M1","closed","type: question,","andreoss","2020-06-24T19:27:18Z","2020-10-26T06:53:15Z"
"","2370","Non-experimental types are listed in the Experimental API overview","`DisplayName` is included in this table. https://junit.org/junit5/docs/snapshot/user-guide/#api-evolution-experimental-apis ![image](https://user-images.githubusercontent.com/2319838/89122770-6919c400-d4ca-11ea-833a-e0ba7b1f1607.png)   `DisplayName` is marked as `STABLE`: https://junit.org/junit5/docs/snapshot/api/org.junit.jupiter.api/org/junit/jupiter/api/DisplayName.html ![image](https://user-images.githubusercontent.com/2319838/89122794-a1210700-d4ca-11ea-86c6-9828f5f7dbf5.png)","closed","theme: documentation,","sormuras","2020-08-02T12:16:37Z","2020-08-02T13:04:11Z"
"","2420","Provide mechanism to control whether or not to trim whitespace in @CsvSource and @CsvFileSource","`CsvArgumentProvider` does not support configuration of the underlying `CsvParser` by univocity.  ## Steps to reproduce  ```java     @ParameterizedTest     @CsvSource(         ""        SW34NT,SW34NT   ""     )     fun test(one: String, two: String) {         assertThat(one).isEqualTo(two)     }  ```  This should **NOT** work, or at least the behavior should be configurable:  CsvParserSettings.ignoreTrailing/LeadingWhitespace = false  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.7.0  - Build Tool/IDE: IntelliJ  ## Deliverables  - [ ] ...","closed","theme: parameterized tests,","dmsergeevN26","2020-09-23T09:05:32Z","2021-01-15T21:00:25Z"
"","2211","CloseableResource invocation order","`CloseableResource`s should be closed in the inverse order of insertion.  Actually `close()` is executed in random order, since the values are stored in a  `ConcurrentHashMap`.  `storedValues = new ConcurrentHashMap<>(4);`","closed","component: Jupiter,","jflefebvre06","2020-03-11T11:01:50Z","2020-09-12T11:45:54Z"
"","2915","assertIterableEquals: StackOverflow for self-iterating Iterable","`assertIterableEquals`can lead to a StackOverflowError for `Path` or general for `Iterable` that iterates over itself. This is similar to the issue #2157. The PR to this issue fixes the success case only.   I created a PR with a possible fix and test.  ## Steps to reproduce  ```java @Test void assertIterableEqualsWithDifferentListOfPath() { 	try { 		var expected = listOf(Path.of(""1""), Path.of(""2"").resolve(""3""), Path.of(""5"")); 		var actual = listOf(Path.of(""1""), Path.of(""2"").resolve(""4""), Path.of(""5"")); 		assertIterableEquals(expected, actual); 		expectAssertionFailedError(); 	} 	catch (AssertionFailedError ex) { 		assertMessageEquals(ex, ""iterable contents differ at index [1][1][0], expected: <3> but was: <4>""); 	} } ``` ## Context   - Used versions (Jupiter/Vintage/Platform): junit-jupiter-api/junit-jupiter-engine 5.8.2  - Build Tool/IDE: Maven  ## Deliverables  - [x] Provide fix and test for comparing `Iterable>` instances.  ---  I hereby agree to the terms of the JUnit Contributor License Agreement.","closed","component: Jupiter,","thomaszub","2022-05-13T06:22:52Z","2022-06-19T13:12:34Z"
"","2163","@TestInstance(PER_CLASS) @BeforeAll should be executed last","`@TestInstance(TestInstance.Lifecycle.PER_CLASS)` `@BeforeAll` should be executed only after all other `@BeforeAll` annotated extensions. And correspondingly, `@AfterAll` first.  ## Real world example: When using a static (i.e. shared) testcontainer it should already be started before it is accessed in a test class specific `@BeforeAll` method.  ```java @Testcontainers abstract class TestWithPostgres {     @Container     static PostgreSQLContainer postgresqlContainer = new PostgreSQLContainer(); }  @TestInstance(TestInstance.Lifecycle.PER_CLASS) public class SomeTest extends TestWithPostgres {    @BeforeAll   public void prepareTestData() {     postgresqlContainer.getJdbcUrl();     [...]   } } ```  Note, `@Testcontainers` triggers an extension that uses `@BeforeAll` for starting the container.","closed","component: Jupiter,","KaiStapel","2020-01-24T12:54:50Z","2020-01-24T15:39:34Z"
"","2497","Parallelization control of DynamicNode","`@TestFactory` can return a stream of `DynamicContainers` and `DynamicTest`.  It would be awesome if we could run containers in parallel, but the tests within containers on the same thread.  The `@Execution` seems to only allow you to switch from everything parallel/concurrent or everything on the same thread.  The configuration parameters `junit.jupiter.execution.parallel.mode.default` and  `junit.jupiter.execution.parallel.mode.classes.default` also don't seem to allow such a configuration, probably because all test suites and test are coming from the same `class`.  For example: the following should allow tests `test1` and `test2` that are in `suite1` to be run on the same thread, and the tests in `suite2` to be run on a different, but consistent thread:  ```java static class Runner {      @TestFactory     Stream systemTest() {         final Stream tests1 = Stream.of(                         DynamicTest.dynamicTest(""test1"", () -> {System.out.println(Thread.currentThread().getId() + "" -test1"");}),                         DynamicTest.dynamicTest(""test2"", () -> {System.out.println(Thread.currentThread().getId() + "" - test2"");}));          final Stream tests2 = Stream.of(                         DynamicTest.dynamicTest(""test3"", () -> {System.out.println(Thread.currentThread().getId() + "" -test3"");}),                         DynamicTest.dynamicTest(""test4"", () -> {System.out.println(Thread.currentThread().getId() + "" - test4"");}));          return Stream.of(                 DynamicContainer.dynamicContainer(""suite1"", tests1),                 DynamicContainer.dynamicContainer(""suite2"", tests2));     } } ```  Maybe this could be achieved via one or more of:   * a new `junit.jupiter.execution.parallel.mode.container.default` property   * a field on `@TestFactory` to control execution   * an enhancement to `@Execution`   * a parameter to `DynamicContainer`  Thanks!","open","theme: dynamic tests,","big-andy-coates","2020-12-18T10:17:49Z","2021-09-16T11:10:58Z"
"","2079","@TempDir is not evaluated when running tests in nested test classes","`@TempDir` annotations are only evaluated when declared in the same class as the test. Using `@TempDir` annotations in enclosing classes of the test class should also work.   I have provided a pull request (#2080) of a fix.  ## Steps to reproduce  ```java class TempDirInNestedClass {      @TempDir     File tempDir;      @Nested     class NestedTestClass {     @Test         void test() {             assertNotNull(tempDir);             assertTrue(tempDir.exists());         }     } }  ```   ## Context   - tested with junit 5.6.0-M1","closed","component: Jupiter,","okuhn","2019-10-23T19:18:02Z","2019-12-17T09:30:46Z"
"","1996","Introduce @YamlFileSource similar to @CsvFileSource","`@CsvFileSource` is useful, but structured data structures are not supported.  I suggest to add a `@YamlFileSource` for explicit YAML support like `@CsvFileSource` to support structured data structures.  I have created a little demo locally, but it may not be complete. I want to know what everyone thinks.","closed","theme: parameterized tests,","RunningSanil","2019-08-31T08:02:06Z","2019-09-01T14:28:08Z"
"","2360","@BeforeEach and @AfterEach aren't reliably executed around dynamic tests","`@BeforeEach` and `@AfterEach` aren't executed around each dynamic test. They are executed only once per `@TestFactory`. I would expect that they are reliably run around each dynamic test.  I tested on both IntelliJ 2020.1.3 and Maven 3.6.1. What's baffling is that the results are different on each platform.  On IntelliJ, with the snippet below, I get the following output:      before     after     Hello     World  On Maven, I get the following output:      before     Hello     World     after  I would expect that `@BeforeEach` and `@AfterEach` are executed around each test, dynamic or not:      before     Hello     after     before     World     after  ## Steps to reproduce  ``` import java.util.stream.Stream; import org.junit.jupiter.api.*; public class DynamicTestTest {  	@BeforeEach 	void beforeEach() { 		System.out.println(""before""); 	} 	@AfterEach 	void afterEach() { 		System.out.println(""after""); 	}  	@TestFactory 	Stream tests() { 		return Stream.of(""Hello"", ""World"") 				.map(word -> DynamicTest.dynamicTest(word, () -> System.out.println(word))); 	}  } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.7.0-M1, Platform 1.7.0-M1  - Build Tool/IDE: Maven (3.6.1), IntelliJ (2020.1.3)","closed","","ogregoire","2020-07-23T20:10:01Z","2020-07-25T11:20:57Z"
"","2924","Introduce TestSourceLocator for DynamicTests","_This issue has been created following @ST-DDT's pull request #2431._   ## Overview  With dynamic tests in large classes (`TestClass`) it is difficult to find out where they were actually defined. The containing/declaring method (`testMethod()`) helps to get a rough understanding of the source of the test and assertion stacktrace shows where it went wrong, but dynamic tests are meant to test different setups/environment/instances and might be generated/inherited from a different method or class, so it would be nice if double-clicking the test would show the actual source (`""setup3""`) of the dynamic test.  ## Usage-Example  - ❌ TestClass (a)   - ❌ testMethod (b)     - ✔️ setup1     - ✔️ setup2     - ❌ setup3 `<-- This is where I (probably) need to do things`     - ✔️ setup4  ````java class TestClass {      @TestFactory     List testMethod() {         return asList(                  dynamicTest(""setup1"", () -> { // Might be created in a factory method                         // [...]                 }),                  dynamicTest(""setup2"", () -> { // or inherited from a parent class                         // [...]                 }),                  dynamicTest(""setup3"", () -> { // <--- I wish to get here (wherever ""here"" might be, e.g. in another/super method or class)                         // [...]                        assert(foo, bar); // The assertion fails here                         // [...]                 }),                  dynamicTest(""setup4"", () -> {                         // [...]                 }),          ).map(this::resetMocks);     }  } ````  ## Proposition  Add a `TestSourceLocator` that automatically calculates a testSourceUri if none is specified. See implementation in #2431.","open","status: new,","juliette-derancourt","2022-05-22T15:39:02Z","2022-05-22T15:39:36Z"
"","2244","IsTestableMethod silently ignores @Test annotated methods that return a value","[`IsTestableMethod`](https://github.com/junit-team/junit5/blob/master/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java) silently ignores `@Test` annotated methods that return a value (or are static or are private).  `IsTestClassWithTests` uses `IsTestMethod` to discover tests. `IsTestMethod` is a subclass of `IsTestableMethod` that sets `IsTestableMethod.mustReturnVoid` to `true`.  If you annotate a method with `@Test` it's clear you want it run as a test. So if you've mistakenly annotated a method that doesn't conform to the requirements of a test then this should result in an error. It shouldn't be just a warning, it should actively fail the test run. However, at the moment such methods are simply _silently_ ignored.  ## Steps to reproduce  Run the following test class, it contains four tests but only one of them will be run. There is no warning or indication that the other three have been skipped - they are silently ignored despite being annotated with `@Test`. One is ignored because it returns a value, one because it's `static` and one because it's `private`.  ```Java package example;  import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.assertEquals;  public class SilentlyIgnoredTests {     @Test     public void testNonIgnored() {         assertEquals(42, 42);     }      @Test     public boolean testIgnoredDueToReturnType() {         assertEquals(42, 0);          return true;     }      @Test     public static void testIgnoredDueToStatic() {         assertEquals(42, 0);     }      @Test     private void testIgnoredDueToPrivate() {         assertEquals(42, 0);     } } ```  This issue came up in Kotlin code where the value issue silently turned up when I made what I thought was an unproblematic change. I started with something like this:  ```Kotlin import org.junit.jupiter.api.Assertions.assertEquals import org.junit.jupiter.api.Test  class FooTests {     @Test     fun `foo test1`() = fooTest {         assertEquals(42, 42)     }      private fun fooTest(block: () -> Unit) {         block()     } } ```  Obviously `fooTest` does more than just invoke the passed in lambda but that's the core of it. We had a huge number of tests like this and everything worked fine. Then, in certain cases, I wanted to call `fooTest` more than once within a single test and I wanted it to return a result that could be checked in such tests (and ignored in all the existing tests). So I made this change, there were no warnings but suddenly many of our tests stopped running. They stopped because the existing tests now no longer returned void.  If you've annotated something with `@Test` you clearly want it run - it's a mistake if you've used `@Test` with something that can't be run as a test and it should fail the test run (printing a warning isn't enough - in a huge Maven build these things can get lost).  ## Context   - Used versions (Jupiter/Vintage/Platform):  ``` org.junit.jupiter:junit-jupiter-api:jar:5.5.2:compile org.junit.jupiter:junit-jupiter-api:jar:5.5.2:test org.junit.jupiter:junit-jupiter-engine:jar:5.5.2:test org.junit.jupiter:junit-jupiter-params:jar:5.5.2:test org.junit.jupiter:junit-jupiter:jar:5.5.2:compile org.junit.jupiter:junit-jupiter:jar:5.5.2:test org.junit.platform:junit-platform-commons:jar:1.5.2:compile org.junit.platform:junit-platform-engine:jar:1.5.2:compile org.junit.platform:junit-platform-launcher:jar:1.5.2:compile ```   - Build Tool/IDE:     * IntelliJ IDEA Community 2019.3.4    * Apache Maven 3.6.3  ## Deliverables  I would suggest changing the logic for `IsTestableMethod.test` to something like this:  ```Java @Override public boolean test(Method candidate) {     if (!isAnnotated(candidate, this.annotationType)) {         return false;     }     // Beyond this point you know the test annotation is present.      // Please do not collapse the following into a single statement.     if (isStatic(candidate)) {         throw new JUnitException(candidate.getName() + "" cannot be static"");     }     if (isPrivate(candidate)) {         throw new JUnitException(candidate.getName() + "" cannot be private"");     }     if (isAbstract(candidate)) {         return false;     }     if (returnsVoid(candidate) != this.mustReturnVoid) {         throw new JUnitException(candidate.getName() + "" must return "" + (this.mustReturnVoid ? ""void"" : ""a value""));     }      return true; } ```","closed","theme: diagnostics,","george-hawkins","2020-04-06T17:26:47Z","2020-05-22T19:55:34Z"
"","2203","Upgrade to bnd 5.0.0","@rotty3000 I'm a bit confused: there seems to have been a 5.0.0 release of bndtools (congrats BTW!), but the Gradle plugin portal still lists a 4.3.x version. Can we already upgrade or is there still an issue with publishing to the Gradle plugin portal?  ## Deliverables  - [x] Remove custom `APIGuardianAnnotations` bnd plugin and switch to official one","closed","theme: build,","marcphilipp","2020-03-01T10:07:56Z","2020-04-17T11:03:39Z"
"","2572","Support object field access for ParameterizedTest's name","@ParameterizedTest(name = ""..."") provides feature to get it's argument value into it's name by using '{0}'.  The common use is that i want to use an Object within an argument (for example User). In this case i have to go with providing another string argument into test source, that looks like @ParameterizedTest(name = ""I am testing user with name {0}"") void testUser(String userName, User user) { ... }  But what people need is provide only User argument and access needed field through name (user.getName() or user.name): @ParameterizedTest(name = ""I am testing user with name user.name"") void testUser(User user) { ... }  Please allow us to do this <3","closed","component: Jupiter,","Phlegethonyarre","2021-03-17T14:52:52Z","2021-03-17T15:39:03Z"
"","2458","Added osgi-test EclipseCon 2020 presentation","@marcphilipp suggested that I add our talk to the presentations list. I'm not sure where the final rendered pages are or how to produce them so that I can verify the result looks correct though.  cc @bjhargrave, @rotty3000","closed","","kriegfrj","2020-10-23T03:54:17Z","2021-05-19T13:59:00Z"
"","2110","Improve documentation of JUnit 4-based JUnitPlatform runner","@jlink suggested via [tweet](https://twitter.com/johanneslink/status/1197810658483560448):  > JUnit 5's potential to be used through JUnit 4 - `@RunWith(JUnitPlatform.class)` - was a good idea in the beginning. It's now creating a lot of [confusion](https://stackoverflow.com/questions/58981160). Maybe it's time to deprecate it @junitteam  - https://github.com/junit-team/junit5/tree/master/junit-platform-runner  What do you think @junit-team/junit-lambda?","closed","theme: suites,","sormuras","2019-11-22T09:56:49Z","2019-12-17T11:31:53Z"
"","2845","resources folder","...WHY THERE IS NO OPTION FOR DELETING A POST IN HERE?! Unbelievable, like in 80s or something.","closed","type: question,","fafayqa","2022-03-07T09:53:37Z","2022-03-07T13:10:08Z"
"","2726","junit-platform-commons missing export","- Used versions (Jupiter/Vintage/Platform): 5.8.0  - Build Tool/IDE: gradle 7.2  `org.junit.jupiter.engine.config.EnumConfigurationParameterConverter` using `org.junit.platform.commons.logging.LoggerFactory`, but in org.junit.platform.commons 1.8.0 `module-info` is only exports to `org.junit.jupiter.engine`, and not exports `org.junit.jupiter.engine.config`.  ``` Internal Error occurred. org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:160) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverSafely(EngineDiscoveryOrchestrator.java:134) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:108) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:80) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:110) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.lang.IllegalAccessError: class org.junit.jupiter.engine.config.EnumConfigurationParameterConverter (in unnamed module @0x101df177) cannot access class org.junit.platform.commons.logging.LoggerFactory (in module org.junit.platform.commons) because module org.junit.platform.commons does not export org.junit.platform.commons.logging to unnamed module @0x101df177 	at org.junit.jupiter.engine.config.EnumConfigurationParameterConverter.(EnumConfigurationParameterConverter.java:31) 	at org.junit.jupiter.engine.config.DefaultJupiterConfiguration.(DefaultJupiterConfiguration.java:38) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:66) 	at org.junit.platform.launcher@1.8.0/org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:152) 	... 11 more ```","closed","3rd-party: IntelliJ IDEA,","monkey1993","2021-09-21T13:34:08Z","2021-09-21T14:41:48Z"
"","2844","Help diagnose EngineFilter misconfiguration","- PR for #2824 - Split test class - Remove duplication - Throw JUnitException for unmatched include EngineFilters - [Log warning if all engines were excluded](https://github.com/junit-team/junit5/pull/2844/commits/acc02a57d1047b6571d98932cff0fe615470fa95)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","marcphilipp","2022-03-06T17:23:32Z","2022-04-24T14:09:36Z"
"","2314","Give PDF user guide a better name","- No longer build release notes PDF - Link from PDF user guide to HTML release notes  Issue: #770","closed","theme: documentation,","marcphilipp","2020-06-04T18:59:14Z","2020-06-05T17:48:28Z"
"","2297","Parallel test execution isn't working with Maven surefire plugin","- Jupiter 5.6.0 - Maven surefire plugin ```                                      org.apache.maven.plugins                     maven-surefire-plugin                     3.0.0-M4                                              all                         10                                       ```  ## Steps to reproduce  [Example source code ](https://github.com/nadvolod/selenium-java/tree/junit5_parallel) **Expecting** my test methods to run in parallel when doing `mvn test`.  **Actually** they run sequential.  ## Context   - Jupiter 5.6.0  - Maven, IntelliJ 2020.1  ## Deliverables  [Example source code ](https://github.com/nadvolod/selenium-java/tree/junit5_parallel)","closed","","nadvolod","2020-05-13T15:37:28Z","2020-05-13T19:48:07Z"
"","2686","Junit5 testSuite with SelectClasses not working in android unit test","- JUnit5: 5.7.1 - JUnit Platform : 1.7.2 - IDE: Android Studio  I am trying to create a test suite for Unit test of android application, but it always fails with different kinds of configuration error, one among that is as follows,  ``` FAILURE: Build failed with an exception.  What went wrong: Execution failed for task ':appModules:factList:testDebugUnitTest'. No tests found for given includes: [reprator.wipro.factlist.FactListTestSuite] (filter.includeTestsMatching) ``` RepoDetails: https://github.com/TheReprator/Wipro/tree/junit5 Branch: junit5  TestSuite Class: https://github.com/TheReprator/Wipro/blob/junit5/appModules/factList/src/test/kotlin/reprator/wipro/factlist/FactListTestSuite.kt  My whole code works perfectly with junit4 in master branch.","closed","theme: suites,","TheReprator","2021-08-12T02:18:46Z","2021-08-22T15:13:27Z"
"","2876","Is `#` an illegal character in `@CsvSource` text blocks?","- Java 17 - IntelliJ IDEA 2021.3.2 - JUnit Jupiter: 5.8.1 - JUnit Platform: 1.8.1  Here is one of my tests:  ```java     @DisplayName(""HW Id Testing"")     @ParameterizedTest(name = ""[{index}] {arguments}"")     @CsvSource(delimiter = '|', textBlock = """"""             #Num: 1  Simple dec only                  | 123             | 123             #Num: 2  Long test dec only               | 678987654321    | 987654321             #Num: 3  dec and hex                      | 123AbC          | 1194684             #Num: 4  dec and hex with extra chars     | 123XX^^^ABC     | 1194684             #Num: 5  null                             | null            | null             """""")     public void hwIdToIntTester(String descript,                                 String hwId,                                 String convertedValue){ ```    This code FAILS with:  ``` PreconditionViolationException: Configuration error: You must configure at least one set of arguments for this @ParameterizedTest ```  If I change the leading `#` to nearly any other character, it all works fine.","closed","theme: parameterized tests,","jayr-davis","2022-04-02T00:23:08Z","2022-04-02T13:44:26Z"
"","2328","Add support for Java 16","- Extend JRE enum to support Java 16 - Run additional GitHub Actions build using OpenJDK 16-ea  Resolves #2329.","closed","","marcphilipp","2020-06-16T09:07:32Z","2020-06-16T18:42:27Z"
"","2238","Allow using DynamicTestExecutor with custom listener","- Add `Node.DynamicTestExecutor#execute(TestDescriptor,   EngineExecutionListener)` for engines that wish to pass a custom   `EngineExecutionListener` and cancel or wait for the execution of a   submitted test via the returned `Future`. - Add `EngineExecutionListener.NOOP` and change all declared methods to   have empty default implementations.  Resolves #2188.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-04-04T16:35:46Z","2020-04-19T07:00:31Z"
"","2590","Update to Gradle Enterprise Gradle Plugin 3.6.1","- [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","runningcode","2021-04-09T11:12:49Z","2021-04-09T12:19:11Z"
"","2005","Backport fixes to 5.5.2","- [x] Create release notes document for `5.5.2` in the `5.5.x` branch - [x] Backport #2003 to `5.5.x` - [x] Backport #2004 to `5.5.x`","closed","type: task,","sbrannen","2019-09-07T14:57:57Z","2019-09-07T15:33:11Z"
"","2964","Introduce assertEquals() variant with equality BiPredicate","**Use case**: comparing to `BigDecimal`s for equality cannot rely on `equals` because mathematical equality is different from it being the exact same value with the same scale and precision.  On the other hand using  ```java assertTrue(BigDecimal.valueOf(0.3d).compareTo(BigDecimal.valueOf(1.3-1d)) == 0); ```  gives a quite uselss error message:  ``` org.opentest4j.AssertionFailedError:  Expected :true Actual   :false ``` Even when using custom message `Supplier` we cannot fix the expected/actual output.  This is why it would be useful to have:  ```java  void assertEquals(T expected, T actual, BiPredicate equals); ```  This could then be used with for example `BigDecimal`: ```java BiPredicate mathematicalEquality = (a,b) -> a.compareTo(b) == 0; assertEquals(BigDecimal.valueOf(0.3d), BigDecimal.valueOf(1.3-1d), mathematicalEquality); ``` Now the output of expected/actual is proper and no custom message supplier is needed.  ``` org.opentest4j.AssertionFailedError:  Expected :0.3 Actual   :0.30000000000000004 ```  Note that choice of `BiPredicate` might just be the best the JDK has to offer. When a dedicated interface would be defined this could just have one type parameter, for example: ```java interface BinaryPredicate {    boolean test(T a, T b); } ```  I hope it also got clear that this was intentionally suggested as a generic solution that comes in handy in all kinds of use cases. The use case I gave was just one I recently encountered myself that made me think of this.","closed","component: Jupiter,","jbee","2022-07-05T12:16:41Z","2022-07-08T21:03:16Z"
"","2050","AssertThrows should probably propogate instances of AssertionError or AssumptionViolatedException unless they are also instances of user expected Type","**Deep Background:** Over in the lucene-solr project we still use junit4, and have our own version of `expectThrows` that was originally inspired by the corresponding method in some junit4 betas (which -- IIUC -- was renamed `assertThrows` before being ultimately being refactored out of junit4, in favor of `ExpectedException`, but does now exist in junit5 as part of `AssertThrows` ...) and has since evolved and expanded slightly over time and developed variants for supporting multiple expected types (primarily for dealing with various filesystem  related exceptions that annoyingly differ based on JVM impl/version, etc...).  **Recent Background:** We ran into some trouble with test code that looked like this...  ```   // in a test   expectThrows(SecurityException.class, () ->     runWithRestrictedPermissions(this::doSomeForbiddenStuff, /* Some Permissions */)); ... // in our test framework public static  T runWithRestrictedPermissions(PrivilegedExceptionAction action, Permission... permissions) throws Exception {   assumeTrue(""runWithRestrictedPermissions requires a SecurityManager ..."",              System.getSecurityManager() != null); ```  The problem being that on platforms where the test should have been `SKIP`ed due to the failed assumption, we were actually getting `FAIL`ures from `expectThrows, because instead of catching the (expected) `SecurityException` it was catching `AssumptionViolatedException`  **Current:** [We've decided](https://issues.apache.org/jira/browse/LUCENE-8999) to modify the core bits of code in our various `expectThrows` impls to use a helper method to better handle this type of situation, with the meant of the code essentially looking like this... ``` try {   runnable.run(); } catch (AssertionError | AssumptionViolatedException ae) {   for (Class expectedType : expectedTypes) {     if (expectedType.isInstance(ae)) { // user is expecting this type explicitly       return ae;     }   }   throw ae; } catch (Throwable e) {   //   // Return Throwable if it matches expectedTypes   // else Fail w/appropriate message   // } // // Fail w/appropriate message since no Exception was thrown // ```  **Future Suggestion:** In the interest of being good OSS neighbors, I'm opening this junit issue to suggest that as a project you may want to consider making a similar change to the logic in `AssertThrows`","closed","component: Jupiter,","hossman","2019-10-07T22:17:10Z","2019-11-01T12:07:52Z"
"","2379","Launcher should fail with a descriptive error message when the same TestPlan is executed twice","(version: 5.7.0.M1)  I'm trying to implement a RunUntilFailure class that runs the same TestPlan in an infinite loop until the first failure occurs, to catch flapping tests.  Running the plan once succeeds, but, on the second run, I get for each @ParametrizedTest  ```text java.lang.NullPointerException 	at org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor.populateNewExtensionRegistry(TestTemplateInvocationTestDescriptor.java:68) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:103) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:71) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:111) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:111) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:79) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:87) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:53) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:66) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:87) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at de.quantummaid.junit.RunTestsFromClasspathUntilFailure.runTestPlanOnce(RunTestsFromClasspathUntilFailure.java:76) 	at de.quantummaid.junit.RunTestsFromClasspathUntilFailure.main(RunTestsFromClasspathUntilFailure.java:50) ```  It is my understanding that `void execute(TestPlan testPlan, TestExecutionListener... listeners);` is there to not pay the overhead of classpath scanning everytime. You discover the tests once, then run the resulting TestPlan one or more times.  But `TestTemplateInvocationTestDescriptor` seems to have been written with the expectation that it is used with only one `JupiterEngineExecutionContext`, ever. It's not clear what will fix this, or whether I'm just abusing the API.  But my expectation from reading the Launcher javadoc is that I should be able to call the execute() method with the same TestPlan two (or more) times in a row.  ```  * @apiNote Calling this method will cause test discovery to be executed for  * all registered engines. If the same {@link LauncherDiscoveryRequest} was  * previously passed to {@link #discover(LauncherDiscoveryRequest)}, you  * should instead call {@link #execute(TestPlan, TestExecutionListener...)}   <<<<<<<<  * and pass the already acquired {@link TestPlan} to avoid the potential`     <<<<<<<<  * performance degradation (e.g., classpath scanning) of running test         <<<<<<<<  * discovery twice.  *  * @param launcherDiscoveryRequest the launcher discovery request; never {@code null}  * @param listeners additional test execution listeners; never {@code null}  */ void execute(LauncherDiscoveryRequest launcherDiscoveryRequest, TestExecutionListener... listeners);  ```  I'll try doing the same using LauncherDiscoveryRequest and see if it is a workaround for this problem, and report.","closed","theme: documentation,","lestephane","2020-08-11T14:41:31Z","2020-09-28T21:37:12Z"
"","2599","User guide states JUnit 5 can run JUnit 3 tests but it fails to detect them","> JUnit Vintage provides a TestEngine for running JUnit 3 and JUnit 4 based tests on the platform.  but if I have dependency on junit 3.8.1 then I got the following exception ``` Caused by: org.junit.platform.commons.JUnitException: Unsupported version of junit:junit: 3.8.1. Please upgrade to version 4.12 or later. 	at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:49) ``` Looks like the guide should be updated or vintage engine should support junit 3.8 dependencies  Checked with junit-vintage-engine:5.7.0","closed","component: Vintage,","akozlova","2021-04-21T09:50:02Z","2021-04-26T12:46:36Z"
"","2847","@ExtendWith on instance fields registered only after test instantiation","### Overview  JUnit version: 5.8.2  Issue #864 is awesome. However, when I tried to use it, I hit a problem and I'm not sure if (or why) it is supposed to work like this. For some reason, non-static fields are only checked for extensions _after_ the test instance is created, so it is impossible to register a `ParameterResolver` extension that would resolve the value of a private final field.  This behavior makes sense for `@RegisterExtension` fields, as it needs the instance to be registered and that is only available after creating the test instance. It does not, however, make sense for `@ExtendWith` annotations, as those can be read even without having an actual instance.  ```java @lombok.RequiredArgsConstructor class TestClass {   @TestAnnotation   private final String someField;    @Test   void someTestMethod() {     assertThat(someField, is(""abc""));   } }  @ExtendWith(TestAnnotationExtension.class) @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) @interface TestAnnotation { }  class TestAnnotationExtension implements ParameterResolver {   @Override   public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {     return parameterContext.getParameter().getType().equals(String.class);   }    @Override   public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {     return ""abc"";   } }  ```  ### Expected outcome:  test passes.  ### Actual outcome:  ``` org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [final java.lang.String someField] in constructor [public TestClass(java.lang.String)] ```","open","component: Jupiter,","kostislav","2022-03-07T12:20:51Z","2022-03-29T10:06:08Z"
"","2910","Make `@Order` a stable API","### Discussed in https://github.com/junit-team/junit5/discussions/2909    Originally posted by **skohlmann** May  6, 2022 Hi,  the [`@Order`](https://github.com/junit-team/junit5/blob/r5.8.2/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Order.java) annotation is marked as `EXPERIMENTAL` where the type annotation value `OrderAnnotation` implementation is not marked as `EXPERIMENTAL`. So I guess, it‘s stable. The documentation of `OrderAnnotation` also refers to `@Order.`   On the other hand, if `OrderAnnotation` implicitly takes the API state of `@Order`, this indirection is semantically difficult to detect. This also in view of the fact that `@Order` has been in the `EXPERIMENTAL` state for many versions, and within this time period certainly  1. a realization with regard to 👍 or 👎 has arisen. 2. the use in projects is certainly established, after 4 minor releases.  I would be happy if the situation is clarified by the team in the next minor release. Whereby I plead for `@Order` to be transferred to the state `STABLE`.  Have fun :-)   -sascha","closed","component: Jupiter,","sbrannen","2022-05-06T13:45:00Z","2022-05-06T13:53:14Z"
"","2057","Provide EditorConfig","## What is EditorConfig? _EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems._ https://editorconfig.org  ## Deliverables  - [ ] Provide `.editorconfig` matching settings declared in https://github.com/junit-team/junit5/tree/master/src/eclipse as close as possible.","closed","status: stale,","sormuras","2019-10-12T10:13:55Z","2022-07-11T20:21:40Z"
"","2905","Colon should not be used as classpath argument separator on Windows for junit-platform-console","## Steps to reproduce Provide absolute path for jar with test located on drive distinct from working dir. E.g.: Lets use `junit-platform-console-standalone-1.8.2.jar` and jar with test classes `simple-test-case.jar` located in directory on `C:` drive. Running `java -jar C:\dir\junit-platform-console-standalone-1.8.2.jar --scan-classpath -cp C:\dir\simple-test-case.jar` from working directory on `C:` drive will work and running it from other drive will not.  ``` PS D:\Downloads> java -jar C:\dir\junit-platform-console-standalone-1.8.2.jar --scan-classpath -cp C:\dir\simple-test-case.jar --disable-ansi-colors --disable-banner . +-- JUnit Jupiter [OK] '-- JUnit Vintage [OK]  Test run finished after 33 ms [         2 containers found      ] [         0 containers skipped    ] [         2 containers started    ] [         0 containers aborted    ] [         2 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ]  PS D:\Downloads> C: PS C:\WINDOWS\system32> java -jar C:\dir\junit-platform-console-standalone-1.8.2.jar --scan-classpath -cp C:\dir\simple-test-case.jar --disable-ansi-colors --disable-banner Hi, junit . +-- JUnit Jupiter [OK] | '-- AwesomeTest [OK] |   '-- sayHi() [OK] '-- JUnit Vintage [OK]  Test run finished after 59 ms [         3 containers found      ] [         0 containers skipped    ] [         3 containers started    ] [         0 containers aborted    ] [         3 containers successful ] [         0 containers failed     ] [         1 tests found           ] [         0 tests skipped         ] [         1 tests started         ] [         0 tests aborted         ] [         1 tests successful      ] [         0 tests failed          ] ```  ## Context  - Used versions: junit-platform-console-standalone 1.8.2  - Operation system: Windows  ## Reason Colons char should not be used as path separator at https://github.com/junit-team/junit5/blob/r5.8.2/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java on Windows environment","closed","theme: discovery,","alopukhov","2022-05-03T13:23:23Z","2022-06-20T07:51:16Z"
"","2248","Execution of Vintage Tests fail with ""displayName must not be null or blank""","## Steps to reproduce Execute the build https://github.com/reinhapa/exist/tree/junit5 using: `mvn -T 2C -Ddocker=false test -B -e`  ## Context  - Maven `3.6.3`  - JUnit Jupiter/Vintage Engine `5.6.1`  - Apache Surefire `3.0.0-M4`  ## Deliverables Test should run as before using JUnit `4.13`","closed","component: Vintage,","reinhapa","2020-04-07T08:51:08Z","2020-04-08T19:08:11Z"
"","2064","A lot of warnings in IntelliJ IDE","## Steps to reproduce Clone repo and open it in IntelliJ  See screenshot.  There are plenty of warnings and build errors in the Gradle script:    ## Context   - Used versions (Jupiter/Vintage/Platform): latest MASTER BRANCH  - Build Tool/IDE: IntelliJ EAP IU-193.4386.10 (IU-193.4386.10)","closed","status: invalid,","IgorGanapolsky","2019-10-15T16:20:03Z","2019-10-15T19:44:56Z"
"","2273","Parallelism value ignored for the fixed strategy","## Steps to reproduce `git clone git@github.com:rbok78/framework-template.git` `cd framework-template` `mvn clean test -P parallel-execution`  ## Actual outcome All 4 test methods are kicked off at the same time.  ## Expected outcome I use the following configuration for the Maven Surefire Plugin. I expect the number of test methods running in parallel is the same as the parallelism value. I've tried to set it to 1, 2, and 3 but still all 4 test methods run in parallel.  `junit.jupiter.execution.parallel.enabled = true` `junit.jupiter.execution.parallel.mode.default = concurrent` `junit.jupiter.execution.parallel.mode.classes.default = concurrent` `junit.jupiter.execution.parallel.config.strategy = fixed` `junit.jupiter.execution.parallel.config.fixed.parallelism = 1`  ## Context  - Linux 5.3.0-46-generic x86_64  - Ubuntu 19.10  - OpenJDK 11.0.7  - Apache Maven 3.6.1  - Maven Surefire Plugin 3.0.0-M4  - Jupiter 5.7.0-M1   - IntelliJ IDEA 2020.1 (Community Edition)  ## Deliverables n/a","closed","status: works-as-designed,","rbok78","2020-04-25T10:35:15Z","2022-02-09T16:40:36Z"
"","2450","Excessive memory usage with highly parameterized test","## Steps to reproduce ```java import java.util.stream.IntStream;  import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;  public final class AllocationTest {    @ParameterizedTest   @MethodSource(""providesInts"")   public void allocate(int i) {     if (i < 0) {       throw new AssertionError();     }   }    public static IntStream providesInts() {     return IntStream.range(0, 2_000_000);   } } ```  When running on Gradle with a 256mb heap, this test performs ~200k executions before an OutOfMemoryError. The memory grab appears to be heavy-weight test results before retained in-memory. This was run against v5.7.0.  1. Download [junit-stress.zip](https://github.com/junit-team/junit5/files/5383847/junit-stress.zip) project. 2. Run `gradlew cleanTest test` until it slows down 3. Create a heap dump, e.g. `jmap -dump:live,format=b,file=/Users/ben/Downloads/junit.hprof ""$(pgrep -f GradleWorkerMain)""` 4. Open in your favorite profiler, e.g. JMC, YourKit, JProfiler (all free for OSS projects)    ## Context  I discovered this out of curiosity when facing a similar problem in TestNG (https://github.com/cbeust/testng/issues/2096). It too retains the test results in-memory, though its stress tester runs faster and gets to ~600k before failing. In both cases the results shouldn't be held in-memory, e.g. perhaps streaming the results to disk if retained for a report.  The real-world case is Caffeine, which has a test suite that executes 4M+ scenarios. This is because a cache has many configuration options that interact, so a simple change could break a subsets of configurations for a given test case. Therefore the easiest solution is brute force testing with a custom `@CacheSpec` applied to the method to declare the specification constraints. The provider inspects the test method to generates all possible combinations.  Because of the memory grab, Caffeine's test suite is broken into ~30 tasks each running ~140k test executions. Over time I've whittled down the source problems by hacking the testing framework's internal structures to drop allocations. Prior tricks were modifying the test results in a listener, e.g. to replace parameters with their stringified version and dedupe test names. As more tests are added it keeps becoming a problem, requiring more effort to keep the build healthy. Recently I hacked the internals to drop the test result objects themselves (as not needed for Gradle's report). This shrank the heap from 315MB (8.6M objects) down to 22MB (0.5M objects), but is extremely hacky by reflectively clearing various collections. It functions enough for my build to shave the CI time by 20 minutes (22% speedup) which only offers a 512mb heap.  In both frameworks resolving this stress case might be an invasive change. While most test suites are small, better GC behavior can improve performance and lets the framework scale to more extreme scenarios.","closed","component: Platform,","ben-manes","2020-10-15T09:48:24Z","2020-10-24T13:09:23Z"
"","2600","Beginning with 1.7.1 standalone console does not find tests on Java 8","## Steps to reproduce  We are launching tests with the following command: ```shell java -cp ./junit-platform-console-standalone-1.7.1.jar:./jar-file-with-tests.jar org.junit.platform.console.ConsoleLauncher --select-package=root.package.for.all.tests --reports-dir /specified/path ```  `jar-file-with-tests.jar` does contain a lot of classes with methods marked with `@Test` annotation.  This command works fine when:  - we use `junit-platform-console-standalone` version 1.7.0 both on Java 8 and Java 11 - we use `junit-platform-console-standalone` version 1.7.1 or 1.8.0-M1 on Java 11  When launching 1.7.1 console on Java 8 the report states that 2 containers were found (`2 containers found`, `2 containers started` and `2 containers successful`), no tests are present in the report (all other values in the report are 0 (like `0 tests found`))  ## Context  The testing project (`jar-file-with-tests.jar`) is built using Java 8.  Issue seems to occur both in Windows and Linux environments.","closed","component: Platform,","ndimitry","2021-04-23T09:22:37Z","2021-05-19T04:50:56Z"
"","2468","LauncherConfig.builder() appears accidentally package private","## Steps to reproduce  val config =  LauncherConfig.builder().build() // doesn't compile  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.7.0  - Build Tool/IDE: Gradle/Intellij  ## Deliverables  workaround is  ```   val config = object : LauncherConfig {     override fun isTestEngineAutoRegistrationEnabled(): Boolean = false      override fun isTestExecutionListenerAutoRegistrationEnabled(): Boolean = false      override fun isPostDiscoveryFilterAutoRegistrationEnabled(): Boolean = false      override fun getAdditionalTestEngines(): MutableCollection = mutableListOf(       JupiterTestEngine())      override fun getAdditionalTestExecutionListeners(): MutableCollection = mutableListOf()      override fun getAdditionalPostDiscoveryFilters(): MutableCollection = mutableListOf()   } ```","closed","","yschimke","2020-10-29T09:01:39Z","2020-10-31T11:05:15Z"
"","2157","Assertions.assertIterableEquals overflows the stack","## Steps to reproduce  The following code: ```java var expected = List.of(Path.of(""1"")); var actual = List.of(Path.of(""1"")); System.out.println(expected); System.out.println(actual); assertIterableEquals(expected, actual); ```  Yields: ``` [1] [1] java.lang.StackOverflowError 	at java.base/java.util.ArrayList.grow(ArrayList.java:243) 	at java.base/java.util.ArrayList.add(ArrayList.java:453) 	at java.base/java.util.ArrayList.add(ArrayList.java:466) 	at java.base/sun.nio.fs.WindowsPath.initOffsets(WindowsPath.java:649) 	at java.base/sun.nio.fs.WindowsPath.getNameCount(WindowsPath.java:660) 	at java.base/java.nio.file.Path$1.hasNext(Path.java:923) 	at org.junit.jupiter.api.AssertIterableEquals.assertIterableEquals(AssertIterableEquals.java:62) 	at org.junit.jupiter.api.AssertIterableEquals.assertIterableElementsEqual(AssertIterableEquals.java:82) 	at org.junit.jupiter.api.AssertIterableEquals.assertIterableEquals(AssertIterableEquals.java:72) 	at org.junit.jupiter.api.AssertIterableEquals.assertIterableElementsEqual(AssertIterableEquals.java:82) 	at org.junit.jupiter.api.AssertIterableEquals.assertIterableEquals(AssertIterableEquals.java:72) 	[...] ```  ## Deliverables  - [x] Provide fix and test for comparing `Iterable>` instances.","closed","component: Jupiter,","sormuras","2020-01-20T12:01:56Z","2020-01-25T16:19:06Z"
"","2053","Consider adding locale=""en"" to JavaDoc options","## Steps to reproduce  Set a non-English locale. Build JavaDoc. The HTML files would start with something like ``  `org.gradle.external.javadoc.MinimalJavadocOptions#setLocale(""en"")` helps.","closed","theme: documentation,","vlsi","2019-10-08T20:14:24Z","2019-10-11T21:07:47Z"
"","2204","Test failure attributed to the wrong test class with parallel test execution","## Steps to reproduce  Run `./mvnw clean package` using JDK11 in the following branch: https://github.com/dfa1/hosh/tree/bugreport-for-junit5  According to the following message seems that failure is caused by `TerminalModuleTest`, even if the stacktrace shows `CompilerTest`:  ``` [INFO] Running hosh.modules.TerminalModuleTest [INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.007 s - in hosh.runtime.InterpreterTest [INFO] Running hosh.modules.NetworkModuleTest [ERROR] Tests run: 53, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.185 s <<< FAILURE! - in hosh.modules.TerminalModuleTest [ERROR] commandAfterCommentBlock  Time elapsed: 0.047 s  <<< ERROR! java.lang.NullPointerException 	at hosh@0.1.0-SNAPSHOT/hosh.runtime.Compiler.compileSequence(Compiler.java:77) 	at hosh@0.1.0-SNAPSHOT/hosh.runtime.Compiler.compileStatement(Compiler.java:73) 	at hosh@0.1.0-SNAPSHOT/hosh.runtime.Compiler.compile(Compiler.java:66) 	at hosh@0.1.0-SNAPSHOT/hosh.runtime.CompilerTest.commandAfterCommentBlock(CompilerTest.java:317) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:205) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:201) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171) 	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:189) 	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290) 	at java.base/java.util.concurrent.ForkJoinTask.doJoin(ForkJoinTask.java:396) 	at java.base/java.util.concurrent.ForkJoinTask.join(ForkJoinTask.java:721) 	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.joinConcurrentTasksInReverseOrderToEnableWorkStealing(ForkJoinPoolHierarchicalTestExecutorService.java:148) 	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171) 	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:189) 	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290) 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020) 	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656) 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594) 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:177) ```  ## Context   - Used versions (Jupiter/Vintage/Platform):5.6.0  - Build Tool/IDE: maven 3.6.2 - parallel test execution enabled: ``` junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent junit.jupiter.execution.parallel.mode.classes.default = concurrent ```","closed","3rd-party: Maven Surefire,","dfa1","2020-03-01T19:55:18Z","2020-03-01T21:55:36Z"
"","2021","JUnit5-Vintage produces duplicate TestIdentifiers when running JUnit3 suites with duplicate test names","## Steps to reproduce  Reproducer: https://github.com/junit-team/junit5-samples/pull/113  I admit that JUnit3 is kind of old, however https://github.com/apache/jmeter contains quite a few `suite()`-driven tests. It would be nice if Vintage executor could account for `TestSuite` names as well when producing `TestIdentifier`s  Relevant JMeter PR: https://github.com/apache/jmeter/pull/496. I tried to add `implements Descriptable` all over the place. It does help to a degree, however it does not really help when the test must be run twice (e.g. with different `setup` methods).   ## Context   - Used versions (Jupiter/Vintage/Platform): 5.5.1  - Build Tool/IDE: Gradle 5.5.1","closed","component: Vintage,","vlsi","2019-09-22T21:38:51Z","2019-10-10T18:25:13Z"
"","2723","Running test fails on junit-jupiter-engine 5.8.0 but succeed on 5.8.0.-M1","## Steps to reproduce  I just have to run my tests or any of one single of them  ## Context  My project is a Spring boot 2.5.4 monolith running on java 17 (oracle)   - Used versions (succeed) Jupiter:  jupiter:junit-jupiter:5.8.0 junit-jupiter-api:5.8.0 junit-jupiter-engine:5.8.0-M1 junit-jupiter-params:5.8.0   - Used versions (failed) Jupiter:  jupiter:junit-jupiter:5.8.0 junit-jupiter-api:5.8.0 junit-jupiter-engine:5.8.0 junit-jupiter-params:5.8.0  - Build Tool/IDE: Gradle / IntellijIDEA  ## Stack Trace  ``` org.gradle.api.internal.tasks.testing.TestSuiteExecutionException: Could not complete execution for Gradle Test Executor 7. 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:63) 	at java.base@17/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base@17/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) 	at java.base@17/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base@17/java.lang.reflect.Method.invoke(Method.java:568) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at jdk.proxy1/jdk.proxy1.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) 	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71) 	at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) 	at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) Caused by: org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:111) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:85) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:92) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	... 18 more Caused by: org.junit.platform.commons.JUnitException: ClassSelector [className = 'com.orinoko.qorus.QorusApplicationTests'] resolution failed 	at org.junit.platform.launcher.listeners.discovery.AbortOnFailureLauncherDiscoveryListener.selectorProcessed(AbortOnFailureLauncherDiscoveryListener.java:39) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:102) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:82) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:113) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:46) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:69) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:103) 	... 25 more Caused by: java.lang.NoSuchMethodError: 'java.util.Optional org.junit.platform.commons.util.AnnotationUtils.findAnnotation(java.lang.Class, java.lang.Class, boolean)' 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.getDisplayNameGenerator(DisplayNameUtils.java:110) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.lambda$createDisplayNameSupplierForClass$2(DisplayNameUtils.java:98) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.determineDisplayName(DisplayNameUtils.java:88) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.(JupiterTestDescriptor.java:69) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.(ClassBasedTestDescriptor.java:96) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:51) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.newClassTestDescriptor(ClassSelectorResolver.java:119) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.lambda$resolve$0(ClassSelectorResolver.java:71) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution$DefaultContext.createAndAdd(EngineDiscoveryRequestResolution.java:246) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution$DefaultContext.addToParent(EngineDiscoveryRequestResolution.java:209) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:71) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:134) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197) 	at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1602) 	at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:129) 	at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:527) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) 	at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:647) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:185) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:125) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:91) 	... 30 more ```","closed","component: Platform,","Kearny","2021-09-18T20:21:23Z","2022-02-18T09:59:19Z"
"","2523","Improve failure message for assertNull() when toString() results in ""null""","## Steps to reproduce  I didn't find any same issues so I hope this isn't a duplicate.  I get `null != null` when running this test.  ```java public class GsonLoreSerializationTest {      private Gson gson = new Gson();      private List lore;      @Test     public void serializeLore() {         String nullLore = gson.toJson(lore);         // null != null??         Assertions.assertNull(nullLore);          lore = new ArrayList<>();         String emptyLore = gson.toJson(lore);         Assertions.assertEquals(emptyLore, ""[]"");          lore.add(""Test String"");         String normalLore = gson.toJson(lore);         Assertions.assertEquals(normalLore, ""[\""Test String\""]"");     }  } ```  ``` expected:  but was:  Expected :null Actual   :null   GsonLoreSerializationTest > serializeLore() FAILED     org.opentest4j.AssertionFailedError at GsonLoreSerializationTest.java:19 1 test completed, 1 failed ``` Full stack trace: https://pastebin.com/B0LFx5HF  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.7.0  - Build Tool/IDE: Gradle 6.7 with IntelliJ IDEA Ultimate 2020.3  ## Deliverables  N/A","closed","component: Jupiter,","sebba-dev","2021-01-10T19:18:42Z","2021-01-29T12:01:10Z"
"","2303","@TestFactory method succeeds when throwing an exception with Maven Failsafe plugin","## Steps to reproduce  Here is a reproducible test:  ```java     @TestFactory     List tests() {         int a = 1 / 0;  // intentionally throws         return Arrays.asList(             DynamicContainer.dynamicContainer(                 ""dynamic container 1"",                 Stream.of(                     DynamicTest.dynamicTest(""dynamic test 1"", () -> fail("""")),                     DynamicTest.dynamicTest(""dynamic test 2"", () -> fail(""""))                 )             ),             DynamicContainer.dynamicContainer(                 ""dynamic container 2"",                 Stream.of(                     DynamicTest.dynamicTest(""dynamic test 3"", () -> fail("""")),                     DynamicTest.dynamicTest(""dynamic test 4"", () -> fail(""""))                 )             )         );     } ```  the test above succeeded if `int a = 1 / 0;` is present, and failed as expected if I remove it, showing 4 tests executed and all of them failed.  ## Context   - Used versions (Jupiter/Vintage/Platform):  ```xml                              org.junit.jupiter                 junit-jupiter                 5.6.0              ```   - Build Tool/IDE:  maven-failsafe-plugin, with all necessary dependencies configured  ```xml                              org.apache.maven.plugins                 maven-failsafe-plugin                 3.0.0-M4                                                                     ```  ## Deliverables  I'm expecting the tests to be failed if the `TestFactory` method throws","closed","3rd-party: Maven Surefire,","kezhenxu94","2020-05-20T01:51:44Z","2020-05-20T14:49:41Z"
"","2087","Declarative timeout does not interrupt code running in infinite loop","## Steps to reproduce  Having some code running infinitely, but the timeout annotation(neither the class level nor testable method level) can interrupt the execution. Instead, the program hang forever.   I was hoping it can behave like the `assertTimeoutPreemptively` to interrupt the running test method.  e.g. I have a class with just one single infinite running method:  ```java public class A {      public void infinite() {         while (true) {             continue;         }     } } ```  ```java 	@Test 	@Timeout(1) // run at most 1 seconds 	void pollUntil() { 		A a = new A(); 		a.infinite(); 		assertEquals(1,1); 	} ```  ## Context   - Used versions: Jupiter 5.5.2","closed","component: Jupiter,","praenubilus","2019-10-28T02:50:48Z","2022-07-04T17:53:43Z"
"","2685","`TypedArgumentConverter` cannot convert to a primitive","## Steps to reproduce  Given a composed `@StringLength` annotation which registers a `TypedArgumentConverter` that converts from `String` to `Integer`, the following `stringToInteger()` test method succeeds; whereas, `stringToPrimitiveInt()` fails.  ```java @ParameterizedTest @ValueSource(strings = ""enigma"") void stringToInteger(@StringLength Integer length) { 	assertThat(length).isEqualTo(6); }  @ParameterizedTest @ValueSource(strings = ""enigma"") void stringToPrimitiveInt(@StringLength int length) { 	assertThat(length).isEqualTo(6); } ```  Exception thrown for the attempt to convert from `Integer` to `int`:  ``` org.junit.jupiter.api.extension.ParameterResolutionException: Error converting parameter at index 0: Can only convert to type java.lang.Integer ```  ## Deliverables  - [x] Ensure that a `TypedArgumentConverter` can convert to a primitive.","closed","theme: parameterized tests,","sbrannen","2021-08-11T09:50:57Z","2021-08-11T11:13:55Z"
"","2703","ParameterizedTest cannot use Kotlin inline value classes as arguments","## Steps to reproduce  Expect parameterized tests to be able to use Kotlin's inline classes as arguments.  Test below fails to run and instead get an error when initializing the test: `Error converting parameter at index 0: No implicit conversion to convert object of type InlineValueClass to type java.lang.String`  ```kotlin @JvmInline value class InlineValueClass(val value: String)  class InlineTest {     @ParameterizedTest     @MethodSource(""values"")     fun shouldRun(arg: InlineValueClass) {         assertEquals(arg, arg)     }      fun values() = listOf(         arguments(InlineValueClass(""test""))     ) } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Junit 5.0.0 / Kotlin 1.5.20  - Build Tool/IDE: Gradle / IntelliJ","open","theme: parameterized tests,","alyssum","2021-09-01T20:29:03Z","2021-11-01T09:05:02Z"
"","2683","Suite TestEngine excludes classes selected via @SelectClasses","## Steps to reproduce  Changes pushed to `main` in commit 06ab1ebabef0af896035c4ac5c977ba7c09fe10e reveal that there is a bug in the JUnit Platform Suite `TestEngine` with regard to selected classes.  Specifically, if a `@Suite` class explicitly selects a class whose name does not match the default class name include pattern, the selected class will be filtered out and never executed with the suite.  ## Passing example from test suite  ```java @Suite @SelectClasses(SimpleTest.class) public class SelectClassesSuite { } ```  ## Failing example from test suite  ```java @Suite @SelectClasses(SingleTestTestCase.class) public class SelectClassesSuite { } ```  ## Workaround from test suite  ```java @Suite @SelectClasses(SingleTestTestCase.class) @IncludeClassNamePatterns("".*TestCase$"") public class SelectClassesSuite { } ```  ## Deliverables  - [x] Ensure that classes explicitly selected via `@SelectClasses` have their class names automatically included in the class name filter.","closed","theme: suites,","sbrannen","2021-08-10T10:13:06Z","2021-08-11T14:03:38Z"
"","2505","assertThrows doesn't fail if the thrown exception is of child type","## Steps to reproduce  `assertThrows(IOException.class, () -> service.readFile(""sampleFile.txt"")); `  this assertion will pass even if the exception is FileNotFoundException.  I believe this is happening because we are using `Class#isInstance` it will return true for parent types also.  https://github.com/junit-team/junit5/blob/637a78393194737e77d6f9681ad93e9ddac1f399/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertThrows.java#L58  Shouldn't this be replaced with `if (expectedType == actualException.getClass())` ?","closed","component: Jupiter,","govi20","2020-12-27T06:03:02Z","2020-12-28T03:58:48Z"
"","1974","Jupiter engine calls static initializer on each invocation","## Steps to reproduce  ```java public class MyTest {     static int count = 0;     {         System.err.println(""Hi there!: "" + System.identityHashCode(MyTest.class) + "", count: "" + count++);     }      @Test     public void myFirstTest() {}      @Test     public void mySecondTest() {} } ``` Sample output when run using the Jupiter engine  ``` Hi there!: 1929600551, count: 0 Hi there!: 1929600551, count: 1 ``` Run this test using Jupiter and watch the console. ""Hi there!"" will appear twice, and both lines will have the same identity hash code and the count is remember between tests, indicating that they are the same class.  Once I understood what was happening, it was easy to work around this by using a static method with a `@BeforeAll` annotation instead of a static initializer. However, this behaviour was very surprising.  ## Context  The above was tested using Jupiter 5.4.0.  ## Deliverables  I'm not sure if this behaviour is by design. But on the surface of it, I'd have thought that the static initializer should only be invoked once, when the class is loaded (per the Java spec).","closed","component: Jupiter,","kriegfrj","2019-08-07T01:11:02Z","2019-08-07T17:59:02Z"
"","2455","ExtensionContext.Store#getOrComputeIfAbsent invokes the defaultCreator twice if the defaultCreator throws an exception","## Steps to reproduce  ```java public class ConvertCmmnModelResolver implements ParameterResolver {      @Override     public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {         return CmmnModel.class.equals(parameterContext.getParameter().getType());     }      @Override     public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {          extensionContext.getRoot().getStore(ExtensionContext.Namespace.GLOBAL)                 .getOrComputeIfAbsent(extensionContext.getUniqueId(), key -> {                     throw new RuntimeException(""Test exception"");                 });         return null;     }  } ```  I think that the fact that this is a parameter resolver doesn't matter. When this code is run the exception will be thrown twice.  The reason for that is the fact that the `MemoizingSupplier` does not handle the fact that the passed supplier might throw an exception in:  https://github.com/junit-team/junit5/blob/a37f726bc3f5241cdffd7491e16b0266002e0eb9/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExtensionValuesStore.java#L201-L213  This means that when the exception is thrown the first time the value in the `MemoizingSupplier` is still `NO_VALUE_SET`. The supplier is than invoked again when the store is closed as part of:  https://github.com/junit-team/junit5/blob/a37f726bc3f5241cdffd7491e16b0266002e0eb9/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExtensionValuesStore.java#L62-L70  ## Context   - Used versions (Jupiter): 5.7.0  - Build Tool/IDE: Not relevant  ## Deliverables  - [ ] ...","closed","component: Jupiter,","filiphr","2020-10-21T12:45:20Z","2020-10-25T12:52:08Z"
"","1966","TestExecutionResult parameter not resolved on AfterEach","## Steps to reproduce  ```java class SayHelloWorldTest {      @Test   void sayHelloWorldTest() {     System.out.println(""Hello World"");   }    @AfterEach   public void afterEachTest(TestInfo testInfo, TestExecutionResult result) {     System.out.println(testInfo + ""  "" + result);   } } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.5  - Build Tool/IDE: Intellij / Maven  ## Result  ``` org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [org.junit.platform.engine.TestExecutionResult arg1] in method [public void SayHelloWorldTest.afterEachTest(org.junit.jupiter.api.TestInfo,org.junit.platform.engine.TestExecutionResult)] ```  ## Expectation  - TestExecutionResult can be resolved on Methods annotated with `@AfterEach` containing the information of the last method run","closed","component: Jupiter,","knoobie","2019-07-26T08:17:52Z","2019-07-26T08:45:31Z"
"","2046","TempDir fails when it faces a read-only file in Windows","## Steps to reproduce  ```java @Test public void testWriteToFileIOException(@TempDir Path tempDir) throws Exception {     Path f = tempDir.resolve(""test.txt"");     Files.write(f, new byte[0]);     Assertions.assertTrue(f.toFile().setWritable(false), () -> f + "".toFile().setWritable(false) should succeed""); } ```  The exception is similar to the following:  ``` org.apache.jmeter.functions.TestStringtoFile > testWriteToFileIOException(Path) STANDARD_ERROR     Oct 06, 2019 3:06:02 PM org.junit.jupiter.engine.execution.JupiterEngineExecutionContext close     SEVERE: Caught exception while closing extension context: org.junit.jupiter.engine.descriptor.MethodExtensionContext@23c1d81a     java.io.IOException: Failed to delete temp directory C:\Users\jenkins\AppData\Local\Temp\2\junit4877224876769494483. The following paths could not be deleted (see suppressed exceptions for details): , output.txt     	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.createIOExceptionWithAttachedFailures(TempDirectory.java:211)     	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:168)     	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     	at org.junit.jupiter.engine.execution.ExtensionValuesStore.closeAllStoredCloseableValues(ExtensionValuesStore.java:61)     	at org.junit.jupiter.engine.descriptor.AbstractExtensionContext.close(AbstractExtensionContext.java:73)     	at org.junit.jupiter.engine.execution.JupiterEngineExecutionContext.close(JupiterEngineExecutionContext.java:53)     	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:222)     	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.cleanUp(JupiterTestDescriptor.java:57)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$cleanUp$9(NodeTestTask.java:151)     	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.cleanUp(NodeTestTask.java:151)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:83)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.executeNonConcurrentTasks(ForkJoinPoolHierarchicalTestExecutorService.java:141)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:121)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)     	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.executeNonConcurrentTasks(ForkJoinPoolHierarchicalTestExecutorService.java:141)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:121)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)     	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)     	at java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:189)     	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)     	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)     	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)     	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)     	Suppressed: java.nio.file.DirectoryNotEmptyException: C:\Users\jenkins\AppData\Local\Temp\2\junit4877224876769494483     		at sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:266)     		at sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:103)     		at java.nio.file.Files.delete(Files.java:1126)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:192)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.postVisitDirectory(TempDirectory.java:187)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.postVisitDirectory(TempDirectory.java:178)     		at java.nio.file.Files.walkFileTree(Files.java:2688)     		at java.nio.file.Files.walkFileTree(Files.java:2742)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:178)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:166)     		... 38 more     	Suppressed: java.nio.file.AccessDeniedException: C:\Users\jenkins\AppData\Local\Temp\2\junit4877224876769494483\output.txt     		at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:83)     		at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)     		at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)     		at sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:269)     		at sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:103)     		at java.nio.file.Files.delete(Files.java:1126)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.deleteAndContinue(TempDirectory.java:192)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.visitFile(TempDirectory.java:182)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath$1.visitFile(TempDirectory.java:178)     		at java.nio.file.Files.walkFileTree(Files.java:2670)     		at java.nio.file.Files.walkFileTree(Files.java:2742)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:178)     		at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:166)     		... 38 more ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.5.1  - Build Tool/IDE: Gradle  This might be relevant: https://stackoverflow.com/a/32955993/1261287","closed","component: Jupiter,","vlsi","2019-10-07T08:35:31Z","2019-10-13T18:40:52Z"
"","2796","Build fails on linux","## Steps to reproduce  `./gradlew build`  ```text > Task :junit-jupiter-engine:compileTestKotlin 'compileTestJava' task (current target is 17)  and 'compileTestKotlin' task (current target is 16)  jvm target compatibility should be set to the same Java version.  w: Language version 1.3 is deprecated and its support will be removed in a future version of Kotlin  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':junit-jupiter-migrationsupport:test'. > Could not resolve all files for configuration ':junit-jupiter-migrationsupport:testRuntimeClasspath'.    > Could not resolve project :junit-jupiter-api.      Required by:          project :junit-jupiter-migrationsupport       > Unable to find a variant of org.junit.jupiter:junit-jupiter-api:5.8.1         providing the requested capability org.junit.jupiter:junit-jupiter-api-test-fixtures:1.0:            - Variant apiElements provides org.junit.jupiter:junit-jupiter-api:5.8.1            - Variant runtimeElements provides org.junit.jupiter:junit-jupiter-api:5.8.1            - Variant javadocElements provides org.junit.jupiter:junit-jupiter-api:5.8.1            - Variant sourcesElements provides org.junit.jupiter:junit-jupiter-api:5.8.1    ```  ## Context  ``` /junit5$ $JAVA_HOME/bin/java -version openjdk version ""17.0.1"" 2021-10-19 OpenJDK Runtime Environment Temurin-17.0.1+12 (build 17.0.1+12) OpenJDK 64-Bit Server VM Temurin-17.0.1+12 (build 17.0.1+12, mixed mode, sharing) ```","closed","status: works-as-designed,","JOpsDev","2021-12-15T17:23:28Z","2021-12-18T14:25:29Z"
"","2537","Empty report when beforeAll is failing","## Steps to reproduce  1. Create a testClass with parameterized tests only; 2. Create a beforeAll method throwing NPE; 3. Register LegacyXmlReportGeneratingListener.  Because we have: ```   void writeXmlReport(TestIdentifier testIdentifier, Writer out) throws XMLStreamException {       List tests = (List)this.reportData.getTestPlan().getDescendants(testIdentifier).stream().filter(TestIdentifier::isTest).collect(Collectors.toList());       this.writeXmlReport(testIdentifier, tests, out);   } ``` in XmlReportWriter  and all skipped tests are containers (isTest() = false), we have a completely clean xml report with no way to understand, that beforeAll failed and tests were skipped.  Junit version is 5.5.1, platform 1.7.1","closed","component: Platform,","dubilyer","2021-01-19T08:48:06Z","2021-02-18T09:42:59Z"
"","1975","Incorrect test count displayed with Maven Surefire","## Steps to reproduce  - Run code from https://github.com/priyankshah217/junit5sample - It has running strategy concurrent (method and class level)  ```  junit.jupiter.execution.parallel.mode.default = concurrent junit.jupiter.execution.parallel.mode.classes.default = concurrent ```  - Run test using `mvn clean test`  **Actual Output**  ``` [INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.026 s - in SampleTest2 [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.04 s - in SampleTest ```  https://gist.github.com/priyankshah217/c8860393e82eb18172e6bd2afda5957e#file-junit5executionlog  **Expected Output** ``` [INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.026 s - in SampleTest2 [INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.04 s - in SampleTest ```  ## Context   - Used versions (Jupiter/Vintage/Platform): junit-jupiter-engine:5.5.1,junit-platform-runner:1.5.1  - Build Tool/IDE: mvn:3.6.1  Note: Before creating this issue I referred to #148, but it seems different than I am facing.","closed","3rd-party: Maven Surefire,","priyankshah217","2019-08-07T07:51:46Z","2020-05-22T16:39:11Z"
"","2299","Inherited @BeforeEach method executed on wrong instance for @Nested class","## Steps to reproduce  ### code  ```java package org.myproject;  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test;  public class OuterClass extends SuperClass {   @Nested   public class NestedClass extends SuperClass {     @Test     public void test() {       // empty test     }   } }  class SuperClass {   @BeforeEach   public void beforeEach() {     System.out.println(""beforeEach() for "" + this.toString());   } } ```  ### Actual behaviour Running the only test method from the code above results in invocation of `beforeEach()` method on the same instance of `NestedClass` twice before running `test()` method. On instance of `OuterClass` method `beforeEach()` is never invoked. This can be verified by looking at console output:  ``` beforeEach() for org.myproject.OuterClass$NestedClass@5bda8e08 beforeEach() for org.myproject.OuterClass$NestedClass@5bda8e08 ```  The problem is most probably caused by the fact that both `OuterClass` and `NestedClass` extends the same `SuperClass`. I guess similar problem may exists for `@BeforeAll` `@AfterEach`, `@AfterAll` but I didn't check that assumption.  ### Expected behaviour Running test should result in `beforeEach()` method being invoked once on instance of `OuterClass` and once on instance of `NestedClass`.   ## Context  I reproduced that on IntelliJ IDEA 2020.1.1 (Community Edition) Build #IC-201.7223.91, built on April 30, 2020 with junit fetched from maven via: ``` org.junit.vintage:junit-vintage-engine:5.6.2 org.junit.jupiter:junit-jupiter-engine:5.6.2 org.junit.jupiter:junit-jupiter-params:5.6.2 org.junit.platform:junit-platform-launcher:1.6.2 ```","closed","component: Jupiter,","mikosik","2020-05-14T09:40:50Z","2020-07-29T09:47:09Z"
"","2982","Execution mode is needlessly coarsened","## Step to reproduce  Originally reported at: https://github.com/cucumber/cucumber-jvm/issues/2589.   Given a tree of test descriptors where one test declares a global resource lock:  ``` |- Container A | |- Test 1 ( .getExclusiveResources() => GLOBAL_READ_WRITE ) | |- Test 2 | \- Test 3 \- Container B   |- Test 4   |- Test 5   \- Test 6 ```  When executed in parallel `Container A` is executed with `ExecutionMode.SAME_THREAD`. This reduces the efficiency of parallel execution somewhat as the serial part of the execution now also includes tests 2 and 3.  ## Analysis   The same thread execution mode is applied to a container if any of its children has a `GLOBAL_READ_WRITE` lock:  https://github.com/junit-team/junit5/blob/5fdb138924f59703a6a4fcd0cdcde6d1a224a950/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java#L73-L76  The rationale for this behaviour is given in https://github.com/junit-team/junit5/issues/2038#issuecomment-541171707: > The (pessimistic) assumption behind forcing children of containers with resource locks to use execution mode SAME_THREAD is that the resource might not be safe to access in e.g. `@BeforeAll` methods and in different threads from `@Test` methods. Thus it's not the same as having `@ResourceLock` on every `@Test` method. IIRC we had a similar issue for `@Execution` only applying to methods while being declared on the class level.  While this is true for JUnit Jupiter, this is not the case for Cucumber. In Cucumber containers do not execute any hooks.  Providing containers with a way to signal that they are mere containers would allow the coarsened execution mode to be applied more selectively.","open","status: new,","mpkorstanje","2022-07-24T12:32:44Z","2022-07-24T19:27:38Z"
"","2226","Upgrade versions of 3rd-party libraries","## Status  https://github.com/junit-team/junit5/blob/2f6f5d8607177ca889ffc9d6c6528a81667ecf79/buildSrc/src/main/kotlin/Versions.kt#L7-L13  https://github.com/junit-team/junit5/blob/2f6f5d8607177ca889ffc9d6c6528a81667ecf79/buildSrc/src/main/kotlin/Versions.kt#L15-L25  https://github.com/junit-team/junit5/blob/2f6f5d8607177ca889ffc9d6c6528a81667ecf79/buildSrc/src/main/kotlin/Versions.kt#L27-L33  ## Deliverables  - [x] [Picocli 4.2.0](https://github.com/remkop/picocli/releases/tag/v4.2.0) - [x] AssertJ 3.16.0 + move to ""Dependencies"" section -- **not** 3.15.0 doesn't play nice on the module path. #2170  - [x] [ArchUnit 0.13.1](https://github.com/TNG/ArchUnit/releases/tag/v0.13.1) - [x] [ClassGraph 4.8.65](https://github.com/classgraph/classgraph/releases/tag/classgraph-4.8.65) - [x] [Groovy 3.0.2](https://github.com/apache/groovy/releases/tag/GROOVY_3_0_2) - [x] [Log4j 2.13.1](https://logging.apache.org/log4j/2.x/changes-report.html#a2.13.1) - ❌ [Mockito 3.3.6](https://github.com/mockito/mockito/releases/tag/v3.3.6) -- only 3.3.3 is on Maven Central - [x] [Checkstyle 8.31](https://checkstyle.org/releasenotes.html#Release_8.30) - [x] [JMH 1.23](https://github.com/openjdk/jmh/releases/tag/1.23)","closed","component: Groovy,","sormuras","2020-03-27T10:25:12Z","2020-07-17T14:27:47Z"
"","2281","Support file system resources in @CsvFileSource","## Problem description  Test resources are strange beasts. The compiler does not know about them nor cares, so getting the resources into the class path in typical builds needs help from the build system (ant, maven, gradle). This leads to several problems  - running a single test file (e.g. a first after project clean or fresh project) will not work, unless a more or less complete build step is executed. - copying the test file from one location to another without any transformation is a waste of time (and ssd wear). - Modifying the test data and rerun the test requires a rebuild (remember the deployment of the test data to the (test) class path, so modifying just the test data and re-run the test is not enough. - Test data should be considered input to the program, not a resource. A resource is a glorified constant, test data should be able to vary independent of program code, test or otherwise.  ## Original Proposal - Modify the InputStream creating method (see my remarks in #1970) to try file system first, then class path would be a sufficient change. This will create this feature very cheaply without changing current class path semantics. - Update @CsvFileSource documentation to reflect this change since the change proposal in #1970 adapts a private method in the CsvFileArgumentsProvider class.","closed","theme: parameterized tests,","homberghp","2020-04-30T13:31:09Z","2020-06-15T12:12:47Z"
"","2167","Re-order Stream API calls","## Overview We are conducting a research project on re-ordering Stream APIs for improving program execution speed.  Before and after re-ordering, we measured running time of tests which execute target Stream. Command for running tests is :  `time ./gradlew clean -Dtest.single=LockManagerTests test`  and the result is : ``` the order of Stream API      test running time =============================================== distinct().sorted()                 15.527s sorted().distinct()                 15.440s ``` ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","HirotoTanaka114","2020-01-28T06:33:16Z","2020-02-15T15:03:45Z"
"","2522","Remove spurious usage of the word simply","## Overview The word simply is used in roughly two situations:   * When used in instructional documentation the word simply often conveys a    value judgement about the complexity of a task. Not only is this    unnecessary, it makes a number of assumptions about the readers familiarity    with the concepts involved and can come across as condescending.   * When used to describe a default implementation, the word simply is used to    to convey that the description is a complete description of the    implementation. This should be unnecessary given the context.  As such nearly all usages of the world simply can be removed without a loss of clarity.  For more context and a longer argument I found the arguments made Jim Fisher in  his talk ""Don't Say Simply"" at Write the Docs Prague 2018[1] to be quite compelling.   1. https://www.youtube.com/watch?v=gsT2BBWBVmM ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","mpkorstanje","2021-01-10T18:13:49Z","2021-01-11T13:18:55Z"
"","2324","Fix broken Preconditions link in PULL_REQUEST_TEMPLATE","## Overview The current link leads to a 404.  Note that I also edited the [""Definition of Done"" wiki article](https://github.com/junit-team/junit5/wiki/Definition-of-Done), however there I switched to the `current` instead of `snapshot` link by accident. Sorry for this. Let me know if I should correct it.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","theme: documentation,","Marcono1234","2020-06-14T22:52:48Z","2020-06-15T12:50:54Z"
"","2632","Clarify intended usage of assert{Not}Equals","## Overview Resolves #2567  See https://github.com/junit-team/junit5/issues/2567#issuecomment-806626091.  The changes currently only adjust the `Assertions` documentation. Should the user guide be adjusted as well? And should this also be mentioned in the release notes? It is not a behavior change, so I am not sure how relevant it is for the release notes.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","Marcono1234","2021-05-29T18:37:59Z","2021-06-04T14:18:53Z"
"","2388","dump timezone and offset for junit reporter xml timestamp","## Overview related to https://github.com/pytest-dev/pytest/issues/7662  > It looks like pytest (and Junit) just takes the system time from OS, and save it to test report. Unfortunately, this timestamp doesn't have any timezone information, Our CI system will treat this timestamp as a UTC time, even the timestamp is actually from another time zone.    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","graingert","2020-08-20T12:28:34Z","2021-06-03T19:46:51Z"
"","2158","Fix stack overflow error in assertIterableEquals","## Overview Prior to this commit an iterable of iterables (here instances of java.nio.file.Path) passed to method `assertIterableEquals` in class `Assertions` of the JUnit Jupiter API yielded a `StackOverflowError`.  This commit prevent the eternal while-loop by leveraging the `equals()`-implementation of the non-null expected element.  Fixes #2157  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2020-01-20T12:17:46Z","2020-01-20T19:16:18Z"
"","2118","Introduce filtering of TestTemplateInvocationContextProvider","## Overview One test template method can have multiple TestTemplateInvocationContextProviders. As far as I know JUnit doesn't have a mechanism to filter them. If for some reason you need to run tests from subset of context providers here's several options that come to mind: 1. Edit value of ExtendWith by hand 2. Copypaste test template method with context providers you need 3. In theory you can use tagging, but for now you can't add tags programmatically in a list of context provider's extensions  So none of this approaches seem right  ## Proposal Introduce filtering mechanism for TestTemplateInvocationContextProvider, for instance `--testTemplate MyTestTemplate --includeProviders AwesomeContextProvider, EvenBetterContextProvider --excludeProviders NotSoAwesomeContextProvider`  ## Deliverables Added flexibility, reduced test code duplication","closed","theme: discovery,","AOreshin","2019-11-27T13:51:13Z","2019-11-29T17:07:20Z"
"","2043","Log containers and tests which are excluded by post discovery filters","## Overview Mention containers and tests that were ignored because of their tags or any other reason.  Current Behavior: During the execution of post-discovery filters, tests which are excluded does not print any message/reason, which leaves developers to be unaware of the reason for exclusion. Also, No reason was passed from TagFilter class.  Solution: Stores the Exclusion reason against the set of TestDescriptors and print this information after the discovery phase. Passed the inclusion or exclusion reason to FilterResult for TagFilter.  Closes #1514    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: diagnostics,","antimpatel","2019-10-06T12:22:56Z","2020-04-17T11:05:41Z"
"","2984","Bazel build support in user guide","## Overview Hi,  I want to draw attention to the build support provided by Junit 5 user guide.  I found that Bazel build support is missing in the user guide below section   https://junit.org/junit5/docs/current/user-guide/#running-tests-build  It would be great if we have Bazel also. Currently added in the documentation are Maven, Gradel and  Ant. It would be great if we have Bazel also  - ( ) **Question.** This issue tracker is not the place for questions. If you want to ask how to do something, or to understand why something isn't working the way you expect it to, please first use Stack Overflow or Gitter. https://stackoverflow.com/questions/tagged/junit5  - ( ) **Bug report.** Please provide us the version of JUnit 5 you are using and, if possible, a failing unit test with your bug report. Don't forget to describe the rationale for this issue (e.g. expected vs. actual behavior).  - ( ) **Feature request.** Start by telling us what problem you’re trying to solve. Often a solution already exists! Please, don’t send pull requests to implement new features without first getting our support.  ## Deliverables  https://junit.org/junit5/docs/current/user-guide/#running-tests-build  - [ ] ...","open","3rd-party: Bazel,","priyda","2022-07-26T12:56:33Z","2022-07-26T15:48:46Z"
"","2027","Fix link to section about parallel execution","## Overview Fixes a broken link to a section about parallel execution.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","sivaraam","2019-09-25T10:34:12Z","2019-09-26T08:23:42Z"
"","2323","Move Assertions.fail return type documentation to fail(String)","## Overview Fixes #2321 by moving the `Assertions.fail(...)` return type documentation and example to `Assertions.fail(String)` since the example did not fit for `fail(String, Throwable)` where it was previously.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","Marcono1234","2020-06-14T22:28:18Z","2020-06-15T15:50:42Z"
"","2945","Improve documentation about registering a `LauncherSessionListener'","## Overview Addresses #2826  Explicitly states the order and amount of notifications the `LauncherSessionListener` receives.  ## Before ![before](https://user-images.githubusercontent.com/23459549/174137296-0ed7ef04-8309-48dd-8eff-58127965fd98.png)  ## After ![after](https://user-images.githubusercontent.com/23459549/174137333-d48729a9-b57e-46e0-b546-c735f3de19e7.png)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","stoyanK7","2022-06-15T18:16:50Z","2022-07-01T19:21:20Z"
"","2042","Issue #1851: Inline assertThrows lambda arguments","## Overview **Resolves #1851 #1914**  Since provided executables for `assertThrows` invocations are marked as `noinline`, it is not possible to execute them with the same context as the call site. Thus it is not possible to call `assertThrows` on a suspended method from a `CoroutineContext`.  By including overloaded inline methods accepting the `Result<*>` parameter, it is possible to defer a `Throwable` being thrown until it can be evaluated in the java `Executable` instance, despite having already been executed in the calling context.  This approach resolves the issue of being unable to call `assertThrows` be suspended functions, without having to include an additional dependency on Coroutines, and inherits the calling Coroutine hierarchy.  Solution provided alongside #1853 which resolves the same issue through use of `runBlocking`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","ashdavies","2019-10-05T15:28:37Z","2020-04-20T14:56:50Z"
"","2636","Improve TestExecutionListener documentation in the User Guide","## Overview  With the recent introduction of the `FlightRecordingExecutionListener` and `UniqueIdTrackingListener`, we should take the opportunity to improve the documentation of `TestExecutionListener` implementations in general in the User Guide.  For example, we should introduce a new `TestExecutionListener` section in the ""Running Tests"" chapter of the User Guide that provides an overview of the `TestExecutionListener` support, with subsections covering `FlightRecordingExecutionListener` and `UniqueIdTrackingListener`.  ## Deliverables  - [x] Improve TestExecutionListener documentation in the User Guide","closed","component: Platform,","sbrannen","2021-06-03T15:36:57Z","2021-06-04T12:01:02Z"
"","2721","Introduce support for text blocks in `@CsvSource`","## Overview  With the introduction of support for _text blocks_ as a first-class language feature in recent JDKs (preview feature in Java SE 15), we can improve the user experience with `@CsvSource` by allowing the user to provide a text block instead of an array of strings.  ## Example  Given the following parameterized test using a text block...  ```java @ParameterizedTest @CsvSource(textBlock = """"""     apple,         1     banana,        2     'lemon, lime', 0xF1     strawberry,    700_000 """""") void csvSourceWithTextBlock(String fruit, int rank) { 	System.out.println(fruit + "" : "" + rank); } ``` ... the output is:  ``` apple : 1 banana : 2 lemon, lime : 241 strawberry : 700000 ```  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","sbrannen","2021-09-17T11:41:09Z","2021-09-19T16:29:32Z"
"","2336","Introduce MethodName orderer to replace deprecated Alphanumeric","## Overview  With the introduction of DisplayName orderer in 6fee44d, the name of the Alphanumeric orderer becomes ambiguous ie ""Alphanumeric of what?"". MethodName is a better name. It is unambiguous, it clearly states what it is using for ordering the tests and it's naming is consistent with the new orderer DisplayName.  Resolves: #2334    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","gaganis","2020-06-22T17:14:34Z","2020-07-13T15:30:29Z"
"","2068","Publish correct Gradle Module Metadata with Gradle 6","## Overview  With Gradle 6, `maven-publish` automatically published Gradle Module Metadata files (`.module`) in addition to POM metadata files. With this, more information, like additional dependency version constraints, can be provided to Gradle builds consuming JUnit 5 modules. This PR does the following to publish correct and richer Gradle Module Metadata with Gradle 6: - Upgrade the build to Gradle 6 RC1 - Set the JvmTargetVersion for all modules to `8` - Add a _platform dependency_ from each module to the JUnit BOM. This allows Gradle to **always** align the versions if multiple modules are in a dependency graph. - Changes the Javadoc and sources publishing configuration to use the new built-in support of Gradle   In addition this PR fixes a deprecation warnings and an issue with inner classes not correctly declared in a Kotlin DSL script.  An example of how the alignment works can be found here: https://github.com/jjohannes/what-if-gradle-metadata/tree/master/usecases/junit5-align-versions  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - **n/a** Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - **n/a**  Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - **n/a**  Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","jjohannes","2019-10-16T11:42:08Z","2019-10-19T09:12:51Z"
"","2431","Introduce TestSourceLocator for DynamicTests","## Overview  With dynamic tests in large classes (`TestClass`) it is difficult to find out where they were actually defined. The containing/declaring method (`testMethod()`) helps to get a rough understanding of the source of the test and assertion stacktrace shows where it went wrong, but dynamic tests are meant to test different setups/environment/instances and might be generated/inherited from a different method or class, so it would be nice if double-clicking the test would show the actual source (`""setup3""`) of the dynamic test.  ## Usage-Example  - ❌ TestClass (a)   - ❌ testMethod (b)     - ✔️ setup1     - ✔️ setup2     - ❌ setup3 `<-- This is where I (probably) need to do things`     - ✔️ setup4  ````java class TestClass {      @TestFactory     List testMethod() {         return asList(                  dynamicTest(""setup1"", () -> { // Might be created in a factory method                         // [...]                 }),                  dynamicTest(""setup2"", () -> { // or inherited from a parent class                         // [...]                 }),                  dynamicTest(""setup3"", () -> { // <--- I wish to get here (wherever ""here"" might be, e.g. in another/super method or class)                         // [...]                        assert(foo, bar); // The assertion fails here                         // [...]                 }),                  dynamicTest(""setup4"", () -> {                         // [...]                 }),          ).map(this::resetMocks);     }  } ````  ## Content  This PR adds a `TestSourceLocator` that automatically calculates a testSourceUri if none is specified. It isn't a finished implementation yet (It does what I believe it should do, but eclipse doesn't seem to be support it yet) but I would like to start a discussion regarding this feature request.  I also considered creating an issue for that first, but IMO actual code is more expressive.  ## Next steps  1. Discussion whether the feature request gets conceptually accepted 2. Convert to an actual PR with tests 3. Wait for merge 4. Add support to IDEs (if necessary)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: dynamic tests,","ST-DDT","2020-10-01T12:03:53Z","2022-05-22T16:29:24Z"
"","2647","Only search for annotations on enclosing class if current class is an inner class","## Overview  While working on the fix for #2645, I realized that our annotation search algorithms that fall back to searching on _enclosing classes_ also find annotations on enclosing classes even if the current nested class is a static nested class.  For example, given the following test case, the test method in `InnerNestedTests` passes; whereas, the test method in `StaticNestedTests` fails.  ```java @DisplayNameGeneration(ReplaceUnderscores.class) class DisplayNameGenerationInheritanceTests {  	@Nested 	class InnerNestedTests { 		@Test 		void this_is_a_test(TestInfo testInfo) { 			assertThat(testInfo.getDisplayName()).isEqualTo(""this is a test (TestInfo)""); 		} 	}  	// @DisplayNameGeneration(Standard.class) 	static class StaticNestedTests { 		@Test 		void this_is_a_test(TestInfo testInfo) { 			assertThat(testInfo.getDisplayName()).isEqualTo(""this_is_a_test(TestInfo)""); 		} 	} } ```  One could of course argue that this is be design; however, I'm not convinced that `@DisplayNameGeneration` and `@IndicativeSentencesGeneration` should be _inherited_ from an enclosing static class or top-level class if the current class is not an inner class.  For example, in the Spring Framework's testing support, I only search for an annotation on the enclosing class if the current class is an _inner class_:  https://github.com/spring-projects/spring-framework/blob/df588e030f069dd31997ff747839f1d8d5d8d7c7/spring-test/src/main/java/org/springframework/test/context/TestContextAnnotationUtils.java#L398-L401  ## Deliverables  - [x] Decide if want to retain the current semantics. - [ ] If so, document those semantics for `@DisplayNameGeneration` and `@IndicativeSentencesGeneration` and anywhere else we employ such a search algorithm. - [x] If not, change the algorithm to match the behavior in the Spring Framework and document the new semantics.","closed","component: Jupiter,","sbrannen","2021-06-17T16:59:04Z","2021-06-18T13:51:47Z"
"","2347","Describe deprecation in CONTRIBUTING.md","## Overview  While working for #2336 we have found that it could be useful to document the deprecation procedure in more detail in the CONTRIBUTING.md.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","gaganis","2020-07-01T12:23:48Z","2020-07-13T15:39:44Z"
"","2004","JupiterTestEngine crashes if JUnit 4 is on the classpath but Hamcrest is not","## Overview  While migrating the Spring Framework test suite from JUnit 4 and Hamcrest to JUnit Jupiter and AssertJ, entire projects in Spring's test suite started reporting zero tests after removing the dependency on Hamcrest even though the tests no longer used Hamcrest. Adding Hamcrest back as a test runtime dependency allowed the tests to execute again.  ## Analysis  Thanks to some investigative work by @marcphilipp, we came to the following conclusion.  The `JupiterTestEngine` fails with a `NoClassDefFoundError` if JUnit 4 is on the classpath but Hamcrest is not. The underlying reason is that `OpenTest4JAndJUnit4AwareThrowableCollector` has a `static` initialization block that checks if the `org.junit.internal.AssumptionViolatedException` class can be loaded. However, since `AssumptionViolatedException` has a direct dependency on `org.hamcrest.Matcher`, a `NoClassDefFoundError` is thrown when attempting to load `AssumptionViolatedException`.  ## Deliverables  - [x] Refactor `OpenTest4JAndJUnit4AwareThrowableCollector` so that a failed attempt to detect the presence of `AssumptionViolatedException` in the classpath does not crash the entire `JupiterTestEngine`. - [x] Document in the Release Notes.","closed","component: Jupiter,","sbrannen","2019-09-07T11:24:37Z","2019-09-08T13:16:55Z"
"","2884","Remove BOM dependencies from artifacts defined in the BOM to enable participation in Gradle source dependencies","## Overview  While investigating solutions to https://github.com/junit-team/junit5/issues/2883 I attempted to use a Gradle [source dependency](https://blog.gradle.org/introducing-source-dependencies) to depend on the latest version of this project since I couldn't find a published snapshot.  The build with a source dependency failed due to what looks like a circular dependency: most artifacts have a dependency on a BOM that declares them (and hence depends on them).  ``` Could not determine the dependencies of task ':compileTestKotlin'. > Could not resolve all task dependencies for configuration ':testCompileClasspath'.    > Could not find any version that matches org.junit.jupiter:junit-jupiter:5.9.0-SNAPSHOT.      Searched in the following locations:        - Git repository at https://github.com/junit-team/junit5.git      Required by:          project : > project :junit5:junit-jupiter > project :junit5:junit-bom ```  When I remove the circular dependency with this change the source dependency build succeeds.  Open questions: - Is there a reason the BOM is used in this way? - Should I try to add a test to cover this? Could be tricky.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","andrewparmet","2022-04-10T14:21:00Z","2022-04-10T21:19:23Z"
"","2618","Add DisableParentConfigurationParameters annotation to junit-platform-suite-api","## Overview  Where practical the capabilities of the Junit Platform Launcher API and the JUnit Platform Suite API should retain parity. Currently the the Suite API is missing the ability to control whether or not implicit parameters are used. This PR aims to correct that omission.  A potential concrete use case would be the execution of tcks (e.g. #2594) where the execution of the imported test suite should not be influenced by implicit properties.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: suites,","mpkorstanje","2021-05-16T18:24:38Z","2021-08-13T18:28:34Z"
"","2759","Support CSV headers in display names in parameterized tests","## Overview  When using `@CsvSource`, CSV headers are not supported. With `@CsvFileSource`, the first `n` lines of each file can be skipped, which allows headers to be present in a CSV file but not used.  Ideally, one should be able to provide headers in a text block when using `@CsvSource` or in a file when using `@CsvFileSource`, and these headers can be used when generating the display name for each invocation of the `@ParameterizedTest`.  ## Proposal  This feature can be implemented using the `Named` API to associate each column value with its corresponding header.  Given the following parameterized test that sets `useHeadersInDisplayName` to `true` and uses `{arguments}` instead of `{argumentsWithNames}` for its display name pattern...  ```java @ParameterizedTest(name = ""[{index}] {arguments}"") @CsvSource(useHeadersInDisplayName = true, textBlock = """""" 	FRUIT,  RANK 	apple,  1 	banana, 2 	cherry, 3 	"""""") void test(String fruit, int rank) {} ```  The generated display names are:  ``` [1] FRUIT = apple, RANK = 1 [2] FRUIT = banana, RANK = 2 [3] FRUIT = cherry, RANK = 3 ```","closed","theme: parameterized tests,","sbrannen","2021-10-29T11:22:41Z","2021-11-02T14:21:01Z"
"","2530","Block parallel tests longer on CI","## Overview  Various tests in `ParallelExecutionIntegrationTests` verify that different tests were indeed executed by different threads. To ensure that an incorrect implementation does not block the test suite indefinitely these tests contain an intentional race condition.  This race condition assumes awaiting at most 100ms will be sufficient to schedule another thread. This assumption is hardware dependent and does not hold on Github CI[1]. Increasing the maximum time spend waiting by a factor 10 while in CI is hopefully sufficient.  1. https://github.com/junit-team/junit5/pull/2416/checks?check_run_id=1712237454 ``` 2021-01-16T02:00:44.8166959Z > Task :platform-tests:test 2021-01-16T02:00:44.8167430Z 2021-01-16T02:00:44.8168932Z ParallelExecutionIntegrationTests > customContextClassLoader() FAILED 2021-01-16T02:00:44.8177847Z     java.lang.AssertionError: 2021-01-16T02:00:44.8178812Z     Expected size:<3> but was:<2> in: 2021-01-16T02:00:44.8179762Z     <[""ForkJoinPool-19-worker-3"", ""ForkJoinPool-19-worker-5""]> 2021-01-16T02:00:44.8183737Z         at org.junit.platform.engine.support.hierarchical.ParallelExecutionIntegrationTests.customContextClassLoader(ParallelExecutionIntegrationTests.java:135) 2021-01-16T02:01:05.6171111Z 2021-01-16T02:01:05.6173697Z ParallelExecutionIntegrationTests > customContextClassLoader() FAILED 2021-01-16T02:01:05.6175991Z     java.lang.AssertionError: 2021-01-16T02:01:05.6177743Z     Expected size:<3> but was:<2> in: 2021-01-16T02:01:05.6178859Z     <[""ForkJoinPool-1-worker-3"", ""ForkJoinPool-1-worker-5""]> 2021-01-16T02:01:05.6183298Z         at org.junit.platform.engine.support.hierarchical.ParallelExecutionIntegrationTests.customContextClassLoader(ParallelExecutionIntegrationTests.java:135) 2021-01-16T02:01:09.0267715Z 2021-01-16T02:01:09.0280937Z 2021-01-16T02:01:09.0282574Z ParallelExecutionIntegrationTests > customContextClassLoader() FAILED 2021-01-16T02:01:09.0283978Z 1534 tests completed, 3 failed, 7 skipped 2021-01-16T02:01:09.0284818Z     java.lang.AssertionError: 2021-01-16T02:01:09.0290826Z     Expected size:<3> but was:<2> in: 2021-01-16T02:01:09.0291728Z     <[""ForkJoinPool-1-worker-3"", ""ForkJoinPool-1-worker-5""]> 2021-01-16T02:01:09.0295567Z         at org.junit.platform.engine.support.hierarchical.ParallelExecutionIntegrationTests.customContextClassLoader(ParallelExecutionIntegrationTests.java:135) ``` ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mpkorstanje","2021-01-16T02:57:41Z","2021-01-17T15:50:13Z"
"","2099","Introduce TestExecutionListener for configuring Java Logging for test suites","## Overview  Various logging frameworks have mechanisms for test configuration. For example, log4j2 supports a `log4j2-test.xml` file in the root of the classpath, which people typically store under `src/test/resources`.  Java Util Logging (JUL) on the other hand has no mechanism for automatic discovery of test configuration. One can of course set the `java.util.logging.config.file` JVM system property, but that can be cumbersome since one would have to set it for every single run configuration within an IDE.  For the Spring Framework, I introduced a JUnit Platform `TestExecutionListener` that automatically looks for a file named `jul-test.properties` in the root of the classpath and used it to configure JUL. See this commit for details: https://github.com/spring-projects/spring-framework/commit/89b3a9cef218c0d6ff3121d3f0c386b0c2f06dbc  ## Deliverables  - [ ] Decide if it would be useful to introduce such a `TestExecutionListener` as an opt-in feature of the JUnit Platform.","closed","status: stale,","sbrannen","2019-11-14T13:54:52Z","2021-06-19T12:50:07Z"
"","2829","Use `oracle-actions/setup-java` to install JDK","## Overview  Use https://github.com/oracle-actions/setup-java to download and install an OpenJDK 18 build from https://jdk.java.net  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","sormuras","2022-02-14T08:42:31Z","2022-02-14T08:53:53Z"
"","2627","Use actions/setup-java@v2","## Overview  Update our Java setup for GH Actions.","closed","","marcphilipp","2021-05-28T07:21:50Z","2021-05-28T08:11:43Z"
"","2739","bnd: Replace use of conventions with extensions","## Overview  Update Bnd to 6.0.0 and replace the use of gradle conventions which have been deprecated.  We also exploit the new Kotlin DSL support for the `bundle` extension.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","bjhargrave","2021-10-05T13:25:32Z","2021-10-18T11:03:30Z"
"","2207","Improve check for multiple junit-platform.properties files","## Overview  Today, the following warning is generated...  https://github.com/junit-team/junit5/blob/e79dde3a30b146000743e754fc4c3355cfe70736/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfigurationParameters.java#L60  ...and emitted even if the `junit-platform.properties` resource is only once physically present.  This false positive is due to using...  https://github.com/junit-team/junit5/blob/e79dde3a30b146000743e754fc4c3355cfe70736/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfigurationParameters.java#L55  ...which may include duplicated elements when a custom class loader hierarchy is used. For details see the **""Implementation Requirements""** at: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#getResources(java.lang.String)  ## Example  JDK 11, IntelliJ IDEA, in-module (white box) testing with...  ```java   @Test   void getJUnitPlatformProperties() throws Exception {     var loader = getClass().getClassLoader();     System.out.println(""loader = "" + loader);     System.out.println(""loader.parent = "" + loader.getParent());     System.out.println(""loader.parent.parent = "" + loader.getParent().getParent());     System.out.println();     System.out.println(""single: "" + loader.getResource(""junit-platform.properties""));     System.out.println();     var urls = Collections.list(loader.getResources(""junit-platform.properties""));     urls.forEach(url -> System.out.println(""multi: "" + url));     System.out.println();     var distinct = new HashSet<>(urls);     distinct.forEach(url -> System.out.println(""distinct: "" + url));   } ``` ...emits: ``` loader = jdk.internal.loader.ClassLoaders$AppClassLoader@28864e92 loader.parent = jdk.internal.loader.ClassLoaders$PlatformClassLoader@e24ddd0 loader.parent.parent = null  single: file:/.../.idea/out/test/de.sormuras.bach/junit-platform.properties  multi: file:/.../.idea/out/test/de.sormuras.bach/junit-platform.properties multi: file:/.../.idea/out/test/de.sormuras.bach/junit-platform.properties  distinct: file:/.../.idea/out/test/de.sormuras.bach/junit-platform.properties ```  ## Deliverables  - [x] Prune duplicate elements before checking the amount of found resources","closed","component: Platform,","sormuras","2020-03-06T08:03:30Z","2020-03-22T09:29:39Z"
"","2418","Update Gradle Enterprise Plugin","## Overview  This updates the Gradle Enterprise Gradle plugin to the latest version. This also fixes the usage of an internal api that was moved packages.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","runningcode","2020-09-22T13:51:26Z","2020-09-22T15:13:08Z"
"","2782","Add an example of inner class fully qualified method name","## Overview  This took me a while to figure out the syntax, so I thought improving the documentation could be beneficial. As an aside, there are also no tests for `MethodSource` with an inner class.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  Doco-only change, so DoD is not relevant.","closed","theme: parameterized tests,","VirtualTim","2021-11-16T04:14:12Z","2022-05-15T17:48:32Z"
"","2350","Cache Gradle wrapper and dependencies on CI builds","## Overview  This should speed up CI builds as Gradle distributions and external dependencies no longer have to be downloaded each time. Since there are also some Maven integration tests, the local Maven repository is also cached.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","oehme","2020-07-05T13:04:08Z","2020-07-20T06:56:03Z"
"","2724","Fix unintended exceptions in assertLinesMatch","## Overview  This pull request fixes two bugs in the `assertLinesMatch` implementation. The two bugs cause unintended exceptions to be thrown: 1. Fast-forward lines are not trimmed consistently, causing an `IndexOutOfBoundsException` when `""  >> 2 >>  ""` is used, for example. This also caused `"" >> 2 >> ""` to be interpreted as unlimited fast-forward.        This PR adds the missing `String.trim()` and adds test cases that fail without the fix. 2. A limited fast-forward that is not terminal (followed by at least one more expected line) causes a `NoSuchElementException` if it exceeds the number of remaining actual lines.        This PR adds an `if` that will cause the assertion to fail with a detailed message and adds a test case that fail without the fix.  *This is my first pull request here, I welcome any feedback from maintainers how to improve. In particular, I am not sure what the best failure message for the `fail` in the second bug fix is.*  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","MaisiKoleni","2021-09-19T14:34:31Z","2021-09-21T10:52:18Z"
"","2978","#2622 Add new AnnotationBasedArgumentsProvider","## Overview  This PR solves #2622  New abstract class `AnnotationBasedArgumentsProvider` was added and all arguments providers that implemented the `AnnotationConsumer` interface were changed to extend from it.   The `AnnotationConsumerInitializer` was adjusted to recognize the annotation present in `AnnotationBasedArgumentsProvider#provideArguments` since it could not recognize the annotation in `AnnotationBasedArgumentsProvider#accept` method because its type is generic.  Preconditions were added to `provideArguments` and `accept` methods, none of its arguments should be `null`  I'm not sure where to put the release notes, so I did not do it.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","","gilbertojrequena","2022-07-12T19:29:02Z","2022-08-02T13:01:08Z"
"","2217","Make JAR builds reproducible","## Overview  This PR makes the java bytecode generated by this project [reproducible](https://reproducible-builds.org/). This means that under identical builds condition (for example Java version), repeated builds should provide the same output byte-for-byte.  It achieves this by:  * supporting [`SOURCE_DATE_EPOCH`](https://reproducible-builds.org/specs/source-date-epoch/) as a way of fixing build-time-specific metadata added to JARs * using Gradle's [reproducible archives](https://docs.gradle.org/current/userguide/working_with_files.html#sec:reproducible_archives) functionality to fix timestamps and file ordering within JARs * re-archiving JARs that are non-deterministic because they use `jar` to rewrite their contents after build.  ## Confirming the change  ```shell #!/bin/bash -e  rm -f checksums*  # Fix build time export SOURCE_DATE_EPOCH=$(date +%s)  ./gradlew clean build -x test --parallel --rerun-tasks  find . -name '*.jar' \     | grep '/build/libs/' \     | grep -v 'javadoc' \     | sort \     | xargs sha256sum > checksums-1.txt  ./gradlew clean build -x test --parallel --rerun-tasks  find . -name '*.jar' \     | grep '/build/libs/' \     | grep -v 'javadoc' \     | sort \     | xargs sha256sum > checksums-2.txt  diff checksums-{1,2}.txt ```  The diff should be empty, that is to say, both independent runs of the build should have generated byte-for-byte identical outputs.  ## Omitting Javadocs  The javadocs outputs remain non-deterministic - despite the inclusion of `noTimestamp(true)` in the project's javadoc configuration, the comment header is still being generated. It looks like the javadoc mechanism in Gradle isn't honouring this flag.  I wasn't able to solve this problem, but would be necessary to achieve full reproducibility.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement). ✅   ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","mrwilson","2020-03-18T22:33:36Z","2022-05-15T15:29:09Z"
"","2949","Add thread mode to @Timeout","## Overview  This PR is an attempt to solve the issue #2087, allowing to set the thread mode in the `@Timeout` annotation.   Instead of calling the enum `Mode`, I called it `ThreadMode` since there was already a configuration parameter called `TIMEOUT_MODE_PROPERTY_NAME` which can lead to confusion.  `INFERRED` is used as default, in case no thread mode is provided by the configuration parameter `SAME_THREAD` is used as default.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","gilbertojrequena","2022-06-20T20:46:02Z","2022-06-26T14:23:45Z"
"","2130","Add support for using any()/none() in tag expressions","## Overview  This PR introduces support for two special tag expressions, `none()` and `any()`.  Resolved #1679.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mmerdes","2019-12-17T16:44:59Z","2020-01-07T19:25:58Z"
"","2767","Support CSV headers in display names in parameterized tests","## Overview  This PR for #2759 is ready for technical review.  Once the implementation has been approved the remaining documentation _Deliverables_ will be addressed before merging into `main` and `5.8.x`.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Introduce a `useHeadersInDisplayName` attribute in `@CsvSource` and `@CsvFileSource` which enables this feature. - [x] When enabled, process the first CSV record as header names and use those names via the `Named` API to achieve the results in the proposal - [x] Update Javadoc - [x] Document in User Guide - [x] Document in Release Notes - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","sbrannen","2021-11-02T14:18:40Z","2021-11-19T15:00:42Z"
"","2737","Treat text blocks as files in `@CsvSource`","## Overview  This PR for #2734 is feature complete in terms of implementation and ready for review.  Documentation updates will follow, once this PR has been approved based on technical merit.  One topic for discussion is the use of reflection to invoke `java.lang.String#trimIndent()` on Java 15+. An alternative proposed by @sormuras would be to make use of the MR JAR format (multi-release JAR) as was done with `ModuleUtils`. If the team decides to go that route, we could introduce a new `TextBlockUtils` class in a `java15` source folder in `junit-platform-commons` that uses `java.lang.String#trimIndent()`, with a simplified version of `TextBlockUtils` in the standard source folder that does not actually trim indentation.  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","sbrannen","2021-10-03T16:39:00Z","2021-10-26T11:14:14Z"
"","2895","Enable Predictive Test Selection for local and PR builds","## Overview  This PR enables [Gradle Enterprise Predictive Test Selection](https://gradle.com/gradle-enterprise-solutions/predictive-test-selection/) ([user manual](https://docs.grdev.net/enterprise/predictive-test-selection/)) for local and PR builds. CI builds on `main` and `release/*` will continue to always execute all tests.","closed","theme: build,","marcphilipp","2022-04-22T10:00:06Z","2022-04-22T10:19:51Z"
"","2032","Implement safer variant to ensure CDATA end markers result in valid XML","## Overview  This PR changes the implementation of `XmlReportWriter. writeCDataSafely(...)` to be even safer by always passing valid CDATA content to `javax.xml.stream.XMLStreamWriter.writeCData(...)`.  The current implementation passes a String to `javax.xml.stream.XMLStreamWriter.writeCData(...)` that might not be valid CDATA content, i.e. it might contain `]]>`. This causes issues if the implementation of that method validates its parameter value.  The PR does not change the produced XML, which is covered by `XmlReportWriterTests.writesValidXmlEvenIfExceptionMessageContainsCData()`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","chschu","2019-09-26T18:44:01Z","2019-11-25T10:40:55Z"
"","2250","Issues/1771 testkit loose event matching","## Overview  This PR adds two new assert-methods for partial matching, with or without ordering requirements.  Resolves #1771.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Test Kit,","mmerdes","2020-04-07T13:36:57Z","2020-04-19T14:58:42Z"
"","2880","Use registered ParameterResolver(s) when invoking @MethodSource factory methods","## Overview  This PR adds the possibility to provide arguments to a `@MethodSource` factory method. They will be resolved by any registered `ParameterResolver` supporting this type of parameter.  Closes #2191  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","juliette-derancourt","2022-04-08T10:36:15Z","2022-05-13T11:01:56Z"
"","2060","Introduce discovery listeners and abort discovery on failures by default","## Overview  This PR adds the ability to add `LauncherDiscoveryListeners` to `LauncherDiscoveryRequests`. Such listeners are notified when engines resolve or fail to resolve a `DiscoverySelector` and can decide how to handle this. The default listener (up for debate!), currently only logs messages. The new `abortOnFailure()` listener, however, throws exceptions thereby effectively aborting test discovery.  Resolves #2052.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","marcphilipp","2019-10-12T19:44:57Z","2019-10-21T14:10:27Z"
"","2138","Add support for WildCardType and type hierarchy for TypeBasedParameterResolver","## Overview  This new implementation supports WildCardType and type hierarchy thanks to the usage of  `TypeUtils.isAssignable` provided by apache commons lang3.   Drawback : it adds a new dependency to JUnit Jupiter.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","julien-topcu","2019-12-20T13:43:59Z","2020-03-27T13:36:42Z"
"","1977","Make console printing listeners public (and other reporting enhancements)","## Overview  This is an implementation of #1963, with a couple of other changes thrown in.  I created a new package in junit-platform-reporting called `org.junit.platform.reporting.console` and moved all the three listener class implementations into that package. I also had to remove a couple of the ancillary classes along with them that were used for configuring the listeners (`Theme`, `Color`), or for implementing some of their core functionality (`TreePrinter`). This part was fairly straightforward, and hopefully uncontroversial. The listener classes and those used for configuration were made public; the implementation classes were left package private.  In order to make the classes more user friendly, I added some overloaded constructors with default options and added some documentation. The documentation is based on my reading of the code - hopefully I didn't get it too wrong (in particular, if someone could check my comments about the relative merits & functionality of the `TreePrintingListener` vs `VerboseTreePrintingListener`, that would be appreciated).  I marked all of the newly publicized classes with the `@API` annotation, marking them as experimental as of 1.6.  Internally, the console listeners all had a flag `disableAnsiColors`. I have taken the opportunity to flip the polarity on this and called it `useAnsiColors`, as this is easy to do while the API is not public. The console executor still processes the command line the same way and takes care of the conversion.  Another changes was to move `LegacyReportingUtils` from `junit-platform-launcher` to `junit-platform-reporting`. Reasoning:  * It seems to belong more properly in that module rather than in the launcher module - it is a reporting tool, not a launching tool. * The only place in the JUnit 5 source tree where it was actually used is in the reporting module (`LegacyXmlReportGeneratingListener`). * The fact that this class was split and in the wrong package/module caused me a few headaches when I was trying to use it in an OSGi context.  Finally, I added a feature to `LegacyXmlReportGeneratingListener` so that you can override the behaviour as to when an xml file is generated. The original implementation would generate one file per root in the test hierarchy. The new feature allows you to override this so that you can (eg) produce one xml file per test class, or per other container level. This is a feature that I would have found useful for the Bnd JUnit Platform tester implementation. This feature is isolated to its own commit and if necessary could be hived off to its own PR.  Thoughts/comments/suggestions welcome!","closed","status: stale,","kriegfrj","2019-08-10T13:30:38Z","2021-06-03T19:46:49Z"
"","2680","Support declarative extension registration on fields and parameters","## Overview  This is a PR for #864.  The implementation is essentially feature complete and tested (following the 80/20 rule); however, there are some points that should be discussed before merging this PR into the `main` branch.  ## Topics for Discussion  When discussing any of these topics, I recommend that you review the current behavior by analyzing the tests in `ExtensionRegistrationViaParametersAndFieldsTests` before spending time studying the actual implementation details.  1. **Registration Order**: I have done my best to register extensions in the order in which the fields or parameters are used in the lifecycle of a test class and test method. This can be inspected in the `registrationOrder()` test method. Implementation details can be found in `ClassBasedTestDescriptor` and `TestMethodTestDescriptor`. 2. **`@Order` Support**: `ExtensionUtils.registerExtensionsFromFields()` already supported `@Order` for extensions registered via `@RegisterExtension`, and `@Order` is now also applied to extensions registered via fields using `@ExtendWith`. But... `@ExtendWith` extensions are registered _before_ `@RegisterExtension` extensions. 3. **`@ExtendWith` target**: `@ExtendWith` can currently be declared on a `TYPE` or `METHOD`. It cannot be declared directly on a `PARAMETER` or `FIELD`. 4. **Private fields**: `@RegisterExtension` fields are not allowed to be `private`, but in this PR fields meta-annotated with `@ExtendWith` are allowed to be `private`.  I will share my thoughts on these topics as comments and invite feedback.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sbrannen","2021-08-03T12:23:53Z","2021-09-18T14:55:57Z"
"","2025","WIP: use stack for tests in Vintage","## Overview  This is a POC for https://github.com/junit-team/junit5/issues/2021  Unfortunately it does not fully work, however I might need to debug it a bit.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: superseded,","vlsi","2019-09-23T22:37:54Z","2019-10-06T15:43:37Z"
"","2630","Introduce a Unique ID tracking TestExecutionListener","## Overview  This is a draft PR for #2619.  The feature should be functionally complete.  This PR is ""draft"" status for review of the feature in general but more importantly to gain consensus on the names of the system properties that are used to configure the listener.  Documentation will be added once there is consensus on the implementation and naming for the system properties.  All commits will be squashed prior to merging with an appropriate commit message.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sbrannen","2021-05-28T09:04:20Z","2021-05-31T18:22:57Z"
"","2790","Document how to run the ConsoleLauncher with classpath wildcards","## Overview  This enables you to use the compact ""jar star"" pattern in your classpath. Partially addresses https://github.com/junit-team/junit5/issues/2788  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","mbucc","2021-12-08T22:18:32Z","2022-05-15T17:45:59Z"
"","2805","#1858 add ThreadPoolHierarchicalTestExecutorService as optional alternative to ForkJoinPoolHierarchicalTestExecutorService (resolve JUnit 5 + Selenium 4 + Parallelism-issues)","## Overview  This draft-PR ist kind of a POC how we may able to solve https://github.com/junit-team/junit5/issues/1858 and https://github.com/SeleniumHQ/selenium/issues/9359. I´d like to collect your feedback before investing more time into this PR.  IMO `ForkJoinPoolHierarchicalTestExecutorService` still should be default for parallel execution. `ThreadPoolHierarchicalTestExecutorService` may become kind of an configureable alternative for special usecases.  (Some more details regarding the root cause for this issue see https://github.com/junit-team/junit5/issues/1858#issuecomment-1003008244)  CC @titusfortner   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","christophs78","2021-12-31T08:47:59Z","2022-01-02T08:52:45Z"
"","2404","Add JUnit Platform JFR in Dependency Metadata and Diagram","## Overview  This commit also removes the dependency metadata from the `README.md` file and replaces it with a link to the user guide instead.  Closes #2403  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2020-09-14T10:18:08Z","2021-02-11T11:45:12Z"
"","2961","Context of the Test is passed to the constructor when test instance is created","## Overview  This change will give a MethodExtensionContext instead of a ClassExtensionContext to the construction of a constructor for a Test(Template). Before this change, if a test was created, there was no context for what the test was run, now there is context and also the display-name can be taken from the context.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [X] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","","svenkost","2022-07-04T04:22:34Z","2022-07-10T07:08:06Z"
"","2449","Support parallelization in junit-vintage-engine","## Overview  This change updates the JUnit Vintage Test Engine to read the parallel configuration parameters, and if parallel execution is enabled, creates a thread pool for executing the test descriptors concurrently. The approach for configuring the thread pool emulates the logic used by the Jupiter Test Engine.  I tested this with the Maven Surefire plugin with the following configuration:      ... 		 		    junit 		    junit 		    test 		 	     ...                              org.apache.maven.plugins                 maven-surefire-plugin                                      classes                     4                                                                                org.junit.vintage                         junit-vintage-engine                         5.8.0-SNAPSHOT                                                    	      ...  Setting `parallel` to both `classes` and `all` behave as expected.  ### Open Questions  * It was not clear to me how the Maven Surefire plugin interfaces with the JUnit vintage engine. I enabled concurrency for top-level `TestDescriptor` instances. The unit test I created only tests parallelism enabled and parallelism disabled. * ~Also, should I update the user guide and release notes within the scope of this PR?~ I included the user guide and release notes changes in this PR. If they should be separate, please let me know.  Issue: #2229  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","l0s","2020-10-15T07:17:37Z","2022-05-23T14:26:22Z"
"","2711","Add implicit conversion from integral types to byte array","## Overview  This adds implicit type conversion from integral types to byte array.   | Source Type       | Target Type | Example                                                                            | |-------------------|-------------|------------------------------------------------------------------------------------| | `byte` / `Byte`   | `byte[]`    | `0xF` → `ByteBuffer.allocate(Byte.BYTES).put((byte) 0xF).array()`                     | | `short` / `Short` | `byte[]`    | `0xFFF` → `ByteBuffer.allocate(Short.BYTES).putShort((short) 0xFFF).array()`           | | `int` / `Integer` | `byte[]`    | `0xFFFFFFF` → `ByteBuffer.allocate(Integer.BYTES).putInt(0xFFFFFFF).array()`       | | `long` / `Long`   | `byte[]`    | `0xFFFFFFFFL` → `ByteBuffer.allocate(Long.BYTES).putLong(0xFFFFFFFFL).array()` |  Fixes #2702.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","scordio","2021-09-07T23:03:19Z","2022-01-20T12:27:06Z"
"","2649","Introduce AnnotationSupport.findAnnotation() variant that searches on enclosing classes","## Overview  This a follow up to #2647 that aims to make the new `org.junit.platform.commons.util.AnnotationUtils.findAnnotation(Class, Class, boolean)` feature available to `TestEngine` and extension authors.  See also [this thread](https://twitter.com/knutwannheden/status/1404685536527327233) on Twitter.  ## Implementation Considerations  The new method in `AnnotationSupport` does not necessarily have to have the same name or signature as the internal method in `AnnotationUtils`. We may choose a different method name in order to avoid the simplistic `boolean` flag to enable the feature, since setting the flag to `false` makes the method behave the same as the existing `findAnnotation()` methods. Alternatively, we may wish to introduce an enum instead of a boolean flag in order to be able to support additional semantics in the future.  ## Deliverables  - [x] Design the new API. - [x] Implement the new API. - [x] Document it in release notes.","closed","type: new feature,","sbrannen","2021-06-20T16:02:10Z","2021-08-12T13:38:51Z"
"","2874","Fix indentation in buildSrc/build.gradle.kts","## Overview  The title says it all.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","dbgsprw","2022-03-30T17:39:51Z","2022-04-03T15:33:23Z"
"","2704","`@Nested` test class constructors with arguments are broken on JDK 8","## Overview  The support for registering extensions via `@ExtendWith` on parameters is broken on JDK 8 for `@Nested` test class constructors that accept arguments.  This is due to a bug in JDK 8 and my broken workaround for that bug in JUnit 5.8 RC1.  Our build does not detect this, since we do not compile our tests using JDK 8.  If we compiled with JDK 8, our `NestedConstructorParameterTestCase` would fail.  The following stack trace is from a failing test in the `spring-test` module in the Spring Framework.  ``` org.junit.platform.commons.PreconditionViolationException: Parameter index must not be 0 for an inner class constructor 	at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:281) 	at org.junit.platform.commons.util.AnnotationUtils.getEffectiveAnnotatedParameter(AnnotationUtils.java:429) 	at org.junit.platform.commons.util.AnnotationUtils.findRepeatableAnnotations(AnnotationUtils.java:268) 	at org.junit.jupiter.engine.descriptor.ExtensionUtils.lambda$registerExtensionsFromExecutableParameters$5(ExtensionUtils.java:159) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485) 	at org.junit.jupiter.engine.descriptor.ExtensionUtils.registerExtensionsFromExecutableParameters(ExtensionUtils.java:161) 	at org.junit.jupiter.engine.descriptor.ExtensionUtils.registerExtensionsFromConstructorParameters(ExtensionUtils.java:138) ```  ## Deliverables  - [x] Ensure that `@Nested` test class constructors can accept arguments on JDK 8.","closed","component: Platform,","sbrannen","2021-09-02T11:22:01Z","2021-09-02T11:54:21Z"
"","2239","assertTimeoutPreemptively should provide reference to future or executor service parameter","## Overview  The stack trace of the `future` used for `assertTimeoutPreemptively` provides valuable information for where a test thread gets ""stuck"" and is itself valuable for assertions.  ## Proposal  Provide a reference to the `future` used to execute the code under test. This way, users can see, in their errors, where the code hung. Or, users can assert that, e.g., a blocking method correctly blocked.  A robust way to do this, supporting whatever functionality users may want, would be to add a `assertTimeoutPreemptively` overload that accepts an `ExecutorService`. There, users can provide a `ThreadedPoolExecutor` with a `newTaskFor` overload.  Alternatively, the `ExecutorService` can be provided by a `@Rule` (?) But I'm not too familiar with the big picture configuration for JUnit5.  JUnit5 doesn't seem to use custom exceptions, not does it pass information about the assertion failure to callbacks. This seems to be the most flexible way to provide a look into the timeout that future library authors can use without changing conventions.  ## Deliverables   - [ ] A new signature for `assertTimeoutPreemptively`:  ```java public static  T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier supplier, Object messageOrSupplier, ExecutorService executorService) ```  ## Workaround  Copy and paste the implementation out of JUnit and modify it to print the failed thread's stack trace:  ```java static  T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier supplier, 	                                              Object messageOrSupplier) {  		var thread = new AtomicReference(); 		var factory = new ThreadFactory() { 			@Override 			public Thread newThread(@NotNull Runnable r) { 				thread.set(new Thread(r)); 				return thread.get(); 			} 		};  		ExecutorService executorService = Executors.newSingleThreadExecutor(factory);  		try { 			Future future = executorService.submit(() -> { 				try { 					return supplier.get(); 				} catch (Throwable throwable) { 					throw ExceptionUtils.throwAsUncheckedException(throwable); 				} 			});  			long timeoutInMillis = timeout.toMillis(); 			try { 				return future.get(timeoutInMillis, TimeUnit.MILLISECONDS); 			} catch (TimeoutException ex) { 				ex.setStackTrace(thread.get().getStackTrace()); 				throw new AssertionFailedError(buildPrefix(nullSafeGet(messageOrSupplier)) 						+ ""execution timed out after "" + timeoutInMillis + "" ms\ntask stacktrace:\n"" + Throwables.getStackTraceAsString(ex)); 			} catch (ExecutionException ex) { 				throw ExceptionUtils.throwAsUncheckedException(ex.getCause()); 			} catch (Throwable ex) { 				throw ExceptionUtils.throwAsUncheckedException(ex); 			} 		} finally { 			executorService.shutdownNow(); 		} 	} ```","closed","component: Jupiter,","doctorpangloss","2020-04-04T18:47:17Z","2020-08-02T12:50:19Z"
"","2410","StringUtils.nullSafeToString returns null if toString() returns null","## Overview  The original intention of `StringUtils.nullSafeToString` was that it does not throw a `NullPointerException`, not that it never returns `null`.  However, as discussed in https://github.com/junit-team/junit5/pull/2408#issuecomment-692733493, the Javadoc states that `StringUtils.nullSafeToString` never returns `null`, which can occur if the invocation of `toString()` returns `null`. Thus, the implementation is not aligned with the documentation.  ## Deliverables  - [x] Change the behavior of `StringUtils.nullSafeToString` so that it returns `""null""` if the invocation of `toString()` returns `null`.","closed","component: Platform,","sbrannen","2020-09-18T10:20:41Z","2020-10-04T07:33:22Z"
"","2617","Support for methods from external classes in @MethodSource doesn't work when the method is specified in static inner class","## Overview  The external classes support for `@MethodSource` annotations (https://github.com/junit-team/junit5/issues/1088) doesn't seem to work when the method providing arguments is located in a `public static Nested/InnerClass`. This might be a bug or an extension to the existing system, depending on how you look at it :)   Best regards, Chester  ## Data   Happens with java 15 and junit version 5.7.1  Actual behavior: Exception `ClassNotFoundException` is thrown Expected behavior: Both examples work and completes the test successfully.  ```java public class JUnitNestedMethodSourceTest {      @ParameterizedTest     @MethodSource(""example.JUnitNestedMethodSourceTest#getArgs"") // works fine     void testMethodSource(String s) {         Assertions.assertTrue(s.isEmpty());     }      public static Stream getArgs() {         return Stream.of(             Arguments.arguments("""")         );     }      @ParameterizedTest     @MethodSource(""example.JUnitNestedMethodSourceTest.Source#getArgs"") // doesn't work     void testInnerMethodSource(String s) {         Assertions.assertTrue(s.isEmpty());     }      public static class Source {          public static Stream getArgs() {             return Stream.of(                 Arguments.arguments("""")             );         }     } }  // output org.junit.platform.commons.JUnitException: Could not load class [example.JUnitNestedMethodSourceTest.Source]   ...   Caused by: java.lang.ClassNotFoundException: example.JUnitNestedMethodSourceTest.Source ```","closed","","ChesterTheCheese","2021-05-14T16:39:21Z","2021-05-15T13:52:34Z"
"","2853","`@BeforeAll`/`@AfterAll` methods may be `static` in `@Nested` test classes on JDK 16+","## Overview  The current documentation (user guide and Javadoc) states that `@BeforeAll` and `@AfterAll` lifecycle methods must not be `static` when declared within a `@Nested` test class.  However, as of JDK 16 this is no longer true. See [JDK-8254321](https://bugs.openjdk.java.net/browse/JDK-8254321) for details.  For example, the following compiles and runs as expected on Java 16 or higher.  ```java class StaticLifecycleMethodTests {  	@BeforeAll 	static void beforeAllOuter() { 		System.out.println(""@BeforeAll: top-level""); 	}  	@AfterAll 	static void afterAllOuter() { 		System.out.println(""@AfterAll: top-level""); 	}  	@Nested 	class NestedTests {  		@BeforeAll 		static void beforeAllInner() { 			System.out.println(""@BeforeAll: nested""); 		}  		@Test 		void test() { 			System.out.println(""test(): nested""); 		}  		@AfterAll 		static void afterAllInner() { 			System.out.println(""@AfterAll: nested""); 		}  	}  } ```  ## Deliverables  - [x] Ensure that the documentation (user guide and Javadoc) mentions that `@BeforeAll` and `@AfterAll` lifecycle methods may be `static` when declared within a `@Nested` test class on JDK 16 or higher. - [x] Add above test or similar to test suite","closed","component: Jupiter,","sbrannen","2022-03-16T16:22:17Z","2022-03-25T12:59:19Z"
"","2705","Change to scope of API Guardian dependency breaks builds with custom Gradle `Configuration`","## Overview  The change in c5ee49d1347bdab01b7e72d6aa61a0e3c1a9065b breaks existing Gradle builds.  For example, the Spring Framework is using Gradle 6.8.3, and when the build is upgraded to JUnit 5.8 snapshots the build fails with numerous errors similar to the following.  ``` > Task :spring-test:compileJava FAILED /Users/sbrannen/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter-api/5.8.0-SNAPSHOT/617bb4ea90ad07de26681dd57932575b534ec15e/junit-jupiter-api-5.8.0-SNAPSHOT.jar(org/junit/jupiter/api/extension/ExtendWith.class): warning: Cannot find annotation method 'status()' in type 'API': class file for org.apiguardian.api.API not found warning: unknown enum constant Status.STABLE   reason: class file for org.apiguardian.api.API$Status not found ```  ## Workaround  Adding `compileOnly(""org.apiguardian:apiguardian-api"")` to `spring-test` allows the `spring-test` module to build.  ## Deliverables  - [x] Document as a potentially breaking change in the release notes.","closed","3rd-party: Gradle,","sbrannen","2021-09-03T15:56:56Z","2022-01-21T13:27:41Z"
"","2403","Include junit-platform-jfr module artifact in Appendix in User Guide","## Overview  The `junit-platform-jfr` artifact introduced in JUnit Platform 1.7.0 has not yet been added to the [Dependency Metadata](https://junit.org/junit5/docs/current/user-guide/#dependency-metadata) and [Dependency Diagram](https://junit.org/junit5/docs/current/user-guide/#dependency-diagram) sections of the User Guide.  ## Deliverables  - [x] Add `junit-platform-jfr` artifact to the `Dependency Metadata` section of the User Guide. - [x] Add `junit-platform-jfr` artifact to the `Dependency Diagram` section of the User Guide.","closed","component: Platform,","sbrannen","2020-09-13T21:33:10Z","2020-10-04T07:33:22Z"
"","2073","Hide JupiterTestEngine and VintageTestEngine from standard Java code","## Overview  The _trick_ described in https://github.com/netty/netty/pull/9687#pullrequestreview-304243904 provides a way to hide the `JupiterTestEngine` and `VintageTestEngine` from standard Java code.  Since we only made those two classes `public` to make them usable by the `ServiceLoader` mechanism, we should consider implementing this _trick_ to better encapsulate the internals of Jupiter and Vintage.  FYI: I tried it out locally for the `JupiterTestEngine`, and it works. Note, however, that we might have to use reflection in a few places in our test suite as a result of the change.  ## Deliverables  - [ ] Decided if we want to hide `JupiterTestEngine` and `VintageTestEngine` from standard Java code.","closed","component: Vintage,","sbrannen","2019-10-21T10:51:05Z","2019-10-31T11:44:27Z"
"","2645","`IndicativeSentences` display name generator does not work as documented","## Overview  The [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/#writing-tests-display-name-generator) states that execution of the `DisplayNameGeneratorDemo` test class results in the following output when using the `ConsoleLauncher`.  ``` +-- DisplayNameGeneratorDemo [OK]   +-- A year is not supported [OK]   | +-- A negative value for year is not supported by the leap year computation. [OK]   | | +-- For example, year -1 is not supported. [OK]   | | '-- For example, year -4 is not supported. [OK]   | '-- if it is zero() [OK]   '-- A year is a leap year [OK]     +-- A year is a leap year -> if it is divisible by 4 but not by 100. [OK]     '-- A year is a leap year -> if it is one of the following years. [OK]       +-- Year 2016 is a leap year. [OK]       +-- Year 2020 is a leap year. [OK]       '-- Year 2048 is a leap year. [OK] ```  However, the following is the actual output.  ```   +-- DisplayNameGeneratorDemo [OK]   | +-- A year is not supported [OK]   | | +-- A negative value for year is not supported by the leap year computation. [OK]   | | | +-- For example, year -4 is not supported. [OK]   | | | '-- For example, year -1 is not supported. [OK]   | | '-- if it is zero [OK]   | '-- DisplayNameGeneratorDemo$A year is a leap year [OK]   |   +-- DisplayNameGeneratorDemo$A year is a leap year -> if it is divisible by 4 but no... [OK]   |   '-- DisplayNameGeneratorDemo$A year is a leap year -> if it is one of the following ... [OK]   |     +-- Year 2016 is a leap year. [OK]   |     +-- Year 2048 is a leap year. [OK]   |     '-- Year 2020 is a leap year. [OK] ```  Note that `@Nested` test classes using the `IndicativeSentences` display name generator incorrectly have `DisplayNameGeneratorDemo$` prepended to their display names.  ## Deliverables  - [x] Ensure that the display name for a test class that makes up the beginning of the ""indicative sentence"" does not include the display name of the enclosing class.","closed","component: Jupiter,","sbrannen","2021-06-16T15:52:06Z","2021-06-17T16:01:11Z"
"","2036","Support for enabling or disabling a test on a range of JREs","## Overview  Support for enabling or disabling a test on a range of JREs. Therfore we implemented two new annotations `@EnabledForJreRange` and `@DisabledForJreRange` which contain two parameters `min` (Defaults to `JRE.Java_8`)  and `max` (defaults to `JRE.OTHER`). By defaulting those to the highest and lowest version, we allow the usage of half open ranges.  I might need to rework javadoc and documentation, i am not really good when it comes to wording those.  Resolves #2016.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","aepfli","2019-10-01T07:11:04Z","2019-10-11T07:22:41Z"
"","2264","Fix selecting Spock methods via MethodSelector","## Overview  Spock uses a Groovy AST transform to generate methods during compilation. Thus, `MethodSelector.getJavaMethod()` always threw an exception when selecting a test method by its name in the source code. Thus, the Vintage engine now uses `MethodSelector.getMethodName()` instead of `MethodSelector.getJavaMethod().getName()` which is then correctly used by Spock's Runner for filtering as demonstrated by the added integration test. Moreover, when both Vintage and Jupiter are present, such a `MethodSelector` caused the Jupiter engine to fail during discovery because it could not resolve `MethodSelector.getJavaMethod()` either. Its `MethodSelectorResolver` now checks if a test class is a Jupiter test class before making that call.  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","marcphilipp","2020-04-18T12:57:54Z","2020-04-19T11:51:46Z"
"","2597","Support AutoCloseable for arguments provided to a @ParameterizedTest","## Overview  Sometimes the arguments provided to a `@ParameterizedTest` are resources that need to be cleaned up after each invocation of the parameterized test -- for example, when testing against various implementations of an API. However, it is currently not possible to clean up such resources without duplicated logic in each `@ParameterizedTest` method that makes use of the arguments source.  One _could_ store the argument injected into the `@ParameterizedTest` method in a field and then access that field within an `@AfterEach` method, but that is more work than simply invoking the cleanup method directly from within each `@ParameterizedTest` method. The following simplified example demonstrates the latter approach.  ```java class ServerTests {  	@ServerTest 	void json(Server server) { 		server.handleRequest(""JSON""); 		server.shutdown(); 	}  	@ServerTest 	void xml(Server server) { 		server.handleRequest(""XML""); 		server.shutdown(); 	}   	private interface Server {  		default void handleRequest(String data) { 			System.out.println(""Request: "" + data + "" for "" + getClass().getSimpleName()); 		}  		default void shutdown() { 			System.out.println(""Shutting down "" + getClass().getSimpleName()); 		} 	}  	private static class MockServer implements Server { 	}  	private static class RealServer implements Server { 	}   	@Retention(RetentionPolicy.RUNTIME) 	@ParameterizedTest 	@MethodSource(""servers"") 	@interface ServerTest { 	}  	static Stream servers() { 		return Stream.of(new MockServer(), new RealServer()); 	}  } ```  The following are the results of executing the above test class.  ``` Request: XML for MockServer Shutting down MockServer Request: XML for RealServer Shutting down RealServer Request: JSON for MockServer Shutting down MockServer Request: JSON for RealServer Shutting down RealServer ```  If we want to automate the shutdown of each server, we can implement a custom `ArgumentsProvider` that stores the arguments in the `ExtensionContext.Store` and modify the `Server` interface so that it extends `CloseableResource`. The following example demonstrates this approach.  ```java class ServerTests {  	@ServerTest 	void json(Server server) { 		server.handleRequest(""JSON""); 	}  	@ServerTest 	void xml(Server server) { 		server.handleRequest(""XML""); 	}   	private interface Server extends CloseableResource {  		default void handleRequest(String data) { 			System.out.println(""Request: "" + data + "" for "" + getClass().getSimpleName()); 		}  		default void shutdown() { 			System.out.println(""Shutting down "" + getClass().getSimpleName()); 		}  		@Override 		default void close() { 			shutdown(); 		} 	}  	private static class MockServer implements Server { 	}  	private static class RealServer implements Server { 	}  	@Target(ElementType.METHOD) 	@Retention(RetentionPolicy.RUNTIME) 	@ParameterizedTest 	@ArgumentsSource(ServerArgumentsProvider.class) 	@interface ServerTest { 	}  	static class ServerArgumentsProvider implements ArgumentsProvider {  		private static final Namespace namespace = Namespace.create(ServerArgumentsProvider.class);  		@Override 		public Stream provideArguments(ExtensionContext context) { 			MockServer mockServer = new MockServer(); 			RealServer realServer = new RealServer(); 			context.getStore(namespace).put(""mockServer"", mockServer); 			context.getStore(namespace).put(""realServer"", realServer); 			return Stream.of(arguments(mockServer), arguments(realServer)); 		} 	} } ```  The following are the results of executing the above test class.  ``` Request: XML for MockServer Request: XML for RealServer Shutting down RealServer Shutting down MockServer Request: JSON for MockServer Request: JSON for RealServer Shutting down RealServer Shutting down MockServer ```  Here we see that the `Server` instances are in fact automatically shut down; however, there are two undesired side effects of this approach:  1. Each `Server` instance is held onto until after _all_ invocations of a given `@ParameterizedTest` have completed. 2. The `Server` instances are closed/shut down in reverse order.  The latter is due to a feature of the `ExtensionContext.Store` that supports ""wrapping"" of closable resources, so that behavior is to be expected in this scenario, but it may not be acceptable depending on the actual use case.  Aside from the above runtime side effects, the implementation requires a lot of boilerplate code to get working.  ## Proposal  To simplify such use cases, we should invoke the `close()` method on any `CloseableResource` (or `java.lang.AutoCloseable`) that is provided as an argument to a `@ParameterizedTest`, and that should occur after each invocation of the `@ParameterizedTest` method. Doing so would allow the original `ServerTest` example to be implemented using `@MethodSource` and having the `Server` extend `CloseableResource` without the need for a custom `ArgumentsProvider` and avoiding direct interaction with the `ExtensionContext.Store`.  ## Deliverables  - [x] Support `java.lang.AutoCloseable` for `@ParameterizedTest` arguments, enabled by default but configurable via a new `autoCloseArguments` attribute in the `@ParameterizedTest` annotation.","closed","theme: parameterized tests,","sbrannen","2021-04-16T09:30:57Z","2021-07-16T08:24:43Z"
"","1999","Drop java.compiler dependence in org.junit.platform.commons","## Overview  Solves #1995 by implementing a custom version of `SourceVersion.isName()`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","juliette-derancourt","2019-09-02T19:06:01Z","2019-09-09T21:03:29Z"
"","1972","Add support for String delimiters in @CsvSource and @CsvFileSource","## Overview  Solves #1958 by adding a `delimiterString` attribute to the `@CsvSource` annotation.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","juliette-derancourt","2019-08-03T12:11:08Z","2019-08-24T18:22:34Z"
"","1971","Document comment support in @CsvFileSource","## Overview  Solves #1782 by adding documentation about the support of comments in @CsvFileSource. Also added a unit test covering this use case.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","juliette-derancourt","2019-08-02T21:45:01Z","2019-08-03T08:56:12Z"
"","2712","Deprecate the `JUnitPlatform` runner in favor of `@Suite` support","## Overview  Since JUnit 5.8 introduces official support for running suites on the JUnit Platform itself, we should deprecate the old `JUnitPlatform` runner for running the JUnit Platform via JUnit 4.  ## Deliverables  - [x] Deprecate the `JUnitPlatform` runner in favor of `@Suite` support in Javadoc and via `@API` - [x] Update build and tests to use `@Suite` - [x] Document the deprecation in the user guide - [x] Document the deprecation in the release notes","closed","theme: suites,","sbrannen","2021-09-08T14:12:46Z","2021-09-09T13:30:39Z"
"","2039","Detect cycles in inner class hierarchies","## Overview  Since Java allows nested classes to extend other classes, it is possible to introduce a cycle when using `@Nested` test classes.  For example, the following compiles in Java. So it's syntactically correct, even though it's semantically invalid. If you attempt to execute `OuterTests` or `NestedTests`, the discovery phase in JUnit Jupiter never completes (or at least it does not result in a stack overflow in a reasonable amount of time on my machine).  On the other hand, if you execute only `test1()` or `test2()`, each of those will execute as expected.  ```java package example;  import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test;  class OuterTests {  	@Test 	void test1() { 	}  	@Nested 	class NestedTests extends OuterTests { 		@Test 		void test2() { 		} 	} } ```  ## Deliverables  - [x] Detect cycles in inner class hierarchies and abort the discovery of those nested test classes by throwing an exception.","closed","component: Platform,","sbrannen","2019-10-04T13:44:30Z","2020-04-07T12:42:20Z"
"","2274","Add platform configuration parameter for test MethodOrderer","## Overview  Similar to the `junit.jupiter.testinstance.lifecycle.default` configuration setting, users of the JUnit platform might want to configure the default test method order globally for all tests instad of adding the `@TestMethodOrder` annotation on every test class.  This change set adds the `junit.jupiter.testmethod.order.default` configuration setting, which sets the default test method order for the whole JUnit platform.  If `junit.jupiter.testmethod.order.default` has not been set or contains an invalid value, the default test method order is being used, otherwise the specified `MethodOrderer`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","joschi","2020-04-25T15:29:50Z","2020-07-27T09:02:07Z"
"","2814","Shadow JUnit Platform Suite Engine into Console's Standalone JAR file","## Overview  Shadow JUnit Platform Suite Engine into Console's Standalone JAR file as motivated by https://github.com/junit-team/junit5/issues/2813#issuecomment-1017546843  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2022-01-20T15:49:30Z","2022-04-08T10:10:51Z"
"","2595","Improvements to build tool docs section","## Overview  see individual commits","closed","theme: documentation,","marcphilipp","2021-04-12T19:18:05Z","2021-08-17T09:48:30Z"
"","2170","Upgrade to AssertJ 3.15.0","## Overview  see https://assertj.github.io/doc/#assertj-core-3-15-0-release-notes for details.  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","epeee","2020-01-31T21:27:47Z","2020-05-08T11:11:14Z"
"","2474","Improve user guide for nested tests","## Overview  See #2451.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mmerdes","2020-11-13T16:23:50Z","2020-11-15T14:37:36Z"
"","2121","Revise module declarations","## Overview  Revise module declarations  Closes #2063  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2019-12-05T10:54:20Z","2019-12-20T18:09:53Z"
"","2478","Feature/color customization (console launcher)","## Overview  Resolving feature #985 .  This PR adds two new command line options, `--color-palette` and `--single-color`. The former accepts a properties file to override any and all ANSI color styling, and the latter provides a built-in single-color style.  Default behaviors/colors are unchanged.  Implementation note: previously, the `Color` enum contained both raw ANSI color codes and also public constants which mapped relevant styles (successful, failed, etc.) to colors. Those two concerns have been split. The `Color` enum has been refactored to `Style`, and Styles are mapped to colors / ANSI text attributes in the `ColorPalette` class. Most `disableAnsiColor` logic is now inside the `ColorPalette` concept as well.  Open question -- haven't done a PR here before -- do these changes warrant Javadoc / User Guide updates as described in the Definition of Done?   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","nmck257","2020-11-21T22:39:19Z","2022-04-08T11:11:18Z"
"","2974","#2969 : Allow DisplayNameGenerators to return null to falling back to the default one","## Overview  Resolves https://github.com/junit-team/junit5/issues/2969  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","theme: discovery,","d-william","2022-07-09T16:49:40Z","2022-07-11T14:29:21Z"
"","2868","Add open-test-reporting writing TestExecutionListener","## Overview  Resolves #373.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2022-03-25T12:34:43Z","2022-05-15T17:06:06Z"
"","2543","Introduce assertThrowsExactly() in Jupiter assertions","## Overview  Resolves #2509   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","terziele","2021-01-31T18:29:13Z","2021-06-11T14:51:46Z"
"","2707","Provide access to the current ExecutionMode in ExtensionContext","## Overview  Resolves #2396.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","juliette-derancourt","2021-09-04T18:05:08Z","2021-09-15T11:01:49Z"
"","2786","Allow extensions to leverage registered ParameterResolvers for method and constructor invocations","## Overview  Resolves #2393.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","juliette-derancourt","2021-12-05T18:19:10Z","2022-02-04T10:14:36Z"
"","2521","Named arguments in parameterized tests","## Overview  Resolves #2301.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","juliette-derancourt","2021-01-09T17:13:43Z","2021-11-01T09:00:49Z"
"","2271","Add Flight Recorder based execution listener","## Overview  Resolves #2272  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sormuras","2020-04-24T02:16:53Z","2020-07-12T11:01:04Z"
"","2061","Run build with JDK 13","## Overview  Resolves #1906.  Resolves #2018 by superseding it.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2019-10-13T19:48:27Z","2020-04-19T11:46:46Z"
"","2018","Upgrade to JDK 13","## Overview  Resolves #1906  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2019-09-20T07:13:45Z","2019-12-05T09:59:01Z"
"","2832","Fix Code Style !isPresent() -> isEmpty()","## Overview  Replaced  negated `isPresent()` with `isEmpty()` ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: invalid,","mklose","2022-02-18T16:39:28Z","2022-02-19T13:32:29Z"
"","2953","Fix potential exponential backtracking in ReflectionUtils array parsing","## Overview  Remove superfluous repetition of outer group, turning the inner into a _non-capturing atomic group_ and applying a _possessive quantifier_, thus disallowing backtracking into the grouped pattern.  Fixes #2950.  Background of atomic grouping and possessive quantifiers:  - https://www.regular-expressions.info/atomic.html - https://www.regular-expressions.info/possessive.html  Cheers to @stitzl for the former; I only used a non-capturing group in the original suggestion.  Background of the potential issue  - https://www.regular-expressions.info/catastrophic.html  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes)","closed","component: Platform,","michael-simons","2022-06-22T12:12:06Z","2022-06-22T13:58:39Z"
"","2785","Feature/invocaton index","## Overview  Relates to #1668.  This PR adds a `getInvocationIndex()` to `ArgumentsAccessor`, allowing test authors access to the index of the parameterized test.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","ghost","2021-12-05T00:37:24Z","2022-03-03T05:40:41Z"
"","2034","Console Launcher as Tool Provider","## Overview  Provide `java.util.spi.ToolProvider` service named `junit` with `org.junit.platform.console.ConsoleLauncherToolProvider`.  Resolves #797  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2019-09-27T09:17:26Z","2019-09-29T19:18:56Z"
"","2368","Emit entire non-matching lines","## Overview  Prior to this PR, a small number (`42`) of lines were always included in the error message string of `assertLinesMatch`. This arbitrary number of lines did not always contain the lines that did not match. This PR removes the constant number and always emits the two non-matching lines entirely.  The staged matching logic is still working in a ""fail-fast mode"". The first non-mathing line pair is reported. Subsequent lines are not processed.  Closes #2233  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2020-08-01T16:10:22Z","2020-08-02T08:34:45Z"
"","2882","Use user's console charset, if available","## Overview  Prior to this commit the charset returned by `Charset.defaultCharset()` was always used to determine the default theme used by the JUnit Console Launcher application.  Now, on Java 17 and later, Java's Console API is queried in order to retrieve the user-specified of the charset used by the system console -- before falling back to the default charset.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2022-04-09T16:46:47Z","2022-05-15T17:44:56Z"
"","2531","Fix package path computation in ClasspathScanner","## Overview  Prior to this commit no trailing `/` character was appended to the computed package path.  Now, except for the default package `""""`, a `/` is appended to package path. This leads to corrected and documented behavior even if two modules start with the same name elements.  Fixes #2500 ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","sormuras","2021-01-16T17:41:44Z","2021-05-07T12:49:52Z"
"","2690","Reduce info logging noise","## Overview  Prior to this commit code in JUnit logged messages via its internal Logging Facade at information level. When a user, a framework, or a tool running JUnit-based tests doesn't explicitly configure logging, the default Java Util Logging frameworks is used, which in turn emits message via `System.err`. Since those messages then appear on some environments red color, they are confusing and somewhat distracting.  This commit replaces all calls of `Logger.info()` to their `config()` variants.  Closes #2664  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","sormuras","2021-08-16T09:17:00Z","2021-08-17T08:15:51Z"
"","2947","Fix support for absolute path entries on Windows","## Overview  Prior this commit absolute paths on Windows starting with a drive letter like `C:\foo.jar` were always split into two path entries:   - `C`   - `foo.jar`  This commit replaces the too simplistic `split = "";|:""` option conversion with a custom converter for classpath entries taking the current platform's path separator character into account.  Fixes #2905 ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-06-17T14:22:18Z","2022-06-20T18:15:21Z"
"","2695","Declare a compile-only dependence on module `org.apiguardian.api`","## Overview  Prevent  ``` java.lang.module.FindException: Module org.apiguardian.api not found, required by org.junit.platform.commons ```  errors at runtime.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: modules,","sormuras","2021-08-19T06:24:39Z","2021-08-19T06:50:59Z"
"","2865","Prefer pre-installed tools","## Overview  Prefer pre-installed tools.  Addresses #2859   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-03-22T09:50:25Z","2022-03-22T17:20:54Z"
"","2734","Treat text blocks as files in `@CsvSource`","## Overview  PR #2721 introduced experimental support for _text blocks_ in `@CsvSource`; however, there is room for improvement.  A CSV line within a text block cannot currently contain a new line (`\n`), even if it is within a quoted string; whereas, this is supported when using `@CsvSource(value = ...)`.  Comments do not make sense in a single string in `@CsvSource(value = ...)`, but they do make sense within `@CsvSource(textBlock = ...)`.  ## Related Issues  - #2528 - #2721  - #2735  ## Deliverables  - [x] Support `\n` within quoted strings in text blocks. - [x] Support comment lines beginning with `#` in text blocks. - [x] Implement robust solution for sanitizing a text block, since `String#stripIndent()` is only available on JDK 15+. - [x] Document in the User Guide. - [x] Document in the Release Notes.","closed","theme: parameterized tests,","sbrannen","2021-10-01T11:33:31Z","2021-10-26T11:13:13Z"
"","2701","Allow `@Nested` test classes to be ordered","## Overview  PR #2488 introduced support for ordering top-level test classes but did not provide support for ordering `@Nested` test classes.  This PR adds support for ordering `@Nested` test classes as well.  Closes: #2699  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sbrannen","2021-08-28T15:17:19Z","2021-08-30T15:17:11Z"
"","2069","JFall 2019 added","## Overview  Please describe your changes here and list any open questions you might have.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","svenruppert","2019-10-17T19:23:33Z","2019-10-17T19:24:06Z"
"","2946","Document configuration parameters for parallel test execution in Jupiter","## Overview  Partially addresses #2669.   Introduces a new table with relevant parallel execution properties in `junit-platform.properties`.  ## How the addition looks like  ![Screenshot from 2022-06-16 19-56-18](https://user-images.githubusercontent.com/23459549/174135390-21b5453a-1294-42e1-b2e1-cc18f7e9a617.png)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","stoyanK7","2022-06-16T18:02:41Z","2022-06-17T12:25:24Z"
"","2668","Added before and after all classes callback","## Overview  Now we can add extensions for executing before all test classes and after all test classes  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","SergKhram","2021-07-20T12:36:48Z","2021-10-09T13:24:45Z"
"","2821","Support FreeBSD and OpenBSD in `@EnabledOnOs` and `@DisabledOnOs`","## Overview  My cross-platform project supports FreeBSD and OpenBSD and I'd like to be able to use the annotations rather than conditionals.  I followed the same format used for AIX.  I see some additional tests in [org/junit/jupiter/api/condition/EnabledOnOsConditionTests.java](https://github.com/junit-team/junit5/blob/e69243ae0f3c68f07d075ac3901c98c375d040f0/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/condition/EnabledOnOsConditionTests.java) and [junit-jupiter-engine/src/test/java/org/junit/jupiter/api/condition/DisabledOnOsConditionTests.java](https://github.com/junit-team/junit5/blob/e69243ae0f3c68f07d075ac3901c98c375d040f0/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/condition/DisabledOnOsConditionTests.java) that were not updated with the AIX addition so I did not (yet) add these OS's.  Let me know if you'd like me to update these with all three new additions.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","dbwiddis","2022-02-05T07:34:48Z","2022-02-06T16:15:22Z"
"","2709","Change seed log message to go to info level","## Overview  Modify the logging of the seed to match what is in the documentation, and the team-decision in [issue 1937](https://github.com/junit-team/junit5/issues/1937)  This seems to be a micro correction back to what the JUnit team had already decided about this functionality. So, I am not sure if this should be mentioned in the release docs, but what is your view?  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","steven-solomon","2021-09-06T01:48:04Z","2021-09-06T15:04:54Z"
"","2765","Bump Maven Plugin versions","## Overview  Might fix #2764  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","sormuras","2021-10-31T18:17:44Z","2021-11-01T08:25:48Z"
"","2082","Make TestExecutionSummary.Failure serializable","## Overview  Make the `TestExecutionSummary.Failure` interface serializable.  The `Throwable` and `TestIdentifier` classes that are used by this interface are serializable, so it is safe to make it serializable also.  The default implementation `org.junit.platform.launcher.listeners.MutableTestExecutionSummary.DefaultFailure` is also safe to make serializable as it's a simple Java Bean with these two serializable fields.  I need to be able to serialize to disk the failures of a test for [QuickPerf](https://github.com/quick-perf), a tool that I works on a JUnit5 implementation that allows to make rapid performance test with JUnit4 and soon 5.   As QuickPerf needs to launch a test in a separate JVM we need a way to pass the failures from one JVM to the other, and serializing them to disk is the easiest way to do it.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - ❌ Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","loicmathieu","2019-10-24T13:42:39Z","2019-12-05T17:20:29Z"
"","2834","Log a warning when no engines are available","## Overview  Logs a warning when no engines are available, either due to not being present on the class path or excluded through a filter.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: superseded,","mpkorstanje","2022-02-19T17:54:31Z","2022-03-09T08:59:59Z"
"","2797","List available test engines","## Overview  List available test engines ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","JOpsDev","2021-12-15T19:10:56Z","2022-03-21T13:38:52Z"
"","2679","Improve logging for extension registration in JUnit Jupiter","## Overview  JUnit Jupiter currently logs the registration of default and auto-detected extensions in aggregated log statements (one for each category). In addition, inclusion of the `source` in the log statement for extensions registered locally by the user often results in unnecessary, duplicated noise.  For example, the logging for a given test class currently looks something like the following.  ``` Registering default extensions: [org.junit.jupiter.engine.extension.DisabledCondition, org.junit.jupiter.engine.extension.TempDirectory, org.junit.jupiter.engine.extension.TimeoutExtension, org.junit.jupiter.engine.extension.RepeatedTestExtension, org.junit.jupiter.engine.extension.TestInfoParameterResolver, org.junit.jupiter.engine.extension.TestReporterParameterResolver] Registering extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$DemoExtension@1a6c1270] from source [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$DemoExtension@1a6c1270]. Registering extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$BeforeEachExtension@6d3c5255] from source [org.junit.jupiter.api.extension.Extension org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$ExplicitOrderInstanceLevelExtensionRegistrationTestCase.extension3]. Registering extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$BeforeEachExtension@b1712f3] from source [org.junit.jupiter.api.extension.Extension org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$ExplicitOrderInstanceLevelExtensionRegistrationTestCase.extension2]. Registering extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$BeforeEachExtension@6986bbaf] from source [org.junit.jupiter.api.extension.Extension org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$ExplicitOrderInstanceLevelExtensionRegistrationTestCase.extension1]. ``` Although the aggregated log statement for default extensions is concise, it's not very user friendly with regard to providing an overview of all registered extensions. The duplicated information for the source of the `DemoExtension` is superfluous and distracting. The source for extensions registered via fields (using `@RegisterExtension`) could benefit from including the word ""field"" and omitting the field type.  ## Proposal  With the proposed changes the log output for the above test class could look like the following.  ``` Registering default extension [org.junit.jupiter.engine.extension.DisabledCondition@6ed3f258]. Registering default extension [org.junit.jupiter.engine.extension.TempDirectory@7803bfd]. Registering default extension [org.junit.jupiter.engine.extension.TimeoutExtension@42bc14c1]. Registering default extension [org.junit.jupiter.engine.extension.RepeatedTestExtension@531f4093]. Registering default extension [org.junit.jupiter.engine.extension.TestInfoParameterResolver@62ef27a8]. Registering default extension [org.junit.jupiter.engine.extension.TestReporterParameterResolver@6436a7db]. Registering local extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$DemoExtension@6ee6f53]. Registering local extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$BeforeEachExtension@4758820d] from source [field org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$ExplicitOrderInstanceLevelExtensionRegistrationTestCase.extension3]. Registering local extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$BeforeEachExtension@74eb909f] from source [field org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$ExplicitOrderInstanceLevelExtensionRegistrationTestCase.extension2]. Registering local extension [org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$BeforeEachExtension@28ec166e] from source [field org.junit.jupiter.engine.extension.OrderedProgrammaticExtensionRegistrationTests$ExplicitOrderInstanceLevelExtensionRegistrationTestCase.extension1]. ```  ## Deliverables  - [x] Improve the logging for extension registration in JUnit Jupiter by logging the category of each extension and omitting the source if it is superfluous.","closed","theme: diagnostics,","sbrannen","2021-08-01T16:43:23Z","2021-08-01T17:45:02Z"
"","2312","preDestroyTestInstance not able to get test instance from context if postProcessTestInstance failed","## Overview  JUnit is treating an exception inside the `postProcessTestInstance` method like an `Exception` in the constructor, but the instance has been created and should (in my mind) be accessible for proper termination.  Even if the behavior is desired and the context should not contain the not proper initialized instance, the call to `preDestroyTestInstance` is somewhat useless without the corresponding instance.   Perhaps the `preDestroyTestInstance` signature could be extended with the `testInstance` (like the `postProcessTestInstance`)?  Thanks in advance   ## Steps to reproduce  ```java         @Override         public void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {             throw new IllegalStateException();         }          @Override         public void preDestroyTestInstance(ExtensionContext context) throws Exception {             context.getRequiredTestInstance().disconnect();         } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.6.1","closed","component: Jupiter,","joerg1985","2020-06-04T07:07:00Z","2020-07-10T13:33:29Z"
"","2049","Doubly nested test class is not usable with EventConditions#nestedContainer in Test Kit","## Overview  Issue internal to JUnit 5 Engine Test Kit.  Condition created with `org.junit.platform.testkit.engine.EventConditions#nestedContainer` does not match events created for doubly nested classes, making it impossible to use `org.junit.platform.testkit.engine.Events#assertEventsMatchExactly` in testing multiple levels of `@Nested` classes.  ## Steps to reproduce  Please see the pull request with reproducer.","closed","component: Test Kit,","pietrygamat","2019-10-07T22:14:48Z","2019-10-25T10:46:23Z"
"","2548","Support named sources for DynamicTest.stream(…)","## Overview  Introduction of `DynamicTest.stream(Iterator>, ThrowingConsumer)` and `DynamicTest.stream(Stream>, ThrowingConsumer)`. Both methods use each name-value pair provided by the first parameter as the display name and value for each generated dynamic test.  Resolves #2375.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: dynamic tests,","juliette-derancourt","2021-02-08T12:45:42Z","2021-02-11T11:29:40Z"
"","2065","Introduce TestInstancePreDestroyCallback as counterpart to TestInstancePostProcessor","## Overview  Introduced new `TestInstancePreDestroyCallback` with associated tests.  Questions: 1. In `TestInstancePreDestroyCallbackTests` I added `assertSame(testInstance, context.getTestInstance().get())` after noticing this was the case, so technically  we can simplify API and remove `testInstance`, or better to keep as is so more explicit? 2. `TestInstancePreDestroyCallback` is new, not clear whether to mark as STABLE or EXPERIMENTAL?  Resolves #1864.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","stehrn","2019-10-15T20:43:16Z","2019-11-19T11:56:41Z"
"","2108","Include parameter names in default name of @ParameterizedTest","## Overview  Introduced a new `{arguments_with_names}` pattern in `@ParameterizedTest`, which is now used in the default name pattern. The parameter names are included only if they are present in the bytecode and if the parameter types are known (`ArgumentsAccessor` and `ArgumentsAggregator` are therefore ignored).  Closes #2040.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","juliette-derancourt","2019-11-20T19:45:06Z","2019-12-05T14:38:30Z"
"","2593","Use Gradle's new version catalog feature","## Overview  Instead of defining an internal platform project, we now use Gradle's new [dependency catalog feature](https://docs.gradle.org/7.0/userguide/platforms.html#sub:central-declaration-of-dependencies) that allows for central declaration of dependencies.","closed","","marcphilipp","2021-04-11T16:22:50Z","2021-04-12T06:05:52Z"
"","2619","Introduce a Unique ID tracking TestExecutionListener","## Overview  Inspired by the simple [`TestClassTrackingTestExecutionListener`](https://github.com/sbrannen/spring-framework/blob/77a115f7172b5b8874391ccfb4ffd800c0b4ba1e/spring-core/src/testFixtures/java/org/springframework/core/testfixture/junit/platform/TestClassTrackingTestExecutionListener.java) that I introduced as a proof of concept in the test suite for the Spring Framework, we should introduce a `UniqueIdTrackingListener` as an implementation of the `TestExecutionListener` API for the JUnit Platform.  `UniqueIdTrackingListener` would track the unique IDs of all ""tests"" (not containers) that were executed during the execution of test plan. It would track all tests, regardless of the success/failure status of the test, and write the unique IDs to a text file.  The text file can then be used by a build tool or plugin to execute the same set of tests again without having to query the user configuration for the test plan and without having to perform classpath scanning again to discover tests.  This can be useful for test environments such as within a native image -- for example, a GraalVM native image -- in order to rerun the exact same tests from a standard JVM test run within a native image.  ## Deliverables  - [x] Introduce `UniqueIdTrackingListener` in the `junit-platform-launcher` module. - [x] Register the `UniqueIdTrackingListener` by default via Java's `ServiceLoader` mechanism. - [x] Make the `UniqueIdTrackingListener` an opt-in feature. If a specific JVM system property has not been set to `true`, the registered `UniqueIdTrackingListener` would serve as a no-op listener and not do anything. - [x] Make the output directory and output file configurable. - [x] Make the output directory convention-based by default, choosing an appropriate build directory for Maven or Gradle, depending on the presence of `pom.xml` or `*.gradle`/`*.gradle.kts` respectively. - [x] Document `UniqueIdTrackingListener` in Javadoc. - ❌ Document `UniqueIdTrackingListener` in the User Guide.   - Since the User Guide currently has no section dedicated to `TestExecutionListener` implementations, this will be addressed in a separate issue. - [x] Document `UniqueIdTrackingListener` in the Release Notes.","closed","type: new feature,","sbrannen","2021-05-17T12:19:46Z","2021-07-02T10:02:28Z"
"","2383","Add tests for whitespace within CsvSource columns","## Overview  Initially, I had intention to make `@CsvSource` support blank quoted strings. But after I made a test, it appeared that `@CsvSource` handles them already. So I just contribute you one unit test.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","hosuaby","2020-08-16T11:59:03Z","2020-08-16T13:23:53Z"
"","2965","Add assertEquals with BinaryPredicate","## Overview  Initial PR for #2964   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jbee","2022-07-05T17:05:29Z","2022-07-08T15:03:00Z"
"","2735","Make quote character in `@CsvSource` and `@CsvFileSource` configurable","## Overview  In order to treat text blocks as files in `@CsvSource` (see #2734), we should allow users to change the quote character to `""` when using text blocks.  This will of course allow one to change the quote character to anything other than `'` or `""`, even when using the `value` attribute in `@CsvSource`, but it is assumed the primary use case is using double quotes in text blocks.  For consistency in supported features, we should do the same for `@CsvFileSource`.  ## Related Issues  - #2721  - #2734  ## Deliverables  - [x] Introduce new `char quoteCharacter() default '\'';` attribute in `@CsvSource`. - [x] Introduce new `char quoteCharacter() default '""';` attribute in `@CsvFileSource`. - [x] Document in the Release Notes.","closed","theme: parameterized tests,","sbrannen","2021-10-01T15:22:35Z","2021-11-05T10:43:08Z"
"","2028","Ask build tools and IDEs to upgrade to junit-platform-launcher 1.6.x","## Overview  In #1909 we've improved error reporting for engine discovery/execution failures. The relevant changes are in `DefaultLauncher` which is contained in the `junit-platform-launcher` artifact. Since most build tools and IDEs bundle that artifact we need to reach out to them and ask them to update to Jupiter/Vintage 5.6 (Platform 1.6).  ## Projects  List of projects and contacts to ping.  - [x] Ant, `JUnitLauncher` task doesn't bundle JUnit artifacts - [x] Eclipse, @noopur2507 - [x] [Gradle](https://github.com/gradle/gradle/pull/12489), @marcphilipp  - [x] IntelliJ IDEA, @akozlova - [x] ~Maven Surefire/Failsafe, @sormuras~ works with Surefire 3.x - [x] Netbeans - [x] VS Code, _work-in-progress_ ... [vscode-java-test #975](https://github.com/microsoft/vscode-java-test/issues/975)   ## Deliverables  - [x] All of the above build tools and IDEs have been upgraded","closed","3rd-party: Gradle,","marcphilipp","2019-09-25T16:22:44Z","2020-06-05T10:18:05Z"
"","2031","Improve performance of Vintage engine","## Overview  Improves performance Parameterized vintage engine with the following changes:  - add map to TestRun to track in progress TestDescriptors - memoize UniqueId#hashCode - memoize UniqueId#toString - avoid intermediate char[] allocation when formatting UniqueId  Issue: #2030  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","marschall","2019-09-26T10:50:56Z","2019-10-05T16:03:16Z"
"","2416","Introduce junit-platform-suite-engine","## Overview  Implements a test engine that allows declarative execution of test suites using the `@Suite` annotation.  Internally the Suite Engine uses the JUnit Platform Launcher. The engine works adding the test descriptors of the discovered engines and tests as children to its own test descriptor.  ```java package org.junit.platform.suite;  import org.junit.platform.suite.api.SelectPackages;  @Suite @SelectPackages(""org.junit.suite.testcases"") class SelectPackageSuite {  } ```  Is equivalent to:  ```java import org.junit.platform.engine.discovery.DiscoverySelectors; import org.junit.platform.launcher.Launcher; import org.junit.platform.launcher.LauncherDiscoveryRequest; import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder; import org.junit.platform.launcher.core.LauncherFactory;  public class Main {      public static void main(String[] args) {         Launcher launcher = LauncherFactory.create();         LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()                 .selectors(DiscoverySelectors.selectPackage(""org.junit.suite.testcases""))                 .build();         launcher.execute(request);     } } ```  Issue: #744  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","mpkorstanje","2020-09-21T16:01:22Z","2021-02-10T19:24:04Z"
"","2662","Issue: #2582 Do not swallow Exceptions in tests if something is throw…","## Overview  Implemented fix as suggest in #2582 by @marcphilipp  -> wrapping the `super.cleanUp()` invocation in `TestMethodTestDescriptor.cleanUp()`  if a dedicated test is needed, please give some advice where to put it.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","BerndFarkaDyna","2021-07-08T05:32:57Z","2021-08-15T08:40:03Z"
"","2514","Introduce Launcher sessions and accompanying listener to support global setup/teardown use cases","## Overview  Implementations of `TestExecutionListener` and (starting with 5.8) `LauncherDiscoveryListener` can be registered via ServiceLoader on each `Launcher` created via `LauncherFactory`. Implementing one of those listeners, in particular the former, allows to have custom setup or teardown code executed once for the entire test run across multiple test engines. Use cases include starting and stopping an external process, replacing the class loader, initializing some library etc. However, subsequent calls to `Launcher.execute` currently cause that setup / teardown code to be executed again which is not desirable, especially if it’s slow. However, for example the Maven Surefire plugin attempts to rerun failed tests if `rerunFailingTestsCount` is set or (when [SUREFIRE-1725](https://issues.apache.org/jira/browse/SUREFIRE-1725) is released) will even execute every test class in a separate request.  We could make the `Launcher` interface extend `AutoCloseable`. Calling `close()` would signal that it’s no longer used and any teardown code should be run. Since we can’t change `Launcher` in that way without breaking existing usages (which wouldn’t call `close()`), this PR introduces a new concept: a closeable `LauncherSession`. Tools that potentially call `Launcher.discover` or `Launcher.execute` multiple times should first create a session and close it when they’re done. Instances of `LauncherSessionListener` — which are registered via ServiceLoader (by default, can be disabled) or explicitly via a `LauncherConfig` — are called when the session is opened and closed. Each listener can then get access to the `Launcher` to register discovery/execution listeners via `LauncherSession.getLauncher`, e.g. to postpone setup until the first execution.  To ensure `LauncherSessionListener` gets called even by tools that do not (yet) use sessions, the `Launcher` created via `LauncherFactory.create` opens and closes a session for each call to `Launcher.discover` or `Launcher.execute`.  ### Open questions  - [ ] Should we deprecate `LauncherFactory.create` and introduce `LauncherFactory.createLauncher` next to `LauncherFactory.createSession` to raise awareness of the new concept?  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","marcphilipp","2021-01-04T14:06:40Z","2021-02-11T11:45:38Z"
"","1984","Introduce TypeBasedParameterResolver adapter","## Overview  Implementation of a ParameterResolver adapter `TypeBasedParameterResolver` which is handling for the developer the supportsParameter when he wants to implement a type-based resolver. This way he only have to implement the resolveParameter method. e.g. ```java public class TypeBasedMapOfListsParameterResolver extends TypeBasedParameterResolver>> {         @Override 	public Map> resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) 			throws ParameterResolutionException { 		return Map.of(""ids"", asList(1, 42)); 	} } ```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","julien-topcu","2019-08-14T20:11:00Z","2019-08-27T11:58:19Z"
"","1983","Introduce TypeBasedParameterResolver adapter","## Overview  Implementation of a ParameterResolver adapter `TypeBasedParameterResolver` which is handling for the developer the supportsParameter when he wants to implement a type-based resolver. This way he only have to implement the resolveParameter method. e.g. ```java public class TypeBasedMapOfListsParameterResolver extends TypeBasedParameterResolver>> { 	@Override 	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) 			throws ParameterResolutionException { 		Map> map = new TreeMap<>(); 		map.put(""ids"", asList(1, 42)); 		return map; 	} } ```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","beyondxscratch","2019-08-14T20:07:32Z","2019-08-14T20:09:10Z"
"","2604","Fix for currently disabled test in ReflectionUtilsWithGenericTypeHierarchiesTests","## Overview  If accepted, this PR will address part of the outstanding work in issue 981.  It addresses `@Test findsMethodsIndependentlyFromOrderOfImplementationsOfInterfaces()` by ensuring a consistent ordering of returned Class objects when getting the implemented interfaces for a type. This is handled by a new method, `ReflectionUtils.getInterfaces(Class)`.  I wanted a consistent ordering of the results and arbitrarily went for alphanumeric sorting by implemented interface name. I did not add a specific test case for `ReflectionUtils.getInterfaces` in `ReflectionUtilsTest` because my new method is private and because it is covered by the re-enabled test in `ReflectionUtilsWithGenericTypeHierarchiesTests`. I'd be happy to add a specific test, if you want.  I also went further than was necessary to fix the failing test by ensuring that all calls to clazz.getInterfaces() in ReflectionUtils used this method. I did this for consistency within that class.  Issue: #981  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","neilmce","2021-04-29T16:43:26Z","2021-08-13T10:29:16Z"
"","2384","Removed an unnecessary ""a"" in the documentation","## Overview  I removed an unnecessary ""a"" in the documentation  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x ] There are no TODOs left in the code - [x ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","OLibutzki","2020-08-16T18:24:43Z","2020-08-16T18:41:25Z"
"","2295","WIP: Class-based platform-suites from experiments/platform-suites over 5.7.0-M1","## Overview  I ported experiments/platform-suites over 5.7.0-M1.  See #744 Replaces #2267   I still need guidance to improve this proposal to hopefully get it integrated.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","nicerloop","2020-05-13T02:49:44Z","2020-09-18T17:10:24Z"
"","2160","Put final link to gradle metadata documentation","## Overview  I just updated the link to the gradle metadata page in the 5.60 release notes in order to point to the _final_ version of the website instead of a RC version  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","twasyl","2020-01-22T15:00:03Z","2020-02-15T15:16:37Z"
"","2349","Respect `--disable-ansi-colors` option when showing usage help","## Overview  I have updated the command line parser so that the `ConsoleLauncher` disables colors when printing help (see #1537).  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","halitanildonmez","2020-07-05T08:50:31Z","2020-07-06T09:38:51Z"
"","2506","Provide ability to disable test based on OS and environment variable","## Overview  I have created an annotation that is capable of disabling test class or test method based on OS and environment variables. In order to disable the test, both conditions must be satisfied (OS and env variable).  - In the case of missing the env variable test will be executed.  - In the case of a different OS but env variable is present the test will be executed  This PR is a proposition and the API is under the discussion. This is my first PR in this project so I may be missing some obvious things to do, please let me know.  Resolved [#2487](https://github.com/junit-team/junit5/issues/2487) ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","lipinskipawel","2020-12-27T14:42:49Z","2021-01-22T11:37:58Z"
"","2784","Support searches for repeated annotations declared as meta-annotations on container annotations for different repeated annotations","## Overview  I created annotation like this:  ```java @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented @TestTemplate @ExtendWith(DirTestCasesExtension.class) @interface DirArgSource {     /**      * Describe specific files for test case args      */     TestCase[] value() default {};      /**      * Parse test cases from specified directory      */     String[] directory() default {}; } ```  And I want to use it with only filled `directory`, but current implementation of `org.junit.platform.commons.util.AnnotationUtils#findRepeatableAnnotations(...)` does not find `@ExtendWith` in this case  _I haven't tested this patch, it is more like demo of what i mean, but i think it must work._ 🙂  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","gordeevnm","2021-11-23T07:20:35Z","2021-11-26T11:25:23Z"
"","2901","Add Assumptions.assumeDoesNotThrow","## Overview  I added assumeDoesNotThrow in Assumptions.java according to the behavior of assertDoesNotThrow in Assertions.java, which also support both ThrowingSupplier and Executable. I've also added related tests in AssumptionsTests.java, parallel to the tests in AssertDoesNotThrowAssertionsTests.java. Hopefully, this could be helpful to your work. My pleasure to contribute!  Resolves #2482   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","HeaDHeaD0820","2022-04-24T20:10:24Z","2022-07-28T06:23:56Z"
"","2929","Add Assumptions.assumeInstanceOf","## Overview  I added ``assumeInstanceOf()`` in ``Assumptions.java`` according to the behavior of ``Assertions.assertInstanceOf()``, adapting to the form of other assumptions. I've also added related tests in AssumptionsTests.java, parallel to the tests in ``AssertInstanceOfAssertionsTests.java``. Hopefully, this could be helpful or at least can ease your work to some extent. My pleasure to contribute if accepted.  Resolves #2926   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","","HeaDHeaD0820","2022-05-28T16:52:07Z","2022-07-27T17:36:58Z"
"","2802","Use correct HTML heading levels in Javadoc","## Overview  HTML headers in the documentation of type members (except for nested types) should start at ``, see https://docs.oracle.com/en/java/javase/17/docs/specs/javadoc/doc-comment-spec.html#html-content  Normally the javadoc tool warns about this, but it looks like this is not the case when executing the `javadoc` task for JUnit. Maybe the build scripts need to be adjusted? Edit: The reason is probably that the check for incorrect HTML headers was added in [JDK 13](https://bugs.openjdk.java.net/browse/JDK-8220379), but an older JDK is used by this project?  The current usage of `` causes it to look rather strange because that is the same level as the member name itself. Example: ![Header usage example screenshot](https://user-images.githubusercontent.com/11685886/147375792-aa672d5d-708d-4331-abe5-654b6f22f7dd.png)  ([`org.junit.jupiter.api.TestInfo.getDisplayName()`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/TestInfo.html#getDisplayName()))  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","Marcono1234","2021-12-25T02:07:03Z","2022-01-02T15:24:10Z"
"","2781","Resolve MethodSource parameters from Kotlin Companion Object","## Overview  Hi, this is update of my old PR https://github.com/junit-team/junit5/pull/2475 rebased to current main branch. It was closed by stale bot.  What do you think about improvement? It allow to used method source on Kotlin's companion object without `@JvmStatic` or `PER_CLASS` lifecycle settings. Thx Ivos  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","bedla","2021-11-14T20:20:50Z","2022-02-12T23:22:13Z"
"","2475","Resolve MethodSource parameters from Kotlin Companion Object","## Overview  Hi, I found that when I write Parameterized tests in Kotlin with `@MethodSource` referred method from Kotlin class have to be placed in Companion object and marked with `@JvmStatic` annotation. This PR make it possible to use regular companion object's method. What do you think? Thx, Ivos  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ x [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","bedla","2020-11-14T18:15:06Z","2021-06-03T19:46:54Z"
"","2934","Reorganize README","## Overview  Hello, I am a student at Oregon State University and am making this contribution for my OSS class.  I reorganized and included content from JUnit5.org and the User Guide with the mindset of converting new and experienced users to the project.   Changes: - Since this project is done primarily in English and the majority of users will be left-to-right readers I repositioned the logo to the left to catch the eye of those who stumble upon the project. - I changed the synopsis to match the one from the website for those who find this repo before the website. - All the information from the previous Readme is included. I tried to arrange it from information that would be useful/important to new users down to information that JUnit5 team wants to showcase but is data that would interest more experienced users. - Expanded the Features and Documentation to include the website, a link to the portion of the user guide to test features, a link to the backwards compatibility with JUnit4, a link to the supported IDEs, and added a link to the Extensions. This will help point users coming for different reasons to the correct portions of the documentation. - Samples was extracted to its own section and I added an explanation. I personally found the examples tough to find my first time interacting with the repo. - I added badges for the version from the website under latest release.  - The last change is organization of the links within the Markdown. I noticed a mixture of embedded Markdown links and tagged Markdown links. Badges I left as embedded and any other link I added to the tags list at the end of the file for ease of use.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: new,","p0pkern","2022-06-01T16:25:12Z","2022-06-15T16:41:40Z"
"","2425","Support underscores for numeric in CSV sources","## Overview  Hello,  This change adds support for underscores in long numeric literals such as `700_000_000` in `CsvSource` and `CsvFileSource`.  This kind of notation was introduced in Java 1.7 to improve readability of long numbers (https://docs.oracle.com/javase/7/docs/technotes/guides/language/underscores-literals.html). It is also available in Groovy and Kotlin.  This is the kind of thing that can be done with an `ArgumentConverter`, however it adds a lot of boilerplate code and loose the benefit of better readability / maintability.  Let me know if this is something that you would consider integrating to JUnit-Jupiter.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","ledoyen","2020-09-25T23:19:33Z","2020-12-24T06:49:20Z"
"","2365","Use specific name prefix in preemptive timeout threads","## Overview  Having a specific name prefix is useful when debugging stack traces to quickly identify which threads are created by the junit framework and from where exactly.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","zabetak","2020-07-29T16:45:49Z","2020-08-04T08:25:37Z"
"","2706","`autoCloseArguments` support in `@ParameterizedTest` breaks existing tests","## Overview  Having `autoCloseArguments` default to `true` is a breaking change for arguments that are shared between parameterized test invocations.  In the Spring Framework test suite, we have three `@ParameterizedTest` methods (in `PathMatchingUrlHandlerMappingTests` and `ClientHttpConnectorTests`) that hang indefinitely while running against JUnit 5.8 snapshots.  Declaring `@ParameterizedTest(autoCloseArguments = false)` solves the problem, but this is technically a regression and, more importantly, the average user will not even know where to begin debugging such failures.  ## Deliverables  Document that `autoCloseArguments` in `@ParameterizedTest` is a potentially breaking change in:  - [x] Javadoc - [x] Release Notes - [x] User Guide","closed","theme: parameterized tests,","sbrannen","2021-09-03T17:28:04Z","2021-09-10T13:12:39Z"
"","2913","Add ""abort"" methods to Assumptions","## Overview  Greetings! I have added `abort()`, `abort(String)`, and `abort(Supplier)` methods into the `Assumptions` class, along with the relevant tests and release notes. These are analogous to the `fail` methods in the `Assertions` class in that they do not validate anything but just abort the current test.   I found myself looking for a method like this a while back and was surprised they did not exist already. These now allow you to write some more complex business logic around the assumption and to fail it with one neat `abort()` call, instead of an ugly `assumeTrue(false)` or `assumeFalse(true)` call.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc  About this -- the pre-existing assumptions and failure methods did not do any precondition validation either, so I did not add such a thing in these `abort` methods either. It definitely will crash to a NullPointerException if someone passes a `null` `Supplier` to it, but hey, the person writing the tests needs to bear some responsibility too, right?  - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes)  The User Guide I haven't edited, but the release notes (""release-notes-5.9.0-M1.adoc"") I did edit. I think it would be enough for these methods to appear in the JavaDocs and the Release Notes, would you agree?  - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","ZeroOne3010","2022-05-10T14:18:34Z","2022-07-02T15:22:32Z"
"","2241","GitHub issue links in IDEA Git log","## Overview  GitHub issue links in IDEA Git log  ---  ### Definition of Done  Clickable links in IDEA Git log   Before - `#2236`  After -  #2236","closed","status: team discussion,","turansky","2020-04-05T13:27:37Z","2020-04-17T11:28:18Z"
"","2623","Discover suite tests using parent configuration parameters","## Overview  From a practical perspective the expectation is that a `@Suite` annotated class uses the same configuration parameters when discovering tests as the discovery request used to discover the suite.  For example:  When executing a suite with the the `ConsoleLauncher` providing a configuration via `--config=key=value` should have the same effect as configuring this value implicitly as an environment variable via `-Dvalue=key`. However when suites are involved this is not the case. Rather implicit variables are considered while explicit values are ignored.  This surprising to say the least.  This behavior occurs because the `junit-platform-suite-engine` creates a new discovery request - and this includes the implicit configuration by default.  There is also a use case where the suite should neither inherit configuration nor use any implicit configuration values. (e.g. the execution of tcks  #2594).  This PR changes the `junit-platform-suite-engine` so as to only discover tests using the explicitly provided parameters and the parameters from the discovery request used to discover the the suite engine.   This behaviour can be disabled by `@DisableParentConfigurationParameters`. If disabled, only the explicitly provided parameters will be used.   This also means that a suite will never use implicit parameters (unless of course the parent discovery request used them).  Note this replaces: https://github.com/junit-team/junit5/pull/2618  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: suites,","mpkorstanje","2021-05-23T16:46:18Z","2021-08-17T09:46:21Z"
"","2887","Prune suite discovery result before use","## Overview  Fixes: #2838.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mpkorstanje","2022-04-10T22:05:14Z","2022-04-21T12:34:13Z"
"","2453","Fix ReflectionUtils.findMethod test cases","## Overview  Fixes some of the test cases added in https://github.com/junit-team/junit5/issues/981.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","angelyan","2020-10-18T17:24:41Z","2021-06-03T19:46:52Z"
"","2287","Report stacktrace of the stuck thread in `assertTimeoutPreemptively`","## Overview  Fixes https://github.com/junit-team/junit5/issues/2239.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","hisener","2020-05-05T11:05:33Z","2020-07-19T12:26:33Z"
"","2494","Fix compiler warnings","## Overview  Fixes existing Java/Kotlin compiler warnings and makes all compile tasks fail on warnings from now on.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-12-15T20:53:47Z","2020-12-16T07:40:23Z"
"","2885","Only retry deleting directories when cleaning up `TempDir` once","## Overview  Fixes #2883.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2022-04-10T16:29:00Z","2022-04-10T17:18:53Z"
"","2644","Optionally import org.apiguardian.api in OSGi metadata","## Overview  Fixes #2547.  A ""regression"" in the context of this issue (compared with the current situation) would be if importing API Guardian suddenly became required, as that would break existing systems. To guard against such a regression, I modified the `verifyOSGi` task so that it excludes the API Guardian jar/bundle from consideration by the resolver. Thus the test will prove that API Guardian is not required for resolving JUnit 5 bundles.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Vintage,","kriegfrj","2021-06-16T05:17:51Z","2021-06-20T06:57:51Z"
"","2408","Evaluate argument length only when argument is not null","## Overview  Fixes #2405.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] ~Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc~ - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] ~Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html)~ - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","scordio","2020-09-15T06:50:39Z","2020-09-18T12:44:10Z"
"","2253","Add FilePosition in FileSelector and ClasspathResourceSelector","## Overview  Fixes #2146.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","timtebeek","2020-04-10T15:26:40Z","2020-05-22T21:06:38Z"
"","2283","Add possibility to register post-discovery filters via SPI","## Overview  fixes #1997  As we discussed before, I introduced additional configuration property for `LauncherConfig` that allows users to control post-discovery filter auto registration and related methods. For consistency reasons, I introduced an additional method to manually add required post-discovery filters.  This part of changes available in separate commit https://github.com/junit-team/junit5/pull/2283/commits/cb24d1cf515c9ce6e41ea59cbe6f703918aa9c56  Then, additional filters are populated to `EngineDiscoveryOrchestrator`. I don't feel right about introduced changes in `Launcher` interface, It would be nice to hear your opinion on that point. The other option would be to modify the constructor of `DefaultLauncher` (or add a constructor that creates `DefaultLauncher`  from provided `EngineDiscoveryOrchestrator`.   The same way I feel about `EngineDiscoveryOrchestrator` -- I decided to not change constructor and use fluent setter, but maybe it would be better to change existed `EngineDiscoveryOrchestrator` to accept post-discovery filters in addition to engines.  When we agree, I'll add more tests and, probably, we should add support for these changes to TestKit as well  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","baev","2020-05-01T11:13:13Z","2020-06-01T10:32:02Z"
"","2017","Add support for LGTM scanner","## Overview  Fix lgtm build due to requiring JDK 12 https://lgtm.com/projects/g/junit-team/junit5  GitHub has acquired Semmle (creators of LGTM).  https://blog.semmle.com/secure-software-github-semmle/?utm_content=101286158&utm_medium=social&utm_source=twitter&hss_channel=tw-4896799426  I wanted to see if Semmle caught any errors against JUnit5 but the build fails because it attempts to use the wrong JDK version. Also, it's currently not possible to use the QL language to query the Java source of Junit5 due to not being able to build properly.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","JLLeitschuh","2019-09-19T14:27:42Z","2019-09-19T15:10:59Z"
"","2174","Improve error message for TestTemplateInvocationContextProvider","## Overview  Fix javadoc about empty streams from template invocation context providers and produce more helpful error message.  Resolves #2166.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc   **This link is broken... probably should be [this](https://junit.org/junit5/docs/current/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html)** - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","t1","2020-02-06T14:55:40Z","2020-02-09T16:24:08Z"
"","2613","Fix package path computation in `ClasspathScanner`","## Overview  Fix `getRootUrisForPackage()` in class `ClasspathScanner` by looking for two ""wordings"" of a package name.  For example, package `foo.bar` is expanded to `foo/bar` and `foo/bar/`. The latter allows find package `foo.bar` in a module called `foo.bar`, and not `foo`.  Fixes #2500 Fixes #2600 Fixes #2612  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2021-05-11T12:40:13Z","2021-05-12T10:13:15Z"
"","2687","Allow `@TempDir` fields to be `private`","## Overview  Due to discussions involving #864 (see https://github.com/junit-team/junit5/pull/2680#issuecomment-894223321), the JUnit 5 team has decided that `@TempDir` fields should be allowed to be `private`.  ## Deliverables  - [x] Allow `@TempDir` fields to be `private`","closed","component: Jupiter,","sbrannen","2021-08-13T19:26:54Z","2021-08-15T10:08:43Z"
"","2688","Allow `@RegisterExtension` fields to be `private`","## Overview  Due to discussions involving #864 (see https://github.com/junit-team/junit5/pull/2680#issuecomment-894223321), the JUnit 5 team has decided that `@RegisterExtension` fields should be allowed to be `private`.  ## Deliverables  - [x] Allow `@RegisterExtension` fields to be `private`","closed","component: Jupiter,","sbrannen","2021-08-13T19:27:49Z","2021-08-17T09:01:16Z"
"","2588","Document array of dynamic tests in the User Guide","## Overview  Currently the [JUnit 5 User Guide - 2.17.1. Dynamic Test Examples](https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests) includes several examples, but the documentation forgets to mention one of those:  ```java DynamicTest[] dynamicTestsFromArray() { ... } ```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","mincong-h","2021-04-09T02:41:49Z","2021-04-09T22:33:59Z"
"","2643","Add `assertThrowsExactly` assertion method","## Overview  Continuation of #2543.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","marcphilipp","2021-06-11T14:50:26Z","2021-06-20T19:27:10Z"
"","2653","Support AutoCloseable for arguments provided to a @ParameterizedTest","## Overview  Closes #2597.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","juliette-derancourt","2021-06-28T16:46:08Z","2021-11-01T09:00:53Z"
"","2291","Introduce Stream variants of assertLinesMatch methods","## Overview  Closes #2290  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","sormuras","2020-05-08T10:01:37Z","2020-05-29T12:57:46Z"
"","2155","Generate modular javadoc API","## Overview  Closes #2136  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2020-01-16T16:46:14Z","2020-01-19T18:23:58Z"
"","2511","Document constant value for ExclusiveResource.GLOBAL_KEY","## Overview  By documenting the value of `ExclusiveResource.GLOBAL_KEY` test engines that can not reference constants from a class file may use plain text configuration to run tests in isolation.  Additionally by documenting the constants used in `Resources` the canonical resource names are exposed and can be consistently used elsewhere.  Fixes: #2508  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","mpkorstanje","2021-01-01T17:57:39Z","2021-02-11T11:44:10Z"
"","2812","Upgrade Gradle enterprise plugin dependencies","## Overview  Bump up Gradle plugin dependencies  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","jprinet","2022-01-17T10:13:58Z","2022-01-17T13:08:27Z"
"","2650","Bump API Guardian version to 1.1.2-SNAPSHOT","## Overview  Because API Guardian 1.1.2-SNAPSHOT now has OSGi metadata, bumping to this dependency allows Bnd to automatically calculate the correct version of the package to import. This allows removing the extra gymnastics that were inserted to calculate it manually.  Fixes #2547 (again!)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","kriegfrj","2021-06-21T01:58:37Z","2021-06-23T08:58:24Z"
"","2736","All tests in Gradle build are SKIPPED","## Overview  As mentioned in https://github.com/junit-team/junit5/issues/2733#issuecomment-932747744, all tests in the Gradle build are `SKIPPED` since commit 826088ec6a3b602e0717505233aad9f33205aecc.  I will disable Jacoco support for the time being, so that tests are executed within the build.  ## Deliverables  - [x] Determine why all `test` tasks are `SKIPPED` when the Jacoco support is enabled. - [x] Fix the issue and reinstate Jacoco support.","closed","type: bug,","sbrannen","2021-10-02T12:58:39Z","2021-10-03T12:46:04Z"
"","2267","WIP: Class-based platform-suites from experiments/platform-suites based on 5.6.0","## Overview  As I would have use of platform-level suites, especially to hold engine-specific configuration, I grabbed the code from experiments/platform-suites and ported it onto platform 1.6.0, adding recursive suite discovery and arbitrary engine configuration.  This is by no means a finished work, nor an original work, but it fulfils my immediate needs, and seems to be in line with some interests for 5.7 (see issue #744).  As this is my first attempt to contribute to this project, I am fully open to any guidance to improve this proposal to hopefully get it integrated.  I did some copy-paste of deprecated method I did not know how to replace, I did not check to coding conventions, nor did I update any documentation: this is a work in progress.  This Works for Me with cucumber-junit-platform-engine, pitest-junit5-plugin, serenity-cucumber5, from maven and eclipse, without visible problems.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","nicerloop","2020-04-19T16:37:13Z","2020-05-22T13:47:25Z"
"","2519","Make LauncherDiscoveryListener an interface","## Overview  As discussed in today's team call, we're deliberately breaking backwards compatibility of the experimental abstract `LauncherDiscoveryListener` class by changing it to be an interface. This makes it more flexible and consistent with the rest of the codebase, e.g. `TestExecutionListener`.  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","marcphilipp","2021-01-08T19:05:07Z","2021-02-11T11:42:44Z"
"","2554","Improve Javadoc for Assumptions.assumingThat","## Overview  As discussed in https://github.com/junit-team/junit5/discussions/2553, improves the documentation of the `Assumptions.assumingThat(...)` methods by clarifying that, unlike the other assumptions methods, they do not cause a test to be aborted.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","Marcono1234","2021-02-17T23:07:33Z","2021-02-18T22:53:41Z"
"","2631","Provide access to ConfigurationParameters via the TestPlan","## Overview  As discussed in #2630, we should introduce a new `ConfigurationParameters getConfigurationParameters()` method in the `TestPlan` so that a `TestExecutionListener` can access the JUnit Platform configuration parameters instead of having to rely on JVM system properties or other means for the user to configure a listener.  ## Deliverables  - [x] Introduce `ConfigurationParameters getConfigurationParameters()` in the `TestPlan`. - [x] Refactor `UniqueIdTrackingListener` to use configuration parameters instead of system properties once #2630 has been merged into `main`.","closed","type: new feature,","sbrannen","2021-05-29T16:08:25Z","2021-06-02T16:33:38Z"
"","2839","Assert that `@TempDir` fields are not `final`","## Overview  As a follow up to #2837, we have decided to ensure that users do not declare `@TempDir` fields as `final`.  This can be achieved analogous to our field type check in `TempDirectory.assertSupportedType(...)` -- for example, by throwing an `ExtensionConfigurationException` with a descriptive error message instead of allowing the JVM to throw an `IllegalAccessException` for a `static final` `@TempDir` field.  ## Deliverables  - [x] Assert that `@TempDir` fields are not `final` and fail the corresponding container/test.","closed","theme: diagnostics,","sbrannen","2022-03-03T13:42:43Z","2022-03-04T12:29:29Z"
"","2676","Use stable JfrUnit version via JitPack","## Overview  As @gunnarmorling didn't release an early-access version of https://github.com/moditect/jfrunit yet, we want to refer to a stable version of this library in our tests.  This is achieved by referring to a specific GIT tag and making use of JitPack's feature to build and server Maven-based artifacts.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","sormuras","2021-07-28T16:24:18Z","2021-07-29T13:26:03Z"
"","2700","Avoid using `Stream.peek()` for required side effects","## Overview  Although we most likely do not use `skip()` or `limit()` in our stream pipelines, we do occasionally use `peek()` for required side effects (i.e., actions that support a given feature).  The API Note in the Javadoc for `peek()` states the following.  > This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline  Depending on the stream pipeline, `peek()` may never be called, beginning with JDK 17.  ## Related Tweets  - https://twitter.com/sam_brannen/status/1431159180761735168 - https://twitter.com/sormuras/status/1431161108191195140  ## Deliverables  - [x] Analyze where `Stream.peek()` is used within JUnit 5 and avoid its use for required side effects.","closed","component: Platform,","sbrannen","2021-08-27T12:48:31Z","2021-08-27T14:03:54Z"
"","2090","Allow to skip a test invocation from an extension","## Overview  Allow to skip a test invocation from an extension  Fixes #2083  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","loicmathieu","2019-10-31T16:41:31Z","2020-10-08T09:59:16Z"
"","2445","Expose DynamicTest executable to InvocationInterceptors","## Overview  Allow dynamic test invocation interceptors to access the dynamic test executable.  Fixes #2399  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","loicmathieu","2020-10-09T13:48:59Z","2020-11-18T10:12:19Z"
"","2454","Add test case for issue #981","## Overview  Adds test case for issue https://github.com/junit-team/junit5/issues/981.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","angelyan","2020-10-18T18:32:30Z","2021-06-03T19:46:53Z"
"","2822","Add failIfNoTests attribute to @Suite","## Overview  Adds new `failIfNoTests` attribute to `@Suite`. This will fail the suite if no tests were discovered, resolving part of #2819.      This mechanism is implemented by having the `SummaryGeneratingListener` listen in on the test execution while also delegating any execution events to the engine execution listener of the parent engine. If the listener did not hear any test executions the suite will mark its own execution as a failure. This is identical to the console launcher.      To prevent pruning the `SuiteTestDescriptor` from being pruned prematurely and not being executed at all, the suite  describes itself a as test container that may register test. In practice the container will never register any tests.      Closes: #2823  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: suites,","mpkorstanje","2022-02-05T22:01:43Z","2022-04-08T15:40:31Z"
"","2729","Feature/temp dir cleanup","## Overview  Addressing issue #2159 .  This PR adds a TempDirStrategy annotation for managing TempDirs. The annotation has a single CleanupMode enum field that can have a value of ALWAYS or NEVER. If the field is NEVER, then a test class's TempDirs are not cleaned up after the test completes. The annotation also works on nested classes, and a config parameter for the default cleanup mode has been added. Unit tests, demo and documentation included.  The issue discussion included the idea of an 'on_success' mode, but I have been unable to work out how to achieve this. Happy to discuss ideas on how this might be done.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","ghost","2021-09-26T13:34:11Z","2022-05-15T17:47:14Z"
"","2768","Add EnumSource.MATCH_NONE mode","## Overview  Addresses issue #2761  Introduced MATCH_NONE mode in `EnumSource` which only selects the enum constant if none of the regex matches. Added tests in `EnumSourceTest`  Questions:  - Should I add usage in documentation? Current documentation `ParameterizedTestDemo` only contains `MATCH_ALL ` example. There is scope to add `MATCH_ANY` and `MATCH_NONE`  Todo:  - [x] Squash the commits once the changes are approved (will be done by Marc before merging)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [X] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [X] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","npathai","2021-11-02T17:32:21Z","2021-11-05T07:27:00Z"
"","2856","List available test engines","## Overview  Addresses #2789   For example `java -jar junit-platform-console-standalone-1.9.0-SNAPSHOT.jar --list-engines`  yields: ``` junit-jupiter (org.junit.jupiter:junit-jupiter-engine:5.9.0-SNAPSHOT) junit-platform-suite (org.junit.platform:junit-platform-suite-engine:1.9.0-SNAPSHOT) junit-vintage (org.junit.vintage:junit-vintage-engine:5.9.0-SNAPSHOT) ```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","sormuras","2022-03-21T11:11:27Z","2022-04-23T11:11:43Z"
"","2407","Build with JDK 15","## Overview  Addresses #2406   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2020-09-15T06:42:45Z","2020-10-06T06:57:11Z"
"","2870","List all tests found by Console Launcher","## Overview  Addresses  #2854 Lists all `TestIdentifier`s  from a `TestPlan`, result of a test discovery. Essentially same output as if one is executing the tests, but without the execution. ### Option `--list-tests` ### Examples #### Command `java -jar junit-platform-console-standalone-1.9.0-SNAPSHOT.jar --list-tests -cp test/ --scan-classpath` #### Tree command + `--details tree` yields ``` ╷ ├─ JUnit Vintage     ├─ CarTest     │  ├─ testModel()     │  └─ testMake()     └─ JUnit Jupiter  ``` #### Verbose command + `--details verbose` yields ``` ─ JUnit Vintage      tags: []  uniqueId: [engine:junit-vintage]    parent: [] ├─ CarTest      tags: []  uniqueId: [engine:junit-jupiter]/[class:CarTest]    parent: [engine:junit-jupiter]    source: ClassSource [className = 'CarTest', filePosition = null] ├─ testModel()      tags: []  uniqueId: [engine:junit-jupiter]/[class:CarTest]/[method:testModel()]    parent: [engine:junit-jupiter]/[class:CarTest]    source: MethodSource [className = 'CarTest', methodName = 'testModel', methodParameterTypes = ''] ├─ testMake()      tags: []  uniqueId: [engine:junit-jupiter]/[class:CarTest]/[method:testMake()]    parent: [engine:junit-jupiter]/[class:CarTest]    source: MethodSource [className = 'CarTest', methodName = 'testMake', methodParameterTypes = ''] ├─ JUnit Jupiter      tags: []  uniqueId: [engine:junit-jupiter]    parent: [] ``` #### Flat command + `--details flat` yields ``` JUnit Vintage ([engine:junit-vintage]) CarTest ([engine:junit-jupiter]/[class:CarTest]) testModel() ([engine:junit-jupiter]/[class:CarTest]/[method:testModel()]) testMake() ([engine:junit-jupiter]/[class:CarTest]/[method:testMake()]) JUnit Jupiter ([engine:junit-jupiter]) ``` ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","stoyanK7","2022-03-29T14:46:06Z","2022-07-10T17:50:16Z"
"","2354","Issues/2299-inheritance-nesting","## Overview  Added two doubly nested test cases with common, and separate inheritance hierarchies, respectively.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","mmerdes","2020-07-09T11:08:23Z","2021-11-01T09:00:47Z"
"","2491","Provide mechanism to control whether or not to trim whitespace in @CsvSource and @CsvFileSource","## Overview  Added support for @CsvSource annotation.ignoreTrailingAndLeadingWhiteSpace property  Resolves #2420  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [X] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [X] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","somayaj","2020-12-11T18:20:03Z","2021-01-15T21:23:25Z"
"","2103","Enhance Javadoc of InvocationInterceptor wrt. class loading","## Overview  Added note wrt. class loading (static initialization) of the test class in `InvocationInterceptor.interceptTestClassConstructor()`'s javadoc. Depending on the structure of the test class, class loading may or may not have taken place when the method is invoked.   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Jupiter,","jonashoef","2019-11-18T17:11:45Z","2019-12-05T17:19:08Z"
"","2220","Added DisplayName MethodOrderer","## Overview  Added new implementation of MethodOrderer named DisplayName, allowing you to control test execution order based on the test display name that is generated for a test method.    Added implementation, tests, user docs and release notes.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","dylan-asos","2020-03-19T16:27:30Z","2020-04-17T11:01:28Z"
"","2078","Improve documentation for writing tests and conditional test execution","## Overview  Added information in `writing-tests.adoc` about conditional handling, as it is already present in `extensions.adoc`.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","aepfli","2019-10-23T05:37:39Z","2019-12-05T17:18:18Z"
"","2026","Add timeout config parameter","## Overview  Added a new configuration parameter (junit.jupiter.execution.timeout.mode) to determine if timeouts should be applied to annotated tests.  Couple of notes/questions: 1. Since the default was to have it be enabled but still allow someone to comment the parameter out I wondered whether there was any reason to see if the value was set to ""enabled"" or not. To me there's no reason so I only checked to see if the value was ""disabled"" or ""disabled_on_debug"". Thoughts?  2. Testing: I created one new test to make sure that setting the value to ""disabled"" truly did disable the timeouts. If there's a way to test the ""disabled_on_debug"" let me know.  Resolves #1959.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","chrischild","2019-09-24T19:34:17Z","2019-10-11T05:29:17Z"
"","2276","Support custom reason in @Disabled* / @Enabled* variants","## Overview  Add the possibility to give a custom reason in case a test/container is disabled with one of the `@Enabled*`/`@Disabled*` annotations. This reason will be printed in addition to the current default reason.  Resolves #1787.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","juliette-derancourt","2020-04-26T18:45:52Z","2020-05-05T14:52:59Z"
"","2900","Allow @RepeatedTest to stop upon failure","## Overview  Add the field stopFirstFail in @RepeatedTest to **allow @RepeatedTest to stop upon failure (issue #2119)**, but the implementation is to skip the remaining tests after meeting a fail, rather than to stop them.  Resolves #2119  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","YuanPeiqi","2022-04-24T20:02:25Z","2022-07-27T15:31:30Z"
"","2512","Add Revved up by Gradle Enterprise Badge to Readme","## Overview  Add Revved up by Gradle Enterprise badge to readme.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","runningcode","2021-01-04T11:09:08Z","2021-01-04T20:00:23Z"
"","2598","Add identifier element to `TempDir` annotation","## Overview  Add identifier element to `TempDir` annotation.  Closes #1967  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2021-04-16T14:19:25Z","2021-06-08T23:00:49Z"
"","2240","Add icon for JetBrains Toolbox","## Overview  Add icon for JetBrains Toolbox  ### Definition of Done  Icon is shown in JetBrains Toolbox","closed","status: team discussion,","turansky","2020-04-05T12:30:23Z","2020-04-17T15:10:44Z"
"","2270","Execute explicitly selected classes regardless of class name filters","## Overview  Add explicitly selected classes from `--select-class` and `--select-method` to the include patterns passed when constructing the `ClassNameFilter` so that these are always executed regardless of the implicit or explicit class name filter.  Resolves #2259.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","juliette-derancourt","2020-04-23T18:31:42Z","2020-06-15T12:14:19Z"
"","2907","Add dependabot configuration to monitor Gradle plugins","## Overview  Add dependabot configuration to monitor Gradle plugins  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ### Definition of Done  - [X] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [X] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","jprinet","2022-05-05T08:50:23Z","2022-05-05T10:52:40Z"
"","2801","User Guide: The definition of `Container` in JUnit5","## Overview  Add a definition of `Container` in the User Guide. Issue #2205  ---   I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","Nogtif","2021-12-21T13:00:33Z","2022-06-26T08:31:55Z"
"","2727","Add `keySet()` method on `ConfigurationParameters` to retrieve all parameter keys","## Overview  Add `keySet()` method on `ConfigurationParameters` and deprecate `size()`.  Resolves #2520.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: discovery,","juliette-derancourt","2021-09-21T16:57:25Z","2021-11-09T09:33:45Z"
"","2518","Provide a way to run tests only if ports are available","## Overview  Add `EnabledIfPortsAvailable`annotation for running tests only if ports are available.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","zabetak","2021-01-08T19:03:23Z","2021-06-19T12:51:02Z"
"","2980","Fix @ArgumentsSource annotation name","## Overview  A small typo fix in user guide  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","gavvvr","2022-07-17T20:54:44Z","2022-07-21T23:18:38Z"
"","2951","Issues/2914 private lifecycle methods should cause exception","## Overview  `private` lifecycle methods now cause an exception similar to the behavior for `static` methods.  (Not yet completely sure how to precisely define 'our' meaning of overridden/shadowed in this context.)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","mmerdes","2022-06-21T20:42:01Z","2022-07-04T07:33:27Z"
"","2866","Provide module-source-path compiler arg through CommandLineArgumentProvider","## Overview  `module-source-path` _compiler argument_ contains absolute paths which break Gradle build cache relocatability. The already existing ModulePathArgumentProvider can be used to overcome this.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: new,","jprinet","2022-03-22T10:34:19Z","2022-03-22T18:34:56Z"
"","2858","Include Bartholdy as sources","## Overview  _Work in progress..._  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-03-21T14:07:31Z","2022-03-22T17:21:56Z"
"","2694","Prune Release Notes for 5.8 GA","## Overview  _Prune_ the release notes like we have done previously (see 4d3b0a5005cd3a721cae17f3fc838a2409fa7487).  ## Deliverables  - [x] Prune Release Notes for 5.8 GA","closed","theme: documentation,","sbrannen","2021-08-18T14:01:31Z","2021-08-18T14:32:37Z"
"","2861","Rename step to trigger main CI with `temurin`","## Overview  _Investigating #2859_   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-03-22T04:45:32Z","2022-03-23T06:43:18Z"
"","2864","Trigger main CI with OpenJDK 17","## Overview  _Investigating #2859_  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-03-22T04:46:21Z","2022-03-23T06:43:41Z"
"","2863","Trigger main CI with latest Oracle JDK 17","## Overview  _Investigating #2859_  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-03-22T04:46:04Z","2022-03-23T06:43:50Z"
"","2862","Trigger main CI with `microsoft` build of OpenJDK","## Overview  _Investigating #2859_  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2022-03-22T04:45:49Z","2022-03-23T06:43:31Z"
"","2783","Use Gradle `because` to document `junit-platform-launcher` dependency","## Overview  [Link to view rendered doc](https://github.com/aSemy/junit5/blob/5cb390d90eb29c6e6e957eb701f764af0eaaa59b/documentation/src/docs/asciidoc/user-guide/running-tests.adoc)  A really minor change, but I think using 'because' makes the comment more clear - that it's referring to the the `junit-platform-launcher` dependency.  From [the Gradle docs](https://docs.gradle.org/current/userguide/declaring_dependencies.html#sec:documenting-dependencies)  > ### Documenting Dependencies > > When you declare a dependency or a dependency constraint, you can provide a custom reason for the declaration. This makes the dependency declarations in your build script and the dependency insight report easier to interpret.  ### Before   ```kotlin testImplementation(platform(""org.junit:junit-bom:{bom-version}"")) // Only needed to run tests in a version of IntelliJ IDEA that bundles older versions testRuntimeOnly(""org.junit.platform:junit-platform-launcher"") testRuntimeOnly(""org.junit.jupiter:junit-jupiter-engine"") testRuntimeOnly(""org.junit.vintage:junit-vintage-engine"") ```  ### After   ```kotlin testImplementation(platform(""org.junit:junit-bom:{bom-version}"")) testRuntimeOnly(""org.junit.platform:junit-platform-launcher"") {   because(""Only needed to run tests in a version of IntelliJ IDEA that bundles older versions"") } testRuntimeOnly(""org.junit.jupiter:junit-jupiter-engine"") testRuntimeOnly(""org.junit.vintage:junit-vintage-engine"") ```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","aSemy","2021-11-20T08:59:25Z","2021-11-20T13:52:15Z"
"","2436","Enable GitHub Code Scanning Feature","## Overview  [Blog: Code scanning is now available!](https://github.blog/2020-09-30-code-scanning-is-now-available/)  This adds GitHub's new code scanning feature and GitHub action to the Junit5 repository.  Once merged, scan results will appear (only for maintainers) under https://github.com/junit-team/junit5/security/code-scanning  You can also view the results here: https://lgtm.com/projects/g/junit-team/junit5/alerts  Currently there are no scan results/warnings.  Additionally, new potential vulnerabilities that get introduced via pull request will be flagged inline on the pull request.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","JLLeitschuh","2020-10-02T20:40:11Z","2020-10-03T12:17:06Z"
"","2422","@Disabled javadoc - use better wording to be more precise about actua…","## Overview  @Disabled use word ""should"" in ""should not be executed""  Word ""should"" can be interpreted as something which may happen, but it's not 100% sure. Like they say in https://tools.ietf.org/html/rfc2119. In context of JUnit5 this actually means ""shall not be executed""  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","component: Vintage,","michalbcz","2020-09-23T16:26:49Z","2021-02-11T11:45:43Z"
"","2867","Fix integration tests by avoiding downloads from archive.apache.org","## Overview  - Resolve Ant from Maven Central via Gradle - Resolve Maven from Maven Central via Gradle  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2022-03-22T16:57:41Z","2022-03-22T18:29:47Z"
"","2175","Simplified Kotlin Assertions","## Overview  - Inlined `ExecutableStream` and `ExecutableCollection` type aliases since each is only used in two places that don‘t warrant dedicated type aliases. There is also [KT-24700](https://youtrack.jetbrains.com/issue/KT-24700) that makes private type aliases kind of dangerous. - Removed the two map extension functions and instead inlined it at a single spot, all other functions are now calling that function and there is no need for the additional symbols anymore. - Removed the `toList()` calls and exchanged them with `Arrays.stream()`, there is really no need to construct a list first. - Moved the examples to Kotlin files and made them actual tests. This ensures that the code from the examples stays up-to-date and is correct since they are treated like normal tests. In fact, I fixed some samples that where using `Duration.seconds` which actually needs to be `Duration.ofSeconds`.  We could make every trivial, forwarding function `inline` but I didn‘t do it right away because I would first like to know if there are any good reasons not to. I will leave a comment on every function that I believe should be inlined. Instead of making them `inline` we could also drop them altogether since some of them are just forwarding to their corresponding Java functions. Instead of redeclaring the whole Java API in Kotlin we could just start annotating the Java code with the [JetBrains annotations](https://github.com/JetBrains/java-annotations), the result would be the same but the experience would not only be improved for Kotlin users but for Java users as well (given they use IntelliJ).  Moving the samples to actual tests means that I had to enable tests in the API module. I am not sure if this is a good thing. Let me know what you think.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","Fleshgrinder","2020-02-06T19:09:49Z","2021-06-17T06:16:30Z"
"","2183","Add config parameter for deactivating auto-registered listeners","## Overview  - Add conditional property to be able to deactivate listeners being registered from ServiceLoader - Update conditions deactivate to support csv configs  See #2181  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [X] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","nishantvas","2020-02-14T15:42:37Z","2020-03-29T12:50:41Z"
"","2624","Restore executable/readable directory permissions when deleting temp dir","## Overview  * Written some tests to illustrate problem #2609 (→ tests were used to fill [test matrix](https://github.com/junit-team/junit5/issues/2609#issuecomment-846634527)) * Trying to reset readable & executable permissions of `TempDir` itself and any contained files (currently failing)  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","Philzen","2021-05-24T01:14:59Z","2021-08-17T09:45:53Z"
"","2177","Added programmatic test builder API","## Overview  > This is a draft because the PR is still missing crucial parts like tests and documentation. However, the implementation itself is mostly finished and I would like to gather feedback. 😊  Using `junit-jupiter-params` in Kotlin is awkward for many reasons and why I propose the addition of a programmatic, functional API to JUnit that will make `junit-jupiter-params` obsolete for many use-cases.  ```kotlin private class JunitJupiterParamsKt {     /** @see dataProvider */     @ParameterizedTest     @MethodSource(""dataProvider"")     fun isPalindrom(candidate: String) {         assertEquals(candidate.reversed(), candidate)     }      companion object {         @JvmStatic         fun dataProvider(): Stream =             Stream.of(                 arguments(""mum""),                 arguments(""dad"")             )     } } ```  Above is an extremely simple test written in Kotlin that makes use of `junit-jupiter-params` but there are many issues with it (ordered from top to bottom as they occur in the file above):  - We have to add the kdoc block with an `@see` reference to the actual method source to please IntelliJ and stop insisting on `dataProvider` being unused (this is a total IDE issue that can be solved but it is a real issue). - We need to add two annotations to our function to enable the parameterization. - We need to add an annotation with a string value matching the name of the data provider function, keeping it up-to-date manually. - We need to define the signature as we expect things to arrive, however, there are no compile-time checks that actually ensure that the arguments of the data provider are actually compatible with our signature. We might have been running tests for five minutes already until we run into the issue at runtime. - We need to create a companion object where we collect all data providers. This means that the data providers will end up far away from the spot where they are actually being used. Forcing us to scroll and jump around to find everything that makes up a test case.      There is the ability to change the test instance lifecycle to class that lifts this requirement. However, many users do not know about it and I also had to learn that tests can be written in ways that make it impossible to switch. - We need to annotate each data provider with `@JvmStatic`. - We need to add `Stream` as the return type (or add `!!` at the end of the stream construction and each `arguments` call) to disable warnings about missing nullability information. - We need to use `Stream` which is not very idiomatic in Kotlin.  Here is the very same parameterized test written with the programmatic API that I am proposing:  ```kotlin private class JunitJupiterTestBuilderKt {     @TestFactory fun isPalindrom() =         testOf(case(""mum""), case(""dad"")) {              assertEquals(it.reversed(), it)         } } ```  It solves all mentioned issues, better yet, it is also much faster than the version from above because there is no runtime discovery necessary and nothing needs to be wired by JUnit since its all done by the language. We can have all these benefits in Java too:  ```java class JunitJupiterTestBuilderJ {     @TestFactory     TestCases isPalindrom() {         return testOf(             it -> assertTrue(StringUtils.isPalindrom(it)),             caseOf(""mum""),             caseOf(""dad"")         );     } } ```  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","Fleshgrinder","2020-02-08T18:12:25Z","2021-05-14T11:40:33Z"
"","2265","Add potentially failing use-case of #2171","## Overview  > ""[...] any read-only directory in the tree causes cleanup to fail.""  Issue #2171  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","sormuras","2020-04-19T09:42:31Z","2020-04-19T12:52:08Z"
"","2932","Support default `@MethodSource` factory method with arguments","## Overview  #2191 introduced support for using registered `ParameterResolver` extensions when invoking `@MethodSource` factory methods; however, a _default_ factory method for a `@MethodSource` parameterized test is not permitted to accept arguments (i.e., declare parameters resolved by a `ParameterResolver`).  This commit modifies the factory method resolution algorithm so that a factory method that accepts arguments can also be inferred as the _default_ factory method. The key change is the check that the current candidate factory method is not the original test method.  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","sbrannen","2022-05-29T14:33:29Z","2022-06-03T16:49:55Z"
"","2258","Remove deprecated event filtering methods in EngineTestKit API","## Overview  #1950 deprecated the `all()`, `containers()`, and `tests()` event filtering methods in the `EngineTestKit` API for removal in JUnit Platform 1.7.0.  This commit tracks their removal.  ## Deliverables  - [x] Remove deprecated event filtering methods in EngineTestKit API - [x] Document removal in release notes","closed","component: Test Kit,","sbrannen","2020-04-14T15:43:44Z","2020-04-17T10:59:38Z"
"","2318","Update junit5-sponsoring.md","## Overview  ![image](https://user-images.githubusercontent.com/2319838/84035850-a8310a80-a99c-11ea-95c3-610f1ebf6528.png)   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).","closed","","sormuras","2020-06-08T13:28:27Z","2020-06-08T14:32:20Z"
"","2637","Add 'class' URI scheme for dynamic test sources","## Overview   * Adding `ClassSource.from(URI)` method, which accepts URIs with a new `class` scheme. The URI details the fully qualified class name and optional `line` and `column` query parameters.  * Hooking that new scheme into `TestFactoryTestDescriptor.fromUri(URI)`, so that such URIs can be supplied when creating dynamic tests  *  Associated unit test and documentation updates  This enables dynamic tests instances to be located using the information available in a StackTraceElement, so it becomes possible to automatically provide test locations by walking the call stack.  These changes are largely a subset of #2431. To the extent that they work, credit goes to @ST-DDT. To the extent that they're broken, blame falls upon me.  Resolves issue: #2635  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: dynamic tests,","therealryan","2021-06-03T21:39:29Z","2021-06-07T10:08:26Z"
"","2927","provide a AllBooleanCombinationsSource arguments provider #2878","## Overview   I provide a AllBooleanCombinationsSource arguments provider.  Resolve #2878  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","XIANY1203","2022-05-28T07:19:19Z","2022-07-27T15:31:35Z"
"","2426","Issue #2401 adding custom dokka test with configuration","## Overview   I have attempted to take a look at dokka for Kotlin.   I have created a custom task, added dependencies, added some javadoc to Kotlin and tried to generate an html file.  Running the new custom task ends up with an html file as expected. I also updated properties and made it depend on javadoc  task. ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","halitanildonmez","2020-09-26T09:26:33Z","2020-10-25T09:47:08Z"
"","2124","Introduce IndicativeSentences DisplayNameGenerator","## Overview   Hi!, as followed up in the issue #1596, this is the pull request of the implementation of a IndicativeSentencesGenerator supporting the RemplaceUnderscores class and with DisplayName's.  I have a open question: https://github.com/junit-team/junit5/issues/1596#issuecomment-562296145 Here I proposed that might be better to use a variable string to separate the result of the nodes of the test tree, instead of a fixed comma, but I am not sure how to pass that variable.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  --- ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","Kazhuru","2019-12-10T04:47:57Z","2020-06-18T17:15:31Z"
"","2333","Add examples to Javadoc section in CONTRIBUTING.md","## Overview   Hello! I want to contribute and found the simplest issue I could: #1007  It is unclear to me whether it was resolved or not since there is a javadoc section under contribute.md.   I tried to read the linked issue but it seems like the latest versions have their own standards.   So I added an example section for the javadoc section. If this is good for you I can continue updating the document.   If the issue is no longer valid then you can discard this merge request.   Resolves #1007  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: documentation,","halitanildonmez","2020-06-19T20:38:29Z","2020-09-13T07:41:46Z"
"","2928","Allow @RepeatedTest to stop after a certain number of failures","## Overview   Add the field stopAfterFailure in @RepeatedTest to allow @RepeatedTest to stop after a certain number of failures (issue https://github.com/junit-team/junit5/issues/2925), but the implementation is to skip the remaining tests after meeting a fail, rather than to stop them. ---  Related issue [#2925](https://github.com/junit-team/junit5/issues/2925) I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","YuanPeiqi","2022-05-28T16:37:59Z","2022-07-28T06:23:56Z"
"","2917","A start to add DynamicContainerInvocation","## Overview   According to the issue #2661, it appears to be interesting to add this DynamicContainerInvocation, However I just add some basic files and is still working on to finish all the needed part. I found it a little hard and may need some instructions.   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","Cody-Banks7","2022-05-16T14:53:56Z","2022-07-20T03:57:37Z"
"","2366","Make ForkJoinPoolHierarchicalTestExecutorService easier to use","## Overview    This change adds a new constructor `ForkJoinPoolHierarchicalTestExecutorService(ParallelExecutionConfiguration configuration)` so that engines can pass in an instance of `ParallelExecutionConfiguration` directly, instead of having to map it to `ConfigurationParameters` first.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","leonard84","2020-07-30T13:08:13Z","2020-08-11T16:02:12Z"
"","2958","Add factory SPI for `@TempDir`","## Overview    This adds a factory SPI to `@TempDir`, allowing to define how the temporary directory is created.  My initial target was to support a custom file system (#2400), but it may also be a solution for a custom parent directory (#2088).  The intended usage is to extend `TempDirFactory` and provide the class to the new `factory` attribute of `@TempDir`:  ```java class CustomFactory implements TempDirFactory {      @Override     public Path createTempDirectory(String prefix) throws IOException {         return Files.createTempDirectory(""custom-prefix"");     }  } ```  ```java @Test void test(@TempDir(factory = CustomFactory.class) tempDir) {     ... } ```  #### Example with Custom Parent Directory  ```java class CustomParentFactory implements TempDirFactory {      @Override     public Path createTempDirectory(String prefix) throws IOException {         return Files.createTempDirectory(Paths.get(""/tmp-dir-root""), prefix);     }  } ```  #### Example with Custom File System  Using [marschall/memoryfilesystem](https://github.com/marschall/memoryfilesystem):  ```java class MemoryFileSystemFactory implements TempDirFactory {      @Override     public Path createTempDirectory(String prefix) throws IOException {         FileSystem fileSystem = MemoryFileSystemBuilder.newEmpty().build();         return Files.createTempDirectory(fileSystem.getPath(""/""), prefix);     }  } ```  Using [google/jimfs](https://github.com/google/jimfs):  ```java class JimfsFactory implements TempDirFactory {      @Override     public Path createTempDirectory(String prefix) throws IOException {         FileSystem fileSystem = Jimfs.newFileSystem(Configuration.unix());         return Files.createTempDirectory(fileSystem.getPath(""/""), prefix);     }  } ```  I would be happy to receive any feedback on the direction I have taken.  If this feature gets accepted, I would like to add a global configuration parameter like `junit.jupiter.tempdir.factory` in a separate PR.  ### Open points - [x] Testing strategy: new test cases in both `TempDirectoryPerDeclarationTests` and `TempDirectoryPerContextTests`, or separate class? - [ ] Behavior in case of `junit.jupiter.tempdir.scope=PER_CONTEXT` - [x] Both in-memory file system libraries currently fail due to an unsupported `Path::toFile` call: ``` java.lang.UnsupportedOperationException: memory file system does not support #toFile() 	at com.github.marschall.memoryfilesystem.AbstractPath.toFile(AbstractPath.java:74) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.resetPermissions(TempDirectory.java:353) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:282) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:268) ```  ``` java.lang.UnsupportedOperationException 	at com.google.common.jimfs.JimfsPath.toFile(JimfsPath.java:387) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.resetPermissions(TempDirectory.java:353) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.deleteAllFilesAndDirectories(TempDirectory.java:282) 	at org.junit.jupiter.engine.extension.TempDirectory$CloseablePath.close(TempDirectory.java:268) ```  Would it be an option to catch the `UnsupportedOperationException` in `TempDirectory.CloseablePath::resetPermissions` and ignore it? In support of this, the `Path::toFile` javadoc mentions that the exception can be thrown if the `Path` is not associated with the default provider, which can be a potential use case once this SPI is offered.  - [ ] Add test to cover b28450594c576d0433801fe73c0b9d377ea893a9 - [ ] Similar to #2969, should `TempDirFactory::createTempDirectory` allow returning `null` for falling back to the default factory?  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","","scordio","2022-07-02T13:38:04Z","2022-07-23T09:27:50Z"
"","2535","additional arguments source example","## Overview    The example provided with ArgumentsSources uses only **one** parameter, which is a pity because that does not show the full potential of ArgumentsSources. This additional example shows that ArgumentsSources can be used as CsvSource on steroids, because it stays inside the domain of Java code, so that conversions that are impossible from text to java code is easy. The example shows that for instance lambda expressions can be used as parameters in parameterized test without much extra coding.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","homberghp","2021-01-17T18:08:26Z","2021-01-17T18:16:25Z"
"","2972","Introduce AssertionFailureBuilder","## Overview    Resolves #2967.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","type: new feature,","marcphilipp","2022-07-08T20:25:54Z","2022-07-17T16:27:58Z"
"","2894","Added support for `architectures` parameter in @EnabledOnOs and @DisabledOnOs","## Overview    Resolves #2848   ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","michaelfmnk","2022-04-21T20:14:38Z","2022-07-02T13:33:14Z"
"","2342","Add maxCharsPerColumn attribute to @CsvFileSource and @CsvSource","## Overview    MaxCharsPerColumn configuration is added to CsvFileSource and CsvSource.  Resolves #1476. ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","cemurat","2020-06-25T22:06:10Z","2020-08-16T16:42:47Z"
"","2973","Improve debug mode detection in JUnit Jupiter","## Overview    I'm handling an upgrade from JUnit 4 to JUnit 5 and noticed that disabling our timeouts with `-Djunit.jupiter.execution.timeout.mode=disabled_on_debug` is not working as expected.  We use [VSCode](https://code.visualstudio.com/) as our editor/IDE. When using the [Debugger for Java extension](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-debug) to debug tests.  When _ran_ in my project, the following ""test"" prints `[-ea, -Djunit.jupiter.execution.timeout.mode=disabled_on_debug, -XX:+ShowCodeDetailsInExceptionMessages, -Dfile.encoding=UTF-8]`  When _ran with the debugger_ in my project, the following ""test"" prints `[-Xdebug, -Xnoagent, -Djava.compiler=NONE, -Xrunjdwp:transport=dt_socket,address=localhost:34399,server=n,suspend=y, -ea, -Djunit.jupiter.execution.timeout.mode=disabled_on_debug, -XX:+ShowCodeDetailsInExceptionMessages, -Dfile.encoding=UTF-8]`  ```java @Test void test() {   System.out.println(ManagementFactory.getRuntimeMXBean().getInputArguments()); } ```  Notably, the first 4 argument of the output from the run using the debugger are not present from the run without the debugger.  [JUnit 4 detected `-Xdebug` as a sign of debugging](https://github.com/junit-team/junit4/blob/80838a508b8875080c1b59d04f14ebaf74908af0/src/main/java/org/junit/rules/DisableOnDebug.java#L106), but (prior to this change) JUnit 5 does not, leading to the unexpected timeouts while debugging (and regression, compared to JUnit 4). Since JUnit 4 used it, I figured `-Xdebug` was the best thing to detect.  I'm not really sure how to test this kind of thing, but I'm open to suggestions.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","cj81499","2022-07-08T20:31:15Z","2022-07-26T14:37:56Z"
"","2367","Fix special characters in PDF version of User Guide","## Overview    Hello! This commit solves the linked issue. Though here are some things that I wanted to point out.   I had to point to the fonts directory at the `documentation.gradle.kts` file because I was getting errors saying that  **GEM_FONTS_DIR** was not found.   After update, I had to download the default fonts from https://github.com/asciidoctor/asciidoctor-pdf/tree/master/data/fonts    I also changed the ""rare""  Japanese charset, U+FF0 emoji.   Here: https://github.com/asciidoctor/asciidoctor-pdf/blob/v1.5.x/docs/theming-guide.adoc#applying-your-theme it says that one can do `pdf-fontsdir=""path/to/fonts;GEM_FONTS_DIR""` yet it did not worked.   Yet this commit solves the emoji problem.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","halitanildonmez","2020-07-30T18:51:36Z","2020-08-02T08:40:11Z"
"","2414","Issues/2381 provide concise test feed details","## Overview    Hello!   I have attempted to fix issue #2381   What I added:   1. Details option now takes comma separated values now 2. Added a new mode called testfeed 3. Added unit tests for it 4. TestFeed prints according to https://github.com/junit-team/junit5/issues/2381#issuecomment-674025977  Questions:   1. Are there colors you need there ? How should the coloring scheme should look like ?  2. Should we print containers ? Like override testPlanExecutionStarted or dynamicTestRegistered ?  3. Code needs feedback as I am not sure whether it looks as expected  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","","halitanildonmez","2020-09-19T15:23:42Z","2022-06-26T08:39:09Z"
"","2282","implemented #2281, including unit test enhancment and csvfilesource a…","## Overview    Enhance the way CsvFileSource resolves its resources by searching the file system for the named resource in addition to resolving it via the class loader of the test class, which is the current implementation. The following benefits will be provided:  - In case of sub classes in different packages (#1970) this will be a no brainer. In that case specifying the test class as `src/test/resources/testEquals.csv` would solve that whole issue. - Resource resolution will have two steps: file system first, then default to class loader resolution. In case test cases are deployed by jar file, one gets the added benefit of being able to _overwrite_ the test data by supplying a file with the same path and file name as the test data file in the deployment artifact. - Test data classes no longer need to be copied around if the file system resolving is used. This may be a minor issue unless files are big and/or you worry about storage hardware wear.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: parameterized tests,","homberghp","2020-04-30T15:03:42Z","2020-05-08T10:49:31Z"
"","2536","Additional ArgumentsSource example","## Overview    Additional ArgumentsSource example to show the power of ArgumentsSource.   The orginal example shows only one test method parameter, but ArgumentsSource is way more powerful.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","status: stale,","homberghp","2021-01-17T18:33:33Z","2021-08-15T07:50:44Z"
"","2897","the change to fix the issue #2748","## Overview    ---it is for fixing the issue #2748. To be honestly, it just finish the internal part. For special type, the 7 characters rule is true. I found it in [the document](https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md#mangling-rules) and [the souce code](https://github.com/JetBrains/kotlin/blob/92d200e093c693b3c06e53a39e0b0973b84c7ec5/compiler/backend/src/org/jetbrains/kotlin/codegen/state/inlineClassManglingUtils.kt). But its hash fuction is difficult, I still didn't get it. Maybe I will continue to fix it when I am available。 It's my first time to try to do this. If there is something wrong, please give me the comment to introduce.  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","fll02020","2022-04-24T17:59:12Z","2022-07-27T15:31:32Z"
"","2902","Declarative timeout does not interrupt code running in infinite loop #2087","## Overview    --- Declarative timeout does not interrupt code running in infinite loop #2087 I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","Cody-Banks7","2022-04-24T22:57:57Z","2022-04-25T01:08:04Z"
"","2899","Add feature that allow @RepeatedTest to stop upon failure (issue junit-team#2119)","## Overview    --- Add a new field stopFirstFail to **allow @RepeatedTest to stop upon failure**, but the implement is to skip the renaining tests when it encounters a failure, rather than stop them.  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","YuanPeiqi","2022-04-24T18:53:35Z","2022-04-24T19:52:19Z"
"","2931","Try to give a switch that forces a unique order","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  --- I try to give a switch called enforceUniqueOrder for @TestMethodOder, so that it can be used in some cases This is mainly to resolve #2930 and #2757 ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","open","status: stale,","fll02020","2022-05-29T08:09:21Z","2022-07-30T09:06:18Z"
"","2944","Add JRE.JAVA_20","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Jupiter,","marcphilipp","2022-06-14T07:18:46Z","2022-06-14T09:22:48Z"
"","2493","Add JRE.JAVA_17","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-12-15T19:13:00Z","2020-12-15T20:04:09Z"
"","2467","More straightforward usage of Optional","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","yorlov","2020-10-29T06:42:00Z","2020-12-07T18:43:23Z"
"","2466","Use built-in comparator","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","yorlov","2020-10-29T06:34:57Z","2020-10-31T21:20:00Z"
"","2465","Use Math.min instead of manual calculation","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","component: Platform,","yorlov","2020-10-28T19:40:24Z","2020-10-31T21:21:05Z"
"","2654","Resolvable.osgi.result","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","rotty3000","2021-06-28T18:45:28Z","2021-10-29T18:38:42Z"
"","2808","Update Gradle Enterprise plugins","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","runningcode","2022-01-05T17:11:33Z","2022-01-13T12:39:34Z"
"","2186","Handle missing secrets on PR builds from forks","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-02-15T16:43:44Z","2020-02-15T17:06:43Z"
"","2185","Inject Gradle Enterprise access key via file to fix builds from forks","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2020-02-15T16:41:29Z","2020-02-15T16:41:51Z"
"","2139","TEST COMMIT Update KEYS","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","Aligieri","2019-12-27T09:40:12Z","2019-12-27T09:51:16Z"
"","2992","Remove GH Actions specific env vars","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2022-07-28T15:12:06Z","2022-07-29T07:21:29Z"
"","2960","Improve stability of timeout tests","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","marcphilipp","2022-07-03T15:40:42Z","2022-07-03T17:23:25Z"
"","2898","Provide a MethodOrderer which enforces unique order(junit-team#2757)","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","XIANY1203","2022-04-24T18:12:42Z","2022-05-28T02:46:04Z"
"","2562","Update Gradle Enterprise Gradle Plugin to 3.5.2","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","runningcode","2021-03-02T16:29:30Z","2021-03-06T10:15:37Z"
"","2356","Update mockito version to 3.4.2","## Overview    ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [ ] There are no TODOs left in the code - [ ] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org.junit.platform.commons/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [ ] [Coding conventions](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [ ] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [ ] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/HEAD/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [ ] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [ ] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","theme: build,","mickroll","2020-07-17T11:54:16Z","2020-07-17T14:23:45Z"
"","2738","Introduce iterationSelector DiscoverySelector to JUnit Platform","## Motivation  With this [commit](https://github.com/spockframework/spock/commit/90427874f5ccde29be8cfb35c0f3450244bd8dd1) Spock got the capability to select individual iterations via their `UniqueId`. This works great for re-running a test from the IDE, but it doesn't work well if you don't have a prior run to obtain the `UniqueId` as we don't want external tools to create these IDs themselves.  ![Spock_Run_Iteration](https://user-images.githubusercontent.com/1151511/135996162-01fbdb61-452a-4668-8766-93c0ae2ad140.png)  ## Possible Solution  `DiscoverySelectors.iterationSelector(MethodSelector method, int... iterationIndices)`  This would re-use the existing `MethodSelector` to select the method and accept a varargs of indices to select which iterations to run.  ## Deliverables  - [ ] Add a `DiscoverySelectors.iterationSelector(...)`","closed","type: new feature,","leonard84","2021-10-05T09:20:42Z","2022-06-19T13:09:16Z"
"","2247","TestExecutionListener,  Test that failed while parameterizing the test, gets the result “SUCCESSFUL”","## java test code  ```java  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource;  import java.util.stream.Stream;   public class test {     @ParameterizedTest     @MethodSource(""userGenerator"")     void testFail1(String name,String pw) {         Assertions.assertEquals(name,pw);     }     public static Stream userGenerator(){         return Stream.of(Arguments.of(""15138493452"", ""hlf2016""));     } } ```  ```java public class TestListener implements TestExecutionListener {   /*     *   ... ...     */  public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {   }    if (""SUCCESSFUL"".equals(testExecutionResult.getStatus().name())) {           /* testExecutionResult.getStatus().name() = ""SUCCESSFUL""            *            * Expected : FAILURES            */   }  } ```  ## bug screenshots  ![image](https://user-images.githubusercontent.com/2319838/78626999-a6f63b00-7890-11ea-89b4-10c6cda1a65a.png)","closed","component: Platform,","houseshi","2020-04-07T02:09:23Z","2020-04-08T01:21:23Z"
"","2671","@ParametersByName annotation","## Goals  A really low-friction way to provide a set of parameters for a parameterized test.  Also, sometimes it's desirable to get full coverage of all combinations of parameters. For example, try all `Evaluator` implementations with all possible `Expression` objects. The existing parameterization schemes require the user to list all the possible combinations; it would be nice if independent parameters could be injected independently.  ## Usage example  I have the following example working in my project and I think it's pretty handy.  The effect is to call the `test` method with every combination of `name` and `number` returned by the static methods.  ``` public class MyTest { 	@ParametersByName  // The new annotation 	void test(String name, Integer number) { 		// test goes here 	}  	static Stream name() { 		return Stream.of(""Hello"", ""world""); 	}  	static Stream number() { 		return Stream.of(123, 456, 789); 	} } ```  `@ParametersByName` is a variant of `@TestTemplate`:  ``` @Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @ExtendWith(ParametersByNameContextProvider.class) @TestTemplate public @interface ParametersByName { } ```  `ParametersByNameContextProvider` calls, for each parameter, a static method with the same name. It expects a `Stream` of values. It creates a `TestTemplateInvocationContext` for each combination of parameter values. It looks up the methods using `ReflectionUtils` so it plays nice with inheritance even though the methods are static.  If you agree that this is a good practice, perhaps it could be included in the base JUnit5 distribution.  For Java 8, it current requires the javac flag `-parameters` to include parameter name information in the classfile of the test class. But the annotation could also accept parameter names, like `@ParametersByName({""name"",""number""})`.  ## Deliverables  - [ ] `@ParametersByName` annotation that calls a method for each parameter, and invokes the test template with every combination of parameter values returned by those methods.","open","status: new,","prdoyle","2021-07-24T21:05:48Z","2022-03-11T09:24:59Z"
"","2229","Support some level of parallelization in junit-vintage-engine","## Goal Add support for some level of parallelization inside the Junit Vintage engine. Ideally the level of configuration should be similar to maven surefire parallel options.  ## Why When including junit 5 tests in a project containing junit4 tests the natural path is to use junit 5 platform with the jupiter and vintage engines.  However this causes problem with parallelization.  In a project with Junit4 tests only maven surefire level parallelization works fine. (See https://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html). For Junit5 tests the jupiter engine [parallel execution works great](https://junit.org/junit5/docs/snapshot/user-guide/#writing-tests-parallel-execution).   However when a project contains a mix of Junit4 and Junit 5 there is no great way to configure parallelism: * Surefire parallel does not work with Junit Platform Provider so it's not an option * Surefire forkCount or gradle maxParallelForks can be used but:   * It's not available at all when using  [tycho surefire](https://www.eclipse.org/tycho/sitedocs/tycho-surefire-plugin/plugin-info.html)   * It introduces some memory and execution time overhead compared to surefire parallel or junit 5 parallel.   * It provides less control than Junit 5 parallel execution options. * Combining fork + junit 5 parallel execution leads to more parallel executions than expected  when executing junit 5 tests because parallelization is done at two level.  Another option is to configure two distinct test tasks one for junit 4 using surefire parallel and one for junit 5 but it kind of defeats the point of junit platform.  ## Deliverables  - [x] Not sure","open","type: new feature,","sarod","2020-03-31T09:53:38Z","2022-05-27T10:04:34Z"
"","2272","Add Flight Recording Test Execution Listener","## Flight Recording Test Execution Listener  Implement a `TestExecutionListener` that sends Java Flight Recorder events.  Motivation: https://twitter.com/gunnarmorling/status/1270285860626403329?s=20 > Essentially, where I currently ask users ""Can you increase your log level to DEBUG and share logs from component xyz"", I'd like to use JFR.  ### Links and Resources  - [Flight Recorder API Programmer’s Guide](https://docs.oracle.com/en/java/javase/14/jfapi) - [Repositories related to Flight Recorder](https://github.com/flight-recorder) - [JEP 328: Flight Recorder](https://openjdk.java.net/jeps/328) - [JEP 349: JFR Event Streaming](https://openjdk.java.net/jeps/349) - [2020 DevDotNext Digital Edition - Continuous Monitoring With JFR](https://www.youtube.com/watch?v=E9K5m1HXMSc) 📹 - [Using JDK FlightRecorder and JDK Mission Control](https://blog.arkey.fr/2020/06/28/using-jdk-flight-recorder-and-jdk-mission-control/) by Brice Dutheil  ## Deliverables  - [x] Spike a JFR-based `TestExectionListener` implementation PR #2271  - [x] Get spike to build and run it on Java 8, 11, and 14 - [x] Decide which events to commit: test only, containers, dynamic test registration, ... - [x] Decide which data to send: unique id, display names, result - [x] Decide which metadata to supply: category, name, label","closed","type: new feature,","sormuras","2020-04-24T13:06:38Z","2020-07-12T11:00:56Z"
"","2730","FindException: Module org.apiguardian.api not found, required by org.junit.platform.launcher","## Description When using a `module-info.java` as part of the test sources, Gradle fails executing the tests: ``` > Task :test FAILED Error occurred during initialization of boot layer java.lang.module.FindException: Module org.apiguardian.api not found, required by org.junit.platform.launcher ```  It appears #2695 tried to solve that issue for 5.8.0, but I am seeing this behavior for 5.8.0 and 5.8.1. Manually adding `testImplementation(""org.apiguardian:apiguardian-api:1.1.2"")` as dependency solves this issue.  ## Steps to reproduce  1. Clone https://github.com/Marcono1234/junit5-module-issue-demo 2. Run `./gradlew build` :x: It fails with a `FindException`  ## Context   - Used versions (Jupiter/Vintage/Platform): `org.junit.jupiter:junit-jupiter:5.8.1`  - Build Tool/IDE: Gradle 7.2","closed","3rd-party: Gradle,","Marcono1234","2021-09-27T13:59:17Z","2021-10-13T22:22:11Z"
"","2243","Improve module descriptions","## Description  The short texts we provide aren't descriptive. Often, they only repeat the name of the module.  https://search.maven.org/artifact/org.junit.jupiter/junit-jupiter shows  ![image](https://user-images.githubusercontent.com/2319838/78581543-4afdc900-7834-11ea-9c75-b0058f61a85a.png)  https://package-search.jetbrains.com/search?query=junit shows  ![image](https://user-images.githubusercontent.com/2319838/78578225-7fbb5180-782f-11ea-96ec-9f53e47dda9c.png)  ## Deliverables  - [ ] Improve short descriptions of each module/artifact/package in such a way, that its purpose is clear, i.e. don't repeat the information that the name already carries.","closed","status: stale,","sormuras","2020-04-06T15:56:53Z","2022-07-11T20:21:42Z"
"","2469","Make useful console loggers public API","## Deliverables  TreePrintingListener should be public  Workaround  ``` private fun treeListener(): TestExecutionListener {   return Class.forName(     ""org.junit.platform.console.tasks.TreePrintingListener"").declaredConstructors.first()     .apply {       println(this)       isAccessible = true     }     .newInstance(PrintWriter(System.out), false, Theme.UNICODE) as TestExecutionListener } ```","closed","","yschimke","2020-10-29T09:03:11Z","2020-10-30T17:35:14Z"
"","2329","Extend JRE enum to support Java 16","## Deliverables  Perform the following for Java **16**.  - [x] Extend `enum JRE` with the new `JAVA_N` constant, with `N` being the latest feature version number. - [x] Update `EnabledOnJreIntegrationTests`, `DisabledOnJreIntegrationTests`, `EnabledOnJreConditionTests`, and `DisabledOnJreConditionTests` accordingly. - [x] Update `EnabledOnJreIntegrationTests`, `DisabledOnJreIntegrationTests`, `EnabledOnJreConditionTests`, and `DisabledOnJreConditionTests` accordingly. - [x] Test against JDK `N`. - [x] Document in Release Notes.  ## History  - 12 https://github.com/junit-team/junit5/issues/1656 - 13 https://github.com/junit-team/junit5/issues/1760 - 14 https://github.com/junit-team/junit5/issues/1934 - 15 ...","closed","theme: modules,","sormuras","2020-06-16T10:35:09Z","2020-07-10T13:33:30Z"
"","2451","Improve user guide for Nested Tests (section 2.11.)","## Deliverables  - A clear documentation of nested tests. Currently, section _Nested Tests_ contains:  > Nesting can be arbitrarily deep, and those inner classes are considered to be full members of the test class family with one exception: @BeforeAll and @AfterAll methods do not work by default.  It is unclear what the _test class family_ is. It is also unclear how the _Nested test suite for testing a stack_ behaves.","closed","theme: documentation,","Chealer","2020-10-15T18:20:25Z","2020-11-15T14:37:34Z"
"","1986","Support @ExtendWith at package level and module level","## Context  I've written an extension which deterministically 'shards' my tests to ensure they run on exactly one CircleCI node (by hashing the name into CIRCLE_NODE_TOTAL buckets), allowing me to dial up [parallelism](https://circleci.com/docs/2.0/parallelism-faster-jobs/#specifying-a-jobs-parallelism-level) and make my builds go faster.  However, it's kinda annoying having to add my annotation `@CircleCiSharding` to every single test class.  I considered using the [automatic registration](https://junit.org/junit5/docs/current/user-guide/#extensions-registration-automatic) functionality (`-Djunit.jupiter.extensions.autodetection.enabled=true`), but I don't like the risk that some other obscure test dependency will then magically start applying its own extension to my tests.  I'd prefer to retain 100% control of exactly what I enable, it's just quite verbose with annotations on every class at the moment.  Another option is to have a single TestBase which all other tests inherit from, but it's very easy to accidentally forget to use this when writing a new test.  ## Proposal  My suggestion would be to allow people to write a `package-info.java`:  ```java @ExtendWith(CircleCiShardingExtension.class) package com.foo.bar; ```  I'm imagining this would apply the extension to all tests within this package. This satisfies my goals because:  - I don't have to enable magical auto-registration, so dependency changes can't change the behaviour of my tests - newly authored test classes will just 'do the right thing' without devs having to remember to my `@CircleCiSharding` annotation","closed","status: stale,","iamdanfox","2019-08-19T16:34:32Z","2022-07-11T20:21:36Z"
"","2180","Kotlin test code using backtick test method names has case-insensitive collision","## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter  - Build Tool/IDE: Grade 5.6.4 or IntelliJ IDEA 2019.3.3  Junit 5 - 5.5.2 Junit Platform - 1.5.2 Kotlin - 1.3.61 Java 11.0.5 (Zulu)  ## Steps to reproduce  ```java import java.util.* import kotlin.test.* import org.junit.jupiter.api.Tag import org.junit.jupiter.api.assertThrows  @Tag(""unit"") class CasingTest {     @Test     fun `when blah, methodA succeeds`() {       // anything or nothing here     }     @Test     fun `when BLAH, methodA succeeds`() {       // anything or nothing here     } } ``` **Expectation:**  Since it's valid in Kotlin to have these two as separate methods you would expect both methods to execute appropriately.  **Actual:** java.lang.NoClassDefFoundError  /TestClass$when blah, methodA succeeds$result$1 (wrong name: /TestClass$when BLAH, methodA succeeds$result$1)","closed","status: waiting-for-feedback,","mattdkerr","2020-02-11T21:28:49Z","2020-03-01T15:37:57Z"
"","2503","JUnit5 tests annotated with @Tag are not executed in suite that has @IncludeTags, unless combined with @SelectPackages","## Bug description  A test suite with `@IncludeTags({ ""foo"" })` will not pick up test annotated with `@Tag(""foo"")`, unless the suite also explicitly has the `@SelectPackages({ ""org.foo"" )}` annotation. It should be possible to not have to define all the packages.  ## Steps to reproduce  * Test class: ```java @Tag(""foo"") class SomeIT {     @Test    public void testSomeStuff()    {        ...    }  } ```  * Suite class: ```java @RunWith(JUnitPlatform.class) @IncludeTags({""foo""}) //@SelectPackages(""org.foo"") public class SomeITSuite { } ``` When you don't have the `@SelectPackages(""org.foo"")`, the `SomeIT` will not be automatically discovered and executed. * Minimal `pom.xml`: ```xml       4.0.0      org.foo     bar     1.0-SNAPSHOT     jar                UTF-8          1.7.30         5.7.0         1.7.0                                                  org.apache.maven.plugins                 maven-compiler-plugin                 3.8.1                                      1.8                     1.8                     UTF-8                                                            org.apache.maven.plugins                 maven-surefire-plugin                 3.0.0-M5                                                                org.junit.jupiter             junit-jupiter             ${version.junit}             test                               org.junit.platform             junit-platform-runner             ${version.junit.platform.runner}             test                                          integration-tests                                                                             org.apache.maven.plugins                         maven-failsafe-plugin                         3.0.0-M5                                                                                       **/*ITSuite.java                                                                                                                                             integration-test                                 integration-test                                                                      integration-test                                                                                                                            verify                                 verify                                                                      verify                                                                                                                                                          ```  This executes the suite with 0 tests in both Idea and a console (using `mvn clean install -Pintegration-tests`).  If I restore the commented out `@SelectPackages(""org.foo"")`, it will run all the tests, regardless of whether they're tagged, or not. It doesn't even care, if they're in those packages. What am I missing here? Is this a bug?  Associated [Stackoverflow question](https://stackoverflow.com/questions/65398013/how-to-get-junit-tests-annotated-with-tag-to-be-executed-in-suite-that-has-inc).  ## Context  * Used versions (Jupiter/Vintage/Platform):   * JUnit: 5.7.0   * JUnit Platform Runner: 1.7.0 * Build Tool/IDE:   * Maven 3.6.3, IntelliJ Idea, XTerm ``` Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: /java/apache/maven-3.6.3 Java version: 1.8.0_241, vendor: Oracle Corporation, runtime: /java/jdk1.8.0_241/jre Default locale: en_GB, platform encoding: UTF-8 OS name: ""linux"", version: ""5.4.0-56-generic"", arch: ""amd64"", family: ""unix"" ```  ## Deliverables  - [ ] It should be possible to run the tests in the suite without having a `@SelectPackages(""org.foo"")`, if there is a `@IncludeTags`.","closed","theme: suites,","carlspring","2020-12-21T21:04:09Z","2020-12-24T14:19:20Z"
"","2168","Allow @Testable on fields","## Background  Currently, it's only possible to annotate classes and methods with `@Testable` to indicate that those are testable.  In ArchUnit we have a custom engine to execute defined architecture rules as tests. The user has to annotate the elements with `@ArchTest`. The engine executes all rules that are annotated `@ArchTest`, no matter if they are methods or fields.  Example project: [archunit-example/example-junit5](https://github.com/TNG/ArchUnit/tree/v0.13.0/archunit-example/example-junit5) Example test class: [CodingRulesTest](https://github.com/TNG/ArchUnit/blob/v0.13.0/archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/CodingRulesTest.java)  When I open the mentioned test class in my IDE, the IDE only recognizes the class itself and the one method as testable. The fields are not recognized as testable.  ## Suggestion  It should be possible to (meta)-annotate fields with `@Testable`. With this enhancement, IDEs have the chance to identify testable fields.","closed","theme: discovery,","rweisleder","2020-01-30T09:05:00Z","2020-04-19T14:59:21Z"
"","2663","ReflectionUtils.hasCompatibleSignature method return false incorrectly in some cases","## Applies to JUnit 5.7.2 / Junit-platform-commons 1.7.2  `ReflectionUtils.hasCompatibleSignature()` should return true for methods that have wider parameters than the passed argument types, however, it will return false.  Since this method is used by all of the `findMethod()` methods, all of those methods are similarly broken in this class (`ReflectionUtils`) and `ReflectionSupport`.  ## Steps to reproduce Here is a sample test that demonstrates the issue via `ReflectionSupport.findMethod`, which uses `hasCompatibleSignature` in its implementation.  You would expect `findMethod` to find the `format(Object)` method if you pass any type of Object (except Date which has an overloaded method version), however, it only finds this method if `Object.class` is passed, not a `String.class`.  ```java @Test public void junitTest() throws Exception {      //There is a SimpleDateFormat.format(Object) method     assertTrue( 	    ReflectionSupport.findMethod( 			    SimpleDateFormat.class,  			    ""format"", 			    Object.class 	    ).isPresent()     );          //This should find the same method as above since     //a string can be passed to the same method, but     // - - THIS TEST FAILS - -     assertTrue( 	    ReflectionSupport.findMethod( 			    SimpleDateFormat.class, 			    ""format"", 			    String.class 	    ).isPresent()     );  } ```  ## Notes  It seems clear that the intent is that the wider method signatures be accepted and it would make sense because the found method would be usable.  The [for loop on this line](https://github.com/junit-team/junit5/blob/main/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java#L1632) is where the code steps through each method argument to ensure that the method accepts a wide type then the passed type.  If that is not true for any argument, false is returned inside the loop.  However, if all arguments pass the test, only methods that pass the `isGeneric` test return true.","closed","component: Platform,","eeverman","2021-07-10T20:45:03Z","2021-12-03T13:59:55Z"
"","2059","Reflection testcases","## Add tests covering method selection edge cases  Issue #981 These tests show that generic interfaces with a default implementation can lead to unwanted behaviour when selecting a method with a parameter type that extends the used generic type.  ---  I hereby agree to the terms of the [JUnit Contributor License Agreement](https://github.com/junit-team/junit5/blob/002a0052926ddee57cf90580fa49bc37e5a72427/CONTRIBUTING.md#junit-contributor-license-agreement).  ---  ### Definition of Done  - [x] There are no TODOs left in the code - [x] Method [preconditions](https://junit.org/junit5/docs/snapshot/api/org/junit/platform/commons/util/Preconditions.html) are checked and documented in the method's Javadoc - [x] [Coding conventions](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#coding-conventions) (e.g. for logging) have been followed - [x] Change is covered by [automated tests](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#tests) including corner cases, errors, and exception handling - [x] Public API has [Javadoc](https://github.com/junit-team/junit5/blob/master/CONTRIBUTING.md#javadoc) and [`@API` annotations](https://apiguardian-team.github.io/apiguardian/docs/current/api/org/apiguardian/api/API.html) - [x] Change is documented in the [User Guide](https://junit.org/junit5/docs/snapshot/user-guide/) and [Release Notes](https://junit.org/junit5/docs/snapshot/user-guide/#release-notes) - [x] All [continuous integration builds](https://github.com/junit-team/junit5#continuous-integration-builds) pass","closed","","Faradax","2019-10-12T12:34:36Z","2019-10-12T14:02:13Z"
"","2430","PreDestroy callback is not invoked for enclosing instances of nested classes","## Actual behavior  I have a JUnit extension which implements the `TestInstancePostProcessor` and `TestInstancePreDestroyCallback`. When using this extension for a test class with inner nested test classes, if the lifecycle of the enclosing class is `PER_METHOD`, then an instance of the enclosing class is created for the tests in the nested class, as well as a nested instance for each or all of the tests (depending on the lifecycle of the nested class). The post-process hook is then called for the enclosing instance and the nested instances, but the pre-destroy hook is only called for the nested instances and not for the enclosing instance.  ## Expected behavior  The post-process and pre-destroy hooks are called both for the nested instances as well as for the enclosing instance.  ## Steps to reproduce  Example test which shows the behavior: ```java @ExtendWith(OuterTests.LifecycleExtension.class) class OuterTests {     @Test     void testOuter1() {         System.out.println(""testOuter1"");     }      @Test     void testOuter2() {         System.out.println(""testOuter2"");     }      @Nested     class InnerTests {         @Test         void testInner1() {             System.out.println(""testInner1"");         }          @Test         void testInner2() {             System.out.println(""testInner2"");         }     }      static class LifecycleExtension implements TestInstancePostProcessor, TestInstancePreDestroyCallback {         @Override         public void postProcessTestInstance(Object testInstance, ExtensionContext context) {             System.out.println(""postProcess: "" + testInstance);         }          @Override         public void preDestroyTestInstance(ExtensionContext context) {             System.out.println(""preDestroy: "" + context.getRequiredTestInstance());         }     } } ```  Output for lifecycle = PER_METHOD for outer and inner class (indentations for better readability): ``` postProcess: mypackage.OuterTests@7bedc48a -- testOuter1 preDestroy: mypackage.OuterTests@7bedc48a  postProcess: mypackage.OuterTests@38e79ae3 -- testOuter2 preDestroy: mypackage.OuterTests@38e79ae3  postProcess: mypackage.OuterTests@63070bab -- postProcess: mypackage.OuterTests$InnerTests@291b4bf5 ---- testInner1 -- preDestroy: mypackage.OuterTests$InnerTests@291b4bf5  postProcess: mypackage.OuterTests@2d2ffcb7 -- postProcess: mypackage.OuterTests$InnerTests@762ef0ea ---- testInner2 -- preDestroy: mypackage.OuterTests$InnerTests@762ef0ea ```  Output for lifecycle = PER_CLASS for outer and inner class (indentations for better readability): ``` postProcess: mypackage.OuterTests@fa4c865 -- testOuter1 -- testOuter2  -- postProcess: mypackage.OuterTests$InnerTests@2d2ffcb7 ---- testInner1 ---- testInner2 -- preDestroy: mypackage.OuterTests$InnerTests@2d2ffcb7 preDestroy: mypackage.OuterTests@fa4c865 ```  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit Jupiter 5.7.0  - Build Tool/IDE: Maven 3.6.3, IntelliJ IDEA 2020.2, OpenJDK 11","closed","component: Jupiter,","paschi","2020-09-30T13:43:30Z","2020-12-13T13:30:02Z"
"","2778","Using a single aggregator on the method level","# The problem When not all parameters consume the same number of arguments, then it is hard to consume the right arguments.  I have discusses the problem here: #2777  I currently do this with a static variable and a call from `@BeforeEach` setup method to reset method, but I do not like this solution.  ## Example ```java @ParameterizedTest @CsvSource({     ""1, 2, 3, 4, 5"" }) public void test1(@AggregateWith(XA.class) X x, @AggregateWith(YA.class) Y y) {} public void test2(@AggregateWith(YA.class) Y y, @AggregateWith(YA.class) X x) {}  public class XA implements ArgumentsAggregator {     public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)             throws ArgumentsAggregationException {         int index = context.getIndex();         return new Y(accessor.getInt(index + 0), accessor.getInt(index + 1));     } } public class YA implements ArgumentsAggregator {     public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)             throws ArgumentsAggregationException {         int index = context.getIndex();         return new Y(accessor.getInt(index + 0), accessor.getInt(index + 1), accessor.getInt(index + 2));     } } ```  # Solution I would like the option to use `@AggregateWith` on the method level. The aggregator that is referred to should be instanced once per method call and called for every parameter. This way, the consumed arguments can be tracked.  ## Example ```java @ParameterizedTest @CsvSource({     ""1, 2, 3, 4, 5"" }) @AggregateWith(MyAggregator .class) public void test1(X x, y y) {} public void test2(Y y, X x) {}  public class MyAggregator  implements ArgumentsAggregator {     private int offset = -1;     @Override     public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)             throws ArgumentsAggregationException {         Class type = context.getParameter().getType();         if (type.equals(X.class))             return new X(accessor.getInt(++offset), accessor.getInt(++offset));         if (type.equals(Y.class))             return new Y(accessor.getInt(++offset), accessor.getInt(++offset), accessor.getInt(++offset));         throw new UnsupportedOperationException();     } } ```  # Future improvement It might also be nice to use a default aggregator and register convertor classes with it. I think this will lead to more reuse being possible  ## Example ```java @ParameterizedTest @CsvSource({     ""1, 2, 3, 4, 5"" }) @ConvertWith(XC .class) @ConvertWith(YC .class) public void test1(X x, y y) {} public void test2(Y y, X x) {}  public class DefaultAggregator  implements ArgumentsAggregator {     private int offset = -1;     private Map, SomeFunction> map;      public void register(Class type, SomeFunction func> { map.put(type, func); }      public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context) {         Class type = context.getParameter().getType();         if (map.contains(type)) {             SomeFunction func = map.get(type);             Object obj = func.function(offset, accessor, context);             offset += func.consumes();             return obj;         }         throw new UnsupportedOperationException();     } }  public class XC implements SomeFunction {     public Object function(int offset, ArgumentsAccessor accessor, ParameterContext context) {         return new X(accessor.getInt(++offset), accessor.getInt(++offset));     }     public int consumes() { return 2; } }  public class YC implements SomeFunction {     public Object function(int offset, ArgumentsAccessor accessor, ParameterContext context) {         return new Y(accessor.getInt(++offset), accessor.getInt(++offset), accessor.getInt(++offset));     }     public int consumes() { return 3; } } ```","closed","theme: parameterized tests,","akruijff","2021-11-11T21:35:10Z","2021-11-19T11:21:08Z"
"","2294","Introduce getJavaClass() and getJavaMethod() in MethodSource","# Problem Description We added a new Annotation to the Test Cases, i.e. DisplayDescription, which allows giving a longer description of a test case than that of DisplayName(). Afterward, we need to check for the presence of / access this annotation. We do this via the TestIdentifier.   `Optional source = identifier.getSource();`  In case of a class source it is straightforward:   ``` if (source.filter((e) -> e instanceof ClassSource).isPresent()) {      ClassSource cs = (ClassSource) source.get();      annotation = cs.getJavaClass().getAnnotation(DisplayDescription.class); } ```  However, there isn´t, to our knowledge, a function that does the same for methods, leaving us to use Reflection in order to get the Java Method Source:   ``` else if (source.filter((e) -> e instanceof MethodSource).isPresent()) {      MethodSource ms = (MethodSource) source.get();      try {          annotation = Arrays.stream(Class.forName(ms.getClassName()).getMethods())                   .filter(m -> m.getName().equals(ms.getMethodName()))                   .findAny().map(m -> m.getAnnotation(DisplayDescription.class))                  .orElse(null);      } catch (ClassNotFoundException e) {          annotation = null;     } } ```  # Request Support for something in the art of: `((MethodSource) source.get()).getJavaMethod()` that works analog to getJavaClass","closed","theme: discovery,","kicasta","2020-05-12T07:51:19Z","2020-06-16T13:09:12Z"
"","2693","`TestRun` in Vintage omits suppressed exceptions when creating `MultipleFailuresError`","# Overview  Thanks to the tip from @DidierLoiseau (see https://github.com/junit-team/junit5/issues/1602#issuecomment-891077168), I have confirmed that the changes made in #1602 should also be applied in `org.junit.vintage.engine.execution.TestRun.getStoredResultOrSuccessful(TestDescriptor)`.  The reason is that `org.junit.internal.runners.model.EachTestNotifier.addMultipleFailureException(MultipleFailureException)` invokes `org.junit.runner.notification.RunNotifier.fireTestFailure(Failure)` for each failure in the supplied `org.junit.runners.model.MultipleFailureException`.  This can happen if you are using the JUnit 4 `ErrorCollector` rule.  ## Deliverables  - [x] Add suppressed exceptions to the `MultipleFailuresError` created in the Vintage `TestRun`.","closed","component: Vintage,","sbrannen","2021-08-17T20:52:40Z","2021-08-18T23:33:11Z"
"","2009","Parameterized Nested Tests","# Expected  **Creating a nested test within a parameterized test in JUnit5.** Perhaps this is a feature request.  There are many conditions for the Android ViewModel using param. tests. I want to organize the tests within the param. test to improve output readability.  ```kotlin     @ExtendWith(InstantExecutorExtension::class)     class ContentViewModelTest {          private fun `FeedLoad`() = Stream.of(             FeedLoadTest(isRealtime = false, feedType = MAIN, timeframe = DAY, lceState = LOADING),             FeedLoadTest(isRealtime = false, feedType = MAIN, timeframe = DAY, lceState = CONTENT))                      @ParameterizedTest         @MethodSource(""FeedLoad"")         fun `Feed Load`(test: FeedLoadTest) {              @Nested             class FeedLoadNestedTest {                 @Test                 fun `all fields are included`() {                     assertThat(4).isEqualTo(2 + 2)                 }                 @Test                 fun `limit parameter`() {                     assertThat(4).isEqualTo(3 + 2)                 }             }             ...         }         data class FeedLoadTest(val isRealtime: Boolean, val feedType: FeedType,                             val timeframe: Timeframe, val lceState: LCE_STATE)     } ```  # Observed  The normal parameterized assertions [not depicted] work as expected. The nested `FeedLoadNestedTest` does not run within the Stream of parameterized `FeedLoad` tests.  [![enter image description here][1]][1]     [1]: https://i.stack.imgur.com/YU8MI.png","closed","theme: parameterized tests,","AdamSHurwitz","2019-09-13T22:57:35Z","2019-09-17T07:54:10Z"
"","2327","Parameterized Test - 'Cannot invoke non-static method' in @MethodSource with Kotlin","# Expect  Convert a standard JUnit 5 test into a parameterized test in order to iterate through a stream of test cases using the `@ParamterizedTest` and `@MethodSource` annotations in Kotlin.  # Observe  The `@MethodSource` is unable to access the stream of data. This seems to be an issue with this annotation specifically, as `@ValueSource(strings = [""SF"", ""NYC""])` iterates through the statically defined options as expected.   Error:  > PreconditionViolationException: Cannot invoke non-static method {someMethodName} on a null target.  # Implement  The parameterized test is set to pass in a stream of data classes similar to the setup outlined by Phillip Hauer in [Data Classes for Parameterized Tests][1].  ## Code *build.gradle (:SomeProject)*  ```groovy dependencies {     ...         classpath(""de.mannodermaus.gradle.plugins:android-junit5:$junit5_version"") } ```  *build.gradle (:someModule)*  ```groovy apply plugin: ""de.mannodermaus.android-junit5"" android {     ...     compileOptions.targetCompatibility = JavaVersion.VERSION_1_8     kotlinOptions.jvmTarget = ""1.8"" } dependencies {     testImplementation ""org.junit.jupiter:junit-jupiter-api:5.6.2""     testRuntimeOnly ""org.junit.jupiter:junit-jupiter-engine:5.6.2""     testImplementation ""org.junit.jupiter:junit-jupiter-params:5.6.2"" } ```  *SomeTest.kt*  ```Kotlin class SomeTest {     private val testDispatcher = TestCoroutineDispatcher()      private fun someDataStates() = Stream.of(         // Kotlin data class         TestState(""123""),         TestState(""345"")     )      @ParameterizedTest     @MethodSource(""someDataStates"")     fun someTest(testState: TestState) = testDispatcher.runBlockingTest {         // Test state here.         ...     } } ```  ## Build environment - Android Studio 4.0 - Build #AI-193.6911.18.40.6514223, built on May 20, 2020 - Runtime version: 1.8.0_242-release-1644-b3-6222593 x86_64 - VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o - macOS 10.15.5 - GC: ParNew, ConcurrentMarkSweep - Memory: 1979M - Cores: 16 - Registry: ide.new.welcome.screen.force=true - Non-Bundled Plugins: cn.wjdghd.unique.plugin.id, com.android.tool.sizereduction.plugin, com.developerphil.adbidea, com.thoughtworks.gauge, mobi.hsz.idea.gitignore  #Attempted solutions  ## 1. Refactor test case data states to a top-level function.  *TestCases.kt*  ```kotlin fun someDataStates() = Stream.of(     TestState(""123""),     TestState(""345"") ) ```  *SomeTest.kt*  ```kotlin private fun SomeDataStates() = someDataStates()  @ParameterizedTest @MethodSource(""SomeDataStates"") fun someTest(testState: TestState) = testDispatcher.runBlockingTest {    // Test state here.    ...     } ```  ## 2. Refactor test case data states to a top-level function of type `List` instead of `Stream`.  ```kotlin fun someDataStates() = listOf(     TestState(""123""),     TestState(""345"") ) ```   # Full error log  > org.junit.platform.commons.PreconditionViolationException: Cannot invoke non-static method [private final {someMethodName} on a null target. >   at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:296)    at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:682) 	at org.junit.jupiter.params.provider.MethodArgumentsProvider.lambda$provideArguments$1(MethodArgumentsProvider.java:46) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485) 	at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:106) 	at org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor.execute(TestTemplateTestDescriptor.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) 	Suppressed: org.junit.platform.commons.PreconditionViolationException: Configuration error: You must configure at least one set of arguments for this @ParameterizedTest 		at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:281) 		at org.junit.jupiter.params.ParameterizedTestExtension.lambda$provideTestTemplateInvocationContexts$6(ParameterizedTestExtension.java:90) 		at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323) 		at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:279) 		... 49 more >Process finished with exit code 255     [1]: https://phauer.com/2018/best-practices-unit-testing-kotlin/#data-classes-for-parameterized-tests","closed","theme: parameterized tests,","AdamSHurwitz","2020-06-16T01:30:44Z","2020-06-28T04:14:41Z"
"","2406","Build JUnit 5 with JDK 15","# Build JUnit 5 with JDK 15  ## Deliverables  - [x] Require [JDK 15](https://jdk.java.net/15) in JUnit's build configuration - [x] Upgrade to [Gradle 6.7](https://docs.gradle.org/6.7-rc-1/release-notes.html) - [x] Upgrade ""cross version"" build enviroment https://github.com/junit-team/build-env/issues/2 - [x] Update https://github.com/junit-team/junit5/blob/main/.github/workflows/cross-version.yml - [x] Check plugins still work - [x] Check IDE integration - [x] Cleanup build configuration - [x] Use Text Blocks in test code","closed","theme: modules,","sormuras","2020-09-15T04:24:09Z","2020-10-11T07:26:28Z"
"","2575","JDK 16 Records for Tests not working","# Actual behaviour Using JDK 16 records within a test:  ## First Test Case If you define a test class (record) like this: ```java record RecordTest() {    @Nested   record F2() {      @Test     @DisplayName(""Record F2:test1"")     void test_1() {       assertThat(true).isTrue();     }    }    @Nested   record F1() {      @Test     @DisplayName(""Record F1:test1"")     void test_1() {       assertThat(true).isTrue();     }      @Test     @DisplayName(""Record F1:test2"")     void test_2() {       assertThat(true).isTrue();     }   }  } ``` ## Second Test Case  ```java package com.soebes.kata.fraction;  import static org.assertj.core.api.Assertions.assertThat;  import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test;  class ClassTest {    @Nested   record F2() {      @Test     @DisplayName(""Record F2:test1"")     void test_1() {       assertThat(true).isTrue();     }    }    @Nested   record F1() {      @Test     @DisplayName(""Record F1:test1"")     void test_1() {       assertThat(true).isTrue();     }      @Test     @DisplayName(""Record F1:test2"")     void test_2() {       assertThat(true).isTrue();     }   }  } ```  In both cases neither within the IDE (IntelliJ) nor with the build tool (Maven / maven-surefire-plugin) identifies the test cases and execute them.  The IDE shows the so called ""gutter icon"" that you can execute the tests within the class but the result is simply: `No tests were found`.  ## Expected Behaviour  My opinion is that both cases `ClassTest` as well as `RecordTest` should execute all Test cases (methods).  ## Steps to reproduce  I have created a minimal project with the different class/record setup's for reproducing it ...  https://github.com/khmarbaise/junit-jupiter-record-issue  Using the `RecordWithoutNestedTest` you can execute the tests from `F2` via IDE and for the class `UsualWithoutNestedTest` you can not even execute the tests from within the IDE. But those case are correct because both record/class do not contain `@Nested` annotation to make junit jupiter aware of tests within the local classes/records.  The class `UsualTest` will execute the tests as expected. That will work from IDE as well as from Maven (cli).  Apart from above there can be observed a very interesting behaviour: If you start the tests based on the package `com.soebes.junit.jupiter.record` via IDE Ctrl-Shift-R(MAC) / Ctrl-Shift-F10(Windows) you will get the following output:  ![Screenshot 2021-03-18 at 22 37 29](https://user-images.githubusercontent.com/42484/111701309-eff19600-883a-11eb-9a99-2d51cfaf5fb3.png)  which shows a completely different behaviour.  ## Context  - Using JUnit Jupiter 5.7.1 / 5.8.0-M1 - Using Maven 3.6.3 as well as IntelliJ IDE (2020.3.2)  ``` Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: /Users/khmarbaise/tools/maven Java version: 16, vendor: Oracle Corporation, runtime: /Users/khmarbaise/.sdkman/candidates/java/16-open Default locale: en_GB, platform encoding: UTF-8 OS name: ""mac os x"", version: ""10.14.6"", arch: ""x86_64"", family: ""mac"" ```","closed","theme: discovery,","khmarbaise","2021-03-18T21:42:59Z","2021-03-19T08:40:52Z"
"","2332","How to add testcase description in junit xml.","![image](https://user-images.githubusercontent.com/58168151/85106095-3fae1d00-b229-11ea-9d48-05d0f3b3ef75.png)   We need to add multi-line description with scenario so that we get it in junit xml but it seems junit is not supporting description in junit xml currently.","closed","theme: reporting,","rgaikwad008","2020-06-19T07:06:43Z","2020-06-22T15:20:57Z"
"","2452","@ParameterizedTest display custom names for arguments","When using `@ParamerizedTest` annotation, will it be possible to display a string other than what is supplied by toString()? When we are using some big objects the toString value is very large and displays lots of informations which are not relevant  It would be helpful if we can give provision to * display some parameter on the argument like `{0.shortName}` or `{0.route.origin}` etc * Provide another class name which will generate the string to display for each argument  ## Deliverables Provision to customise the name of the arguments in `@ParamerizedTest`","closed","theme: parameterized tests,","SarathBabu","2020-10-18T03:48:40Z","2020-10-19T08:20:29Z"
"","2989","Execution of a third-level Nested class only executes methods of the top-level class","When trying to launch a third-level @Nested class (a class inside a class inside the top-level class) using Maven, it only executes the children methods of that top-level class and ignores everything else.  In this case, the execution logs show only two tests executed. The XML report contains these two testcase tags.  ## Steps to reproduce  The command I used to run the test: `mvn test -Dtest=""com.baeldung.junit5.nested.TestingAStackDemo$WhenNew$afterPushing""`  The class:  [TestingAStackDemo.java.txt](https://github.com/junit-team/junit5/files/9198692/TestingAStackDemo.java.txt)  ## Context   - Used versions: JUnit Jupiter 5.8.2  - Build Tool: Maven 3.8.6  - JDK:      - java 11.0.13 2021-10-19 LTS      - Java(TM) SE Runtime Environment 18.9 (build 11.0.13+10-LTS-370)      - Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.13+10-LTS-370, mixed mode)  - IDE: IntelliJ IDEA 2021.2.4 (Ultimate Edition)   ## Deliverables  The execution logs: [execution_log.txt](https://github.com/junit-team/junit5/files/9198707/execution_log.txt)  The report: [TEST-com.baeldung.junit5.nested.TestingAStackDemo.xml.txt](https://github.com/junit-team/junit5/files/9198717/TEST-com.baeldung.junit5.nested.TestingAStackDemo.xml.txt)","open","status: new,","tru3v0r","2022-07-27T12:36:04Z","2022-08-01T11:56:41Z"
"","2550","Inconsistent @TempDir behaviour","The `@TempDir` behaves differently if a non-test level resource is annotated than a test-level.  If I annotate an attribute or static field in my test than the annotated parameter will be same as the field. This is true for `@BeforeAll` and `@BeforeEach` method as well. ```java public class SameTempDirTest {   @TempDir   public Path attribute;    @Test   public void test1(@TempDir Path parameter) {     assertEquals(attribute, parameter);   }    @Test   public void test2(@TempDir Path parameter) {     assertEquals(attribute, parameter);   } } ```  However if I only annotate the test method parameters than they will be different. ```java public class DifferentTempDirTest {   private Path otherParameter;    @Test   public void test1(@TempDir Path parameter) {     if (otherParameter == null) {       otherParameter = parameter;     } else {       assertNotEquals(otherParameter, parameter);     }   }    @Test   public void test2(@TempDir Path parameter) {     if (otherParameter == null) {       otherParameter = parameter;     } else {       assertNotEquals(otherParameter, parameter);     }   } }  ```  This is an inconsistent behavior which could cause issues. One potential problem when I already have multiple test methods annotated with `@TempDir` and for some reason I want to use `@BeforeAll` with a `@TempDir` which will result all of the previously different temp dirs to be the same.  ## Steps to reproduce The [inconsistent-tempdir.zip](https://github.com/junit-team/junit5/files/5964361/inconsistent-tempdir.zip) file contains a maven project with the two test classes.  ## Context   - Used versions Jupiter 5.7.0  - Build Tool/IDE: Maven, Intellij IDEA (same result in both)  ## Deliverables - [ ] Option 1: Consistent way of working for normal tests and tests created by `TestFactory` like `ParameterizedTest`. - [ ] Option 2: Show an error if test and higher level `@TempDir` annotations present. - [ ] Option 3: A more detailed configuration like in #1967 - [ ] The #2219 is similar issue but for multiple annotations on same level.","closed","component: Jupiter,","gebezs","2021-02-11T10:21:19Z","2021-05-29T12:08:11Z"
"","2335","Parametrized CSV tests do not accept integer literals with underscore ""_""","Relates to JUnit 5.6.2  JUnit 5 does not allow using integer literals with underscore in the CSV parameters of parameterized tests.   Such literals are valid as described in https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html (Using Underscore Characters in Numeric Literals.)  ## Steps to reproduce   ```java     @ParameterizedTest(name = ""Testing Divisors.gcd ({0}, {1} -> {2})"")     @CsvSource({         ""-2_147_483_648, 400, 16"",     })     void testDivisors_gcd(int input1, int input2, int output) {         assertEquals(output, Divisors.gcd(input1, input2));     } ``` It triggers the following error: ``` Error converting parameter at index 0: Failed to convert String ""-2_147_483_648"" to type java.lang.Integer ``` ## Context   - Used versions (Jupiter/Vintage/Platform): NA  - Build Tool/IDE: Sublime  ## Deliverables  - [ ] NA  Thank you!","closed","theme: parameterized tests,","SvitlanaMo","2020-06-21T19:46:42Z","2020-12-24T06:46:32Z"
"","2192","Clearly document that `name` attribute of `@ParameterizedTest` is a `MessageFormat` pattern","junit 5.5.2  ## Steps to reproduce    @ValueSource(ints = { -1, 1 }) @ParameterizedTest(name = ""don't message {0}"") void myTest(int value) {}  The pling in the name string courses the test name to be formatted wrong. The result is ""dont message {0}""  Removing the pling results in: ""dont message -1"" and ""dont message 1""  ## Context   - Used versions (Jupiter/Vintage/Platform):  - Build Tool/IDE:","closed","component: Jupiter,","kec2","2020-02-21T11:24:32Z","2020-04-17T11:03:56Z"
"","2178","Test not failing if BeforeAll crashes","Junit 5.4.2 and 5.6.0 Attached a failing example  Rationale expected: If a BeforeAll method crashes, the test should be reported as failed  Actual Tests are silently ignored and the result is success.  ## Steps to reproduce Create a maven project with Junit 5 as test runner Create a test with a BeforeAll method which throws an RuntimeException See that the tests passes. Example below ``` [INFO] --- maven-surefire-plugin:3.0.0-M4:test (default-test) @ junit_fail --- [INFO]  [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running junit_fail.JunitFailTest [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 s - in junit_fail.JunitFailTest [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  ```  ``` import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertTrue;  public class JunitFailTest {          @BeforeAll     public static void setUp () {         throw new RuntimeException(""Should be noted"");     }      @Test     public void test1() {         assertTrue(false);     }     @Test     public void test2() {         assertTrue(true);     } } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.6.0//1.6.0  - Build Tool/IDE: Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) openjdk 11.0.6 2020-01-14 OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.6+10) OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.6+10, mixed mode) and openjdk version ""1.8.0_242"" OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_242-b08) OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.242-b08, mixed mode)  ## Deliverables  - [x] ...  [junit_fail.zip](https://github.com/junit-team/junit5/files/4180208/junit_fail.zip)","closed","3rd-party: Maven Surefire,","hheg","2020-02-10T10:46:24Z","2020-11-06T11:40:22Z"
"","2838","Suite crashes with JUnitException when a test engine in it is filtered out","If a suite contains test classes running with different test engines and one of the test engines is filtered out by a `PostDiscoveryFilter`, a JUnitException is thrown and no test is executed.  ## Steps to reproduce    Suppose we have the following four classes. ```java public class ExcludedTestClass {      @org.junit.jupiter.api.Test     public void test() {     } } ```  ```java public class IncludedTestClass {      @org.junit.Test     public void aTest() {     } } ```  ```java import org.junit.platform.suite.api.SelectClasses; import org.junit.platform.suite.api.Suite;  @Suite @SelectClasses({ ExcludedTestClass.class, IncludedTestClass.class}) public class SuiteClass {  } ```  ```java import org.junit.platform.engine.FilterResult; import org.junit.platform.engine.TestDescriptor; import org.junit.platform.engine.support.descriptor.MethodSource; import org.junit.platform.launcher.PostDiscoveryFilter;  public class Filter implements PostDiscoveryFilter {      @Override     public FilterResult apply(TestDescriptor object) {         if (object.getSource().isPresent() && object.getSource().get() instanceof MethodSource)             if (((MethodSource) object.getSource().get()).getJavaMethod().getName().startsWith(""test"")) {                 return FilterResult.excluded(null);             }         return FilterResult.included(null);     }  } ```  The class `Filter` is registered as a `PostDiscoveryFilter`. When `SuiteClass` is executed, the test method `IncludedTestClass#aTest` should be executed. Instead, a `JUnitException` is thrown and no test is executed.   The reason is that after filtering, the field `launcherDiscoveryResult` of the `SuiteTestDescriptor` still contains the `JupiterEngineDescriptor`, which should not be executed because all of its children were filtered out. Therefore, the `execute` method in the `EngineExecutionOrchestrator` tries to execute this empty `EngineDescriptor`, which leads to the `JUnitException`.  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.8.2, Vintage 5.8.2, Platform 1.8.2  - Build Tool/IDE: Eclipse","closed","theme: suites,","D4nielLa","2022-03-01T16:21:09Z","2022-05-15T17:53:17Z"
"","2850","Provide information about parameterized test iteration in related descriptor","Hello, everyone. Hope, ill find a solution, but it seems, that current `PostDiscoveryFilter` implementation does not provide filtering parameterized test's iteration  Goal:  Its said, that `PostDiscoveryFilter` is used for customisation of test tree   I want to exclude (not just skip, like `ExecutionCondition`) an iteration of parameterized test. Contract of filter says that i need to manipulate on incoming descriptor  Here is a test:  ```@TestInstance(TestInstance.Lifecycle.PER_CLASS) class SomeTest {        @ParameterizedTest(name = ""ohh my gosh"")       @ValueSource(ints = [1,2,3])       fun params(value: Int) {           assert(value == 1)       } } ``` So, there are 2 failed iterations with unique ID's  ``` [engine:junit-jupiter]/[class:org.example.SomeTest]/[test-template:params(int)]/[test-template-invocation:#2] [engine:junit-jupiter]/[class:org.example.SomeTest]/[test-template:params(int)]/[test-template-invocation:#3] ```  I want to implement a Filter, that will work with some conditions and disable tests, that not matches these unique ID's  But `PostDiscoveryFilter` receives `TestTemplateTestDescriptor` instance only with ID, that does not contain unique ID's of iterations above: `[engine:junit-jupiter]/[class:org.example.SomeTest]/[test-template:params(int)]`  Please, explain me, or add a better context of PostDiscoveryFilter's process.  Can we implement ""smart"" descriptors for test-template/parameterized tests?  ## My Environment - kotlin 1.6 (with JDK 17) - JUnit5 5.8.2","open","status: waiting-for-feedback,","toolateitsme","2022-03-14T10:04:31Z","2022-06-03T11:47:23Z"
"","2652","assertEquals behavior with Int, Long looks inconsistency in Kotlin","Bug report for JUnit 5 jupiter API  ## Steps to reproduce  ```kotlin internal class ExampleTest {      private fun exampleInt(): Int = 1      private fun exampleLong(): Long = 1L  	     @Test     fun test1() {         // success         assertEquals(1, exampleLong())     }      @Test     fun test2() {         // fail: expected: java.lang.Long@30a3e2da<1> but was: java.lang.Integer@50fc3976<1>         assertEquals(1L, exampleInt())     } } ```    ## Context   - Used versions (Jupiter/Vintage/Platform): ```     // Gradle Kotlin DSL     testImplementation(platform(""org.junit:junit-bom:5.7.2""))     testImplementation(""org.junit.jupiter:junit-jupiter"")  tasks {     withType {         useJUnitPlatform()     } }  ```  - Build Tool/IDE:    - JDK 16    - Intellij  ## Deliverables  - [ ] ...","closed","component: Kotlin,","hojongs","2021-06-27T13:49:57Z","2021-07-05T14:00:57Z"
"","2154","Method `Assertions.assertThrows(expectedType, executable, message)` doesn't check the contents of the exception message.","**JUnit Version:** 5.4.0  **For this unit test**  ``` @Test public void verifyErrorMessageWhenBranchCannotBeFound() {         given(restTemplate.getForObject(any(), any(), (Object) any())).willThrow(NotFoundException.class);          assertThrows(NotFoundException.class, () -> testInstance.retrieveBranchDetails(""3001""),                 ""I don't think this error messaging thing checker works""); } ```  **Testing this code** ```  public BranchDetailsResponse retrieveBranchDetails(String branchNumber) {         try {             return restTemplate.getForObject(url, BranchDetailsResponse.class, branchNumber);         } catch (HttpStatusCodeException e) {             throw new NotFoundException("""");         }    } ```  I expect that the test will fail as the error message passed to the `assertThrows` method does not match the error message that is returned from the thrown exception.   I believe the offending piece of code is here in the class `AssertThrows.java`  ``` @SuppressWarnings(""unchecked"") private static  T assertThrows(Class expectedType, Executable executable, 	Object messageOrSupplier) { 	try { 		executable.execute(); 	} 	catch (Throwable actualException) {                 // This part here just returns so long as the two exceptions match without checking the messages 		if (expectedType.isInstance(actualException)) { 			return (T) actualException; 		} 		else { 			BlacklistedExceptions.rethrowIfBlacklisted(actualException); 			String message = buildPrefix(nullSafeGet(messageOrSupplier)) 					+ format(expectedType, actualException.getClass(), ""Unexpected exception type thrown""); 			throw new AssertionFailedError(message, actualException); 		} 	}  	String message = buildPrefix(nullSafeGet(messageOrSupplier)) 			+ String.format(""Expected %s to be thrown, but nothing was thrown."", getCanonicalName(expectedType)); 	throw new AssertionFailedError(message); } ```  The if statement which is bolded will return the actualException if it matches the expectedException but nowhere does it do any message error checking.","closed","component: Jupiter,","borisilic","2020-01-16T07:20:09Z","2020-11-19T04:35:03Z"
"","2429","Provide a platform hook for agents","While discussing [Sarek](https://github.com/SarekTest/Sarek/) with @kriegaex we discovered the need to initialize the Sarek agent was soon as possible. Right now, it uses a Jupiter/Spock extension to load, but as the Platform can execute multiple engines it would be possible for other engines to run earlier and load classes, that then couldn't be ""unfinalized"" by the agent.  A platform level hook that would run as early as possible would be the best solution, so that users wouldn't have to manually call the java executable with javaagent arguments.  ## Deliverables  - [ ] ServiceLoader interface to initialize Agents, could be as simple as `interface AgentLoader { void install(); }` this should be calles as early as possible","closed","component: Platform,","leonard84","2020-09-28T13:08:58Z","2021-02-11T11:37:15Z"
"","2673","Typesafe mechanism for storing and retrieving extension state","When writing extensions, typically I will be storing objects of a particular type.  To put the object in, I will be writing, let's say,  ```java     private final String KEY = ""..."";     List value = ImmutableList.of(1, 2, 3);     store.put(KEY, value); ```  To get it back out, I will be writing,  ```java     List value = (List) store.get(KEY); ```  This issues an unsafe cast warning that I have to suppress.  While the warning is annoying, I don't think it's the thing I want to address. Rather, I wondered whether JUnit has considered that the key can automatically carry the type information wanted for the value.  Consider a design like this:  ```java     public class StoreKey {         private final String name;         private final TypeToken valueType;         private Key(String name, TypeToken valueType) {             this.name = name;             this.valueClass = valueClass;         }         public static  StoreKey of(String name, TypeToken valueType) {             return StoreKey<>(name, valueType);         }         public TypeToken getValueType() {             return valueType;         }         @Override         public String toString() {             return name;         }     }      public interface Store {         // ...         public  void put(Key key, V value);         public  V get(Key key);     } ```  The `TypeToken` I refer to is a common utility class found in a few other libraries but I'm guessing to reduce dependencies it would be neatest to clone something similar in JUnit. You could of course have overloads taking just Class for the simpler cases.  Putting the values in looks more or less the same, but I'm essentially declaring the type up-front:  ```java     private final String KEY = StoreKey.of(""..."", new TypeToken>(){});     List value = ImmutableList.of(1, 2, 3);     store.put(KEY, value); ```  But to get it back out, now I only have to write:  ```java     List value = store.get(KEY); ```  ## Deliverables  [ ] ?","open","status: new,","hakanai","2021-07-27T01:20:48Z","2021-11-01T15:45:52Z"
"","2259","ConsoleLauncher: warn when using --select-class with a class that is not accepted by the --include-classname rules","When using the ConsoleLauncher to execute tests in a class FirstTesterMon.java, selected by the option --select-class, no tests were found. This is correct, as I had not specified any --include-classname nonstandard rule.   However, it would have been really helpful to get a warning message in the style of: WARNING: you have specified to scan a class FirstTesterMon; however this class will NOT be scanned due to the rules for classname scanning. Consider specifying a --include-classname rule.  Or alternatively, and perhaps more sane: if a class is specified using --select-class always scan it even if the name does not match the --include-classname rules.","closed","component: Platform,","fredlund","2020-04-15T21:04:07Z","2020-05-02T15:53:27Z"
"","2952","java.nio.file.FileSystemAlreadyExistsException during test discovery","When using JUnit 5 (and also 4) with version `1.8.2` for the launcher and `5.8.2` for `jupiter` I have been observing the presence of the following warning: `WARNING: Error scanning files for URI jar: ...` followed immediately by `java.nio.file.FileSystemAlreadyExistsException` emitted from the JUnit code `jdk.zipfs/jdk.nio.zipfs.ZipFileSystemProvider.newFileSystem(ZipFileSystemProvider.java:102)` at `org.junit.platform.commons.util.CloseablePath.createForJarFileSystem(CloseablePath.java:57)`.   I am making a program to run a suite of JUnit tests across multiple threads, and using the JUnit launcher to perform test execution. I suspect this issue is caused by the JUnit `.exectue()` method running test discovery each time I invoke the method, which causes a race condition on the java filesystem object that JUnit creates. For reference, I believe that this class is not thread safe https://github.com/junit-team/junit5/blob/main/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CloseablePath.java. I expect JUnit to produce no warnings when I execute tests across threads.    Since JUnit no longer supports performing test discovery once for multiple executions (which is ideal for my use case), I am forced to perform repeated test discovery each time I invoke the JUnit launcher. Moreover, it seems that the decision to repeatedly do test discovery on each execution was made by JUnit recently https://github.com/junit-team/junit5/issues/2379.   The environment I run my program in requires the tests to be in `.jar` files. When the tests are not in a `.jar` file the error coming from `ZipFileSystemProvider` does not happen.   ## Steps to reproduce  I created a simple program https://github.com/oscargolding/junit-load-test that shows the presence of the bug.   To reproduce the warning clone the project then run the following commands.  First build the project and get the resulting `.jar` file. Then place the file into a relevant directory (I picked `/tmp/1/lib`).  ``` $ ./gradlew build $ mkdir -p /tmp/1/lib $ cp ./build/distributions/junit-load-tst-1.0-SNAPSHOT.jar /tmp/1/lib/ ```  Then copy all the junit dependency `.jar` files (listed below) that are cached under the directory `~/.gradle/` into `/tmp/1/lib/`.   ``` junit-jupiter-api-5.8.2.jar junit-jupiter-engine-5.8.2.jar junit-platform-commons-1.8.2.jar junit-platform-engine-1.8.2.jar junit-platform-launcher-1.8.2.jar junit-platform-runner-1.8.2.jar junit-platform-suite-api-1.8.2.jar junit-platform-suite-commons-1.8.2.jar ```  Finally run the commands below to reproduce the warning.   ``` $ cd /tmp/1 $ java -cp ""./lib/*"" ""org.example.Main"" ```    ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.2  - Build Tool/IDE: Gradle, Java 11  ## Deliverables  - [ ] ...","closed","theme: discovery,","oscargolding","2022-06-22T06:35:35Z","2022-06-28T10:36:46Z"
"","2648","`CloneNotSupportedException` when running a certain Unit Test using AdoptOpenJDK 16, `junit-vintage-engine` and PowerMock","When running a certain Unit Test using `PowerMock` and `Junit-Vintage` on Java 16 (AdoptOpenJDK 16), the test fails to intialize due to Java 16's new reflection policies. I have linked the Unit Test and stacktrace below, let me know if you need any further information :)  ## Steps to reproduce    1. Install AdoptOpenJDK 16 2. Clone the repository `https://github.com/mcMMO-Dev/mcMMO` 3. Run `mvn clean package` (or any other command which executes the `test` goal) 4. Witness how `ChunkStoreTest.java` fails to initialize  The issue was discovered on this repository:  https://github.com/mcMMO-Dev/mcMMO  Here is the project's `pom.xml`: https://github.com/mcMMO-Dev/mcMMO/blob/master/pom.xml  Here is the Unit Test which fails to initialize: https://github.com/mcMMO-Dev/mcMMO/blob/master/src/test/java/com/gmail/nossr50/util/blockmeta/ChunkStoreTest.java  And the full stacktrace: https://pastebin.com/7DBVLmEZ  I updated the Unit Test from `Junit-Vintage` to `Junit5-Jupiter` (and from `PowerMock` to `Mockito`) and it seems to completely resolve the issue, but I decided to still raise an issue here in case this is somehow be able to be fixed nonetheless.  ## Context   - Used JDK: AdoptOpenJDK 16 - `16.0.1+9 64-bit 2021-04-20`  - Used versions: `org.junit.vintage:junit-vintage-engine:5.6.2` (also tested on `5.8.0-M1`)  - Build Tool: Maven (`mvn clean package`)  ## Deliverables Not quite sure what is needed here :/","closed","status: new,","TheBusyBiscuit","2021-06-20T13:48:39Z","2021-06-20T19:37:25Z"
"","2411","Introduce communication link between test engine and platform extensions","We have a TestExecutionListener implementation that collects base information about tests, and for some of the engines, we have additional extensions that enrich that information with engine-specific data, for example for Jupiter we catch fixtures execution using InvocationInterceptor.   Our TestExecutionListener holds the state and we need to send data from InvocationInterceptor to our TestExecutionListener. The only option available so far is to publish report entries using ExtensionContext#publishReportEntry method and process these entries in TestExecutionListener#reportingEntryPublished method. And all that smell bad  The current issues:  1) In some cases report entries are published to system out 1) Users may use report entries on it's general-purpose -- to enrich tests with some data.   So users got spammed by our internal communication.  Jupiter API exposes ExtensionContext.Store that can be used to share data between Jupiter extensions. The solution I have in mind is to add a similar API to the platform level and expose this API for the engines. In that way the engines can support such API in their extensions to build a communication link between platform and engine extensions","closed","type: new feature,","baev","2020-09-18T12:56:12Z","2020-10-23T10:39:01Z"
"","2938","Hook before timeout exception is started by calling interrupt()","The problem: When having sporadic timeout exceptions, it is hard to tell from the stacktrace where the code was hanging.  A debugger might not be available (sporadic, on build system) Also the stackdump of other threads might be very helpful, because the timeout might be caused by other threads activity or dead lock.  An own extension seems to be not reasonable, as the timeout control also from maven, is part of the infrastructure.  ## Deliverables  - Either have a hook, that gets called before the `thread.interrupt()` is called in org.junit.jupiter.engine.extension.TimeoutInvocation.InterruptTask.run(). - Or have a way to activate collecting a stackdump of all threads (just before calling interrupt() as above) and put it into the TimeoutException. - Or have collected stackdumps of all threads as information always in the TimeoutException","open","status: new,","frankbenoit","2022-06-07T09:23:15Z","2022-07-30T11:39:57Z"
"","2235","allow @CsvSource and or @MethodSource on @Before Methods or test class ctor","Tests are best when they are focused and have only one assert and little distracting details. Interpreting test data certainly if that need some conversion before use, such as using the test data to prime a mockito.mock is an effort that must be done in each test method, unless the priming can be delegated to the test class constructor or a @BeforeEach method. When all data interpretation is done in the ctor or before method, the test method would be parameterless, a.k.a. a normal non-parameterized test and there needs to be only the verify or assert.  In my use case, if use a key to lambda map to be able to put say triggers or actions (functions, suppliers or consumers) in a csv file. like map.put(""insertCoin"", (ctx,state)-> cts.insertCoin(state);   ## Deliverables Allow @MethodSource and @CsvSource etc on constructor and @Beforeeach method.  - [ ] ...","closed","theme: parameterized tests,","homberghp","2020-04-03T10:35:05Z","2020-04-04T13:19:25Z"
"","2269","Invalid XML report created","tested with: 1.5.1, 1.6.2, 1.7.0-M1  ## Steps to reproduce  TestAscii.java ```java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*;  public class TestAscii {     @Test     void testAsciiZero() {         assertEquals(""A"", ""B\0"");     } } ```  ```sh VER=1.7.0-M1  javac -encoding UTF-8 -d . -cp .:junit-platform-console-standalone-${VER}.jar TestAscii.java java -jar junit-platform-console-standalone-${VER}.jar -cp=. --details=summary  --reports-dir=. --scan-class-path ```  The '\0' ist copied to the failure message in the xml report   try any xml tool, e.g. ``` xmllint TEST-junit-jupiter.xml  TEST-junit-jupiter.xml:57: parser error : Char 0x0 out of allowed range  but was:                closedcomponent: Platform,                 AugustH                2020-04-23T12:53:28Z               2020-05-22T19:52:05Z                                             2268               Console Launcher does not explicitly set [java.class.path] system property when using the [--classpath] option                Hey,  Previously we were using ant junit task and junit4. Many of our tests use `System.getProperty("" java.class.path"")="""" `to="""" pull="""" classpath="""" entries.="""" we="""" have="""" never="""" explicitly="""" passed="""" `""java.class.path""`="""" in="""" the="""" ant="""" junit="""" task.="""" obviously,="""" underlying="""" runner="""" is="""" automatically="""" doing="""" it="""" by="""" putting="""" entries="""" specify="""" `` attribute and this seems valid to me.  Now we are migrating to junit5 and we started using directly the console launcher in the ant java task, where we explicitly pass `–-classpath `option to the launcher. All the test that are using `System.getProperty(""java.class.path"")` are  now failing because the entries we pass in  the `–-classpath `option are not automatically populated in `""java.class.path"" `property.  How can we solve this?   If I additionally add `""java.class.path""` as `sysproperty key` or as `jvmarg value`, the task fails as the command line becomes huge (as I already have the same entries in the `--classpath `option and I cannot remove them as the launcher requires this):  ```  [java] Caused by: java.io.IOException: CreateProcess error=206, The filename or extension is too long      [java]     at java.lang.ProcessImpl.create(Native Method)      [java]     at java.lang.ProcessImpl.(ProcessImpl.java:386)      [java]     at java.lang.ProcessImpl.start(ProcessImpl.java:137)      [java]     at java.lang.ProcessBuilder.start(ProcessBuilder.java:1029) ```   I am using junit-platform-launcher-1.6.0-RC1.jar  And my ant task looks like this:  ```                                                                                                                                                                                                                                                                                                                                                         -->                                                                                                                                                                                               ```","closed","component: Platform,","Vazzilena","2020-04-23T10:43:18Z","2020-04-24T12:25:12Z"
"","2586","Consider default value for @EnabledIfEnvironmentVariable.matches","Sometimes, you want to run a test only if a particular environment variable is present, regardless of its value.  This can be achieved using   ```java @EnabledIfEnvironmentVariable(named = ""VARIABLE"", matches = "".*"") ```  which is a bit verbose.  In the past, this requirement has led to feature requests like https://github.com/junit-team/junit5/issues/1825, asking for a dedicated `@EnabledIfEnvironmentVariableExist` counterpart.  But IMHO, the same could be achieved by adding a default value of `"".*""` or `"".+""` for the `matches` property. Then the following would be legal:  ```java @EnabledIfEnvironmentVariable(named = ""VARIABLE"") ```  AFAICT, this change would not break compatibility; all annotations with the explicit `matches` property would work as before.  ## Deliverables  - [ ] A new version of `@EnabledIfEnvironmentVariable` with a default value for the `matches` property.","closed","component: Jupiter,","sewe","2021-04-06T10:13:50Z","2021-04-09T11:11:06Z"
"","2472","The Gradle test runner's XML report lumps together unrelated @Nested tests under the same test/@classname","Not a 100% sure whether you are responsible for the Gradle test runner and whether the problem is located in the JUnit 5 part of Gradle's `java` plugin, but here is probably a good starting place to file this issue. That being said, feel free to point me to the Gradle project if you think it is their ""fault"".  ## Steps to reproduce  1. Check out the `reproducer` branch from https://github.com/sewe/junit5-samples:     ```sh     git clone https://github.com/sewe/junit5-samples -b reproducer     ``` 2. ```sh     pushd junit5-samples/junit5-jupiter-starter-maven     ./mvnw test     ls target/surefire-reports/TEST-*.xml     ``` 3. This produces a `TEST-*.xml` files for each of the three `Example?Test` classes (which all inherit from a common `BaseClass`). This is **good**. 4. ```sh     popd     pushd junit5-samples/junit5-jupiter-starter-gradle     ./gradlew test     ls build/test-results/test/TEST-*.xml     ``` 5. This produces, in addition to files for each of the three `Example?Test` classes, a file `TEST-com.example.BaseClass$NestedClass.xml` which lumps together the test results of the `@Nested` test inherited from `BaseClass` by both `Example1Test` and `Example2Test`. This is **bad**.    Looking at the XML report you will see two **indistinguishable** test executions (``s in this case, but the problem occurs for succesful tests as well):    ```sh    grep -r failure -B 1 'build/test-results/test/TEST-com.example.BaseClass$NestedClass.xml'    ```  As these two executions are different, the should be communicated as such to upstream tools. But based on `TEST-com.example.BaseClass$NestedClass.xml`, it looks like the **same** test was executed twice.  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit 5.7, as used by `junit5-starter` (https://github.com/sewe/junit5-samples/tree/reproducer)   - Build Tool/IDE:  ```sh ./mvnw --version Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: /home/sewe/.m2/wrapper/dists/apache-maven-3.6.3-bin/1iopthnavndlasol9gbrbg6bf2/apache-maven-3.6.3 Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-8-oracle/jre Default locale: en_CA, platform encoding: UTF-8 OS name: ""linux"", version: ""4.15.0-122-generic"", arch: ""amd64"", family: ""unix"" ```  ```sh ./gradlew --version  ------------------------------------------------------------ Gradle 6.2.2 ------------------------------------------------------------  Build time:   2020-03-04 08:49:31 UTC Revision:     7d0bf6dcb46c143bcc3b7a0fa40a8e5ca28e5856  Kotlin:       1.3.61 Groovy:       2.5.8 Ant:          Apache Ant(TM) version 1.10.7 compiled on September 1 2019 JVM:          1.8.0_201 (Oracle Corporation 25.201-b09) OS:           Linux 4.15.0-122-generic amd64 ```  ## Deliverables  - [ ] Either the reported executions for `@Nested` tests move to `TEST-Example?Test.xml` (as in the Maven case) or they need to become distinguisable in `TEST-com.example.BaseClass$NestedClass.xml` by different `testcase/@classname`s. (https://github.com/junit-team/junit5/issues/2471 might be interesting, when going do the latter route.)","closed","","sewe","2020-11-03T12:59:36Z","2020-11-04T11:56:51Z"
"","2615","Problem finding tests in IntelliJ using Gradle test runner","No idea if this is a IntelliJ, Gradle or JUnit issue.  I've tried with both JUnit 5.4 and 5.7 - same issue.  Ditto for JUnit 4 btw  For a reproducer, this is happening with the Hibernate project (http://github.com/hibernate/hibernate-orm) with the `wip/6.0` branch.  Totally understand if you want a smaller reproducer - let me know.  I played around a little bit to see if I could narrow down possible causes.  It seems like the projects that have multiple test tasks (how we expose testing the different available databases) are the ones experiencing this problem.  That is most of the Java sub-projects.    To reproduce:  1) Set IntelliJ to run tests using Gradle (Settings > Build, Execution, Deployment > Build tools > Gradle : ""Run tests using : Gradle"").  I see the same behavior with ""Chose per test"" 2) Select an individual test class/method from a Java sub-project (e.g. `hibernate-core`) and run or debug it  I expect the tests to run.  IJ fails to find them.  E.g.  ```` Execution failed for task ':documentation:matrix_derby'. > No tests found for given includes: [org.hibernate.userguide.mapping.basic.NationalizedStringMappingTests](filter.includeTestsMatching) ````  As a counter-point, if you use that same IJ set-up and try to do the same with tests in the `hibernate-testing` sub-project, it works fine.  That project has just the one test task.","closed","","sebersole","2021-05-14T10:21:26Z","2021-05-17T17:38:42Z"
"","2563","Filtering by tags prevents Spock specs from being executed.","Neither Spock 1.x nor Spock 2.x support tags, so they should not be affected by a tag filter. Yet it seems they are  ## Steps to reproduce  Update: I was able to spot this in the debugger (somehow the debug output is not printed even when I run gradle with `-d`) ![Screenshot_20210305_175214](https://user-images.githubusercontent.com/2794994/110147304-cfa5ee00-7ddb-11eb-8f6e-927b5f500b6f.png)  I think this clearly shows there is a bug. Tags should not affect other engines than Jupiter.  --  Add some Spock 1.x Specs and have a gradle test task configured as follows:  ```     test {             useJUnitPlatform {                 includeTags(""SomeTag"")                 includeEngines(""junit-vintage"")             }     } ``` Observe specs are not being executed.  If you comment out the line with ""includeTags"" the specs are executed.  I've checked in the debugger that a `RunnerTestDescriptor` with a `Sputnik` runner is being discovered (the Specs are not being skipped/ignored by Spock).  ![Screenshot_20210305_165810](https://user-images.githubusercontent.com/2794994/110143226-4c829900-7dd7-11eb-80a0-baa66fbda3ac.png)   The same happens with Spock 2.x  ```     test {             useJUnitPlatform {                 includeTags(""SomeTag"")                 excludeEngines(""junit-vintage"")             }     } ``` ![Screenshot_20210305_174750](https://user-images.githubusercontent.com/2794994/110146620-12b39180-7ddb-11eb-9c3a-1ca70674d7cd.png)  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.6.3 / 1.6.3  - Build Tool/IDE: gradle 6.8.3  - Spock 1.3-groovy-2.5, 2.0-M2-groovy-2.5","closed","theme: discovery,","jakub-bochenski","2021-03-05T16:38:39Z","2021-03-06T09:26:26Z"
"","2421","BeforeAllCallback called twice when using @Nested test classes","Junit 5.7.0  ## Steps to reproduce  ```kotlin class Ext : BeforeAllCallback, AfterAllCallback {     override fun beforeAll(context: ExtensionContext) = println(""beforeAll"")     override fun afterAll(context: ExtensionContext) = println(""afterAll"") }  @ExtendWith(Ext::class) internal class MainActivityTest {     @org.junit.jupiter.api.Nested     inner class Nested {          @Test         fun beforeAllCalledTwice() {             /** Out put is:             beforeAll             beforeAll                                       afterAll             afterAll              */         }     } } ```  ## Context      def junitVersion = ""5.7.0""     testImplementation(""org.junit.jupiter:junit-jupiter:$junitVersion"")     testCompileOnly('junit:junit:4.13') // To allow running JUnit 4 Tests     testRuntimeOnly(""org.junit.vintage:junit-vintage-engine:$junitVersion"")  AS 4.0.1 Build tools 30.0.2  ## Deliverables  I assume this shouldn't happen and it should only be called once?","closed","component: Jupiter,","OliverCulleyDeLange","2020-09-23T10:16:19Z","2020-10-03T12:33:49Z"
"","2190","Provide ExtensionContext as a default ParameterResolver","Is it possible to have ExtensionContext as part of a default ParameterResolver which could be used in BeforeAll, BeforeEach,  AfterEach, AfterAll methods  I know that we can implement Extension classes for beforeEachCallback and similar methods, however in cases where each test class need small or very specific before and after methods or want to use class elements for their implementation, it doesn't make sense to have classes for the same  Be Aware of another request https://github.com/junit-team/junit5/issues/2191   ## Deliverables  - [ ] ... Be able to resolve ExtensionContext as a default ParameterResolver for Before and After Methods","closed","component: Jupiter,","nishantvas","2020-02-20T10:37:56Z","2020-02-20T10:49:44Z"
"","2567","Document implementation of assertEquals() and assertNotEquals() regarding equals()","I made some tests for the TestNG issue https://github.com/cbeust/testng/issues/2490 and found the same issue on `Assertions.assertNotEquals`.  ## Steps to reproduce   https://github.com/cbeust/testng/issues/2490#issuecomment-798894748  ## Context   - Used versions (Jupiter): 5.7  - Build Tool/IDE: N/A","closed","component: Jupiter,","juherr","2021-03-14T12:06:18Z","2021-06-03T13:39:22Z"
"","2811","@TempDir directory cannot be deleted on Windows with Java 11","I have a test that has been failing on `windows-latest` with Java 11 on GitHub Actions CI, but not on Java 17.  [This is my test](https://github.com/renatoathaydes/jbuild/blob/efc4ee69387c4956b33c0ea9df2085ea7ff3d567/src/intTest/java/tests/FetchTest.java#L64):  ```java     @Test     void canFetchArtifactToSpecificDir(@TempDir File tempDir) throws Exception {         var outputDir = new File(tempDir, ""outDir"");         final var expectedFileLocation = new File(outputDir, ""opentest4j-1.2.0.pom"");         outputDir.deleteOnExit();         expectedFileLocation.deleteOnExit();          var result = runWithIntTestRepo(""fetch"", ""org.opentest4j:opentest4j:1.2.0:pom"",                 ""-d"", outputDir.getPath());         verifySuccessful(""jbuild fetch"", result);          assertThat(result.getStdout()).startsWith(""JBuild success in "");         assertThat(expectedFileLocation).isFile();          try (var stream = new FileInputStream(expectedFileLocation)) {             var pom = MavenUtils.parsePom(stream);             assertThat(pom.getArtifact()).isEqualTo(new Artifact(""org.opentest4j"", ""opentest4j"", ""1.2.0""));         }     } ```  I added those `deleteOnExit` calls to try to ""help"" JUnit to get rid of that temp dir, to no avail.  [Link to GitHub Actions CI Log](https://github.com/renatoathaydes/jbuild/runs/4834144178?check_suite_focus=true) [Link to JUnit report](https://github.com/renatoathaydes/jbuild/runs/4834148435#r2)  The error it shows:  ``` ❌ canFetchArtifactToSpecificDir(File) 	java.io.IOException: Failed to delete temp directory C:\Users\RUNNER~1\AppData\Local\Temp\junit13368809472936183425. The following paths could not be deleted (see suppressed exceptions for details): , outDir, outDir\opentest4j-1.2.0.pom  FetchTest > canFetchArtifactToSpecificDir(File) FAILED     java.io.IOException at TempDirectory.java:262 ```  Notice that this same test passes on Java 11 on MacOS and Linux, and on Java 17 on MacOS, Linux and Windows. It seems to fail very consistently on Java 11/Windows.  ## Steps to reproduce    It should be very easy to reproduce the problem as long as you can run your tests on the specific Windows and Java versions being used by GitHub Actions CI. The code under test will basically just copy a file from one location to another.  Feel free to [fork my project](https://github.com/renatoathaydes/jbuild) to make it easy to run the tests.  GitHub Environment:  ``` Current runner version: '2.286.0' Operating System   Microsoft Windows Server 2019   10.0.17763   Datacenter Virtual Environment   Environment: windows-2019   Version: 20220110.1   Included Software: https://github.com/actions/virtual-environments/blob/win19/20220110.1/images/win/Windows2019-Readme.md   Image Release: https://github.com/actions/virtual-environments/releases/tag/win19%2F20220110.1  Java configuration:   Distribution: zulu   Version: 11.0.13+8   Path: C:\hostedtoolcache\windows\Java_Zulu_jdk\11.0.13-8\x64 ```  ## Context   - Used versions (Jupiter/Vintage/Platform):  ```groovy dependencies {     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'     testImplementation 'org.assertj:assertj-core:3.21.0'     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'      intTestImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'     intTestImplementation 'org.assertj:assertj-core:3.21.0'     intTestRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0' } ```  [Link to build file](https://github.com/renatoathaydes/jbuild/blob/master/build.gradle)   - Build Tool/IDE:  Gradle downloaded from (see the wrapper properties):  ``` distributionUrl=https\://services.gradle.org/distributions/gradle-7.3.3-bin.zip ```","open","status: new,","renatoathaydes","2022-01-16T21:15:04Z","2022-07-15T18:06:57Z"
"","2471","Need alternative to TestInfo.getTestClass for inherited @Nested tests","I have a shared base class with a couple of `@Test` methods (like [this one](https://github.com/sewe/junit5-samples/blob/reproducer/junit5-jupiter-starter-gradle/src/test/java/com/example/BaseClass.java)).  Now suppose the `TestInfo` object injected into the test methods should be used to derive unique, test-specific directory names.  Unfortunately, no combination of `TestInfo.getTestClass()` and `TestInfo.getTestMethod()` does the trick, at least not for `@Nested` tests, as their `TestInfo.getTestClass()` is the base class, not the concrete subclass.  Consider [this reproducer](https://github.com/sewe/junit5-samples/commit/e4d905db390c371aedd3c56495c9c5cc3a84bc8c#diff-a349a9b76e6a99bbcce3b1d8711f2dbabe8c4fe238845e286629a7ea3344e2df) based on [junit5-samples](https://github.com/junit-team/junit5-samples):  ```java abstract class BaseClass {      @Test     void test(TestInfo testInfo) {         String actualName = testInfo.getTestClass().get().getName();         Assertions.assertTrue(actualName.matches(""com.example.Example[123]Test""), actualName);     }      @Nested     class NestedClass {          @Test         void nestedTest(TestInfo testInfo) {             String actualName = testInfo.getTestClass().get().getName();             Assertions.assertTrue(actualName.matches(""com.example.Example[123]Test\\$NestedClass""), actualName);         }     } } ```  ```java class Example1Test extends BaseClass { } ```  ```java class Example2Test extends BaseClass { } ```  While the test class for the two invocations of `BaseClass.test` is `Example1Test` and `Example2Test`, respectively, for the two invocations of `BaseClass.NestedClass.nestedTest` it is in both cases `BaseClass.NestedClass` (making `nestedTest` fail as written). This means that `TestInfo.getTestClass()` is unusable for deriving the name of a test-specific directory.  ``` [INFO] Running com.example.Example1Test [ERROR] Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.001 s <<< FAILURE! - in com.example.Example1Test [ERROR] nestedTest{TestInfo}  Time elapsed: 0.001 s  <<< FAILURE! org.opentest4j.AssertionFailedError: com.example.BaseClass$NestedClass ==> expected:  but was:  	at com.example.BaseClass$NestedClass.nestedTest(BaseClass.java:22)  [INFO] Running com.example.Example2Test [ERROR] Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.025 s <<< FAILURE! - in com.example.Example2Test [ERROR] nestedTest{TestInfo}  Time elapsed: 0.006 s  <<< FAILURE! org.opentest4j.AssertionFailedError: com.example.BaseClass$NestedClass ==> expected:  but was:  	at com.example.BaseClass$NestedClass.nestedTest(BaseClass.java:22) ```  ## Deliverables  I would hence like to see some alternative to `TestInfo.getTestClass()` (`getInvokedClass()` perhaps?), that changes based on the class that is ""invoked"" (for lack of a better name) by the test runner, not the class where the test method ultimately executed resides.  Alternatively, since for non-`@Nested` tests, `getTestClass()` already behaves as expected by me, it's behavior might be (incompatibly) changed for `@Nested` tests.  ## Considered Alternatives  `@TempDir` is unfortunately not an alternative, for two reasons: - The test-specific directories MUST to be created below a specific directory - The directory names SHOULD be human-readable and easily correlatable to the tests; what `@TempDir` produces is too cryptic.","open","component: Jupiter,","sewe","2020-11-03T12:31:45Z","2021-08-15T07:50:32Z"
"","2751","A test class with Java 9+ dependencies can not be disabled with @DisabledOnJre(JRE.JAVA_8)","I have a project that is compiled to Java 8 compatibility. However, there are some test dependencies that no longer support Java 8 but only newer versions (Java 9+).   ```java public class TestWithAJava11Dependency {     @RegisterExtension     public static Java11OnlyExtension = Java11OnlyExtension.instance();      .... } ```  My naive idea was to decorate this with `@DisabledOnJre(JRE.JAVA_8)`. However, when running this code on a Java 8 JRE, it reports  ``` java.lang.UnsupportedClassVersionError: .../Java11OnlyExtension has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 ```  so even though the code itself is compiled to java 8 and it is annotated with ""skip when on java 8"", the class is loaded and fails on Java 8  ## Deliverables  - [ ] Clearly it would be good if the test class could somehow be inspected without the Java 9+ dependencies being loaded by the class loader. I am not sure if that is possible; in any case it would be reasonable to document this clearly.","open","status: waiting-for-feedback,","hgschmie","2021-10-25T01:56:54Z","2021-11-14T15:53:31Z"
"","2092","Generate multiple test instances (with names) from a TestInstanceFactory","I am trying to find a nice way for testclasses to be executed multiple times based on an external configuration. My test classes get configurations for multiple different systems to interact with via system properties. The tests should then be executed for each of these systems without the programmer having to know about the mechanism.  ```java // interface to annotate tests with @ExtendWith(ForEachSystemFactory.class) @interface RunForEachSystem() {} ``` ```java // factory creating test instances class ForEachSystemFactory implements TestInstanceFactory {   // create instances displaynames   @Override   public Map createTestInstances(...) {      buildMap(        ""systemFoo"", ReflectionSupport.newInstance(factoryContent.getTestClass(), ...)        ""systemBar"", ReflectionSupport.newInstance(factoryContent.getTestClass(), ...)      )   } } ```  ```java // test used in examples class SomeTest {   @Test   void testSomething() {} } ```  The end result would be something like this  All tests   * SomeTest     * systemFoo  (as returned by `createTestInstances()`)       * testSomething()     * systemBar       * testSomething()   In theory it would be even nicer to generate the whole suite for each system, but it seems to me this would be much harder to implement.  All tests   * systemFoo     * SomeTest       * testSomething()   * systemBar     * SomeTest       * testSomething()  Unfortunately I can neither change the execution engine nor the way these parameters are passed.  Alternatively it looks like a `@TestTemplate` for test classes would be a good fit.","closed","component: Jupiter,","t-8ch","2019-11-06T16:59:45Z","2019-11-06T17:20:21Z"
"","2577","Intoduce API to add ParameterResolvers through Launcher","I am developing a framework that aims to automate grading by running student submissions together with JUnit tests to assign points and produce a graded rubric. Each submission (sources) jar is compiled at runtime together with the JUnit tests for that submission. These tests are all run in parallel on separate ClassLoaders.  I would like to provide a custom instance of my interface `TestCycle` (which represents a combination of submission classes + test classes). An example usage can be found [here](https://github.com/JagrKt/JagrKt/pull/1). I looked for a way of providing a `ParameterResolver` through the platform launcher but could not find one.  This is the class that runs the JUnit tests for a given submission: [JavaRuntimeTester](https://github.com/JagrKt/JagrKt/blob/feature/code-context/jagrkt-common/src/main/kotlin/org/jagrkt/common/testing/JavaRuntimeTester.kt). Note that `createTestCycle` runs in parallel for all submissions.  ### What I tried  According to https://junit.org/junit5/docs/current/user-guide/#extensions-registration, there are currently three ways of registering ParameterResolvers. Both `@ExtendsWith` and the java ServerLoader are out of the question because they would require some way of accessing the current `TestCycle` from a global context, which is not compatible with parallelization.  The only way I came up with providing my `TestCycle` instance (with the current JUnit API) was during the classloading of the JUnit tests. As each JUnit test class instance is unique to that `TestCycle`, it would potentially be possible to inject a reference to the current `TestCycle` in a static field in the test class and use this reference in the test methods. However, I find this solution relatively ugly and unnecessary considering the `ParameterResolver` system in JUnit.  ### My suggestion  In my opinion, it should be possible to register `ParameterResolver`s programmatically through the `Launcher` somehow.   I launch JUnit like this in my [JavaRuntimeTester](https://github.com/JagrKt/JagrKt/blob/feature/code-context/jagrkt-common/src/main/kotlin/org/jagrkt/common/testing/JavaRuntimeTester.kt):  ```kotlin   private fun List.runJUnit(testCycle: JavaTestCycle): JUnitResultImpl? {     return try {       val launcher = LauncherFactory.create()       val testPlan = launcher.discover(LauncherDiscoveryRequestBuilder.request().selectors(this).build())       val summaryListener = SummaryGeneratingListener()       val statusListener = TestStatusListenerImpl(logger)       launcher.execute(testPlan, summaryListener, statusListener) // <-- inject testCycle here?       JUnitResultImpl(testPlan, summaryListener, statusListener)     } catch (e: Throwable) {       logger.error(""Failed to run JUnit tests for ${testCycle.submission.info}"", e)       null     }   } ```  To use in tests like this:  ```java @Test @DisplayName(""Fib Iterative Correct"") public void fibIterative(TestCycle testCycle) {   JavaMethodContext ctx = ContextResolver.ofJavaMethod(() -> Fibonacci.class.getMethod(""fibIterative"", int.class))     .resolve(testCycle);   assertTrue(ctx.modified()); // ctx.getModifiedSource() != ctx.getOriginalSource()   assertTrue(ctx.getModifiedSource().contains(""for""));   ...additional tests... } ```  To me this seems like the most intuitive way of doing this: I have my `TestCycle` in `runJUnit` and would like to pass it to the methods I am running (indirectly through the launcher).  While I have used JUnit in the past, this is my first time programmatically running tests using the platform launcher. So I am therefore not entirely sure of the best way to approach adding this to the API and am open to discussing alternatives.  (for more info on what the context stuff is, click [here](https://github.com/JagrKt/JagrKt/pull/1))","closed","component: Platform,","alexstaeding","2021-03-19T22:41:34Z","2021-05-20T13:36:47Z"
"","2741","Multiple groups behaving different with same static configuration","Hi folks! I have multiple classes and each class has a different `@Tag` and in case I try to run multiple tags at same time, they are not getting the same Logging configuration, I will give examples bellow, but before that, some details:  JUnit5 jupiter > 5.8.1 JUnit5 runner > 1.8.1  Descriptive example: Given I have two classes, each one with a different @Tag, both classes extends from a parent class that has a static block configuring logs, when I try to run via maven using both tags, each class is behaving differently with Logging.  Code example and how to reproduce:  ```java public class BaseTest {     static {        Logger.getLogger(""org.openqa.selenium"").setLevel(Level.OFF);     } }  @Tag(""finance"") public class FinanceTest extends BaseTest {     @Test     void someFunFinanceTest() {      } }  @Tag(""login"") public class LoginTest extends BaseTest {     @Test     void someFunLoginTest() {      } } ```  When I run: ```sh # Log not as expected, it's not being update to OFF. mvn clean test -Dgroups=finance,login ```  But the commands below works: ```sh # Log as expected, everything from the desired package is OFF mvn clean test -Dgroups=finance # or # Log as expected, everything from the desired package is OFF mvn clean test -Dgroups=login ```  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter  - Build Tool/IDE: N/A","closed","3rd-party: Maven Surefire,","SpencerMelo","2021-10-07T21:31:10Z","2021-10-08T12:07:36Z"
"","2722","junit-vintage-engine:5.8.0 requires junit:junit:{strictly 4.13.2}","Building a project with JUnit 5.8.0 and Jackson 2.12.5 can result in a build failure due to `junit-vintage-engine-5.8.0` strictly requiring `junit:junit:4.13.2`. Jackson 2.12.5's bom manages the version as 4.13.1. I suspect this dependency management should not be present in Jackson's bom and have opened https://github.com/FasterXML/jackson-bom/issues/43, but it's been there for quite some time and this problem only appeared when upgrading to JUnit 5.8.0 from 5.7.  Here's a build scan from building Spring Boot where I originally discovered the problem: https://ge.spring.io/s/xwscy4qijm2w6/failure#1.  ## Steps to reproduce  Here's a much simpler build that should reproduce the problem using Gradle 6.9.1:  ``` plugins { 	id 'java' }  repositories { 	mavenCentral() }  dependencies { 	implementation(enforcedPlatform('com.fasterxml.jackson:jackson-bom:2.12.5')) 	implementation('com.fasterxml.jackson.core:jackson-databind') 	testImplementation('org.junit.vintage:junit-vintage-engine:5.8.0') } ```  ```  ./gradlew dependencyInsight --dependency junit:junit --configuration testCompileClasspath  > Task :dependencyInsight junit:junit:4.13.1 FAILED    Selection reasons:       - By constraint       - Forced    Failures:       - Could not resolve junit:junit:4.13.1.           - Cannot find a version of 'junit:junit' that satisfies the version constraints:                Dependency path ':jackson-bom-junit-5.8-problem:unspecified' --> 'org.junit.vintage:junit-vintage-engine:5.8.0' --> 'junit:junit:{strictly 4.13.2}'                Constraint path ':jackson-bom-junit-5.8-problem:unspecified' --> 'com.fasterxml.jackson:jackson-bom:2.12.5' --> 'junit:junit:4.13.1'                Constraint path ':jackson-bom-junit-5.8-problem:unspecified' --> 'com.fasterxml.jackson.core:jackson-databind:2.12.5' --> 'com.fasterxml.jackson:jackson-bom:2.12.5' --> 'junit:junit:4.13.1'  junit:junit:4.13.1 FAILED \--- com.fasterxml.jackson:jackson-bom:2.12.5      +--- testCompileClasspath      +--- com.fasterxml.jackson.core:jackson-databind:2.12.5      |    +--- testCompileClasspath (requested com.fasterxml.jackson.core:jackson-databind)      |    \--- com.fasterxml.jackson:jackson-bom:2.12.5 (*)      +--- com.fasterxml.jackson.core:jackson-annotations:2.12.5      |    +--- com.fasterxml.jackson.core:jackson-databind:2.12.5 (*)      |    \--- com.fasterxml.jackson:jackson-bom:2.12.5 (*)      \--- com.fasterxml.jackson.core:jackson-core:2.12.5           +--- com.fasterxml.jackson.core:jackson-databind:2.12.5 (*)           \--- com.fasterxml.jackson:jackson-bom:2.12.5 (*)  junit:junit:4.13.2 FAILED    Failures:       - Could not resolve junit:junit:{strictly 4.13.2}. (already reported)  junit:junit:{strictly 4.13.2} -> 4.13.2 FAILED \--- org.junit.vintage:junit-vintage-engine:5.8.0      +--- testCompileClasspath      \--- org.junit:junit-bom:5.8.0           +--- org.junit.platform:junit-platform-engine:1.8.0           |    +--- org.junit:junit-bom:5.8.0 (*)           |    \--- org.junit.vintage:junit-vintage-engine:5.8.0 (*)           +--- org.junit.platform:junit-platform-commons:1.8.0           |    +--- org.junit.platform:junit-platform-engine:1.8.0 (*)           |    \--- org.junit:junit-bom:5.8.0 (*)           \--- org.junit.vintage:junit-vintage-engine:5.8.0 (*)  org.junit:junit-bom:5.8.0    variant ""apiElements"" [       org.gradle.category            = platform       org.gradle.usage               = java-api       org.gradle.status              = release (not requested)        Requested attributes not found in the selected variant:          org.gradle.dependency.bundling = external          org.gradle.libraryelements     = classes          org.gradle.jvm.version         = 11    ]  org.junit:junit-bom:5.8.0 +--- org.junit.platform:junit-platform-commons:1.8.0 |    +--- org.junit.platform:junit-platform-engine:1.8.0 |    |    +--- org.junit:junit-bom:5.8.0 (*) |    |    \--- org.junit.vintage:junit-vintage-engine:5.8.0 |    |         +--- testCompileClasspath |    |         \--- org.junit:junit-bom:5.8.0 (*) |    \--- org.junit:junit-bom:5.8.0 (*) +--- org.junit.platform:junit-platform-engine:1.8.0 (*) \--- org.junit.vintage:junit-vintage-engine:5.8.0 (*)  (*) - dependencies omitted (listed previously)  A web-based, searchable dependency report is available by adding the --scan option.  BUILD SUCCESSFUL in 513ms 1 actionable task: 1 executed ```  If you downgrade `junit-vintage-engine` to 5.7.2 the problem does not occur:  ``` ./gradlew dependencyInsight --dependency junit:junit --configuration testCompileClasspath  > Task :dependencyInsight junit:junit:4.13.1    variant ""compile"" [       org.gradle.status              = release (not requested)       org.gradle.usage               = java-api       org.gradle.libraryelements     = jar (compatible with: classes)       org.gradle.category            = library        Requested attributes not found in the selected variant:          org.gradle.dependency.bundling = external          org.gradle.jvm.version         = 11    ]    Selection reasons:       - By constraint       - Forced  junit:junit:4.13.1 \--- com.fasterxml.jackson:jackson-bom:2.12.5      +--- testCompileClasspath      +--- com.fasterxml.jackson.core:jackson-databind:2.12.5      |    +--- testCompileClasspath (requested com.fasterxml.jackson.core:jackson-databind)      |    \--- com.fasterxml.jackson:jackson-bom:2.12.5 (*)      +--- com.fasterxml.jackson.core:jackson-annotations:2.12.5      |    +--- com.fasterxml.jackson.core:jackson-databind:2.12.5 (*)      |    \--- com.fasterxml.jackson:jackson-bom:2.12.5 (*)      \--- com.fasterxml.jackson.core:jackson-core:2.12.5           +--- com.fasterxml.jackson.core:jackson-databind:2.12.5 (*)           \--- com.fasterxml.jackson:jackson-bom:2.12.5 (*)  junit:junit:4.13 -> 4.13.1 \--- org.junit.vintage:junit-vintage-engine:5.7.2      +--- testCompileClasspath      \--- org.junit:junit-bom:5.7.2           +--- org.junit.platform:junit-platform-engine:1.7.2           |    +--- org.junit:junit-bom:5.7.2 (*)           |    \--- org.junit.vintage:junit-vintage-engine:5.7.2 (*)           +--- org.junit.platform:junit-platform-commons:1.7.2           |    +--- org.junit.platform:junit-platform-engine:1.7.2 (*)           |    \--- org.junit:junit-bom:5.7.2 (*)           \--- org.junit.vintage:junit-vintage-engine:5.7.2 (*)  org.junit:junit-bom:5.7.2    variant ""apiElements"" [       org.gradle.category            = platform       org.gradle.usage               = java-api       org.gradle.status              = release (not requested)        Requested attributes not found in the selected variant:          org.gradle.dependency.bundling = external          org.gradle.libraryelements     = classes          org.gradle.jvm.version         = 11    ]  org.junit:junit-bom:5.7.2 +--- org.junit.platform:junit-platform-commons:1.7.2 |    +--- org.junit.platform:junit-platform-engine:1.7.2 |    |    +--- org.junit:junit-bom:5.7.2 (*) |    |    \--- org.junit.vintage:junit-vintage-engine:5.7.2 |    |         +--- testCompileClasspath |    |         \--- org.junit:junit-bom:5.7.2 (*) |    \--- org.junit:junit-bom:5.7.2 (*) +--- org.junit.platform:junit-platform-engine:1.7.2 (*) \--- org.junit.vintage:junit-vintage-engine:5.7.2 (*)  (*) - dependencies omitted (listed previously)  A web-based, searchable dependency report is available by adding the --scan option.  BUILD SUCCESSFUL in 610ms 1 actionable task: 1 executed ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.0  - Build Tool/IDE: Gradle 6.9.1  ## Deliverables  - [ ] TBD","closed","component: Vintage,","wilkinsona","2021-09-17T14:01:40Z","2021-09-20T08:26:21Z"
"","2123","JUnit 5 can't find test units when called from Gradle","Affected versions: - Junit version: `5.5.2` - Gradle  version: `6.0`  Working versions: - Junit version: `5.3.2` - Gradle  version: `6.0`  ## Steps to reproduce    Run `gradle test`.  Sample `build.gradle`:  ``` test {     useJUnitPlatform {         includeEngines ""junit-jupiter""         excludeEngines ""junit-vintage""     }     testLogging {         events ""passed"", ""skipped"", ""failed""     } }  sourceCompatibility = 1.8 targetCompatibility = 1.8  dependencies {     testImplementation(""org.junit.jupiter:junit-jupiter-api:5.5.2"")     testRuntimeOnly(""org.junit.jupiter:junit-jupiter-engine:5.5.2"") } ```  When executed in `debug` mode following error appears: ``` 2019-12-09T00:58:03.573+0100 [DEBUG] [TestEventLogger] Gradle Test Executor 14 STANDARD_ERROR 2019-12-09T00:58:03.573+0100 [DEBUG] [TestEventLogger]     Dec 09, 2019 12:58:03 AM org.junit.platform.launcher.core.DefaultLauncher handleThrowable 2019-12-09T00:58:03.573+0100 [DEBUG] [TestEventLogger]     WARNING: TestEngine with ID 'junit-jupiter' failed to discover tests 2019-12-09T00:58:03.573+0100 [DEBUG] [TestEventLogger]     java.lang.NoClassDefFoundError: org/junit/platform/engine/support/discovery/SelectorResolver 2019-12-09T00:58:03.574+0100 [DEBUG] [TestEventLogger]          at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:69) ```  ## Context   - Used versions (Jupiter/Vintage/Platform): `5.5.2`  - Build Tool/IDE: `Gradle`  ## Deliverables  - [ ] ...","closed","3rd-party: Gradle,","niamster","2019-12-09T10:14:09Z","2020-11-08T14:50:39Z"
"","2555","Support declarative extension registration on lifecycle methods","```@ExtendWith``` annotation attached to a custom ""before all"" annotation is not respected. When it is attached to an annotation interface with a ""@TestTemplate"", it lets JUnit use an extension specified by it. However, when it is attached to an interface with ```@BeforeAll``` annotation, JUnit doesn't use the extension and keep performing the default behaviour, apparently.  *Expectation:* If the extension specified by the ""@ExtendWith"" is implementing ""before all callback extension"" , the ```beforeAll(ExtensionContext)``` method should be called back.  That is, with the code example I placed in ""Steps to reproduce"", it should print following.  ``` beforeAll(ExtensionContext) is called beforeAll is called customBeforeAll is called test is called ```  *Actual:* The ```beforeAll(ExtensionCotext)``` of the provided extension is not called back. That is, we see a following output when we run the test in the ""Steps to reproduce"" section.  ``` beforeAll is called customBeforeAll is called test is called ```  ## Steps to reproduce Run following class from your IDE. (in my case IntelliJ).    ```java package com.github.dakusui.jcunitx.engine.junit5;  import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.BeforeAllCallback; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.api.extension.ExtensionContext;  import java.lang.annotation.Retention;  import static java.lang.annotation.RetentionPolicy.RUNTIME;  public class Example {   @BeforeAll   @Retention(RUNTIME)   @ExtendWith(CustomBeforeAllExtension.class)   public @interface CustomBeforeAll {   }    public static class CustomBeforeAllExtension implements BeforeAllCallback {     @Override     public void beforeAll(ExtensionContext context) {       System.out.println(""beforeAll(ExtensionContext) is called"");     }   }    @BeforeAll   public static void beforeAll() {     System.out.println(""beforeAll is called"");   }    @CustomBeforeAll   public static void customBeforeAll() {     System.out.println(""customBeforeAll is called"");   }    @Test   public void test() {     System.out.println(""test is called"");   } } ```    ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.7.1  - Build Tool/IDE: IntelliJ  ## Deliverables  - [ ] ...","closed","component: Jupiter,","dakusui","2021-02-18T04:11:30Z","2021-03-05T11:41:49Z"
"","2569","Junit5.7.1 @Nested demo's problem","## Steps to reproduce my test ```java @DisplayName(""IO"") public class IO {       @Nested     @DisplayName(""fileIO"")     class FileIo{         @Test         @DisplayName(""BIO"")         void bio() throws IOException{          }    } } ``` then I run it,but ```java Internal Error occurred. org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:111) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:85) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:92) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53) Caused by: org.junit.platform.commons.JUnitException: ClassSelector [className = 'com.jieshao.IO$FileIo'] resolution failed 	at org.junit.platform.launcher.listeners.discovery.AbortOnFailureLauncherDiscoveryListener.selectorProcessed(AbortOnFailureLauncherDiscoveryListener.java:39) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:102) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:82) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:113) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:45) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:69) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:103) 	... 7 more Caused by: org.junit.platform.commons.PreconditionViolationException: Could not load class with name: com.jieshao.IO$FileIo 	at org.junit.platform.engine.discovery.ClassSelector.lambda$getJavaClass$0(ClassSelector.java:75) 	at org.junit.platform.commons.function.Try$Failure.getOrThrow(Try.java:335) 	at org.junit.platform.engine.discovery.ClassSelector.getJavaClass(ClassSelector.java:74) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:66) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:134) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1351) 	at java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:126) 	at java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:498) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:485) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:464) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:185) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:125) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:91) 	... 12 more Caused by: java.lang.ClassNotFoundException: com.jieshao.IO$FileIo 	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 	at org.junit.platform.commons.util.ReflectionUtils.lambda$tryToLoadClass$9(ReflectionUtils.java:792) 	at org.junit.platform.commons.function.Try.lambda$call$0(Try.java:57) 	at org.junit.platform.commons.function.Try.of(Try.java:93) 	at org.junit.platform.commons.function.Try.call(Try.java:57) 	at org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(ReflectionUtils.java:755) 	at org.junit.platform.commons.util.ReflectionUtils.tryToLoadClass(ReflectionUtils.java:711) 	... 27 more  Process finished with exit code -2 ``` Is there something I didn't do?[link](https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested)    ## Context   - Used versions (Jupiter/Vintage/Platform): ``` windows10 jdk8 dependencies {     testImplementation(""org.junit.jupiter:junit-jupiter-api:5.7.1"")     testRuntimeOnly(""org.junit.jupiter:junit-jupiter-engine:5.7.1"") } ```  - Build Tool/IDE: ``` gradle 6.7 IDEA 2020.2 ```  ## Deliverables  - [ ] ...","closed","","LY1806620741","2021-03-16T01:39:17Z","2021-03-16T02:02:24Z"
"","2105","error when junit4 not in classpath","## Steps to reproduce if junit4 not in classpath, `JUnit4VersionCheck.checkSupported()` reports the error below when a junit5 test case exists in the code. ``` java.lang.NoClassDefFoundError: junit/runner/Version         at org.junit.vintage.engine.JUnit4VersionCheck.checkSupported(JUnit4VersionCheck.java:32)         at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:61)         at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:177)         at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:164)         at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)         at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150)         at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124)         at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384)         at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345)         at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126)         at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418)  ```   ## Context   - Used versions (Jupiter/Vintage/Platform): since 5.4  - Build Tool/IDE: maven, IntelliJ IDEA  ## Deliverables  - [x] check `junit.runner.Version` exists first in `JUnit4VersionCheck.checkSupported()`","closed","theme: discovery,","JaynLau","2019-11-19T08:04:09Z","2020-04-17T11:01:22Z"
"","2795","PreconditionViolationException: Launcher session has already been closed","## Steps to reproduce I created a project with the cucumber archetype which has the junit5 suite. ``` mvn archetype:generate                      \    ""-DarchetypeGroupId=io.cucumber""           \    ""-DarchetypeArtifactId=cucumber-archetype"" \    ""-DarchetypeVersion=7.0.0""               \    ""-DgroupId=hellocucumber""                  \    ""-DartifactId=hellocucumber""               \    ""-Dpackage=hellocucumber""                  \    ""-Dversion=1.0.0-SNAPSHOT""                 \    ""-DinteractiveMode=false"" ``` then I added the following profile: ```      dd-civisibility              false                                -javaagent:${settings.localRepository}/com/datadoghq/dd-java-agent/0.90.0/dd-java-agent-0.90.0.jar             -Ddd.service=hellocucumber             -Ddd.prioritization.type=ENSURE_TRACE             -Ddd.jmxfetch.enabled=false             -Ddd.integrations.enabled=false             -Ddd.integration.junit.enabled=true                                         com.datadoghq             dd-java-agent             0.90.0             provided                                                          org.apache.maven.plugins                 maven-surefire-plugin                                      ${dd.java.agent.arg}                                              ```   When adding a profile to send data to datadog the command `mvn test -Pdd-civisibility` shows the following error: ``` [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M5:test (default-test) on project hellocucumber: There are test failures. [ERROR]  [ERROR] Please refer to /Users/jcuzmar/Development/tests/hellocucumber/target/surefire-reports for the individual test results. [ERROR] Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream. [ERROR] There was an error in the forked process [ERROR] org.apache.maven.surefire.booter.SurefireBooterForkException: There was an error in the forked process [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:733) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:305) [ERROR]         at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:265) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1314) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:1159) [ERROR]         at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:932) [ERROR]         at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:210) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:156) [ERROR]         at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:148) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117) [ERROR]         at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81) ... ``` And the report says: ```  # Created at 2021-12-14T11:24:13.474 java.lang.ExceptionInInitializerError 	at org.junit.platform.launcher.core.DefaultLauncherSession.close(DefaultLauncherSession.java:47) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.discover(SessionPerRequestLauncher.java:47) 	at org.apache.maven.surefire.junitplatform.TestPlanScannerFilter.accept(TestPlanScannerFilter.java:56) 	at org.apache.maven.surefire.api.util.DefaultScanResult.applyFilter(DefaultScanResult.java:102) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.scanClasspath(JUnitPlatformProvider.java:147) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:128) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:428) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:162) 	at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:562) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:548) Caused by: org.junit.platform.commons.PreconditionViolationException: Launcher session has already been closed 	at org.junit.platform.launcher.core.DefaultLauncherSession$ClosedLauncher.registerTestExecutionListeners(DefaultLauncherSession.java:109) 	at org.junit.platform.launcher.core.DefaultLauncherSession$ClosedLauncher.(DefaultLauncherSession.java:100) 	at org.junit.platform.launcher.core.DefaultLauncherSession$ClosedLauncher.(DefaultLauncherSession.java:97) 	... 10 more ```   Sample project:    https://github.com/j1cs/cucumber-junit5-datadog-error  Just clone it and run `mvn clean test -Pdd-civisibility`  thanks in advance.","closed","3rd-party: Maven Surefire,","j1cs","2021-12-14T14:36:59Z","2021-12-16T11:53:14Z"
"","2260","@ParamerizedTests {displayName}/{arguments} cannot show correctly in Maven's report","## Steps to reproduce Add the parameterized to tests. ``` @ParameterizedTest(name = ""{displayName} with [{arguments}]"") @ValueSource(strings = { ""val0"", ""val1"" }) public void testDisplay(String someValue) ```  **Expected to see:** ```       ``` **Actual reports** ```       ```   ## Context   - Used versions (Jupiter/Vintage/Platform): Win10 + jdk 11 + jupiter  - Maven SureFire Plugin: 3.0.0-M4  - Build Tool/IDE: Terminal","closed","3rd-party: Maven Surefire,","sima-zhu","2020-04-16T22:16:28Z","2020-04-23T06:09:24Z"
"","2364","Failures not reported in junit jupiter version 5.4.0","## Steps to reproduce 1. Create a kotlin test file like this: ``` package com.something  import org.junit.jupiter.api.Assertions.assertEquals import org.junit.jupiter.api.Test   class SimpleTests {     @Test     fun `failure fails`() {         assertEquals(1, 2)     } } ``` 2. Configure build.gradle to contain the following: ``` ext {     junitjupiter_version = '5.3.2' ... } ... test {     useJUnitPlatform() } ... ``` 3. Run the tests, confirm they fail: ``` ./gradlew test  > Task :service:test  com.something.SimpleTests > failure fails() FAILED     org.opentest4j.AssertionFailedError at SimpleTests.kt:10  18 tests completed, 1 failed  > Task :service:test FAILED  FAILURE: Build failed with an exception. ``` 4. Update junit jupiter version to 5.4.0: ``` junitjupiter_version = '5.4.0' ``` 5. Re-run tests.  Expected outcome: Failure Reported  Actual outcome:  ``` ./gradlew test  BUILD SUCCESSFUL in 1s 11 actionable tasks: 11 up-to-date ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.3.2 -> 5.4.0  - Build Tool/IDE: gradle/IntelliJ  ## Deliverables  - [ ] How to ensure failures are reported","closed","component: Jupiter,","rlarner-quizlet","2020-07-27T20:00:25Z","2020-07-28T08:16:49Z"
"","2289","JUnit 5 console launcher requires include classes pattern even when test class specified","## Steps to reproduce  When using the 1.7.0-M1 JUnit 5 console launcher to run Spock tests from the command it failed to discover and run the tests even though `--select-class` was correctly specifiying the name of the Spock test class which was on the classpath along with the other required dependencies. To resolve the problem the `--include-classname` option also needs to be supplied with a regex that the value of `--select-class` satisfies. Given that the name of the test class has been explicitly supplied and there is no classpath scanning going on it feels unnecessary to also have to supply this regex pattern.  I've created a small GitHub [repo](https://github.com/georgeharley/spock-test-app) to help demonstrate the problem.  ## Context   - Used versions (Jupiter/Vintage/Platform): JUnit5 console launcher version 1.7.0-M1  - Spock version: Spock version 2.0-groovy-2.5-SNAPSHOT  - Build Tool/IDE: IntelliJ  - Java version: Java 8  - OS: macOS","closed","component: Platform,","georgeharley","2020-05-06T13:06:26Z","2020-05-06T13:37:04Z"
"","2881","TestEngine with ID 'junit-jupiter' failed to discover tests v5.8.2 java 17","## Steps to reproduce  Upgrading the junit-jupiter-api and junit-jupiter-engine from 5.7.0 to 5.8.2 under JDK 17    ## Context I have faced an issue when upgrading my Jupiter version from 5.7.0 to 5.8.2 on Java 17 project with these errors :   ``` org.junit.platform.commons.JUnitException: TestEngine with ID 'junit-jupiter' failed to discover tests 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:111) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:85) 	at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:92) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) 	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: org.junit.platform.commons.JUnitException: ClassSelector [className = 'com.azure.monitoring.application.service.PostServiceTest'] resolution failed 	at org.junit.platform.launcher.listeners.discovery.AbortOnFailureLauncherDiscoveryListener.selectorProcessed(AbortOnFailureLauncherDiscoveryListener.java:39) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:102) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:82) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:113) 	at org.junit.jupiter.engine.discovery.DiscoverySelectorResolver.resolveSelectors(DiscoverySelectorResolver.java:46) 	at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:69) 	at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:103) 	... 9 more Caused by: java.lang.NoSuchMethodError: 'java.util.Optional org.junit.platform.commons.util.AnnotationUtils.findAnnotation(java.lang.Class, java.lang.Class, boolean)' 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.getDisplayNameGenerator(DisplayNameUtils.java:110) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.lambda$createDisplayNameSupplierForClass$2(DisplayNameUtils.java:98) 	at org.junit.jupiter.engine.descriptor.DisplayNameUtils.determineDisplayName(DisplayNameUtils.java:88) 	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.(JupiterTestDescriptor.java:69) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.(ClassBasedTestDescriptor.java:96) 	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.(ClassTestDescriptor.java:51) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.newClassTestDescriptor(ClassSelectorResolver.java:119) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.lambda$resolve$0(ClassSelectorResolver.java:71) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution$DefaultContext.createAndAdd(EngineDiscoveryRequestResolution.java:246) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution$DefaultContext.addToParent(EngineDiscoveryRequestResolution.java:209) 	at org.junit.jupiter.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:71) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:134) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197) 	at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1602) 	at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:129) 	at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:527) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) 	at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:647) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:185) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:125) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:91) 	... 14 more ```   - Used versions (Jupiter): 5.8.2  - Build Tool/IDE: Intellij  ## Deliverables  - [ ] ...","closed","3rd-party: IntelliJ IDEA,","kasdihacene","2022-04-09T11:47:39Z","2022-04-09T12:33:54Z"
"","2149","Bad version range in Import-Package","## Steps to reproduce  The change https://github.com/junit-team/junit5/commit/aba6adbe591b7a5dd33e346f9b91a872e62d3322 lead to invalid version ranges in Import-Package statements. For example in `junit-platform-runner` we see `@4.12` instead of the desired `[4.12,5)`:  ``` Import-Package   org.junit.platform.commons.logging     {version=[1.6,2), status=INTERNAL}   org.junit.platform.commons.util        {version=[1.6,2)}   org.junit.platform.engine              {version=[1.6,2)}   org.junit.platform.engine.discovery    {version=[1.6,2)}   org.junit.platform.engine.reporting    {version=[1.6,2)}   org.junit.platform.engine.support.descriptor {version=[1.6,2)}   org.junit.platform.launcher            {version=[1.6,2)}   org.junit.platform.launcher.core       {version=[1.6,2)}   org.junit.platform.suite.api           {version=[1.6,2)}   org.junit.runner                       {version=@4.12}   org.junit.runner.manipulation          {version=@4.12}   org.junit.runner.notification          {version=@4.12}  ```    ## Context  This occurs in the current master branch.  ## Deliverables  The solution will be change change the versions in the build scripts from `version=""@${Versions.junit4Min}""` to `version=""[${Versions.junit4Min},5)""`.","closed","type: bug,","bjhargrave","2020-01-14T22:44:03Z","2020-01-21T16:51:00Z"
"","2140","JUnit standalone program doesn't discover tests","## Steps to reproduce  run  java -jar ex1/lib/junit-platform-console-standalone-1.6.0-M1.jar --select-directory=""./ex1/test"" with the following hierarchy   ``` . ├── ex1 │   ├── lib │   │   ├── apiguardian-api-1.1.0.jar │   │   ├── junit-jupiter-api-5.6.0-M1.jar │   │   ├── junit-platform-commons-1.6.0-M1.jar │   │   ├── junit-platform-console-standalone-1.6.0-M1.jar │   │   └── opentest4j-1.2.0.jar │   ├── mavnat.iml │   ├── out │   │   ├── production │   │   │   └── mavnat │   │   │       ├── AVLTree$AVLNode.class │   │   │       ├── AVLTree.class │   │   │       ├── AVLTree$DeletionBalancer.class │   │   │       ├── AVLTree$IAVLNode.class │   │   │       ├── AVLTree$InsertionBalancer.class │   │   │       ├── AVLTree$Rotations.class │   │   │       └── TreePrinter.class │   │   └── test │   │       └── mavnat │   │           ├── ActualAVLTree.class │   │           ├── ActualAVLTree$IAVLNode.class │   │           ├── AVLSanitizer.class │   │           ├── AVLTreeTest.class │   │           ├── AVLTreeTestExternal.class │   │           ├── DeletionTest.class │   │           ├── ExTester$10.class │   │           ├── ExTester$11.class │   │           ├── ExTester$12.class │   │           ├── ExTester$13.class │   │           ├── ExTester$14.class │   │           ├── ExTester$1.class │   │           ├── ExTester$2.class │   │           ├── ExTester$3.class │   │           ├── ExTester$4.class │   │           ├── ExTester$5.class │   │           ├── ExTester$6.class │   │           ├── ExTester$7.class │   │           ├── ExTester$8.class │   │           ├── ExTester$9.class │   │           ├── ExTester.class │   │           ├── InsertionTest.class │   │           ├── META-INF │   │           │   └── mavnat.kotlin_module │   │           ├── RotationsTest.class │   │           ├── SplitTest.class │   │           ├── SuccessStatus.class │   │           ├── TesterUtils.class │   │           ├── Tests.class │   │           └── TestUtils.class │   ├── pro-1.docx │   ├── src │   │   ├── AVLTree.java │   │   └── TreePrinter.java │   └── test │       ├── AVLSanitizer.java │       ├── AVLTreeTestExternal.java │       ├── AVLTreeTest.java │       ├── DeletionTest.java │       ├── InsertionTest.java │       ├── JoinTest.java │       ├── RotationsTest.java │       ├── SplitTest.java │       └── TestUtils.java └── ex2 ```   ## Context   - Used versions (Jupiter/Vintage/Platform): linux junit platform 1.6  - Build Tool/IDE: java 11  I expect the launcher to run my tests. instead no test is run.  ``` java -jar ex1/lib/junit-platform-console-standalone-1.6.0-M1.jar -cp ex1 --scan-classpath  Thanks for using JUnit! Support its development at https://junit.org/sponsoring  ╷ ├─ JUnit Jupiter ✔ └─ JUnit Vintage ✔  Test run finished after 29 ms [         2 containers found      ] [         0 containers skipped    ] [         2 containers started    ] [         0 containers aborted    ] [         2 containers successful ] [         0 containers failed     ] [         0 tests found           ] [         0 tests skipped         ] [         0 tests started         ] [         0 tests aborted         ] [         0 tests successful      ] [         0 tests failed          ]  ```","closed","type: question,","exx8","2019-12-28T18:32:27Z","2019-12-30T06:10:44Z"
"","2162","JUnit Jupiter 5.6.0 @Nested tests do not run when running tests in Maven Surefire and IntelliJ IDEA","## Steps to reproduce  Pom.xml with Junit 5.6.0 and run with maven surefire plugin example code (Kotlin)  ```java import org.junit.jupiter.api.Nested import org.junit.jupiter.api.Test  class NestedClassTest {   @Nested   inner class InnerClassTest1 {     @Test     fun innerClassTest1Case1() {       println(""InnerClass1 Test1 Case1"")     }     @Test     fun innerClassTest1Case2() {       println(""InnerClass1 Test1 Case2"")     }     @Test     fun innerClassTest1Case3() {       println(""InnerClass1 Test1 Case3"")     }     @Test     fun innerClassTest1Case4() {       println(""InnerClass1 Test1 Case4"")     }   } } ``` In maven, they are not in the report, where non-nested classes run ok.  In IntelliJ IDEA when running the test class, it alerts to ""No tests were found""  In Jupiter 5.5.2 (and recent previous versions) the issue is not present: tests are running in both. This may be related to https://github.com/junit-team/junit5/issues/1343  ## Context   - Used versions (Jupiter/Vintage/Platform): Jupiter 5.6.0, Platform: 1.60  - Build Tool/IDE: Maven surefire plugin / IntelliJ IDEA  ## Deliverables  - [ ] ...","closed","3rd-party: Maven Surefire,","koretzki","2020-01-23T19:03:23Z","2020-01-27T15:39:28Z"
"","2804","test arguments are not templated into @parameterizedtest name","## Steps to reproduce  https://github.com/nhomble/junit5-display-name-repro  If I write  ```java @ParameterizedTest(name = ""{0} ' {1}"") ``` then the second argument is **not templated** into the name.  ## Context   - Used versions (Jupiter/Vintage/Platform):  ```groovy dependencies {     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'     testImplementation('org.junit.jupiter:junit-jupiter:5.8.2') } ```  - Build Tool/IDE: Intellij 2021.3  ## Deliverables  - [ ] ...","closed","status: new,","nhomble","2021-12-29T01:54:19Z","2021-12-29T17:58:04Z"
"","2954","The JUnit 5 build must be executed with Java 17. Currently executing with Java 18.","## Steps to reproduce  follow the instructions, prompts and suggestions of java to upgrade to the latest version and then after try to install JUNIT.   ## Context  It's only natural that a programmer would want to be up to date , there may be a way that JUnit could be structured that it still functions with a latest version of Java even if it is not kept up to date.","closed","theme: build,","prepstarr","2022-06-24T16:47:17Z","2022-06-24T18:38:50Z"
"","2444","TempDir can't delete subfolders when assertAll is used","## Steps to reproduce  Executing the following test results in an exception: ``` java.io.IOException: Failed to delete temp directory C:\tmp\junit3857951443644498861. The following paths could not be deleted (see suppressed exceptions for details):  [...] 	Suppressed: java.nio.file.DirectoryNotEmptyException: C:\tmp\junit3857951443644498861 ``` 	  ``` public class DirTest {  	@TempDir 	Path temp;  	@Test 	public void foo() throws MultipleFailuresError, IOException { 		Path dir = temp.resolve(""dir""); 		Files.createDirectories(dir); 		Files.createFile(dir.resolve(""file"")); 		assertAll(Files.list(dir).map(f -> () -> {})); 	}  } ```  Debugging shows that `file` can be deleted while `dir` remains existent even after a successful call to `Files#delete` ([TempDirectory](https://github.com/junit-team/junit5/blob/cfdf09aad5ed70fae210fe14fad6d6356f749242/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java#L206))  I suspect there is something within `assertAll` interfering with deleting the directory. Can anyone confirm this behaviour or propose a solution?  ## Context   - JUnit-Version: org.junit.jupiter:junit-jupiter:5.6.2  - Build Tool/IDE: Eclipse 2020-03","closed","component: Jupiter,","MichaelWarnecke","2020-10-07T13:52:20Z","2020-10-08T06:10:27Z"
"","2659","JUnit silently fails to resolve tests if they aren't of type `void`. This can be confusing, particularly in other JVM languages like Scala.","## Steps to reproduce  1. Make class with a JUnit `@Test` that doesn't return `void` 2. Try to run all tests 3. Have it be reported that no tests were found    ## Context  Following a multi-day investigation and discussion with the Redhat/Quarkus team at: - https://github.com/quarkusio/quarkus/issues/18373 - https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/.22No.20Tests.20Found.22.2C.20last.20issue.20for.20Scala.203.20support  # The confusion ![image](https://user-images.githubusercontent.com/26604994/124505556-c0d64480-dd97-11eb-9be4-288cfc7cf83f.png)  ![image](https://user-images.githubusercontent.com/26604994/124505570-cc297000-dd97-11eb-986a-a41e9b71195f.png)  # The resolution  - (Add `: Unit` to function signature to have it generate `void` as return type in bytecode)  ![image](https://user-images.githubusercontent.com/26604994/124505624-e95e3e80-dd97-11eb-9459-e2e0f847fb55.png)  ![image](https://user-images.githubusercontent.com/26604994/124505647-f24f1000-dd97-11eb-9b72-c3b05726f0c3.png)   ## Deliverables  Please would it be possible to either: - Make JUnit tests accept `@Test` that return things beside `void`, potentially just disregarding the return type - Issue a VERY LARGE, blatant error/warning message when `No tests were found` that JUnit only resolves `@Test` methods of type `void`. Something like `No tests returning type ""void"" were found. JUnit only resolves tests of type ""void"".`","closed","status: new,","GavinRay97","2021-07-05T17:53:50Z","2021-07-09T12:33:20Z"
"","2319","Exception thrown in @MethodSource method results in ""no tests""","## Steps to reproduce    Running the following code:  ~~~java import java.util.List;  import org.junit.jupiter.api.TestInstance; import org.junit.jupiter.api.TestInstance.Lifecycle; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource;  @TestInstance(Lifecycle.PER_CLASS) public class MethodSourceErrorTest {      public List getValues() {         throw new RuntimeException(""Foo""); // fails         // return Arrays.asList(""a""); // works     }      @ParameterizedTest     @MethodSource(""getValues"")     public void test1(String value) {         System.out.println(value);     }  } ~~~  Results in:  ~~~ [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO] Running foo.MethodSourceErrorTest [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 s - in foo.MethodSourceErrorTest [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 [INFO]  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ ~~~  My expectation would be that: * JUnit reports an error for the tests using the method source * The build fails  Additional information: * It fails the same way, being a `static` method * It fails the same way, running the test from inside Eclipse:             Screenshot of failure in Eclipse      ![image](https://user-images.githubusercontent.com/202474/84295341-bde43280-ab4a-11ea-9e44-b1e04f07b776.png)           ## Context   - Used versions (Jupiter/Vintage/Platform): 5.6.2, 1.6.2  - Build Tool/IDE: Eclipse 2020-06, Maven 3.6.3  ## Deliverables  - [ ] ...","closed","3rd-party: Maven Surefire,","ctron","2020-06-10T16:48:02Z","2020-06-15T12:55:40Z"
"","2835","Junit systemProperty for parallel execution is not working inside Gradle Tests Plugin","## Steps to reproduce    I am trying to run unit tests and smokes tests in parallel in gradle. I was able to achieve it with unit tests by declaring below mentioned two SystemProperties, now unit tests are running in parallel.  ``` test { // this is main test block in build.gradle file     useJUnitPlatform()     systemProperty(""junit.jupiter.execution.parallel.enabled"", true)     systemProperty(""junit.jupiter.execution.parallel.mode.default"", ""concurrent"")     finalizedBy jacocoTestReport } ```  I have used jvm test suites plugin to place all smoke tests at one place, I tried applying same systemProperty in suites block for these smoke tests but it was not working. All smoke tests are runnning sequentially only.  This is what I am trying:-  ``` testing {     suites {         test {             useJUnitJupiter()             targets.all {                 testTask.configure {                     systemProperty(""junit.jupiter.execution.parallel.enabled"", true)                     systemProperty(""junit.jupiter.execution.parallel.mode.default"", ""concurrent"")                 }             }         }         smokeTest(JvmTestSuite) {             dependencies {                 implementation project             }         }     } } ```  If anyone got some idea, if this is bug from junit side or some other issue is there. Please suggest !!  ## Context   - Used versions (Jupiter/Vintage/Platform): Platform  - Build Tool/IDE: Gradle, IntelliJ Idea","closed","status: new,","sukhbir-singh","2022-02-24T20:33:08Z","2022-02-25T12:09:12Z"
"","2308","@DisplayName not working when used with @ParameterizedTest","## Steps to reproduce    ```java @DisplayName(""RandomTest"") public class RandomTest {     @Test     @DisplayName(""Test"")     void test() {}      @DisplayName(""Parameterized Test"")     @ParameterizedTest()     @ValueSource(bytes = { 0, 1, 2 })     void parameterizedTest() {} } ```  I expect it to print the following result:  ``` RandomTest > Test PASSED  RandomTest > Parameterized Test > [1]  PASSED  RandomTest > Parameterized Test > [2]  PASSED  RandomTest > Parameterized Test > [3]  PASSED ```  But it actually printed this:  ``` RandomTest > Test PASSED  RandomTest > [1]  PASSED  RandomTest > [2]  PASSED  RandomTest > [3]  PASSED ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.6.2  - Build Tool/IDE: Gradle  ## Deliverables  - [ ] ...","closed","3rd-party: Gradle,","JasonHK","2020-05-29T16:42:31Z","2020-05-31T11:42:15Z"
"","2173","If there is a big array need to string in assert msg, junit5 will not report fail if assert fail","## Steps to reproduce    ## Context   - Used versions (Jupiter/Vintage/Platform): ```gradle plugins {     id 'java' }  group 'H-ZeX' version '1.0-SNAPSHOT'  sourceCompatibility = 1.11  repositories {     mavenCentral() }  dependencies {     // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api     testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.6.0-M1'     // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine     testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.6.0-M1' } ``` ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/home/hzx/.gradle/wrapper/dists/gradle-4.10.3-bin/31t79e2qsceia4mkbojplrgx/gradle-4.10.3/lib/groovy-all-2.4.15.jar) to method java.lang.Object.finalize() WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release  ------------------------------------------------------------ Gradle 4.10.3 ------------------------------------------------------------  Build time:   2018-12-05 00:50:54 UTC Revision:     e76905e3a1034e6f724566aeb985621347ff43bc  Kotlin DSL:   1.0-rc-6 Kotlin:       1.2.61 Groovy:       2.4.15 Ant:          Apache Ant(TM) version 1.9.11 compiled on March 23 2018 JVM:          11.0.1 (Oracle Corporation 11.0.1+13) OS:           Linux 5.0.0-38-generic amd64 ``` ``` IntelliJ IDEA 2019.1.4 (Ultimate Edition) Build #IU-191.8026.42, built on July 30, 2019 Subscription is active until November 28, 2020 For educational use only. JRE: 1.8.0_212-release-1586-b4 amd64 JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o Linux 5.0.0-38-generic ``` ``` $ cat /proc/version                                    Linux version 5.0.0-38-generic (buildd@lgw01-amd64-036) (gcc version 8.3.0 (Ubuntu 8.3.0-6ubuntu1)) #41-Ubuntu SMP Tue Dec 3 00:27:35 UTC 2019  ```  ## Deliverables  ```java import org.junit.jupiter.api.Test;  import java.nio.ByteBuffer; import java.util.Arrays; import java.util.Random; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.FutureTask; import java.util.function.Supplier;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue;  interface TriConsumer {     void accept(P1 p1, P2 p2, P3 p3); }   class K {     private final int eachMaxSize = 1024 * 1024;     private final int maxCnt = 16;      private byte[][] makeData() {         int cnt = maxCnt / 2;         byte[][] result = new byte[cnt][];         for (int i = 0; i < cnt; i++) {             int size = eachMaxSize / 2;             result[i] = new byte[size];             for (int j = 0; j < result[i].length; j++) {                 result[i][j] = 122;             }         }         return result;     }      private void k(TriConsumer, Future, byte[][]> checkEq) {         byte[][] bs = makeData();         FutureTask f1 = new FutureTask<>(() -> ByteBuffer.allocateDirect(bs.length).put((byte) 10).rewind());         FutureTask f2 = new FutureTask<>(() -> true);         f1.run();         f2.run();         checkEq.accept(f1, f2, bs);     }      @Test     void test() {         TriConsumer, Future, byte[][]> checkEq = (f1, f2, d) -> {             try {                 assertTrue(f2.get());                 ByteBuffer gotData = f1.get();                 int cnt = 0;                 Supplier msg = () -> Arrays.deepToString(d);                 for (byte[] bs : d) {                     for (byte x : bs) {                         assert x == gotData.get(cnt) : msg.get();                         // assertEquals(x, gotData.get(cnt++), msg);                         cnt++;                     }                 }             } catch (InterruptedException | ExecutionException e) {                 throw new RuntimeException(e);             }         };         k(checkEq);     }      @Test     public void test2() {         byte[] [] d = makeData();         Supplier msg = () -> Arrays.deepToString(d);         assert false : msg.get();     }      public static void main(String[] args) {         new K().test();     } }  ``` ![Screenshot from 2020-02-06 12-34-25](https://user-images.githubusercontent.com/21231345/73906207-12497e00-48dd-11ea-9775-8767a4e50f87.png)  If unfold that fold in the picutre, it is: ![Screenshot from 2020-02-06 12-34-18](https://user-images.githubusercontent.com/21231345/73906210-14134180-48dd-11ea-94e2-4b53aa9ca0ff.png)  ![Screenshot from 2020-02-06 12-33-55](https://user-images.githubusercontent.com/21231345/73906227-268d7b00-48dd-11ea-8f1e-baf79ba56d4e.png)","closed","3rd-party: IntelliJ IDEA,","H-ZeX","2020-02-06T04:27:28Z","2020-02-06T11:19:22Z"
"","2642","Test auto-labeling new issues","## Steps to reproduce    ## Context   - Used versions (Jupiter/Vintage/Platform):  - Build Tool/IDE: Eclipse  ## Deliverables  - [ ] ...","closed","3rd-party: Eclipse,","marcphilipp","2021-06-09T11:57:26Z","2021-06-18T10:37:26Z"
"","2413","Test","## Steps to reproduce    ## Context   - Used versions (Jupiter/Vintage/Platform):  - Build Tool/IDE:  ## Deliverables  - [ ] ...","closed","","SergeyKulachenko","2020-09-18T19:29:15Z","2020-09-18T19:47:17Z"
"","2525","add SHORT_DISPLAY_NAME and LONG_DISPLAY_NAME to ParameterizedTest","## Status Quo  By default, the display name of ```ParameterizedTest``` is similar to ```RepeatedTest#SHORT_DISPLAY_NAME```. If we want to make display name include ""method name"", we have to write string formate like ``` ""{displayName} - {arguments}""``` for all test cases. It seems to me ```RepeatedTest#LONG_DISPLAY_NAME``` is a good example and it would be better to introduce ```LONG_DISPLAY_NAME``` to ```ParameterizedTest```. The benefit is that junit 5 users can replace aforementioned string format by ""standard"" long display name.  ```java @ParameterizedTest(name = ParameterizedTest.LONG_DISPLAY_NAME) ```  ## Considerations  ```java 	String SHORT_DISPLAY_NAME = ""["" + INDEX_PLACEHOLDER + ""] "" + ARGUMENTS_WITH_NAMES_PLACEHOLDER; 	String LONG_DISPLAY_NAME = DISPLAY_NAME_PLACEHOLDER + "" :: "" + SHORT_DISPLAY_NAME;         String DEFAULT_DISPLAY_NAME = SHORT_DISPLAY_NAME ```  ## Deliverables  N/A","closed","theme: parameterized tests,","chia7712","2021-01-13T08:54:31Z","2021-01-13T14:48:27Z"
"","2755","Test not able to find when TestSuite explicitly defined in the include property of surefire plugin","## Expected Behavior Run all the tests that are in the scope of the TestSuite.  ## Actual Behavior None of the test is executed if the test suite is defined  ## Pom.xml dependencies  ```      5.2.0     1.2.0        org.junit.platform     junit-platform-runner     ${junit-platform.version}     test        org.junit.jupiter     junit-jupiter-engine     ${junit-jupiter.version}     test       org.junit.jupiter     junit-jupiter-params     ${junit-jupiter.version}     test       org.junit.jupiter     junit-jupiter-api     ${junit-jupiter.version}     test  ``` ## Steps to reproduce  1. My tests are not able to find if I explicitly include the TestSuite in the maven surefire plugin  ```      org.apache.maven.plugins     maven-surefire-plugin     2.22.2                           **/IntegrationTestSuite.java                ```  ``` @RunWith(JUnitPlatform.class) @SelectClasses(MyTest.class) public class IntegrationTestSuite {  }  **Result:** [INFO] ------------------------------------------------------- [INFO]  T E S T S [INFO] ------------------------------------------------------- [INFO]  [INFO] Results: [INFO]  [INFO] Tests run: 0, Failures: 0, Errors: 0, Skipped: 0 ```  Removing the include tag **OR** including only the MyTest.class will succeed ``` [INFO] Results: [INFO]  [INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0 ```   ## Context   - Used versions (Jupiter/Vintage/Platform): ```             5.2.0         1.2.0      ```  - Build Tool/IDE:  Intellij / Maven","closed","3rd-party: IntelliJ IDEA,","fuzzy28","2021-10-27T07:03:52Z","2021-10-27T07:35:43Z"
"","2717","Abstract classes with `@Nested` are not ignored / not handled properly","## Description The predicate for whether a class annotated with `@Nested` can be executed does not check whether the class is abstract, see [`IsNestedTestClass`](https://github.com/junit-team/junit5/blob/main/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClass.java). This causes a `java.lang.InstantiationException` when trying to run the tests (from within Eclipse IDE).  The predicate for top level test classes in [`IsPotentialTestContainer`](https://github.com/junit-team/junit5/blob/main/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainer.java) excludes abstract classes.  In case you decide to indeed ignore abstract nested classes, then error handling for that would probably have to be part of #242.  ## Steps to reproduce Try to run the following test: ```java package test;  import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test;  public class NestedTestClass {     @Nested     public abstract class NestedClass {         @Test         public void test() {             System.out.println(""test"");         }     } } ```  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.0  - Build Tool/IDE: Eclipse IDE 2021-06 (4.20.0)","closed","theme: diagnostics,","Marcono1234","2021-09-13T13:05:21Z","2022-03-02T20:36:27Z"
"","2715","`ReflectionSupport.findNestedClasses` is not thread-safe","## Description The method `ReflectionSupport.findNestedClasses` is not thread-safe because the underlying implementation uses a `static` field of type `HashSet` without any synchronization: https://github.com/junit-team/junit5/blob/ed3d84d0db3807ae4065221c47d10448ea60e74b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java#L133  It should probably use `ConcurrentHashMap.newKeySet()` or similar. The question is also how much value this cache adds in the first place, but you probably had your reasons to introduce it.  ## Steps to reproduce I cannot provide example code to show the non-thread-safety, because, as often with thread-safety issues, showcasing that something is not thread-safe is difficult. In this particular case it can most likely result in arbitrary exceptions being thrown when two or more threads try to rehash the set at the same time.  ## Context   - Used versions (Jupiter/Vintage/Platform): 5.8.0","closed","component: Platform,","Marcono1234","2021-09-13T10:34:13Z","2021-09-18T14:53:59Z"
"","2843","Add reason alias to @Disabled","## Deliverables  - [ ] Can you please add the `reason` alias in addition to the `value` in the `@Disabled` annotation to improve readability. It will be much easier to read as `@Disabled(reason=""Some message"")`. Good work to the JUnit5 Team!!!","closed","component: Jupiter,","iblessings","2022-03-04T22:16:00Z","2022-03-12T03:08:47Z"
"","2950","Fix inefficient regular expression in ReflectionUtils","Tracking issue for: - [x] https://github.com/junit-team/junit5/security/code-scanning/1","closed","component: Platform,","marcphilipp","2022-06-21T18:36:38Z","2022-06-22T13:49:33Z"
"","2959","Fix broken Javadoc link in DisplayNameGenerator","","closed","component: Jupiter,","scordio","2022-07-02T13:48:49Z","2022-07-02T22:17:15Z"
"","2935","Update to BND 6.3.1","","closed","","marcphilipp","2022-06-03T07:27:36Z","2022-06-09T13:13:30Z"
"","2817","Add JDK 19 CI build","","closed","","marcphilipp","2022-01-31T20:25:26Z","2022-04-09T21:11:06Z"
"","2780","Misc CI improvements","","closed","","marcphilipp","2021-11-14T12:15:29Z","2021-11-14T12:40:37Z"
"","2766","Try to stabilize timeout tests on Windows","","closed","","marcphilipp","2021-10-31T18:28:07Z","2021-11-01T08:54:33Z"
"","2763","More GitHub Actions refactorings","","closed","","marcphilipp","2021-10-29T17:50:31Z","2021-10-29T18:22:05Z"
"","2762","Use composite actions to reduce duplication","","closed","","marcphilipp","2021-10-29T15:02:00Z","2021-10-29T17:18:18Z"
"","2746","Run Gradle with JDK 17","","closed","","marcphilipp","2021-10-14T07:38:54Z","2021-10-15T05:58:48Z"
"","2716","Switch from Adopt to Temurin JDK distribution","","closed","","marcphilipp","2021-09-13T11:45:33Z","2021-09-13T12:09:43Z"
"","2689","Add JDK 18 build and `JRE` enum constant","","closed","component: Jupiter,","marcphilipp","2021-08-15T16:37:12Z","2022-06-14T09:22:22Z"
"","2675","Example pull request","","closed","","dennis-sig","2021-07-28T11:56:45Z","2021-07-28T12:23:14Z"
"","2672","Update AssertJ to 3.20.2","","closed","","marcphilipp","2021-07-26T10:12:57Z","2021-07-26T10:24:42Z"
"","2665","Update to ArchUnit 0.20.1","","closed","","marcphilipp","2021-07-17T09:27:44Z","2021-07-26T08:00:07Z"
"","2658","Update ArchUnit to 0.20.0","","closed","","marcphilipp","2021-07-05T06:49:01Z","2021-07-05T08:00:09Z"
"","2638","Make module `org.junit.platform.jfr` work on Java 8","","closed","","marcphilipp","2021-06-04T11:40:08Z","2021-06-08T07:19:38Z"
"","2576","CI improvements","","closed","","marcphilipp","2021-03-19T09:23:08Z","2021-03-19T11:02:42Z"
"","2574","Test on JDK 16","","closed","","marcphilipp","2021-03-18T15:19:06Z","2021-03-18T15:51:35Z"
"","2568","Upgrade Gradle Enterprise plugin to 3.6 and simplify GH Actions config","","closed","","marcphilipp","2021-03-15T14:31:09Z","2021-03-18T09:29:30Z"
"","2534","Update all the things","","closed","","marcphilipp","2021-01-16T20:58:07Z","2021-01-17T14:06:29Z"
"","2495","Upgrade ArchUnit to 0.15.0","","closed","type: task,","marcphilipp","2020-12-17T19:16:44Z","2020-12-17T19:37:41Z"
"","2463","Upgrade bnd to 5.2.0","","closed","","marcphilipp","2020-10-26T19:53:36Z","2020-10-26T20:08:57Z"
"","2448","Use Docker images from GitHub Container Registry","","closed","","marcphilipp","2020-10-13T19:55:41Z","2020-10-13T20:16:48Z"
"","2339","Found used undeclared dependencies junit 4.13 when I use junit 5","","closed","","Svetlana116","2020-06-25T06:20:02Z","2020-06-25T06:21:16Z"
"","2151","Fix bad version range in Import-Package","","closed","","rotty3000","2020-01-15T19:55:53Z","2020-01-18T13:29:06Z"