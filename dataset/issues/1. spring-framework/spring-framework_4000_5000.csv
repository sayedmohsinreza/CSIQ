"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","24243","测试文件","请忽略","closed","status: invalid,","huozhenblin","2019-12-21T04:16:39Z","2019-12-21T11:44:29Z"
"","23823","Merge pull request #1 from spring-projects/master","合并Spring最新代码","closed","status: invalid,","244372610","2019-10-16T16:21:59Z","2019-10-16T16:25:31Z"
"","23960","Merge pull request #1 from spring-projects/master","合并","closed","status: invalid,","kyo564296811","2019-11-09T06:34:22Z","2019-11-09T08:02:37Z"
"","24079","Floating point conversion error with @Value","使用@Value解析配置文件的配置项时，数据转换错误； 例：配置文件中配置项：project.item.value=1234.5e1213453 当我们使用@Value(${project.item.value})接受参数时，spring默认先把1234.5e1213453当浮点型处理，这种情况导致数据内容超出浮点的范围时会放回invalid错误","closed","in: core,","lanlystrong","2019-11-26T05:43:05Z","2019-12-10T12:58:54Z"
"","24266","Add missing space in AopConfigException message","…yBean#namedBeanToAdvisor  @pivotal-issuemaster This is an Obvious Fix","closed","type: task,","PascalSchumacher","2019-12-25T15:21:09Z","2019-12-26T08:56:14Z"
"","24256","can we add default convert list for ConvertService","you know some times ,when we write some business code ,we offten need POJO convert, but convertService only support class convert ,if we want to convert list,we need use `	Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType); ` this method ,i dont think this is a good way to me 。so can we add default impl to convert list ```java  public interface ConversionService {  	default  List convert(List objectList, Class targetType) { 		return objectList.stream().map(ob -> convert(ob, targetType)).collect(Collectors.toList()); 	}  }  ```","closed","status: duplicate,","lazyfighter","2019-12-24T09:20:46Z","2019-12-24T09:29:56Z"
"","24130","XmlBeansMarshaller should be brought back, as Xmlbeans is unretired by Apache.","XmlBeansMarshaller class was deperecated and removed because of retirement of Xmlbeans by Apache.  However, Xmlbeans is unretired and active development is also happening.  Shouldn't Marshaller be reintroduced to support Xmlbeans ?  Update about Xmlbeans unretirement is published in below link. http://xmlbeans.apache.org/news","closed","status: duplicate,","chirag519086","2019-12-04T11:28:35Z","2019-12-05T15:41:20Z"
"","24530","Partial dependency injection into constructor","With this commit it is possible to partially autowire constructors. It is useful, for example, for lookup methods, creating prototype beans. Sometimes prototype beans depend on singletons, and before to create such prototypes it was required to write custom factories. This change allows to use lookup methods.","open","in: core,","gzoom13","2020-02-15T14:47:16Z","2021-11-10T11:58:05Z"
"","24466","If controller method has produces=""*/*"" in 5.2.3 response is 500 instead of 406","With the following commit, if a RequestMapping specifies `produces=""*/*`and the request headers don't specify any accept, it will override the response with a 500 as the code below suggests :  https://github.com/spring-projects/spring-framework/commit/34d32402d352fe7bca2f45d3bc5c7243459ec556#diff-24571dc5c7743b2a69f7a5df4f2109b2R316","closed","type: enhancement,","smaldini","2020-01-31T19:06:17Z","2020-02-18T21:51:36Z"
"","24464","Support command line arguments with an empty value","With Spring Boot, you can override application properties using command line arguments like so:  ``` java -jar my-boot.jar --my.property.name=value ```  This, however, fails when you try to pass an empty value:  ``` java -jar my-boot.jar --my.property.name= ```  ``` java.lang.IllegalArgumentException: Invalid argument syntax: --my.property.name=   at org.springframework.core.env.SimpleCommandLineArgsParser.parse(SimpleCommandLineArgsParser.java:75)   at org.springframework.core.env.SimpleCommandLinePropertySource.(SimpleCommandLinePropertySource.java:90) ```  Since an empty string is a legal value for an application property, there seems to be no good reason to reject command line arguments with an empty value.  A real-world example is Kafka's `ssl.endpoint.identification.algorithm` which has to be set to an empty string to disable host name verification.","closed","status: feedback-provided,","robwruck","2020-01-31T12:06:47Z","2020-02-03T14:04:39Z"
"","24389","ServerSentEventHttpMessageReader maps null when event has comment only.","With Spring 5.2.3 I'm experiencing a Bug when reading server sent events with the web client. I've managed to write this minimal sample to reproduce the bug:  This code works perfectly fine on Spring 5.2.2  ```java public static void main(String[] args) { 	ServerSentEventHttpMessageReader reader = new ServerSentEventHttpMessageReader(); 	DataBufferFactory factory = new DefaultDataBufferFactory();  	ReactiveHttpInputMessage message = new ReactiveHttpInputMessage() { 		@Override 		public Flux getBody() { 			return Flux.just( 				factory.wrap("":ping\n"".getBytes(StandardCharsets.UTF_8)), 				factory.wrap(""\n"".getBytes(StandardCharsets.UTF_8)) 			); 		}  		@Override 		public HttpHeaders getHeaders() { 			return new HttpHeaders(); 		} 	};  	Flux flux = reader.read(ResolvableType.forType(String.class), message, emptyMap()); 	flux.collectList().block().forEach(System.out::println); } ```  But on Spring 5.2.3 an exception is thrown. This also happens when the comment `:ping` is missing and just a newline is received.  ``` Exception in thread ""main"" java.lang.NullPointerException: The mapper returned a null value. 	at java.util.Objects.requireNonNull(Objects.java:228) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:100) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.emit(FluxBufferPredicate.java:295) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.onNextNewBuffer(FluxBufferPredicate.java:260) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.tryOnNext(FluxBufferPredicate.java:214) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.onNext(FluxBufferPredicate.java:186) 	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onNext(FluxPeekFuseable.java:845) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:213) 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:103) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:213) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.emit(FluxBufferPredicate.java:295) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.onNextNewBuffer(FluxBufferPredicate.java:260) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.tryOnNext(FluxBufferPredicate.java:214) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.onNext(FluxBufferPredicate.java:186) 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drainSync(FluxFlattenIterable.java:576) 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drain(FluxFlattenIterable.java:646) 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.request(FluxFlattenIterable.java:273) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.request(FluxBufferPredicate.java:149) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.request(FluxMap.java:281) 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.request(FluxContextStart.java:132) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.request(FluxMap.java:281) 	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.request(FluxPeekFuseable.java:775) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.request(FluxBufferPredicate.java:149) 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) 	at reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onSubscribe(MonoCollectList.java:72) 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.onSubscribe(FluxBufferPredicate.java:180) 	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onSubscribe(FluxPeekFuseable.java:808) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onSubscribe(FluxMap.java:185) 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onSubscribe(FluxContextStart.java:97) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onSubscribe(FluxMap.java:185) 	at reactor.core.publisher.FluxBufferPredicate$BufferPredicateSubscriber.onSubscribe(FluxBufferPredicate.java:180) 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.onSubscribe(FluxFlattenIterable.java:215) 	at reactor.core.publisher.FluxArray.subscribe(FluxArray.java:53) 	at reactor.core.publisher.FluxArray.subscribe(FluxArray.java:59) 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:53) 	at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:54) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4105) 	at reactor.core.publisher.Mono.block(Mono.java:1662) 	at de.codecentric.boot.admin.server.web.InstancesControllerIntegrationTest.main(InstancesControllerIntegrationTest.java:243) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) 		at reactor.core.publisher.Mono.block(Mono.java:1663) 		... 1 more ```","closed","type: bug,","joshiste","2020-01-17T15:47:55Z","2020-01-20T17:32:55Z"
"","24453","Compatibility with JDK 14","With JDK 14 GA coming up in March and the final release candidate just in time for our Spring Framework 5.2.4 release, let's aim for general runtime compatibility as well as being able to run the Spring Framework master build on JDK 14. If there are any limitations, e.g. with JDK 14 bytecode level in certain scenarios, those should get documented.","closed","type: enhancement,","jhoeller","2020-01-29T10:56:42Z","2020-02-06T15:49:34Z"
"","24123","StringHttpMessageConverter lost a fix that assumed charset UTF-8 for ""application/json""","With #22100 (release 5.1.4) the StringHttpMessageConverter used charset UTF-8 for application/json, which is correct. However, the change to StringHttpMessageConverter.java was undone with #22954 (release 5.2.0). #22954 aims to remove the charset parameter from Spring MVC JSON content type. But the lines dropped from StringHttpMessageConverter.java do not *add* a charset parameter to a content type. Instead they *define* the charset which will be used in interpreting messages. Without the fix from #22100 the charset for JSON messages defaults to ISO_8859_1, which is not correct and would require  to set the charset explicitly.","closed","type: regression,","iorjfeiofjseoirf","2019-12-03T09:57:33Z","2019-12-13T10:00:31Z"
"","24817","spring-beans:compileGroovy FAILED。 Spring5.1.x","who can help me？ When I compile Spring5.1.x use idea,always this error.   ``` D:\sqt\demo\spring-framework>gradlew :spring-oxm:compileTestJava  > Task :spring-beans:compileGroovy FAILED D:\sqt\demo\spring-framework\spring-beans\src\main\java\org\springframework\beans\support\PropertyComparator.java:138: ??: ??????: PropertyComparator?????Comparator                         source.sort(new PropertyComparator<>(sortDefinition));                                     ^   ??, CAP#1??????:     CAP#1???????Object ?: ?????????; ??? -Xdiags:verbose ??????????? 1 ??? startup failed: Compilation failed; see the compiler error output for details.  1 error   FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-beans:compileGroovy'. > Compilation failed; see the compiler error output for details.  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  BUILD FAILED in 7s 12 actionable tasks: 1 executed, 11 up-to-date ```","closed","for: stackoverflow,","ListenerSun","2020-03-30T16:06:35Z","2021-10-28T09:32:38Z"
"","24554","AbstractClientHttpResponse not compatible with Cloudflare 521 status code","While trying to access the http status from an interceptor on the RestTemplate I'm getting the following exception:  ``` No matching constant for [521] at  org.springframework.http.HttpStatus.valueOf(HttpStatus.java:538) at  org.springframework.http.client.AbstractClientHttpResponse.getStatusCode(AbstractClientHttpResponse.java:33) at  org.springframework.http.client.BufferingClientHttpResponseWrapper.getStatusCode(BufferingClientHttpResponseWrapper.java:50) ```  It seems that 521 (Web server is down) isn't a valid value for `org.springframework.http.HttpStatus`.  I can just get the raw number but does it make sense to support it from Spring side?","closed","status: declined,","rubasace","2020-02-19T10:31:21Z","2020-02-19T16:14:45Z"
"","24664","Short circuit check in SynthesizedMergedAnnotationInvocationHandler.isVisible()","While testing `spring-core` within a GraalVM native image (which uses a single, system-wide `ClassLoader`), it became apparent that the visibility check within `SynthesizedMergedAnnotationInvocationHandler.isVisible(ClassLoader, Class)` could be short circuited to avoid an unnecessary invocation of `Class.forName`.  @jhoeller suggested something along the lines of the following.  ```java 	private static boolean isVisible(ClassLoader classLoader, Class interfaceClass) { 		// short circuit? 		if (interfaceClass.getClassLoader() == classLoader) { 			return true; 		} 		try { 			return Class.forName(interfaceClass.getName(), false, classLoader) == interfaceClass; 		} 		catch (ClassNotFoundException ex) { 			return false; 		} 	} ```","closed","type: enhancement,","sbrannen","2020-03-09T14:07:28Z","2020-07-27T10:26:42Z"
"","23884","Support for limits on input stream processing in WebFlux codecs","While a proxy, or the underlying server, or a `WebFilter` can be used to enforce general limits on the size of server request input, it would be helpful for `Decoder` and `HttpMessageReader` implementations to expose configurable limits too, because codecs in WebFlux can parse asynchronously and pass one object one at a time to the application, as a stream. That means the overall request input stream may be infinite, and it's the input per streamed object that should be limited.","closed","type: enhancement,","rstoyanchev","2019-10-29T11:47:50Z","2019-12-06T16:20:39Z"
"","24825","Allow @DynamicPropertySource on non-static fields","While `@DynamicPropertySource` is great, it would be even better if it could be executed on each `@Test` method instead only one time at start of the test class.  For example: okhttp `MockWebServer` starts on a free random port. But each test needs its own `MockWebServer` as otherwise the state is preserved between test runs.  ```java @SpringBootTest public class MockTest implements BeforeEachCallback { 	private MockWebServer mockServer;  	//requires a fresh instance for each @Test method 	@Override 	public void beforeEach(ExtensionContext extensionContext) { 		mockServer = new MockWebServer(); 	}  	//this is not possible as mockServer is not static! 	@DynamicPropertySource 	static void changePort(DynamicPropertyRegistry registry) { 		registry.add(""my.app.base.url"", () -> ""http://localhost:"" + mockServer.getPort());  	} } ```  If I'd make the `MockWebServer` a `static` field, that won't work if multiple `@Test` classes make use of the mock. Eg `assertEquals(1, mockServer.getRequestCount());` would only be valid for the first test method, as mockwebserver preserves the state then.","open","status: blocked,","membersound","2020-03-31T12:21:03Z","2020-04-07T15:01:52Z"
"","24101","Change value of Order.LOWEST_PRECEDENCE or make it configurable","Whether you can change the Order of int LOWEST_PRECEDENCE = Integer. MAX_VALUE; Can provide overwriting LOWEST_PRECEDENCE after the sorting function","closed","status: declined,","zhengchb","2019-11-29T07:48:00Z","2020-04-02T07:49:27Z"
"","24030","Incorrect Javadoc regarding default Tomcat async request timeout","Where Spring WebMvc allows to configure async request timeout, the Javadoc mentions the following:  ```java /**  * Specify the amount of time, in milliseconds, before concurrent handling  * should time out. In Servlet 3, the timeout begins after the main request  * processing thread has exited and ends when the request is dispatched again  * for further processing of the concurrently produced result.  * If this value is not set, the default timeout of the underlying  * implementation is used, e.g. 10 seconds on Tomcat with Servlet 3.  * @param timeout the timeout value in milliseconds  */ ```  I found these in Spring WebMvc in `org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setAsyncRequestTimeout` and `org.springframework.web.servlet.config.annotation.AsyncSupportConfigurer#setDefaultTimeout`  However, actually the default timeout in Tomcat is 30 seconds as noted in this comment: https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/core/AsyncContextImpl.java#L74 and indeed set to the default `30000` ms here: https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/connector/Connector.java#L134  I suggest the Spring WebMvc documentation to be adjusted or the explicit value to be removed altogether from the Javadoc.","closed","type: task,","adammichalik","2019-11-19T13:57:44Z","2019-11-19T18:27:55Z"
"","24590","SimpleJdbcInsertOperations executeBatch method should accept Collection as parameter","When we insert multiple records in one batch, very often we have a collection of records. As `SimpleJdbcInsertOperations` interface has `executeBatch(Map... batch)` only, we have to transform the collection to an array. As the implementation in `AbstractJdbcInsert::executeBatchInternal` converts the array (vararg) into a List anyway, adding a new method which accepts a Collection of Maps (`executeBatch(Collection> batch)`) seems to be straightforward and would help avoiding an additional conversion in many cases.","open","in: data,","foldvari","2020-02-25T13:57:56Z","2021-11-12T12:12:08Z"
"","24673","Fix execution order of @AfterReturning and @After methods in ReflectiveAspectJAdvisorFactory","When using the `@AfterReturning` and `@After` to implement AOP function, the program always  call the method annotated by `@After` before the method annotated by `@AfterReturning`. It's opposite to the normal execution order of AOP function implemented by the XML.  By tracing and debugging, I found the reason is that the annotated methods is sorted by a wrong comparator which was not constructed correctly in the process of parsing annotations. Finally, the problem was fixed by adjusting the order of parameters (annotation classes) when the comparator be constructed. It was be verified after repair and compilation. So, I created this commit . If I misunderstand something, please tell me. thanks !","closed","status: superseded,","Dafengsu","2020-03-10T18:12:39Z","2020-06-09T14:15:51Z"
"","24416","Out of the box MDC support in WebClient","When using `WebClient` in servlet environment, MDC is one of the pain point that requires boilerplate code. Since `RestTemplate` is in maintenance mode, more and more apps would choose to use `WebClient`. It would be very helpful that spring provides out of the box support for MDC for the use of `WebClient`. Then, it would be a smooth ride migrating `RestTemplate` to `WebClient`.  Since spring already [detects underlying logging framework](https://github.com/spring-projects/spring-framework/blob/master/spring-jcl/src/main/java/org/apache/commons/logging/LogAdapter.java#L50-L75), it could be implemented agnostic to the actual logging framework.  ## What needs to be implemented:  - Pass MDC values from main thread to reactor thread In servlet environment, it is required to propagate MDC context values from servlet thread to reactor thread. To implement, `ExchangeFilterFunction` or some sort of hook which should apply as the first action of response operators.  - Pass around MDC values to subscriber context within reactor schedulers/operators My suggestion to reactor-addons. https://github.com/reactor/reactor-addons/issues/219   If such boilerplate code is provided from spring, then, spring-boot may auto-configure the MDC support.   Relates to https://github.com/reactor/reactor-core/issues/1985","closed","status: declined,","ttddyy","2020-01-22T22:58:54Z","2022-02-18T21:11:31Z"
"","24656","RSocket MetadataEncoder expands the routes incorrect","When using `route(""process.{id}.log"", ""deadbeef"")` I'd expect the route to be expanded to `process.deadbeef.log` but to my suprise it's expanded to `process.deadbeef`.  Affected version: spring-messaging 5.2.4.RELEASE  I could track down the error to the `org.springframework.messaging.rsocket.MetadataEncoder`. This minimal sample illustrates the bug (sorry for the reflection hackery):  ```java public static void main(String[] args) throws Exception {    Class clazz = Class.forName(""org.springframework.messaging.rsocket.MetadataEncoder"");     Method expandMethod = clazz.getDeclaredMethod(""expand"", String.class, Object[].class);     expandMethod.setAccessible(true);     String route = (String) expandMethod.invoke(null, ""process.{id}.log"", new Object[]{""deadbeef""});     System.out.println(route); } ```","closed","type: bug,","joshiste","2020-03-07T12:34:02Z","2020-03-12T12:23:35Z"
"","23915","Turn off useSuffixPatternMatching by default","When useSuffixPatternMatching is set to true, then   > a method mapped to ""/users"" also matches to ""/users.*""  The default value is true. Please can this be changed to false.  **Defaults shouldn't be surprising** It is not obvious to developers that this will occur. They intend to setup a static mapping of ""/users"" and find that this mapping works. They have to explicit visit ""/users.blah"" to discover that they have unintentionally mapped more than they intended.  There are lots of examples of this causing surprise with developers being confused by the cause and purpose of this function:  * https://stackoverflow.com/questions/9688065/spring-mvc-application-filtering-html-in-url-is-this-a-security-issue * https://stackoverflow.com/questions/30610607/how-to-change-spring-request-mapping-to-disallow-url-pattern-with-suffix * https://stackoverflow.com/questions/30307678/why-does-requestmapping-spring-annotation-in-controller-capture-more-that-i-wan * https://stackoverflow.com/questions/22845672/requestmapping-in-spring-with-weird-patterns  The behaviour is [clearly documented](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match) but that isn't good enough to stop the surprise because it isn't clear from the application code itself. All a developer sees is that ""/users"" is mapped and there is nothing explicit to make them realise something else is going on.   **Defaults should encourage best practice** As documented, this default is enabling a practice that used to be widespread but has fallen out of favour due to the problems it causes. Developers should be using the Accept header and not file extensions for content negotiation.  It would be better to allow developers to opt-in to this feature, rather than having the best practice be an opt-in.   **Defaults should be secure** `antMatchers` still exists in Spring Security. Whilst everybody should be using `mvcMatchers`, it's still really easy to open up a security hole by having this switched on.  It is also much more risky than the optional trailing slash feature which developers are far more likely to expect and anticipate since such a feature is common to many web frameworks. Developers are very unlikely to add a file extension to their URL if they haven't mapped one and thus can still easily miss this vulnerability if they have failed to use `mvcMatchers`","closed","type: enhancement,","rupert-madden-abbott","2019-11-03T23:51:09Z","2020-05-12T08:02:44Z"
"","24537","DefaultCorsProcessor should return HTTP 204 instead of 200","When the `DefaultCorsProrocessor` successfully handles a pre-flight request and returns a response that has an HTTP 200 status code, but it's arguably more correct to return a 204 as there is no content. It is also clearer that something out of the ordinary is happening as it's less common to have a 204 response than a 200 which may help when debugging issues.  Changing this may break some tests as rather than just testing that a request is ok, developers may be explicitly be checking for a 200 status code.  This is how an example pre-flight request currently looks:  ``` > OPTIONS / HTTP/1.1 > Host: localhost:8443 > User-Agent: curl/7.64.1 > Accept: */* > Origin: https://localhost:3000 > Access-Control-Request-Method: POST > Access-Control-Request-Headers: Content-Type >  < HTTP/1.1 200  < Vary: Origin < Vary: Access-Control-Request-Method < Vary: Access-Control-Request-Headers < Access-Control-Allow-Origin: https://localhost:3000 < Access-Control-Allow-Methods: GET,HEAD,DELETE,PUT,PATCH,POST < Access-Control-Allow-Headers: Content-Type < Access-Control-Allow-Credentials: true < X-Content-Type-Options: nosniff < X-XSS-Protection: 1; mode=block < Cache-Control: no-cache, no-store, max-age=0, must-revalidate < Pragma: no-cache < Expires: 0 < Strict-Transport-Security: max-age=31536000 ; includeSubDomains < X-Frame-Options: DENY < Content-Length: 0 < Date: Mon, 17 Feb 2020 09:55:47 GMT <  ```","closed","status: declined,","buckett","2020-02-17T09:59:51Z","2021-10-18T11:12:14Z"
"","24420","Solve ReflectPermission issue in sandbox security policy model for repackaged CGLIB ReflectUtils","When the **custom Security Policy** is implemented within the Spring Boot applications to restrict permissions for the **user defined plugin code**, below mentioned exception will be thrown while building the beans from the plugin code. This change will solve this issue. **Same approach is already followed** in [SimpleInstantiationStrategy](https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/SimpleInstantiationStrategy.java), [ConstructorResolver](https://github.com/spring-projects/spring-framework/blob/v5.1.8.RELEASE/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java) and even in [ReflectUtils](https://github.com/spring-projects/spring-framework/blob/v5.1.5.RELEASE/spring-core/src/main/java/org/springframework/cglib/core/ReflectUtils.java) (for some other statements but not this)   ### **Issue:** org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.autoconfigure.batch.JpaBatchConfigurer]: Factory method 'batchConfigurer' threw exception; nested exception is java.security.AccessControlException: access denied (**""java.lang.reflect.ReflectPermission"" ""suppressAccessChecks""**)  Refer the **attachment** for complete stack trace. [Exception_Stacktrace.txt](https://github.com/spring-projects/spring-framework/files/4102581/Exception_Stacktrace.txt)","closed","type: enhancement,","kalmeshcs","2020-01-23T10:35:36Z","2020-01-28T11:46:41Z"
"","24162","QuartzScheduler needs to be shut down after each integration test","When running multiple tests the application contexts are not closed after each test class, which is the defined behavior.   If multiple tests are starting a Quartz Scheduler, this may lead to some cached scheduler starting jobs in the wrong application context. The obvious solution is to mark all those tests with `@DirtiesContext`.   I wonder if this can be done automatically by the spring test framework.   So you can't forget the annotation on some test.  It would also save some other folks time (like this guys: https://stackoverflow.com/questions/54818080/quartz-job-from-a-previous-spring-boot-test-randomly-still-running/59234469#59234469) - it took me 5h debugging this until it fell like scales from my eyes.","open","in: test,","joshiste","2019-12-08T10:42:45Z","2021-10-29T08:37:38Z"
"","24593","Additional pom with groupId io.spring.asciidoctor","When releasing Spring Framework `5.2.4.RELEASE` I noticed an extra package on Bintray for `io.spring.asciidoctor`.  Looking at our snapshot repo, we've started to recently deploy an extra pom for that `groupId`:  https://repo.spring.io/snapshot/io/spring/asciidoctor/spring/  Maybe this is related to 02e90a8645d34389d?   I've removed the extra repo on Bintray. As part of fixing this we should also remove this pom from the snapshot repository.","closed","type: task,","snicoll","2020-02-25T18:47:00Z","2020-03-16T15:32:44Z"
"","24239","Remove quality parameter from chosen media type in WebFlux responses","When processing requests and working on the Content Negotiation for WebFlux Controller handlers, `HandlerResultHandlerSupport`:  * get the list of accepted media types from the request * get the list of producible media types from the handler * select the most specific, concrete media type and use it for the response  It seems that when doing so, WebFlux does not remove the quality parameter from the media type, which means that the response can have a response header like `Content-Type: application/json; q=0.9`.  This quality parameter is properly removed in `AbstractMessageConverterMethodProcessor` for Spring MVC, we should do the same here.","closed","type: enhancement,","bclozel","2019-12-20T13:33:44Z","2020-01-02T10:34:31Z"
"","24833","Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()'","When migrating from 5.2.3.RELEASE to 5.2.4.RELEASE the error message shows up: ""Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()'""  In 5.2.5.RELEASE shows up as well.  The logs: ``` INFO: Initializing Spring DispatcherServlet 'dispatcher' 2020-04-01 14:23:47,410 INFO [main] Initializing Servlet 'dispatcher' 2020-04-01 14:23:53,207 WARN [main] Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0': Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()' 2020-04-01 14:23:53,211 ERROR [main] Context initialization failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0': Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()' 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:882) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) ~[spring-context-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:702) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:668) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:716) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:591) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:530) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:170) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at javax.servlet.GenericServlet.init(GenericServlet.java:158) [servlet-api.jar:4.0.FR] 	at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1134) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1089) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:983) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4876) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5185) [catalina.jar:9.0.33] 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [catalina.jar:9.0.33] 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) [catalina.jar:9.0.33] 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) [catalina.jar:9.0.33] 	at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?] 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) [tomcat-util.jar:9.0.33] 	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) [?:?] 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:841) [catalina.jar:9.0.33] 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [catalina.jar:9.0.33] 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) [catalina.jar:9.0.33] 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) [catalina.jar:9.0.33] 	at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?] 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) [tomcat-util.jar:9.0.33] 	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) [?:?] 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) [catalina.jar:9.0.33] 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:421) [catalina.jar:9.0.33] 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [catalina.jar:9.0.33] 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:930) [catalina.jar:9.0.33] 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [catalina.jar:9.0.33] 	at org.apache.catalina.startup.Catalina.start(Catalina.java:633) [catalina.jar:9.0.33] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?] 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?] 	at java.lang.reflect.Method.invoke(Method.java:567) ~[?:?] 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:343) [bootstrap.jar:9.0.33] 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:474) [bootstrap.jar:9.0.33] Caused by: java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()' 	at org.springframework.web.servlet.resource.ResourceHttpRequestHandler.afterPropertiesSet(ResourceHttpRequestHandler.java:378) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	... 49 more abr. 01, 2020 2:23:53 P. M. org.apache.catalina.core.ApplicationContext log SEVERE: Servlet.init() para servlet [dispatcher] lanzó excepción org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0': Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()' 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:882) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) 	at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:702) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:668) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:716) 	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:591) 	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:530) 	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:170) 	at javax.servlet.GenericServlet.init(GenericServlet.java:158) 	at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1134) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1089) 	at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:983) 	at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4876) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5185) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:841) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:421) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:930) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:633) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:343) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:474) Caused by: java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()' 	at org.springframework.web.servlet.resource.ResourceHttpRequestHandler.afterPropertiesSet(ResourceHttpRequestHandler.java:378) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	... 49 more  abr. 01, 2020 2:23:53 P. M. org.apache.catalina.core.StandardContext loadOnStartup SEVERE: Servlet [dispatcher] in web application [/Intranet] threw load() exception java.lang.NoSuchMethodError: 'java.util.Map org.springframework.web.accept.ContentNegotiationManager.getMediaTypeMappings()' 	at org.springframework.web.servlet.resource.ResourceHttpRequestHandler.afterPropertiesSet(ResourceHttpRequestHandler.java:378) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:882) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) 	at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:702) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:668) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:716) 	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:591) 	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:530) 	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:170) 	at javax.servlet.GenericServlet.init(GenericServlet.java:158) 	at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1134) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1089) 	at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:983) 	at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4876) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5185) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:841) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:421) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:930) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:633) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:343) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:474) ```","closed","status: invalid,","o-frias","2020-04-01T12:36:55Z","2020-04-01T17:44:25Z"
"","23841","server.servlet.context-path has no impact on webmvc RouterFunction","When i use the new webmvc RouterFunction to define a REST rest service method the value of the property server.servlet.context-path does not become part of the URL the service is exported with. I have to specify the defined context-path explicitely when defining the router function. [demo.zip](https://github.com/spring-projects/spring-boot/files/3744352/demo.zip)  When i export the method using a `@RestController` bean then then the url starts with the context-path value as expected","closed","in: web,","urferr","2019-10-18T14:17:32Z","2019-10-31T15:07:08Z"
"","24273","Updating from 4.0.X to 5.2.2 breaks","When I try to upgrade spring-beans from 4.0.X to version after 4.1.0. The following code breaks. ``` public class MyBeanFactory implements BeanFactory {      @Override     public Object getBean(String name) throws BeansException {         return null;     }      @Override     public  T getBean(String name, Class requiredType) throws BeansException {         return null;     }      @Override     public  T getBean(Class requiredType) throws BeansException {         return null;     }      @Override     public Object getBean(String name, Object... args) throws BeansException {         return null;     }      @Override     public boolean containsBean(String name) {         return false;     }      @Override     public boolean isSingleton(String name) throws NoSuchBeanDefinitionException {         return false;     }      @Override     public boolean isPrototype(String name) throws NoSuchBeanDefinitionException {         return false;     }      @Override     public boolean isTypeMatch(String name, Class targetType) throws NoSuchBeanDefinitionException {         return false;     }      @Override     public Class getType(String name) throws NoSuchBeanDefinitionException {         return null;     }      @Override     public String[] getAliases(String name) {         return new String[0];     } }  ```  The code should pass, but it throws an error: ``` MyBeanFactory.java:[7,8] com.penghui.beanFacoryPostProcessorTest.beanFactory.MyBeanFactory is not abstract and does not override abstract method getBean(java.lang.Class,java.lang.Object...) in org.springframework.beans.factory.BeanFactory ```","closed","status: invalid,","SElab2019","2019-12-30T03:28:49Z","2019-12-30T08:14:52Z"
"","24277","gradle build problem build-scan","when i run the comman ""gradle build"",there is a problem which the description is ""The build scan plugin is not compatible with Gradle 6.0 and later. "".  gradle version is 6.0.1, java version is 13.0.1","closed","","makoto4423","2019-12-31T01:57:24Z","2019-12-31T08:28:54Z"
"","24467","Exception occur when building","When I build the latest spring-framework downloaded in the form of zip, I meet the following problem. Fail to excute ""git rev-parse --verify HEAD"", can you give me some advice?  ``` Build scan background action failed. org.gradle.process.internal.ExecException: Process 'command 'git'' finished with non-zero exit value 128         at org.gradle.process.internal.DefaultExecHandle$ExecResultImpl.assertNormalExitValue(DefaultExecHandle.java:409)         at org.gradle.process.internal.DefaultExecAction.execute(DefaultExecAction.java:38)         at org.gradle.process.internal.DefaultExecActionFactory.exec(DefaultExecActionFactory.java:145)         at org.gradle.groovy.scripts.DefaultScript.exec(DefaultScript.java:261)         at org.gradle.api.Script$exec$1.callCurrent(Unknown Source)         at build_scan_user_data_9wi7bqeuo81ab78i4yis7f9li.execAndGetStdout(C:\Project\Containers\spring-framework-master\gradle\build-scan-user-data.gradle:73)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:104)         at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:326)         at org.gradle.internal.metaobject.BeanDynamicObject$MetaClassAdapter.invokeMethod(BeanDynamicObject.java:479)         at org.gradle.internal.metaobject.BeanDynamicObject.tryInvokeMethod(BeanDynamicObject.java:191)         at org.gradle.groovy.scripts.BasicScript$ScriptDynamicObject.tryInvokeMethod(BasicScript.java:130)         at org.gradle.internal.metaobject.ConfigureDelegate.invokeMethod(ConfigureDelegate.java:77)         at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeOnDelegationObjects(ClosureMetaClass.java:398)         at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:338)         at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:68)         at build_scan_user_data_9wi7bqeuo81ab78i4yis7f9li$_addGitMetadata_closure1.doCall(C:\Project\Containers\spring-framework-master\gradle\build-scan-user-data.gradle:26)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:104)         at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:326)         at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:264)         at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1041)         at groovy.lang.Closure.call(Closure.java:411)         at groovy.lang.Closure.call(Closure.java:427)         at org.gradle.util.ClosureBackedAction.execute(ClosureBackedAction.java:71)         at org.gradle.util.ConfigureUtil.configureTarget(ConfigureUtil.java:154)         at org.gradle.util.ConfigureUtil.configure(ConfigureUtil.java:105)         at org.gradle.util.ConfigureUtil$WrappedConfigureAction.execute(ConfigureUtil.java:166)         at com.gradle.scan.plugin.internal.api.j.a(SourceFile:22)         at com.gradle.scan.plugin.internal.api.k$a.a(SourceFile:112)         at com.gradle.scan.plugin.internal.api.h.a(SourceFile:61)         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)         at java.util.concurrent.FutureTask.run(FutureTask.java:266)         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)         at java.lang.Thread.run(Thread.java:748) ```","closed","status: invalid,","chchzh1978","2020-02-01T15:31:04Z","2020-02-03T08:49:13Z"
"","24211","Un-deprecate PathResource (for java.nio.file.Path resolution in createRelative)","When creating a `FileSystemResource` with a `Path` containing `..` in the path, then `createRelative` resolves to a wrong path.  The problem resides on `StringUtils::applyRelativePath` method: I suggest change the method on `FileSystemResource` checking first if the location is a `Path` and then use `Path::resolve` instead calling  `StringUtils::applyRelativePath`.  ```kotlin println(FileSystemResource(Paths.get(""../xxxx/dist/"")).createRelative(""index.html"")) ``` print `../index.html` instead `../xxx/dist/index.html`.  Attached image shows the variables inside `FileSystemResource::createRelative` method.  ![bug](https://user-images.githubusercontent.com/6311119/70852892-01652900-1ea7-11ea-953c-04ce55992a50.png)","closed","type: enhancement,","userquin","2019-12-14T18:22:50Z","2019-12-16T15:52:18Z"
"","23910","PatternsRequestCondition combine bug fix","When combining the current `PatternsRequestCondition` instance and another, a new instance with combined URL patterns from both is created and returned. If the other instance sets other fields such as `useSuffixPatternMatch` and `useTrailingSlashMatch`, they are ignored as [the current instance (`this`) is supplied](https://github.com/spring-projects/spring-framework/blob/v5.2.0.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java#L195) to the [constructor instead of the `other` instance](https://github.com/spring-projects/spring-framework/blob/v5.2.0.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java#L128) presenting buggy behaviour while customizing path matching and URL treatment options.  see gh-23907","closed","status: superseded,","kwahome","2019-11-02T12:16:53Z","2019-11-07T14:22:50Z"
"","23842","WebClient: wrap connection exceptions","When calling a remote service, it's important to know if an exception happened before sending the request or after receiving the response.  Unfortunately, not all exceptions are wrapped by `WebClientResponseException`, `WebClientException `or another subclass of `WebClientException `when calling `webClient.retrieve().bodyToFlux()` resp. `webClient.retrieve().bodyToMono()`  E.g.: **Before request:**  - ` java.net.ConnectException`  - `io.netty.channel.ConnectTimeoutException`  - `io.netty.handler.timeout.ReadTimeoutException`  **After response:** - `org.springframework.core.codec.DecodingException`  `org.springframework.core.codec.CodecException` could happen before request and after response, I guess. How can we detect this?  I also might have missed some exceptions.  Exception handling would be much easier if the following rule could be implemented:  if the exception happens after the response -> wrap the exception with a `WebClientResponseException`, so we don't loose the http status code and the payload  else wrap the exception with a `WebClientException `or another subclass.  I'm not sure if this a bug or an enhancement request.","closed","type: enhancement,","puce77","2019-10-21T15:56:17Z","2020-09-14T13:11:27Z"
"","23979","JMS request/reply no possibility to reply with null","When a JMSListener is used and a reply header is set, the return value is sent as a reply to the reply header destination. But if you return null, this behavior is ignored. According the documentation this is OK. But I am wondering if something could be added so that a reply will be sent even if return value is null. In my opinion, if the reply header is set, I expect a reply.  In [apache camel](https://camel.apache.org/components/latest/jms-component.html) they provide a ""allowNullBody"" option. Maybe a setting like this could help.   I already tried to extend the MessagingMessageListenerAdapter and removed the if statement which checks if the return value is null. But then deeper in the code it fails because of Assert statements in GenericMessage and MessageBuilder. They expect always that the payload should not be null.    What do you think about this? @snicoll","closed","status: declined,","rroex","2019-11-12T09:14:06Z","2019-11-12T12:54:27Z"
"","24712","Non-public Kotlin beans can't be instantiated","When a bean definition from an XML file is instantiated, and the bean class is a Kotlin class that is not public (e.g. protected), or a non-public constructor is used, this fails with an `IllegalAccessException: class kotlin.reflect.jvm.internal.calls.CallerImpl$Constructor cannot access a member of class MyKotlinClass with modifiers ""protected""`.   This works fine for Java classes, so I believe that this should also work for Kotlin classes.  I managed to locate and fix the cause of this problem. It is in `BeanUtils.instantiateClass(Constructor ctor, Object... args)`.   Here, the provided constructor object is made accessible before it is being used to instantiate the bean.   Then, if the class that declares the constructor is a Kotlin class (and the `kotlin-reflect` jar is on the classpath; another prerequisite for this problem), the Kotlin `KFunction` object representing the Java constructor is obtained, and used to instantiate the bean.  Unfortunately, when this Kotlin constructor is used, the accessibility flag that was set on the original Java constructor object is not set. This is because the original Java constructor object is not the same object as the Java constructor object that is buried deep down in the Kotlin constructor object, what you might expect.  My fix sets the accessibility flag on the Kotlin constructor object itself, in a similar way as it is done for Java constructors.  I've added a test to `BeanUtilsTests` to ensure that a private Java class with a private constructor can be instantiated without problems. A few tests are added to `KotlinBeanUtilsTests` to ensure that this fix allows private and protected classes and constructors to be used.  I'm looking forward to your feedback.  Regards, Tom","closed","type: enhancement,","tomvandenberge","2020-03-17T21:00:00Z","2020-03-23T09:52:10Z"
"","24641","Inconsistent Behaviour for @RequestParam MultiValueMap and @RequestParam Collection with Delimiter String","When `@RequestParam Collection` is used, the `DelimitedStringToCollectionConverter` class is in the `ConverterRegistry` to convert the delimited string to a collection object. `?id=1,2` --> `List` with size = `2` and value as `[ ""1"", ""2"" ]`.  When `@RequestParam MultiValueMap` is used, the delimited string was not handled. `?id=1,2` --> `map.get(""id"")` --> `List` with size = `1` and value as `[ ""1,2"" ]`.  Is this intended?","closed","status: declined,","roger2hk","2020-03-04T12:36:46Z","2020-03-06T16:14:27Z"
"","24773","Improve method injection when @Autowired(require=false) on mixed nullability args method","When `@Autowired(require=false)` on mixed nullability args method, I think IOC container shoud call this method to inject partially non-null parameters, but in fact the current code logic will ignore this method injection, for example `:`  ```java 	static class MixedNullableInjectionBean{ 		public NonNullBean nonNullBean; 		public NullableBean nullableBean;  		@Autowired(required = false) 		public void nullabilityInjection(@Nullable NullableBean nullableBean, NonNullBean nonNullBean){ 			if(nullableBean != null){ 				this.nullableBean = nullableBean; 			} 			this.nonNullBean = nonNullBean; 		} 	} ```  ```java 	@Test 	public void testMethodInjectionWithMultiMixedNullableArgs(){ 		bf.registerBeanDefinition(""nonNullBean"", new RootBeanDefinition( 				NonNullBean.class)); 		bf.registerBeanDefinition(""mixedNullableInjectionBean"", new RootBeanDefinition(MixedNullableInjectionBean.class)); 		MixedNullableInjectionBean mixedNullableInjectionBean = bf.getBean(MixedNullableInjectionBean.class); 		assertThat(mixedNullableInjectionBean.nonNullBean).isNotNull(); 		assertThat(mixedNullableInjectionBean.nullableBean).isNull(); 	} ``` I liberated the `@Autowired(require=false)` annotation on the `nullabilityInjection` method of `MixedNullableInjectionBean`, this method has two parameters, `nullableBean` and `nonNullBean`, as the name of the parameter means, I only register `nonNullBean` to `DefaultListableBeanFactory`, and then register `MixedNullableInjectionBean` . I think the IOC container should invoke `nullabilityInjection` method to inject `nonNullBean`, but in fact the current code logic will ignore this method injection, I have expressed the nullability of the parameter `nullableBean`, so, I think this parameter is null should not affect the overall method injection. I slightly adjusted the logic of method injection in this pr, what do you think? Thank you for your reading and looking forward to your reply.","open","in: core,","chenqimiao","2020-03-25T02:50:09Z","2021-11-10T11:58:06Z"
"","24759","@Conditional bean called multiple times","Whats happening is that my project which implements the Condition interface is getting instantiated multiple times and its match method also gets called 3 times.if any logic in matches method will to be called 3 times,is necessary?","closed","","JerryJavaCoding","2020-03-22T14:22:16Z","2020-04-05T19:01:01Z"
"","24819","WebClient with reactor-netty fails to send multiple request cookies","WebClient only sends the first cookie to the server when multiple cookies are set in the request.  See the following test case for repro: https://github.com/spring-projects/spring-framework/blob/df32d7f026941fff2dc376d62cceb3424cd34d1f/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java#L625-L654  Reactor-netty implementation needed to be excluded to make the test pass: https://github.com/spring-projects/spring-framework/blob/df32d7f026941fff2dc376d62cceb3424cd34d1f/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java#L629-L632","closed","status: invalid,","martin-tarjanyi","2020-03-30T20:35:10Z","2020-03-31T08:31:41Z"
"","23935","Reading 'null' JSON response via WebClient fails in v5.2.x","WebClient is not able to read `null` JSON response in both v5.2.0 and v5.2.1, however at least in v5.1.x it works as expected and empty result was correctly retrieved.  ### Code to reproduce the problem Sample project with the failing test: [webclient-null-json-sample.zip](https://github.com/spring-projects/spring-framework/files/3808206/webclient-null-json-sample.zip)  ```java import static org.junit.jupiter.api.Assertions.assertNull;  import java.io.IOException; import java.util.Map; import okhttp3.mockwebserver.MockResponse; import okhttp3.mockwebserver.MockWebServer; import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import org.springframework.http.HttpHeaders; import org.springframework.http.MediaType; import org.springframework.web.reactive.function.client.WebClient;  class WebClientJsonNullTest {    //dependency: com.squareup.okhttp3:mockwebserver:4.2.2   private static MockWebServer mockWebServer;    @BeforeAll   public static void startMockWebServer() throws IOException {     mockWebServer = new MockWebServer();     mockWebServer.start();   }    @AfterAll   public static void shutdownMockWebServer() throws IOException {     mockWebServer.shutdown();   }    //this test is failing in v5.2, in v5.1 passes   @Test   void nullJsonResponse_shouldBeReadAsEmpty() {     WebClient webClient = WebClient.builder().build();      mockWebServer.enqueue(new MockResponse()         .setResponseCode(200)         .setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)         .setBody(""null""));      Map result = webClient.get()         .uri(mockWebServer.url(""/"").uri())         .retrieve()         .bodyToMono(Map.class)         .block();     assertNull(result);   } } ```  Following NPE is thrown: ```  java.lang.NullPointerException: The mapper returned a null value.  	at java.base/java.util.Objects.requireNonNull(Objects.java:246) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Body from GET http://localhost:54097/ [DefaultClientResponse] Stack trace: 		at java.base/java.util.Objects.requireNonNull(Objects.java:246) 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107) 		at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:103) 		at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:103) 		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) 		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:330) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1592) 		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145) 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 		at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:397) 		at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:197) 		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:345) 		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:363) 		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:412) 		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:556) 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302) 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) 		at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.base/java.lang.Thread.run(Thread.java:834) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:93) 		at reactor.core.publisher.Mono.block(Mono.java:1663) 		at WebClientJsonNullTest.nullJsonResponse_shouldBeReadAsEmpty(WebClientJsonNullTest.java:43) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 		at java.base/java.lang.reflect.Method.invoke(Method.java:566) 		at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675) 		at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:125) 		at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:132) 		at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:124) 		at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:74) 		at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:104) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:62) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:43) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:35) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:202) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:198) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:69) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229) 		at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197) 		at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 		at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69) 		at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 		at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 		at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)  ```  That `null` comes from decoding JSON response body via `Jackson2JsonDecoder`.","closed","type: regression,","ckubik-monster","2019-11-05T09:56:20Z","2019-11-11T15:58:17Z"
"","24042","SqlRowSet accessor methods should be marked @Nullable","We use `org.springframework.jdbc.support.rowset.SqlRowSet` in our project to extract data from PostgreSQL. Recently I found out that IntelliJ IDEA shows warning where it shouldn't be. ![image](https://user-images.githubusercontent.com/741251/69243130-6f257a00-0bb3-11ea-9def-cff779350091.png) As I understand it's because IDEA thinks that `SqlRowSet.getString` always return non-`null` value. But it's not true. It's because of `@NonNullApi` annotation in https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/support/rowset/package-info.java  Need to mark all `SqlRowSet`s methods which can return `null` as `@Nullable` to avoid static analyzer false-positive warnings.","closed","type: bug,","turbanoff","2019-11-20T13:38:07Z","2019-11-20T16:41:08Z"
"","24777","Document role of views within Spring application","We should add a section to the reference documentation that explains that views live within the trust boundary of the application, and the security implications thereof.","closed","in: web,","poutsma","2020-03-25T13:57:37Z","2020-03-25T14:07:36Z"
"","23949","Use Method::getParameterCount where possible","We often use `Method.getParameterTypes()` which clones underlying array: ```java @Override public Class[] getParameterTypes() {     return parameterTypes.clone(); } ``` The problem is that array is often used only to get its length, so we allocate memory mostly in vain.  Instead in numerous cases we call `Method.getParameterCount` introduced in Java 8: ```java public int getParameterCount() { return parameterTypes.length; } ``` which doesn't allocate.  In cases where we still need parameter types we can postpone retrieving it until it becomes inevitable.","closed","type: enhancement,","stsypanov","2019-11-07T16:14:38Z","2019-11-08T10:32:22Z"
"","24646","CodecException (from JSON conversion) in RestController is not mapped to 400 but 500 (SB 2.2.5 & Kotlin)","We just upgraded our **Kotlin** project from Spring Boot 2.2.4 to 2.2.5.  Unfortunately now some **WebFlux**-RestController tests fail because a mandatory JSON payload field now leads to a _500 Internal Server Error_ instead of a _400 Bad Request_.  This is an exemplary RestController with its Kotlin data class for the request payload:  ``` @RestController class Controller {      @PostMapping(""/hello"")     fun post(@RequestBody request: RequestPayload) =         ResponseEntity.ok().body(""Hello ${request.foo} - ${request.bar}"")  }  data class RequestPayload(     val foo: String,     val bar: String? )  ```  Please notice that attribute _foo_ is mandatory (no `?`).  This is the invalid payload (missing JSON field `foo`): `{      ""bar"": ""bar text""  } `  When calling this RestController in a **Spring Boot 2.2.4** app this results in a **_DecodingException_** which is correctly mapped to the status code **400**.  But when calling this RestController in a **Spring Boot 2.2.5** app this leads to **_CodecException_** which is **not** mapped to the status code 400 but results in a **500**.  Please find the example in my GitHub repo: https://github.com/csh0711/boot-2-2-5-kotlin-codec-exception  Or use this ControllerTest:   ``` @WebFluxTest(Controller::class) internal class ControllerTests(     @Autowired private val webTestClient: WebTestClient ) {     @Test     fun `responds with HTTP 400 BAD_REQUEST for missing foo in payload`() {         webTestClient.post()             .uri(""/hello"")             .contentType(MediaType.APPLICATION_JSON)             .bodyValue("""""" { ""bar"": ""bar text"" } """""")             .exchange()             .expectStatus().isBadRequest     } } ```  Many thanks in advance! :-)","closed","type: regression,","csh0711","2020-03-03T16:27:29Z","2020-03-11T13:57:24Z"
"","24630","Invalid JSON in requests now causes 500 instead of 400","We just updated to Spring 5.2.4 and are seeing 500 instead of 400 for requests like this: ``` {     ""bracket_not_closed"": [ } ``` With 5.2.3 we'd see: ``` {     ""timestamp"": ""2020-03-02T20:51:06.580+0000"",     ""path"": ""/cards/requests"",     ""status"": 400,     ""error"": ""Bad Request"",     ""message"": ""Failed to read HTTP message"",     ""requestId"": ""5ef79eec"" } ``` With 5.2.4 we see: ``` {     ""timestamp"": ""2020-03-02T20:30:13.032+0000"",     ""path"": ""/cards/requests"",     ""status"": 500,     ""error"": ""Internal Server Error"",     ""message"": ""JSON conversion problem: Unexpected close marker '}': expected ']' (for Array starting at [Source: (io.netty.buffer.ByteBufInputStream); line: 2, column: 22]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: Unexpected close marker '}': expected ']' (for Array starting at [Source: (io.netty.buffer.ByteBufInputStream); line: 2, column: 22])\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 4, column: 1] (through reference chain: com.vmware.platform.objects.request.ObjectRequests[\""card_requests\""])"",     ""requestId"": ""5505890a-13"" } ```  This appears to have been caused by the fix for #24455 I'm not sure if it's exactly the same issue as #24610","closed","type: regression,","rworsnop","2020-03-02T20:54:09Z","2020-03-11T13:57:24Z"
"","24302","How to dynamically change the broker in runtime while sending messages from application to clients","We have a requirement to evenly distribute the load say if we have two stomp brokers both should share the load. We have created a RoundRobin to dynamically give a different host name each time. It is working fine when a websocket client tries to connect to StompBrokerRelay. But when the application tries to send message to the broker or to the client(using convertAndSendToUser()) it is always taking the first tcpClient hostname which is registered. Below I have added the code snippet. From the websocket docs i could read system connection comes in when a application tries to send messages to the stomp broker. Can't we override hostname here as we did for websocket connection? Or am I missing something here. Could you please advice.  ```java public WebSocketConfig() {     List hostArray = new ArrayList();     String amqStompUrl = config.getString(AMQ_STOMP_URL).orElse(LOCALHOST);     Stream.of(amqStompUrl.split(COMMA_SEPARATE)).forEach(hostArray::add);     stringHostRoundRobin = new HostRoundRobin(hostArray); } ```  **configureMessageBroker**:  ```java brokerRegistry.enableStompBrokerRelay(DESTINATION_PREFIX)           .setUserDestinationBroadcast(UN_RESOLVED_USER_DESTINATION)           .setUserRegistryBroadcast(""/topic/simp-user-registry"")           .setClientLogin(clientLogin)           .setClientPasscode(clientPasscode)           .setSystemLogin(systemLogin)           .setSystemPasscode(systemPasscode)           .setTcpClient(createTcpClient());  Supplier socketAddressSupplier() {     int amqStompPort = config.getInt(AMQ_STOMP_PORT).orElse(AMQ_STOMP_PORT_DEFAULT);     String nextHost = getNextHostName();     Supplier socketAddressSupplier = () -> new InetSocketAddress(nextHost, amqStompPort);     return socketAddressSupplier; }  private String getNextHostName() {     return stringHostRoundRobin.iterator().next(); }  private ReactorNettyTcpClient createTcpClient() {     return new ReactorNettyTcpClient<>(client -> client.addressSupplier(() -> socketAddressSupplier().get()), new StompReactorNettyCodec()); } ```","closed","status: declined,","sharmilay2k","2020-01-06T14:12:56Z","2020-01-15T09:50:17Z"
"","23854","Get null result when using RefreshScope annotation with Kotlin","We found following Kotlin code will return null when we call it by http://localhost:8080/message, which should be 'Hello default'  @RestController @RefreshScope open class MessageRestController {      @Value(""\${message:Hello default}"")     @get:RequestMapping(""/message"")     internal val message: String? = null } If we changed it to Java, it works well  used Spring version: spring boot 2.1.6 spring-cloud-dependencies Greenwich.SR3  is this a know issue?","closed","","newry","2019-10-23T21:07:05Z","2021-01-08T13:09:14Z"
"","23912","component-scan load beans in unfixed order in different machine","we find the bean load order is different for component-scan in different machine, is this a bug?","closed","for: stackoverflow,","jessin20161124","2019-11-03T09:04:55Z","2019-11-03T09:24:51Z"
"","24395","Thread BLOCKED issues of DestinationCache in DefaultSubscriptionRegistry","We are using the spring-messaging to implement a STOMP server (using SimpleBrokerMessageHandler). The Client will subscribe on 5 channel and everything is ok when there are only a few users. However, when the online user is above ~ 700, the websocket channel is ""out of response"".  After analysis, I found many other thread has been ""BLOCKED"" by DestinationCache, as follows:  ```bash ""pk-ws-worker-100-thread-78"" #560 prio=5 os_prio=0 tid=0x00007ff19c182000 nid=0x1252 waiting for monitor entry [0x00007ff0a8d9f000]    java.lang.Thread.State: BLOCKED (on object monitor)         at org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry$DestinationCache.getSubscriptions(DefaultSubscriptionRegistry.java:269)         - waiting to lock <0x00000004c007ec20> (a org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry$DestinationCache$1) ```  And part of the code are as follows:  ```java public LinkedMultiValueMap getSubscriptions(String destination, Message message) {   LinkedMultiValueMap result = this.accessCache.get(destination);   if (result == null) {     synchronized (this.updateCache) {       result = new LinkedMultiValueMap<>();       for (SessionSubscriptionInfo info : subscriptionRegistry.getAllSubscriptions()) {         for (String destinationPattern : info.getDestinations()) {           if (getPathMatcher().match(destinationPattern, destination)) {             for (Subscription sub : info.getSubscriptions(destinationPattern)) {               result.add(info.sessionId, sub.getId());             }           }         }       }       if (!result.isEmpty()) {         this.updateCache.put(destination, result.deepCopy());         this.accessCache.put(destination, result);       }     }   }   return result; } ``` As you can see, the code inside synchronized will traverse all subscription, which will cost too much time and block other Thread.  Also, the accessCache / updateCache is not works if the client has not success make the subscription, which will make the situation worse.  We try to increase the cache limit and it does't work for our case.  To solve the problem, we remove the DestinationCache and reimplement an Map ->  subsId> inside SessionSubscriptionRegistry. (in our own codebase of course)  After theses change, the server can handle more than 5K online users with no problem.  Meanwhile, I noticed that DefaultSubscriptionRegistry and DestinationCache has been there for many years.  So, I just wonder is it ok to make a pr? Or the existing DestinationCache is good for some other reason?","closed","status: superseded,","liheyuan","2020-01-19T11:12:03Z","2021-05-27T06:01:40Z"
"","24544","WebClient builder call from one microservice to another microservice giving bad request error for first time in Webflux","We are making use of WebClient Builder call for communication among micro services in our project.It's springboot-thymleaf-webflux based application.Everything is running fine till now but we got a requirement from Client to change GET call to POST call in thymleaf controller.After making these changes at UI and Backend,Thymleaf calls are working fine but one of the XHR i.e post call from UI-- is giving bad request error for WebClient call to second microservice for first click and working for second click.I compared header and request for both click did not find any difference.I am not able to understand why WebClient behaving abnoramlly first time and working fine second time.   Below is code snippet for WebClient call and it is routing to WebClientResponseException without hitting to second microservice by saying BAD Request for `http://second-microservice -eureka-address/endpoint-url`  ```java      * Submitting xyz       * @param submitFlowRequest      */ @Override public Mono> submitFlow(SubmitFlowRequest submitFlowRequest,         Map headers) {      long startTime = System.currentTimeMillis();     String uri = propertyConfig.getAggregationService()             + propertyConfig.getAggregationSubmitCCInfoURL();     DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(uri);     factory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT);     MultiValueMap clientHeaders = buildHeaders(headers);     return webClientBuilder.uriBuilderFactory(factory).build().post()             .headers(httpHeaders -> httpHeaders.addAll(clientHeaders)).accept(MediaType.APPLICATION_JSON)             .syncBody(submitFlowRequest).retrieve().bodyToMono(ApiResponse.class)             .onErrorMap(ConnectException.class,                     error -> new VzwRuntimeException(ErrorCodeEnum.V404.toString(), Constants.OPP_TC_SYSTEM_ERROR,                             (Constants.CONNECTION_FAILURE_TEXT + Constants.AGGREGATION)))             .onErrorMap(WebClientResponseException.class,                     error -> new VzwRuntimeException(ErrorCodeEnum.V404.toString(), Constants.OPP_TC_SYSTEM_ERROR,                             (Constants.CONNECTION_FAILURE_TEXT + Constants.AGGREGATION)))             .flatMap(res -> {                 Audit apiAudit = Audit.builder().apiUrl(uri).request(LoggerUtil.asJson(submitFlowRequest))                         .response(LoggerUtil.asJson(res))                         .executionTime(String.valueOf(System.currentTimeMillis() - startTime))                         .headers(LoggerUtil.asJson(clientHeaders)).transactionType(res.getData()!=null?mapper.map(res.getData(), SubmitResponse.class).getTransactionType():"""").build();                 LoggerUtil.logExternalApiCalls(apiAudit);                 return Mono.just((ApiResponse) res);             }); } ```  Please provide me some lead.I am tired of finding solution for this.","closed","status: invalid,","manuj20","2020-02-17T16:53:00Z","2020-02-21T09:59:24Z"
"","24228","Add support for registration of additional JMS endpoints at runtime","We are looking into using the `JmsListenerEndpointRegistry` to dynamically register and unregister listener containers during the runtime of the application. However, unregistering a container is currently not possible in the moment. Is there a reason for this? Is it possible to add a method that would allows us to unregister a container in a similar way as you can register one?  If something like this is accepted by the team I am willing to do a PR to add the functionality.","open","status: feedback-provided,","filiphr","2019-12-18T15:06:20Z","2021-11-10T11:41:09Z"
"","24561","ConcurrentModificationException when executing AutowireCapableBeanFactory.createBean","We are facing Initialization of bean failed; nested exception is java.util.ConcurrentModificationException and we are using Akka framework 2.6.3, Apache AVRO-1.9.2 and these are in classpath spring-boot-2.0.1.release and spring framework (bean,context,core,web) 5.0.5 release     below are the error stack. please help me what needs to be done to resolve this issue    ```  akka.actor.ActorInitializationException: exception during creation  	at akka.actor.ActorInitializationException$.apply(Actor.scala:166)  	at akka.actor.ActorCell.create(ActorCell.scala:596)  	at akka.actor.ActorCell.invokeAll$1(ActorCell.scala:456)  	at akka.actor.ActorCell.systemInvoke(ActorCell.scala:478)  	at akka.dispatch.Mailbox.processAllSystemMessages(Mailbox.scala:263)  	at akka.dispatch.Mailbox.run(Mailbox.scala:219)  	at akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(AbstractDispatcher.scala:397)  	at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)  	at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)  	at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)  	at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)          Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with          name 'messageHandlerActor' defined in file [/Users/muv416/intellij_workplace/decision-          engine/stellar/target/classes/com/fs/decisionengine/stellar/actor/MessageHandlerActor.class]:          Initialization of bean failed; nested exception is java.util.ConcurrentModificationException  	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:587)  	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:501)  	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)  	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)  	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1089)  	at com.capitalone.fs.decisionengine.stellar.common.SpringActorProducer.produce(SpringActorProducer.java:26)  	at akka.actor.Props.newActor(Props.scala:255)  	at akka.actor.ActorCell.newActor(ActorCell.scala:552)  	at akka.actor.ActorCell.create(ActorCell.scala:578)  	... 9 common frames omitted          Caused by: java.util.ConcurrentModificationException: null  	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)  	at java.util.ArrayList$Itr.next(ArrayList.java:859)  	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1341)  	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:578)  	... 17 common frames omitted ```","closed","status: duplicate,","syedkither","2020-02-21T02:57:12Z","2020-02-24T13:41:03Z"
"","24442","Re-ordering Stream APIs","We are conducting a research project on re-ordering Stream APIs for improving program execution speed.  Before and after re-ordering, we measured running time of tests which execute target Stream. Command for running tests is :  `time ./gradlew -Dtest.single=RestTemplateTests test`  and the result is : ``` the order of Stream API      test running time =============================================== distinct().sorted()                 50.165s sorted().distinct()                 47.752s ```","closed","status: invalid,","HirotoTanaka114","2020-01-27T23:20:30Z","2020-01-29T19:01:37Z"
"","24317","illegal reflective access on SpringBoot 2.1.2","WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access using Lookup on org.springframework.cglib.core.ReflectUtils (file:/home/user/.m2/repository/org/springframework/spring-core/5.1.4.RELEASE/spring-core-5.1.4.RELEASE.jar) to class java.lang.Object WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release  **Spring boot : 2.1.2** **java : OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.5+10)**","closed","status: duplicate,","xbaker","2020-01-08T13:46:15Z","2020-04-11T08:04:59Z"
"","24184","@Autowired @RequestScope bean identity changed randomly in the middle of a loop within an @Async method","Versions: Spring Boot 2.2.2, Spring Cloud Hoxton.RELEASE Runnable demo: https://drive.google.com/open?id=1ThjcCoJToHKAhWYhpOIyGzi9xIoYtxRY  In my application, I have the following `@Configuration` to add support for `@RequestScope` bean within `@Async` methods.      @Configuration     @EnableAsync     public class AsyncExecutionConfiguration extends AsyncConfigurerSupport {`         public static final String ASYNC_THREAD_NAME_PREFIX = ""async-worker-"";          @Override         @Primary         @Bean(""taskExecutorWithClonedRequestContext"")         public Executor getAsyncExecutor() {             ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();             // Copy the current RequestContext to each and every new @Async task             executor.setTaskDecorator(new RequestContextCloningDecorator());             executor.setCorePoolSize(5);             executor.setMaxPoolSize(10);             executor.setQueueCapacity(20);             executor.setThreadNamePrefix(ASYNC_THREAD_NAME_PREFIX);             executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());             executor.initialize();              return executor;         }     }  I'm using the following `RequestContextCloningDecorator` to clone the request context on every `@Async` call.      public class RequestContextCloningDecorator implements TaskDecorator {         @Nonnull         @Override         public Runnable decorate(@Nonnull Runnable runnable) {             RequestAttributes requestContext = this.cloneRequestAttributes(RequestContextHolder.currentRequestAttributes());                  return () -> {                 try {                     RequestContextHolder.setRequestAttributes(requestContext);                     runnable.run();                      } finally {                     RequestContextHolder.resetRequestAttributes();                      }             };         }              private RequestAttributes cloneRequestAttributes(RequestAttributes requestAttributes) {             ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) requestAttributes;                  try {                 RequestAttributes clonedRequestAttribute = new ServletRequestAttributes(servletRequestAttributes.getRequest(), servletRequestAttributes.getResponse());                      // Since we're not using session scope, we only need to copy request scope attributes                 String[] scopeAttributes = requestAttributes.getAttributeNames(RequestAttributes.SCOPE_REQUEST);                 if (scopeAttributes.length > 0) {                     for (String attrName : scopeAttributes)                         clonedRequestAttribute.setAttribute(attrName,                                                             requestAttributes.getAttribute(attrName, RequestAttributes.SCOPE_REQUEST),                                                             RequestAttributes.SCOPE_REQUEST);                 }                      return clonedRequestAttribute;                  } catch (Exception e) {                 return requestAttributes;                  }         }     }  Everything has worked fine so far until I have a new feature which involves an `@Async` method with a loop inside of it. I can reproduce the bug consistently with 3 simple beans.  First, this is the `RequestScopeBean` which does nothing but holding an `int` value, default to 99.      @RequestScope     @Component     public class RequestScopeBean {         private int value = 99;              public void updateValue(int newValue) {             value = newValue;         }              public int getCurrentValue() {             return value;         }     }  This is the `@Service` which contains an `@Async` method with a loop inside.      @Service     public class AsyncService {         @Autowired         private RequestScopeBean mrBean;              @Async         public void loopAsync() {             for (int i = 0 ; i < 1000 ; i++) {                 if  (mrBean.getCurrentValue() != 1234) {                     System.out.println(""================="");                     System.out.println(""SERVICE BEAN: "" + mrBean);                     System.out.println(""INDEX: "" + i + "" - CUR VALUE: "" + mrBean.getCurrentValue());                 }             }         }     }  Finally, this is our entry point.      @RestController     @RequestMapping(""/async"")     public class AsyncController {         @Autowired         private AsyncService asyncService;              @Autowired         private RequestScopeBean mrBean;              @GetMapping(""/test"")         public void test() {             mrBean.updateValue(1234);                  System.out.println(""================="");             System.out.println(""CONTROLLER BEAN: "" + mrBean);             System.out.println(""CUR VALUE: "" + mrBean.getCurrentValue());                  asyncService.loopAsync();         }     }  When I call this endpoint, I'll see something like this.      =================     CONTROLLER BEAN: com.ft.demo.helper.RequestScopeBean@2278b137     CUR VALUE: 1234     =================     SERVICE BEAN: com.ft.demo.helper.RequestScopeBean@1f1b5a8c     INDEX: 865 - CUR VALUE: 99     =================     SERVICE BEAN: com.ft.demo.helper.RequestScopeBean@1f1b5a8c     INDEX: 866 - CUR VALUE: 99     =================     SERVICE BEAN: com.ft.demo.helper.RequestScopeBean@1f1b5a8c     INDEX: 867 - CUR VALUE: 99     ......     =================     SERVICE BEAN: com.ft.demo.helper.RequestScopeBean@1f1b5a8c     INDEX: 999 - CUR VALUE: 99  Within the loop, at any random point of time, the `@RequestScope` bean will suddenly be swapped with a brand new instance, which carries the default value instead of the updated value.   When I wrote my code, I mainly referred to the solutions suggested in this [StackOverflow question](https://stackoverflow.com/questions/23732089/how-to-enable-request-scope-in-async-task-executor). If there's a better way to do this, please let me know. Otherwise, I think we should have a fix for this buggy behaviour? :)","closed","status: invalid,","jamestrandung","2019-12-11T02:18:06Z","2020-01-16T09:55:49Z"
"","24275","Mongo Conditional Aggregation Expression: thenValueOf(field) does not append ""$"" to field reference","Version: Srping boot 2.1.5.RELEASE I tried this:   AggregationExpression someBool = Gt.valueOf(someField).greaterThanValue(0); 		Cond cond = ConditionalOperators.when(someBool) 				.thenValueOf(fieldRef1) 				.otherwiseValueOf(fieldRef2);  This produces the following query:   ""$cond"": {                                     ""if"": {                                         ""$gt"": [                                             ""$someField"",                                              0                                         ]                                     },                                     ""then"": ""fieldRef1"",                                     ""else"": ""$fieldRef2""                                 }   But the ""then"" clause should be : ""then"": ""$fieldRef1"". I assume the missing $ is a bug.  best wishes","closed","for: external-project,","andoneN4","2019-12-30T14:02:58Z","2019-12-30T14:08:30Z"
"","24690","loadtimeweaver  not work","version: springframework 5.2.3.RELEASE I found that when instantiating loadtimeweaver, the bean I defined has been loaded.So when instantiating bean, it does not go through classFileTransform.","open","in: core,","liuaixi200","2020-03-13T13:01:11Z","2021-11-12T12:08:04Z"
"","23934","Different behavior when injecting beans from local @Configuration class vs. external @Configuration classes","Version: 5.2.1.RELEASE  Given the following configuration:  ```java @Configuration public class BaseTestConfig {      @Autowired     private Collection strings;      @Bean     public String stringA() {         return ""A"";     }      @Bean     public String stringB() {         return ""B"";     }       @Bean     public DemoClass demoBean() {         System.out.println(""Base config autowired strings: "" + strings.size());         return new DemoClass(strings);     }      class DemoClass {         private final Collection strings;          public DemoClass(Collection strings) {             this.strings = strings;         }          public Collection getStrings() {             return strings;         }     }  } ```  When `demoBean` is instantiated, it prints:   > Base config autowired strings: 2  If we add another config file with content:  ```java @Configuration public class Extension1TestConfig {      @Bean     public String stringC() {         return ""C"";     }  } ```  when `demoBean` is instantiated, it prints:   > Base config autowired strings: 1  We expect to have the 3 string beans injected into `demoBean` (2 beans of `BaseTestConfig` and 1 bean of `Extension1TestConfig`). However, as soon as another configuration file is declaring some String beans, the beans declared in `BaseTestConfig` are not injected anymore in the collection (strings) and only the beans of the other context(s) are injected.","closed","in: core,","aposcia","2019-11-05T09:37:20Z","2019-11-18T09:36:32Z"
"","24501","Raise log level for exceptions from EntityManager close call","Version 5.1.9  In `EntityManagerFactoryUtils::closeEntityManager` there is a catch-all for `Throwable` which logs any exception on `DEBUG` level. It would be very helpful if the level could be increased to `ERROR`. In our multi-tenancy project we're using a custom `ConnectionProvider` which threw an exception, but we didn't see it in the logs and it took us a day to track down the problem.","closed","type: enhancement,","mirkoadebahr","2020-02-11T08:58:34Z","2020-02-12T16:14:13Z"
"","24159","WebFluxLinkBuilder disregards path set in exchange","Version 1.0.1  WebFluxLinkBuilder doesn't seem to take the path from the current exchange into account.   See this method at the end of the class: ``` private static Function getBuilderCreator(UriComponentsBuilder exchange) {    return path -> exchange.replacePath(path == null ? ""/"" : path); } ```   The full request path is replaced by just the controller mapping, so some information is potentially lost. For example these 2 use cases don't generate correct links:  - x-forwarded-prefix header (processed by ForwardedHeaderTransformer) - setting a context path https://stackoverflow.com/questions/49196368/context-path-with-webflux","closed","for: external-project,","ctytgat","2019-12-07T21:24:17Z","2019-12-09T08:46:31Z"
"","24605","Distributions no longer deployed","Usually I can find a full dist of the spring releases at: https://maven.springframework.org/release/org/springframework/spring/ 5.2.4 does not seem to have been posted despite most of the modules now being available on Maven central.","closed","type: regression,","JohnZ1385","2020-02-27T17:36:36Z","2020-03-24T13:41:57Z"
"","24492","Use try-with-resource instead of try-finally to close stream","Use try-with-resource instead of try-finally to close stream, and merge two try blocks into one. This looks more concise.","closed","in: core,","chenqimiao","2020-02-08T15:17:19Z","2020-03-10T01:12:59Z"
"","24628","Specify MockHttpServletRequest object instance to use in MockMvc perform() method","Use case:  say for instance i'm using mocking frameworks such as PowerMock, EasyMock and I have components within my controller that accept HttpServletRequest as an argument. Most of these frameworks rely on ArgumentMatchers that invoke the equals() methods to compare expected arguments versus actual ones. In the case of Mockmvc a new instance of MockHttpServletRequest is always created because it accepts a builder, so the following tests will always fail. One option would be to use a broader matcher of course, but ideally if I could specify the MockHttpServletRequest object instance to use that would work better.  As far as I can tell there is no way I can specify the instance of MockHttpServletRequest instantiated when I perform a call using mockMvc such as: ```java     mockMvc.perform(get(""/myPath"")); ``` because the perform method accepts a Builder.  I know that I can build the request myself (i.e)  ```java Integer id = new Integer(1);  MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.post(""/myPath"").param(Constants.ID, id.toString());  MockHttpServletRequest request = requestBuilder.buildRequest(wac.getServletContext()); ``` and then pass that into the perform() method but still creates an object id mismatch which is problematic when you are using testing matcher frameworks and the object does not override the equals() method. Obivously I could use a broader matcher but ideally I'd rather not do that. I could get a hold of the request with a   Example source and test:   ```java   @Autowired   private MyService myService;      @GetMapping(value = ""/myPath"")   public ModelAndView getDetail(HttpServletRequest request) {     myService.invokeSomeMethod(request);   }    MyService myServiceMock = EasyMock.createMock(MyService.class);   MockHttpServletRequest mockRequest = new MockHttpServletRequest();    EasyMock.reset(myService);   myService.invokeSomeMethod(request);   /* this will always fail as MockHttpServletRequest does not override equals() so the default Object.equals() is used ..        and the mockMvc.perform method creates its own instance of MockHttpServletRequest */   EasyMock.expectLastCall();   EasyMock.replay(myService);    mockMvc.perform(get(""/myPath"").andExpect(status().is(HttpStatus.OK.value()));    EasyMock.verify(myService);`  ```  I suppose I could dance around the problem using the RequestPostProcessor but that seems ugly.","closed","in: web,","JohnZ1385","2020-03-02T19:26:25Z","2020-03-13T09:34:31Z"
"","24316","Fix race condition for InputStreamResource","Use AtomicBoolean instead of primitive boolean","closed","status: declined,","quaff","2020-01-08T03:37:41Z","2020-01-09T12:24:23Z"
"","23882","Fixing NPE in AbstractNamedValueMethodArgumentResolver","Upgrading one of our apps to Spring Boot 2.2.0.RELEASE (with Spring 5.2.0.RELEASE) is blocked by a null pointer exception in AbstractNamedValueMethodArgumentResolver that occurs whenever we are trying to receive a message via an `SqsListener`.  My approach is to undo https://github.com/spring-projects/spring-framework/commit/5b3b0b1a7b01b0ee752ee5e100d1238e9c6fdddf#diff-ba4bc09499d8cbf059d24ea9c6062b9cL82","closed","type: regression,","dekelpilli","2019-10-29T01:16:31Z","2019-11-01T10:21:04Z"
"","24595","UnknownHttpStatusCodeException is missing the response body","Updates	`DefaultResponseErrorHandler.handleError(ClientHttpReponse)` to read the response body once and reuse it for creating exception message and parameter.","closed","type: regression,","awoodbury","2020-02-25T23:34:22Z","2020-03-17T16:16:43Z"
"","24831","Update spring-doc-resources version","Update the spring-doc-resources version to get the latest look and feel.","closed","type: task,","Buzzardo","2020-03-31T18:28:43Z","2020-04-01T12:54:51Z"
"","24145","Support variable resolution of wildcard types","Update `ResolvableType` so that variable referenced can be resolved against wildcard types. Prior to this commit, given a type:  	Map>  Calling `type.getGeneric(1).asCollection().resolveGeneric()` would return `null`. This was because the `List` variable `E` referenced a wildcard type which `resolveVariable` did not support.","closed","type: enhancement,","philwebb","2019-12-05T21:30:33Z","2019-12-06T12:48:43Z"
"","24439","Add support for URIs with underscore","Underscores are valid in URIs https://www.ietf.org/rfc/rfc3986.txt but has long been ignored in jdk https://bugs.openjdk.java.net/browse/JDK-8019345  Could we provide a Spring URI class (and supporting classes like `UriComponentsBuilder`) that supports this?  ```java URI uri = UriComponentsBuilder.fromUriString(""https://endpoint_with_underscore"").build().toUri(); ```  results in   ``` java.lang.IllegalStateException: Could not create URI object: Illegal character in hostname at index 16: https://endpoint_with_underscore  	at org.springframework.web.util.HierarchicalUriComponents.toUri(HierarchicalUriComponents.java:516) 	at org.springframework.cloud.gateway.filter.ForwardRoutingFilterTests.uriWithUnderscore(ForwardRoutingFilterTests.java:75) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) 	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:44) 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:74) 	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:80) 	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:39) 	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) Caused by: java.net.URISyntaxException: Illegal character in hostname at index 16: https://endpoint_with_underscore 	at java.net.URI$Parser.fail(URI.java:2848) 	at java.net.URI$Parser.parseHostname(URI.java:3387) 	at java.net.URI$Parser.parseServer(URI.java:3236) 	at java.net.URI$Parser.parseAuthority(URI.java:3155) 	at java.net.URI$Parser.parseHierarchical(URI.java:3097) 	at java.net.URI$Parser.parse(URI.java:3053) 	at java.net.URI.(URI.java:673) 	at org.springframework.web.util.HierarchicalUriComponents.toUri(HierarchicalUriComponents.java:512) 	... 29 more ```  Various issues: - https://github.com/r2dbc/r2dbc-spi/issues/155 - https://github.com/spring-cloud/spring-cloud-gateway/issues/851 - https://github.com/spring-cloud/spring-cloud-gateway/issues/543 - https://github.com/spring-cloud/spring-cloud-netflix/issues/263 - https://github.com/spring-cloud/spring-cloud-commons/issues/159","closed","for: external-project,","spencergibb","2020-01-27T16:17:33Z","2022-06-07T10:28:30Z"
"","24140","Cannot override conversion service with custom one","Tried this on 5.0.x, 5.1.x, and 5.2.x.  I have a simple webapp for a REST API, WAR file, hosted on Tomcat. Root and webapp context as usual configured in `web.xml`.  I wrote a simple converter:  ```java @Component public class RecordEtagConverter implements Converter {  	@Override 	public RecordEtag convert(String source) {  		if (source.startsWith(""W/"")) 			throw new IllegalArgumentException(""weak ETags are not supported"");  		if (!source.startsWith(""\"""") && !source.endsWith(""\"""")) 			throw new IllegalArgumentException(""ETag must be enclosed in double qoutes"");    		return null; 	}  } ```  according to [chapter 3.4.5](https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#core-convert-Spring-config) I have added to my `servlet-context.xml`:  ```xml  	 		 			 		 	  ````   When I invoke the controller I only get converter not found, manually wiring `ConversionService` in my controller gives me:  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'projectController': Unsatisfied dependency expressed through field 'conv'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'org.springframework.core.convert.ConversionService' available: expected single matching bean but found 2: org.springframework.format.support.FormattingConversionServiceFactoryBean#0,conversionService 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:598) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:376) ```  This basically means that the default conversion service is not replaced. I have debugged the `TypeConverterDelegate` and my custom converter does not even appear with the `PropertyEditor`. I have also moved the conversion service bean to the root context. Same effect.","closed","status: invalid,","michael-o","2019-12-05T08:51:44Z","2019-12-09T15:14:33Z"
"","24237","Add new  element in the tool namespace","To safely deprecate XML elements from namespaces it would be nice to be able to express that deprecation in the XSD for the namespace. Spring already defines a `tool` namespace that contains information to let IDEs evaluate information to apply additional verifications, show warnings etc.  A new `` element could take a `message` attribute that'd allow XSD authors to mark an element as deprecated and provide additional information to give users a hint to what to use instead and also when they have to expect the eventual removal of that element.  @martinlippert indicated he'd already be looking into what it'd take to let the current generation of STS use such element. I guess it's worth pinging the IntelliJ folks as well.","open","type: enhancement,","odrotbohm","2019-12-20T09:43:30Z","2020-01-10T09:17:31Z"
"","24276","[spring expression doc] symbolic logical operators","To make it clear that symbolic logical operators are supported.","closed","type: documentation,","honnix","2019-12-30T16:07:07Z","2019-12-31T17:58:56Z"
"","24337","Update throwable to SQLException","To be as specific as possible in catching exceptions. As far as I can see, there is no problem.","closed","type: enhancement,","hyeonisism","2020-01-13T10:32:34Z","2020-02-09T14:52:11Z"
"","24375","Nested annotations no longer supported in ASM-based annotation processing","tl;dr  Build https://github.com/AndreasKl/spring-issue-in-TypeMappedAnnotation the test fails with the following exception:  ``` org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [.../demo/DemoApplicationTests.class]; nested exception is java.lang.ClassCastException: class org.springframework.core.annotation.TypeMappedAnnotation cannot be cast to class java.util.Map (org.springframework.core.annotation.TypeMappedAnnotation is in unnamed module of loader 'app'; java.util.Map is in module java.base of loader 'bootstrap') ```  This is caused by the `@AliasFor(""value"")` and `@AliasFor(""hallo"")` on `public @interface Bad`.  We do not see this behaviour with Spring Boot 2.1.11 (Spring Core 5.1.12.RELEASE) but can reproduce the issue on (Spring Core 5.2.2.RELEASE and 5.2.4.BUILD-SNAPSHOT).  Failing test case:  ```java public class Gh24375Tests {    @Target({ElementType.METHOD, ElementType.TYPE})   @Retention(RetentionPolicy.RUNTIME)   public @interface A {      @AliasFor(""value"")     B versus() default @B;      @AliasFor(""versus"")     B value() default @B;   }    @Target(ElementType.ANNOTATION_TYPE)   @Retention(RetentionPolicy.RUNTIME)   public @interface B {      String name() default """";   }    @Test   @A(versus = @B)   public void gh24375() {     new ClassPathScanningCandidateComponentProvider(true)         .findCandidateComponents(Integer.class.getPackage().getName());   } } ```  The root cause could be in:  ```java org.springframework.core.annotation.AnnotationTypeMapping#areEquivalent(java.lang.Object, java.lang.Object, java.util.function.BiFunction) ```  and could be mitigated by adding:  ```java if (value instanceof Annotation && extractedValue instanceof TypeMappedAnnotation) {   return areEquivalent((Annotation) value, (TypeMappedAnnotation)extractedValue, valueExtractor); }  private static boolean areEquivalent(Annotation annotation, @Nullable TypeMappedAnnotation extractedValue, BiFunction valueExtractor) {      AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());     for (int i = 0; i < attributes.size(); i++) {         Method attribute = attributes.get(i);         String name = attributes.get(i).getName();         if (!areEquivalent(ReflectionUtils.invokeMethod(attribute, annotation),             extractedValue.getValue(name).orElse(null), valueExtractor)) {             return false;         }     }     return true; } ```  As this is core framework code I'm not really feeling confident to provide a PR without breaking something else.","closed","in: core,","AndreasKl","2020-01-16T06:45:56Z","2020-02-12T11:48:18Z"
"","23986","Use array.clone() instead of manual array creation","Tiny simplification making code more brief and readable: in case we create a copy of the same length as original array and copy all the data into it we can use `array.clone()` instead of hand-made code snippet.","closed","","stsypanov","2019-11-13T12:45:56Z","2022-02-18T19:07:17Z"
"","24012","Allocate objects only when it's necessary","Tiny and trivial improvements.","closed","status: invalid,","stsypanov","2019-11-17T22:19:20Z","2019-11-18T09:26:08Z"
"","24339","StringDecoder buffer leak related to maxInMemorySize limit","This was discovered while working on implementing the same type of limit for `ServerSentEventsMessageReader` which depends on `StringDecoder` to split the stream into lines (see #24312).   When a single input buffer contains multiple lines in which case slices for each line are retained, and if one of the earlier lines exceeds the limit, then subsequent lines are not released. This is due to a suspected issue with  `concatMapIterable` not respecting `doOnDiscard`. I've added a https://github.com/reactor/reactor-core/issues/1925#issuecomment-573630082 related to that.   The goal for this issue is to add a workaround.","closed","type: bug,","rstoyanchev","2020-01-13T13:03:07Z","2020-01-13T15:41:50Z"
"","24251","Upgrade to nohttp plugin 0.0.4.RELEASE","This updates the nohttp plugin to 0.0.4.RELEASE which contains improvements to make the `checkstyleNoHttp` task cacheable.","closed","type: dependency-upgrade,","ghale","2019-12-23T14:16:49Z","2019-12-23T16:08:41Z"
"","24252","Upgrade to Gradle build scan plugin 3.1.1","This updates the Gradle build scan plugin to the latest release.","closed","type: dependency-upgrade,","ghale","2019-12-23T14:26:13Z","2019-12-23T16:17:13Z"
"","24250","Update Artifactory plugin to 4.12.0","This updates the artifactory plugin to 4.12.0 which includes improvements to parallelism when uploading artifacts during publish.","closed","type: task,","ghale","2019-12-23T13:53:52Z","2020-01-16T09:50:26Z"
"","23955","Delete unnecessary variable assignment","This statement`mbd = null;`seems to be useless.","closed","in: core,","chenqimiao","2019-11-08T12:19:32Z","2019-11-08T14:23:32Z"
"","23887","Revisit @Configuration(proxyBeanMethods = false) with qualified injection points","This relates to #23839  We've switched `DelegatingWebMvcConfiguration` to disable method proxying and there are a number of side effects that aren't currently covered.  `requestMappingHandlerAdapter` takes a `mvcContentNegotiationManager`, `mvcConversionService` and `mvcValidator`. These are ""qualified"" in the aim of calling the related method on the same class.  The problem with this approach is that if any of those types are already exposed with a `@Primary` bean, the context will not even attempt to look for a candidate (and therefore will not invoke the dedicated bean factory method if necessary).  A concrete illustration of this problem for `mvcConverter` can be found in https://github.com/spring-projects/spring-boot/issues/18672. A fix is to add a `@Qualifier` to teach the context the qualified bean is actually required and the context should attempt to look it up.   This seems to be working as expected (although with more metadata than it should be ideally) but given that no tests broke, I can only assume this use case isn't covered by tests at the moment. The purpose of this issue is to revisit this support, add missing tests and eventually change our mind with regards to this decision.","closed","type: regression,","snicoll","2019-10-29T13:59:39Z","2019-10-30T14:15:28Z"
"","24436","Support message conversion with kotlinx.serialization","This pull requests adds `HttpMessageConverter`s for kotlinx.serialization that support `application/json` and `application/cbor`. Tests are included but written in Kotlin because `@Serializable` works only for Kotlin data classes.  I have not added a converter for Protocol Buffers but might do so if this pull request gets accepted.  Closes gh-21188.","closed","type: enhancement,","aahlenst","2020-01-27T13:01:08Z","2020-09-30T07:54:54Z"
"","24216","Upgrade to Asciidoctor Gradle 2.4","This pull request updates the build to use version 2.4 of the Asciidoctor Gradle plugin. These changes are made in the first commit. One of the main benefits of the upgrade is that the `asciidoctor` task is now cacheable. To take full advantage of this, the second commit configures the PDF backend for snapshots builds. This will allow PDF documentation to be generated for snapshots, but for the cost to only be incurred when a change to the documentation has been made.","closed","type: task,","wilkinsona","2019-12-16T09:31:28Z","2020-01-09T09:21:19Z"
"","24512","Use Gradle Enterprise Conventions Plugin to configure build scans","This pull request simplifies the build scan configuration in the build by using our [Gradle Enterprise Conventions Plugin](https://github.com/spring-gradle-plugins/gradle-enterprise-conventions-plugin). Please see the plugin's README for details of the conventions that it applies.","closed","type: task,","wilkinsona","2020-02-12T14:59:08Z","2020-02-12T17:14:39Z"
"","24581","BlockHoundIntegration for spring-core","This pull request adds a `BlockHoundIntegration` for spring-core that whitelists locking in `ConcurrentReferenceHashMap` for #24241, and `LocalVariableTableParameterNameDiscoverer` for #24247.","closed","type: enhancement,","rstoyanchev","2020-02-24T12:37:29Z","2020-02-24T17:21:26Z"
"","24803","Optimize hard code in PropertiesBeanDefinitionReader","This PR removes some hard codes.  Please see my PR changes, although `CONSTRUCTOR_ARG_PREFIX` is final, but it is still possible to update iteratively, although it is unlikely, but it is still recommended to modify the hard code.","closed","in: core,","chenqimiao","2020-03-28T13:35:47Z","2021-12-21T08:41:15Z"
"","24096","Remove duplicate checks in ResponseCookieTests","This PR removes duplicate checks in `ResponseCookieTests.domainChecks()`.","closed","type: task,","izeye","2019-11-28T01:07:59Z","2019-11-28T07:46:23Z"
"","23883","Add opt-in support for remote build cache and pushing to it from CI","This PR provides opt-in enablement of Gradle's remote build cache. When the `GRADLE_ENTERPRISE_URL` environment variable is set, its build cache node will be used as a source of cached output. If both `GRADLE_ENTERPRISE_CACHE_USERNAME` and `GRADLE_ENTERPRISE_CACHE_PASSWORD` are also set, task output produced by the build will be pushed to the build cache node for use by subsequent builds.","closed","type: task,","wilkinsona","2019-10-29T09:55:07Z","2019-10-29T11:51:07Z"
"","24463","Polish length calculation in PropertiesBeanDefinitionReader","This PR polishes a bit by avoiding an unnecessary addition.","closed","in: core,","izeye","2020-01-31T08:42:28Z","2020-01-31T10:43:46Z"
"","24620","Polish ReactorResourceFactory","This PR polishes `ReactorResourceFactory` a bit.","closed","type: documentation,","izeye","2020-03-01T03:49:46Z","2020-03-02T13:17:44Z"
"","23995","Polish CorsAbstractHandlerMappingTests","This PR polishes `CorsAbstractHandlerMappingTests`.","closed","type: task,","izeye","2019-11-14T11:47:00Z","2019-11-19T11:40:55Z"
"","24235","Polish ClientResponse.logPrefix() Javadoc","This PR polishes `ClientResponse.logPrefix()` Javadoc by removing ""no"" as it seems to be added accidentally.","closed","type: task,","izeye","2019-12-20T07:17:24Z","2019-12-20T13:59:24Z"
"","24525","Optimize getDependencyType implementation of DependencyDescriptor by using ResolvableType","This pr optimizes `getDependencyType` implementation of  `DependencyDescriptor`  by using `ResolvableType` instead of native type operations. Please help review the code by `Files changed`. Looking forward to your reply.","closed","in: core,","chenqimiao","2020-02-14T15:32:30Z","2021-12-21T10:21:15Z"
"","24529","Fix typo and polish if block","This pr is to polishing some `if` blocks in `ResolvableType` and fixing some typos in `ResolvableTypeTests`. Looking forward to your reply.","closed","in: core,","chenqimiao","2020-02-15T06:21:30Z","2020-02-24T14:38:40Z"
"","24599","Add support for explicit generic type in PayloadApplicationEvent","This PR is to make event mechanisms better support generics.  When I publish an event which contains generics via `org.springframework.context.support.AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)` , I find that corresponding listener does not get event message.  Please see the unit test cases in my PR. `The unit test method of named publishEventWithGeneric fail before this PR submission`. So, I think we can add a payloadType field to PayloadApplicationEvent to fix this. In addition, this fix code also can cache the type information of the payload to improve performance.   Thank you for reading and look forward to your reply.","closed","type: enhancement,","chenqimiao","2020-02-26T12:01:50Z","2021-12-11T11:32:12Z"
"","24786","Simplify conversion of DataBuffer to String","This PR is similar to https://github.com/spring-projects/spring-framework/pull/24785  Also there's one more place about which I'm not sure: This code ```java return DataBufferUtils.join(flux) 		.map(buffer -> { 			byte[] result = new byte[buffer.readableByteCount()]; 			buffer.read(result); 			DataBufferUtils.release(buffer); 			return DigestUtils.md5DigestAsHex(result); 		}); ``` could be rewritten as  ```java return DataBufferUtils.join(flux) 		.map(buffer -> { 			try (InputStream inputStream = buffer.asInputStream(true)) { 				return DigestUtils.md5DigestAsHex(inputStream); 			} catch (Exception e) { 				throw new RuntimeException(e); 			} 		}); ``` But I'm not sure whether it is worth the effort.","closed","in: core,","stsypanov","2020-03-26T09:46:33Z","2020-03-27T07:40:51Z"
"","24801","Use autoboxing instead of explicit wrapping","This PR is considering using auto Box/Unbox instead of manual, because constructors like `new Integer(1)` have been `deprecated` since JDK 9.  There are a lot of changes in this PR.  I already ran `./gradlew check` and got a successful result, so I hope this will reduce your workload.","closed","type: task,","chenqimiao","2020-03-27T15:47:47Z","2020-04-01T14:34:09Z"
"","24137","Fix status code in webflux.adoc","This PR fixes status code in `webflux.adoc` which has been fixed in `webmvc.adoc` via f638bfc6a9231591f4e605c4caced092cd7cd32f.","closed","type: task,","izeye","2019-12-05T04:05:45Z","2019-12-05T12:31:16Z"
"","24758","Fix empty domain handling in ResponseCookie","This PR fixes empty domain handling in `ResponseCookie`.  This PR also updates its test to use its intended inputs.","closed","type: bug,","izeye","2020-03-22T04:31:06Z","2020-03-25T08:25:16Z"
"","24418","Fix typo in Javadoc","This PR fixes a typo in Javadoc.","closed","type: task,","izeye","2020-01-23T07:23:21Z","2020-01-23T15:55:39Z"
"","23869","Extract build cache settings to a dedicated file","This PR extracts build cache settings to a dedicated file.","closed","type: task,","izeye","2019-10-25T04:32:08Z","2019-10-25T13:36:46Z"
"","24625","Add test cases to StringUtilsTests","This PR considers adding some test cases to StringUtilsTests","closed","in: core,","chenqimiao","2020-03-02T11:11:46Z","2020-03-13T13:51:35Z"
"","24172","Use hasSize() where possible","This PR changes to use `hasSize()` where possible.","closed","type: task,","izeye","2019-12-10T03:38:13Z","2019-12-10T11:32:11Z"
"","24185","Short-circuit in AbstractBeanDefinition.equals()","This PR changes to short-circuit in `AbstractBeanDefinition.equals()`.","closed","type: enhancement,","izeye","2019-12-11T03:37:19Z","2019-12-11T16:21:53Z"
"","24704","Avoid unnecessary sorting in AbstractHandlerMethodMapping","This PR can reduce useless sorting in AbstractHandlerMethodMapping.","closed","type: enhancement,","chenqimiao","2020-03-16T03:54:37Z","2020-03-16T11:41:43Z"
"","24700","Integrate Apache Http client with WebClient","This PR aims to integrate Apache HttpClient 5 (which supports reactive streams and became GA last month) with WebClient.  Questions ------ * Does Spring have some internal load tests which can be run the new implementation to see how it behaves under stress? * Should we support some kind of resource sharing just like it's done for the netty and jetty implementations?","closed","type: enhancement,","martin-tarjanyi","2020-03-14T22:32:16Z","2020-04-29T13:24:38Z"
"","23938","Add tests for PrincipalMethodArgumentResolver","This PR adds tests for `PrincipalMethodArgumentResolver`.","closed","type: task,","izeye","2019-11-06T02:47:17Z","2019-11-08T09:32:07Z"
"","24645","containsAny in CollectionUtils delegates to findFirstMatch","This method implementation named `containsAny` is redundant with that method implementation named `findFirstMatch`. Consider reuse `findFirstMatch` to optimize `containsAny` implementation.","closed","in: core,","chenqimiao","2020-03-05T02:57:10Z","2020-03-13T13:48:23Z"
"","24327","Update CORS support","This issue is about updating CORS support in order to check `Origin` header in `CorsUtils#isPreFlightRequest` which does not change how Spring MVC or WebFlux process CORS request but is more correct in term of behavior since it is a public API potentially used in another contexts.  It also includes other improvements and related tests.","closed","type: enhancement,","sdeleuze","2020-01-10T13:46:43Z","2020-01-13T09:22:43Z"
"","24329","Cloning a WebClient.Builder instance does not copy strategiesConfigurers","This issue is about fixing a missing copy of strategiesConfigurers when cloning a `WebClient.Builder` instance, introduced in #23961 and #24106.","closed","type: bug,","bclozel","2020-01-10T14:49:12Z","2020-01-10T15:01:42Z"
"","23860","Remove unused type parameter declarations in XpathRequestMatchers","This issue is a follow up to #23858. See that issue for details.","closed","type: bug,","sbrannen","2019-10-24T11:00:16Z","2019-10-24T11:12:39Z"
"","23943","setReadOnly not defined in JpaTransactionObject in JpaTransactionManager","This is for version 5.2.1.RELEASE   In  spring-framework/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java line 405 has  ``` txObject.setTransactionData(transactionData); txObject.setReadOnly(definition.isReadOnly());  // Register transaction timeout. if (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) { ```  However setReadOnly is not defined in private class JpaTransactionObject  How did this compile successfully?","closed","status: invalid,","pmirajkar","2019-11-07T01:26:46Z","2019-11-07T07:57:47Z"
"","24739","Polish implementation of BeanDefinitionReaderUtils.generateBeanName()","This is an invalid 'if'  `BeanDefinitionReaderUtils.generateBeanName`  ```java 		String id = generatedBeanName; 		if (isInnerBean) { 			// Inner bean: generate identity hashcode suffix. 			id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition); 		} 		else { 			// Top-level bean: use plain class name with unique suffix if necessary. 			return uniqueBeanName(generatedBeanName, registry); 		} 		return id; ```","closed","in: core,","sin-ning","2020-03-20T06:36:54Z","2020-03-20T18:13:56Z"
"","23893","Reorder date formatting converter in registrar","This is an attempt at fixing spring-projects/spring-framework#23890  In that issue, a developer configures the `spring.mvc.date-format` application property in Spring Boot and sees that the `@DateTimeFormat` annotation is not honored anymore when binding to a controller method argument. This property is merely registering a `DateFormatterRegistrar` with a specific pattern.  It seems that the ordering of registration of formatters in that registrar is off and registers the annotation-based formatter before the pattern-based one. Because the formatters are considered in reversed order when multiple candidates match the same source/target type pairs, this needs to be reversed. This PR aligns this registration order in `DateFormatterRegistrar` with what's already done in `DateTimeFormatterRegistrar`.","closed","in: core,","bclozel","2019-10-30T13:01:30Z","2019-10-30T16:22:12Z"
"","24089","Fix consecutive-word duplications in documentation","This is a follow-up of the other PR https://github.com/spring-projects/spring-security/pull/7673, which checks for consecutive words for possible duplication(s). such as `the the`, `can can` etc.","closed","type: documentation,","ryenus","2019-11-27T02:21:11Z","2019-11-27T08:45:10Z"
"","24081","PropertyResolver extension getProperty with default value","This convenient metod will return non null value with reified type","closed","status: declined,","kkocel","2019-11-26T11:03:06Z","2021-04-28T18:34:56Z"
"","24587","Polish some String equals()","This change can prevent NPE  and will be consistent overall code using the String equals method.","closed","status: declined,","hyeonisism","2020-02-25T10:37:18Z","2020-02-27T10:56:55Z"
"","24636","Polish mergeArrayIntoCollection of CollectionUtils","This can simplify the code","closed","in: core,","chenqimiao","2020-03-04T04:07:33Z","2022-01-11T13:11:22Z"
"","24555","Simplify code in spring-test by using Collections.addAll","This can be changed like this.","closed","type: task,","hyeonisism","2020-02-19T12:57:46Z","2020-02-20T09:16:06Z"
"","24678","Fix missing response body in UnknownHttpStatusCodeException instances","This bug surfaced during spring-boot 2.1 -> 2.2 migration.","closed","status: duplicate,","mzcu","2020-03-11T10:50:08Z","2020-03-11T12:57:42Z"
"","24577","Remove unnecessary semicolon in some enum classes","These are unnecessary semicolons. So I removed.","closed","type: task,","hyeonisism","2020-02-24T02:43:59Z","2020-02-25T06:11:11Z"
"","24117","Add Nullable to Joinpoint and MethodInterceptor","These annotations enable better Kotlin Interop. With these annotations the Kotlin compiler correctly picks up nullability when calling .proceed() used on a method returning void.  closes gh-24028","closed","type: enhancement,","eiselems","2019-12-02T20:19:20Z","2020-05-18T12:33:33Z"
"","23969","Simplify ConstructorResolver: do not sort intermediate array","There's no need to create an intermediate array of Method candidates just to sort it. Intead we can directly sort existing `ArrayList` which costs us the same as there's array under the hood.","closed","type: enhancement,","stsypanov","2019-11-11T11:55:28Z","2019-11-11T14:56:11Z"
"","24143","Ensure MvcUriComponentsBuilder generates correct URL from type-level mapping without leading slash","There seems to be a bug in `MvcUriComponentsBuilder`, so I fixed it.  ### affects  * Spring 5.2.1 and older. * Using Spring WebMVC and JSP/Thymeleaf.  ### problem  `MvcUriComponentsBuilder` generates incorrect URLs from paths without slashes.  * Context Path  `/demo`  * Controller  ```java @Controller @RequestMapping(""test"") // non slash path public class TestController {      @GetMapping     public String test() {         return ""test"";     } } ```  * JSP (The same problem will happen with Thymeleaf)  ```jsp test ```  * Created HTML  ```html test  ```  ### Cause  At `MvcUriComponentsBuilder#fromMethodInternal`,  `PathMatcher` adds a slash between the path of class `@RequestMapping` and the path of method  `@RequestMapping`. However, no slash is added at the beginning of the merged path.","closed","type: bug,","yoshikawaa","2019-12-05T13:33:50Z","2020-01-09T01:20:14Z"
"","24631","Fix formatting in AOP examples in documentation","There is some problems with formatting. As a result we see incorrect Java code snippets. We can try to escape some of the symbols. i.e. using '\\' character. But I don't see any possibility to escape unconstrained quotes. i.e. '**'. So the best way is removing redundant 'quotes' subs.   **The current documentation is incorrect because of that and contains misleading code fragments.**","closed","type: task,","hrybs","2020-03-02T21:22:29Z","2020-03-09T14:44:42Z"
"","24167","Hoist constant result of SerializableTypeWrapper.unwrap() out of loop","There is no point in calculatation of expression ```java TypeVariable v2 = SerializableTypeWrapper.unwrap(variable); ``` at each iteration of the loop as far as its result depends only on method's argument.","closed","type: enhancement,","stsypanov","2019-12-09T12:01:55Z","2019-12-09T12:15:21Z"
"","24784","How to get the actual type when using generic injection","There is a `Provider` interface in my project, which provide some common functions. I want to use it in `Controller` with generic injection of SpringFramework, in order to keep code simple and clean.  ```java public interface Provider {     ... }   @Component(""myProvider"") public class MyProvider implements Provider {        @Autowired     private Converter converter;    ... }  @RestController public class UserController {        @Autowired    private Provider provider;    ... }  @RestController public class ProductController {        @Autowired    private Provider provider;    ... } ```  How to get the actual type `User` or `Product` in method of `MyProvider` or `Converter` class, could someone please give some help?  Spring version: 5.0.9.RELEASE","closed","for: stackoverflow,","cdfive","2020-03-26T08:44:00Z","2020-03-26T09:19:59Z"
"","24052","Use String.isEmpty() instead of String.equals("""")","There are certains cases when we are sure that String is not null, so instead of using `equals("""")` we can call `String.isEmpty()` making core more readable.","closed","type: enhancement,","stsypanov","2019-11-21T15:36:24Z","2019-11-22T09:11:13Z"
"","23971","Upgrade to Shadow Plugin 5.2.0","There are a few improvements, the most notable of which for Framework's build is that the [shadow jar task is now cacheable](https://github.com/johnrengelman/shadow/pull/524).","closed","type: task,","wilkinsona","2019-11-11T13:39:11Z","2019-11-11T14:10:04Z"
"","24007","Asssociate timeout to underlying Jetty HTTP client","The websocket handshake timeout is now the sum of connection timeout, idle tiemout and 1 margin second.","closed","status: duplicate,","Kukosoft","2019-11-15T12:05:19Z","2019-11-19T13:57:32Z"
"","24619","Spring Tools 4 is now!","The website [Spring Tool Suite](https://spring.io/tools/sts)  is not found.","closed","status: duplicate,","quxinyong","2020-03-01T02:38:52Z","2020-03-01T16:38:07Z"
"","24125","ReadCancellationException does not play well with `onErrorContinue`","The way that `ReadCancellationException` is used in `BodyExtractors` is apparently meant to be an implementation detail:  https://github.com/spring-projects/spring-framework/blob/1bff7ce1418807d1f75daa9025fabfe4d4203bb9/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java#L269-L273 However, if somewhere downstream in the pipeline an `onErrorContinue` operator is appended, the exception does surface which caused me some confusion. Could this be implemented differently without throwing an exception?","closed","type: bug,","chringwer","2019-12-03T13:03:38Z","2019-12-04T18:23:36Z"
"","24675","Remove unnecessary variable declaration in ProxyCallbackFilter","The var `key` declaration seems unnecessary. Suggest remove it.","closed","in: core,","chenqimiao","2020-03-11T01:37:42Z","2020-03-11T13:00:27Z"
"","24694","Reduce byte array allocations in StompEncoder","The use of an `okio.Buffer` instead of an `ByteArrayOutputStream` will reduce the amount of allocated byte arrays by 50% to 66%.  With the current `ByteArrayOutputStream`-based implementation, 2-3 byte arrays are allocated. One when the stream is created, one when `toByteArray()` is called and maybe a third one, when the stream must grow because the overhead(headers) exeeds 128 bytes.  With an `okio.Buffer`, only one byte array has to be allocated, when `readByteArray()` is called. All other needed arrays will be taken from Okio's internal Segment Pool.  The pattern of conditionally using classes, when they are present on the classpath is inspired by RestTemplate.  I've choosen this older okio version, because its the same version that would be pulled by the already managed okhttp version.  ### Context While profiling our application we noticed that a considerable amount of byte arrays is created in `org.springframework.messaging.simp.stomp.StompEncoder.encode`: ![stomp-profiling](https://user-images.githubusercontent.com/6069961/76651526-fe8cd980-6564-11ea-80ef-1d1f8a8aa63a.png)  In other parts of our application, we already made good experience with using `okio.Buffer`s instead of `ByteArrayOutputStream`s","closed","type: enhancement,","larsgrefer","2020-03-13T19:06:05Z","2020-03-31T13:50:41Z"
"","24063","Default UriBuilder removes slash from protocol","The UriBuilder returned by DefaultUriBuilder removes slashes from protocols, turning, for example http://test.com to http:/test/com.  # Steps to reproduce ```java new DefaultUriBuilderFactory().builder().path(""http://user/{userId}"").build(1) ```","closed","","BenMMcLean","2019-11-23T04:35:56Z","2022-02-18T19:07:18Z"
"","24019","Add parameter name module to object mapper","The three modules for Java 8 feature support in Jackson have been merged into one (https://github.com/FasterXML/jackson-modules-java8). It makes sense to treat all three now as well known modules that are registered by default.  As the documentation from the new project says about Jackson 3:  > Because of this parameter-names and datatypes modules are merged into jackson-databind and need not be registered; datetime module (JavaTimeModule) remains separate module due to its size and configurability options.  Spring could provide this behavior already today.","closed","type: enhancement,","jehrhardt","2019-11-18T21:22:34Z","2021-12-06T10:41:13Z"
"","24080","Documentation flaw for  settings","The table entries for `` settings for `rollback-for` and `no-rollback-for` include the full stop as part of the exception name. It should not be. It should be like `read-only`.","closed","type: documentation,","michael-o","2019-11-26T10:46:12Z","2019-11-29T18:03:50Z"
"","24465","SseEmitter cannot format text/plain if StringHttpMessageConverter is not configured","The SseEmitter included in the spring framework does not seem to include a capable text/plain parser in the underlying converter set.  Whenever i try to send any form of event, the emitter automatically includes a ""data:"" prefix, which it adds with the text/plain mediatype.  After a bit of digging i noticed some of the underlying functions use a subset of spring's default MessageConverters, this subset does not include the default String converter.  So, whenever i try to send any type of event like so: ```java   SseEmitter.SseEventBuilder event = SseEmitter.event()                             .data(""SSE MVC - "" + LocalTime.now().toString())                             .id(String.valueOf(i))                             .name(""sse event - mvc"");                     emitter.send(event); ```  it will inevitably result in a `java.lang.IllegalArgumentException: No suitable converter for class java.lang.String`  The suggestion would be to either include the standard string converter, or let the SseEmitter use a different mediatype for pre- and suffixes that are supported in the Converter chain for the emitter.  I'm currently on spring boot version 2.1.12.RELEASE","closed","type: enhancement,","incapable","2020-01-31T13:43:32Z","2020-02-05T20:50:35Z"
"","24295","Optimize SimpleAliasRegistry hasAlias implementation","The purpose of this PR is to reduce the number of loops and recursions of SimpleAliasRegistry hasAlias implementation","closed","type: enhancement,","chenqimiao","2020-01-05T08:50:49Z","2020-03-11T14:12:41Z"
"","24799","Remove unnecessary mem alloc in CollectingReaderEventListener","The parameter of `collection.toArray()` method only need to express the type convert to , no need to specify the length of the parameter array.","closed","type: task,","chenqimiao","2020-03-27T09:48:59Z","2020-03-27T10:04:37Z"
"","24589","Fix URL to Spring Tools for Eclipse","The page of the url of Spring Tool Suite is 404. I found that deleting the last string of ""/sts"", page can reach the Spring Tool Suite page","closed","type: task,","chenqimiao","2020-02-25T11:24:57Z","2020-03-04T01:32:46Z"
"","23984","Fix typo in EventSourceTransportHandler","The other files are written as Server-Sent **E**vents.  * https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-web/src/main/java/org/springframework/http/codec/ServerSentEvent.java#L24 * https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-web/src/main/java/org/springframework/http/codec/ClientCodecConfigurer.java#L88 * https://github.com/spring-projects/spring-framework/blob/ef14d76d3637abeb31edd8a22031c21f9445efef/spring-web/src/main/java/org/springframework/http/codec/ServerCodecConfigurer.java#L94 * https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/handler/EventSourceTransportHandler.java#L33","closed","type: task,","johngrib","2019-11-13T06:16:03Z","2019-11-13T14:25:04Z"
"","23914","Modify the name of map earlyProxyReferences to earlyTargetReferences","The original map named earlyProxyReferences seems to stores the target object, not the proxy object.","open","in: core,","chenqimiao","2019-11-03T16:07:36Z","2021-04-27T05:06:11Z"
"","23878","Support matching against multiple header values in HeaderAssertions","The only way to validate multiple response header values – is to assert for strict equality with `valueEquals(String headerName, String... values)`. Got to be a way to also validate them against regular expression, and with any custom check, like in `value(String name, Consumer consumer)` (which btw has wrong copy-pasted javadoc).  Other method javadocs say that they work with ""primary value"". There is no such term neither in [RFC7230](https://tools.ietf.org/html/rfc7230), nor in [RFC6265](https://tools.ietf.org/html/rfc6265). It seems that all values should be treated as equally significant.  This functionality is extremely important for work with response cookies (`Set-Cookie` header).","closed","type: enhancement,","Adamovskiy","2019-10-28T12:12:07Z","2020-05-13T11:31:45Z"
"","23874","Add RSocketRequester retrieveAndAwaitOrNull extension","The nullable variant of `retrieveAndAwait` is missing.","closed","type: enhancement,","sdeleuze","2019-10-27T19:10:40Z","2019-10-27T19:39:34Z"
"","24179","Deprecate use of path extensions in request mapping and content negotiation","The motivation for this has been described in the [""Suffix Match""](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match) section of the reference docs for some time. This issue is about formally deprecating options to use path extensions in request mapping and content negotiation.  When you have to consider all of the following together: path patterns and URI variables, URL encoding (and double encoding chicanery), path parameters "";""  and their treatment (and potential mistreatment) by frameworks and servers, relative paths `""../""`, and the need for alignment between security and web framework path matching among others, it is not surprising that incidental complexity makes it hard to reason about potential attacks such as RFD (see [""Suffix Match and RFD""](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-rfd)). All of this makes the use of path extensions for request mapping and content negotiation an anti-pattern.  `@RequestMapping(produces=""..."")` should be preferred over suffix pattern matching for mapping requests with acceptable media types derived from the `Accept` header, or otherwise a query parameter could also be used to express acceptable format(s).  For 5.3, the defaults for suffix pattern matching will change so that only registered path extensions are used for request mapping and content negotiation, see https://github.com/spring-projects/spring-framework/issues/23915#issuecomment-563987147. This aligns closer with the Spring Boot web starter auto-config where the use of path extensions is off by default, and for comparison Spring WebFlux does not even have such options.  Update: --- **2020-04-20:** the plans for 5.3 have changed after #24642, see https://github.com/spring-projects/spring-framework/issues/23915#issuecomment-616566606.","closed","in: web,","rstoyanchev","2019-12-10T12:03:05Z","2020-04-20T13:53:11Z"
"","24074","Improve part content type determination in MockMultipartHttpServletRequest","The MockMultipartHttpServletRequest does not support handling of non-file multiparts. This aligns the behavior of MockMultipartHttpServletRequest with StandardMultipartHttpServletRequest and DefaultMultipartHttpServletRequest, which support such scenarios by looking up content types in file as well as non-file parts of the request.","closed","type: enhancement,","Syquel","2019-11-25T14:07:07Z","2019-11-29T15:56:21Z"
"","24633","Add a unit test for getMostSpecificMethod of ClassUtils","The method `getMostSpecificMethod` of `ClassUtils` does not seem to be covered by unit test. Consider adding a unit test method for this method. Test this method from multiple latitudes of inheritance, method modifiers, implementation, etc. Looking forward to your reply.","open","in: core,","chenqimiao","2020-03-03T09:21:19Z","2021-11-11T09:51:09Z"
"","24648","Fix meta-annotations: @Timed and @Repeat","The javadoc of the annotations `@Timed` & `@Repeat` says: ""This annotation may be used as a meta-annotation to create custom composed annotations.""  The `@Inherited` annotation is missing in the definitions of both annotation. We should add the `@Inherited` annotation to make them meta-annotations or update the javadoc.  // Steps to reproduce the problem:  ``` @Timed(millis = 5000L) @Retention(RUNTIME) @Target(TYPE) @interface MetaAnnotation {}  @MetaAnnotation class TargetClass { }  Timed timed = TargetClass.class.getAnnotation(Timed.class); // timed is null ```","closed","status: invalid,","Ammar0","2020-03-05T10:48:53Z","2020-03-06T14:35:12Z"
"","24647","Fix @Timed annotation (Make it meta-annotation)","The javadoc of the @Timed annotation says: ""This annotation may be used as a meta-annotation to create custom composed annotations.""  The @Inherited annotation is missing, so @Timed cannot be used to create meta-annotation. We should add the @Inherited annotation to be respect the javadoc or omit the meta-annotation line from javadoc.  // Steps to reproduce the problem:  ``` @Timed(millis = 5000L) @Retention(RUNTIME) @Target(TYPE) @interface MetaAnnotation {} ```  ``` @MetaAnnotation class TargetClass { }  Timed timed = TargetClass.class.getAnnotation(Timed.class); // timed is null ```","closed","status: invalid,","Ammar0","2020-03-05T10:20:03Z","2020-03-06T14:36:34Z"
"","23996","TypeDescriptor#getElementTypeDescriptor does not throw IllegalStateException anymore","The JavaDoc of `TypeDescriptor#getElementTypeDescriptor` states   >  @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type  However, that is not the case:  ```java public static void main(String...a) { 	System.out.println(TypeDescriptor.valueOf(String.class).getElementTypeDescriptor()); 	System.out.println(TypeDescriptor.valueOf(String[].class).getElementTypeDescriptor()); } ```  This works without an exception.  I would provide a fix, if I knew what is wrong: The behaviour or only the JavaDoc.","closed","in: core,","michael-simons","2019-11-14T12:11:09Z","2019-11-22T13:18:55Z"
"","24288","Confusing javadoc in RestClientException","The javadoc for `RestClientException` says (emphasise is mine):  > Base class for exceptions thrown by `{@link RestTemplate}` whenever it encounters **client-side** HTTP errors  But one of its subclasses is `HttpServerErrorException`, so clearly `RestClientException` signals both client- and server-side errors.","closed","type: task,","iNikem","2020-01-03T10:18:23Z","2020-01-03T11:22:56Z"
"","24015","ExceptionHandlerExceptionResolver.setResponseBodyAdvice() Javadoc is incorrect","The Javadoc for `ExceptionHandlerExceptionResolver.setResponseBodyAdvice()` states that it will ""Add one or more components...""; however, it actually first clears the current list and effectively _sets_ the advice to the specified list.  This is in contrast to `RequestMappingHandlerAdapter.setResponseBodyAdvice()` which actually does _add_ the advice instead of clearing the current list.  Granted the name of the latter is misleading and should actually be `addResponseBodyAdvice()`, we likely will not want to change the semantics.  Thus, we should consider one of the following.  1. Update Javadoc for `ExceptionHandlerExceptionResolver.setResponseBodyAdvice()` to reflect that it actually ""sets"" the list instead of adding. 2. Stop invoking `this.responseBodyAdvice.clear()` so that `ExceptionHandlerExceptionResolver.setResponseBodyAdvice()` does what the Javadoc says it does.  Option # 2 would align the behavior in `ExceptionHandlerExceptionResolver` and `RequestMappingHandlerAdapter`.","closed","status: superseded,","sbrannen","2019-11-18T12:17:54Z","2019-12-13T16:07:32Z"
"","24085","Examples in Data Access chapter declare unused JdbcTemplate fields","The Java sample code in that chapters used `SimpleJdbcInsert`, but still declares `JdbcTemplate` w/o any use. This is higly confusing to reader since the `SimpleJdbcInsert` is sold as an alternative to the former.  Please focus on the really used objects in sample code.","closed","type: documentation,","michael-o","2019-11-26T12:19:59Z","2019-11-29T18:02:40Z"
"","24084","Data Access chapter 3.5.1 uses bad pattern","The Java sample code in [section 3.5.1](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc-batch-classic) performs index-based operations on the `List` input with `int i`. This might incur a performance penalty depending on the list implementation of `O(n²)`. Lists are best acceessed with iterators. Don't use bad practices in samples.","closed","type: documentation,","michael-o","2019-11-26T12:17:05Z","2019-11-30T15:31:23Z"
"","24551","Fix javadoc in DependencyDescriptor","The java doc description of `(never {@code null})` does not match the annotation of `@Nullable`. Suggest to fix this description.","closed","type: documentation,","chenqimiao","2020-02-19T04:24:10Z","2020-02-19T11:27:54Z"
"","24741","MessagingRSocket incorrectly tries to release entire input stream on channel interaction","The issue was discovered in Spring Security tests after a recent fix in Reactor Core to the `switchOnFirst` operator which now properly detects and flags the scenario.  In an RSocket channel interaction, a Spring server responder fails to find a matching route and in that scenarios the exception occurs. The server handles this with `switchOnFirst` and in the end, if input stream wasn't subscribed to (e.g. because there was no matching handler), it subscribes in order to release the payloads resulting in:  ``` reactor.core.Exceptions$ErrorCallbackNotImplemented: java.util.concurrent.CancellationException: FluxSwitchOnFirst has already been cancelled Caused by: java.util.concurrent.CancellationException: FluxSwitchOnFirst has already been cancelled 	at reactor.core.publisher.FluxSwitchOnFirst$SwitchOnFirstMain.subscribe(FluxSwitchOnFirst.java:348) ~[reactor-core-3.3.4.BUILD-SNAPSHOT.jar:3.3.4.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.subscribe(Flux.java:8260) ~[reactor-core-3.3.4.BUILD-SNAPSHOT.jar:3.3.4.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.subscribeWith(Flux.java:8424) ~[reactor-core-3.3.4.BUILD-SNAPSHOT.jar:3.3.4.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.subscribe(Flux.java:8231) ~[reactor-core-3.3.4.BUILD-SNAPSHOT.jar:3.3.4.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.subscribe(Flux.java:8158) ~[reactor-core-3.3.4.BUILD-SNAPSHOT.jar:3.3.4.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.subscribe(Flux.java:8101) ~[reactor-core-3.3.4.BUILD-SNAPSHOT.jar:3.3.4.BUILD-SNAPSHOT] 	at org.springframework.messaging.rsocket.annotation.support.MessagingRSocket.lambda$handleAndReply$5(MessagingRSocket.java:177) ~[spring-messaging-5.2.4.RELEASE.jar:5.2.4.RELEASE] ```  We shouldn't subscribe to the entire input which in a channel interaction can be quite long. In any case only the first payload is received at that point, and it's the only one that needs releasing.","closed","type: bug,","rstoyanchev","2020-03-20T09:55:38Z","2020-03-20T10:04:58Z"
"","23847","Introduce NestedBeanPropertyRowMapper to map nested objects from arbitrary SQL query","The idea of this implementation for RowMapper is to have convenient tool for mapping ResultSet into nested object. Current implementation of BeanPropertyRowMapper doesn't support nor designed for nested properties.          class Employee {                 public long id;                 public long companyId;                 public String lastName;                  public Company company;         }          class Company {                 public long id;                 public String name;         }          NestedBeanPropertyRowMapper rowMapper = NestedBeanPropertyRowMapper.newInstance(Employee.class);         rowMapper.setEntityDelimiter(""__"");         List employees = jdbcTemplate.query(""SELECT "" +                         ""   EMPLOYEE.*, "" +                         ""   COMPANY.ID as COMPANY__ID, "" + // option1 without escaping column name                         ""   COMPANY.NAME as `COMPANY.NAME` "" + // option2 with escaping                         "" FROM EMPLOYEE JOIN COMPANY "" +                         ""   ON EMPLOYEE.COMPANY_ID = COMPANY.ID "",                 new HashMap<>(), rowMapper);","open","type: enhancement,","cziberpv","2019-10-22T10:03:08Z","2021-04-27T05:06:11Z"
"","24531","Correct formatting of MessageSource example in documentation","The formatting of MessageSource example is not correct. To have as an output the sentence ""Ebagum lad, the 'userDao' argument is required, I say, required."" we should add two pairs of single quotes.","closed","type: documentation,","hrybs","2020-02-16T13:30:37Z","2020-02-17T14:25:53Z"
"","24048","Revise AbstractBeanDefinition equals implementation","The following way of writing seems a bit redundant ```java rtn = rtn &= ObjectUtils.nullSafeEquals(this.scope, that.scope); ```` I think we can polish it by writing the following.  ```java rtn &= ObjectUtils.nullSafeEquals(this.scope, that.scope); ````","closed","in: core,","chenqimiao","2019-11-21T02:57:37Z","2019-11-22T14:58:00Z"
"","23978","TestDispatcherServlet ambiguous handler methods with consumes condition and body not required","The following servlet works in production code, but fails from within junit. The problem is that requestbody is marked as false here, which seems to confuse the TestDispatcherServlet. `spring-boot-2.2.1:RELEASE`.  It used to work in `spring-boot-2.1.9.RELEASE`.  It is probably caused by introduction of method body checks in: https://github.com/spring-projects/spring-framework/commit/45147c23c1fd61912d82abd42650bb060fa08a7a#diff-1f02d8b67b89d3bfbec03633e5499294   ``` @RestController public class ExampleServlet { 	@PostMapping(value = ""/example"", consumes = APPLICATION_JSON_VALUE) 	public void exampleJson(@RequestBody(required = false) String json) { 		System.out.println(""json""); 	}  	@PostMapping(value = ""/example"", consumes = APPLICATION_XML_VALUE) 	public void exampleXml(@RequestBody(required = false) Map xml) { 		System.out.println(""xml""); 	} } ```  Test: ``` @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class ExampleServletITest { 	@Autowired 	private MockMvc mvc;  	@Autowired 	private ObjectMapper objectMapper;  	@Test 	public void testMethodInvocation() throws Exception { 		mvc.perform(MockMvcRequestBuilders 				.post(""/example"") 				.contentType(MediaType.APPLICATION_JSON) 				.content(objectMapper.writeValueAsString(""json test""))) 				.andExpect(status().isOk()) 				.andReturn().getResponse().getContentAsString(); 	} } ```  Logs: ```  [jPwxrJ][anonymousUser] 2019-11-11 15:50:23,255 ERROR: Ambiguous handler methods mapped for '/example': {public void ExampleServlet.exampleJson(java.lang.String), public void ExampleServlet.exampleXml(java.lang.String)} - uri=/example;client=127.0.0.1 java.lang.IllegalStateException: Ambiguous handler methods mapped for '/example': {public void ExampleServlet.exampleJson(java.lang.String), public void ExampleServlet.exampleXml(java.lang.String)} 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:412) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:367) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getHandlerInternal(RequestMappingHandlerMapping.java:449) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getHandlerInternal(RequestMappingHandlerMapping.java:67) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:393) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1234) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.web.servlet.TestDispatcherServlet.getHandler(TestDispatcherServlet.java:121) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1016) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.27.jar:9.0.27] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:72) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.27.jar:9.0.27] 	at org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:167) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.web.servlet.setup.PatternMappingFilterProxy.doFilter(PatternMappingFilterProxy.java:105) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) ~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) ~[spring-boot-actuator-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:183) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at ExampleServletITest.testMethodInvocation(ExampleServletITest.java:29) ~[test-classes/:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?] 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?] 	at java.lang.reflect.Method.invoke(Method.java:566) ~[?:?] 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) ~[junit-4.12.jar:4.12] 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) ~[junit-4.12.jar:4.12] 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) ~[junit-4.12.jar:4.12] 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) ~[junit-4.12.jar:4.12] 	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) ~[junit-4.12.jar:4.12] 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) ~[junit-4.12.jar:4.12] 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) ~[junit-4.12.jar:4.12] 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) ~[junit-4.12.jar:4.12] 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) ~[junit-4.12.jar:4.12] 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) ~[junit-4.12.jar:4.12] 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) ~[junit-4.12.jar:4.12] 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) ~[spring-test-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) ~[junit-4.12.jar:4.12] 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) ~[junit-rt.jar:?] 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) ~[junit-rt.jar:?] 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) ~[junit-rt.jar:?] 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ~[junit-rt.jar:?]  MockHttpServletRequest:       HTTP Method = POST       Request URI = /example        Parameters = {}           Headers = [Content-Type:""application/json;charset=UTF-8""]              Body = ""json test""     Session Attrs = {}  Handler:              Type = null  Async:     Async started = false      Async result = null  Resolved Exception:              Type = java.lang.IllegalStateException  ModelAndView:         View name = null              View = null             Model = null  FlashMap:        Attributes = null  MockHttpServletResponse:            Status = 500     Error message = null           Headers = [Content-Type:""application/json;charset=UTF-8"", Content-Length:""206"", X-Content-Type-Options:""nosniff"", X-XSS-Protection:""1; mode=block"", Cache-Control:""no-cache, no-store, max-age=0, must-revalidate"", Pragma:""no-cache"", Expires:""0"", X-Frame-Options:""DENY""]      Content type = application/json;charset=UTF-8              Body = Ambiguous handler methods mapped for '/example': {public void ExampleServlet.exampleJson(java.lang.String), public void ExampleServlet.exampleXml(java.lang.String)}     Forwarded URL = null    Redirected URL = null           Cookies = []    java.lang.AssertionError: Status  Expected :200 Actual   :500 ```","closed","type: regression,","membersound","2019-11-11T14:53:44Z","2019-11-12T17:36:08Z"
"","24818","Recursively copy directory with symbolic link","The following modification will also recursively traverse the directory that the symbolic link points to. This modification is not proposed for deleteRecursively, since it can be harmful if not intended.  This modification relates to the following commit: Consistent use of NIO.2 for file read/write interactions Issue: SPR-15748 spring-projects@12114a9","closed","","mavigdor","2020-03-30T16:48:10Z","2020-03-31T11:07:07Z"
"","24823","Recursively copy directory with symbolic link","The following modification will also recursively traverse the directory that the symbolic link points to. This modification is not proposed for deleteRecursively, since it can be harmful if not intended.  This modification relates to the following commit: Consistent use of NIO.2 for file read/write interactions Issue: SPR-15748","closed","in: core,","mavigdor","2020-03-31T11:05:33Z","2020-04-03T19:05:28Z"
"","23866","Fix RSocket Fire and forget handling with Kotlin","The following code with suspend function throws ```Missing 'rsocketResponse'``` exception. `println` prints data to the console as expected. It works only when the method is rewritten with Mono: ```fun enter(data: Any): Mono```. The same issue is reproduced for methods annotated with ```@ConnectMapping```.  Reproduced with Spring Boot 2.2.0.RELEASE and 2.2.1.SNAPSHOT.  ```kotlin @Controller class Api {     @MessageMapping(""test"")     suspend fun enter(data: Any) {         println(data)     } } ```  Stacktrace:  ``` java.lang.IllegalArgumentException: Missing 'rsocketResponse' 	at org.springframework.util.Assert.notNull(Assert.java:198) 	at org.springframework.messaging.rsocket.annotation.support.RSocketPayloadReturnValueHandler.handleEncodedContent(RSocketPayloadReturnValueHandler.java:65) 	at org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler.lambda$handleReturnValue$0(AbstractEncoderMethodReturnValueHandler.java:124) 	at org.springframework.messaging.handler.invocation.reactive.ChannelSendOperator$WriteBarrier.onComplete(ChannelSendOperator.java:251) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1820) 	at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:129) 	at kotlinx.coroutines.reactor.MonoCoroutine.onCompleted(Mono.kt:71) 	at kotlinx.coroutines.AbstractCoroutine.onCompletionInternal(AbstractCoroutine.kt:102) 	at kotlinx.coroutines.JobSupport.tryFinalizeSimpleState(JobSupport.kt:275) 	at kotlinx.coroutines.JobSupport.tryMakeCompleting(JobSupport.kt:807) 	at kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core(JobSupport.kt:787) 	at kotlinx.coroutines.AbstractCoroutine.resumeWith(AbstractCoroutine.kt:111) 	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:46) 	at kotlinx.coroutines.DispatchedKt.resumeCancellable(Dispatched.kt:457) 	at kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:26) 	at kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt:109) 	at kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt:154) 	at kotlinx.coroutines.reactor.MonoKt$monoInternal$1.accept(Mono.kt:60) 	at kotlinx.coroutines.reactor.MonoKt$monoInternal$1.accept(Mono.kt) 	at reactor.core.publisher.MonoCreate.subscribe(MonoCreate.java:57) 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:53) 	at org.springframework.messaging.handler.invocation.reactive.ChannelSendOperator.subscribe(ChannelSendOperator.java:85) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1592) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1592) 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247) 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:173) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2148) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.request(MonoPeekTerminal.java:132) 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:318) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onSubscribe(MonoPeekTerminal.java:145) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4087) 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:55) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:55) 	at io.rsocket.RSocketResponder.handleFireAndForget(RSocketResponder.java:366) 	at io.rsocket.RSocketResponder.handleFrame(RSocketResponder.java:296) 	at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:160) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onNext(MonoFlatMapMany.java:242) 	at reactor.core.publisher.FluxGroupBy$UnicastGroupedFlux.drainRegular(FluxGroupBy.java:554) 	at reactor.core.publisher.FluxGroupBy$UnicastGroupedFlux.drain(FluxGroupBy.java:630) 	at reactor.core.publisher.FluxGroupBy$UnicastGroupedFlux.subscribe(FluxGroupBy.java:696) 	at reactor.core.publisher.Flux.subscribe(Flux.java:8134) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onNext(MonoFlatMapMany.java:188) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1592) 	at reactor.core.publisher.MonoProcessor.onNext(MonoProcessor.java:317) 	at io.rsocket.internal.ClientServerInputMultiplexer.lambda$new$1(ClientServerInputMultiplexer.java:116) 	at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:160) 	at reactor.core.publisher.FluxGroupBy$GroupByMain.drainLoop(FluxGroupBy.java:380) 	at reactor.core.publisher.FluxGroupBy$GroupByMain.drain(FluxGroupBy.java:316) 	at reactor.core.publisher.FluxGroupBy$GroupByMain.onNext(FluxGroupBy.java:201) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:206) 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:329) 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:348) 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:457) 	at reactor.netty.http.server.WebsocketServerOperations.onInboundNext(WebsocketServerOperations.java:153) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931) 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:700) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514) 	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:830) ```","closed","type: bug,","denyshorman","2019-10-24T19:58:36Z","2021-04-20T09:31:58Z"
"","24220","Escape quotes in filename in ContentDisposition.Builder when charset not specified","The filename, when specified without a charset, is quoted but not checked for the presence of any unquoted `""` characters. We should check for those and turn into a quoted-pair.","closed","type: bug,","rstoyanchev","2019-12-17T16:35:49Z","2022-07-15T13:30:01Z"
"","24152","Let UriUtils.encode…(…) methods optimize for sources without the need to be encoded","The encoding methods always create `ByteArrayOutputStream` for each input String, even dropping that in case the source String was traversed without a single character being encoded. As the values usually passed into such methods are usually designed to be used in URIs (e.g. (numeric) identifiers), chances are high that the method is called a lot with sources that don't have to be encoded in the first place.","closed","type: enhancement,","odrotbohm","2019-12-06T15:24:46Z","2019-12-09T12:29:20Z"
"","24265","Unsafe double-checked locking in SpelExpression#compileExpression","The double-checked locking `SpelExpression#compileExpression` does not seem to be thread safe, because `compiledAst` is not `volatile`, see:  https://github.com/spring-projects/spring-framework/blob/master/spring-expression/src/main/java/org/springframework/expression/spel/standard/SpelExpression.java#L506  Or am I missing something?  Edit: Also `SpelExpression#compileExpression` uses `this.expression` (a `String`) as a lock object. Shouldn't this be avoided, as Strings objects are shared throughout the program?","closed","in: core,","PascalSchumacher","2019-12-25T15:03:53Z","2020-01-08T17:39:22Z"
"","24430","Remove mention of non-existent local bean attribute from documentation","The documentation contains incorrect mention of 'local' attribute of 'ref' tag. As far as I know the 'local' attribute was removed in http://www.springframework.org/schema/beans/spring-beans-4.0.xsd.","closed","type: task,","hrybs","2020-01-26T14:58:05Z","2020-01-27T17:48:33Z"
"","24621","Fix formatting for pointcut expression examples in documentation","The documentation contains incorrect combining pointcut expressions example in code snippet.   ```java @Pointcut(""execution(public * (..))"") private void anyPublicOperation() {}  @Pointcut(""within(com.xyz.someapp.trading..)"") private void inTrading() {}  @Pointcut(""anyPublicOperation() && inTrading()"") private void tradingOperation() {} ```  But correct form should be as follows:  ```java @Pointcut(""execution(public * *(..))"") private void anyPublicOperation() {}  @Pointcut(""within(com.xyz.someapp.trading..*)"") private void inTrading() {}  @Pointcut(""anyPublicOperation() && inTrading()"") private void tradingOperation() {} ```","closed","type: task,","hrybs","2020-03-01T11:31:06Z","2020-03-06T16:15:20Z"
"","24658","Fix ampersands in AOP examples in documentation","The documentation contains incorrect code sample with ampersands `&&` instead of `&&`  ```java                                 ...       ```  But correct form should be as follows:  ```java                                 ...       ```","closed","type: task,","hrybs","2020-03-07T19:51:40Z","2020-03-09T13:27:56Z"
"","24552","Correct Ant-style Patterns example in documentation","The documentation contains incorrect Ant-style pattern code snippet.  ``` /WEB-INF/-context.xml com/mycompany//applicationContext.xml file:C:/some/path/-context.xml classpath:com/mycompany//applicationContext.xml ``` But correct form should be as follows:  ``` /WEB-INF/*-context.xml com/mycompany/**/applicationContext.xml file:C:/some/path/*-context.xml classpath:com/mycompany/**/applicationContext.xml ```","closed","type: documentation,","hrybs","2020-02-19T08:00:42Z","2020-02-19T09:51:28Z"
"","24120","Optimize WebClient BodyExtractors default contentType strategy","The ContentType of APPLICATION_OCTET_STREAM is used by default, and an exception will be thrown when using the BodyToMono to transform the Entity. I think in addition to the default strategy here, users should be free to choose which default ContentType to use","closed","status: declined,","klboke","2019-12-03T04:13:14Z","2019-12-04T14:15:32Z"
"","24424","Update defaults in ReactorResourceFactory for ConnectionProvider","The connection pool in Reactor Netty 0.9 was switched from elastic to fixed 500 connections (per host), see https://github.com/reactor/reactor-netty/issues/578.  By default the `WebClient` picks up this default, even if `ReactorResourceFactory` is plugged in, as Spring Boot does, because `useGlobalResources` is true by default. However if global resources are turned off, then we have our own default supplier that does `ConnectionProvider.elastic(""webflux"")`. This should be changed to align with Reactor Netty.   Further in 0.9.5, `ConnectionProvider.elastic` and `ConnectionProvider.fixed` are both deprecated. We can use `ConnectionProvider.fixed(""webflux"", 500)` in 5.2.x and switch to `ConnectionProvider.create` in 5.3.","closed","type: task,","rstoyanchev","2020-01-24T11:56:48Z","2020-01-24T15:58:48Z"
"","24279","java.nio.ByteBuffer not initialized correctly","The attached integration test leads to the following problem when run against the attached Demo App. ``` java.lang.UnsupportedOperationException: null 	at java.base/java.nio.ByteBuffer.array(ByteBuffer.java:1041) ~[na:na] 	at com.example.demo.DemoApplication.lambda$handle$0(DemoApplication.java:36) ~[classes/:na] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:100) ~[reactor-core-3.3.1.RELEASE.jar: ... ``` The Demo App is a very basic echo server written in Spring Webflux. Every binary WebSocket message sent to it will be echoed. The interesting part looks like this: ```java     @Override     public Mono handle(WebSocketSession session) {         return session.send(                 session.receive()                         .map(WebSocketMessage::getPayload)                         .map(dataBuffer -> DataBufferUtils.retain(dataBuffer).asByteBuffer().array())                         .map(bytes -> {                             byte[] newArray = new byte[bytes.length + 1];                             newArray[0] = 1;                             System.arraycopy(bytes, 0, newArray, 1, bytes.length);                             return newArray;                         })                         .map(bytes -> session.binaryMessage(dataBufferFactory -> dataBufferFactory.wrap(bytes)))                         .doOnError(throwable -> LOGGER.error(""WebSocket error"", throwable))         );     } ``` The integration test connects to the server and tries to send a message like this: ```java     @Test     void sendATextMessage() {         client.execute(                 URI.create(""ws://localhost:8080/demo""),                 session -> session.send(Mono.just(session.binaryMessage(dataBufferFactory -> dataBufferFactory.wrap(new byte[]{1, 2, 3}))))                         .thenMany(session.receive().doOnNext(webSocketMessage -> {                             LOGGER.info(""Received: "" + webSocketMessage.getPayload().asByteBuffer().array());                         }))                         .then()         ).block(Duration.ofSeconds(10L));     } ``` When I change the program just slightly to support text messages instead of binary messages, it runs perfectly.  Please take a look! I am sure you guys are much more deeply involved in Java NIO than I am.  Tested platforms:  - OpenJDK 11.0.4 and Oracle JDK 1.8.0_212. - spring-boot-starter-webflux:2.2.2.RELEASE  [demo.zip](https://github.com/spring-projects/spring-framework/files/4014432/demo.zip)","closed","for: stackoverflow,","DrStefanFriedrich","2020-01-01T18:37:44Z","2020-01-07T12:03:07Z"
"","24804","Remove unnecessary assignment in PropertiesBeanDefinitionReader","The assignment `int sepIdx = -1;` is useless. Suggest to remove it.","closed","in: core,","chenqimiao","2020-03-28T13:56:59Z","2020-03-31T02:04:52Z"
"","24792","Fix broken link in Javadoc for DynamicPropertySource","The `{@link Supplier}` can not be referenced, because there is no `import java.util.function.Supplier;` So suggest introducing the package name in `Supplier` link.","closed","type: task,","chenqimiao","2020-03-26T14:10:34Z","2020-03-27T02:01:07Z"
"","24322","Add support for metadata push to RSocketRequester","The `RSocketRequester` does not currently support the metadata push interaction model of RSocket directly. Instead, you have to get the underlying RSocket and then build out your own composite metadata as follows:  ``` CompositeByteBuf metadataByteBuf = ByteBufAllocator.DEFAULT.compositeBuffer(); CompositeMetadataFlyweight.encodeAndAddMetadata(     metadataByteBuf,     ByteBufAllocator.DEFAULT,     ""messaging/x.hello.messageformat"",     ByteBufAllocator.DEFAULT.buffer().writeBytes(messageFormat.getBytes()));  rSocketRequester.rsocket()     .metadataPush(ByteBufPayload.create(Unpooled.EMPTY_BUFFER, metadataByteBuf))     .block(); ``` Full example here: https://github.com/gregwhitaker/springboot-rsocketmetadatapush-example  This is a little difficult on users of the library. I would like to suggest an enhancement that adds support for the metadata push interaction model to RSocketRequester.  Not sure what to suggest at this point as there are already request-level ""metadata"" methods on there that may cause confusion if a new metapush method was added. @rstoyanchev (if i understood his comment correctly) suggested sending a metadata push frame if no data was supplied and only metadata. On the surface that seems ok to me as I can't dream up any scenarios where I would be doing ""metadata push"" at the request level that I couldn't just use a combination of request metadata and the data payload for at that point, but I may be totally missing something obvious. Thoughts?","closed","type: enhancement,","gregwhitaker","2020-01-09T16:26:51Z","2020-05-14T14:55:39Z"
"","24774","Make resourceAnnotationTypes field final in CommonAnnotationBPP","The `resourceAnnotationTypes` field reference will not be reassigned. So suggest adding `final` keyword to this field.","closed","in: core,","chenqimiao","2020-03-25T04:56:38Z","2020-03-25T13:34:36Z"
"","24164","Add ""application/*+xml"" as supported media type to XML decoders","The `Jackson2JsonDecoder` supports own media types out of the box because it accepts `application/*+json` by default. The same does not work with xml (`Jaxb2XmlDecoder`). If you want to handle a xml response (with an own mediatype eg `application/my.type+xml`) with the spring webclient you'll get an error because no decoder can be found. You have to manually extend the `Jaxb2XmlDecoder` and let him accept any xml mediatype through the constructor and register this new decoder in the webclient. I think the Jackson and Jaxb decoder should behave the same way.","closed","type: enhancement,","Chr3is","2019-12-08T18:50:22Z","2019-12-10T16:54:48Z"
"","24318","Update CciLocalTransactionManager.java","The `determineTimeout(TransactionDefinition definition)` method  will fall back to this manager's default timeout if the transaction definition doesn't specify a non-default value , so can remove the code here and use  `determineTimeout(TransactionDefinition definition)`  directly","closed","","jujunchen","2020-01-08T14:52:30Z","2022-02-18T19:07:19Z"
"","23824","Revise ClassUtils.getMostSpecificMethod to check that provided method really belongs to the provided class hierarchy","The `ClassUtils.getMostSpecificMethod()` doesn't check any correlations between a `targetClass` and `method.getDeclaringClass()` causing unexpected behavior when a maybe method requested from fully different hierarchy.  See discussion here: https://github.com/spring-projects/spring-integration/pull/3082/files#r335614474","open","in: core,","artembilan","2019-10-16T18:05:04Z","2021-11-11T10:12:42Z"
"","24795","Remove the wrong @Nullable annotation in DynamicPropertiesContextCustomizer","The `buildDynamicPropertiesMap ` method may return an empty unmodifiableMap, but not null.","closed","status: superseded,","chenqimiao","2020-03-27T01:58:41Z","2020-03-27T16:04:24Z"
"","23945","Fix bug : sorting problem with beanPostProcessor annotated by @Order","The `beanPostProcessor` annotated with @Order will not be sorted, but the implementation of `PriorityOrdered` or `Ordered` will be sorted.","closed","in: core,","chenqimiao","2019-11-07T12:13:31Z","2019-11-08T02:32:30Z"
"","24100","Documentation typo","The [Spring Cloud Function documentation](https://cloud.spring.io/spring-cloud-static/spring-cloud-function/3.0.0.RELEASE/reference/html/spring-cloud-function.html#_comparing_functional_with_traditional_bean_definitions) makes reference to an artifact named:  `spring-cloud-function-starter-web`   instead of the real name of:   `spring-cloud-starter-function-web`","closed","for: external-project,","marco-ruiz","2019-11-29T02:02:14Z","2019-11-29T09:55:38Z"
"","24124","Improve configuration API of ClientCodecConfigurer.CustomCodecs","The 5.2.2 release includes new API to allow custom decoders to be registered to use the default configuration for decoders. There are a few things that could be improved about that.  1. The method one has to work with is named `withDefaultConfig(…)` and takes a `Consumer`. Wither methods usually return a new instance of the object being called on taking the argument into account. This one here simply provides a configuration abstraction I now have to use to configure my own decoder. 2. `DefaultCodecConfig`'s `maxInMemorySize()` returns a nullable `Integer`. `setMaxInMemorySize(…)` takes an `int`. Looks like everyone trying to use those methods will now have to repeat the same `null` check before copying the value over. 3. In general I wonder how the current programming model reacts to additional configuration exposed by `DefaultCodecConfig`. As it's user code that is responsible to copy properties from left to right, new options will not automatically propagated unless the developer finds out about that new property and adds the necessary line of copying.  Have you though about a `CustomCodecs.decoderWithDefaultConfig(…)` that register the given `Decoder` applying all applicable defaults? That especially would free developers from having to play catch up with new options added and also resolve the `null` checks needed for every client.","closed","type: enhancement,","odrotbohm","2019-12-03T12:48:01Z","2019-12-12T21:59:29Z"
"","24385","Use try-with-resource in ScriptUtils","That can use try-with-resource.","closed","type: task,","hyeonisism","2020-01-17T11:10:26Z","2020-02-09T14:46:30Z"
"","24393","Add close() method in FileCopyUtils to reduce duplication","That can be reduced by the close method.","closed","in: core,","hyeonisism","2020-01-17T17:50:50Z","2020-02-09T14:52:57Z"
"","24189","Supplement Test Cases In XmlBeanFactoryTests","Supplement Test Cases In XmlBeanFactoryTests","closed","in: core,","lixiaolong11000","2019-12-11T15:46:08Z","2019-12-13T15:14:27Z"
"","24672","Reduce String garbage in CglibAopProxy.doValidateClass()","Subj + some tiny improvements","closed","in: core,","stsypanov","2020-03-10T15:43:50Z","2020-03-12T09:00:50Z"
"","24310","Trim line in LineInfo only once","Subj","closed","type: enhancement,","stsypanov","2020-01-07T13:42:02Z","2020-01-07T15:04:43Z"
"","23967","5.1.x","study","closed","status: invalid,","lqstyle","2019-11-11T09:17:27Z","2022-01-24T09:58:52Z"
"","24014","Simplify UriComponentsBuilder.FullPathComponentBuilder.build()","String::replace is more simple and likely to perform better than repeating substring concatenation","closed","type: enhancement,","stsypanov","2019-11-18T11:54:54Z","2019-11-18T15:02:41Z"
"","24491","spring-aspects has a compile dependency on spring-orm","Starting from version 5.2.0 `spring-orm` is no longer an optional dependency of spring-aspects. https://search.maven.org/artifact/org.springframework/spring-aspects/5.2.0.RELEASE/jar  This causes the below conditional to match which will then try to auto configure a data source. https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java#L52  Was this intentional?   **Affects:** 5.2.x  ---","closed","type: bug,","asibross","2020-02-08T00:32:49Z","2020-02-18T13:55:34Z"
"","24632","Remove UTF-8 charset parameter from Content-Type in SseEmitter","SseEmitter is adding header ""Content-type:text/event-stream;charset=UTF-8"". Golang revproxy is expecting header ""Content-Type: text/event-stream"" for immediately flushing the event stream.  HTML standard says [ https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model ] ignore the MIME type param and the data is always expected in utf-8.  https://github.com/golang/go/blob/master/src/net/http/httputil/reverseproxy.go#L374","closed","type: enhancement,","sada-sigsci","2020-03-03T02:07:13Z","2020-03-04T19:50:31Z"
"","23825","Incorrect value of the MediaType.APPLICATION_PROBLEM_JSON_UTF8","spring-web: 5.2.0 The media type `APPLICATION_PROBLEM_JSON_UTF8` has incorrect value ~`application/problem;charset=UTF-8`~ instead of `application/problem+json;charset=UTF-8` missing the `+json` part.  [APPLICATION_PROBLEM_JSON_UTF8 = new MediaType(""application"", ""problem"", StandardCharsets.UTF_8);](https://github.com/spring-projects/spring-framework/blob/d1aee0e8691c41753621332ff69b17be3f7c8ba2/spring-web/src/main/java/org/springframework/http/MediaType.java#L373)  This causes regression like:       org.springframework.http.converter.HttpMessageNotWritableException: No converter for [class fully.qualified.name.of.our.Exception] with preset Content-Type 'application/problem;charset=UTF-8'","closed","type: regression,","jstanik","2019-10-17T07:18:32Z","2019-10-30T10:23:00Z"
"","24353","Unable to create HEAD response with completely empty body","Spring-Boot Version: `1.5.22.RELEASE`  When creating a route with the method `HEAD` in spring-boot, i.e.  ```java @RequestMapping(value = ""/"", method = HEAD) ```  And you have chunked-encoding enabled by default, it doesn't appear to be possible to return a response that is completely empty  (which is required for `HEAD` requests). For example if you do something like this  ```java return ResponseEntity.status(OK).contentLength(0).build(); ```  And analyze the bytes in the bodies response you get `""0\r\n\r\n""` which indicates chunked encoding. This is illegal according to the RFC-spec, see https://tools.ietf.org/html/rfc7230#section-3.3 specifically  ```    Responses to the HEAD request method (Section 4.3.2    of [RFC7231]) never include a message body because the associated    response header fields (e.g., Transfer-Encoding, Content-Length,    etc.), if present, indicate only what their values would have been if    the request method had been GET (Section 4.3.1 of [RFC7231]). ```  In other words, the response body should be completely empty. This is causing issues with certain http clients such as akka-http client which expect there to be no response in the body when making a `HEAD` request. The related issue with akka-http can be seen here https://github.com/akka/akka-http/issues/2883#issuecomment-574070860","closed","in: web,","mdedetrich","2020-01-14T11:11:08Z","2020-01-23T15:50:49Z"
"","24425","Digest Auth support in WebClient","Spring's WebClient allows specifying Basic Auth credentials quite simply: ```java webClient.get()         .uri(someEndpoint)         .headers(httpHeaders -> httpHeaders.setBasicAuth(someUserName, somePassword))         ... ``` However, there doesn't seem to be a way to configure the WebClient to perform Digest Auth ([RFC 7616](https://tools.ietf.org/html/rfc7616)).  A lot of servers rely on Digest Auth, and given that WebClient supports the less secure Basic Auth protocol, it would make sense to add support to the client's capabilities. Note that this feature has been requested in other places, for example on [StackOverflow](https://stackoverflow.com/questions/50865597/spring-webflux-webclient-does-it-supports-digest-based-authentication).  Thanks for considering this feature request!   _Issue originally posted in the Spring Security project (https://github.com/spring-projects/spring-security/issues/7861)._","open","type: enhancement,","PyvesB","2020-01-24T13:36:16Z","2021-06-03T14:51:46Z"
"","24411","Support model attribute data binding via builder API","Spring's argument resolver mechanism is very flexible and fits most of the scenarios. However, since nowdays most of applications uses Lombok and immutable objects with builders, t would be very good to have option to bind request argument directly to builder instance instead (I mean in addition to) Java Bean compliance objects only.   In my head it is kind of similar and straight forward - instead of introspecting setter/getter method to match request name, resolver would have to introspect methods to resolve those.","closed","type: enhancement,","Antoniossss","2020-01-22T07:45:24Z","2020-01-30T17:22:43Z"
"","24659","spring Interceptor failure","spring version:4.3.7.RELEASE  The interceptor is not available in spring with the following configuration, The preHandle method of the AuthInterceptor is not executed ```java @Component public class WebMvcConfigurerAdapterConfig extends WebMvcConfigurerAdapter {     @Resource     private AuthInterceptor authInterceptor;      @Override     public void addInterceptors(InterceptorRegistry registry) {         registry.addInterceptor(authInterceptor).addPathPatterns(""/**"");         super.addInterceptors(registry);     } } ``` However, the following configuration is available ```xml                                                       ```  Is my posture wrong？","closed","for: stackoverflow,","dingqianwen","2020-03-08T10:36:13Z","2020-03-10T15:47:16Z"
"","24733","UrI path error on websphere liberty(runtimes-wlp-javaee8)","spring version: 5.2.4.RELEASE websphere liberty: runtimes-wlp-javaee8.      url mapping is ""xxxx/**"" and request url is ""xxxx/"". it will been redirected to ""/"". By looking at the source code i have find the spring will to  read `com.ibm.ws.webcontainer.removetrailingservletpathslash` from `com.ibm.ws.webcontainer.WebContainer.getWebContainerProperties()`.  1. websphere liberty(runtimes-wlp-javaee8) can not set this property. 2. Class cl = classLoader.loadClass(className);     Properties prop = (Properties) cl.getMethod(methodName).invoke(null);     this code can not get the `getWebContainerProperties` method.      Static trace is ``` [err] java.lang.NoClassDefFoundError: com/ibm/wsspi/adaptable/module/UnableToAdaptException [err]   at java.lang.Class.getDeclaredMethods0(Native Method) [err]   at java.lang.Class.privateGetDeclaredMethods(Class.java:2701) [err]   at java.lang.Class.privateGetMethodRecursive(Class.java:3048) [err]   at java.lang.Class.getMethod0(Class.java:3018) [err]   at java.lang.Class.getMethod(Class.java:1784) [err]   at org.springframework.web.util.UrlPathHelper.shouldRemoveTrailingServletPathSlash(UrlPathHelper.java:613) [err]   at org.springframework.web.util.UrlPathHelper.getServletPath(UrlPathHelper.java:385) [err]   at org.springframework.web.util.UrlPathHelper.getPathWithinServletMapping(UrlPathHelper.java:217) [err]   at org.springframework.web.util.UrlPathHelper.getLookupPathForRequest(UrlPathHelper.java:172) [err]   at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:363) [err]   at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:110) [err]   at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:59) [err]   at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:395) [err]   at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1234) [err]   at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1016) [err]   at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [err]   at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [err]   at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [err]   at javax.servlet.http.HttpServlet.service(HttpServlet.java:686) [err]   at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [err]   at javax.servlet.http.HttpServlet.service(HttpServlet.java:791) [err]   at [internal classes] [err]   at inetsoft.web.security.SessionAccessFilter.doFilterInternal(SessionAccessFilter.java:38) [err]   at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [err]   at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) [err]   at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.JWTFilter.doFilter(JWTFilter.java:81) [err]   at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) [err]   at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.RequestPrincipalFilter.doFilter(RequestPrincipalFilter.java:57) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.CSRFFilter.doFilter(CSRFFilter.java:73) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.AnonymousUserFilter.doFilter(AnonymousUserFilter.java:90) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.DefaultAuthorizationFilter.doFilter(DefaultAuthorizationFilter.java:84) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:150) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.LogoutFilter.doFilter(LogoutFilter.java:35) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.InvalidateSessionFilter.doFilter(InvalidateSessionFilter.java:54) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.SecurityHeaderFilter.doFilter(SecurityHeaderFilter.java:61) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.security.WebSocketLimitFilter.doFilter(WebSocketLimitFilter.java:84) [err]   at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) [err]   at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:141) [err]   at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:82) [err]   at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) [err]   at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at inetsoft.web.SafeInputStreamFilter.doFilter(SafeInputStreamFilter.java:48) [err]   at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:201) [err]   at [internal classes] [err]   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [err]   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [err]   at java.lang.Thread.run(Thread.java:748) [err] Caused by: java.lang.ClassNotFoundException: com.ibm.wsspi.adaptable.module.UnableToAdaptException [err]   at com.ibm.ws.classloading.internal.AppClassLoader.findClassCommonLibraryClassLoaders(AppClassLoader.java:557) [err]   at [internal classes] [err]   at java.lang.ClassLoader.loadClass(ClassLoader.java:418) [err]   at com.ibm.ws.classloading.internal.AppClassLoader.findOrDelegateLoadClass(AppClassLoader.java:535) [err]   at [internal classes] [err]   at java.lang.ClassLoader.loadClass(ClassLoader.java:351) [err]   ... 100 more ```","closed","","codeWorldRookie","2020-03-19T07:13:34Z","2020-03-25T14:20:29Z"
"","24802","EclipseLinkJpaDialect applies per-transaction isolation level to shared DatabasePlatform","spring orm version: 5.1.4.RELEASE  In EclipseLinkJpaDialect class line 81 ``` if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) { 	// Pass custom isolation level on to EclipseLink's DatabaseLogin configuration 	// (since Spring 4.1.2) 	UnitOfWork uow = entityManager.unwrap(UnitOfWork.class); 	uow.getLogin().setTransactionIsolation(definition.getIsolationLevel()); } ```  for instance: If txA beginTransaction and there is Isolation.SERIALIZABLE around the repository class, the TransactionIsolation in uow.getLogin() will be changed to Isolation.SERIALIZABLE. Then txB beginTransaction with Isolation.DEFAULT, the condition is not met,  TransactionIsolation in uow.getLogin()  still be SERIALIZABLE.  I think the right code should like this:  ``` if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT    && definition.getIsolationLevel() != entityManager.unwrap(UnitOfWork.class).getLogin().setTransactionIsolation()) { 	// ...  } ```","open","type: bug,","deanwong","2020-03-27T17:22:35Z","2020-07-19T16:48:32Z"
"","24564","Consider supporting PreFlight requests and CORS in Servlet Functional Endpoints","Spring MVC [supports CORS with simple and pre-flight requests](https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/web.html#mvc-cors).  Spring MVC provides support for global CORS handling with a filter, but also local support with `@CorsMapping` annotations or a `CorsConfiguration` instance, which is provided to `AbstractHandlerMapping` implementations.  In the case of Servlet Functional Endpoints, the provided `CorsConfiguration` has no effect on pre-flight requests.  Here is a sample application:  ``` @Configuration public class SampleRouterConfig {  	@Bean 	public RouterFunction router() { 		return RouterFunctions.route() 				.POST(""/function"", (req) -> ServerResponse.ok().body(""Hello"")) 				.build(); 	} } ```  We can also set a custom `CorsConfiguration` on the `RouterFunctionMapping`.  In this case, the following request will not match any handler, and other `HandlerMapping` later in the chain will handle this:  ``` OPTIONS http://localhost:8080/function Origin: https://spring.io Access-Control-Request-Method: POST ```  Other `HandlerMapping` implementations have additional checks in the request matching infrastructure to check requests with `CorstUtils.isPreFlightRequest(request)`. See implementations of  `AbstractRequestCondition` and also `AbstractHandlerMethodMapping` itself.  I'm wondering if we should have here additional `RequestPredicates` to locally manage CORS requests, or if existing predicates should look for pre-flight requests and match anyway.","closed","type: enhancement,","bclozel","2020-02-21T14:48:58Z","2020-03-10T16:23:22Z"
"","24723","Support for X-Forwarded-Prefix in Spring HATEOAS","Spring HATEOAS doesn't currently support the `X-Forwarded-Prefix` header.  > NOTE: Examples are illustrative  We are using a reverse proxy / API gateway to serve a HATEOAS webflux project. Our API gateway accepts requests at:  `https://api.example.com/context/resource`  Our backend service address for this is:  `https://backend.example.com/resource`  It returns the following HATEOAS links  ``` {   ""_links"": {     ""self"": {       ""href"": ""https://backend.example.com/resource""     }   } } ```  By using the following headers:  ``` X-Forwarded-Host: api.example.com X-Forwarded-Prefix: /context ```  We would expect the result to be  ``` {   ""_links"": {     ""self"": {       ""href"": ""https://api.example.com/context/resource""     }   } } ```  Instead we are seeing that the `X-Forwarded-Host` header is being applied correctly, but the `X-Forwarded-Prefix` header is not, e.g.:  ``` {   ""_links"": {     ""self"": {       ""href"": ""https://api.example.com/resource""     }   } } ```  The `WebFluxLinkBuilder` used to create HATEOAS links leverages the `UrlComponentsBuilder` from spring-web, which is [missing the handling logic for the `X-Forwarded-Prefix` header](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L739). The [ForwardedHeaderTransformer (also in spring-web) does handle this header](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/server/adapter/ForwardedHeaderTransformer.java#L60).  I'm proposing having this added to the `UrlComponentsBuilder`.","closed","in: web,","stuartwakefield","2020-03-18T14:35:17Z","2021-06-01T10:19:21Z"
"","24609","CVEs on io.netty dependencies","Spring Framework version 2.2.4.RELEASE --- Hi, I found io.netty 4.1.45/44 that is used in your project has some security problem.   Overview org.wso2.transport.http:org.wso2.transport.http.netty is a HTTP protocol handling implementations for C5 based products.  Affected versions of this package are vulnerable to HTTP Response Splitting due to HTTP Header validation being disabled.  Remediation Upgrade org.wso2.transport.http:org.wso2.transport.http.netty to version 6.3.1 or higher.  References: CONFIRM - https://snyk.io/vuln/SNYK-JAVA-ORGWSO2TRANSPORTHTTP-548944      See below for more details:","closed","status: invalid,","sewilguler","2020-02-28T11:20:09Z","2020-03-02T08:23:11Z"
"","24828","Make it possible to run Spring MVC without kotlin-reflect","Spring Framework Kotlin support has been designed to make it possible to run it without `kotlin-reflect` artifact (even if various features are disable in that case). The Coroutines check in `AbstractHandlerMethodMapping.MappingRegistry#register` should have a `kotlin-reflect` lenient check instead of throwing a `java.lang.NoClassDefFoundError: kotlin.reflect.jvm.ReflectJvmMapping` like currently in Spring Framework 5.2.5.","closed","type: bug,","sdeleuze","2020-03-31T13:32:12Z","2020-04-14T12:59:57Z"
"","23951","allow-bean-definition-overriding not working as expected","Spring boot version: [2.1.6.RELEASE, 2.2.1.RELEASE]  ``` package a.b;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class Foo {    public static void main(String[] args) {      new SpringApplicationBuilder(Foo.class)         .run(args);   } } ```  ``` package a.c;  import org.springframework.stereotype.Service;  @Service public class Foo {} ```  `application.properties` contains following property  ``` spring.main.allow-bean-definition-overriding=false ```  **Expectation**   Failure on startup because two beans with name `foo` are not supposed to be registered.  **Reality** No exception and silently the non-main class bean is left out. (i.e. bean with name `foo` is registered with class `a.b.Foo`)  Note:  This is only the case when another bean contributor is the entry-point Spring boot application class.","open","in: core,","JigarJoshi","2019-11-07T17:11:04Z","2021-11-11T09:26:55Z"
"","24028","AOP Alliance with Kotlin: Joinpoint.proceed() on void method leads to IllegalStateException","Spring Boot Version used: 2.2.0  Steps to reproduce  1. Use kotlin 2. Implement the MethodInterceptor interface 3. Auto generate the methods - it generates `override fun invoke(invocation: MethodInvocation?): Any ` 4. Call invocation.proceed on a method returning null  Analysis so far: * Kotlin does not detect the nullability of the interface and the proceed() method correctly.  Suggestion: * Add Spring's Nullable annotation since it is based on JSR-305 (javax.annotation) `@Nullable` to at least the interface. The method also does not get picked up by the compiler (it is indicating Any!) - but that doesn't seem to be an issue.  Fix: Replace the return type of the implemented interface method with Any? (instead of Any).  Is this my bad or should the interface suggest that there could be a null value?","closed","type: enhancement,","eiselems","2019-11-19T11:18:43Z","2019-12-03T13:45:04Z"
"","24519","Include Spring Boot's JacksonTester in the test module","Spring Boot ships `JacksonTester` (see Boot's [reference docs](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests)) that's very handy to formulate assertions on Jackson rendered payloads. That kind of functionality is very helpful for tests in Spring projects that deal with Jackson serialization (Spring HATEOAS, Spring Data REST) and it doesn't look like the class is tied to Boot in any way.  That said, it refers to AssertJ as assertion library but there seem to be quite a few themes regarding the integration of AssertJ APIs in e.g. MockMVC already.","open","type: documentation,","odrotbohm","2020-02-13T13:27:30Z","2022-06-07T11:09:28Z"
"","24175","Add hook-point to exclude imported configuration classes","Spring Boot has an optimization in which a `DeferredImportSelector` implementation has a chance to look at an index to remove auto-configuration classes that do not match conditions that can be evaluated early (typically, `@ConditionalOnClass`). This has the net effect of removing the FQN for each non matching candidate so that the class isn't even loaded while still making sure the auto-configuration report contains an entry for it.  Unfortunately, this arrangement does not extend to configuration classes that are imported as a result of processing an auto-configuration. A large number of auto-configurations are enabled with minimal assumptions, followed by all supported combinations in a form of an isolated `@Configuration` class, each having their own conditions. Extending this mechanism to ""sub-imports"" would skip a fair amount of configuration classes, depending on the classpath of the application.  Concretely, everything happens in `ConfigurationClassParser`. When `processConfigurationClass` kicks in, members are evaluated for a `@Component` (that could be configuration classes in the form of inner classes, a very common setup in Spring Boot) and `@Import` annotations are processed. This method currently misses some form of ""owner"" (or the component that required the scan).  If we had such argument, we could check if the owner implements an additional strategy interface, something like  ```java interface ConfigurationClassFilter { 	 	boolean filter(String configurationClassName); } ```  On the Spring Boot side of things, we could make sure our `DeferredImportSelector` implements this interface as well and filter the class argument the same way it does early on when looking at the list in `META-INF/spring.factories`.","closed","type: enhancement,","snicoll","2019-12-10T07:48:08Z","2020-02-05T17:20:18Z"
"","24735","@Spybean cannot mock apsectj @Cacheable method","Spring Boot 2.2.5.RELEASE  Mocking a `@Cacheable` method with `@SpyBean` results in `null` when calling method. Example: ``` @Service public class SomeService{     @Cacheable(""somecache"")     public String method() {         return ""not"";     } } ``` ``` @SpringBootTest @TestExecutionListeners(MockitoTestExecutionListener.class) public class TestClass extends AbstractTestNGSpringContextTests {     @SpyBean SomeService spybean;      @Test     public void test(){        doReturn( ""expected"" ).when( spybean ).method();        assertEquals( spybean.method(), ""expected"" ); //fails     } }  ```","open","in: core,","cdalexndr","2020-03-08T22:19:12Z","2021-11-10T09:51:27Z"
"","23899","Support one off scheduled tasks","Sometimes I want to have a task that runs 1M after the app starts as well as once a day at 1AM.  Right now, there doesn't seem to be an option using `@Scheduled` to do this.  A workaround is to annotate the method like this:  ```java @Scheduled(cron = ""..."") @Scheduled(initialDelayString = ""PT1M"", fixedDelay = Long.MAX_VALUE) public void doSomething() { } ```  It would be nice if `@Scheduled` had an attribute such as `runOnce=true|false` and/or `maxRuns=integer` to control how many times a scheduled job is allowed to run.","open","in: core,","behrangsa","2019-10-31T02:38:56Z","2021-11-10T12:03:13Z"
"","24523","Allow easy localization of response object's fields","Someone [on StackOverflow](https://stackoverflow.com/questions/60189856/how-to-localize-individual-values-of-domain-objects-in-a-rest-api-build-with-spr/60209390#60209390) brought up an interesting use case. Imagine a Java class used to create a JSON response body and one of the String fields contains a message to be localized:  ```java class MyResponse {   String messageKey; } ```  A Spring MVC controller method could now of course use a `MessageSourceAccessor` to replace that value against a `MessageSource` and replace it in the model object. However, I wondered whether an annotation, that just declares ""This is a field to be localized"" could be used and some Jackson integration could be deployed that automatically translates the value during rendering. I.e. the domain object could look like this and that would remove the need for the controller manually triggering the translation.  ```java class MyResponse {   @JsonLocalized String messageKey; } ```  I have a prototypical implementation [over here](https://gist.github.com/odrotbohm/f00079458c970b43f69c2e1b292459e3) which probably could be extended to also support properties of type `MessageSourceResolvable`.  I briefly discussed with @wilkinsona whether something like this should rather live in Boot, but as nothing really ties this to Boot and there's already precedent in Spring Framework to allow customization of rendering of form objects with `@DateTimeFormat` we thought it might be a good fit for Framework. Of course one could also argue, that currently, Framework itself doesn't have any opinion regarding the Jackson setup while Boot already ships customizations and SPI to ease the implementation of serializers etc. I am entirely open for suggestions regarding that.","closed","status: declined,","odrotbohm","2020-02-14T12:43:43Z","2022-06-22T15:30:42Z"
"","24776","Optimize sortPostProcessors() in PostProcessorRegistrationDelegate","Size equal to 0 or 1 can return directly  ```java private static void sortPostProcessors(List postProcessors, ConfigurableListableBeanFactory beanFactory) { 		Comparator comparatorToUse = null; 		if (beanFactory instanceof DefaultListableBeanFactory) { 			comparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator(); 		} 		if (comparatorToUse == null) { 			comparatorToUse = OrderComparator.INSTANCE; 		} 		postProcessors.sort(comparatorToUse); 	} ```","closed","type: enhancement,","cherishsince","2020-03-25T08:33:52Z","2020-03-26T16:34:03Z"
"","24226","Introduce reactive @Transactional support in the TestContext framework","Since we have `@Transactional` working with R2DBC repositories in _1.0 M2_ (as said [here](https://spring.io/blog/2019/05/16/reactive-transactions-with-spring)), I would like to ask if there is a way to make `@Transactional` working with JUnit (integration) tests (the same way we are able to do when using JDBC repositories). Is this currently possible? Will this even be possible? What is the right approach to achieve transactional tests ?  Currently, running a `@Transactional` `@SpringBootTest` gives me `java.lang.IllegalStateException: Failed to retrieve PlatformTransactionManager for @Transactional test` (the same problem as this guy has: http://disq.us/p/2425ot1).","open","in: test,","jansvajcr","2019-12-18T13:37:15Z","2022-05-15T19:17:57Z"
"","24263","excludeFilters of @ComponentScan ignored since Spring Framework 5.2","Since Spring Boot 2.2.0 the `excludeFilters` of `@ComponentScan` is ignored when loading the Spring Boot application context.  When using a configuration class, loaded with `spring.factories` which does a `@ComponentScan` for the ""framework"" it provides, the application context is loading configuration classes which should be excluded (added to the `excludeFilters`). In version 2.1.11 all works fine. Starting from 2.2.0 the excluded class is loaded causing the context to fail.  I added a small maven project to reproduce the issue. Switch parent pom version to 2.2.0 (or later) and maven build will fail. It looks like a Spring Boot (test context?) issue. Tests using a standard Spring context are not affected (`common-framework-boot-support`module), the `@SpringBootTest` tests are (`application` module). [spring-componentscan-issue.zip](https://github.com/spring-projects/spring-boot/files/3999184/spring-componentscan-issue.zip)","closed","type: regression,","rob-valor","2019-12-24T23:29:00Z","2020-01-10T16:21:55Z"
"","24280","“Vary” headers for eot fonts with Spring 5.2 causes cache problems with IE9/IE11","Since Spring 5.2 the [Cors][1] [Handling][2] is changed, if the request is not a cors request. This impacts the loading of the fonts in IE9. Caching fonts in combination with IE9 is [kind of unstable][3]. Adding the the ""Vary"" headers on the fonts breaks the loading of the fonts after a reload of the page.  Best option is that visitors don't use IE 9 anymore, but I'm afraid I can't force that. It would be fine if this impacts only the font type. Unfortunately also some icons are loaded with a font, so this impacts functionality on some pages.      [1]: https://github.com/spring-projects/spring-framework/issues/22273   [2]: https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x#upgrading-to-version-52   [3]: https://stackoverflow.com/questions/13415073/on-ie-css-font-face-works-only-when-navigating-through-inner-links","closed","for: external-project,","MAJNaber","2020-01-02T13:15:33Z","2020-02-03T09:55:05Z"
"","24178","Document which parts of the AssertJ APIs are preferable","Since our use of AssertJ is relatively new, we should [document in the wiki](https://github.com/spring-projects/spring-framework/wiki/Code-Style#assertions) which parts of the AssertJ APIs are preferable for use in tests.  Doing so will avoid debates about what is the right way to assert something when AssertJ offers more than one way to achieve the same thing — for example, `assertThat(collection).size().isEqualTo(n)` vs. `assertThat(collection).hasSize(n)`.","open","in: core,","sbrannen","2019-12-10T11:30:37Z","2022-07-05T08:47:28Z"
"","24421","Test dependency injection into generic constructor","Since it is possible to recognize type for generic classes using ResolvableType mechanism, it should be possible to inject dependencies based on their defined types. It allows to autowire beans of generic types, created with BeanRegistryPostProcessor.  This test fails and shows, that Spring lacks capability of resolving any generics in runtime for beans, that have not defined their resolved type using Java or XML configuration. However, it is possible to check that all generics are resolved for this particular bean and it can be autowired.  I did some steps in direction of making this test green. This pull request aim is to ask if it is something, that is worth to fix in Spring. If it is, then I would want to ask in what direction should I move.  I started my work in direction of expanding MethodParameter with additional factory method, similar to `MethodParameter.forExecutable`. If we add ResolvableType as factory method parameter, it would completely possible to check resolved type for this MethodParameter.","closed","","gzoom13","2020-01-23T17:37:47Z","2022-02-18T19:06:45Z"
"","24051","HttpHandlerConnector does not propagate errors once response is committed","Since gh-23936, the `HttpHandlerConnector` uses a non-blocking thread for handling requests, thanks to `Mono.defer` and `Schedulers.parallel()`.  With this new arrangement, any error happening after the response is committed is completely ignored and dropped. The resulting `Mono` returned by the connector never completes and hangs.  Here is a test reproducing this issue:  ```java @Test public void handlerThrowingException() {   TestHttpHandler handler = new TestHttpHandler(response ->       response.setComplete()           .then(Mono.error(new IllegalStateException(""error while writing response body""))));    Mono connect = new HttpHandlerConnector(handler)       .connect(HttpMethod.POST, URI.create(""/path""), request -> request.writeWith(Mono.empty()));   StepVerifier.create(connect)       .expectError(IllegalStateException.class).verify(); } ```  This can happen if the server encounters an error while writing the response body (and the response has been completed already.  We've hit that problem in Spring Boot while upgrading Spring Framework, see spring-projects/spring-boot#19076.  I'm not sure how we're suppose to handle such errors and if `WebTestClient` should react. We might need to fix the test itself in Spring Boot, but I'd like to clarify that point first.","closed","in: web,","bclozel","2019-11-21T09:55:29Z","2019-11-22T10:29:33Z"
"","24764","Upgrade to Dokka 0.10.1","Since Dokka 0.9.x releases have always been pretty buggy, it seems interesting to upgrade to the latest Dokka `0.10.1` which fixes various bugs, see https://github.com/Kotlin/dokka/releases for more details. It will allow to benefit from upcoming minor releases as well.","closed","type: task,","sdeleuze","2020-03-23T11:57:20Z","2020-03-23T12:03:04Z"
"","24142","WebTestClientExtensions.expectBody doesn't work for generic types","Since `WebTestClientExtensions.expectBody` uses plain `Class` instead of `ParameterizedTypeReference`, it cannot correctly deserialize generic types.  ```kotlin package net.example  import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController  @SpringBootApplication class ExampleApplication  @RestController class ExampleController {     @GetMapping(""example"")     fun index(): ExampleWrapper = ExampleWrapper(ExampleData(""EXAMPLE"")) }  data class ExampleWrapper(val payload: T)  data class ExampleData(val string: String) ```  ```kotlin package net.example  import org.junit.jupiter.api.Assertions import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest import org.springframework.test.web.reactive.server.WebTestClient import org.springframework.test.web.reactive.server.expectBody  @WebFluxTest(ExampleController::class) class ExampleControllerTest @Autowired constructor(     private val webClient: WebTestClient ) {     @Test     fun test() {         webClient.get()             .uri(""/example"")             .exchange()             .expectBody>()             .consumeWith {                 Assertions.assertEquals(ExampleData::class, it.responseBody!!.payload::class)             }     } } ```  ``` java.lang.AssertionError:  Expected :class net.example.ExampleData Actual   :class java.util.LinkedHashMap ```","closed","type: enhancement,","hban","2019-12-05T13:22:48Z","2020-01-13T09:22:43Z"
"","24257","why ClassUtils.isAssignable(long.class,int.class) return false","simply thinking,  long abc = 5 should be ok, is this a bug? System.out.println(ClassUtils.isAssignable(long.class,int.class));","closed","for: stackoverflow,","gravin","2019-12-24T09:40:46Z","2019-12-24T10:02:45Z"
"","24221","Reduce Class[] garbage when creating proxies","Simple clean-up of reflection-related code: use ReflectionUtils.isEqualsMethod() / ReflectionUtils.isHashCodeMethod() / ReflectionUtils.isToStringMethod() in order to have unified approach in all pieces of code.","closed","type: enhancement,","stsypanov","2019-12-17T16:57:20Z","2020-03-24T09:30:16Z"
"","24291","Inherited @Transactional methods use wrong TransactionManager","Setup: In a multi-DB environment, there is an abstract Service/DAO class with `@Transactional` methods common to all entities from all DBs. Then there are multiple concrete Service/DAO beans, one per DB, each with specific transactionManager in the class-level `@Transactional` annotation.  Problem: When calling a base-class method via some DB-specific bean, a wrong transactionManager is used (always the `@Primary` one). The worst is that no exceptions are thrown, no error messages printed in log. The entities are simply silently e.g. not saved/updated in DB. Or, I afraid, they could even be saved to wrong DB.  The problem has already been described at least in #14011, #14295, #17080. Related issue is also #11839. But all the issues have been closed (as outdated) without a solution.  There were also some workarounds: https://stackoverflow.com/questions/51087660/dynamic-selection-of-transactionmanager-spring-boot, https://www.tirasa.net/en/blog/dynamic-springs-at-transactional, also #14295. But they all are not working (anymore).  How can it be solved? What do you, guys, do in such situation? Am I missing something obvious? Thank you for your thoughts.","open","in: data,","elab","2020-01-03T20:25:41Z","2022-04-10T18:25:22Z"
"","24707","Avoid ClassCastException for CoyoteInputStream in TomcatHttpHandlerAdapter","Servlet filter added in Spring Boot's `org.springframework.boot.web.embedded.tomcat.TomcatContextCustomizer` may override `HttpServletRequestWrapper.getInputStream()` and return an object derived from `ServletInputStream` that is not assignment compatible with Tomcat's `CoyoteInputStream`.","closed","type: enhancement,","sada-sigsci","2020-03-17T00:18:16Z","2020-03-19T12:21:08Z"
"","24055","MessageLite support with Protobuf","Seems like `ProtobufHttpMessageConverter` supports only full-featured protobuf `Message` inheritors.  Is it possible to add `MessageLite` support for `LITE_RUNTIME` protobuf usage?  https://github.com/spring-projects/spring-framework/blob/b5529f3f2bcf69c89a0a6a52c4f6b0034dc7f61e/spring-web/src/main/java/org/springframework/http/converter/protobuf/ProtobufHttpMessageConverter.java#L170-L173  - Spring: 2.2.1.RELEASE - Protobuf: 3.10.0","closed","status: declined,","dummyco","2019-11-21T18:55:47Z","2020-06-18T09:12:39Z"
"","23961","Allow ExchangeStrategies customizations in WebClient","Seems caused by https://github.com/spring-projects/spring-framework/commit/89d053d7f45fb1886b044be5e3276927d7a7798e / https://github.com/spring-projects/spring-framework/issues/23884.  After upgrading from Spring Boot 2.2.0 to 2.2.1, WebClient started throwing `org.springframework.core.io.buffer.DataBufferLimitException: Exceeded limit on max bytes to buffer : 262144` when calling a JSON REST API (that has a large response size).  From the linked documentation (https://github.com/spring-projects/spring-framework/blob/master/src/docs/asciidoc/web/webflux.adoc#limits), it's not clear what configuration should be changed to make our API calls work again.  Is this expected behavior?  Full stack trace: ``` org.springframework.core.io.buffer.DataBufferLimitException: Exceeded limit on max bytes to buffer : 262144 	at org.springframework.core.io.buffer.LimitedDataBufferList.raiseLimitException(LimitedDataBufferList.java:101) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Body from POST  [DefaultClientResponse] Stack trace: 		at org.springframework.core.io.buffer.LimitedDataBufferList.raiseLimitException(LimitedDataBufferList.java:101) 		at org.springframework.core.io.buffer.LimitedDataBufferList.updateCount(LimitedDataBufferList.java:94) 		at org.springframework.core.io.buffer.LimitedDataBufferList.add(LimitedDataBufferList.java:59) 		at reactor.core.publisher.MonoCollect$CollectSubscriber.onNext(MonoCollect.java:119) 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 		at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:213) 		at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:346) 		at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:348) 		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:572) 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:93) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:326) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:300) 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1478) 		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:503) 		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:442) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:281) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931) 		at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:792) 		at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:502) 		at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:407) 		at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1050) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","type: enhancement,","totof3110","2019-11-09T07:27:00Z","2022-01-28T12:06:23Z"
"","24369","Official Gradle Wrapper Validation GitHub Action","See: https://github.com/gradle/wrapper-validation-action","closed","status: declined,","JLLeitschuh","2020-01-15T18:46:40Z","2020-06-23T16:31:40Z"
"","24727","Add toString hook for GenericMessage to let end-users obfuscate non-public information in logs","See https://github.com/spring-projects/spring-integration/issues/3222 for more info.  An idea to have something like `GenericMessage .setToStringFunction(Function, String>)` which is going to be called from the `Message.toString()`. So, end-user can provide any possible way for presenting message in logs.  Thanks","open","status: pending-design-work,","artembilan","2020-03-18T19:13:41Z","2021-11-01T14:31:39Z"
"","24331","Expose the proxyPing property for client or server WebSocket with Reactor Netty","See https://github.com/reactor/reactor-netty/pull/945#issuecomment-571640355 for @violetagg's suggested places framework needs changing.  This is reactor-netty 9.3.x and 1.0.x so framework 5.2.x and 5.3.x respectively IIRC.  This is to support spring cloud gateway","closed","status: superseded,","spencergibb","2020-01-10T23:52:52Z","2020-01-16T08:02:40Z"
"","24010","Support escape chars in PropertyPlaceholderHelper","see gh-23348","closed","","nosan","2019-11-17T15:17:03Z","2022-02-18T19:07:17Z"
"","24128","Spring WebFlux & Jetty, large responses are cut off due to prematurely closed connection","See demonstration repository here: https://github.com/opentable/webflux-large-response-spring  # I. Description  Given a Spring WebFlux application running on Jetty server using Spring 5.1.6 / Spring Boot 2.1.5 and above:  When returning a response from the server that is sufficiently large*, the connection is closed prematurely and the response is cut off part-way through.  The client will only receive the bytes of the response prior to the cut off point. The server will emit a Jetty error, `java.io.IOException: Closed while Pending/Unready`.  ``` 2019-12-03 20:28:13.862  WARN 1 --- [ttp@6bb4dd34-15] org.eclipse.jetty.server.HttpOutput      : java.io.IOException: Closed while Pending/Unready ```  \* What is a ""sufficiently large"" response to trigger the cut-off depends on various factors detailed below.  This repository (https://github.com/opentable/webflux-large-response-spring) is a demonstration of the issue that can be used to reproduce when running locally from IDE, in a local Docker container, in Docker container deployed to Heroku, or running on some other container resource cluster (e.g. Mesos).  See usage details in the Background & Analysis section below. In short:  ```shell script $ curl -v localhost:8080/just?size=8000000 *   Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > GET /just?size=8000000 HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* >  < HTTP/1.1 200 OK < Date: Tue, 03 Dec 2019 21:56:03 GMT < Content-Type: text/plain;charset=utf-8 < Content-Length: 8000000 <  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa  (etc...)  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa* transfer closed with 7197652 bytes remaining to read * stopped the pause stream! * Closing connection 0 curl: (18) transfer closed with 7197652 bytes remaining to read ```   # II. Affected Versions  - Spring 5.1.6 / Spring Boot 2.1.5 and above (tested up to Spring 5.2.1/Boot 2.2.1) - Jetty 9.4.15.v20190215 and above (tested up to Jetty 9.4.24.v20191120) - Java 8 and above (tested up to Java 11)  Note that the issue is only impacted by the Spring/Boot version and not the Jetty or Java versions.  We tested various combinations of Spring, Spring Boot, Jetty, and Java versions and determined that the issue is introduced only with an update to Spring 5.1.6/Spring Boot 2.1.5, regardless of which Jetty or Java version is used.  The issue is *not* exhibited on Spring 5.1.5/Spring Boot 2.1.4, regardless of which Jetty or Java version is used.   ## Tests with different Spring and Jetty versions  _Does the issue occur?_  --  Boot 2.1.4, Jetty 9.4.15.v20190215: No (This is the default pairing for Spring Boot 2.1.4)  Boot 2.1.4, Jetty 9.4.16.v20190411: No  Boot 2.1.4, Jetty 9.4.17.v20190418: No  Boot 2.1.4, Jetty 9.4.18.v20190429: No  Boot 2.1.4, Jetty 9.4.19.v20190610: No  Boot 2.1.4, Jetty 9.4.24.v20191120: No  --  Boot 2.1.5, Jetty 9.4.15.v20190215: Yes  Boot 2.1.5, Jetty 9.4.16.v20190411: Yes  Boot 2.1.5, Jetty 9.4.17.v20190418: Yes  **Boot 2.1.5, Jetty 9.4.18.v20190429: Yes (this is the default pairing for Spring Boot 2.1.5)**  Boot 2.1.5, Jetty 9.4.19.v20190610: Yes  Boot 2.1.5, Jetty 9.4.24.v20191120: Yes  --  **Boot 2.2.1, Jetty 9.4.22.v20191022: Yes (this is the default pairing for Spring Boot 2.2.1)**  Boot 2.2.1, Jetty 9.4.24.v20191120: Yes  *Conclusion: The specific version of Jetty doesn't matter. The issue occurs consistently with Spring 5.1.6/Boot 2.1.5 and up, regardless of the Jetty version used.*   ## Tests with different servers (Jetty, Netty, Tomcat Undertow)  _Does the issue occur?_  **Jetty server: Yes**  Reactor Netty server: No  Tomcat Server: No  Undertow Server: No  Conclusion: The issue is produced only by a combination of Spring 5.1.6/Boot 2.1.5 with the Jetty server. We were able to make requests for significantly larger amounts of data using, e.g., Reactor Netty server without ever encountering the error.   # III. Background & Analysis  ## Q: Is it a problem with WebClient? A: No  We originally encountered this issue with an API gateway proxy server built on Spring Webflux, that uses the WebFlux `WebClient` to proxy requests and responses from downstream services. Web apps consuming these APIs would encounter an issue with large JSON responses returned by the API gateway being cut-off part way through.  Our initial assumption was that the issue has to do with the WebClient client connector used, but this hypothesis was disproved in testing. *Ultimately, what matters is that the response from the server is large, even if no downstream WebClient call is made.*  The demo app contains an API `/webclient?path=""foo""` which proxies a request to the URI `foo` and returns the result as an un-parsed String. When curling this API and proxying to a downstream URI that returns a very large response to the demo app, the demo app will attempt to return this to the caller. The server will close the connection prematurely and the client receives only a partial response.   ### Testing different WebClient client connectors  _Does the issue occur?_  **Reactor-netty client: Yes**  **Jetty-reactive-httpclient: Yes**  Conclusion: The client connector doesn't matter. The issue occurs consistently with either client connector, as long as the server component is Jetty.   ## Removing WebClient from the mix...  The demo app also contains an API `/just?size=bar` which simply generates a large static string of `size` number of characters and returns it in the server response using `Mono.just`. When curling this API with a sufficiently large size the server will close the connection prematurely and the client receives only a partial response.  Conclusion: The use of WebClient as part of the call stack doesn't matter. All that matters is returning a large response from the server.   ## What is a ""sufficiently large"" response?  We had a difficult time reproducing this issue at first because what is a ""sufficiently large"" response to trigger the premature connection close can vary by several orders of magnitude depending on the operating environment where the code is running.  We were able to reproduce the issue using this demo app in the following operating environments:  - Running locally in the IDE (IntelliJ) - Running in a local Docker container in Docker Desktop - Running in a Docker container in Heroku - Running in a Docker container in a Mesos cluster in our organization's remote data center  The number of bytes of the response that are necessary to trigger the cutoff *decreases* as you go down this list.  In other words, when running in our Mesos cluster, we are able to consistently reproduce the issue when requesting a response of 78200 characters or more. But when running in Heroku it requires up to 10x the number of bytes (as our Mesos cluster), and when running locally (in local Docker or in IDE) it can require up to 100x the number of bytes to trigger the issue.  Something about our Mesos cluster or our organizational network lowers the threshold significantly, but it is still possible to trigger the issue in these other environments by making the response size sufficiently large.  One hypothesis is that varying threshold has something to do with the network itself (maybe network latency?) over which the request is being made, but we have yet been unable to empirically test this.  Incidentally the threshold to trigger the issue in our Mesos cluster is *always exactly* 78200 characters.    ## What about container resource provisioning?  Given that we know the exact threshold to trigger the issue in a particular operating environment (78200 characters in Mesos), we were able to test whether container resource provisioning has any impact on triggering the issue.   ### Test container resource sizing  _Does the issue occur?_  **Tested with a provisioned container with 512m native memory and 0.1 cpus, and max heap of 256m: Yes, after 78200 characters**  **Tested with a provisioned container with 2048m native memory and 2.0 cpus, and max heap of 1024m: Yes, after 78200 characters**  Conclusion: Container resource sizing does not appear to have any impact on whether or not the issue is triggered or any affect on what is the triggering threshold.","closed","status: duplicate,","scottjohnson","2019-12-03T22:09:22Z","2020-10-11T10:15:47Z"
"","24340","Document Objenesis license in license.txt","See #24326","closed","type: task,","sbrannen","2020-01-13T13:41:38Z","2020-01-13T13:44:56Z"
"","24458","Unordered list not rendered in docs","See ![screenshot](https://user-images.githubusercontent.com/573017/73443268-a99b5800-4356-11ea-82f6-e8b29883b31c.png)  unordered list ist not rendered.","closed","status: superseded,","michael-o","2020-01-30T10:51:19Z","2020-01-31T14:02:25Z"
"","24459","Annoation missing @ in docs","See  ![screenshot](https://user-images.githubusercontent.com/573017/73443929-e3b92980-4357-11ea-8888-d313500b8997.png)","closed","status: superseded,","michael-o","2020-01-30T10:59:09Z","2020-01-31T07:59:01Z"
"","24526","Documentation - add link to latest current version in the reference","Search engines results often lead to old versions of Spring Framework reference and it is becoming a habit to go to address bar and change the version in the URL to current.   As I imagine it's not straightforward to optimise reference website for promoting latest current version in search results, one solution I have in mind is to add for every version older than current an information like:  > This is the documentation for an older version of Spring Framework. If you’re looking for the current documentation click here.   Sample how it is done in VueJS docs:  ![image](https://user-images.githubusercontent.com/1357927/74549989-e4091580-4f50-11ea-88df-f1fd83b22104.png)  Ideally it would link to the same page/section of the reference or redirect to reference home if section does not exist in the latest current version.","open","type: documentation,","maciejwalkowiak","2020-02-14T16:43:17Z","2021-11-11T10:35:14Z"
"","24170","Support for RxJava 3","RxJava 3 will certainly go GA in our Spring Framework 5.3 timeframe, so let's add support for it... next to deprecating RxJava 1 (#19628).","closed","type: enhancement,","jhoeller","2019-12-09T18:00:26Z","2020-05-11T07:52:19Z"
"","24427","Fix Asciidoctor Warnings","Running the `:asciidoctor` task produces two different types of warnings `possible	invalid	reference` and `skipping reference to missing attribute`. We should fix those errors","closed","type: documentation,","rwinch","2020-01-24T15:11:44Z","2020-01-24T15:15:42Z"
"","24482","Upgrade to RSocket 1.0.0-RC6","RSocket Java 1.0.0-RC6 is out. Spring Security 5.3 needs this version to get https://github.com/rsocket/rsocket-java/pull/731 It would be nice if Spring Framework could build against RSocket Java 1.0.0-RC6.","closed","type: dependency-upgrade,","rwinch","2020-02-05T21:26:29Z","2020-02-06T09:31:17Z"
"","24612","TransactionInterceptor constructors should accept a generic TransactionManager","Right now to configure a `TransactionInterceptor` programmatically with a `ReactiveTransactionManager` we need to call a default constructor and then `setTransactionManager(TransactionManager)`.  For consistency it would be better to have other constructors based on this `TransactionManager` abstraction instead of a `PlatformTransactionManager` trait.  I would even say it is not a breaking change since `PlatformTransactionManager extends TransactionManager`.","closed","type: enhancement,","artembilan","2020-02-28T15:01:26Z","2020-03-11T13:57:25Z"
"","24562","Support for byte-range requests in Servlet Functional endpoints","Right now in Spring MVC and WebFlux  we support byte-range requests for `Resource` response bodies. This is supported by infrastructure like `ResourceRegion`, `HttpRange` and `ResourceRegionHttpMessageConverter` - those are able to convert parts of `Resource` instances according to the requested ranges.  In Spring MVC, a critical part for that is implemented in `AbstractMessageConverterMethodProcessor`: detecting whether the request asks for byte ranges, and turning the `Resource` into a collection of `ResourceRegion` accordingly, to then let the message converter write those to the response.  In Spring MVC functional endpoints, we're missing that last part currently.  We can achieve that currently with:  ``` Resource resource = ... List httpRanges = request.headers().range(); if(!httpRanges.isEmpty()) {   return  ServerResponse.status(HttpStatus.PARTIAL_CONTENT) 		.contentType(MediaType.APPLICATION_OCTET_STREAM) 		.body(HttpRange.toResourceRegions(httpRanges, resource), new ParameterizedTypeReference>() {}); }  ```  Now I'm wondering how we could make this easier with functional endpoints. Handling that directly in `ServerResponse` can be challenging since it might be not expected by developers and we don't have access to the request at that point.  The `ResourceHandlerFunction` might be a better place for that, but it might lack flexibility since it would only work when mapping a particular handler and not whenever we want to return a `Resource` as a response body.","closed","type: enhancement,","bclozel","2020-02-21T09:55:42Z","2020-03-05T14:38:32Z"
"","23976","AbstractRequestLoggingFilter.getHeaderPredicate is accidentally public","Reviewing #23814 in terms of a missing backport to 4.3.x, a related accident seems to have happened in the 5.2 release: `getHeaderPredicate` is accidentally public, so let's make it protected as of 5.2.2 as well.","closed","type: bug,","jhoeller","2019-11-11T14:48:27Z","2019-11-11T14:56:31Z"
"","23837","spring review","review","closed","status: invalid,","coffeeCherry","2019-10-19T20:26:27Z","2019-10-20T14:51:00Z"
"","24301","Test using StepVerifier blocks when using Spring WebClient with retry","Reproducible with `Spring Webflux 5.2.2.RELEASE` (via `Spring Boot 2.2.2.RELEASE`). A sample application is available here: https://github.com/wujek-srujek/reactor-retry-test - please let me know if you would like me to put the complete code here, for now I just copied the relevant parts. Originally posted as a SO question here: https://stackoverflow.com/questions/59406297/test-using-stepverifier-blocks-when-using-spring-webclient-with-retry.  The following client code (Kotlin):      fun send(data: Data): Mono {         return webClient                 .post()                 .uri(uri)                 .contentType(MediaType.APPLICATION_JSON)                 .bodyValue(data)                 .retrieve()                 .toBodilessEntity()                 .doOnSubscribe {                     println("">>> Calling backend, uri: $uri"")                 }     //                .retryExponentialBackoff(     //                        maxRetries, firstBackOff, maxBackOff, jitter = true) {     //                    println(""<<< Call to $uri failed, will retry (#${it.iteration()} of max 2)"")     //                }                 .retryBackoff(maxRetries, firstBackOff, maxBackOff, 0.5)                 .doOnError {                     println(""<<< Call to $uri with 2 retries failed with $it"")                 }                 .doOnSuccess {                     println(""<<< Call to $uri succeeded"")                 }                 .then()     }  with the following test:      @Test     fun `test with WebClient`() {         val responseStatus = HttpStatus.INTERNAL_SERVER_ERROR          // client.maxRetries = 3         // server is an instance of okhttp3.mockwebserver.MockWebServer         repeat(client.maxRetries.toInt()) {             server.enqueue(MockResponse().setResponseCode(responseStatus.value()))         }          StepVerifier.withVirtualTime { client.send(Data(""some data"")) }                 .expectSubscription()                 .thenAwait(Duration.ofDays(1)) // wait long enough                 .expectNextCount(0)                 .expectError()                 .verify()     }  blocks. A similar test with retry but not using the `WebClient` works fine. The test blocks at the second retry (i.e. the first retry somehow works fine, the second one blocks indefinitely).","closed","for: external-project,","wujek-srujek","2020-01-06T13:08:15Z","2020-01-10T09:47:14Z"
"","24204","Fix behavior in ExceptionHandlerExceptionResolver.setResponseBodyAdvice","Removed the `clear()` call on the `responseBodyAdvice` list before adding the passed list to it in the `setResponseBodyAdvice`.  This brings the method in line with the existing documentation  Closes gh-24015","closed","type: enhancement,","rohitp27","2019-12-13T13:35:14Z","2020-05-19T14:45:57Z"
"","24115","Refactoring the AutowireUtils","Remove some confusing else statements.","closed","","ynfeng","2019-12-02T11:07:24Z","2020-03-10T13:37:50Z"
"","24470","Remove redundant escapes in regular expressions","Remove redundant character escape in RegExp","closed","in: core,","hyeonisism","2020-02-03T12:33:38Z","2020-02-09T14:47:30Z"
"","24057","Refine Coroutines annotated controller support","Related to #23866.","closed","type: task,","sdeleuze","2019-11-22T11:04:30Z","2019-11-22T13:14:14Z"
"","23873","Add tests for cancellation of transactional streams","Related issue: gh-23864.","closed","type: task,","mp911de","2019-10-25T15:00:40Z","2019-10-25T15:16:42Z"
"","24760","Provide a plaintext/data ProtocolResolver by default","Provide a `plaintext`/`data` `ProtocolResolver` by default and register it in the default `ResourceLoader`.  More and more applications are deployed as containerized apps so they benefit greatly from a simplified configuration deployment process. Especially applications that are configured via spring-boot-cloud-config could be improved with inline file configuration/ `Resource` support, all would be configured in a single file/""place"".  https://github.com/yidongnan/grpc-spring-boot-starter/issues/325 In that issue a user requested an additional string property for a `Resource` property because the cloud config only supports simple properties and file `Resource`s require an additional `s3:` setup. I suggested adding a custom `ProtocolResolver` but due to the early initialization of the configuration process there seem to be issues with the registration. It's not the first time I have been requested to implement that.  It doesn't matter for me whether a `plaintext` or `data` (or both) `ProtocolResolver` is added as long as there is a native way of configuring an inline file.  An example implementation for a `data`-URI Protocolresolver can be found [here in the examples](https://github.com/yidongnan/grpc-spring-boot-starter/pull/262). Corresponding ""implementation"" for plaintext can be found [here](https://github.com/yidongnan/grpc-spring-boot-starter/issues/325#issuecomment-586753335)   Feel free to copy/use these dummy implementation as a reference implementaiton.  I'm not sure whether this is the right place to open the issue, maybe this belongs more to spring-boot (cloud (config)), but based on the required code size and the general usefulness I decided to request the feature here.  **Alternatives considered**  - Extend the documentation of [´ProtocolResolver`](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/ProtocolResolver.html) / [`ResourceLoader`](https://docs.spring.io/spring/docs/5.2.4.RELEASE/spring-framework-reference/core.html#resources-resourceloader) with information how to register them ""as early as possible"". - Load the default/additional ´ProtocolResolver` using java's `ServiceLoader` at least if they don't require any additional parameters.","open","in: core,","ST-DDT","2020-03-22T16:46:58Z","2021-11-10T11:55:19Z"
"","23923","Improve usage of String.substring()","Proposed transformations make code more simple and faster due to reduction of allocations.","closed","type: task,","stsypanov","2019-11-04T12:48:22Z","2019-11-07T14:43:44Z"
"","24651","Introduce getContentAsString() in Resource to retrieve resource content as a String","Projects that use java heavily rely on a clunky, verbose, and error prone method to access Resources for tests.   Adding the ability to request a file's contents as a string for testing REST or WEBMVC allows for cleaner test classes and more readable code.","open","in: web,","derrick-pericipio","2020-03-06T05:44:49Z","2021-12-06T13:22:05Z"
"","23872","Stop Created-By manifest header from causing a test task cache miss","Previously, when a project's jar was an input into a test task, a cache hit required the current build to be using the same JDK as the one that created the cache entry. This was due to the `Created-By` entry in the jar's manifest which will vary if JDKs with different values for the java.version and java.specification.vendor version are used.  This commit configures normalization of the runtime classpath to ignore `META-INF/MANIFEST.MF`, thereby allowing a cache hit when the tests were previously run on a different JDK than the one being used now. Typically this is a different update release being used on a CI agent and a developer's machine. This change will therefore improve the likelihood of a cache hit once remote caching has been enabled.","closed","type: task,","wilkinsona","2019-10-25T10:00:19Z","2019-10-25T11:52:57Z"
"","24105","Enable reading from the remote build cache for all","Previously, the remote build cache was only enabled if the `GRADLE_ENTERPRISE_URL` environment variable was configured. This meant that contributors would not benefit from the build time improvements of the caching without some additional setup.  This pull request updates the `buildCache` configuration so that reading from the remote build cache at https://ge.spring.io is enabled for all. Pushing to the cache continues to be disabled unless the required credentials are provided. Build scan configuration has also been updated in line with this change. While the server URL is now hardcoded, publishing is still opt-in via an environment variable. The exact mechanism by which someone can opt in will change in the future once some server-side changes have been made. At this point, only a change to `publishAlwaysIf` should be necessary.","closed","type: task,","wilkinsona","2019-11-29T16:42:35Z","2019-11-29T16:58:17Z"
"","23970","Tidy up classpath pollution caused by resource creation in the tests","Previously, spring-webmvc and spring-webflux both contained tests that would create gzipped files, write them to the filesystem alongside the project's compiled test classes, and configure them to be deleted on JVM exit. The output location placed the files on the classpath, polluting it for every subsequent test that used the same ClassLoader. The test-sources plugin combined with Gradle's use of worker JVMs, broadens the scope of this pollution to other, downstream projects in the same build. For example, the tests for spring-websocket will have a different classpath depending on whether or not the tests for spring-webmvc have already been run on the same worker as part of the current build.  This PR updates the spring-webmvc and spring-webflux modules to introduce a new JUnit Jupiter extension, GzipSupport. This extension allows gzipped files to be created via an injectable GzippedFiles class and automatically deletes each created file in an after-each callback. This ensures that a gzipped file only exists on the classpath for the duration of the test that needs it, avoiding the pollution of the classpath of any subsequent tests.","closed","type: task,","wilkinsona","2019-11-11T13:34:39Z","2019-11-11T14:11:39Z"
"","24441","The new Encoder.encodeValue and Decoder.decode methods in spring 5.2 do not provide access to the Context","Previously, in spring 5.1, `org.springframework.core.codec.Encoder` and `Decoder` implementations could take advantage of the reactor subscriber `Context`, since all methods returned a `Mono` or `Flux`.  In spring 5.2, the following synchronous methods were added (as part of #22782): * in `Encoder`... `DataBuffer encodeValue(T value, DataBufferFactory bufferFactory, ResolvableType valueType, MimeType mimeType, Map hints)` * in `Decoder`... `T decode(DataBuffer buffer, ResolvableType targetType, MimeType mimeType, Map hints)`  These new methods are called instead of the older methods in various places.  E.g. `EncoderHttpMessageWriter.write` calls `encoder.encodeValue` in spring 5.2, where it previously called `encoder.encode` in spring 5.1.  See also [this comment](https://github.com/spring-projects/spring-framework/issues/22782#issuecomment-562706054).  These new methods do not provide access to the subscriber `Context` (since they don't return a `Mono`/`Flux`).  And there is also no way to force all callers to go back to the previous behavior of calling the old methods which do provide access to the `Context`.  Therefore, previous Encoder/Decoder implementations that utilized the subscriber `Context` are now broken in spring 5.2.  I'd like for the subscriber Context to be available in all of the encode*/decode* methods in an Encoder/Decoder.  Perhaps the Context could be added as a hint?  Or another default method added that provides the Context as an additional argument?","closed","type: regression,","philsttr","2020-01-27T21:08:58Z","2020-02-10T15:13:57Z"
"","23892","Only enable caching in main build when building a snapshot","Previously, caching was enabled for the main build irrespective of what type of version was being built. This meant that caching was used for snapshots, milestones, release candidates, and releases.  To ensure that tagged and released versions are built in isolation from previous builds, this PR only enables caching when building a snapshot.","closed","status: declined,","wilkinsona","2019-10-30T10:08:38Z","2019-10-30T19:16:35Z"
"","24371","Publish a build scan only if authenticated","Previously, anyone could publish a scan and publishing was performed if the `GRADLE_ENTERPRISE_URL` environment variable was set. ge.spring.io has now been locked down to prohibit anonymous build scan publishing. This commit aligns with this change by only attempting to publish a build scan when authenticated with the server. Authentication is achieved via an access token that is made available via an environment variable on CI and locally via a file in `~/.gradle`.","closed","type: task,","wilkinsona","2020-01-15T20:21:15Z","2020-01-16T11:01:44Z"
"","24097","@Primary not working for LocalContainerEntityManagerFactoryBean","Present in Spring 5.1.2.RELEASE  Created 2 beans of type `LocalContainerEntityManagerFactoryBean`, annotated one with `@Primary`. Neither EntityManager proxy (of type SharedEntityManagerCreator$SharedEntityManagerInvocationHandler) gets marked as primary when trying to get it through @Autowired  Seems related to  issue #22675  Beans goes through DefaultListableBeanFactory.isPrimary() with beanName as ""org.springframework.orm.jpa.SharedEntityManagerCreator#0"" and ""org.springframework.orm.jpa.SharedEntityManagerCreator#1"". Both do not start with a factory dereference prefix, so isPrimary() does not check the Bean's parent BeanFactory for the @Primary annotation, so the running application cannot decide which to autowire.","open","in: core,","CalebSLane","2019-11-28T07:26:15Z","2021-11-10T11:58:04Z"
"","24087","Add protobuf MessageConverter","PR for #24022.  Should I add this converter to ...?  - [ ] `SimpAnnotationMethodMessageHandler` - [ ] `AbstractMessageBrokerConfiguration` - [ ] `MessageBrokerBeanDefinitionParser`  I found that other converters are used in these classes.","closed","type: enhancement,","parviz-93","2019-11-26T18:33:04Z","2019-11-30T05:49:33Z"
"","24070","Add spring-jcl information to reference doc","PR adds Spring JCL module information and fixes syntax error in core-beans.adoc + https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logging link added for concrete implementation and configuration.  Closes gh-22158","closed","type: documentation,","vananiev","2019-11-25T07:31:39Z","2020-08-10T15:01:46Z"
"","24397","Polish copyConfigurationFrom implementation of AdvisedSupport","Polish copyConfigurationFrom implementation of AdvisedSupport","closed","","chenqimiao","2020-01-19T14:49:32Z","2022-02-18T19:07:20Z"
"","24300","Polish ResolvableType equals implementation","Please See the following code snippet of method `org.springframework.core.ResolvableType#forType(Type, TypeProvider, VariableResolver)`  ```java ResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver); ResolvableType cachedType = cache.get(resultType); if (cachedType == null) { 	cachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash); 	cache.put(cachedType, cachedType); } ```  Currently, this variable of `cachedType` is always `null`, because the property `componentType` of `resultType` is always `null`, which causes the `equals()` method to always return `false` and `cache.get()` always returns `null`.  The purpose of PR is to fix this problem.","closed","in: core,","chenqimiao","2020-01-06T12:26:40Z","2020-01-07T10:50:54Z"
"","24195","Add BeanPropertyRowMapper.newInstance(mappedClass, conversionService)","Please consider adding `BeanPropertyRowMapper.newInstance(mappedClass, conversionService)`. I believe it's going to cover most use cases requiring custom conversion service.  This is similar to `SingleColumnRowMapper.newInstance(requiredType, conversionService)` which was added in #1678.    You may like / need to add `@since` in javadoc. I wasn't sure what version to use.","closed","type: enhancement,","perceptron8","2019-12-12T11:36:34Z","2019-12-12T14:41:26Z"
"","23900","Permit annotating packages with @RequestMapping","Permit annotating packages via `package-info.java` with `@RequestMapping` to set the base path for controllers under a package and its sub-packages.  For example I have these packages:  * com.example.laptops.controller.v1 * com.example.laptops.controller.v2 * com.example.tablets.controller.v1 * com.example.tablets.controller.v2 * com.example.phones.controller.v1 * com.example.phones.controller.v2  Then:  * I want to annotate `com.example` with `@RequestMapping(path = ""/store"")` * Annotate `com.example.laptops` with `@RequestMapping(path = ""/laptops"")`  That would turn the base path for all controllers in `com.example.laptops.controller` to `/store/laptops`.  Then I can annotate the `com.example.laptops.controller.v1` package with `v1` and the `com.example.laptops.controller.v2` package with `v2`.  That would turn the base path for all controllers in `com.example.laptops.controller.v1` to `/store/laptops/v1` and the base path for all controllers in `com.example.laptops.controller.v2` to `/store/laptops/v2`.  And so on.","closed","type: enhancement,","behrangsa","2019-10-31T07:24:37Z","2020-04-08T17:54:39Z"
"","24409","Improve deleteRecursively() method in FileSystemUtil","Performance is too flawed in Java8. So I changed it.","closed","status: invalid,","hyeonisism","2020-01-21T11:57:48Z","2021-04-27T11:21:21Z"
"","24043","Add option to encode MultiValueMap of query params","Parameters passed using %-encoding will be double escaped by `fromCurrentRequest()`:  ```java @GetMapping @ResponseBody public Map test(@RequestParam MultiValueMap params) {     return Map.of(             ""params"", params,             ""uri"", ServletUriComponentsBuilder.fromCurrentRequest().toUriString()     ); } ``` ``` $ curl http://localhost:8080/?p=* {""uri"":""http://localhost:8080/?p=*"",""params"":{""p"":[""*""]}}  $ curl http://localhost:8080/?p=%2a {""uri"":""http://localhost:8080/?p=%252a"",""params"":{""p"":[""*""]}} ``` Spring Web 5.2.1.RELEASE","closed","type: enhancement,","OrangeDog","2019-11-20T13:48:40Z","2019-12-04T18:23:36Z"
"","24643","Name of scanned @Configuration class affects @Import to work or fail","Our projects rely heavily on bean overriding (yes, we know, disabled now by default for good reasons, but still useful at times and a different story).   We now traced down a phenomenon that the name of a `@Configuration` class found by the `@ComponentScan` seem to affect, whether overriding with `@Import` (or sub-classing) works properly. This is though the `ConfigurationClassParser` already does a lot of handling on this case, e. g. in `processConfigurationClass`.  Please find a test case in https://github.com/abenneke/sandbox/tree/master/spring-import-order: It contains four `@Configuration` classes: Two for a ""foo"" bean (`FooConfigurationA+B`) and two for a ""bar"" bean (`BarConfigurationA+B`). However, the `@Import` order is different between both configurations: `FooConfigurationB` is importing `FooConfigurationA` while `BarConfigurationA` is importing `BarConfigurationB`.  In the test we now see that overriding works as expected for ""foo"", but fails for ""bar""!?  Just to make sure we did not miss anything, we added the very same test using standard Spring methods and again using Spring Boot - but it does not make any difference here.","open","in: core,","abenneke","2020-03-04T21:17:52Z","2021-11-11T09:26:56Z"
"","24023","Avoid substring allocation in StringUtils.replace","Our heavily used `StringUtils.replace` implementation temporarily allocates `String` instances from `String.substring` calls which can easily be avoided by using the corresponding `StringBuilder.append` variants.","closed","type: enhancement,","jhoeller","2019-11-19T10:22:32Z","2019-11-19T13:55:06Z"
"","24585","Improve documentation for @Autowired/@Value in @Configuration classes","Original： `Otherwise, @Autowired and @Value do not work on the configuration class itself, since it is being created as a bean instance too early.`  I think this statement is not accurate enough. `@Autowired` actually works, if the priority of the definition of `BeanPostProcessor ` through `@Bean` lower than `AutowiredAnnotationBeanPostProcessor`. So, I think we can adjust this description.","closed","type: documentation,","chenqimiao","2020-02-24T18:13:04Z","2020-02-25T11:00:56Z"
"","23829","InaccessibleObjectException after upgrading to Framework 5.2","Originally raised [on stackoverflow.com](https://stackoverflow.com/questions/58434513/inaccessibleobjectexception-after-upgrading-spring-boot-from-2-1-9-to-2-2) this looks like a problem with the reworked annotation code.  ``` Exception in Application init method java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:567) at javafx.graphics/com.sun.javafx.application.LauncherImpl.launchApplicationWithArgs(LauncherImpl.java:464) at javafx.graphics/com.sun.javafx.application.LauncherImpl.launchApplication(LauncherImpl.java:363) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:567) at java.base/sun.launcher.LauncherHelper$FXHelper.main(LauncherHelper.java:1051)  Caused by: java.lang.RuntimeException: Exception in Application init method at javafx.graphics/com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:895) at javafx.graphics/com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195) at java.base/java.lang.Thread.run(Thread.java:830)  Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make public abstract java.lang.String com.sun.javafx.beans.IDProperty.value() accessible: module javafx.base does not ""exports com.sun.javafx.beans"" to unnamed module @6293abcc at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:344) at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:284) at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:198) at java.base/java.lang.reflect.Method.setAccessible(Method.java:192) at org.springframework.core.annotation.AttributeMethods.(AttributeMethods.java:80) at org.springframework.core.annotation.AttributeMethods.compute(AttributeMethods.java:272) at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) at org.springframework.core.annotation.AttributeMethods.forAnnotationType(AttributeMethods.java:255) at org.springframework.core.annotation.AnnotationsScanner.getDeclaredAnnotations(AnnotationsScanner.java:467) at org.springframework.core.annotation.AnnotationsScanner.getDeclaredAnnotations(AnnotationsScanner.java:439) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:210) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:227) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:227) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:227) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:227) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:227) at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:194) at org.springframework.core.annotation.AnnotationsScanner.processClass(AnnotationsScanner.java:130) at org.springframework.core.annotation.AnnotationsScanner.process(AnnotationsScanner.java:107) at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:97) at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:78) at org.springframework.core.annotation.TypeMappedAnnotations.scan(TypeMappedAnnotations.java:242) at org.springframework.core.annotation.TypeMappedAnnotations.isPresent(TypeMappedAnnotations.java:98) at org.springframework.boot.context.properties.ConfigurationPropertiesBean$BindMethod.isConstructorBindingType(ConfigurationPropertiesBean.java:308) at org.springframework.boot.context.properties.ConfigurationPropertiesBean$BindMethod.forClass(ConfigurationPropertiesBean.java:300) at org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator.validate(ConfigurationPropertiesBeanDefinitionValidator.java:57) at org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator.postProcessBeanFactory(ConfigurationPropertiesBeanDefinitionValidator.java:45) at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:286) at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:174) at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:706) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) at com.mdenis.mdhis3_service.core.MDHIS3_Service.init(MDHIS3_Service.java:109) at javafx.graphics/com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:824) ... 2 more ```","closed","in: core,","philwebb","2019-10-17T16:46:22Z","2019-10-30T13:32:24Z"
"","24289","Support multiple replyTo addresses in MailMessage","org.springframework.mail doesn't support multiple _replyTo_-adresses  Suggestion: implement like _to_, _cc_ or _bcc_   Scenario where this is needed:  1. i have a process which informs a user to do a task. 2. when he has finished the task he has to inform several other users by mail   (**the users to inform depend on the task**) 3. so it would be very helpfull if the process could set the other users as a replyTo inside the mail","open","type: enhancement,","frissner","2020-01-03T15:03:40Z","2020-06-12T11:16:39Z"
"","24797","What is the use of resolvableDependencies collection","org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory ``` beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); ``` ![image](https://user-images.githubusercontent.com/25558493/77720586-51659700-7023-11ea-9942-47a84f6163b2.png)   Why not register to the singletonObjects  beanFactory.registerSingleton(“name”,object);","closed","for: stackoverflow,","shadow-lyvee","2020-03-27T04:06:24Z","2020-03-27T14:22:11Z"
"","24278","Optimize search for applicable AOP Advisors","org.springframework.aop.support.AopUtils  ```java 	public static List findAdvisorsThatCanApply(List candidateAdvisors, Class clazz) { 		if (candidateAdvisors.isEmpty()) { 			return candidateAdvisors; 		} 		List eligibleAdvisors = new ArrayList<>(); 		for (Advisor candidate : candidateAdvisors) { 			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) { 				eligibleAdvisors.add(candidate); 			} 		} 		boolean hasIntroductions = !eligibleAdvisors.isEmpty(); 		for (Advisor candidate : candidateAdvisors) { 			if (candidate instanceof IntroductionAdvisor) { 				// already processed 				continue; 			} 			if (canApply(candidate, clazz, hasIntroductions)) { 				eligibleAdvisors.add(candidate); 			} 		} 		return eligibleAdvisors; 	} ```  ```java 	public static List myFindAdvisorsThatCanApply(List candidateAdvisors, Class clazz) { 		if (candidateAdvisors.isEmpty()) { 			return candidateAdvisors; 		} 		List eligibleAdvisors = new ArrayList<>(); 		boolean hasIntroductions = false; 		for (Advisor candidate : candidateAdvisors) { 			if (candidate instanceof IntroductionAdvisor) { 				if (canApply(candidate, clazz)) { 					eligibleAdvisors.add(candidate); 					if (!hasIntroductions) { 						hasIntroductions = true; 					}	 				} 				continue; 			} 			if (canApply(candidate, clazz, hasIntroductions)) { 				eligibleAdvisors.add(candidate); 			} 		} 		return eligibleAdvisors; 	} ```","closed","","meetinoct","2019-12-31T02:14:12Z","2020-01-17T21:22:51Z"
"","24153","Hoist Class.getName() from String concatenation to dodge an issue related to profile pollution","On one of my projects I've run into performance issue related to profile polution when `Class.getName()` is used inside of String concatenation chain. The issue is described here: https://stackoverflow.com/questions/59157085/java-8-class-getname-slows-down-string-concatenation-chain  As far as Spring is likely to remain on Java 8 code base I suggest to hoist Class.getName() from frequently executed concatenation chains at least from `ObjectUtils.identityToString()` which is called from loop in `DefaultListableBeanFactory.findAutowireCandidates()` and `SimpleTraceInterceptor.getInvocationDescription()`.","closed","type: enhancement,","stsypanov","2019-12-06T16:21:51Z","2019-12-06T22:29:07Z"
"","24433","Object comparisons between all wrapper classes should use equals","Object comparisons between all wrapper classes should use equals","closed","status: invalid,","walesu","2020-01-27T02:40:52Z","2020-01-28T09:27:35Z"
"","24456","Make RSocket call  interface based","Now we implement the RSocket service like this:  * Reactive service interface  ``` public interface AccountService {     Mono findById(Integer id);     Flux findAll(); } ```  * Service implementation with RSocket Exposed  ``` @Controller @MessageMapping(""org.xxxxx.account.AccountService"") public class AccountServiceImpl implements AccountService {     @Override     @MessageMapping(""findById"")     public Mono findById(Integer id) {         return Mono.just(new Account(id, ""nick:"" + id));     }     @Override     @MessageMapping(""findAll"")     public Flux findAll() {         return Flux.just(new Account(1, ""Jackie""), new Account(2, ""Tom""));     } } ```  * Client call with Java Proxy InvocationHandler  ``` return (T) Proxy.newProxyInstance(                 serviceInterface.getClassLoader(),                 new Class[]{serviceInterface},                 new RSocketReactiveServiceProxy(rsocketRequester, serviceInterface, timeout));     ```  Any plan to support this feature by default to make it easy for Java Developers. Now RsocketRequester is alike WebClient, but every developer can understand HTTP, and it's hard to developer to understand RSocket protocol.","open","type: enhancement,","linux-china","2020-01-29T19:45:56Z","2022-07-11T13:10:00Z"
"","24615","Add Encoder and Decoder for ByteBuf","Now it's not possible to output ByteBuf to browser with data from RSocket, gRPC or other Netty based RPC frameworks with Spring WebFlux, and you should convert ByteBuf to ByteBuffer.  Any consideration to support ByteBuf directly.   Maybe performance enhancement without convert, and API friendly.   ```    @GetMapping(value = ""/bytebuf"", produces = {MediaType.APPLICATION_JSON_VALUE})     public Mono byteBuf() {           //data from RSocket payload     } ```","closed","type: enhancement,","linux-china","2020-02-28T20:12:09Z","2020-04-06T11:51:30Z"
"","24452","Make method name as default value for @MessageMapping","Now I have a RSocket controller as following:   ```java @Controller @MessageMapping(""org.xxx.account.AccountService"") public class AccountRSocketController {     @Autowired     private AccountService accountService;      @MessageMapping(""findById"")     public Mono findById(Integer id) {         return accountService.findById(id);     } } ```  I don't want to write method name as @MessageMapping's value for each method handler,  some complicated and not good for method rename.  Is it possible to make @MessageMapping to use method name as default value like following code.   ```java     @MessageMapping     public Mono findById(Integer id) {         return accountService.findById(id);     } ```  I checked MessageMappingMessageHandler.java,  and any possible to pass method's name to getCondition(method)  and use method name as default value for @MessageMapping?  ```java @Override 	protected CompositeMessageCondition getMappingForMethod(Method method, Class handlerType) { 		CompositeMessageCondition methodCondition = getCondition(method); 		if (methodCondition != null) { 			CompositeMessageCondition typeCondition = getCondition(handlerType); 			if (typeCondition != null) { 				return typeCondition.combine(methodCondition); 			} 		} 		return methodCondition; 	} ```","closed","type: enhancement,","linux-china","2020-01-28T23:07:00Z","2020-05-14T15:04:57Z"
"","24160","Fix typos in DataBufferUtils Javadocs","Nothing much going on here: I've been writing a lot of code involving data buffers recently and noticed a couple of typos in the `DataBufferUtils` class.","closed","type: documentation,","PyvesB","2019-12-07T21:31:01Z","2019-12-08T13:03:23Z"
"","23972","Support for new MySQL 8 error code 3572","MySQL 8 exposes a new error code for lock acquisition failures in case of NOWAIT: namely, 3572 which we can translate to `CannotAcquireLockException`. On a specific note, this happens to be inconsistent with MariaDB which exposes the already supported code 1205 in such a scenario, so from that perspective we're closing a gap in our support between the two database variants.  For some context: https://falseisnotnull.wordpress.com/2018/04/23/mysql-vs-mariadb-wait-nowait-skip-locked/ https://hibernate.atlassian.net/browse/HHH-13698","closed","type: enhancement,","jhoeller","2019-11-11T13:45:28Z","2019-11-11T14:56:31Z"
"","24296","CoroutinesUtils not found","my spring version is 5.2.2.RELEASE, and work in eclipse 4.8 of windows10。 when I import the source into eclipse by reading import-into-eclipse.md.  it have errors in spring-core, spring-messaging, spring-webflux that cannot find CoroutinesUtils。 but I have found the module kotlin-coroutines in spring-core and it has been compile。 while does itCoroutinesUtils couldn't found","closed","","shouwangqing","2020-01-06T07:03:24Z","2020-01-27T08:52:31Z"
"","23891","Modify the default value of ddl-auto to ""none""","My project uses spring-data-jpa.  The company stipulates that the test environment and the generated environment database account have only read and write permissions.  I found that when ddl-auto is set to none, the database structure is also changed because there is no permission to cause the service to fail to start.  Official documentation says： You can set spring.jpa.hibernate.ddl-auto explicitly and the standard Hibernate property values are none, validate, update, create, and create-drop.   If I choose none, the program should not do anything.However, in spring-boot-autoconfigure, the none configuration is automatically removed, which is equivalent to not configuring ddl-auto.  I think there needs to be an option for him not to make any changes or verify the behavior of the database.","closed","status: invalid,","handong0123","2019-10-30T09:35:40Z","2019-10-30T15:19:49Z"
"","24541","Fixing logic error.","My application server provides HTTP(http://172.18.0.120) service on port 80, which runs behind the reverse proxy server providing HTTPS(https://domain.com) service on port 443. Then the websocket handshake to https://domain.com/websocket failed because the method org. Springframework. Web. CORS. Corsutils. Iscorsrequest() returns true(originUrl.getScheme() returns ""https"", request.getScheme() returns ""http"") when using HTTPS reverse proxy server to proxy HTTP service.","closed","status: invalid,","hebo6","2020-02-17T14:10:52Z","2020-02-18T13:53:26Z"
"","24013","Support escaping in SimpleJdbcInsert #13874","Motivation https://github.com/spring-projects/spring-framework/issues/13874  **Current implementation steps** 1.  Getting identifierQuoteString to use for escaping from dataBaseMetadata in `GenericTableMetadataProvider` http://docs.oracle.com/javase/6/docs/api/java/sql/DatabaseMetaData.html#getIdentifierQuoteString%28%29. 2. Added property usingEscaping in `SimpleJdbcInsert` and logic related to handling it in `TableMetadataContext`. 3. Updated tests.","open","in: data,","kitaisreal","2019-11-18T07:27:56Z","2021-11-10T12:22:17Z"
"","24169","Documentation misformatted","Most of the docs have disappeared from https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#spring-core Help!","closed","status: duplicate,","jbotuck","2019-12-09T17:20:40Z","2019-12-09T18:18:34Z"
"","24709","Modify the preprocessing method to completely modify the object","Modify the preprocessing method to completely modify the object","closed","status: declined,","luohongtu","2020-03-17T09:19:39Z","2020-03-19T05:59:02Z"
"","24381","Polish constants name in jta transaction manager factory bean","Modified because this did not match the uppercase rule of the class name.","closed","status: declined,","hyeonisism","2020-01-16T18:31:40Z","2020-02-09T14:45:58Z"
"","24627","Fix typo in testing.adoc","Minor typo in `testing.adoc` Thank you!","closed","type: documentation,","YooInKeun","2020-03-02T14:53:00Z","2020-03-02T15:25:36Z"
"","24677","Minor refactoring","Minor refactoring to have uniformity of code and remove unnecessary import","closed","status: declined,","YooInKeun","2020-03-11T09:05:22Z","2020-03-11T13:03:55Z"
"","24534","Update DigestUtils Javadoc with regards to InputStream closing","Maybe I need to use this file later, but for now, I just want the md5 string.  Would you modify the `DigestUtils` class to close it automatically?  Code:  ![DigestUtils](https://user-images.githubusercontent.com/26690346/74608658-14ea7580-511e-11ea-84ea-b7f17073aba9.png)  Result:  ![result](https://user-images.githubusercontent.com/26690346/74608681-3e0b0600-511e-11ea-86c2-610e1e33d333.png)","closed","in: core,","wanjiaXG","2020-02-16T16:40:29Z","2020-02-18T21:51:36Z"
"","23856","Repeatable annotation container no longer found on custom composed annotation","Looks like migration of `AnnotationUtils` to use the `MergedAnnotations` API has introduced a regression to the `public static  A findAnnotation(Method method, @Nullable Class annotationType)` method when finding repeatable annotations that are declared on custom composed annotations.  ```java // Repeatable annotation  @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Repeatable(Roles.class) public @interface Role { 	String value() default """"; } ```  ```java // Container annotation  @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface Roles { 	Role[] value(); } ```  ```java // Custom composed annotation   @Retention(RetentionPolicy.RUNTIME) @Role(""role_a"") @Role(""role_b"") public @interface MyCustomRole { } ```  ```java class MyObject { 	@MyCustomRole 	public void someMethod() {} } ```  `AnnotationUtils.findAnnotation(someMethod, Roles.class)` returns `null` after upgrading to 5.2.0.RELEASE  I've created a sample here to better demonstrate: https://github.com/Walliee/repeatable-annotations  All 3 tests pass on 5.1.10.RELEASE but only 2 on 5.2.0.RELEASE  **Affected versions:** 5.2.0.RELEASE","closed","in: core,","Walliee","2019-10-24T00:00:42Z","2019-10-24T20:24:20Z"
"","24192","ClassUtils.resolvePrimitiveClassName() should check names less than 8","looks even like `Boolean.class.getName()` will have a length than 8,  it will miss the cache.  why not use the max length of keys of `primitiveTypeNameMap`? 	 ```java public static Class resolvePrimitiveClassName(String name) { 		Class result = null; 		// Most class names will be quite long, considering that they 		// SHOULD sit in a package, so a length check is worthwhile. 		if (name != null && name.length() <= 8) { 			// Could be a primitive - likely. 			result = primitiveTypeNameMap.get(name); 		} 		return result; 	} ```","closed","in: core,","gravin","2019-12-12T08:14:37Z","2019-12-13T14:54:26Z"
"","24438","Upgrade to ASM 7.3","Let's pick up the recent ASM 7.3(.1) release for Spring Framework 5.2.4, in time for JDK 14 GA, also introducing early JDK 15 support through it.","closed","type: dependency-upgrade,","jhoeller","2020-01-27T16:11:26Z","2020-01-27T17:19:50Z"
"","24396","Let BeanFactoryAwareGeneratorStrategy extend ClassLoaderAwareGeneratorStrategy","Let `BeanFactoryAwareGeneratorStrategy` extends `ClassLoaderAwareGeneratorStrategy` to reuse `generate` implementation.","closed","in: core,","chenqimiao","2020-01-19T11:34:54Z","2020-02-04T14:09:10Z"
"","23927","Add Kotlin extensions for Cache and CacheManager","kotlin extensions for Cache and CacheManager","closed","type: enhancement,","sokomishalov","2019-11-04T16:09:30Z","2021-12-02T13:52:15Z"
"","24059","Make Kotlin DSL class constructors internal","Kotlin DSL are intended to be used via builder functions like `router { }`, `coRouter { }`, `beans {}` or extensions like `mockMvc.get()`, not via classes constructor like `RouterFunctionDsl()`. #23758 is a good example where we need to change constructor API.  This issue intend to make classes constructor like `RouterFunctionDsl()` internal, in order to allow only usage via builder and extension functions.","closed","type: task,","sdeleuze","2019-11-22T15:00:27Z","2019-11-22T15:26:29Z"
"","24093","Upgrade to Kotlin 1.3.61","Kotlin 1.3.61 is available now and also the corresponding Gradle plugin","closed","status: duplicate,","juergenzimmermann","2019-11-27T13:28:23Z","2019-11-27T13:38:22Z"
"","24006","Upgrade to Kotlin 1.3.61","Kotlin 1.3.60 is available now but the corresponding Gradle plugin isn't yet. Let's upgrade for 5.2.2, in any case.","closed","type: dependency-upgrade,","jhoeller","2019-11-15T08:56:10Z","2019-11-28T08:56:03Z"
"","24703","Fix syntax error","Just found a syntax Error. And our community recently started translate Spring Framework doc in Chinese. This is link and we has finished some parts of it https://www.simviso.com/doc/spring-framework-5.2.x-cn/","closed","status: declined,","chihiro2014","2020-03-15T19:26:15Z","2020-03-15T20:01:06Z"
"","24499","AbstractJackson2HttpMessageConverter handles JsonMappingException","JsonMappingException is treated as HttpMessageConversionException to keep the same behavior for new exceptions introduced in jackson-databind 2.10 Fixes issue 24455","closed","","Romster","2020-02-10T09:28:04Z","2020-02-12T15:47:52Z"
"","24334","org.springframework.core.io.UrlResource.createRelativeURL trims the ../../../../ to ../","JDK 8 + Spring Core 5.2.2.RELEASE  Calling:`URL org.springframework.core.io.UrlResource.createRelativeURL(String relativePath)` having `this.url = file:./../../../configuration/` `and relativePath = foo/bar.xml` results in:  `file:../configuration/foo/bar.xml` Corruption happens on line: `return new URL(this.url, relativePath);`  Seems to be a known bug in JDK, see: https://stackoverflow.com/questions/204784/how-to-construct-a-relative-path-in-java-from-two-absolute-paths-or-urls","closed","in: core,","typekpb","2020-01-12T00:27:12Z","2020-01-28T17:42:32Z"
"","24391","Data binding for Java record classes","JDK 14 introduces record classes as a preview feature, with an expectation of getting revised and possibly taken out of preview mode in JDK 15. This matches our Spring Framework 5.3 timeframe nicely, so let's aim for full data binding support against record classes: refined constructor-based binding on one side and property-style access to record-style ""getters"" with plain method names on the other side. This also goes nicely with several other constructor-based data binding refinements that we plan to get into 5.3.","closed","type: enhancement,","jhoeller","2020-01-17T16:37:34Z","2020-08-28T16:54:21Z"
"","23977","Fallback locale other than the system locale in AbstractResourceBasedMessageSource","It's already possible to fallback to the System Locale in, for example ``ResourceBundleMessageSource``. In my current case, I don't want to fall back to the system locale, but I want to fallback to the same Default Locale that the rest of our system uses.  ```java import org.springframework.context.MessageSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.support.MessageSourceAccessor; import org.springframework.web.servlet.LocaleResolver; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import org.springframework.web.servlet.i18n.SessionLocaleResolver;  import java.util.Locale;  @Configuration public class ResourceConfig implements WebMvcConfigurer {      private static final Locale DEFAULT_LOCALE = Locale.GERMAN;      @Bean     public LocaleResolver localeResolver() {         SessionLocaleResolver slr = new SessionLocaleResolver();         slr.setDefaultLocale(DEFAULT_LOCALE);         return slr;     }      @Bean     public MessageSourceAccessor messageSourceAccessor(MessageSource messageSource) {         return new MessageSourceAccessor(messageSource, DEFAULT_LOCALE);     } } ``` I already attempted this through the ``MessageSourceAccessor`` Bean above, but that only seems to configure the default locale when invoking ``getMessage(...)`` without specifying an explicit locale manually.  So the behaviour I would expect is, that if I have message files ``messages_{en,de}.properties``, and then a call like ``messageSourceAccessor.getMessage(""message.key"", Locale.FRENCH)`` would return the german string configured for ``message.key`` in ``messages_de.properties``","closed","type: enhancement,","sonOfRa","2019-11-11T15:51:49Z","2019-11-13T12:48:44Z"
"","24484","Improve assertion message in PersistenceExceptionTranslationInterceptor","It's a bit odd asserting the bean factory with != null and the given message.","closed","status: feedback-provided,","michael-simons","2020-02-06T08:11:25Z","2020-02-06T14:41:45Z"
"","24545","spring-data-mysqlx","It would be very nice to have spring-data-mysqlx, supporting MySQL's DocumentStore and CRUD operations using the X protocol","closed","for: external-project,","lefred","2020-02-17T21:44:13Z","2020-02-19T06:16:34Z"
"","23861","spring-context-indexer: support creating spring.components file in jar built with Spring 4","It would be nice, if spring-context-indexer would work with Spring 4 as well so that created jar file could contain `spring.components` file  # Benefits * libraries that use Spring 4 could produce jar files that contain `spring.components` file * applications that use Spring 5 with spring-context-indexer     * wouldn't fail because of library built with Spring 4 that relies on classpath scanning (for example because it contains classes with `@Component`)     * would start up faster (compared to disabling spring-context-indexer)  note, that libraries may even throw exceptions on application startup if spring-context-indexer is disabled (i stumbled upon one that doesn't support disabling indexer so as i understand it isn't possible to library requiring indexer to be turned on with another one that doesn't have `spring.components` file but relies on classpath scanning)  # Current situation Currently when buliding jar from Gradle project that uses spring 4 with additional dependencies ```Gradle dependencies {   // ...   annotationProcessor 'org.springframework:spring-context-indexer:5.2.0.RELEASE'   testAnnotationProcessor 'org.springframework:spring-context-indexer:5.2.0.RELEASE' } ``` then building jar succeeds without errors or even warnings, but jar file doesn't contain `spring.components`.","closed","status: declined,","atsu85","2019-10-24T12:53:11Z","2019-10-24T13:28:04Z"
"","24126","Extend WebClient with createException(HttpStatus code)","It would be nice if you could extend `WebClient` with `createException(HttpStatus code)`.  Because eg I have an external webservice that I have no control of, and it always returns `200 OK` EVEN in case of error responses in body and an error hint in the header.  So when I evaluate the response with a `ExchangeFilterFunction`, I might want to return a `clientResponse.createException(BAD_GATEWAY)` based on the received content.  This is impossible by simply calling `clientResponse.createException()`, which would create a json exception, BUT with status `200 OK` proxied through!  In my case, I'd like to write as follows:  ``` private static ExchangeFilterFunction errorHandler() { 	return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> {                   HttpHeaders headers = clientResponse.headers().asHttpHeaders();                   return (headers.getFirst(""error"").equals(""true""))  			? clientResponse.createException(BAD_GATEWAY).flatMap(ex -> Mono.error(ex)) //this is not possible atm 			: Mono.just(clientResponse); 	}); } ```","closed","type: enhancement,","membersound","2019-12-03T16:05:06Z","2020-03-05T14:28:40Z"
"","24503","Update advice on RestTemplate","It would be more helpful, and also accurate, to explain that the `RestTemplate` is in maintenance mode rather than mention a potential deprecation in the future.","closed","in: web,","rstoyanchev","2020-02-11T13:25:28Z","2020-02-11T14:08:11Z"
"","24326","Include Objenesis NOTICE file contents in binary distributions","It seems that Pivotal is distributing Objenesis binaries repackaged in the spring-core JAR. The spring-core binary JAR does not mention this in the license files included within, nor does it  include the information in the NOTICE file in Objenesis JAR file (META-INF/NOTICE in https://repo1.maven.org/maven2/org/objenesis/objenesis/3.1/objenesis-3.1.jar).  It is not clear to me if Pivotal is required to include the NOTICE contents in the binary distribution package by the Apache 2.0 terms, but doing so would certainly make it easier for redistributors of spring-core to discover that they must include the Objenesis NOTICE contents in their own documentation.","closed","type: task,","tazle","2020-01-10T11:25:50Z","2020-01-15T13:45:17Z"
"","24454","Spring scheduling may be prone to clock drift problems","It seems that [`ThreadPoolTaskScheduler`](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/scheduling/concurrent/ThreadPoolTaskScheduler.java) delegates the actual scheduling to `ScheduledThreadPoolExecutor` which is prone to clock drift problems. See [this blog post](https://medium.com/@leventov/cronscheduler-a-reliable-java-scheduler-for-external-interactions-cb7ce4a4f2cd) for some details.","open","type: enhancement,","leventov","2020-01-29T14:42:40Z","2021-05-25T11:39:47Z"
"","24166","Fix RSocketRequester Coroutines extensions","It seems #24073 broke the following Kotlin extensions for some use cases: `sendAndAwait`, `retrieveAndAwait`, `retrieveAndAwaitOrNull`, `retrieveFlow`, `retrieveMono` and `retrieveFlux`. After https://github.com/spring-projects/spring-framework/commit/6ed1b5835b84bab0fda48956cdad143080c063ae, these extensions should be applied on `RetrieveSpec` instead of `RequestSpec`.","closed","type: regression,","sdeleuze","2019-12-09T10:49:37Z","2019-12-09T10:52:04Z"
"","24629","@Scheduled methods in beans created by FactoryBeans are not cancelled","It looks like, that beans created by `FactoryBean`s are passed to `ScheduledAnnotationBeanPostProcessor.postProcessAfterInitialization`, however never get passed to  `ScheduledAnnotationBeanPostProcessor.postProcessBeforeDestruction`. Only the `FactoryBean` itself is checked via `ScheduledAnnotationBeanPostProcessor.requiresDestruction` (and of course fails to require destruction).  As a consequence, the methods in those beans are still continued to be started in parallel during the close-process of the application context - and of course fail when they try to access other beans, entity manager, transaction support, ... They are however finally stopped once the `TaskScheduler` is shut down.  Normal beans (without `FactoryBean`s) are created by `AbstractAutowireCapableBeanFactory.doCreateBean`, which in the end does `registerDisposableBeanIfNecessary`.   However beans created via `FactoryBean`s are created by   `FactoryBeanRegistrySupport.doGetObjectFromFactoryBean` `FactoryBeanRegistrySupport,getObjectFromFactoryBean` `AbstractBeanFactory.getObjectForBeanInstance` `AbstractBeanFactory.doGetBean`   and never get the `DisposableBeanAdapter` applied. Hence `@Scheduled` tasks created by those beans are not cancelled.  Please find a stripped down test case at  https://github.com/abenneke/sandbox/tree/master/spring-scheduled-factory The `ComponentConfiguration` creates two `ScheduledBean`s, one directly and another one via a simple `FactoryBean`. Both beans have the same `testScheduled` method to be triggered every 100ms. It also adds a `SlowDestroyBean`, which simply slows down the application context close process a bit. When you run the `Main` program, you see that  - both `testScheduled` are executed perfectly while the context is up and running, - once the closing process is started, the `testScheduled` invocation of the normal `ScheduledBean` are stopped as expected, however - the `testScheduled` invocations of the `ScheduledBean` created via the `FactoryBean` continue - until eventually the `TaskScheduler` is stopped  This might be related to #14146","open","type: enhancement,","abenneke","2020-03-02T20:14:16Z","2020-07-22T10:34:32Z"
"","24157","Regression: prototype @ControllerAdvice beans should not be cached","It is ignored that the scope of bean, which is annotated `@ControllerAdvice` .  Broken at this commit. https://github.com/spring-projects/spring-framework/commit/21267e56b7b4645e145422ee918eb75fab250f56  Bean of ControllerAdvice is wrongly cached, I think. If Scope of Bean which is annotated `@ControllerAdvice` and  register as a not singleton component, `ControllerAdviceBean#resolveBean()` should  request to BeanFactory.","closed","type: regression,","yokotaso","2019-12-07T05:30:31Z","2019-12-07T12:44:13Z"
"","24654","Fix common HashMap initial capacity issue in HttpMethod","It is a common error to specify HashMap's initial capacity as expected size. It doesn't take `load factor` into consideration, which is never 1.0. Fixed the issue in HttpMethod via the util method from guava library.","closed","","NathanQingyangXu","2020-03-07T04:47:27Z","2020-03-13T20:14:55Z"
"","24668","use StringBuilder instead of StringBuffer in ReflectUtils#getClass","It could use StringBuilder instead of StringBuffer in ```ReflectUtils#getClass```","closed","status: declined,","GungnirLaevatain","2020-03-10T07:26:08Z","2021-06-17T07:12:15Z"
"","24386","Use computeIfAbsent to simplify getSessionAttributesHandler()","It can simplify using computeIfAbesnt.","closed","type: task,","hyeonisism","2020-01-17T12:25:15Z","2020-02-09T14:49:40Z"
"","24404","Simplify canConvertElements method() in ConversionUtils class","It can simplify this way.","closed","status: declined,","hyeonisism","2020-01-20T13:02:11Z","2020-02-09T14:52:26Z"
"","24358","Simplify getParsedSql() method in NamedParameterJdbcTemplate","It can simplify this way.","closed","type: enhancement,","hyeonisism","2020-01-15T09:32:33Z","2020-02-09T14:47:15Z"
"","24378","Simplify hasNext method() in compositeIterator","It can simplify this way","closed","in: core,","hyeonisism","2020-01-16T16:12:53Z","2020-02-09T14:46:15Z"
"","24698","Use Collections.emptyList() instead of new ArrayList()","It can reduce object creation.","closed","","chenqimiao","2020-03-14T14:52:42Z","2020-03-17T17:05:05Z"
"","24383","Use dedicated catch block for ScriptException","It can be that.","closed","type: task,","hyeonisism","2020-01-17T10:56:58Z","2020-02-09T14:45:13Z"
"","24403","Simplify GenericConversionService.getMatchableConverters()","It can be simplify this way.","closed","in: core,","hyeonisism","2020-01-20T12:58:04Z","2020-02-09T14:45:47Z"
"","24380","Simplify spring configurator method getBeanNameByType()","It can be simplify .","closed","","hyeonisism","2020-01-16T18:00:30Z","2022-02-18T19:07:20Z"
"","24419","Simplify UrlFileNameViewController#getViewNameForUrlPath()","It can be simplify","closed","type: task,","hyeonisism","2020-01-23T09:26:38Z","2020-02-09T14:50:48Z"
"","24379","Use dedicated catch block for AnnotationConfigurationException","It can be separate.","closed","in: core,","hyeonisism","2020-01-16T16:53:34Z","2020-02-09T14:49:09Z"
"","24489","AbstractJackson2Decoder is not aware of jackson's non-blocking parser only supporting UTF-8","It appears that `AbstractJackson2Decoder` assumes that the non-blocking parser used with  `Jackson2Tokenizer` auto-detects input's encoding. This appears to not be the case as the parser only works for `UTF-8` and `ASCII` (see https://github.com/FasterXML/jackson-core/issues/596). This causes it to fail with any non-`UTF-8` compatible charset. For example, this code throws a `DecodingException`:  ```java     DataBuffer jsonBuffer = new DefaultDataBufferFactory()         .wrap(""{\""Psst!\"": \""I'm not UTF-8\""}"".getBytes(StandardCharsets.UTF_16));     Jackson2JsonDecoder decoder = new Jackson2JsonDecoder();     Flux flux = decoder.decode(Flux.fromIterable(List.of(jsonBuffer)),         ResolvableType.forType(new ParameterizedTypeReference >() {}),         MediaType.parseMediaType(""application/json; charset=utf-16""), Map.of());     flux.subscribe(System.out::println); ```","closed","type: bug,","mizosoft","2020-02-07T04:21:50Z","2020-02-20T10:20:55Z"
"","24196","CachedIntrospectionResults completely traverses interface hierarchy","Issue: SPR-16978","closed","type: backport,","rkopka","2019-12-12T12:15:47Z","2019-12-12T14:35:59Z"
"","24806","Recompile spring-web with Maven","Is there a way we can download spring-web  source and compile with Maven? If yes, could you please let me know the steps?","closed","for: stackoverflow,","kadimulam","2020-03-29T03:06:11Z","2020-03-29T07:56:26Z"
"","24638","addCandidateComponentsFromIndex should create ScannedGenericBeanDefinitions","Is there a special reason why `ClassPathScanningCandidateComponentProvider.addCandidateComponentsFromIndex` does create `AnnotatedGenericBeanDefinition`s while `scanCandidateComponents` creates `ScannedGenericBeanDefinition`s?  Without this `ScannedGenericBeanDefinition`s in `ConfigurationClassBeanDefinitionReader.isOverriddenByExistingDefinition` the bean definitions created from the index are treated different than the scanned bean definitions and overriding no longer works.","closed","in: core,","abenneke","2020-03-04T11:55:38Z","2020-03-11T13:57:25Z"
"","24745","Missing nullability declarations for package web.socket.server.jetty","Introduce `@NonNullApi`,`@NonNullFields` to package-info to help tools understand something about nullability.","closed","type: bug,","chenqimiao","2020-03-20T15:05:47Z","2020-03-25T03:01:52Z"
"","24485","Prevent unnecessary refresh for InjectionMetadata.EMPTY","InjectionMetadata.EMPTY won't cached well in AutowiredAnnotationBeanPostProcessor#injectionMetadataCache  org.springframework.beans.factory.annotation.InjectionMetadata#needsRefresh with InjectionMetadata.EMPTY always returns true,  And therefore AutowiredAnnotationBeanPostProcessor#find always calls AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata  As a result of this, Performance degration of constructing component  happen from 5.1.  Ref: https://github.com/spring-projects/spring-framework/issues/23905  This is a part of performance degration, And this pull request won't improve performance degration  completely. performance degration remains a little.","closed","in: core,","yokotaso","2020-02-06T08:31:37Z","2020-02-06T12:22:20Z"
"","23992","Fix inappropriate eager init.","Incorrectly passing the value of includeNonSingletons to the allowEagerInit parameter in the next method causes a subsequent allowEagerInit logic error.","closed","in: core,","SchutzeHades","2019-11-14T09:03:48Z","2019-11-14T09:14:17Z"
"","24669","Optimize global advisor registration in ProxyFactoryBean","In the source code, `Map names = new HashMap<>(beans.size());`, `beans.size()` actually equal `0`. This problem will cause the hashMap to resize multiple times in subsequent `put` operations. This operation of resize is expensive when the expected size is large. So, I think we can set a suitable `initialCapacity` value to `names`  of  `HashMap` type, doing this prevents `resize`.","closed","type: enhancement,","chenqimiao","2020-03-10T08:18:44Z","2020-03-23T23:09:16Z"
"","24510","Incorrect mention of getPropertyValues in BeanWrapper section of documentation","In the section of  **3.3.1** in spring framework `version 5.1.3.RELEASE` **core technologies** document, the document describes that there is a `getPropertyValues` method. In fact, there is no such method in the `BeanWrapeer` class. I'm not sure if this is a version problem or refers to a method in another class instead of `BeanWrapper`.  ![图片](https://user-images.githubusercontent.com/53943926/74342145-ff0a4700-4de3-11ea-9df0-1ea401621ba3.png)","closed","in: core,","zhuzhuman978","2020-02-12T14:08:43Z","2020-02-18T09:45:12Z"
"","24536","Support inlined properties in @PropertySource analogous to @TestPropertySource","In the annotation `@TestPropertySource` you can add single properties using `@TestPropertySource(properties = [""foo=bar""])`.  With the annotation `@PropertySource` this is not supported.  I would expect the test annotation and the production annotation to work the same way.   In our case we want to add a configuration in a library, which should set a single property.","closed","in: core,","huehnerlady","2020-02-17T08:26:37Z","2020-02-19T06:45:44Z"
"","24422","setReadOnly not defined in JpaTransactionObject in JpaTransactionManager","In spring-orm-8.2.3.RELEASE the problem described in Ticket # [23943](https://github.com/spring-projects/spring-framework/issues/23943) is still present.   At line 405 `txObject.setReadOnly(definition.isReadOnly());` txObject is of type JpaTransactionObject line 378 : `JpaTransactionObject txObject = (JpaTransactionObject) transaction;`  method isReadOnly() is not in the service contract of JpaTransactionObject.  Because of this I get the following message :  `Caused by: java.lang.NoSuchMethodError: 'void org.springframework.orm.jpa.JpaTransactionManager$JpaTransactionObject.setReadOnly(boolean)' 	at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:405) 	... 37 more`","closed","status: invalid,","pmartin8","2020-01-23T21:51:04Z","2020-01-23T22:25:13Z"
"","24710","MimeTypeUtils over-occupy the cpu","In Spring-core-5.2.2-Release Inner class ConcurrentLruCache, When the LRU cache is full, it over-occupt the cpu.  Because of the excess CAS and locks","closed","status: duplicate,","poorbarcode","2020-03-17T09:41:33Z","2020-03-17T15:10:21Z"
"","24540","Provide a mechanism to configure integration tests with a dynamic property source","In Spring Boot, we'd like to make it easier to set configuration properties from something else that's bootstrapped as part of running an integration test. The main use case that we have for this is setting [configuration properties based on the IP address and port on which a Testcontainers container is listening](https://github.com/spring-projects/spring-boot/issues/16886).  The current solution requires using an `ApplicationContextInitializer` to  manipulate the `Environment`:  ```java @Testcontainers @ContextConfiguration(initializers = DataRedisTestIntegrationTests.Initializer.class) @DataRedisTest public class DataRedisTestIntegrationTests {      @Container     public static RedisContainer redis = new RedisContainer();      // …      static class Initializer             implements ApplicationContextInitializer {          @Override         public void initialize(                 ConfigurableApplicationContext configurableApplicationContext) {             TestPropertyValues.of(                 ""spring.redis.host="" + redis.getContainerIpAddress(),                 ""spring.redis.port="" + redis.getMappedPort()             ).applyTo(configurableApplicationContext.getEnvironment());         }      }  } ```  We'd like to make this more of a first-class concept. One proposal is to achieve that via a method on the test class that can provide a property source:  ```java @Testcontainers @DataRedisTest class DataRedisTestIntegrationTests {     @Container    static RedisContainer redis = new RedisContainer();      // …      @DynamicPropertySource     static PropertySource redisProperties() {         return TestPropertyValues.of(             ""spring.redis.host="" + redis.getContainerIpAddress(),             ""spring.redis.port="" + redis.getMappedPort()         ).asPropertySource();     }  } ```  There are some interesting ordering considerations here. It requires the `RedisContainer` to have been started and assigned to `redis` before the `redisProperties()` method is called. To some extent at least, this is already a solved problem as the more cumbersome `ApplicationContextInitializer` approach shown above works today.","closed","type: enhancement,","wilkinsona","2020-02-17T13:36:19Z","2020-03-23T16:26:47Z"
"","23994","Avoid indefinite wait to connect in JettyWebSocketClient","In some cases, `org.eclipse.jetty.websocket.client.WebSocketClient.connect(listener, uri, request)` call will return a future that is never completed. It is reasonable that our `future.get()` must have a timeout to avoid thread blocking. I suggest something like: ```java Callable connectTask = () -> { 	Future future = this.client.connect(listener, uri, request); 	try { 		// TODO Configurable timeout 		future.get(2000, TimeUnit.MILLISECONDS); 	} catch (Exception ex){ 		logger.error(""Failed to connect to remote websocket endpoint"", ex); 		future.cancel(true); // This method will stop the running underlying task 	} 	return wsSession; }; ```","closed","type: enhancement,","Kukosoft","2019-11-14T11:31:16Z","2019-11-15T08:19:56Z"
"","24520","Spring Data Jpa - Query with SPEL - Named parameter not bound : __$synthetic$__","In parseParameterBindingsOfQueryIntoBindingsAndReturnCleanedQuery, the matcher is referencing the parsed query.  	Matcher matcher = PARAMETER_BINDING_PATTERN.matcher(resultingQuery);  When checking for quotes in the matched parameters, the matcher passes its own indexes from the parsed query to the spelExtractor.isQuoted method which references the original non-parsed query.  				if (spelExtractor.isQuoted(matcher.start())) { 					continue; 				}   By coincidence it appears the start index of some of your parameters in the parsed query match the start index of quotes in the original query.   ![quoteranges](https://user-images.githubusercontent.com/29769908/53455247-6bcbdc00-39ef-11e9-8ac0-00284680af26.png)   Thus, the above lines skip binding the parameters which results in the named parameter not bound exception.   I was able to get your test to pass by changing the names of some parameters in the filter slightly.  ![testpassedspringparser](https://user-images.githubusercontent.com/29769908/53455483-4b505180-39f0-11e9-819b-c422fa7e8bb6.png) .  _Originally posted by @mfedirko in https://github.com/spring-projects/spring-framework/issues/22450#issuecomment-467665886_","closed","for: external-project,","felixng1028","2020-02-14T05:41:15Z","2020-02-20T12:09:15Z"
"","23832","Consider target transaction manager for traditional vs reactive transaction decision","In our app, we have several controller methods that construct `Mono` within JPA transaction and returns it.  Something like:  ```kotlin @PostMapping @Transactional fun handle(): Mono {   val user = findUser()   val subscription = user.subscriptions[0]   return emailSender.send(subscription.email, ...) } ```  Before 5.2, the transaction commits when the method returns, and the returned side effect gets executed without holding a transaction.  With reactive transactions introduced in 5.2, code like this breaks because `JpaTransactionManager` is not a `ReactiveTransactionManager`.  Currently there is no way to restore the previous behavior as reactive transaction handling is always active in [TransactionAspectSupport](https://github.com/spring-projects/spring-framework/blob/243f2890ee9e98c97c8dc7278f033def3bf33f86/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L328-L337). It would be easier to upgrade if there is a way to opt-out from reactive transaction behavior.  Some ideas:  - Globally disable reactive transactions: `TransactionAspectSupport#setEnableReactiveTransactions(false)`? - Selectively disable reactive transactions: `@Transactional(reactive = false)`?","closed","type: regression,","dittos","2019-10-18T14:01:21Z","2019-10-30T15:23:54Z"
"","24756","Add BeanPostProcessors in bulk","In one of my applications there's about 50 post processors added in loop to `CopyOnWriteArrayList`. I think this can be improved by using bulk method where lock/unlock happens only once for all PP and less garbage is produced inside of `CopyOnWriteArrayList`.","closed","type: enhancement,","stsypanov","2020-03-21T17:16:29Z","2020-05-13T14:09:24Z"
"","24506","org.springframework.orm.hibernate5.SpringSessionContext.currentSession() does not handle jta transaction that is not in active state appropriately","In hibernate5 SpringSessionContext, 'currentSession' checks the existence of a transactionManager and a jtaSessionContext.  If they exist, it then checks the transactionManager status to see if the transaction is active.  Unfortunately, if the transactionManager status is not active, the code does not throw an exception but instead 'falls through' to using a SessionHolder based session.    This session in some cases gets leaked permanently into the thread local 'TransactionSynchronizationManager.resources' (for some reason, the clear() method of this class does not clean up the resources thread-local').    From this point on, the thread is corrupted, because this session is always pulled out of the thread-local preferentially in 'currentSession'. (and in our case this session object is marked-for-rollback permanently).  So that thread is essentially dead.  A proposed fix is to have an 'else' statement on the transactionManager status check that throws an exception.","open","type: bug,","mwgreen","2020-02-11T17:09:28Z","2020-02-20T17:05:55Z"
"","24740","Improve Javadoc in AnnotatedElementUtils","In fact, an empty set will be returned if none found in `getMetaAnnotationTypes` method. In addition, `org.springframework.core.annotation.AnnotatedElementUtilsTests#getMetaAnnotationTypesOnNonAnnotatedClass`  method can also verify this。","closed","in: core,","chenqimiao","2020-03-20T07:35:40Z","2020-03-20T15:21:07Z"
"","24435","WebFlux RouterFunctions builder lets you compile two equal paths","In comparison to Spring MVC, the WebFlux RouterFunction builder does not raise an exception whereas **Spring MVC throws a ""java.lang.IllegalStateException""** saying: ""Ambiguous mapping. Cannot map '...Controller' method"" on compile time.  It took me half an hour trying to figure out why my endpoint did not return any data, instead, it returned a 404 Not Found.  **Example:** In Spring MVC, this does not compile:  ```java @GetMapping(""/all"") public List getAll() {     return ... }  @GetMapping(""/all"") public List getAll() {     return ... } ```  Meanwhile, the Spring WebFlux RouterFunctions builder lets you compile this (nor does it throw an exception on runtime):  ```java @Bean RouterFunction userRoutes(UserHandler handler) {     return RouterFunctions.route()             .GET(""/all"", handler::findAll)             .GET(""/all"", handler::findAll)             .build(); ```","closed","","itsandreramon","2020-01-27T09:34:22Z","2020-02-10T14:01:02Z"
"","24388","Hoist concatenation of two constant Strings out of loops","In cases when concatenation arguments are the same they produce equal String at each iteration. This is why we can hoist them to reduce output of String garbage.","closed","type: task,","stsypanov","2020-01-17T14:14:41Z","2020-02-25T14:02:37Z"
"","24005","What is the purpose of this code","In `registerBeanDefinition()` method, What is the purpose of this code ? ```java this.beanDefinitionMap.put(beanName, beanDefinition); 					List updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); 					updatedDefinitions.addAll(this.beanDefinitionNames); 					updatedDefinitions.add(beanName); 					this.beanDefinitionNames = updatedDefinitions; ```","closed","status: invalid,","Pamgo","2019-11-15T08:35:33Z","2019-11-15T08:54:29Z"
"","24682","Improve javadoc in RollbackRuleAttribute regarding nested classes","In `public RollbackRuleAttribute(Class clazz) `, only store the class name of the specified class, and in `private int getDepth(Class exceptionClass, int depth) `, matching logic is by `exceptionClass.getName().contains(this.exceptionName)`. So, the enclosed class of the specified parameter of `public RollbackRuleAttribute(Class clazz)` also can be match. Suggest Improve javadoc in corresponding method.","closed","type: documentation,","chenqimiao","2020-03-12T01:46:25Z","2020-03-15T11:32:17Z"
"","24455","AbstractJackson2HttpMessageConverter + Jackson 2.10: handle ValueInstantiationException properly","In **jackson-databind** version 2.10 a new exception was introduced:  ValueInstantiationException It appears when we can't instantiate a new instance but successfully parsed input json.  In my case, it was null-checks in the constructor. Previously exception which were thrown in constructor caused InvalidDefinitionException and was wrapped into HttpMessageConversionException by AbstractJackson2HttpMessageConverter: ``` protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage) 			throws IOException, HttpMessageNotWritableException {  		MediaType contentType = outputMessage.getHeaders().getContentType(); 		JsonEncoding encoding = getJsonEncoding(contentType); 		JsonGenerator generator = this.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding); 		try {                 ......                 ......  		} 		catch (InvalidDefinitionException ex) { 			throw new HttpMessageConversionException(""Type definition error: "" + ex.getType(), ex); 		} 		catch (JsonProcessingException ex) { 			throw new HttpMessageNotWritableException(""Could not write JSON: "" + ex.getOriginalMessage(), ex); 		} 	} ``` But with a new version of **jackson-databind** (2.10.2, which comes with spring-boot) a new ValueInstantiationException is thrown and it is handled as a JsonProcessingException. Thereby  HttpMessageNotWritableException is thrown instead (which also leads to  RestClientException if it happens in RestTemplate)  I think ValueInstantiationException should cause HttpMessageConversionException and not HttpMessageNotWritableException.","closed","type: enhancement,","Romster","2020-01-29T16:12:41Z","2020-02-12T15:49:54Z"
"","24068","Improved readability in CONTRIBUTING.md","Improved the sentence so that it is easier to understand.","closed","type: task,","jasdeepgill","2019-11-25T04:36:07Z","2019-11-26T16:22:29Z"
"","24800","Set initialValue of NamedThreadLocal in XmlBeanDefinitionReader","Implement `initialValue` method of `NamedThreadLocal` to lazy init `set` in `XmlBeanDefinitionReader`. This will look more concise. In addition, can you consider this PR #24705 ? Because with this PR code, the writing will be simpler.","closed","in: core,","chenqimiao","2020-03-27T12:40:03Z","2020-03-27T16:16:52Z"
"","24705","Introduce static factory method with initial supplier in NamedThreadLocal","If we need a `NamedThreadLocal` with an initialization value, it will be very convenient to use the `withInitial` method of this PR, like this:  ```java NamedThreadLocal.withInitial(""SimpleThreadScope"", HashMap::new); ```  It's just a suggestion. If you think it's okay, I hope it can be absorbed into this project.","open","type: enhancement,","chenqimiao","2020-03-16T06:09:30Z","2021-04-27T05:06:13Z"
"","24429","odata uses MERGE method for updating Entity","If we dont add MERGE HttpMethod here, then [preflight request with asking MERGE method will be rejected](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/cors/DefaultCorsProcessor.java#L117).  https://www.odata.org/documentation/odata-version-2-0/operations/ 2. Operations The OData service interface has a fixed number of operations that have uniform meaning across all the resources it can act on. These operations are retrieve, create, update and delete and they map to the GET, POST, PUT/MERGE and DELETE HTTP methods.","closed","status: declined,","met-pub","2020-01-26T13:00:13Z","2020-01-29T08:40:20Z"
"","24478","EOFException when wait_timeout on server side is bellow the time interval between two queries","If wait_timeout on server side is set bellow the time interval between two database queries and you use DataSourceTransactionManager as transaction manager and NamedParameterJdbcTemplate to perform queries, a second query uses the same connection as the first one and results in ""Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost."".  In https://github.com/spring-projects/spring-framework/blob/72685b1d819d0fda74ebf17a489080059051baed/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceUtils.java#L107 the check is performed against the connection holder but not against the connection itself. Would it make sense to also check the connection is still valid and checkout a new one if it's not?","open","in: data,","marcatl","2020-02-04T13:26:17Z","2021-11-10T11:38:07Z"
"","23853","How to get certificate in spring-webflux","If use spring tomcat server, I can get client certificate by the code. ```java X509Certificate[] certs = (X509Certificate[])HttpServletRequest.getAttribute(""javax.servlet.request.X509Certificate""); ```  Now, I use webflux netty-http-server, How to get client certificate?","closed","for: stackoverflow,","xxxxpenny","2019-10-23T12:22:30Z","2019-10-23T12:39:45Z"
"","24333","Make resolveAutowiringValue method of AutowireUtils support abstract class parameter","If the argument `requiredType ` of `resolveAutowiringValue` is an abstract class  and meet some other conditions, I think the argument that method return can be an object of subclass to the argument `requiredType`.  So I took the liberty to add some implementations, hoping to meet expectations.","closed","status: feedback-provided,","chenqimiao","2020-01-11T14:56:06Z","2022-02-18T19:07:19Z"
"","24812","ImportAware","if implements ImportSelector and ImportAware interfaces ,selectImports method can be invoke ,but setImportMetadata method cannot invoke","closed","in: core,","githubcheng2978","2020-03-29T14:48:47Z","2020-03-30T09:53:16Z"
"","24689","Deserializing @RequestBody with invalid datatype of json payload ends with HTTP status 500 instead of HTTP status 400 (changed behaviour observed since spring-web:5.2.4.RELEASE)","I've observed change of processing invalid payloads when deserializing in controller between versions spring-web:5.2.4.RELEASE and spring-web:5.2.3.RELEASE.  When calling REST API with json payload of incorrect field types, servlet responds with `request processing failure` as server error (500) instead of bad request as it worked till release 5.2.4.  Example, dto with getter: ```java @JsonInclude(JsonInclude.Include.NON_NULL) class Points {     @NotNull     @Min(0)     private Integer points;      @JsonCreator     public LoyaltyPointsDto(@JsonProperty(""points"") Integer points) {this.points = points;}     public Integer getPoints() {return points;} } ```  In controller: ```java @PostMapping(consumes = APPLICATION_JSON_VALUE) public boolean update(@Valid @RequestBody Points points){ //.... } ```  Invalid json payload (Integer expected, but passed value is out of int range) ``` {    ""points"": 3333333333333 } ```  API call ends with internal server error (stacktrace with exception details below):  ``` 12:38:42.643 [http-nio-8080-exec-3] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.http.converter.HttpMessageConversionException: JSON conversion problem: Numeric value (3333333333333) out of range of int (-2147483648 - 2147483647); nested exception is com.fasterxml.jackson.databind.JsonMappingException: Numeric value (3333333333333) out of range of int (-2147483648 - 2147483647)  at [Source: (PushbackInputStream); line: 2, column: 13] (through reference chain: pl.dto.Points[""points""])] with root cause com.fasterxml.jackson.core.exc.InputCoercionException: Numeric value (3333333333333) out of range of int (-2147483648 - 2147483647)  at [Source: (PushbackInputStream); line: 2, column: 26] 	at com.fasterxml.jackson.core.base.ParserMinimalBase._reportInputCoercion(ParserMinimalBase.java:601) 	at com.fasterxml.jackson.core.base.ParserMinimalBase.reportOverflowInt(ParserMinimalBase.java:570) 	at com.fasterxml.jackson.core.base.ParserBase.convertNumberToInt(ParserBase.java:889) 	at com.fasterxml.jackson.core.base.ParserBase._parseIntValue(ParserBase.java:802) 	at com.fasterxml.jackson.core.base.ParserBase.getIntValue(ParserBase.java:646) 	at com.fasterxml.jackson.databind.deser.std.NumberDeserializers$IntegerDeserializer.deserialize(NumberDeserializers.java:472) 	at com.fasterxml.jackson.databind.deser.std.NumberDeserializers$IntegerDeserializer.deserialize(NumberDeserializers.java:452) 	at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:530) 	at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeWithErrorWrapping(BeanDeserializer.java:528) 	at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeUsingPropertyBased(BeanDeserializer.java:417) 	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1287) 	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:326) 	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:159) 	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4202) 	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3258) 	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:240) 	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.read(AbstractJackson2HttpMessageConverter.java:228) 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:205) 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:158) 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:131) 	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) 	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:668) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:750) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.doFilter(AbstractPreAuthenticatedProcessingFilter.java:124) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) 	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:688) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639) 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.base/java.lang.Thread.run(Thread.java:834)` ```","closed","in: web,","Cledyn","2020-03-13T12:47:04Z","2020-03-13T15:05:22Z"
"","24559","ConcurrentModification in LinkedMultiValueMap ( spring-web-5.1.6)","I've just seen that (rare) exception in an otherwise well-behaving web applicaiton of ours.  It would be great to hear whether that's a known issue and which release contains a fix. I see a couple of similar issued but with different call stacks. So may be this is a new variant?  Thank you!  ``` Feb 20, 2020 7:38:17 PM org.apache.catalina.core.StandardWrapperValve invoke SEVERE: Servlet.service() for servlet [springmvc] in context with path [] threw exception [Request processing failed; nested exception is java.util.ConcurrentModificationException] with root cause java.util.ConcurrentModificationException 	at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134) 	at org.springframework.util.LinkedMultiValueMap.add(LinkedMultiValueMap.java:89) 	at org.springframework.web.accept.MappingMediaTypeFileExtensionResolver.addMapping(MappingMediaTypeFileExtensionResolver.java:80) 	at org.springframework.web.accept.AbstractMappingContentNegotiationStrategy.resolveMediaTypeKey(AbstractMappingContentNegotiationStrategy.java:121) 	at org.springframework.web.accept.AbstractMappingContentNegotiationStrategy.resolveMediaTypes(AbstractMappingContentNegotiationStrategy.java:102) 	at org.springframework.web.accept.ContentNegotiationManager.resolveMediaTypes(ContentNegotiationManager.java:124) 	at org.springframework.web.servlet.mvc.condition.ProducesRequestCondition.getAcceptedMediaTypes(ProducesRequestCondition.java:257) 	at org.springframework.web.servlet.mvc.condition.ProducesRequestCondition.getMatchingCondition(ProducesRequestCondition.java:194) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfo.getMatchingCondition(RequestMappingInfo.java:235) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:93) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:57) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.addMatchingMappings(AbstractHandlerMethodMapping.java:425) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:391) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:365) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:65) 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:401) 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1231) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1014) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.sitemesh.webapp.contentfilter.ContentBufferingFilter.bufferAndPostProcess(ContentBufferingFilter.java:169) 	at org.sitemesh.webapp.contentfilter.ContentBufferingFilter.doFilter(ContentBufferingFilter.java:126) 	at org.sitemesh.config.ConfigurableSiteMeshFilter.doFilter(ConfigurableSiteMeshFilter.java:163) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.web.multipart.support.MultipartFilter.doFilterInternal(MultipartFilter.java:124) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:209) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at de.hybris.platform.servicelayer.web.AbstractPlatformFilterChain$InternalFilterChain.doFilter(AbstractPlatformFilterChain.java:329) 	at de.hybris.platform.servicelayer.web.AbstractPlatformFilterChain.processStandardFilterChain(AbstractPlatformFilterChain.java:207) 	at de.hybris.platform.servicelayer.web.AbstractPlatformFilterChain.doFilterInternal(AbstractPlatformFilterChain.java:184) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at de.hybris.platform.servicelayer.web.XSSFilter.processPatternsAndDoFilter(XSSFilter.java:358) 	at de.hybris.platform.servicelayer.web.XSSFilter.doFilter(XSSFilter.java:306) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:543) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) 	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:678) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:609) 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:810) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1623) 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","status: duplicate,","axel-grossmann-sap","2020-02-20T18:49:10Z","2020-02-24T13:36:42Z"
"","24269","Spring Websocket ChannelInterceptor not firing CONNECT event","I'm writing simple Stomp Websocket application with Spring, and clients are both web (JS), and Mobile (ios, android). From JS code client connecting over SockJS, while mobile clients are using plain websocket connection behind SockJS. The issue is that behaviour in my ChannelInterceptor where I'm checking authentication, is completely different for different type of connections. I can't make it work the same for every client. Let me briefly give some code behind it and explain by example: Websocket starter was taken from Spring example here: https://github.com/spring-guides/gs-messaging-stomp-websocket.git  Websocket Config:      @Configuration     @EnableWebSocketMessageBroker     public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {          @Override         public void configureMessageBroker(MessageBrokerRegistry config) {             config.enableSimpleBroker(""/topic"");             config.setApplicationDestinationPrefixes(""/app"");         }          @Override         public void registerStompEndpoints(StompEndpointRegistry registry) {             registry.addEndpoint(""/gs-guide-websocket"")                     .setAllowedOrigins(""*"")                     .withSockJS();         }          @Override         public void configureClientInboundChannel(ChannelRegistration registration) {             registration.interceptors(new MyChannelInterceptor());         }     } And ChannelInterceptor itself:      public class MyChannelInterceptor implements ChannelInterceptor {         @Override         public void postSend(Message message, MessageChannel channel, boolean sent) {             StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);             StompCommand command = accessor.getCommand();             ...         }     } When I'm connecting via SockJS from JS app (http://localhost:8080/gs-guide-websocket - and let Spring SockJS do the rest):  I can catch CONNECT command in MyChannelInterceptor, in postSend method - OK When I close the connection, in the same place DISCONNECT command fires TWICE. - Not OK When I'm connecting via Websocket behind SockJS (ws://localhost:8080/gs-guide-websocket/websocket):  I CAN'T catch CONNECT command in MyChannelInterceptor, in postSend method - CRITICAL When I close the connection, DISCONNECT command fires correctly, once. - OK Basically, though I can't understand why sockjs tries to disconnect twice, I can live with it. But with interceptor not catching every connect event - I can't live, since I'm going to keep track of user session, and store them from exactly that interceptor.  I've already tried to remove .withSockJs() in the config - and just connect to socket - same problem I've also tried to implement application event listener on SessionConnectEvent and SessionConnectedEvent - same problem","closed","status: invalid,","DruidKuma","2019-12-27T10:41:46Z","2020-01-08T13:39:05Z"
"","24320","SimpleKey contains invalid hashcode on deserialization when parameters include an enum","I'm working on an application that uses Spring caching and replicates cache entries across a cluster of hosts. When one host adds a new entry to a cache, it serializes that cache entry and sends it to the other hosts for them to add too.  I noticed an issue where if an enum type is a part of the cache key the cache will not replicate properly. Each host winds up with duplicate entries in the cache for identical-looking keys.  I traced the issue to the SimpleKey's hashCode field. It gets initialized in the SimpleKey's constructor and is based on the hash codes of all of the SimpleKey's parameters. The problem is that enum hash codes are based on object identity - they aren't consistent from one host to another and will even change with an application restart. If a SimpleKey instance was deserialized from another host and contains an enum parameter, then its hashCode field will have a different value than a SimpleKey with the same parameters created by the current host.  This means that even though the replication is working - each host is adding cache entries sent from other hosts to their own caches - no host can ever get a cache hit on an entry that was sent to it from another. The different hash codes make the cache's underlying map lookups fail to find the already-existing keys. The ultimate consequence is that these caches effectively have no synchronization across hosts and they're bloated with up to one duplicate entry per host for common keys.  This pull request fixes the issue by making the SimpleKey's hashCode transient so it isn't shared with other runtimes when serialized, and by making sure its hashCode gets calculated by its own runtime even when the object was deserialized instead of constructed.  I think this is a reasonable change because identity-based hashcodes are a real possibility in Java (it's the Object.hashCode implementation) and since SimpleKey derives its hash code from a set of parameters of unknown types you can't assume it's safe to share when serializing.","closed","in: core,","ZikFat","2020-01-08T22:28:59Z","2020-01-09T21:44:20Z"
"","24742","Add javadoc for ManagedAttribute elements","I'm trying to use ManagedAttribute  and elements names are confusing to me. It's not clear when to set values to them and what values should be set. Please add javadoc. Now it's absent. `ManagedResource` should be enhanced as well.","closed","in: core,","turbanoff","2020-03-20T12:04:42Z","2020-03-20T21:52:31Z"
"","24820","Allow handling of HTTP CONNECT in WebFlux","I'm trying to simulate an CONNECT HTTP request using `MockServerHttpRequest`, but it only receives `HttpMethod` as valid methods (not strings). For some reason CONNECT isn't in the `HttpMethod` enum. I don't mind creating a PR for that, just want to make sure it's not intentional.","closed","type: enhancement,","GuyLewin","2020-03-30T21:12:54Z","2020-05-22T20:47:54Z"
"","24088","Null pointer when connecting to RSocket","I'm trying RSocket and I'm using:  ```xml          org.springframework.boot         spring-boot-starter-parent         2.2.2.BUILD-SNAPSHOT           ```  My client code looks like:  ```java requester         .route(""test"")         .retrieveFlow()         .collect({             println(""Receiving $it"")         }) ```  Starting from today I'm facing this exception:  ```java.lang.NullPointerException: null 	at java.util.Objects.requireNonNull(Objects.java:203) ~[na:1.8.0_202] 	at reactor.core.publisher.FluxSource.(FluxSource.java:46) ~[reactor-core-3.3.1.BUILD-SNAPSHOT.jar:3.3.1.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.wrap(Flux.java:9869) ~[reactor-core-3.3.1.BUILD-SNAPSHOT.jar:3.3.1.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.from(Flux.java:961) ~[reactor-core-3.3.1.BUILD-SNAPSHOT.jar:3.3.1.BUILD-SNAPSHOT] 	at io.rsocket.RSocketRequester.requestChannel(RSocketRequester.java:174) ~[rsocket-core-1.0.0-RC5.jar:na] 	at io.rsocket.util.RSocketProxy.requestChannel(RSocketProxy.java:50) ~[rsocket-core-1.0.0-RC5.jar:na] 	at io.rsocket.util.MultiSubscriberRSocket.lambda$requestChannel$3(MultiSubscriberRSocket.java:47) ~[rsocket-core-1.0.0-RC5.jar:na] 	at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:46) ~[reactor-core-3.3.1.BUILD-SNAPSHOT.jar:3.3.1.BUILD-SNAPSHOT] 	at reactor.core.publisher.Flux.subscribe(Flux.java:8128) ~[reactor-core-3.3.1.BUILD-SNAPSHOT.jar:3.3.1.BUILD-SNAPSHOT] 	at kotlinx.coroutines.reactive.PublisherAsFlow.collect(ReactiveFlow.kt:77) ~[kotlinx-coroutines-reactive-1.3.2.jar:na] 	at kotlinx.coroutines.flow.FlowKt__TransformKt$onEach$$inlined$unsafeTransform$1.collect(SafeCollector.kt:127) ~[kotlinx-coroutines-core-1.3.2.jar:na] 	at kotlinx.coroutines.flow.FlowKt__CollectKt.collect(Collect.kt:30) ~[kotlinx-coroutines-core-1.3.2.jar:na] 	at kotlinx.coroutines.flow.FlowKt.collect(Unknown Source) ~[kotlinx-coroutines-core-1.3.2.jar:na] ```  Some days ago everything works as expected, after replacing 2.2.2.BUILD-SNAPSHOT with 2.2.1.BUILD-SNAPSHOT, everything works again.  After debugging the problem seems to be in:  ``` Flux payloadFlux = this.payloadMono != null ? 					this.payloadMono.flatMapMany(rsocket::requestStream) : 					rsocket.requestChannel(this.payloadFlux); ``` With 2.2.1.BUILD-SNAPSHOT the null check returns true, while with 2.2.2.BUILD-SNAPSHOT the null check returns false.  I think that this happens because on [this commit](https://github.com/spring-projects/spring-framework/commit/996f7290cf97df2938287630ca956fe5ac35fdc8#diff-194716dad2f2306d0e70620b51d1779a) someone remove `emptyPayload()`:  ```java @Nullable private Mono payloadMono = emptyPayload(); ```","closed","type: bug,","jesty","2019-11-26T21:47:59Z","2019-11-27T07:50:18Z"
"","24767","Do not cache multipart mime types in MimeTypeUtils LRU cache","I'm sorry, I mentioned it once, but the lasted version still doesn't solve the problem.   I mentioned a  [Pull-Request](https://github.com/spring-projects/spring-framework/pull/24768), hoping for a little use  Despite this, it doesn't solve all the problems. In many case, we write code like this:  `request.getHeaders().getContentType()`  In project Spring-Cloud-Gateway. People can attack us like this:   `curl -X GET -H ""Content-Type: [random characters]"" ""http://127.0.0.1:8080/get""` In project Spring-MVC. People can attack us like this:  'curl -X GET -H ""Accept: [random characters]"" ""http://127.0.0.1:8080/get""'   Also can fill the LRU cache, resulting in degraded performance.    Maybe giving an api to turn off the LRU cache can solve this problem, or some better way   In project Spring-Cloud-Gateway, when the cache is full, performance drops to 10% in half an hour  When MidiaType is Multipart-formdata,  mimeType characters has random characters, causing the LRU cache to be full, then over-occupy the cpu  At that time the LRU cache like this:   application/stream+x-jackson-smile, application/vnd.spring-boot.actuator.v3+json, application/vnd.spring-boot.actuator.v2+json, application/json, multipart/form-data; boundary=----WebKitFormBoundaryVHfecvFDYeDEjhu4, multipart/form-data; boundary=----WebKitFormBoundarymKzwdDkWNDNzQFP0, multipart/form-data; boundary=----WebKitFormBoundaryiWpMXOUbWwBwq2AX, application/x-www-form-urlencoded, text/html;charset=UTF-8, application/octet-stream, application/vnd.ms-excel;charset=utf8, application/msword, multipart/form-data; boundary=----WebKitFormBoundaryGF2AJ2ZdPqbWOyEO, multipart/form-data; boundary=----WebKitFormBoundaryTZLPpyBs2F0ycmkB, multipart/form-data; boundary=----WebKitFormBoundaryBUClXdZPA3oxpUpx, image/jpeg;charset=UTF-8, multipart/form-data; boundary=----WebKitFormBoundarysODcdeMwzfHwEjtw, multipart/form-data; boundary=----WebKitFormBoundary26i2en6YQUSXUBzs, multipart/form-data; boundary=----WebKitFormBoundaryxUUWAyZnZjwlM1oy, multipart/form-data; boundary=----WebKitFormBoundarysVMYk11tVTTsXuEB, multipart/form-data; boundary=----WebKitFormBoundaryXsI4dpNsVTCWWrRo, multipart/form-data; boundary=----WebKitFormBoundaryiV1owCGwTHyQzja0, multipart/form-data; boundary=----WebKitFormBoundarygf1XpLmgasAQU9fi, multipart/form-data; boundary=----WebKitFormBoundaryBNaQtUvpQ2VV7YYA, multipart/form-data; boundary=----WebKitFormBoundaryW1rdrg4AbJ5Jn3Po, multipart/form-data; boundary=----WebKitFormBoundaryoBwFj2ABM5LflDmW, multipart/form-data; boundary=----WebKitFormBoundary40xI2TxryjbkSCtO, multipart/form-data; boundary=----WebKitFormBoundarytaCC9B6g8u4urnLF, multipart/form-data; boundary=----WebKitFormBoundaryOrhplGKYP9ozLkCs, multipart/form-data; boundary=----WebKitFormBoundaryvEUouFAr3R3YJYBh, multipart/form-data; boundary=----WebKitFormBoundaryuQ9tEKtn59w5hPLY, multipart/form-data; boundary=----WebKitFormBoundaryRGvPXUBAuZ6xJ95u, application/vnd.openxmlformats-officedocument.wordprocessingml.document, multipart/form-data; boundary=----WebKitFormBoundary7jpljZi4k61KhCNN, multipart/form-data; boundary=----WebKitFormBoundary7GVKDTHVuBABvjGB, multipart/form-data; boundary=----WebKitFormBoundaryZbNBPl3T4VZ44q6B, audio/mp3, multipart/form-data; boundary=----WebKitFormBoundaryI6rUM76YvxrIEcqv, multipart/form-data; boundary=----WebKitFormBoundaryag4BDWrzifHRdDiR, multipart/form-data; boundary=----WebKitFormBoundary1YRsWAdVqDin8g8p, multipart/form-data; boundary=----WebKitFormBoundaryDaatlrV3KAyZu7wA, multipart/form-data; boundary=----WebKitFormBoundaryyhvikZJdRGH1AjQq, multipart/form-data; boundary=----WebKitFormBoundary2z4SJhqeEx5XtVj4, multipart/form-data; boundary=----WebKitFormBoundaryeDLd1MTvuhmcmzNe, multipart/form-data; boundary=----WebKitFormBoundarybKizrvRESfhxHAMQ, multipart/form-data; boundary=----WebKitFormBoundary24U8tmsOluZqcRXX, multipart/form-data; boundary=----WebKitFormBoundarye4j6KdQyBjY4FqSk, multipart/form-data; boundary=----WebKitFormBoundaryjPmgLdzMcMYYB3yS, multipart/form-data; boundary=----WebKitFormBoundaryxzBZ9w6Je3IJ53NM, multipart/form-data; boundary=----WebKitFormBoundaryScy0j73cvx3iCFyY, multipart/form-data; boundary=----WebKitFormBoundaryTBoS8s4YWwmBGTDA, image/*, multipart/form-data; boundary=----WebKitFormBoundaryRUutFo3RXlNPgoBS, text/html;charset=utf-8, multipart/form-data; boundary=----WebKitFormBoundarykLObBi1tJMf158kt, multipart/form-data; boundary=----WebKitFormBoundary8M8MfCWBEFcsxnBU","closed","type: enhancement,","poorbarcode","2020-03-24T03:40:00Z","2020-03-24T10:36:14Z"
"","24058","PostProcessorRegistrationDelegate makes needed sorting impossible","I'm registering a custom `BeanPostProcessor` instance that adds some filters to `WebClient.Builder` instances. I need my filters to be added after the tracing ones, which are added by a third party tracing library (`opentracing-spring-web`). The main problem is that this library doesn't specify any order on the PostProcessor they register to assign the Trace data. This becomes a problem cause `PostProcessorRegistrationDelegate` sorts all post-processor putting all sorted ones before the unsorted ones  ```java // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);  // Next, register the BeanPostProcessors that implement Ordered. List orderedPostProcessors = new ArrayList<>(); for (String ppName : orderedPostProcessorNames) { 	BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 	orderedPostProcessors.add(pp); 	if (pp instanceof MergedBeanDefinitionPostProcessor) { 		internalPostProcessors.add(pp); 	} } sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors);  // Now, register all regular BeanPostProcessors. List nonOrderedPostProcessors = new ArrayList<>(); for (String ppName : nonOrderedPostProcessorNames) { 	BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 	nonOrderedPostProcessors.add(pp); 	if (pp instanceof MergedBeanDefinitionPostProcessor) { 		internalPostProcessors.add(pp); 	} } registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);  // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors);  // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); ```  I have three options:  1. Register mine as sorted: doesn't work cause it gets registered before 2. Register mine as unsorted: doesn't work for me either cause I don't seem to find a way of predicting the order 3. Register mine as MergedBeanDefinitionPostProcessor: it works as it gets registered at the end, but it doesn't really make sense as it doesn't implement the extra methods  I can also register it as a `WebClientCustomizer` but also gets processed before.  In my opinion, the way the sorting is done isn't right because it leads to this kind of situation where we need to operate after something else we have no control over, and we just don't have a proper mechanism of controlling it.  My suggestion would be to assign a default priority to the unsorted postprocessors so they get sorted along with the sorted ones instead of before/after. This way the order would be:  1. priorityOrderedPostProcessors 2. orderedPostProcessos and nonOrderedPostProcessors (sorted treating nonOrderedPostProcessors as if they had order 0) 3. internalPostProcessors (the ones that extend MergedBeanDefinitionPostProcessor)  Of course, this is based on my own experience and what makes sense to me. I know I'm missing many things on the big picture so feel free to let me know if it can cause other issue.","closed","status: superseded,","rubasace","2019-11-22T13:03:37Z","2022-08-02T08:24:25Z"
"","24242","Support JAX-RS annotations for REST controllers","I'm putting together a project, where the different modules communicate via REST.  Not all of the modules use Spring, so I decided to use JAX-RS instead.  The way I'm making sure that all modules are on the same page when it comes to REST resources is that I created an interface, with DTO classes, annotated them with the typical JAX-RS annotations and put them into a maven depedency that both sides can depend on.  This got me the idea, that Spring could use a functionality, where these annotations are recognized and made into either a proxy in case of a Rest client, or when implementing an interface, these annotations could substitute `@RequestMapping` and similar annotations.  To my knowledge, Spring has most of the functionalities needed to implement this feature with the potential of a great, spring-independent way of sharing common rest resources.","closed","","rolaca11","2019-12-20T20:48:31Z","2019-12-23T09:07:45Z"
"","24508","BeanPostProcessorChecker warning due to missing infrastructure role on ProxyTransactionManagementConfiguration","I'm not sure if this is the right place to log this issue, but thought I would start here.  When `@EnableRetry` is added to a Boot application also using `spring-boot-actuator`, the following occurs:  ``` trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.retry.annotation.RetryConfiguration' of type [org.springframework.retry.annotation.RetryConfiguration$$EnhancerBySpringCGLIB$$2cf7388d] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) ```  The same is also true when adding `spring-boot-starter-jdbc` along with `spring-boot-actuator`.  ``` trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) ``` It appears that the `MeterRegistryPostProcessor` is causing some Advisors and other beans to be initialized early.  This [initializr generated application](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.2.2.RELEASE&packaging=jar&jvmVersion=1.8&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=actuator,data-jdbc,hsql) shows the `ProxyTransactionmanagementConfiguration` message during startup.  Adding `@EnableRetry` and the following will cause the `RetryConfiguration` message during startup. ```xml    org.springframework.retry   spring-retry      org.springframework   spring-aspects   ```","closed","type: regression,","edwardsre","2020-01-10T22:44:57Z","2020-02-12T15:51:30Z"
"","24781","Fix typos and improve readability in Webflux documentation","I'm currently reading through the webflux documentation and decided to just edit typos and change some sentences for the sake of readability. Just submitting a PR now to see if you are interested in taking this in, I'd be happy to continue if you are (I'll be reading the docs anyway, so).","closed","type: documentation,","mickeelm","2020-03-25T19:03:37Z","2020-03-26T14:16:50Z"
"","23925","Kotlin Extension Function for WebClient in Spring WebFlux","I'd recommend a Kotlin Extension Function for _WebClient_ in the context of _Kotlin Coroutines_. Currently POST (PUT, PATCH) requests look like the following:  ``` val customer: Customer = ... val client = WebClient.builder()     ...     .baseUrl(...)     .build() val response = client.post()     .body(customer.toMono())  // Project Reactor becomes visible inspite of awaitExchange     .awaitExchange() ```  Just a suggestion for an _Extension Function_ (maybe there is a better name than `singleBody`): ``` inline fun  WebClient.RequestBodySpec.singleBody(obj: T): WebClient.RequestHeadersSpec<*>    = body(obj.toMono()) ```","closed","status: invalid,","juergenzimmermann","2019-11-04T15:38:07Z","2019-11-14T14:48:33Z"
"","24598","Test HttpMethod class","I wrote the test code knowing that there is no test code in this class.","closed","status: declined,","hyeonisism","2020-02-26T10:25:08Z","2020-02-26T20:58:03Z"
"","24376","Simplify getCache() method in CaffeineCacheManager","I would like to make some contributions.  Current spring framework is based on JDK8. So, CaffeineCacheManager.getCache() method can be simplified with Map.computeIfAbsent  Thank you.","closed","type: enhancement,","bananayong","2020-01-16T08:27:05Z","2020-01-16T23:50:54Z"
"","24135","Add firstElement to CollectionUtils","I was wondering why CollectionUtils has lastElement but not firstElement. It's quite handy!","closed","type: enhancement,","vitalikrst","2019-12-04T16:25:29Z","2019-12-05T15:27:00Z"
"","23962","Support combining multiple SqlParameterSource","I want to support the feature that combine multiple `SqlParamterSource` to a one `SqlParameterSource`. For example, When save a domain object to the database, I want to bind retrieving values  from domain object and other object(e.g. login user object) to an SQL using `NamedParameterJdbcOperations`.  WDYT?  **Code sample:**  ```java Account newAccount = new Account(); // ... KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcOperations.update(     ""INSERT INTO accounts (name, email, created_at, created_by) "" +     ""VALUES(:name, :email, current_timestamp, :operatorId)"",     SqlParameterSource.combine(         new BeanPropertySqlParameterSource(newAccount), // retrieving 'name' and 'email'         new BeanPropertySqlParameterSource(operator)), // retrieving 'operatorId'     keyHolder); // ... ```  ```java public interface SqlParameterSource {    // …    static SqlParameterSource combine(SqlParameterSource... sources) {     return new CompositeSqlParameterSource(sources);   }    public static class CompositeSqlParameterSource implements SqlParameterSource {     private final Map cache = new HashMap<>();     private final SqlParameterSource[] sources;      private CompositeSqlParameterSource(SqlParameterSource... sources) {       this.sources = sources;     }      @Override     public boolean hasValue(String paramName) {       return cache.computeIfAbsent(paramName,           x -> Stream.of(sources).filter(s -> s.hasValue(paramName)).findFirst().orElse(null)) != null;     }      @Override     public Object getValue(String paramName) {       return hasValue(paramName) ? cache.get(paramName).getValue(paramName) : null;     }      @Override     public String getTypeName(String paramName) {       return hasValue(paramName) ? cache.get(paramName).getTypeName(paramName) : null;     }      @Override     public int getSqlType(String paramName) {       return hasValue(paramName) ? cache.get(paramName).getSqlType(paramName) : TYPE_UNKNOWN;     }      @Override     public String[] getParameterNames() {       return Stream.of(sources)           .map(SqlParameterSource::getParameterNames)           .flatMap(Stream::of).distinct()           .toArray(String[]::new);     }   }  }  ```","open","in: data,","kazuki43zoo","2019-11-09T08:30:40Z","2021-11-10T12:22:16Z"
"","24399","how to use mdc in different stream","I used this solution https://github.com/archie-swif/webflux-mdc, the values can be obtained in the same stream, but not in different streams, this affects the logging id. How to solve?   eg: Setting parameters using webfilter ```java @Component public class MdcWebFilter implements WebFilter {     @Override     public Mono filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {         return webFilterChain.filter(serverWebExchange).subscriberContext(ctx -> ctx.put(""traceId"", 123));     } }  @RestController public class TestController {      private final static Scheduler SETTLEMENT_SCHEDULER = Schedulers.newParallel(""settlement-scheduler"", 30);      @GetMapping(""/test"")     public Flux test() {          //123         System.out.println(Thread.currentThread().getId() + "":"" + MDC.get(""traceId""));          Mono.just(1).map(s -> {             thread1();             return 1;         }).subscribeOn(SETTLEMENT_SCHEDULER).subscribe();          return Flux.just(1).map(s -> {             thread2();             return 1;         }).subscribeOn(SETTLEMENT_SCHEDULER);     }      private void thread1() {         //null         System.out.println(Thread.currentThread().getId() + "":"" + MDC.get(""traceId""));     }      private void thread2() {         //123         System.out.println(Thread.currentThread().getId() + "":"" + MDC.get(""traceId""));     } ```","closed","for: stackoverflow,","jmilktea","2020-01-20T08:31:40Z","2020-01-20T10:32:00Z"
"","24147","ScheduledTaskRegistrar.addCronTask has concurrency issues in Spring 5.1.0 context","I used multiple threads to register multiple `@Scheduled` tasks during the spring container initialization phase, NullPointerException occurred. Here is the stack information. The `@Scheduled` bean scope is `SCOPE_PROTOTYPE`  ``` 17:56:40.174 ERROR org.springframework.boot.SpringApplication - Application run failed java.lang.NullPointerException: null     at org.springframework.scheduling.config.ScheduledTaskRegistrar.scheduleCronTask(ScheduledTaskRegistrar.java:414)     at org.springframework.scheduling.config.ScheduledTaskRegistrar.scheduleTasks(ScheduledTaskRegistrar.java:352)     at org.springframework.scheduling.config.ScheduledTaskRegistrar.afterPropertiesSet(ScheduledTaskRegistrar.java:332)     at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.finishRegistration(ScheduledAnnotationBeanPostProcessor.java:300)     at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:231)     at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:103)     at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)     at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)     at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)     at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:402)     at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:359)     at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:896)     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:162)     at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:552)     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141)     at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:744)     at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:391)     at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215)     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1204)     at loki.porsche.MacanApplicationKt.main(MacanApplication.kt:27) ```","open","status: feedback-provided,","aq0706","2019-12-06T02:29:05Z","2021-11-10T12:03:14Z"
"","24165","MethodValidationPostProcessor conflict with Scheduler","I use the Spring Boot v2.0.5.RELEASE which depends on Spring 5.0.9 Release   I got a problem when I need both `MethodValidationPostProcessor` and  `Scheduled`  here's the detail.  When I just use `Scheduled` like below   ```java @SpringBootApplication @EnableConfigServer @EnableScheduling public class SpringConfigServerApplication {     public static void main(String[] args) {         SpringApplication.run(SpringConfigServerApplication.class, args);     }      @Scheduled(fixedDelay = 5000)     public void test() {         System.out.println(""Demo"");     } } ```  the scheduler works well as what I want. But when I add a MethodValidationPostProcessor like below  ```java @SpringBootApplication @EnableConfigServer @EnableScheduling public class SpringConfigServerApplication {     public static void main(String[] args) {         SpringApplication.run(SpringConfigServerApplication.class, args);     }      @Bean     public MethodValidationPostProcessor methodValidationPostProcessor() {         MethodValidationPostProcessor methodValidationPostProcessor = new MethodValidationPostProcessor();         methodValidationPostProcessor.setProxyTargetClass(true);         return methodValidationPostProcessor;     }      @Scheduled(fixedDelay = 5000)     public void test() {         System.out.println(""Demo"");     } } ```  the scheduler doesn't work. I have already checked the `org.springframework.scheduling.config.ScheduledTaskRegistrar`, the scheduler inits as well, but there isn't any task in all of the task variables such as `fixedRateTasks`, `fixedDelayTasks` and etc.  Is there any chance that we can use MethodValidationPostProcessor and the scheduler together?","closed","for: stackoverflow,","Zheaoli","2019-12-09T07:09:17Z","2019-12-09T11:25:35Z"
"","23851","I use `getContentAsString()` and mockMvc seems to return my content as ISO 8859-1.","I use `getContentAsString()` and mockMvc seems to return my Content as ISO 8859-1. Before (with Spring Boot 2.1.8) it was proper UTF-8  When I add a produces to my Endpoint like `@GetMapping(value = ""/test"", produces={""application/json; charset=UTF-8""})` it works as indented. But I dont want todo this on our big project with tons of endpoints  Example:  ```java @RestController @RequestMapping(""test"") public class TestClass {   @GetMapping   public List test() {     return List.of(""AEß"");   } } ```  ```java @RunWith(SpringRunner.class) @SpringBootTest(classes = {Application.class}) @AutoConfigureMockMvc() @ActiveProfiles(""test"") @Transactional public class TestClassTest {   @Autowired   private ObjectMapper objectMapper;   @Autowired   private MockMvc mvc;   @Test   public void test() throws Exception {     var mvcResult = mvc.perform(MockMvcRequestBuilders       .get(""/test"")       .contentType(MediaType.APPLICATION_JSON)       .accept(MediaType.APPLICATION_JSON))       .andExpect(MockMvcResultMatchers.status().isOk())       .andReturn();      assertEquals(List.of(""AEß""), objectMapper.readValue(mvcResult.getResponse().getContentAsString(),       new TypeReference>() {       }));   } } ```  Fails with:  ``` java.lang.AssertionError:  Expected :[AEß] Actual   :[AEÃ] ```  _Originally posted by @chrisaige in https://github.com/spring-projects/spring-framework/issues/23622#issuecomment-545322300_","closed","in: web,","chrisaige","2019-10-23T08:09:38Z","2021-07-29T15:10:32Z"
"","24133","ComponentScan excludeFilters via FilterType.REGEX does not work with escaping","I tried to exclude an entire subpackage of my SpringBootApplication (Spring Boot Version 2.1.10.RELEASE) from component scan with annotations and values equivalent to this:  ``` @SpringBootApplication @ComponentScan(basePackages = ""some.ba_se.package"",     excludeFilters = @Filter(type=FilterType.REGEX, pattern=""some\\.ba_se\\.package\\.ignore\\..*"")) ```  This does not exclude the some.ba_se.package.ignore package.","closed","","jvs64893","2019-12-04T15:01:52Z","2021-01-08T13:09:15Z"
"","24782","Using UriComponentsBuilder.cloneBuilder does not copy uriVariables","I took the liberty of adding a dedicated test which checks if all properties are properly copied when `UriComponentsBuilder.cloneBuilder()` is called. I intentionally added a separate test case since I wasn't sure if `testClone` isn't covering a use case I haven't though of.  Closes gh-24772","closed","type: bug,","steve-todorov","2020-03-26T00:17:58Z","2020-03-26T18:14:36Z"
"","24624","Use native trim() of String instead of iterating through String in trimWhitespace of StringUtils","I think we can use the native method trim() of String instead of iterating through String in trimWhitespace of StringUtils. This is simpler and secondarily more efficient.","closed","status: superseded,","chenqimiao","2020-03-02T10:52:57Z","2022-01-27T05:42:48Z"
"","24259","unused LogFactory.getLog","I think the follow code should be deleted:  ```java 	      protected final Log logger = LogFactory.getLog(getClass());  ```  Any logger should be defined like this :   ```java  private static final Logger logger = LoggerFactor.getLogger(ClassName);  ```  =============================== https://github.com/spring-projects/spring-framework/blob/9c17eb59a4312a9787b23ebaea3bff6e95f3657c/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/AbstractMediaTypeExpression.java#L38","closed","status: declined,","pandening","2019-12-24T12:44:22Z","2019-12-26T09:02:27Z"
"","24588","Polish code by using matches() method in HttpMethod","I think it's safer to compare with using the matches() method than to compare with using the literal. So I changed it like this.","closed","status: declined,","hyeonisism","2020-02-25T10:58:26Z","2021-07-15T04:30:46Z"
"","23833","Transactions doesn't work with custom inner dynamic or CGLIB proxies","I ran into a problem that transactions do not work with a double dynamic proxy of Connection/PreparedStatement. Here is a Java code example: https://paste.ubuntu.com/p/ds73pjfGpZ/.  This works until you uncomment lines 74-78. If I'll do something in method with @Transactional annotation, the transaction won't start. I have tried to implement it with CGLIB with no luck. Finally, I had to stop on simple Delegates with a lot of boiler code. Is it a bug?","open","in: core,","squadgazzz","2019-10-18T14:20:17Z","2019-11-05T09:26:20Z"
"","24729","Relax check in LocalVariableTableParameterNameDiscoverer","I propose to remove unnecessary if condition.","closed","","YooInKeun","2020-03-19T01:07:55Z","2020-03-19T11:41:43Z"
"","24731","Remove unnecessary condition in LocalVariableTableParameterNameDiscoverer","I propose to remove unnecessary condition in `LocalVariableTableParameterNameDiscoverer`.","closed","in: core,","YooInKeun","2020-03-19T01:18:59Z","2020-03-19T10:37:34Z"
"","24730","Remove unnecessary condition in LocalVariableTableParameterNameDiscoverer","I propose to remove unnecessary condition in `LocalVariableTableParameterNameDiscoverer`.","closed","","YooInKeun","2020-03-19T01:13:52Z","2020-03-19T11:42:00Z"
"","24684","Remove unnecessary setter in DefaultServerRequest","I propose to remove `public void setStatus(int sc, String sm)` setter method in `class CheckNotModifiedResponse`.  Because setting status message code is not being used in `public void setStatus(int sc, String sm)`. ex) `this.statusMsg = sm;`  And I know `public void setStatus(int sc, String sm)` in HttpServletResponse is deprecated.  There is an explanation about this in https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletResponse.html#setStatus(int,%20java.lang.String)  `As of version 2.1, due to ambiguous meaning of the message parameter. To set a status code use setStatus(int), to send an error with a description use sendError(int, String). Sets the status code and message for this response.`  Thank you for reading my PR!","closed","status: declined,","YooInKeun","2020-03-12T06:17:33Z","2020-03-13T10:06:43Z"
"","24717","Delete empty .gitignore file","I propose to delete empty .gitignore file.","closed","type: task,","YooInKeun","2020-03-18T06:58:27Z","2020-03-18T15:13:57Z"
"","24721","Simplify Conventions.attributeNameToPropertyName()","I propose refactored code to simplify code and improve accuracy of Conventions.attributeNameToPropertyName() method.","closed","status: declined,","YooInKeun","2020-03-18T12:36:38Z","2020-03-19T09:34:48Z"
"","24720","Simplify Conventions.attributeNameToPropertyName()","I propose refactored code to simplify code and improve accuracy of Conventions.attributeNameToPropertyName() method.","closed","","YooInKeun","2020-03-18T12:28:04Z","2020-03-18T17:27:56Z"
"","24445","Should ListenableFutureAdapter implement ListenableFuture.completable()?","I noticed that `ListenableFutureAdapter`, introduced in Spring 4, does not handle `ListenableFuture.completable()`, introduced in Spring 5. I'm not sure if this is a problem or not, but I've noticed the latter has some implementations.","closed","in: core,","codefromthecrypt","2020-01-28T07:17:15Z","2020-02-03T09:59:57Z"
"","24496","ExecutorConfigurationSupport to allow millisecond precision for await termination period","I noticed `ExecutorConfigurationSupport`(_`ThreadPoolTask[Executor|Scheduler]`_) only takes seconds for await termination.  I'm writing a graceful shutdown logic for k8s environment and awaiting by second is a bit large granularity to control the shutdown/await. Graceful shutdown get triggered by liveness probe and the frequency for liveness probe is not so long.   This PR changes the minimum unit to milliseconds and adds a method to take `Duration` to specify the await termination.","closed","type: enhancement,","ttddyy","2020-02-10T07:53:49Z","2020-02-11T18:35:10Z"
"","23963","SpelCompiler is unable to compile too often","I need to allow allow a user to build an expression that will be used to evaluate a boolean result against millions of records per second, so I need to ensure the expression is compiled.  There is an apparent problem with the way the spring expression framework attempts to compile the expression.  Let's say I have this expression: `productType == 'Firewall' and categoryId == 400`  The issue is: If the first 100 records that are sent through this expression never contain `productType=""Firewall""`, then `categoryId` is never evaluated by the parser due to short-circuiting of the boolean ""and"" operator.  Deep in the code, in `PropertyOrFieldReference`, `this.cachedReadAccessor` is always null for the `categoryId` field. Because of this, the spring expression parser will never be able to compile this expression.  Does anyone have any recommendations for me?  I'd like to use this framework for this use case, but I need to ensure these expressions are compiled.","closed","in: core,","tonyschwartz","2019-11-09T12:31:45Z","2019-11-27T15:57:57Z"
"","24255","External Filter","I need to add my custom Filter as a library for existing web applications without code changes in that application, kind of plug and play.  Extended myclass with OncePerRequestFilter and Overrided dofilterInternal with my changes, but failed to add this in existing application.  it works if I add below code ```java @Bean public RequestFilter getdeta(){ return new RequestFilter(); } ```  Is that possible to achieve it without adding the above code?  Thanks in Advance","closed","for: stackoverflow,","KishoreVenkatachalam123","2019-12-24T07:58:44Z","2020-01-02T12:02:54Z"
"","24168","Improve exception message for mixed explicit and implicit aliases with @AliasFor","I just upgraded Spring Boot version to 2.2.2 from 2.1.8 and noticed a weird exception:  > Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'value' in annotation [en.example.package.PostApi] must be declared as an @AliasFor 'path', not 'path'.  Whole code for my custom annotation.  ```java public @interface PostApi {      @AliasFor(annotation = ResponseStatus.class, attribute = ""code"")      HttpStatus status() default HttpStatus.OK;      @AliasFor(""value"")      String[] path() default {};      @AliasFor(annotation = RequestMapping.class, attribute = ""path"")      String[] value() default {};      @AliasFor(annotation = RequestMapping.class, attribute = ""consumes"")      String[] consumes() default { MediaType.APPLICATION_JSON_VALUE };  } ```  Any ideas what is going on?","closed","type: enhancement,","BartoszCoyote","2019-12-09T13:59:35Z","2019-12-10T13:45:15Z"
"","24283","StringHttpMessageConverter addDefaultHeaders() should check media type for wildcard before setting it into headers","I have just started to fail after this change 9b30d46ff4653c411ee4c8edb89b9bafa11b2ee9.  My content type candidate is like this one: ``` if (CollectionUtils.isEmpty(acceptTypes)) { 		acceptTypes = Collections.singletonList(MediaType.ALL); } ``` So, `MediaType.ALL` is really compatible with `MediaType.APPLICATION_JSON`, but it is wrong value for the `Content-Type` header: ``` java.lang.IllegalArgumentException: Content-Type cannot contain wildcard type '*'  	at org.springframework.util.Assert.isTrue(Assert.java:118) 	at org.springframework.http.HttpHeaders.setContentType(HttpHeaders.java:949) 	at org.springframework.http.converter.StringHttpMessageConverter.addDefaultHeaders(StringHttpMessageConverter.java:109) 	at org.springframework.http.converter.StringHttpMessageConverter.addDefaultHeaders(StringHttpMessageConverter.java:44) 	at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:211) ```  Any clues what to use instead of `MediaType.ALL` when no `Accept` header in the request?  Or maybe this fix should be improved to skip `MediaType.ALL` as it is done in the super class: ``` if (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) { 		contentTypeToUse = getDefaultContentType(t); } ```  Note that `AbstractMessageConverterMethodProcessor` is not used in Spring Integration. There logic in the `HttpRequestHandlingMessagingGateway` is like this: https://github.com/spring-projects/spring-integration/blob/master/spring-integration-http/src/main/java/org/springframework/integration/http/inbound/HttpRequestHandlingMessagingGateway.java#L171  So, instead of falling back to the `MediaType.APPLICATION_OCTET_STREAM` we try to rely on the Content-Type populated by the converted which fits to the `payload` we would like to return into the response.  Originally based on [discussion](https://github.com/spring-projects/spring-framework/commit/9b30d46ff4653c411ee4c8edb89b9bafa11b2ee9#r36586211).","closed","type: enhancement,","artembilan","2020-01-02T14:56:15Z","2020-01-07T15:34:57Z"
"","24225","Allow AcceptHeaderLocaleResolver to fail on unsupported locales","I have configured in 5.2.0.RELEASE:  ```xml 	 		 		 			 				cs 				de 				en 				es 				fr 				pt 				ru 			 		 	 ```  I would like the system to use the default locale if and only if the `Accept-Language` header has not been provided. In the case a user sends `Accept-Language: pl, da` I want the resolver to return 400 because neither Polish not Danish is supported.","closed","status: declined,","michael-o","2019-12-18T13:11:22Z","2019-12-30T06:43:06Z"
"","24091","How to aop method 'handleBinaryMessage' ?","i have a websocket application. How to aop method 'handleBinaryMessage' ? ```java @Service public class AsrHandler extends BinaryWebSocketHandler {     @Override     public void afterConnectionEstablished(WebSocketSession session)         throws Exception {     }     @Override     protected void **handleBinaryMessage**(WebSocketSession session, BinaryMessage message)         throws Exception {     }     @Override     public void afterConnectionClosed(WebSocketSession session, CloseStatus status)         throws Exception {     } }  @Configuration @EnableWebSocket public class WebsocketEndPoint implements WebSocketConfigurer {     @Autowired     private AsrHandler asrProxyHandler;      @Override     public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {         registry.addHandler(asrProxyHandler, API_V1)             .setAllowedOrigins(""*"")             .addInterceptors(new HttpSessionHandshakeInterceptor());     } } ```","closed","for: stackoverflow,","lujiango","2019-11-27T08:55:48Z","2021-11-10T10:01:01Z"
"","24368","Spring webflux - ServerWebExchangeDecorator code is not executed when an exception is thrown","I have a Webflux application, where I have a ServerWebExchangeDecorator that decorates the request and responses. I have overrides to do some logging and then call the super methods. This is what I have in code:  ```java import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import org.springframework.web.server.ServerWebExchangeDecorator; import org.springframework.web.server.WebFilter; import org.springframework.web.server.WebFilterChain; import reactor.core.publisher.Mono;  @Component public class LoggingWebFilter implements WebFilter {    @Override   public Mono filter(ServerWebExchange exchange, WebFilterChain chain) {     return chain.filter(decorate(exchange));   }    private ServerWebExchange decorate(ServerWebExchange exchange) {      final ServerHttpRequest decoratedRequest = new LoggingServerHttpRequestDecorator(exchange.getRequest());     final ServerHttpResponse decoratedResponse = new LoggingServerHttpResponseDecorator(exchange.getResponse());      return new ServerWebExchangeDecorator(exchange) {        @Override       public ServerHttpRequest getRequest() {         return decoratedRequest;       }        @Override       public ServerHttpResponse getResponse() {         return decoratedResponse;       }      };   }  } ``` ```java import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.io.buffer.DataBuffer; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpRequestDecorator; import reactor.core.publisher.Flux;  public class LoggingServerHttpRequestDecorator extends ServerHttpRequestDecorator {    private static final Logger logger = LoggerFactory.getLogger(LoggingServerHttpRequestDecorator.class);    public LoggingServerHttpRequestDecorator(ServerHttpRequest delegate) {     super(delegate);   }    @Override   public Flux getBody() {     logger.info(""getBody method"");     return super.getBody();   }  } ```  ```java import org.reactivestreams.Publisher; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.io.buffer.DataBuffer; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.http.server.reactive.ServerHttpResponseDecorator; import reactor.core.publisher.Mono;  public class LoggingServerHttpResponseDecorator extends ServerHttpResponseDecorator {    private static final Logger logger = LoggerFactory.getLogger(LoggingServerHttpResponseDecorator.class);    public LoggingServerHttpResponseDecorator(ServerHttpResponse delegate) {     super(delegate);   }    @Override   public Mono writeWith(Publisher body) {     logger.info(""writeWith method"");//THIS LINE IS NOT EXECUTED WHEN AN EXCEPTION IS THROWN     return super.writeWith(body);   }    @Override   public Mono writeAndFlushWith(Publisher> body) {     logger.info(""writeAndFlushWith method"");     return super.writeAndFlushWith(body);   }  } ```  When I do a happy path with a POST request, this works fine , but when an exception is thrown, the Response Decorator is omitted and my custom code is not being executed.  This is a sample controller code to replicate the issue:  ```java import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; import reactor.core.publisher.Mono;  @RestController @RequestMapping(""/decorator-demo"") public class DecoratorDemoController {    /** The Constant logger. */   private static final Logger logger = LoggerFactory.getLogger(DecoratorDemoController.class);     @PostMapping(produces = MediaType.APPLICATION_STREAM_JSON_VALUE, consumes = MediaType.APPLICATION_STREAM_JSON_VALUE)   public Mono> postData(@RequestBody String id) {     logger.info(""attempting to post the data"");     if(id.length() == 1){       Mono created = Mono.just(id);       return created.flatMap(vo -> Mono.just(ResponseEntity.status(HttpStatus.CREATED).body(vo)));     }     throw new IllegalArgumentException(""String length must be 1"");   }  } ```  When I post a single character, I have the logs I am expecting:  ``` LoggingServerHttpRequestDecorator  : getBody method DecoratorDemoController            : attempting to post the data LoggingServerHttpResponseDecorator : writeWith method ```  But when I post more than one character, this is the logs I am having:  ``` LoggingServerHttpRequestDecorator  : getBody method DecoratorDemoController            : attempting to post the data AbstractErrorWebExceptionHandler : [0b933716]  500 Server Error for HTTP POST ""/decorator-demo"" ```  Am I doing something wrong, or missing something? I am expecting the Decorator code to be executed, regardless of how a request is processed (i.e. happy path or an exception thrown, just as in Spring MVC, the response wrappers work whether the request followed a happy path or an exception occurred.   I am not sure if this is expected behavior in Webflux.","closed","for: stackoverflow,","erikrz","2020-01-15T18:33:28Z","2020-01-17T09:32:17Z"
"","23905","Annotation retrieval performance degradation after 5.2","I have a web application based on struts2 and spring, after upgrading to spring 5.2.0, I found performance degraded, I confirm it caused by [AutowireCapableBeanFactory.createBean()](https://github.com/apache/struts/blob/600203bbea77ba3c58f42a95b2b9970e2d928939/core/src/main/java/com/opensymphony/xwork2/spring/SpringObjectFactory.java#L191) .  I write an very simple test project [AutowirePerformance.zip](https://github.com/spring-projects/spring-framework/files/3796470/AutowirePerformance.zip), 1000000 iterations takes about 2100ms with 5.1.9 but 2800ms with 5.2.0, it means throughput decreased 25%.  https://github.com/spring-projects/spring-framework/issues/23792 doesn't improve much, @e-hubert would you run this test project and feedback?","closed","in: core,","quaff","2019-11-01T02:37:12Z","2020-04-27T11:49:02Z"
"","24270","Why is the Connection header missing in the WebFlux netty-server response?","I have a very simple application with WebFlux.  ```java package com.example.demo;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import reactor.core.publisher.Mono;  @RestController @SpringBootApplication public class DemoNettyApplication {      public static void main(String[] args) {         SpringApplication.run(DemoNettyApplication.class, args);     }      @GetMapping(""/hello"")     public Mono test() {         return Mono.just(""hello"");     } } ```  When I test the request with Chrome, I found that the response lost the `Connect` header. There are only 2 headers in my response header.  ``` HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 5 ```  When I test the same application with Undertow as the server, there are 4 headers.  ``` HTTP/1.1 200 OK Connection: keep-alive Content-Type: text/html;charset=UTF-8 Content-Length: 5 Date: Fri, 27 Dec 2019 12:18:57 GMT ```  It looks like it lost the `Connection` header. The `Connection` header is very important.  Why is the `Connection` header present in the response when using Undertow but not when using Netty?","closed","for: external-project,","ldwqh0","2019-12-27T12:17:56Z","2020-01-03T09:07:50Z"
"","24567","RequestContextHolder.getRequestAttributes always return null in resttemplate interceptor.","I have a spring cloud application which have multiple spring boot micro services. I'm using resttemplate to call other services in someone, and for security reason I use an interceptor to pass through the `Authorization` header. The full source code can be found at [Spring Cloud in Practice](https://github.com/jaggerwang/spring-cloud-in-practice).  ```java package net.jaggerwang.scip.common.api.interceptor;  import org.springframework.http.HttpHeaders; import org.springframework.http.HttpRequest; import org.springframework.http.client.ClientHttpRequestExecution; import org.springframework.http.client.ClientHttpRequestInterceptor; import org.springframework.http.client.ClientHttpResponse; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import java.io.IOException; import java.util.Collections; import java.util.Set;  public class HeadersRelayInterceptor implements ClientHttpRequestInterceptor {     private Set headers;      public HeadersRelayInterceptor(Set headers) {         this.headers = headers;     }      @Override     public ClientHttpResponse intercept(HttpRequest request, byte[] body,                                         ClientHttpRequestExecution execution) throws IOException {         var requestAttrs = RequestContextHolder.getRequestAttributes();         if (requestAttrs instanceof ServletRequestAttributes) {             var upstreamRequest = ((ServletRequestAttributes) requestAttrs).getRequest();             for (var header: headers) {                 request.getHeaders().addAll(header,                         Collections.list(upstreamRequest.getHeaders(header)));             }         }         return execution.execute(request, body);     } }  ```  But the `requestAttrs` above is always null, and I see the request executed by resttemplate is not in the main thread. Does this is the reason and how can I solve this problem.   **Spring Boot:** 2.2.2 **Spring Cloud:** Hoxton.SR1  ```xml       4.0.0               net.jaggerwang         spring-cloud-in-practice         1.0.0-SNAPSHOT           net.jaggerwang     spring-cloud-in-practice-user     1.0.0-SNAPSHOT     spring-cloud-in-practice-user     Spring cloud in practice user                            net.jaggerwang             spring-cloud-in-practice-common             ${scip-common.version}                                org.springframework.boot             spring-boot-starter-web                               org.springframework.boot             spring-boot-starter-security                               org.springframework.boot             spring-boot-starter-data-jpa                               org.springframework.boot             spring-boot-starter-actuator             true                               org.springframework.boot             spring-boot-devtools             runtime             true                               org.springframework.boot             spring-boot-configuration-processor             true                               org.springframework.boot             spring-boot-starter-test             test                                                   org.junit.vintage                     junit-vintage-engine                                                              org.springframework.security             spring-security-oauth2-resource-server                               org.springframework.security             spring-security-oauth2-jose                                org.springframework.cloud             spring-cloud-starter-consul-discovery                               org.springframework.cloud             spring-cloud-starter-consul-config                               org.springframework.cloud             spring-cloud-starter-circuitbreaker-reactor-resilience4j                                com.querydsl             querydsl-apt             provided                               com.querydsl             querydsl-jpa                                org.projectlombok             lombok                                mysql             mysql-connector-java             runtime                                org.flywaydb             flyway-core                                org.apache.commons             commons-pool2                                                           org.springframework.boot                 spring-boot-maven-plugin                                            com.mysema.maven                 apt-maven-plugin                 ${apt-maven-plugin.version}                                                               generate-sources                                                      process                                                                               target/generated-sources/java                             com.querydsl.apt.jpa.JPAAnnotationProcessor                                                                                            ```","closed","for: stackoverflow,","jaggerwang","2020-02-22T10:22:44Z","2020-02-25T02:20:54Z"
"","23846","Non-nullable non-primitive properties in kotlin classes can't be used as request parameters","I have a kotlin class with a non-nullable property, which is not using a primitive type in the jvm, and I'm trying to use the properties of that class as request parameters. If I don't include that property as a request parameter, I would expect a bad request response. However, it instead crashes with this exception:  ``` java.lang.IllegalArgumentException: Parameter specified as non-null is null: method no.finntech.iaap.data_import.Params., parameter a ```  This is the code I'm using:  ``` class Params(         val a: String )  @SpringBootApplication @RestController class Application {     @GetMapping(""/test"")     fun test(params: Params) = """" } ```  If `a` is of type `Int` instead, or if I use a non-nullable `String` directly in the arguments to `test` as a `RequestParam`, I get a bad request as expected.","open","in: kotlin,","trygveaa","2019-10-22T09:43:15Z","2022-01-19T10:55:19Z"
"","24139","Spring Cache does not support List key cache","I hava some ids to find users :  ```java  List users = ids.stream().map(id -> {     return getUserById(id); }) .collect(Collectors.toList());  @Cacheable(key = ""#p0"", unless = ""#result == null"") public User getUserById(Long id) { ... }  ```  I can also use ：  ```java  List users = ids.stream().map(id -> {     return getUserById(id); }) .collect(Collectors.toList());  @Cacheable(key = ""#ids.hash"") public Collection getUsersByIds(Collection ids) { ... }  ``` but getUsersByIds(Collection ids) cache and getUserById(Long id) cache cannot be shared  why does spring cache not support ids cache？  I want them to share the cache","closed","status: declined,","shenjianeng","2019-12-05T07:45:44Z","2019-12-07T11:15:29Z"
"","23959","Document the expected behavior of a method annotated by multiple @Scheduled annotations","I had a look at the [docs](https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/integration.html#scheduling) and couldn't find anything about the expected behaviour of a method being annotated by multiple `@Scheduled` annotations, such as:  ```java @Scheduled(cron = ""..."") @Scheduled(initialDelay = ..., fixedDelay = ...) public void launchTheDrones() {     // ... }  // or  @Scheduled(fixedRate = 10_000) @Scheduled(fixedRate = 20_000) public void launchTheCyborgs() {     // ... }  // or  @Scheduled(cron = ""0 * * * * MON-FRI"") @Scheduled(cron = ""0 * * * * MON-TUE"") public void launchTheShuttles() {     // ... } ```   I assume this depends on the task executor in use -- some are single threaded and only run the method once at any given point in time, but what if a `ThreadPoolTaskExecutor` with a core pool size > 1 is used?","open","in: core,","behrangsa","2019-11-09T06:12:59Z","2020-01-13T13:34:14Z"
"","24021","Question about AnnotatedBeanDefinitionReader#doRegisterBean()","I found the following code will never execute, which is left for the subsequent expansion of Spring?  ```java if (qualifiers != null) { 	for (Class qualifier : qualifiers) { 		if (Primary.class == qualifier) { 			abd.setPrimary(true); 		} 		else if (Lazy.class == qualifier) { 			abd.setLazyInit(true); 		} 		else { 		    abd.addQualifier(new AutowireCandidateQualifier(qualifier)); 		} 	} } ```  I am a beginner. Can you give me an explanation?   Thank you.","closed","for: stackoverflow,","gnehcgnaw","2019-11-19T07:53:12Z","2019-11-19T14:51:27Z"
"","24116","Automatic registration of EventPublishingTestExecutionListener breaks certain test setups","I found that the changes in issue #23748 break a special test setup of mine (well, I could not find a way to work around this, anyway). As requested I repost my concerns as a new issue here.  The scenario goes like this: I have this Jetty/CXF/Spring server process, which is required to be self contained and start from the command line as a plain old Java application. The setup and tear down of the Spring Context is handled manually within that process, of course. I have an accompanying integration test, which asserts that the startup and shutdown of the server work as intended. I use TestNG and `AbstractTestNGSpringContextTests` for that. We recently updated Spring, and this particular test now fails, due to the `EventPublishingTestExecutionListener` accessing the Spring Context in `org.springframework.test.context.support.DefaultTestContext.getApplicationContext()` after it was closed by the server process.  So, while this enhancement improves a lot of cases I guess, I suggest it also requires a possibility to modify the list of listeners.","closed","status: feedback-provided,","patrick-peer","2019-12-02T12:39:49Z","2019-12-13T14:06:01Z"
"","24033","json desirialization for kotlin collections on inheritated classes","I found a problem with json deserialization on lists with inherited classes and kotlin. The problem occurs when you define an abstract rest endpoint on kotlin collections. Here's a small example:  ```kotlin abstract class BaseCrudController {     @PostMapping(""/saveAll"")     @ResponseBody     fun saveAsList(@RequestBody dtos: List): List = listOf() }  @Controller @RequestMapping(""/api/v1/customer"") class CustomerController() : BaseCrudController() ```  Here's the class to deserialize:  ```kotlin class CustomerDto(var name: String?, var accountNumber: String?) : BaseDto()  abstract class BaseDto {     var id: Long? = null     var version: Int = 0 } ```  The error message is:  ``` Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class com.example.basecrudspringrestendpoint.presentation.dto.core.BaseDto]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinition Exception: Cannot construct instance of `com.example.basecrudspringrestendpoint.presentation.dto.core.BaseDto` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information  at [Source: (PushbackInputStream); line: 2, column: 3] (through reference chain: java.util.ArrayList[0])] with root cause ```  according to a bug ticket in the jackson module, the problem is maybe that spring not passing type resolution context to jackson: https://github.com/FasterXML/jackson-module-kotlin/issues/267  you can find the code for this also here [https://github.com/vb-dci/jackson-spring-bug](https://github.com/vb-dci/jackson-spring-bug)","open","in: kotlin,","vb-dci","2019-11-12T16:10:22Z","2022-01-19T10:53:53Z"
"","23857","I found a problem in the process of reading the source code, the configurationClasses member of the ConfigurationClassParser class, why not use Set here?","I found a problem in the process of reading the source code: the `configurationClasses` member of the `ConfigurationClassParser` class.  Why not use `Set` here?  https://github.com/spring-projects/spring-framework/blob/5b6337b6a9c4b23720f92aee575df099a9972c64/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L133","closed","in: core,","wycm","2019-10-24T04:09:28Z","2019-10-25T12:40:17Z"
"","24586","Simplify some redundant code","I find some code to refactor using analysis :  * Redundant `Collection.addAll()` call. It may cause one time array copy. * The code like `this.messageBytesToRead >= input.readableByteCount() ? input.readableByteCount() : this.messageBytesToRead;` may cause one more time `input.readableByteCount()` call.","closed","type: task,","zhangt2333","2020-02-25T02:00:04Z","2020-02-26T11:29:17Z"
"","24377","Set MessageProducer's deliveryMode after create Producer","I find out that the producer does not have the same deliveryMode that the JmsTemplate has.","closed","status: declined,","ivyxjc","2020-01-16T13:50:10Z","2020-01-16T14:50:16Z"
"","24666","Cache the default logger for recovery in FailFastProblemReporter","I feel that the default logger can be cached here. If we do this, we can avoid duplicate logger creation, when calling setLogger with a null parameter.","closed","in: core,","chenqimiao","2020-03-10T04:06:38Z","2021-12-03T01:32:13Z"
"","24241","Blocking call in ConcurrentReferenceHashMap on event loop","I encountered the following blocking call within `ConcurrentReferenceHashMap` on the event loop.  I'd like any of the following solutions: 1. Fix `ConcurrentReferenceHashMap` so that it does not block, OR 2. Move the blocking call to another thread pool (perhaps via `BodyExtractors.toMono`), OR 3. Create a `BlockHoundIntegration` within spring that will whitelist this blocking call  ``` java.lang.Error: Blocking call! jdk.internal.misc.Unsafe#park 	at reactor.blockhound.BlockHound$Builder.lambda$new$0(BlockHound.java:196) 	at reactor.blockhound.BlockHound$Builder.lambda$install$6(BlockHound.java:318) 	at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:46) 	at java.base/jdk.internal.misc.Unsafe.park(Unsafe.java) 	at java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:194) 	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:885) 	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:917) 	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1240) 	at java.base/java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:267) 	at org.springframework.util.ConcurrentReferenceHashMap$Segment.doTask(ConcurrentReferenceHashMap.java:524) 	at org.springframework.util.ConcurrentReferenceHashMap.doTask(ConcurrentReferenceHashMap.java:419) 	at org.springframework.util.ConcurrentReferenceHashMap.put(ConcurrentReferenceHashMap.java:282) 	at org.springframework.util.ConcurrentReferenceHashMap.put(ConcurrentReferenceHashMap.java:271) 	at org.springframework.core.ResolvableType.forType(ResolvableType.java:1420) 	at org.springframework.core.ResolvableType.forType(ResolvableType.java:1344) 	at org.springframework.web.reactive.function.BodyExtractors.toMono(BodyExtractors.java:80) 	at org.springframework.security.oauth2.core.web.reactive.function.OAuth2AccessTokenResponseBodyExtractor.extract(OAuth2AccessTokenResponseBodyExtractor.java:59) 	at org.springframework.security.oauth2.core.web.reactive.function.OAuth2AccessTokenResponseBodyExtractor.extract(OAuth2AccessTokenResponseBodyExtractor.java:48) 	at org.springframework.web.reactive.function.client.DefaultClientResponse.body(DefaultClientResponse.java:110) 	at org.springframework.security.oauth2.client.endpoint.WebClientReactiveClientCredentialsTokenResponseClient.lambda$null$0(WebClientReactiveClientCredentialsTokenResponseClient.java:85) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:203) 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:203) 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onNext(MonoFlatMapMany.java:242) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2186) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onSubscribeInner(MonoFlatMapMany.java:143) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onSubscribe(MonoFlatMapMany.java:237) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core.publisher.Flux.subscribe(Flux.java:8143) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onNext(MonoFlatMapMany.java:188) 	at reactor.core.publisher.FluxRetryPredicate$RetryPredicateSubscriber.onNext(FluxRetryPredicate.java:82) 	at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:156) 	at reactor.netty.http.client.HttpClientConnect$HttpObserver.onStateChange(HttpClientConnect.java:397) 	at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:494) 	at reactor.netty.resources.PooledConnectionProvider$DisposableAcquire.onStateChange(PooledConnectionProvider.java:526) 	at reactor.netty.resources.PooledConnectionProvider$PooledConnection.onStateChange(PooledConnectionProvider.java:435) 	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:521) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:89) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:326) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:313) 	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:427) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:281) 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931) 	at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:792) 	at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:502) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:407) 	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1050) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:834) ```  spring-boot 2.2.2.RELEASE spring-core 5.2.2.RELEASE spring-security-oauth2-client 5.2.1.RELEASE","closed","status: superseded,","philsttr","2019-12-20T17:26:53Z","2020-02-24T12:39:57Z"
"","24366","Explicit Content-Type Header in WebClient is overwritten by ResourceHttpMessageWriter","I discovered this on spring-boot 2.1 I can reproduce the same behaviour using spring-boot 2.2.2.  I'm trying to post binary Content with a specified Content-Type Header using WebClient:  ```  WebClient.create().post().uri(MY_URI)                 .contentType(MediaType.APPLICATION_PDF)                 .body(BodyInserters.fromResource(myResource))                 .exchange() ```  in some cases the request was made with `Content-Type: application/octet-stream` instead of `application/pdf`. Apparently the RessourceHttpMessageWriter will set the Content-Type Header based on the resources filename overwriting the explicitly set contentType on the Request in [ResourceHttpMessageWriter.writeResource](https://github.com/spring-projects/spring-framework/blob/02da8486a3c1cf34893be3096dbd95abfb44fd0f/spring-web/src/main/java/org/springframework/http/codec/ResourceHttpMessageWriter.java#L116).  See https://github.com/hgarus/webclient-content-type-example/blob/master/src/test/java/com/example/demo/WebClientContentTypeTest.java for a minimal testcase.","closed","type: bug,","hgarus","2020-01-15T14:50:46Z","2020-01-20T17:32:56Z"
"","24558","Update section on HTTP/2 in WebFlux documentation","I check the http/2 [Wiki](https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support#reactor-netty). I think it is a confusing phrase.","closed","type: task,","moonchanyong","2020-02-20T14:57:20Z","2020-02-20T23:04:43Z"
"","24770","@RepositoryRestResource loses pagination when entities are nested","I am working on an api and am trying to leverage @RepositoryRestResource to get paginated results. This works fine with a single entity and repository. When this entity has a @OneToMany/@ManyToOne bidirectional child, calls to the child endpoint do not return the page element. I made an example to demonstrate. Given the application:  ``` @SpringBootApplication public class NestedDataJpaApplication {     public static void main(String[] args) {         SpringApplication.run(NestedDataJpaApplication.class);     } } ``` My model objects: ``` @Entity public class Company {     @Id     @GeneratedValue(strategy=GenerationType.AUTO)     private Long id;     private String name;      public Long getId() {      return id;     }      public String getName() {      return name;     }      @OneToMany(targetEntity = Division.class, mappedBy = ""company"")     private List divisions = new ArrayList<>();      public List getDivisions() {      return divisions;     } }  @Entity public class Division {     @Id     @GeneratedValue(strategy= GenerationType.AUTO)     private Long id;     String name;      @ManyToOne     private Company company;      public Long getId() {         return id;     }      public String getName() {         return name;     }      public Company getCompany() {         return company;     } } ``` And the resource repositories: ``` @RepositoryRestResource public interface CompanyRepository extends PagingAndSortingRepository {}  @RepositoryRestResource public interface DivisionRepository extends PagingAndSortingRepository {} ``` ``` After starting the application, create a company with: curl --location --request POST 'http://localhost:8080/companies'  --header 'Content-Type: application/json'  --data-raw '{ ""name"":""Microsoft"" }' ``` Now fetch the results to see the pagination info at the bottom: ``` curl --location --requestGET 'http://localhost:8080/companies'{ { ""_embedded"" : { ""companies"" : [ { ""name"" : ""Microsoft"", ""_links"" : { ""self"" : { ""href"" : ""http://localhost:8080/companies/1"" }, ""company"" : { ""href"" : ""http://localhost:8080/companies/1"" }, ""divisions"" : { ""href"" : ""http://localhost:8080/companies/1/divisions"" } } } ] }, ""_links"" : { ""self"" : { ""href"" : ""http://localhost:8080/companies{?page,size,sort}"", ""templated"" : true }, ""profile"" : { ""href"" : ""http://localhost:8080/profile/companies"" } }, ""page"" : { ""size"" : 20, ""totalElements"" : 1, ""totalPages"" : 1, ""number"" : 0 } } ``` Add a division: ``` curl --location --request POST 'http://localhost:8080/divisions'  --header 'Content-Type: application/json'  --data-raw '{ ""name"":""Windows"", ""company"":""http://localhost:8080/companies/1"" }' ``` Now when fetching divisions, note the missing page section: ``` curl --location --request GET 'http://localhost:8080/companies/1/divisions'  { ""_embedded"" : { ""divisions"" : [ { ""name"" : ""Windows"", ""_links"" : { ""self"" : { ""href"" : ""http://localhost:8080/divisions/2"" }, ""division"" : { ""href"" : ""http://localhost:8080/divisions/2"" }, ""company"" : { ""href"" : ""http://localhost:8080/divisions/2/company"" } } } ] }, ""_links"" : { ""self"" : { ""href"" : ""http://localhost:8080/companies/1/divisions"" } } } ``` Expected behavior is the child element will have a page section just as the parent does.  Here is my build.gradle for good measure: ``` plugins { 	id 'org.springframework.boot' version '2.2.2.RELEASE' 	id 'io.spring.dependency-management' version '1.0.8.RELEASE' 	id 'java' }  group = 'com.example' version = '0.0.1-SNAPSHOT' sourceCompatibility = '1.8'  repositories { 	mavenCentral() }  dependencies { 	implementation 'org.springframework.boot:spring-boot-starter-data-jpa' 	implementation 'org.springframework.boot:spring-boot-starter-data-rest' 	runtimeOnly 'com.h2database:h2' 	testImplementation('org.springframework.boot:spring-boot-starter-test') { 		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine' 	} }  test { 	useJUnitPlatform() }  ```","closed","for: external-project,","D-Dubs","2020-03-24T14:54:58Z","2020-03-24T17:21:28Z"
"","24432","SELECT FOR UPDATE issue with @Transactional","I am using `SELECT ... FOR UPDATE` statement to achieve row-level locking in my SpringBoot app. Database: MySQL 5.7.28, connector - MariaDb java client 2.5.2, connection pool HikariCP 2.7.9, spring boot version - 2.0.3 Release.  Persistence is accomplished by Spring JDBC Template, not by JPA. I am using Spring Transaction management, annotation-based by slapping `@Transactional` annotation on my DAO methods. Transactional proxies are generated via AspectJ compile-time weaving (`@EnableTransactionManagement(mode = AdviceMode.ASPECTJ)`). I am sure that the transaction manager is configured correctly.  I have written a couple of integration tests that would verify the possibility of a race condition when multiple threads are competing to update the same row, that is supposed to be locked with `SELECT ... FOR UPDATE`.  Now, the tests work 95% of the time, however, there is one test that is failing when there is a particular sequence of ITs executed.  I am certain that when a test fails, a row lock is not imposed.  I have enabled the MySql query log on the server to help with troubleshooting.  Here is what I see when the first thread is executing the `SELECT ... FOR UPDATE` statement:  ``` 2020-01-26T12:54:06.681319Z	 1219 Query	set autocommit=0 2020-01-26T12:54:36.616097Z	 1209 Query	SELECT _listed_fields_ FROM _my_table_ WHERE id IN ('19qix6lvsfx') FOR UPDATE ```  It seems that the auto-commit is set on a wrong connection object. Do I read it right? What are those numbers `1219` and `1209`?   When everything works right, the log looks like this:  ``` 2020-01-26T13:24:22.940787Z	 1243 Query	set autocommit=0 2020-01-26T13:24:36.515016Z	 1243 Query	SELECT _listed_fields_ FROM _my_table_ WHERE id IN ('19xbs7vv53r') FOR UPDATE ```  Is there an issue in spring-jdbc framework that is causing this problem?   In the application logs I see the following:  ``` 2020-01-27 19:23:13.616 DEBUG [487dcb99ba9566ac] 22318 --- [o-auto-1-exec-1] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [SELECT _fields_ FROM _my_table_ WHERE id IN (?) FOR UPDATE] 2020-01-27 19:23:13.617 DEBUG [0cf8b334ec05dc92] 22318 --- [-auto-1-exec-10] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [SELECT _fields_ FROM _my_table_ WHERE id IN (?) FOR UPDATE] 2020-01-27 19:23:13.618 DEBUG [ff5c51b0af88dbc6] 22318 --- [o-auto-1-exec-9] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [SELECT _fields_ FROM _my_table_ WHERE id IN (?) FOR UPDATE] 2020-01-27 19:23:13.620 DEBUG [487dcb99ba9566ac] 22318 --- [o-auto-1-exec-1] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource 2020-01-27 19:23:13.622 DEBUG [0cf8b334ec05dc92] 22318 --- [-auto-1-exec-10] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource 2020-01-27 19:23:13.624 DEBUG [ff5c51b0af88dbc6] 22318 --- [o-auto-1-exec-9] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource ``` The suspicious part is that after each of those selects, new connection is being requested instead of reusing an old one.  When this test is passing, the logs do not contain `Fetching JDBC Connection from DataSource` after `SELECT ... FOR UPDATE` stmts.  Also these 2 guys (I doubt it is related, but I thought I'd mention them as it is a little suspicious that the same log is printed across different threads. Concurrent collection not used?): ``` 2020-01-27 19:23:13.581 DEBUG [487dcb99ba9566ac] 22318 --- [o-auto-1-exec-1] t.a.AnnotationTransactionAttributeSource : Adding transactional method 'com.my.package.EventManager.update' with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''  2020-01-27 19:23:13.586 DEBUG [ff5c51b0af88dbc6] 22318 --- [o-auto-1-exec-9] t.a.AnnotationTransactionAttributeSource : Adding transactional method 'com.my.package.EventManager.update' with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; '' ```  I have reproduced the problem just to confirm mysql query logs:   ``` 2020-01-28T01:42:14.746340Z	 2252 Query	set autocommit=0 2020-01-28T01:42:14.746839Z	 2253 Query	set autocommit=0 2020-01-28T01:42:14.747515Z	 2254 Query	set autocommit=0 2020-01-28T01:42:14.770750Z	 2243 Query	SELECT _fields_ FROM _my_table_ WHERE id IN ('1e4s7x7jbhz') FOR UPDATE 2020-01-28T01:42:14.770997Z	 2242 Query	SELECT _fields_ FROM _my_table_ WHERE id IN ('1e4s7x7jbhz') FOR UPDATE 2020-01-28T01:42:14.771432Z	 2244 Query	SELECT _fields_ FROM _my_table_ WHERE id IN ('1e4s7x7jbhz') FOR UPDATE ```","closed","in: test,","imochurad","2020-01-27T02:08:08Z","2020-02-17T16:41:07Z"
"","24549","WebMvcConfigurer not working without @EnableWebMvc after upgrading to spring-boot 2.x","I am updating from spring-boot 1.5.4 to spring-boot 2.2.4. After migrating my JUnitss started breaking for ContentNegotiatingViewResolver.  I have the following functionality. 1. Download the CSV / xls file. 2. For this, we have used ContentNegotiatingViewResolver. Hence, we can make the following HTTP request `http://localhost:8080/myapp/download.xls` `http://localhost:8080/myapp/download.csv` 3. based on file extension present in URL, the appropriate view is resolved and file with required extension is responded.  This is working as expected with sprint-boot 1.5.4. But after migration, my unit tests are failing to return HTTP 404 status.  But, after the upgrade, if I annotated my class implementing `WebMvcConfigurer `  with `@EnableWebMvc` unit tests are able to detect the above URLs. Even the same behavior is observed when application is running the upgrade.  Not sure, if `@EnableWebMvc` is mandatory for classes implementing `WebMvcConfigurer ` or it is an issue with Spring - boot 2.2.4 i.e. with spring 5.  Please guide me.","closed","for: stackoverflow,","ShriprasadM","2020-02-19T02:25:01Z","2020-02-20T07:31:45Z"
"","24423","How can we use Spring Cloud Sleuth with spring MVC project?","I am trying to use spring cloud sleuth with spring web mvc project. We are sending the request from spring web mvc to another spring boot project. I need to have the traceID and spanId to display in the UI. How can we achieve this?","closed","for: stackoverflow,","jitenvij1992","2020-01-24T06:48:19Z","2020-01-24T08:14:01Z"
"","24634","Revisit DataAccessException translation API","I am implementing transaction retry mechanism to our applications and using `DataAccessException` mapping facility to translate some db failures to transient exception. Since `DataAccessException` mapping is one of the early days feature of spring-framework, I felt some of the APIs are bit outdated.  Here is list of things I encountered:  ### `SQLErrorCodeSQLExceptionTranslator` requires subclassing to perform custom mapping logic.  To add custom mappings to existing logic, `SQLErrorCodeSQLExceptionTranslator#customTranslate` need to be overridden by subclass.  I made a delegation subclass, then injected custom translators.  ```java public class CustomDelegatingSQLErrorCodeSQLExceptionTranslator extends SQLErrorCodeSQLExceptionTranslator {  	@Nullable 	private SQLExceptionTranslator delegate;  	// constructors  	@Override 	protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) { 		if (this.delegate == null) { 			return null; 		} 		return this.delegate.translate(task, sql, sqlEx); 	} } ```  I think composition style API is nicer to have than sub-classing.   ### Does not have a way to append/update *some* of the error codes on `SQLErrorCodes` (not just entire override)  Error code provided by `org/springframework/jdbc/support/sql-error-codes.xml`(`SQL_ERROR_CODE_DEFAULT_PATH`) can be overridden by `sql-error-codes.xml`(`SQL_ERROR_CODE_OVERRIDE_PATH`). However, the override is done by bean(DB type). So, it cannot partially update error codes on a specific bean. For example, adding some error codes to transient exceptions to PostgreSQL.  To workaround repeating entire DB error code mapping, I created a `SQLErrorCodesUpdater` which uses the nature that the `SQLErrorCodes` is a mutable java bean.  ```java @AllArgsConstructor @Getter public class CustomSQLErrorCodes {  	/** 	 * name has to match with db vendor name from 	 * ""DataSourceMetaData#getDatabaseProductName"" which also matches to the bean id in 	 * ""org/springframework/jdbc/support/sql-error-codes.xml"" 	 */ 	private String databaseName;  	/** 	 * Which exception to map 	 */ 	private DataAccessExceptionType dataAccessExceptionType;  	/** 	 * Whether replace or add to the default sql error code 	 */ 	private boolean add;  	/** 	 * SQL error code to add or replace 	 */ 	private String[] codes;  } ```  ```java public enum DataAccessExceptionType { 	BAD_SQL_GRAMMAR(""badSqlGrammarCodes""), 	INVALID_RESULT_SET_ACCESS(""invalidResultSetAccessCodes""), 	DUPLICATE_KEY(""duplicateKeyCodes""),   ...   	private String propertyName;   ... } ```  ```java public class SQLErrorCodesUpdater {  	public void update(CustomSQLErrorCodes customSQLErrorCodes) { 		update(customSQLErrorCodes.getDatabaseName(), customSQLErrorCodes.getDataAccessExceptionType(), 				customSQLErrorCodes.isAdd(), customSQLErrorCodes.getCodes()); 	}  	private void update(String databaseName, DataAccessExceptionType exceptionType, boolean add, String[] values) { 		SQLErrorCodesFactory factory = SQLErrorCodesFactory.getInstance(); 		SQLErrorCodes sec = factory.getErrorCodes(databaseName);  		String propertyName = exceptionType.getPropertyName();  		BeanWrapper beanWrapper = new BeanWrapperImpl(sec); 		Set newCodes = new HashSet<>(Arrays.asList(values)); 		if (add) { 			// since codes fields in SQLErrorCodes have initially empty String[] assigned 			// codes will never be null 			String[] codes = (String[]) beanWrapper.getPropertyValue(propertyName); 			newCodes.addAll(Arrays.asList(codes)); 		} 		beanWrapper.setPropertyValue(propertyName, newCodes.toArray(new String[0]));  	} ```  Then, run them at runtime ```java @Bean public InitializingBean updateSQLErrorCodes(ObjectProvider customSQLErrorCodesProvider) {   SQLErrorCodesUpdater updater = new SQLErrorCodesUpdater();   return () -> {     for (CustomSQLErrorCodes customSQLErrorCodes : customSQLErrorCodesProvider) {       updater.update(customSQLErrorCodes);     }   }; } ```  Alternatively, `CustomSQLErrorCodesTranslation` can be used to provide custom mappings, but it is mapped to `SQLErrorCodes` instance which is database vendor specific. I can create a custom error code map, but assigning it requires to retrieve db vendor type.   ```java CustomSQLErrorCodesTranslation translation = new CustomSQLErrorCodesTranslation(); translation.setExceptionClass(TransientDataAccessResourceException.class); translation.setErrorCodes(""99999"");  // custom error map by DB vendor type Map> map = new HashMap<>(); map.put(""H2"", Arrays.asList(translation));  // here needs to retrieve db vendor name String dbName = null; try {   dbName = JdbcUtils.extractDatabaseMetaData(dataSource, ""getDatabaseProductName""); } catch (MetaDataAccessException ex) {   // TODO: log or re-throw } List customTranslations = map.getOrDefault(dbName, Collections.emptyList());  SQLErrorCodes sqlErrorCodes = SQLErrorCodesFactory.getInstance().getErrorCodes(dataSource); sqlErrorCodes.setCustomTranslations(customTranslations.toArray(new CustomSQLErrorCodesTranslation[0])); ```  Still it's a bit complicated to just apply custom error code mappings.  `SQLErrorCodes` does not know the db vendor name, I need to retrieve it from datasource. (`SQLErrorCodes#getDatabaseProductName()` returns one from bean property and different from bean id(db vendor name), which is a bit confusing as well.)   ### An instance of `SQLErrorCodeSQLExceptionTranslator` is specific to single DB type  SQLErrorCodeSQLExceptionTranslator when `setDataSource`, `setDatabaseProductName`, `setSqlErrorCodes`, or corresponding constructors are called, then `sqlErrorCodes` is populated for the specific DB vendor type. This makes the bean dependent to specific vendor type. It is fine but not simple to find this dependency until digging the code.  Probably adding documentation would be helpful.   ### `PersistenceExceptionTranslationInterceptor#detectPersistenceExceptionTranslators` does not consider ordering  When multiple `PersistenceExceptionTranslator` are available, there is no way to specify ordering. I don't find any workaround to guarantee the ordering of each translator unless spring code is updated to consider the ordering.","open","type: enhancement,","ttddyy","2020-03-03T18:41:10Z","2020-12-07T11:30:40Z"
"","24743","MediaTypeNotSupportedStatusException seems unused","I am currently writing some code that wraps common Spring web exceptions.  I came across both `MediaTypeNotSupportedStatusException` and `UnsupportedMediaTypeStatusException`. They seem very similar, yet the former is never instantiated in any of Spring's code. Are they supposed to convey different exception semantics?  Anyway, it seems like this class was accidentally missed during a refactoring, or something. It feels like it could be removed.","closed","type: bug,","sagacity","2020-03-20T13:11:17Z","2020-03-23T17:03:29Z"
"","24762","Upgrade to JUnit 5.6.1","https://junit.org/junit5/docs/5.6.1/release-notes/","closed","type: dependency-upgrade,","sbrannen","2020-03-22T19:46:39Z","2020-03-22T19:57:52Z"
"","24713","SPR-8389 condense BeanCreationException exception message","https://github.com/spring-projects/spring-framework/issues/8389  The root cause is the message for NestedException included the cause (by concatenating by `; nested exception is ...`), which is NestedException as well, so its message will include its own `nested exception` again, thus the horrible long exception messages. We don't need to include the cause message for stack trace will output its enclosed content at the `Caused by:` section. My approach is to only return the basic message excluding cause message in `getMessage` overridden method, via runtime stack trace inspection.","closed","","NathanQingyangXu","2020-03-17T23:23:08Z","2020-03-18T17:28:32Z"
"","23944","Update AbstractNestablePropertyAccessor.java","https://github.com/spring-projects/spring-framework/issues/23937#issue-517809539","closed","status: declined,","ScOrPiOzzy","2019-11-07T01:34:22Z","2019-11-28T12:38:09Z"
"","24608","YamlProcessor cannot parse a map with numeric keys","https://github.com/spring-projects/spring-framework/blob/b30f9a13083aa1a95c92dd4d7916eeb7474c9a1c/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlProcessor.java#L286  For example: ``` valueMap: {1: enabled, 0: disabled}  Caused by: java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 	at java.util.LinkedHashMap.forEach(Unknown Source) 	at org.springframework.beans.factory.config.YamlProcessor.buildFlattenedMap(YamlProcessor.java:271) 	at org.springframework.beans.factory.config.YamlProcessor.lambda$buildFlattenedMap$1(YamlProcessor.java:287) 	at java.util.LinkedHashMap.forEach(Unknown Source) 	at org.springframework.beans.factory.config.YamlProcessor.buildFlattenedMap(YamlProcessor.java:271) 	at org.springframework.beans.factory.config.YamlProcessor.lambda$buildFlattenedMap$1(YamlProcessor.java:287) 	at java.util.Collections$SingletonMap.forEach(Unknown Source) 	at org.springframework.beans.factory.config.YamlProcessor.buildFlattenedMap(YamlProcessor.java:271) 	at org.springframework.beans.factory.config.YamlProcessor.lambda$buildFlattenedMap$1(YamlProcessor.java:299) 	at java.util.LinkedHashMap.forEach(Unknown Source) 	at org.springframework.beans.factory.config.YamlProcessor.buildFlattenedMap(YamlProcessor.java:271) 	at org.springframework.beans.factory.config.YamlProcessor.lambda$buildFlattenedMap$1(YamlProcessor.java:287) 	at java.util.LinkedHashMap.forEach(Unknown Source) 	at org.springframework.beans.factory.config.YamlProcessor.buildFlattenedMap(YamlProcessor.java:271) 	at org.springframework.beans.factory.config.YamlProcessor.getFlattenedMap(YamlProcessor.java:266) 	at org.springframework.beans.factory.config.YamlProcessor.process(YamlProcessor.java:218) 	at org.springframework.beans.factory.config.YamlProcessor.process(YamlProcessor.java:161) 	at org.springframework.beans.factory.config.YamlProcessor.process(YamlProcessor.java:134) 	at org.springframework.boot.env.OriginTrackedYamlLoader.load(OriginTrackedYamlLoader.java:75) 	at org.springframework.boot.env.YamlPropertySourceLoader.load(YamlPropertySourceLoader.java:50) 	at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.loadDocuments(ConfigFileApplicationListener.java:562) 	at org.springframework.boot.context.config.ConfigFileApplicationListener$Loader.load(ConfigFileApplicationListener.java:518) 	... 42 common frames omitted ```","closed","in: core,","tedinGH","2020-02-28T07:44:02Z","2020-02-28T12:35:49Z"
"","24075","Refine Throwable handling in spring-websocket","https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-websocket/src/main/java/org/springframework/web/socket/handler/ExceptionWebSocketHandlerDecorator.java#L97  ExceptionWebSocketHandlerDecorator swallows all exceptions including OOM, I had a problem where all my apps went into zombie mode, because they did not crash with OOM as expected, because they were swallowed","closed","type: enhancement,","maczikasz","2019-11-25T14:32:10Z","2019-11-26T13:31:49Z"
"","24660","How to write accesslog using RollingFileAppender in springboot embed tomcat","How to write accesslog using RollingFileAppender in springboot embed tomcat","closed","for: stackoverflow,","249510573","2020-03-08T12:51:02Z","2020-03-08T14:55:46Z"
"","24072","Cache result of String.getBytes() in ExtendedBeanInfo.PropertyDescriptorComparator","Hoist constant byte[] out of loop. This is likely to improve start-up time for the cases when `ExtendedBeanInfo` is widely used as their property descriptors are stored in `TreeSet`","closed","type: enhancement,","stsypanov","2019-11-25T10:09:16Z","2019-12-01T09:49:34Z"
"","24811","Add support for customization of property names in validation","Hibernate Validator (HV) `6.1.0.FINAL` adds support for [property names customization](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-property-node-name-provider).  Simply put, this feature allows us to customize how property names are resolved during validation, so for e.g. depending on our needs `private String firstName` can be resolved to `firstName`, or `first_name`, or whatever we want.  This, however, causes issues to Spring, because `DataBinder` is not able to find a corresponding accessor if the name has changed. `org.springframework.beans.NotReadablePropertyException` is raised in this case. [This](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java#L312) is the method that is failing.  I have created a small [project](https://github.com/dalibegovic/spring-validation-custom-property-name-support) to showcase this. Some things to note: - HV `6.1.0.Final` is explicitly set in `build.gradle` - Some [configuration](https://github.com/dalibegovic/spring-validation-custom-property-name-support/blob/master/src/main/java/com/example/validation/ValidationConfiguration.java) is needed to set up this HV feature - Project has one test that is failing with the above mentioned exception  This feature is specific for HV library, it is not (yet) part of Java Bean Validation specification, so i don't know what is Springs stand on supporting features like this, but i would assume a lot of Spring users would find feature useful.  I am willing to contribute with implementing this support if needed.","open","in: core,","dalibegovic","2020-03-29T14:31:51Z","2022-06-02T07:49:29Z"
"","24815","Fix typo in webflux-cors.adoc","Hi, I'm reading WebFlux documentation. I've just found little typo so I create this PR to fix it. Thanks for your maintenance.","closed","type: task,","KimTaehee","2020-03-30T11:48:57Z","2020-03-30T12:00:40Z"
"","24557","WebFluxTest cannot read URL with matrix variable","Hi, I notice WebFluxTest cannot test with a URL with matrix variable. For example I have a test: ```java     @Autowired     WebTestClient webTestClient;     @Test     public void exampleTest(){                  webTestClient.get().uri(""http://localhost:8080/example/employees/id=1"")                      .exchange()                      .expectBody().consumeWith(response -> assertTrue(new String(response.getResponseBody(),                                                StandardCharsets.UTF_8).contains(expected)));   } ``` The code to  test is: ```java @Controller public class Example {          @GetMapping(""/example/employees/{id}"")     @ResponseBody     public String example(@MatrixVariable(""id"") int id) {          ....     } ``` And there is a config here: ```java @Configuration public class MyConfig implements WebMvcConfigurer {   @Override     public void configurePathMatch(PathMatchConfigurer configurer) {         UrlPathHelper urlPathHelper = new UrlPathHelper();         urlPathHelper.setRemoveSemicolonContent(false); // <---         configurer.setUrlPathHelper(urlPathHelper);     } ... } ``` Output: ``` ""status"":400,""error"":""Bad Request"",""message"":""Missing matrix variable 'id' for method parameter of type int""} ```","closed","status: invalid,","aCodeRancher","2020-02-19T18:34:42Z","2020-02-20T16:19:15Z"
"","24472","Cached Flux problem with application/stream+json response type","Hi, I continue here the issue from gitter https://gitter.im/spring-projects/spring-boot?at=5e3800b16f9d3d34981a7c43 In short - I spot the problem with `cache` operator while returing a `Flux` from controller endopoint with `produce=APPLICATION_STREAM_JSON_VALUE`. - This flux never ends (even if is completed) and what is worse, as I see it returns only the first value.  Repo: https://github.com/Azbesciak/FluxCacheProblemJsonStream","closed","for: external-project,","Azbesciak","2020-02-03T14:12:50Z","2020-02-09T06:50:13Z"
"","24394","In IDEA， could not find org.springframework.cache.annotation.EnableCachingIntegrationTests.DummyFooRepository","Hi, I am new to Spring Framework compilation, and after I import Spring source code into IDEA, there are some errors.   for example,   ![image](https://user-images.githubusercontent.com/6405801/72655805-08191b80-39d2-11ea-82b2-461297b31c3c.png)  as the above photo shows, IDEA could not find class org.springframework.cache.annotation.EnableCachingIntegrationTests.DummyFooRepository， and as you can see, the class is here.   And I guess， there is something wrong in my IDEA config, but could not locate the wrong config.   So, could you help me with that.","closed","for: stackoverflow,","sluk3r","2020-01-18T01:10:36Z","2020-01-20T10:44:54Z"
"","23838","@RequestHeader and POJO binding","Hi, do you have plans to add support for `header` binding with `POJO`?  This issue based on stackoverflow question [@RequestHeader not binding in POJO but binding only in variable](https://stackoverflow.com/questions/49305099/requestheader-not-binding-in-pojo-but-binding-only-in-variable)  IMHO, it would be a useful feature, instead of writing custom and similar `HandlerMethodArgumentResolver`   Some ideas: add an annotation for method args - `@Header` add an annotation for `POJO` fields - `@HeaderParam` add support for validation - `@Valid` add support for immutable  `POJO`  Thanks","closed","status: invalid,","tsarenkotxt","2019-10-20T18:12:03Z","2020-10-29T04:21:26Z"
"","24111","Default cache implementation causes OOME","Hi, according to [documentation](https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#cache-strategies), Spring under the hood uses `ConcurrentHashMap` that as we know is unbounded and lacking TTL policy. While `ConcurrentHashMap` is a great choice for a demo application, it is harmful unless chosen consciously.  If a developer forget to configure a cache provider (like EhCache or Caffeine) before deployment, it will cause `OutOfMemoryError` after indeterminate amount of time. It happened couple of weeks ago in a company I work with, when one of our services crashed.  I would like to suggest a small change to configuration of Spring cache abstraction - developer should configure explicitly that is fine with the default config. I propose to make a `SimpleCacheConfiguration` dependent on `spring.cache.type=simple` setting. When `spring.cache.type` is missing, context should fail to start. WDYT?","closed","status: declined,","mszarlinski","2019-12-01T19:13:05Z","2020-08-07T09:17:42Z"
"","23827","Reactor stacktrace-mode is not configurable","Hi, according to #22105 I should be able to configure Reactor's stacktrace mode by configuration. After digging a bit I think it is not the case.   Spring's Webflux Handler does not take any property into account in DispatcherHandler [here](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/DispatcherHandler.java#L170).   Moreover 'description' is always non-null which causes [AssemblySnapshot](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java#L135) to be always 'checkpointed' thus always appending a debug exception.   This is not the expected behaviour IMO.   Thanks in advance for having a look","closed","for: external-project,","beltram","2019-10-17T13:33:52Z","2019-11-12T11:10:01Z"
"","24662","Spring JDBC Slice doesn't work","Hi, One question before send the issue. I am using @EnableJdbcRepositories with last vesrion of the dependencies: https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#jdbc.repositories  Is it possible to use Slice or Page in CrudRepository ?","closed","for: stackoverflow,","LaCoCa","2020-03-09T12:12:23Z","2020-03-09T14:59:52Z"
"","24191","Regression: tracing context lost with WebTestClient","Hi, Once using Sleuth and injecting Tracing headers in a WebTestClient I was able to retrieve them in Reactor's context later on like this : ```kotlin // Test webTestClient.get()     .uri(""/api/tracing"")     .header(""X-B3-TraceId"", ""463ac35c9f6413ad48485a3953bb6124"")     .header(""X-B3-SpanId"", ""a2fb4a1d1a96d312"")  // Controller @GetMapping     fun spanId(): Mono {         return Mono.subscriberContext()                 .filter { it.hasKey(Span::class.java) }                 .map { it[Span::class.java].context() }                 .map { it.spanIdString() }     } ```  This worked with spring-test 5.2.1.RELEASE but no longer with 5.2.2.RELEASE.    What happens is that a new Span is created [here](https://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/web/TraceWebFilter.java#L186) because Context lacks original Span.    I think root cause comes from [this commit](https://github.com/spring-projects/spring-framework/commit/5d2fc2fc32a73f2250addac1404ae3b8df309736#diff-03c4d94a51354f90b067904bc25811d4) or [this one](https://github.com/spring-projects/spring-framework/commit/21b2fc1f0129420a8da521cd1e7f33f19beffbc1#diff-03c4d94a51354f90b067904bc25811d4) in [HttpHandlerConnector](https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/main/java/org/springframework/test/web/reactive/server/HttpHandlerConnector.java).  I've setup a reproducer [here](https://github.com/beltram/spring-test-sleuth-reproducer). Thank you 😄   Affects: Spring Framework 5.2.2.RELEASE","closed","for: external-project,","beltram","2019-12-11T16:24:57Z","2019-12-16T17:41:30Z"
"","24233","Consider order on DeferredImportSelector when processing DeferredImportSelector.Group","Hi,  When I was writing custom `DeferredImportSelector` (https://github.com/spring-projects/spring-boot/pull/19400), I found an issue for handling `DeferredImportSelector.Group` with `@Order` on `DeferredImportSelector`.  Here is an example to describe the issue:  Let's say I have 3 `DeferredImportSelectors` with ordering specified 10, 20, 30. The one with order 10 and 30 returns same import-selector-group(`GroupA`), and the one with order 20 returns different import-selector-group(`GroupB`).   ```java @Order(10) static class DeferredImportSelectorA implements DeferredImportSelector {   @Override   public String[] selectImports(AnnotationMetadata importingClassMetadata) {     return new String[]{MyConfigA.class.getName()};   }    @Override   public Class getImportGroup() {     return GroupA.class;   } }  @Order(20) static class DeferredImportSelectorB implements DeferredImportSelector {   @Override   public String[] selectImports(AnnotationMetadata importingClassMetadata) {     return new String[]{MyConfigB.class.getName()};   }    @Override   public Class getImportGroup() {     return GroupB.class;   } }  @Order(30) static class DeferredImportSelectorC implements DeferredImportSelector {   @Override   public String[] selectImports(AnnotationMetadata importingClassMetadata) {     return new String[]{MyConfigC.class.getName()};   }    @Override   public Class getImportGroup() {     return GroupA.class;  // <== same group with selector-A   } } ```  It might be arguable to use same import-selector-group in differently ordered deferred import selector, but it is possible to write that way currently.   ```java @Configuration(proxyBeanMethods = false) @Import({DeferredImportSelectorA.class, DeferredImportSelectorB.class, DeferredImportSelectorC.class}) static class ImportConfig { } ```  When `ConfigurationClassParser` parses this `ImportConfig`, I think expected order of returned `ConfigurationClass` are ordered by `@Order`: - `ImportConfig` - `MyConfigA` (from import-selector-A with order-10) - `MyConfigB` (from import-selector-B with order-20) - `MyConfigC` (from import-selector-C with order-30)  However, currently it returns this order: - `ImportConfig` - `MyConfigA` (from import-selector-A with order-10) - `MyConfigC` (from import-selector-C with order-30)  <=== - `MyConfigB` (from import-selector-B with order-20)   This is because, when deferred-import-selectors are [sorted](https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L769), it orders selectors to `selector-A`, `selector-B`, `selector-C` based on the `@Order` which is correct. However, when `Group` is processed, since `selector-A` and `selector-C` uses same `GroupA`, when `selector-A`'s group is processed, it also processes `selector-C`'s imports as well. ([here](https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L791-L793) uses group as key)  This would be a problem, for example, selector-B is spring-boot's auto-configuration and selector-A and selector-C are to be applied before/after auto-configurations.   To fix this issue, in my patch, I have added `DeferredImportSelectorGroupingKey` for the `LinkedHashMap` that handles `groupings`. The key object also takes into account the order specified on import-selector. This way, even same import-selector-group is specified in import-selector with different order, they are considered to be in different group and the one has higher order priority is processed first. Of course, same order with same group will be treated in same category.","open","in: core,","ttddyy","2019-12-19T22:30:51Z","2021-11-11T09:26:56Z"
"","24082","Memory Leaks in WebClient Get Request with Body","Hi,  When I try to make a get request with body using webclient, it creates memory leaks in direct memory. And 10-12 hours of running the service we see following exception -    ``` Direct buffer memory 	at java.base/java.nio.Bits.reserveMemory(Unknown Source) 	at java.base/java.nio.DirectByteBuffer.(Unknown Source) 	at java.base/java.nio.ByteBuffer.allocateDirect(Unknown Source) 	at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:768) 	at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:744) 	at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:245) 	at io.netty.buffer.PoolArena.allocate(PoolArena.java:215) 	at io.netty.buffer.PoolArena.allocate(PoolArena.java:147) 	at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:327) 	at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187) 	at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:173) 	at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:107) 	at org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:65) 	at org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:39) 	at org.springframework.http.codec.json.AbstractJackson2Encoder.encodeValue(AbstractJackson2Encoder.java:168) 	at org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$0(AbstractJackson2Encoder.java:122) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107) 	at reactor.core.publisher.FluxHide$SuppressFuseableSubscriber.onNext(FluxHide.java:127) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070) 	at reactor.core.publisher.FluxHide$SuppressFuseableSubscriber.request(FluxHide.java:142) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.request(ScopePassingSpanSubscriber.java:79) 	at reactor.core.publisher.FluxHide$SuppressFuseableSubscriber.request(FluxHide.java:142) 	at reactor.core.publisher.MonoSingle$SingleSubscriber.request(MonoSingle.java:94) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.request(ScopePassingSpanSubscriber.java:79) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1878) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1752) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onSubscribe(ScopePassingSpanSubscriber.java:71) ```  Code for the get with body is as follows-   ``` public Mono> getReviewsByPostData(SearchCriteria searchCriteria, Mono propertyReviewsRequestBody) {         CircuitBreaker reviewCircuitBreaker = circuitBreakerRegistry.circuitBreaker(""property-reviews-webclient"");         return this.webClient                 .method(HttpMethod.GET)                 .uri(url -> UrlProviderUtil.getUrlForReviews(url, searchCriteria))                 .contentType(MediaType.APPLICATION_JSON_UTF8)                 .header(HttpHeadersEnum.REQUEST_ID.getHeader(), MDC.get(MdcKeysEnum.REQUEST_ID.getMdcKey()))                 .header(HttpHeadersEnum.SESSION_ID.getHeader(), MDC.get(MdcKeysEnum.SESSION_ID.getMdcKey()))                 .header(HttpHeadersEnum.DEBUG_HEADER.getHeader(), DEBUG.equalsIgnoreCase(MDC.get(MdcKeysEnum.DEBUG_REQUEST.getMdcKey())) ? DEBUG : """")                 .body(propertyReviewsRequestBody, PropertyReviewsRequestBody.class)                 .retrieve()                 .bodyToFlux(ReviewDetailsV1.class)                 .transform(CircuitBreakerOperator.of(reviewCircuitBreaker))                 .collectList()                 .doOnSuccess(res -> longOnReviewsDataSuccess(searchCriteria, res))                 .onErrorResume(ex -> reviewsFallback(searchCriteria, propertyReviewsRequestBody, ex));     } ```  However if I comment the line `.body(propertyReviewsRequestBody, PropertyReviewsRequestBody.class)` it works fine.   Attached graphs for direct memory allocated.    Is it a known issue?  Spring Boot Dependency used -  ```          org.springframework.boot         spring-boot-starter-webflux         2.1.6.RELEASE        ```","closed","status: duplicate,","codeomnitrix","2019-11-26T11:11:48Z","2019-11-28T06:39:25Z"
"","24460","Polish documentation format","Hi,  this PR fixes #24458 and #24459 in one go. That's hopefully okay.  Cheers, Christoph","closed","type: documentation,","dreis2211","2020-01-30T13:19:35Z","2020-01-31T07:59:25Z"
"","24617","Avoid unnecessary sorting overhead","Hi,  this PR avoids some unnecessary sorting overhead (e.g. if the collection is too small) for methods that are repeatably called and where collection sizes of <= 1 are fairly common (e.g. for the `ProducesRequestCondition`).  Cheers, Christoph","closed","in: core,","dreis2211","2020-02-29T14:32:03Z","2020-03-04T19:29:40Z"
"","24402","Protobuf messages error decoding with Flux","Hi,  Starting from this project : https://spring.io/blog/2015/03/22/using-google-protocol-buffers-with-spring-mvc-based-rest-services I tried to get a working controller with Weblux / Protobuf support. This is the code after modification  ``` package com.keeneye.io.server;  import java.util.Arrays; import java.util.Collection; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import java.util.stream.Collectors;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import demo.CustomerProtos; import reactor.core.publisher.Flux;  @SpringBootApplication public class ServerApplication {  	public static void main(String[] args) { 		SpringApplication.run(ServerApplication.class, args); 	}  	@Bean 	ProtobufHttpMessageConverter protobufHttpMessageConverter() { 		return new ProtobufHttpMessageConverter(); 	}  	private CustomerProtos.Customer customer(int id, String f, String l, Collection emails) { 		Collection emailAddresses = emails.stream() 				.map(e -> CustomerProtos.Customer.EmailAddress.newBuilder() 						.setType(CustomerProtos.Customer.EmailType.PROFESSIONAL).setEmail(e).build()) 				.collect(Collectors.toList());  		return CustomerProtos.Customer.newBuilder().setFirstName(f).setLastName(l).setId(id).addAllEmail(emailAddresses) 				.build(); 	}  	@Bean 	CustomerRepository customerRepository() { 		Map customers = new ConcurrentHashMap<>(); 		// populate with some dummy data 		Arrays.asList(customer(1, ""Chris"", ""Richardson"", Arrays.asList(""crichardson@email.com"")), 				customer(2, ""Josh"", ""Long"", Arrays.asList(""jlong@email.com"")), 				customer(3, ""Matt"", ""Stine"", Arrays.asList(""mstine@email.com"")), 				customer(4, ""Russ"", ""Miles"", Arrays.asList(""rmiles@email.com""))) 				.forEach(c -> customers.put(c.getId(), c));  		// our lambda just gets forwarded to Map#get(Integer) 		return id -> { 			return Flux.just(customers.get((id)));  		}; 	}  }  interface CustomerRepository { 	Flux findById(int id); }  @RestController class CustomerRestController {  	@Autowired 	private CustomerRepository customerRepository;  	@RequestMapping(""/customers/{id}"") 	Flux customer(@PathVariable Integer id) { 		return this.customerRepository.findById(id); 	}  } ```  If you run this code, after having generated the protobuf classes, you'll get an error with  ``` cat customer.msg | protoc --encode demo.Customer customer.proto | curl -sS -X POST  -H ""Content-Type: application/x-protobuf"" --data-binary @- http://localhost:8080/customers/1  protoc --decode demo.Customer customer.proto ```  But if you switch Flux to Mono in the Java code, the decoding passes. More surprisingly, if you skip the first byte of the response with Flux, the decoding passes also.  ``` cat customer.msg | protoc --encode demo.Customer customer.proto | curl -sS -X POST  -H ""Content-Type: application/x-protobuf"" --data-binary @- http://localhost:8080/customers/1 | tail -c +2 | protoc --decode demo.Customer customer.proto ``` Is it mandatory to use Mono instead of Flux to make it work ? Why would Flux work with just a few bytes skipped ? It seems there's an issue somewhere.","closed","status: invalid,","imatmati","2020-01-20T11:09:56Z","2020-01-23T10:11:07Z"
"","24056","Jackson2TokenizerTest is missing a call to verify","Hi,  I was trying to fix two places in the code that use an ""unfinished"" `StepVerifier` when I noticed an issue in the Jackson2Tokenizer handling. By applying the following patch, the test `Jackson2TokenizerTests#testLimit` starts to fail as the desired `DataBufferLimitException` is not thrown: ```patch --- a/spring-web/src/test/java/org/springframework/http/codec/json/Jackson2TokenizerTests.java +++ b/spring-web/src/test/java/org/springframework/http/codec/json/Jackson2TokenizerTests.java @@ -19,6 +19,7 @@ package org.springframework.http.codec.json;  import java.io.IOException;  import java.io.UncheckedIOException;  import java.nio.charset.StandardCharsets; +import java.time.Duration;  import java.util.List;   import com.fasterxml.jackson.core.JsonFactory; @@ -211,7 +212,7 @@ public class Jackson2TokenizerTests extends AbstractLeakCheckingTests {                                 .verifyComplete();                  StepVerifier.create(decode(source, false, maxInMemorySize - 1)) -                               .expectError(DataBufferLimitException.class); +                               .expectError(DataBufferLimitException.class).verify(Duration.ofSeconds(5));         } ```  I've done a lot of back and forth on this and tried the following patch for Jackson2Tokenizer that seems to let the tests pass again: ```patch --- a/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java +++ b/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java @@ -186,7 +186,7 @@ final class Jackson2Tokenizer {          private void assertInMemorySize(int currentBufferSize, List result) {                 if (this.maxInMemorySize >= 0) { -                       if (!result.isEmpty()) { +                       if (this.tokenizeArrayElements && !result.isEmpty()) {                                 this.byteCount = 0;                         }                         else if (currentBufferSize > Integer.MAX_VALUE - this.byteCount) { ``` I'm not entirely confident that's the correct fix as I miss the domain knowledge if I'm totally honest.  While taking a deeper look though I noticed that Jackson2Tokenizer is always invoked with the `tokenizeArrayElements` switched turned on (apart from the tests obviously). So my preferred option would be to remove that field and its related logic entirely and therefore simplifying the class. Given that it's a package internal class, that shouldn't be a big problem.  In general, I would create two separate PRs:  - Remove `tokenizeArrayElements` from `Jackson2Tokenizer` - Fix StepVerifier usage in `EncoderHttpMessageWriterTests#emptyBodyWritten` (that's the other broken StepVerifier usage)  I wanted to sync with you upfront before I create PRs that maybe don't make sense, so let me know what you think.  Cheers, Christoph","closed","type: task,","dreis2211","2019-11-21T21:23:02Z","2019-11-22T19:44:37Z"
"","24674","Improve performance of StringUtils#cleanPath","Hi,  I noticed an optimization opportunity in `StringUtils#cleanPath` while profiling one of our apps. I noticed that a lot of times, strings like `file:/Users/christoph.dreis/project/xyz/build/resources/main/META-INF/spring.factories` or similar absolute file paths are passed. E.g. in `ClassPathResource` (which is called 100.000 times in the mentioned app). For those strings we can shortcut a bit earlier and save the overhead from `collectionToDelimitedString`.  ``` Benchmark                                          Mode  Cnt     Score     Error   Units MyBenchmark.testNew                               thrpt   10  2188,511 ±  64,208  ops/ms MyBenchmark.testNew:·gc.alloc.rate                thrpt   10  2561,819 ±  75,078  MB/sec MyBenchmark.testNew:·gc.alloc.rate.norm           thrpt   10  1536,000 ±   0,001    B/op MyBenchmark.testNew:·gc.churn.G1_Eden_Space       thrpt   10  2558,410 ± 141,016  MB/sec MyBenchmark.testNew:·gc.churn.G1_Eden_Space.norm  thrpt   10  1533,735 ±  57,896    B/op MyBenchmark.testNew:·gc.churn.G1_Old_Gen          thrpt   10     0,002 ±   0,001  MB/sec MyBenchmark.testNew:·gc.churn.G1_Old_Gen.norm     thrpt   10     0,001 ±   0,001    B/op MyBenchmark.testNew:·gc.count                     thrpt   10   145,000            counts MyBenchmark.testNew:·gc.time                      thrpt   10    84,000                ms MyBenchmark.testOld                               thrpt   10  1345,572 ±  52,746  ops/ms MyBenchmark.testOld:·gc.alloc.rate                thrpt   10  2264,133 ±  88,387  MB/sec MyBenchmark.testOld:·gc.alloc.rate.norm           thrpt   10  2208,000 ±   0,001    B/op MyBenchmark.testOld:·gc.churn.G1_Eden_Space       thrpt   10  2263,917 ± 116,378  MB/sec MyBenchmark.testOld:·gc.churn.G1_Eden_Space.norm  thrpt   10  2208,212 ± 102,736    B/op MyBenchmark.testOld:·gc.churn.G1_Old_Gen          thrpt   10     0,003 ±   0,005  MB/sec MyBenchmark.testOld:·gc.churn.G1_Old_Gen.norm     thrpt   10     0,003 ±   0,005    B/op MyBenchmark.testOld:·gc.count                     thrpt   10   158,000            counts MyBenchmark.testOld:·gc.time                      thrpt   10    85,000                ms ```  Let me know what you think. Cheers, Christoph","closed","type: enhancement,","dreis2211","2020-03-10T20:05:56Z","2020-03-23T22:25:16Z"
"","24618","Add missing field to MethodParameter copy constructor","Hi,  I just noticed that the `MethodParameter` copy constructor misses to copy its `nestedMethodParameter` field.  Cheers, Christoph","open","in: core,","dreis2211","2020-02-29T16:48:01Z","2021-11-10T12:35:33Z"
"","23897","Fix Mockito deprecations","Hi,  I just noticed a couple of migration warnings coming from `Mockito.verifyZeroInteractions` that should be replaced by `Mockito.verifyNoInteractions`.  Cheers, Christoph","closed","type: task,","dreis2211","2019-10-30T17:15:08Z","2019-10-30T17:30:07Z"
"","24022","Protobuf MessageConverter in spring-messaging for use with STOMP","Hi,  I have created a ReactorNettyTcpStompClient to connect to RabbitMQ STOMP.  My requirement is to send **protobuf ByteString** to the destination queue. I tried with all the message converters that are available under _org.springframework.messaging.converter_ package. Either i get `MessageDeliveryException: nested exception is java.lang.ClassCastException` or `MessageConversionException: Unable to convert payload with.... `  I am thinking of overriding/overloading the send() method of `DefaultStompSession `class and use it.  Is there any other easier way?  How to use protocol buffers with Spring Messaging?  Thanks, Strive","closed","status: superseded,","onlybytes","2019-11-19T09:58:35Z","2020-09-17T08:54:18Z"
"","24415","x-death header missing in STOMP response","Hi,  I am using `ReactorNettyTcpStompClient` to connect to RabbitMQ `STOMP`. During frame handling, i am NACKing messages and are routed to dead letter exchange.  While examining the messages from DLX, i noticed that `x-death` header is missing. The following headers are available: `x-first-death-exchange` `x-first-death-queue` `x-first-death-reason`  `x-death` header contains useful information but unfortunately that is not available in STOMP headers.  Looks like a bug to me. Please let me know a way to get the `x-death` header while processing the messages from DLX  Thanks, Strive","closed","for: external-project,","onlybytes","2020-01-22T14:10:53Z","2020-02-06T09:35:10Z"
"","24681","Improve performance of AbstractAutowireCapableBeanFactory#predictBeanType","Hi,  I am currently trying to improve startup time of a medium sized Spring-Boot app that currently takes around 20 seconds to start. While profiling I noticed that the top hotspot is `AbstractAutowireCapableBeanFactory#predictBeanType` as shown in the screenshot below:  ![image](https://user-images.githubusercontent.com/6304496/76451369-98228280-63cf-11ea-943a-a7bb714243b8.png)  Additionally you can see`Iterator.hasNext()/next()` which are also in the top of the list. I found out that a reasonable time is spent iterating over `BeanPostProcessors` (23 in my case) for every bean, although most of the post-processors are not a `SmartInstantiationAwareBeanPostProcessor` at all (only 3 in my case), which are the only post-processors of interest for predicting bean types. Even worse, almost all standard smart post-processors are anyway returning null.  The idea of this PR is to hold an additional list of smart post-processors that can be used to minimize the iteration overhead in cases where only `SmartInstantiationAwareBeanPostProcessor` instances are of interest. Applying this patch shows the following results in the profiling and saves around 1-2 seconds for me:  ![image](https://user-images.githubusercontent.com/6304496/76452280-28ad9280-63d1-11ea-8ad7-c53f91eada94.png)  Let me know what you think. Cheers, Christoph","closed","type: enhancement,","dreis2211","2020-03-11T18:48:29Z","2020-05-13T13:54:22Z"
"","24062","Add missing verify() in EncoderHttpMessageWriterTests","Hi,  as noted in #24056 there is another missing verification in `EncoderHttpMessageWriterTests`.  Cheers, Christoph","closed","type: task,","dreis2211","2019-11-22T19:04:36Z","2019-11-25T11:48:58Z"
"","24407","top-level domain","Hi! I use spring boot 2.2.2.RELEASE and spring webflux. When I send POST Http request to my app by host name http://mobile-backend:8080/api/cat name, I saw what app got GET request to /app path When I send request by ip address or without ""-"" in name it works fine.  How can I fix it? Thank you","closed","for: stackoverflow,","Iamdreamlover","2020-01-21T09:21:38Z","2020-01-21T19:24:01Z"
"","24053","How to register/activate MappingJackson2HttpMessageConverter using Bean Definition DSL?","Hi!  I am using spring-webmvc + jackson databind + kotlin  I need to configure/activate **MappingJackson2HttpMessageConverter** for the media type ""application/*+json""  in **GenericWebApplicationContext**  using  **Bean Definition DSL**.    Unfortunately, I did't find any documentation for this.  Currently, I have found the following solution:  ``` bean {     RouterFunctionMapping().apply {         setMessageConverters(listOf(             MappingJackson2HttpMessageConverter(ref()),             StringHttpMessageConverter()         ))         order = 1    } } ```  Is this correct or not?  Thanks for attention :)","closed","for: stackoverflow,","ghost","2019-11-21T15:40:52Z","2019-11-25T16:43:33Z"
"","24443","Add Informix to supported database products for procedure calls","Hi everyone,  We're facing an issue in our application when we try to call a procedure in Informix database,  our app uses standard JDBC (spring-jdbc and com.ibm.informix.jdbc.4.50.3) without Hibernate  to connect to the database    Issue: When we trying to execute any procedure call in our Informix database there is no data returned.  Diagnostic: It points to the Java class called CallMetaDataProviderFactory in spring-jdbc project.  Taking a look of this class there is no explicit support for Informix procedure calls, so I added ""Informix Dynamic Server"" to the  list of supported databases and now I can execute procedures call without issues.  Basically I added the line ""Informix Dynamic Server"" to the list called ""supportedDatabaseProductsForProcedures""  of CallMetaDataProviderFactory class in my local environment and it worked as expected.   I really appreciate any feedback/suggestion for this approach due we would like to continue using the framework  normally in our development without losing updates using a workaround in our end.  Many thanks in advance.","closed","type: enhancement,","wilrosco","2020-01-28T00:12:38Z","2020-01-29T17:01:23Z"
"","23828","AbstractSockJsSession exception when handling message with closed session","Hi All  We are frequently finding this exception in our logs:  ``` org.springframework.web.socket.sockjs.SockJsMessageDeliveryException:    Failed to deliver message(s) [] for session nl2a0rcr; nested exception is org.springframework.web.socket.sockjs.SockJsMessageDeliveryException:    Failed to deliver message(s) [] for session nl2a0rcr: Session closed at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.delegateMessages(AbstractSockJsSession.java:391) ```  Basically it seems that [AbstractSockJsSession](https://github.com/spring-projects/spring-framework/blob/master/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractSockJsSession.java) is trying to deliver an **empty** message but it raises a `SockJsMessageDeliveryException` because the session is already closed.  ``` 	public void delegateMessages(String... messages) throws SockJsMessageDeliveryException { 		List undelivered = new ArrayList<>(Arrays.asList(messages)); 		for (String message : messages) { 			try { 				if (isClosed()) { 					throw new SockJsMessageDeliveryException(this.id, undelivered, ""Session closed""); 				} 				else { 					this.handler.handleMessage(this, new TextMessage(message)); 					undelivered.remove(0); 				} ```  Ignoring the fact that it's trying to deliver an empty message, should it avoid throwing an exception when effectively there is nothing to be delivered? If not, how would one handle such exception?  Thanks!","closed","type: enhancement,","marco-primiceri","2019-10-17T13:58:49Z","2020-03-13T15:24:07Z"
"","23826","use spring around advice for spring reactive application","Hi @jhoeller  I want to use around advice to Spring boot reactive application to check the time taken by a particular method.  Could you please help me on this?  Thanks, Deepak","closed","status: invalid,","saxenadeepakkumar","2019-10-17T09:18:21Z","2019-10-18T09:47:47Z"
"","24582","Multipart/related support in Spring Webclient","Hi  Is `multipart/related` supported in spring webclient? I am trying to create `multipart/related` mime request using webclient, but i dont see a corresponding `MediaType` listed for it, although i know it is possible with RestTemplate as per #23159  I have tried to make it work but i suppose i dont have then required [Convertor](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/FormHttpMessageConverter.html#addPartConverter-org.springframework.http.converter.HttpMessageConverter-) in the chain, hence not able to correctly parse the individual parts.  This issue is more to get a traction on the SO [question](https://stackoverflow.com/questions/60359649/support-for-multipart-related-mime-type-in-spring-webclient) is posted.   P.S. Pardon me for ignoring the guidelines and creating the issue here. Please delete/remove this if required.  Thanks, Nitesh","closed","type: enhancement,","niteshsinha","2020-02-24T16:38:25Z","2020-03-04T19:08:07Z"
"","24569","Is there a way to cache http response on redis with WebClient","Hi  I decided to migrate existing Spring Boot projects to webflux. The Spring Boot version I update to is 2.2.4.RELEASE.  I have many microservices. I was caching http responses using in memory cache, and redis cache. I found a workaround to cache incoming responses in the current state. However, I need to use redis cache in some projects. Up to now, I couldn't find any way to do this.  Is there anyone who use redis cache with webflux? Or do you have any recommendation to do this?   In addition, will there be support for using `@Cacheable` annotation with webflux. If not, I would ask you to take it into planning.","closed","for: stackoverflow,","taylancapraz","2020-02-22T18:50:59Z","2020-07-08T07:58:53Z"
"","24488","Can't escape } in 'short' property declaration","Hey,  I think I found a bug while trying to figure out how to escape } in property declarations like  `property: ${ENV_VAR:textWith}inIt}`  I ended up with something like that:  `property: ${ENV_VAR:#{'textWith}inIt'}}`  which worked fine when ENV_VAR wasn't set - but with ENV_VAR + ""}"" in the property if it's set.  Don't hestitate to ask if you need additional information.  Cheers Marko","open","in: core,","ElectroLutz","2020-02-06T17:04:10Z","2021-11-12T13:34:37Z"
"","23898","Cannot inject generic FactoryBean","Here is an example test case: ``` import org.junit.Test; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.core.ResolvableType;  import static org.junit.Assert.assertTrue;  public class FactoryTests {      @Test     public void testAutowire() {         AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(                 TestConfig.class);         ClassWithGenericBar classWithGenericBar = context.getBean(ClassWithGenericBar.class);         assertTrue(classWithGenericBar.stringGenericBar.type.equals(String.class));     }      @Test     public void testGetByType() {         AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(                 TestConfig.class);         String[] names = context.getBeanNamesForType(ResolvableType.forClassWithGenerics(GenericBar.class, String.class));         assertTrue(names.length > 0);     }      static class TestConfig {          @Bean         GenericBarFactory stringGenericBarFactory() {             return new GenericBarFactory<>(String.class);         }          @Bean         GenericBarFactory integerGenericBarFactory() {             return new GenericBarFactory<>(Integer.class);         }          @Bean         ClassWithGenericBar classWithGenericBar() {             return new ClassWithGenericBar();         }     }      public static class GenericBar {         Class type;          public GenericBar(Class type) {             this.type = type;         }     }      public static class GenericBarFactory implements FactoryBean> {          private Class type;          public GenericBarFactory(Class type) {             this.type = type;         }          @Override         public GenericBar getObject() {             return new GenericBar<>(type);         }          @Override         public Class getObjectType() {             return type;         }     }      public static class ClassWithGenericBar {         @Autowired         GenericBar stringGenericBar;          @Autowired         GenericBar integerGenericBar;     }  } ```  And I got exception: ``` Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.springframework.guice.FactoryTests$GenericBar' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1695) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1253) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:636) 	... 36 more ```  Is this an expected behavior or a bug?","open","in: core,","kzwang","2019-10-30T20:46:56Z","2021-11-10T11:58:04Z"
"","24796","Remove incorrect @Nullable in DynamicPropertiesContextCustomizer","Hello~ This PR contains the following points： * Remove incorrect `@Nullable` annotation in buildDynamicPropertiesMap, this method may return empty map, but not null. * If the `methods ` parameter of Constructor of `DynamicPropertiesContextCustomizer` is null, it will produce NPE, and if the parameter is a empty set, it doesn't seem to make much sense, considering that this class is visible by the package, so I suggest adding a empty check in this Constructor.","closed","type: task,","chenqimiao","2020-03-27T04:01:03Z","2020-03-28T15:01:03Z"
"","24548","on JDK 11 - WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils$1","Hello. Issue #22674 was closed, but it still exists.  @jhoeller has mentioned, that it's fixed, but it obviously not.","closed","status: duplicate,","Felixoid","2020-02-18T10:23:09Z","2020-12-10T21:29:25Z"
"","23879","Race condition affecting performance in AbstractJaxb2HttpMessageConverter - JAXBContext creation","Hello. I saw this issue recently and wanted to share it with you in hopes that you can tweak things to prevent others from suffering through the troubleshooting that we just did.  Here'a [a LINK|https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/xml/AbstractJaxb2HttpMessageConverter.java] to the source code in question.  When the code linked above's ""getJaxbContext"" method is called concurrently with a Jaxb type that's not already initialized in its ""jaxbContexts"" map we've experienced that many threads spend a lot of time on line 113's JAXBContext.newInstance() call. It appears that many threads are executing the ""JAXBContext jaxbContext = this.jaxbContexts.get(clazz);"" line (line 110) before any thread has been able to get to the ""jaxbContexts.putIfAbsent"" step.  I've attached a screenshot of a JProfiler performance profile demonstrating that the time is spent in this code. I used sampling mode instead of dynamic to minimize profiling overhead.  I think this issue can be addressed by replacing several lines of code with a single line of code that leverages ConcurrentMap's computeIfAbsent method. That method works to fetch the value from the map and on a ""miss"" creates the needed object, puts it in the map, and returns it.  Priority-wide this is something that may not affect a lot of users. It did take us a while to figure out why our performance was terrible and while the workaround of ""priming the pump"" once before going concurrent does work it looks like this is best addressed in this code as doing so will simplify the code and prevent others from suffering from this ""happens once for each JVM startup, then goes away"" performance degradation.  Affected versions:  We're using ""spring-web-5.1.1.RELEASE"". I suspect that this is probably present in all reasonably-current versions.","closed","type: enhancement,","gjd6640","2019-10-28T14:38:48Z","2019-10-30T13:33:07Z"
"","24810","When using ""UriComponentsBuilder"", there is a bug, is it a known issue?","Hello.  When using UriComponentsBuilder, an exception occurs in the following code: -  jdoodle link : https://jdoodle.com/a/1XG2 - code ```java import org.springframework.web.util.UriComponentsBuilder;  public class Test { 	public static void main(String[] args) {   		try { 			String uri = ""http://test.com?param1={aaa}¶m2={bbb}¶m3={ccc}""; 			UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromUriString(uri);  			String param1 = ""1""; 			String param2 = ""2""; 			String param3 = ""{3}"";  			String uriString = uriComponentsBuilder.buildAndExpand(param1, param2, param3).toUriString(); 			System.out.println(""test1 : "" + uriString); 			 		} catch (Exception e) { 			e.printStackTrace(); 		}  		try { 			String uri = ""http://test.com?param1={aaa}¶m2={bbb}¶m3={ccc}""; 			UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromUriString(uri);  			String param1 = ""1""; 			String param2 = ""2""; 			String param3 = ""{3}"";  			UriComponentsBuilder uriComponentsBuilder1 = uriComponentsBuilder.queryParam(""param1"", param1); 			String uriString = uriComponentsBuilder1.buildAndExpand(param2, param3).toUriString(); 			System.out.println(""test2 : "" + uriString); 			 		} catch (Exception e) { 			e.printStackTrace(); 		}  	} }  ```  - output ``` test1 : http://test.com?param1=1¶m2=2¶m3={3}  java.lang.IllegalArgumentException: Not enough variable values available to expand 'ccc' 	at org.springframework.web.util.UriComponents$VarArgsTemplateVariables.getValue(UriComponents.java:367) 	at org.springframework.web.util.HierarchicalUriComponents$QueryUriTemplateVariables.getValue(HierarchicalUriComponents.java:1053) 	at org.springframework.web.util.UriComponents.expandUriComponent(UriComponents.java:262) 	at org.springframework.web.util.HierarchicalUriComponents.lambda$expandQueryParams$5(HierarchicalUriComponents.java:445) 	at java.util.Map.forEach(Map.java:630) 	at org.springframework.web.util.HierarchicalUriComponents.expandQueryParams(HierarchicalUriComponents.java:441) 	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:430) 	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:51) 	at org.springframework.web.util.UriComponents.expand(UriComponents.java:172) 	at org.springframework.web.util.UriComponentsBuilder.buildAndExpand(UriComponentsBuilder.java:433) 	at Test.main(Test.java:31) ```  Is it wrong to use it? Or is it a known issue? If it's a bug, can I apply for a pullrequest for that content?","closed","for: stackoverflow,","taetaetae","2020-03-29T10:59:09Z","2020-03-29T17:14:50Z"
"","24173","implements `checkNotModified` for `ServerRequest`","Hello.  Can implements method the `checkNotModified`  in `org.springframework.web.servlet.function.ServerRequest`?  Thank you!","closed","type: enhancement,","kevin70","2019-12-10T06:26:50Z","2020-03-11T15:53:25Z"
"","23859","Provide transform from mono Context to coroutinesContext","Hello, we want to keep mono context in coroutine scope For example: we use webFilter and set something to Context(reactor.util.context) ``` ... filter(exchange: ServerWebExchange, chain: WebFilterChain): Mono {       context.put(ourCoroutineContext, ""test"") ... } ... ``` And when we use such methods in controller: ``` suspend fun test():Response {        val test = coroutineContext[ourCoroutineContext] } ``` test will be null. I think, it would be good to convert mono Context to coroutine Context, before invoke function. I see a part of code in InvocableHandlerMethod ``` ReflectionUtils.makeAccessible(getBridgedMethod()); 				Method method = getBridgedMethod(); 				if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(method.getDeclaringClass())) { 					value = CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args); 				} ``` It would be good to extend invokeSuspend fun to take a mono Context, which will be transformed. What do you think? Also I would like to submit a PR, but I can't find what CoroutineUtils is.","closed","status: superseded,","kostya05983","2019-10-24T10:36:20Z","2021-01-08T13:13:16Z"
"","24807","Use try-with-resource to close resources","Hello, this PR changes replace `try-finally` with `try-with-resource` to close resources.","closed","type: task,","chenqimiao","2020-03-29T04:55:59Z","2020-03-31T02:05:01Z"
"","24808","Replace anonymous inner classes with lambdas in tests","Hello, this PR changes replace `inner class` with `lambada` to make the code more concise.","closed","type: task,","chenqimiao","2020-03-29T06:06:06Z","2020-03-31T02:05:11Z"
"","24174","Expose local address in reactive ServerHttpRequest","Hello, is there any way how to obtain localAddr from incoming request? I mean if I have multiple virtual addresses/interfaces on host and I need to distinguish on which address was the request accepted.  Only way which I found now is little hack with netty's HttpServerRequest.  ``` if ((((AbstractServerHttpRequest) exchange.getRequest()).getNativeRequest()) instanceof HttpServerRequest) {     final InetSocketAddress localAddress = ((HttpServerRequest) (((AbstractServerHttpRequest) exchange.getRequest()).getNativeRequest())).hostAddress();     logger.debug(""!!! Hostname {}, HostString {}, Address {}"",             localAddress.getHostName(),             localAddress.getHostString(),             localAddress.getAddress()     ); } ```  Is there any general approach?  Thanks","closed","type: enhancement,","bilak","2019-12-10T07:31:59Z","2019-12-10T16:56:37Z"
"","24083","Possible connection leak in combination of webflux with spring-data-redis-reactive","Hello,  we're using redis pub-sub via spring-data-redis-reactive to stream events to client (webapp and mobile) using SSE (server sent events). In short each customer has own channel where events are streamed. Client opens a connection and listens for incoming events. Periodically connection is terminated by proxy and client reopens it. Typically there very few events are sent. With such behaviour we discovered that redis connections opened by client when events stream is created are not closed when event stream is cancelled (connection termination either by a client or proxy). We started getting very weird NPE-s caused by exceeding direct memory buffer limit (lettuce is using by default direct memory). After experimenting we came to conclusion that redis connections are not closed. Actually they are closed when after cancelling stream an event in sent to the channel (or two events if channel has received at least one event while being active).  We have prepared a simple project where this issue can be reproduced (see README for steps to reproduce): [https://gitlab.com/vadim-gerassimov/lettuce-sse](https://gitlab.com/vadim-gerassimov/lettuce-sse)  Current work around is periodically sending ping events to the active redis channels.   Regards, Vadim","closed","for: external-project,","vadger","2019-11-26T11:20:06Z","2019-11-27T15:01:26Z"
"","24040","WebTestClient send post request without body","Hello,  It seems org.springframework.test.web.reactive.server.WebTestClient never send my body in a post http request. I currently use springboot 2.2.0.RELEASE (Spring Test 5.2.0.RELEASE). I did the following :  ``` @Component class UserHandler(private val userRepo: UserRepository) {      suspend fun addUser(req: ServerRequest): ServerResponse = coroutineScope {         val log: Logger = LoggerFactory.getLogger(UserHandler::class.java)         log.info(""TEST TEST TEST: {}"", req.awaitBody()) // Here to log the body          val userCreated: Deferred = async { userRepo.save(req.awaitBody()) }         ServerResponse.ok().json().bodyValueAndAwait(userCreated.await())     }  } ```  ``` @Configuration class RouterConfig {      companion object {         const val USER_ID_PATH_PARAM = ""id""     }      @Bean     fun userRoutes(userHandler: UserHandler) = coRouter {         User.USER_API_ENDPOINT.and(accept(MediaType.APPLICATION_JSON)).nest {             POST(Strings.EMPTY, userHandler::addUser)         }     } } ```  ``` @WebFluxTest @ContextConfiguration(classes = [RouterConfig::class, UserHandler::class]) class UserHandlerTests(@Autowired private val webClient: WebTestClient) {      @MockBean     private lateinit var userRepository: UserRepository      @Test     fun addCorrectUser() {         val user1: User = User(1L, ""boby@bob.bb"")          webClient.post().uri(User.USER_API_ENDPOINT).bodyValue(user1).exchange()                 .expectBody().json(""{\""toto\"": \""toto\""}"") // What ever the result     } } ```  Then I can see in test logs, the body sent with the request :   ``` java.lang.AssertionError:  Expected: toto      but none found   > POST /user > WebTestClient-Request-Id: [5] > Content-Type: [application/json] > Content-Length: [47]  {""id"":1,""email"":""boby@bob.bb"",""birthDate"":null}  < 500 INTERNAL_SERVER_ERROR Internal Server Error < Content-Type: [application/json] < Content-Length: [17704] ```  But in my UserHandler logs it seems the body is empty : `2019-11-20 11:31:29.549  INFO 1660 --- [er @coroutine#9] c.l.o.cash.demo.user.UserHandler         : TEST TEST TEST: {}`  It works if I started my apps, this issue only occurs with WebTestClient. I suspect the log is wrong, I read the exchange method definition : ""Perform the exchange without a request body."" but I didn't find other method to do the job. It seems anyway the exchange method takes care about the body :  ``` public Mono exchange() { 			ClientRequest request = (this.inserter != null ? 					initRequestBuilder().body(this.inserter).build() : 					initRequestBuilder().build()); ... ```  Do you have any guess ? Thank you !","closed","","kizux","2019-11-20T11:12:03Z","2021-01-08T13:09:14Z"
"","23982","Technical Support Expiration Date","Hello,  I work for a long-term project which requires strong and stable technical support for every software used.  I want to know how long you are providing technical support for Spring Framework 4.3.24.  Please I appreciate so much that you can give me expiration dates for this software product or expectations of its EOL.  Thank you! Sergi","closed","status: invalid,","Sergindra","2019-11-12T16:06:58Z","2019-11-13T18:18:08Z"
"","24319","TransactionAspectSupport: order of commit/cleanup actions","Hello! I am migrating a project from Spring 3.x to Spring 4.3.25. The project I am working with has an expectation that the transaction cleanup phase happens after the transaction commit phase. It used to be like this when the transactional aspect was implemented using the before/after/after returning/after throwing pointcuts (AspectJ). However, it has changed and now it is impossible to execute before commit phase code that requires database connection (which is inside the transaction context).  As a workaround I have cloned the spring-aspects module and manually rewritten the transactional aspect, however that solution is not perfect.   Question: Why does the `TransactionAspectSupport#invokeWithinTransaction` method clean up the context before commit phase?  Can I create a pull request and move the commit phase inside the try section?  ```java if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) { 	// Standard transaction demarcation with getTransaction and commit/rollback calls. 	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); 	Object retVal = null; 	try { 		// This is an around advice: Invoke the next interceptor in the chain. 		// This will normally result in a target object being invoked. 		retVal = invocation.proceedWithInvocation(); 		// To here <--------------- 		commitTransactionAfterReturning(txInfo); 	} 	catch (Throwable ex) { 		// target invocation exception 		completeTransactionAfterThrowing(txInfo, ex); 		throw ex; 	} 	finally { 		cleanupTransactionInfo(txInfo); 	} 	// From here <----------- 	// commitTransactionAfterReturning(txInfo); 	return retVal; } ```","open","in: data,","ivan-fedorenkov","2020-01-08T19:05:28Z","2020-01-10T14:29:22Z"
"","23876","Generalize inter-thread context propagation","Hello!  While working on asynchronous retry support in **spring-retry**, we encountered a scenario, where some thread-fixed context should be propagated from a scheduler thread (that calls `executor.execute(...)`) to the worker thread (that actually executes the runnable).  We found the same pattern implemented in `org.springframework.security.concurrent` package of **spring-security** for `SecurityContext`: https://github.com/spring-projects/spring-security/tree/master/core/src/main/java/org/springframework/security/concurrent  The idea of the issue is to generalize this mechanics: extract common part to **spring-core** and use it for `SecurityContext` in **spring-security**, and for `RetryContext` in **spring-retry**.  Here is a prototype of an implementation: https://github.com/ashamukov/spring-security/pull/1 What do you think?  Thanks  cc: @rwinch","open","in: core,","ashamukov","2019-10-28T08:29:46Z","2021-11-10T12:04:52Z"
"","24127","Implementing interface in abstract class does not expose parameter annotations","Hello there!  The problem is with the Spring-boot-web.  Spring boot version '2.2.1.RELEASE'  The bug :   If you got interface, an abstract class and implement class, the `@RequestBody` annotation will not be taken to the implemented class.   Example:    ```java public interface TheControllerInterface {    @PostMapping(""/test"")    public String returnString(@RequestBody SomeKindOfObject object); } ```  ```java public abstract class AbstractController implements TheControllerInterface {    // It might be empty right now, but in overall I had the implementation of few methods here EXCLUDING the one in interface. } ```  ```java @RestController @RequestMapping(""/springTest"") public class Controller extends AbstractController {        @Override       public String returnString(SomeKindOfObject object) {          //implementation of method.      } } ```   After checking the url endpoint /springTest/test you will see that it does not have body.  Those informations will go to `@RequestParam` annotation instead of `@RequestBody` annotation.  The url will be inheritated. Just the `@RequestBody` annotation will not.  Best!  PS. It looks like somebody has RequestBody username in github, to using ""@"" with Annotation name will provide link to that username :(","closed","type: bug,","cogunites","2019-12-03T21:27:05Z","2020-03-23T17:03:29Z"
"","24583","Cannot resolve dependency when there are multiple DataSource defined","Hello Team,   Today I found a potentially interesting bug when I was working on a small application that uses DataSource beans. In my situation, I wanted to declare two DataSource beans and use one of them dynamically using AbstractRoutingDataSource, which is declared as `@Primary` bean. Surprisingly, I was not able to run my application because of cyclic dependency:   ```    org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration ┌─────┐ |  dataSource defined in  ↑     ↓ |  readOnlyDataSource defined in  ↑     ↓ |  org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker └─────┘ ``` It looks that both of those beans: DataSourceHealthContributorAutoConfiguration and DataSourceInitializerInvoker have a dependency on DataSource - it's not cyclic.   I've created a small app to allow you quickly reproduce this bug: https://github.com/kozub/spring-dependency-management-bug - in this case, there is a problem with resolving dependency for HibernateJpaConfiguration and DataSourceInitializerInvoker. It looks the same, so I believe that the difference in these two cases is a consequence of different jars on the classpath.   Please let me know if there are any additional details that I might provide to you.","closed","","kozub","2020-02-24T16:43:31Z","2022-02-18T19:06:46Z"
"","24417","Unsatisfied dependency expressed through constructor parameter 1: Ambiguous argument values for parameter of type [int] - did you specify the correct bean references as arguments?","Hello Team, I am using spring version 4.3.1 ,i am facing problem while using spring ,Kindly provide solution for the problem ```  org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.apache.http.HttpHost#1a451d4d' defined in class path resource [spring/context-dao.xml]: Unsatisfied dependency expressed through constructor parameter 1: Ambiguous argument values for parameter of type [int] - did you specify the correct bean references as arguments? 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:736) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:299) 	... 23 more Related cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.apache.http.HttpHost#1a451d4d' defined in class path resource [spring/context-dao.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [java.net.InetAddress] - did you specify the correct bean references as arguments? 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:736) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:299) ``` ================================================================ **my XML file is:-**	 ```xml  	 		 			 				 					 					 					 				 			 ```","closed","for: stackoverflow,","sunil-kumarBV","2020-01-23T06:28:33Z","2020-01-23T16:31:06Z"
"","23952","Why does AbstractHttpMessageConverter set charset?","Hello all,  I'm using spring-web 5.2.0.RELEASE and I have the following mockmvc test:  ```java         getMockMvc().perform(get(""/facade/creditAccount/creditAccountCodeForCurrentUser"").accept(MEDIA_TYPE).contentType(MEDIA_TYPE)                                                                                          .with(user(""test-get-credit-account-code-rest@nemesis.com"")                                                                                                                .password(""pass"").roles(""CUSTOMERGROUP"")))                     .andExpect(status().isOk()).andExpect(content().contentType(MEDIA_TYPE)).andExpect(content().string(notNullValue()))                     .andExpect(content().string(Matchers.equalToIgnoringCase(""get-code-rest-credit-account""))).andDo(print())                     .andDo(document(""facade/"" + CreditAccountFacade.NAME + ""/creditAccountCodeForCurrentUser"")); ```  which fails because:  ``` Content type expected: but was: ```  I see in the `AbstractHttpMessageConverter` the charset is added here:  https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/AbstractHttpMessageConverter.java#L249-L257  So I thought maybe I should use `MediaType.APPLICATION_JSON_UTF8_VALUE` but this one is deprecated with the following message:   ```java 	/** 	 * Public constant media type for {@code application/json;charset=UTF-8}. 	 * @deprecated Deprecated as of Spring Framework 5.2 in favor of {@link #APPLICATION_JSON} 	 * since major browsers like Chrome 	 *  	 * now comply with the specification and interpret correctly UTF-8 special 	 * characters without requiring a {@code charset=UTF-8} parameter. 	 */ 	@Deprecated 	public static final MediaType APPLICATION_JSON_UTF8; ``` Doesn't this mean that the `AbstractHttpMessageConverter` must not add the charset any more?!","closed","status: feedback-provided,","ptahchiev","2019-11-07T20:56:16Z","2019-11-08T12:37:07Z"
"","24141","Some beans are not woven anymore by AspectJ Load Time Weaving in Spring 5.2.1 Web Application","Having switched web application with XML spring configuration from Spring 5.1.11 to Spring 5.2.1 some beans are not woven with AspectJ Load Time Weaving anymore without providing additional javaagent.  ### Before: On Apache Tomcat 9.0.20 and Caucho Resin 4.0.62 + Spring 5.1.11 - both application servers worked perfectly without specifying javaagents. Beans defined in XML + autoscan detected ones were woven successfully.   ### After: * Problem 1: beans from autoscan (with and without interfaces) are not woven anymore. Classes are loaded too early - before classloader is ready to apply aspects. Default load time weaver is not applied at that moment.  * Problem 2: (behavior has not been changed but reasons are not clear) annotation configured beans without interfaces also cannot be woven. Classes are loaded too early, when no transformation can be done.  ### Reproduce the problem Application which demonstrates the problem can be found here (with detailed description and results): [Minimal Application to Reproduce the Problem](https://github.com/densp/aspectj-in-spring521)","open","in: core,","densp","2019-12-05T12:05:02Z","2021-11-10T09:51:27Z"
"","24215","Upgrade to Groovy 3.0","Groovy 3.0 is currently in RC3 and certainly going GA in our 5.3 timeframe. While it seems to be compatible for our purposes and therefore a seamless upgrade from Groovy 2.5 for Spring users, let's see whether there are specific things we can do towards making Groovy 3 a first-class citizen.","closed","type: dependency-upgrade,","jhoeller","2019-12-15T22:40:02Z","2020-04-28T12:00:59Z"
"","24719","Upgrade to Groovy 2.5.10 (for JDK 14 compatibility)","Groovy 2.5.10 comes with basic JDK 14 support now, and it looks like we can use it as the sole version in our build: i.e. there is no need to differentiate between `customJavaHome` and regular execution with conditional use of Groovy 3.0.x anymore.  We'll upgrade to Groovy 3.0 proper for the Spring Framework 5.3 line.","closed","type: dependency-upgrade,","jhoeller","2020-03-18T11:11:48Z","2020-03-18T11:33:10Z"
"","24769","Improve MediaType parsing performance","Given the latest issues reported against `MediaType` / `MimeTypeUtils` and the internal LRU cache implementation (see #24767), we should benchmark `MediaType.parseMediaType` and `MimeTypeUtils.parseMimeType` to find performance opporuntinies.","closed","type: enhancement,","bclozel","2020-03-24T10:32:07Z","2020-05-13T19:42:40Z"
"","24732","Improper @AliasFor configuration now results in an exception","Given the following composed `@ContentRespBody` annotation:  ```java @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @ResponseBody public @interface ContentRespBody {     @AliasFor(annotation = ResponseBody.class)     Class value() default ContentResultForm.class; } ```  Regarding the meta-annotation `@ResponseBody`, version 5.0.7 will not report an error, but when upgrading to version 5.2.4, it will report an error.  Is this a bug or an expected result?  > Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'value' in annotation [com.augurit.agcloud.meta.util.annotations.ContentRespBody] is declared as an @AliasFor nonexistent attribute 'value' in annotation [org.springframework.web.bind.annotation.ResponseBody]. 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:160) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:131) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:123) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:100) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:116) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:68) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:251) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_102] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:247) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:204) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:186) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:173) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.TypeMappedAnnotation.of(TypeMappedAnnotation.java:634) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.annotation.MergedAnnotation.of(MergedAnnotation.java:596) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.type.classreading.MergedAnnotationReadingVisitor.visitEnd(MergedAnnotationReadingVisitor.java:96) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.asm.ClassReader.readElementValues(ClassReader.java:2985) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.asm.ClassReader.readMethod(ClassReader.java:1393) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.asm.ClassReader.accept(ClassReader.java:718) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.asm.ClassReader.accept(ClassReader.java:401) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:50) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:123) ~[spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.__scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:430) ~[spring-context-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	... 23 common frames omitted","closed","in: core,","929404097","2020-03-19T01:54:30Z","2022-03-21T15:59:34Z"
"","23922","Correct Javadoc for WebMvcConfigurer#addInterceptors","gh-20583 updated resourceHandlerMapping to use shared interceptors. addInterceptors in WebMvcConfigurer now adds interceptors for static resources as well. Closes gh-23908","closed","in: web,","samarthrastogi","2019-11-04T12:28:54Z","2019-11-19T10:16:35Z"
"","24702","Suppress deprecation warning in AnnotationMetadata#from","From the Javadoc of `StandardAnnotationMetadata `'s constructor,  the reason `StandardAnnotationMetadata` is marked as `@Deprecated` is `since 5.2 in favor of the factory method {@link AnnotationMetadata # introspect (Class)}`. However,`AnnotationMetadata.introspect` is delegated to` StandardAnnotationMetadata.from`, consider suppressing deprecation warnings of `AnnotationMetadata.from`.","closed","status: feedback-provided,","chenqimiao","2020-03-15T13:50:14Z","2022-02-18T19:06:47Z"
"","24686","Fix exception message in getMergedBeanDefinition","From the context, it feels like it should be `ConfigurableBeanFactory`, not `AbstractBeanFactory`.","closed","in: core,","chenqimiao","2020-03-13T01:13:15Z","2020-03-13T10:01:53Z"
"","24332","Polish populateBean implementation of AbstractAutowireCapableBeanFactory","From the context point of view, this property of filteredPds  must be null at the place I modified","closed","in: core,","chenqimiao","2020-01-11T09:50:02Z","2020-01-12T00:54:32Z"
"","24290","Incorrect displaying of Spring official reference docs for some build versions","Found issues with displaying correctly some chapters in the [official ](https://docs.spring.io/spring/docs/current/spring-framework-reference)spring-framework core docs.  Some versions of the reference docs are **not** displaying correctly everything after **1.9. Annotation-based Container Configuration** chapter in the docs. The rest chapters/parts are missing in the bookmarks section in the left, while the actual content is available and obviously missing some formatting. Affected versions  - [current](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers) - [5.2.x](https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers) - [5.2.2.BUILD-SNAPSHOT](https://docs.spring.io/spring/docs/5.2.2.BUILD-SNAPSHOT/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers) - [5.2.2.RELEASE](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers)  The difference is obvious and can be seen after simply comparing the same docs with these versions (which are not affected): - [5.2.0.RELEASE](https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html) - [5.2.1.BUILD-SNAPSHOT](https://docs.spring.io/spring/docs/5.2.1.BUILD-SNAPSHOT/spring-framework-reference/core.html) - [5.2.1.RELEASE](https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/core.html) - [5.2.3.BUILD-SNAPSHOT](https://docs.spring.io/spring/docs/5.2.3.BUILD-SNAPSHOT/spring-framework-reference/core.html)  Example screenshots: ![spring-docs-1](https://user-images.githubusercontent.com/40799709/71738088-448b3a00-2e5e-11ea-9608-513398a266f2.PNG) ![spring-docs-2](https://user-images.githubusercontent.com/40799709/71738089-448b3a00-2e5e-11ea-84d8-6560e3eab002.PNG)","closed","status: duplicate,","GeorgeVelev","2020-01-03T17:22:29Z","2020-01-03T21:06:39Z"
"","24104","Add fast-path for no-args constructor in BeanUtils.instantiateClass","For the cases when constructor has no args we could have fast-paths which is likely to improve start-up time as BeanUtils.instantiateClass is called at least once for each bean instantiation in application context.","open","in: core,","stsypanov","2019-11-29T15:48:40Z","2022-07-18T17:19:27Z"
"","24768","MimeTypeUtils no longer cache MediaType.MULTIPART_FORM_DATA_VALUE","For example ""multipart/form-data; boundary=----WebKitFormBoundarymKzwdDkWNDNzQFP0"", this mimeType with random characters, wastes LRU cache space, resulting in severe performance degradation.  This pull-request fixed it","closed","","poorbarcode","2020-03-24T04:17:14Z","2022-02-18T19:06:48Z"
"","24766","MimeTypeUtils no longer cache MediaType.MULTIPART_FORM_DATA_VALUE","For example ""multipart/form-data; boundary=----WebKitFormBoundarymKzwdDkWNDNzQFP0"", this mimeType with random characters, wastes LRU cache space, resulting in severe performance degradation.  This pull-request fixed it","closed","","poorbarcode","2020-03-24T03:37:41Z","2022-02-18T19:06:48Z"
"","24570","Issue #23262 - remove obsolete documentation of ""autowire"" property","for Bean class.","closed","","mikesmithson","2020-02-22T22:21:11Z","2020-02-25T17:41:28Z"
"","24258","ConstructorResolver.resolveConstructorArguments calculates minNrOfArgs","for (Map.Entry entry : cargs.getIndexedArgumentValues().entrySet()) { 			int index = entry.getKey(); 			if (index < 0) { 				throw new BeanCreationException(mbd.getResourceDescription(), beanName, 						""Invalid constructor argument index: "" + index); 			} 			if (index > minNrOfArgs) { 				minNrOfArgs = index + 1; 			}  for this part, looks should be index >= minNrOfArgs because index starts from 0, if found a index is 5, can guess the minNrOfArgs at least 6, so if current minNrOfArgs is 5, when found a 5 index, the minNrOfArgs should be adjusted to 6.","closed","status: invalid,","gravin","2019-12-24T09:45:11Z","2019-12-25T07:13:06Z"
"","24511","Use proxyBeanMethods=false on remaining internal configuration classes","Following up on #23004 and #23166, let's revisit all remaining internal configuration classes and refactor them towards `proxyBeanMethods=false` as well: most importantly, the caching config classes - but also the async/scheduling ones as well as `LoadTimeWeavingConfiguration` and `MBeanExportConfiguration`.","closed","in: core,","jhoeller","2020-02-12T14:20:31Z","2020-05-12T20:20:28Z"
"","24232","shouldn't `AbstractHttpMessageConverter:addDefaultHeader::addDefaultHeaders` set `Content-Encoding` header?","Following org.springframework.http.MediaType deprecation messages, I now use media types without encoding suffixes but  ... my request now miss content encoding info.  Shouldn't `org.springframework.http.converter.AbstractHttpMessageConverter` set `Content-Encoding` header, for instance in `addDefaultHeaders` method, when it sets `Content-Type`?","closed","","ch4mpy","2019-12-19T20:27:53Z","2021-01-08T13:09:15Z"
"","24032","Support the feature that combine multiple SqlParamterSource","Fixes gh-23962","open","in: data,","kazuki43zoo","2019-11-19T17:08:14Z","2022-05-12T06:24:00Z"
"","24281","Honor generic type information in BeanUtils.copyProperties()","Fixes #24187 Honor generic type information when copying properties with BeanUtils  Handled standard supported Type Casting of properties. Any custom Object level property casting is restricted.","closed","type: enhancement,","kpkunal1406","2020-01-02T14:24:45Z","2020-04-28T11:32:26Z"
"","23855","Avoid default Accept header from HttpUrlConnection in RestTemplate with put and delete #23740","Fixes #23740","closed","type: enhancement,","sap-nocops","2019-10-23T22:17:32Z","2019-11-08T08:47:43Z"
"","23875","MockHttpServletResponse now checks for committed responses","Fixes #22304","closed","type: enhancement,","bckrispi","2019-10-27T23:42:29Z","2019-11-08T09:46:48Z"
"","24687","Fix encoding problem when loading bean definition from properties file","Fixed the encoding problem when loading an EncodedResource target with specified charset, not encoding.","open","in: core,","dowenliu-xyz","2020-03-13T05:27:22Z","2021-04-27T05:06:12Z"
"","23957","Update webflux.adoc","Fixed error in examples.","closed","type: task,","denisgalaybo","2019-11-08T14:42:49Z","2019-11-08T18:07:56Z"
"","24746","Fix typos in source files","Fix typos in some java files.","closed","type: task,","chenqimiao","2020-03-20T17:06:49Z","2020-03-20T19:07:03Z"
"","24287","Fix Javadoc typos","fix typos","closed","in: core,","KangZhiDong","2020-01-03T08:51:18Z","2020-01-03T11:23:34Z"
"","24086","Fix typos","fix typos","closed","status: invalid,","KangZhiDong","2019-11-26T12:55:27Z","2019-11-26T14:50:15Z"
"","24471","Fix typo in StringUtils class","Fix typo","closed","type: documentation,","hyeonisism","2020-02-03T12:52:47Z","2020-02-09T14:46:42Z"
"","24437","Update integration.adoc","Fix typo","closed","type: task,","neanton","2020-01-27T14:57:24Z","2020-01-27T16:21:18Z"
"","24344","Fix typo in ReflectionUtilsTests","Fix typo","closed","type: task,","chenqimiao","2020-01-13T14:52:58Z","2020-01-13T15:27:18Z"
"","24350","Fix variable to static in OrderSourceProviderTests","Fix to static final","closed","status: invalid,","hyeonisism","2020-01-14T00:54:57Z","2020-01-16T15:31:48Z"
"","24701","Fix typos in MergedAnnotationsCollectionTests","Fix some typos in MergedAnnotationsCollectionTests.","closed","in: core,","chenqimiao","2020-03-15T02:29:13Z","2020-03-15T11:33:14Z"
"","24679","Extract traceEnabled for reuse in RuleBasedTransactionAttribute","Fix logger.isTraceEnabled check before the last logger.trace. And extract an traceEnabled variable for reuse.","closed","status: declined,","chenqimiao","2020-03-11T14:27:38Z","2020-03-13T14:01:32Z"
"","24303","Use SingletonSupplier to create singletons","Fix https://github.com/spring-projects/spring-framework/issues/24286","closed","type: enhancement,","quaff","2020-01-07T02:52:58Z","2020-05-08T18:03:45Z"
"","24591","Support wildcards in @PropertySource","Fix #21325","closed","type: enhancement,","zarchinard","2020-02-25T14:13:29Z","2020-06-09T14:47:51Z"
"","24493","Extract a method named openNewTransaction to reuse some code","Extract a method named openNewTransaction to reuse some code","closed","type: task,","chenqimiao","2020-02-09T07:33:34Z","2020-03-14T08:51:33Z"
"","24490","Extract a method named getRawClassForType to reuse some code","Extract a method named getRawClassForType to reuse some code and add a test case for the method.","closed","","chenqimiao","2020-02-07T10:22:22Z","2022-02-18T19:06:45Z"
"","24653","Experiment with aggregateJavadoc task in Spring Javadoc plugin","Experiment with the [`aggregateJavadoc` Gradle task](https://github.com/spring-gradle-plugins/javadoc-plugin) by @rwinch and provide feedback.","closed","status: superseded,","sbrannen","2020-03-06T17:22:05Z","2020-03-18T17:48:51Z"
"","24108","[*.*] is displayed as [bold .] ,need to escape","execution(* com.xyz.service.*.*(..))  ->  execution(* com.xyz.service.\*.*(..))","closed","type: documentation,","goribun","2019-12-01T05:34:57Z","2019-12-02T18:14:19Z"
"","23890","@DateTimeFormat is override when I set spring.mvc.date-format","example： `@GetMapping 	public void DateFormateTest(@DateTimeFormat(pattern = ""yyyyMMdd"")Date date) { 	}`  In application.properties: `spring.mvc.date-format=yyyyMMddHH`  I must set the parameter `date` fotmat is `yyyyMMddHH`.Is it reasonable?","closed","status: superseded,","lutongzero","2019-10-30T03:14:13Z","2019-11-29T07:06:50Z"
"","24494","Use equals method() instead of ==","Equals are better than comparisons using ""=="" Also, Boolean returns each new object.","closed","in: core,","hyeonisism","2020-02-09T14:29:31Z","2020-02-17T16:54:21Z"
"","24655","Support user-defined key type in JDBC KeyHolder","Enhance JDBC KeyHolder by allowing to retrieve single Generated Key that is not a Number. Generated key can be an UUID or something else. Devs shouldn't have to go manually through complex collections to get it.","closed","status: feedback-provided,","eXsio","2020-03-07T10:45:48Z","2020-06-16T15:38:11Z"
"","24603","Fix typo in URI Encoding section of reference docs","EncodingMode enum has constant URI_COMPONENT, but documentation uses URI_COMPONENTS.","closed","type: task,","floftar","2020-02-26T17:12:11Z","2020-02-26T21:09:50Z"
"","24214","Reuse InputStream for ResourceRegionHttpMessageConverter","Dynamically generated input streams cannot be closed and reopened multiple times. This fix reuses the same InputStream across multiple ResourceRegion writes.  This solution does not presume anything about the underlying Resources across different ResourceRegions. It will attempt to reuse an InputStream if it's already open for a given Resource. If the range request is out of order, then the solution closes the existing open stream and attempts to open a new one. This is, at worst (all ranges are out of order or overlapping),  consistent with the existing solution, and at best (all ranges are non overlapping and in order), reuses the same InputStream to help matters.  This is a proposal for and closes #24210","closed","type: enhancement,","randomnicode","2019-12-15T03:38:51Z","2019-12-19T12:56:19Z"
"","24212","Reuse InputStream for ResourceRegionHttpMessageConverter","Dynamically generated input streams cannot be closed and reopened multiple times. This fix reuses the same InputStream across multiple ResourceRegion writes.  Closes #24210","closed","status: invalid,","randomnicode","2019-12-14T18:54:33Z","2019-12-16T10:28:37Z"
"","24736","Clarify behavior for WebClient statusHandlers","During Spring Boot 2.2 upgrade (from 2.1.x) we've noticed regression in tests using webclient.   **Scenario**: Call an enpoint returning 404 NOT_FOUND (with **non-empty** response body)  **Expected**: webclient returns empty Mono instance  **spring-webflux >= 5.2.0** **Actual**: webclient call returns an non-empty response but the wrapped object has nothing more than nulls inside - unit test fails.   **spring-webflux == 5.1.14** **Actual**: webclient call returns an empty response - unit test works fine.   Here is a sample that reproduces the problem: https://github.com/jmayday/emptymono Please have a look at this unit test (it uses Wiremock) - _shouldReturnEmptyObjectFor404WithResponseBody_  Unit test result: ``` java.lang.AssertionError:  Expecting an empty Optional but was containing value: . ``` Pay attention, that if we'll modify response body in wiremock mapping and replace body ``` {""error_code"":404,""message"":""Page not found""} ``` with empty body, then test will work.   Is this a spring-webflux 5.2.x regression or I'm misusing it?","closed","in: web,","jmayday","2020-03-06T11:53:06Z","2020-03-20T20:48:58Z"
"","24392","Upgrade to Gradle 4.10.2","Due to an upgrade of the Artifactory publication plugin on the CI server, we need to upgrade the build for `4.3.x` to Gradle 4.x.","closed","type: task,","sbrannen","2020-01-17T17:24:42Z","2020-01-17T21:05:32Z"
"","24374","webflux how to listen websession event?","Does webflux has the class like the InvalidSessionStrategy to do something when websession is valid","closed","","chunaidong","2020-01-16T06:24:31Z","2020-01-17T09:23:08Z"
"","24524","MapSqlParameterSource.getValue Handling of null values","Does the reading of multithreaded HashMap need to be synchronized? This problem has been bothering me. I don't think it's necessary","open","in: data,","rengy-github","2020-02-14T13:26:18Z","2021-11-10T12:22:17Z"
"","24064","DataSourceTransactionManager does not consider SQLExceptionTranslator on commit","Disclaimer: I understand that questions should be asked on SO, but I believe the following is rather a bug report than a question. It has also been asked on https://stackoverflow.com/questions/59006479/how-to-properly-retry-a-serializable-transaction-with-spring.  ----  I am developing against a PostgreSQL v12 database. I am using [`SERIALIZABLE`](https://www.postgresql.org/docs/current/transaction-iso.html#XACT-SERIALIZABLE) transactions. The general idea is that when PostgreSQL detects a serialization anomaly, one should retry the complete transaction.  I am using Spring's [`AbstractFallbackSQLExceptionTranslator`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/support/AbstractFallbackSQLExceptionTranslator.html) to translate database exceptions to Spring's exception classes. This exception translator should translate the PostgreSQL error [`40001`/`serialization_failure`](https://www.postgresql.org/docs/10/errcodes-appendix.html) to a [`ConcurrencyFailureException`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/ConcurrencyFailureException.html). Spring JDBC maintains a [mapping file](https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/resources/org/springframework/jdbc/support/sql-error-codes.xml#L261) to map the PostgreSQL-specific code `40001` to a generic `cannotSerializeTransactionCodes` class of database exceptions, which translates into a `ConcurrencyFailureException` for the API user.  My idea was to rely on the Spring Retry project to retry a `SERIALIZABLE` transaction which is halted due to a serialization error as following:  ``` @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Retryable(include = ConcurrencyFailureException.class, maxAttempts = ..., backoff = ...) @Transactional(isolation = Isolation.SERIALIZABLE) public @interface SerializableTransactionRetry { } ```  In service implementation, I would simply replace `@Transactional` by `@SerializableTransactionRetry` and be done with it.  Now, back to PostgreSQL. Essentially, there are two stages at which a serialization anomaly can be detected:  1. during the execution of a statement 2. during the commit phase of a transaction  It seems that Spring's `AbstractFallbackSQLExceptionTranslator` is properly translating a serialization anomaly which is detected during the execution of a statement, but fails to translate one during the commit phase. Consider the following stack trace:  ``` org.springframework.transaction.TransactionSystemException: Could not commit JDBC transaction; nested exception is org.postgresql.util.PSQLException: ERROR: could not serialize access due to read/write dependencies among transactions   Detail: Reason code: Canceled on identification as a pivot, during commit attempt.   Hint: The transaction might succeed if retried. 	at org.springframework.jdbc.datasource.DataSourceTransactionManager.doCommit(DataSourceTransactionManager.java:332) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:746) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:714) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:533) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:304) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.retry.interceptor.RetryOperationsInterceptor$1.doWithRetry(RetryOperationsInterceptor.java:91) 	at org.springframework.retry.support.RetryTemplate.doExecute(RetryTemplate.java:287) 	at org.springframework.retry.support.RetryTemplate.execute(RetryTemplate.java:164) 	at org.springframework.retry.interceptor.RetryOperationsInterceptor.invoke(RetryOperationsInterceptor.java:118) 	at org.springframework.retry.annotation.AnnotationAwareRetryOperationsInterceptor.invoke(AnnotationAwareRetryOperationsInterceptor.java:153) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ``` As you can see, PostgreSQL detects a serialization anomaly (`ERROR: could not serialize access due to ...`), but this is translated by Spring into a [`TransactionSystemException`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/TransactionSystemException.html) instead of a `ConcurrencyFailureException`.  I could alter the `SerializableTransactionRetry` annotation above to include a `TransactionSystemException` as well, but I believe that would be wrong, as now we will be retrying upon any kind of transaction error, which is not what we want here.  Is this a shortcoming in Spring's `AbstractFallbackSQLExceptionTranslator`? I am using Spring 5.2.1.","closed","type: enhancement,","pbillen","2019-11-23T10:07:32Z","2021-03-16T14:32:31Z"
"","24065","sorry-i am not found 2.2.0-SNAPSHOT","Did I open it in the wrong way?  add this                de.codecentric             spring-boot-admin-starter-server             2.2.0-SNAPSHOT           add this                        spring-milestone                              false                          http://repo.spring.io/milestone                                spring-snapshot                              true                          http://repo.spring.io/snapshot                                sonatype-nexus-snapshots             Sonatype Nexus Snapshots             https://oss.sonatype.org/content/repositories/snapshots/                              true                                           false                                ok  i am not found admin-server    Do I need any other configuration?","closed","for: external-project,","ioxiaowei","2019-11-24T07:00:24Z","2019-11-24T13:08:03Z"
"","24282","Add fast path for ClassUtils.hasMethod","Detecting of whether a Class has particular method could have a fastpath for the case when the method is declared directly in that class. When we have an instance of `Method` then we could first check its declaring class and only then go through conventional path involving heavy usage of reflection.","closed","type: enhancement,","stsypanov","2020-01-02T14:51:42Z","2020-01-08T22:54:19Z"
"","24207","Spring AOP works for save() but not for findAll() with Spring Data JPA","Define point cuts:  ```java @Aspect @Component   public class FooAspect {    @Around(""execution(* com.example.demo.model.*Repository.findAll(..))"")   public Object findAllAspect(ProceedingJoinPoint joinPoint) throws Throwable {     System.out.println(""findAll aspect"");     return joinPoint.proceed();   }      @Around(""execution(* com.example.demo.model.*Repository.save(..))"")     public Object saveAspect(ProceedingJoinPoint joinPoint) throws Throwable {       System.out.println(""save aspect"");       return joinPoint.proceed();     } } ```  with `aop` enabled:  ```java @EnableAspectJAutoProxy @Configuration public class Config { } ```  `save()` and `findAll()` are called, but only `save aspect` get printed. It seems that only `save()` get enhanced. A discussion has been made on [stackoverflow](https://stackoverflow.com/questions/59180446/save-method-is-intercepted-but-findall-is-not?noredirect=1#comment104631520_59180446), but cannot get the problem resolved yet.","open","in: core,","LangInteger","2019-12-14T03:39:10Z","2021-11-10T09:51:27Z"
"","24573","spring-web custom ”HandlerMethodArgumentResolver“ nonoperative problem","Dear developers, When using a custom HandlerMethodArgumentResolver recently discovered that he did not take effect, I found after tracking code custom HandlerMethodArgumentResolver always cannot be invoked, because his priority, after the system default ArgumentResolver can never be called, Please see the detailed code HandlerMethodArgumentResolverComposite class `getArgumentResolver (MethodParameter parameter)` method, my code is as follows:  ```java @Override public void addArgumentResolvers(List resolvers) {     resolvers.add(new HandlerMethodArgumentResolver() {             @Override             public boolean supportsParameter(MethodParameter parameter) {                  log.debug(""测试参数转换是否生效"");                 return parameter.getParameterName().equals(""token"")                         || parameter.getParameterType().isInstance(TokenSupplierCode.class);             } ``` It has always been higher priority RequestResponseBodyMethodProcessor execution","closed","","trifolium-wang","2020-02-23T09:43:39Z","2020-02-28T16:21:29Z"
"","23844","Spring AOP should not apply UndeclaredThrowableException to checked exceptions from Kotlin methods","Currently, when using Spring AOP with Kotlin, `UndeclaredThrowableException` is thrown when a method with advice throws a checked exception. There is a **_workaround_** in Kotlin in that you can add `@Throws` annotations to methods, but this is not really feasible as it would require annotating every method of every project, and methods in other libraries might not be under your control.  What would solve this problem would be to have an option in Spring to disable the throwing of `UndeclaredThrowableException` and simply throw the original exception.","closed","type: enhancement,","ryandanielspmc","2019-10-22T00:53:35Z","2021-04-21T09:20:33Z"
"","23918","Single @EnabledForTestGroups(CI)-annotated test prevents local-remote caching of every test task","Currently, there is a cache miss for every test task when building something locally that's already been built on CI. These misses appear to be due to the test groups system property that's set on every test task as it's non-null on CI and null locally. There's a single test in `spring-core` that uses `@EnabledForTestGroups(CI)` so the current cost in terms of the loss of caching seems rather high in relation to the benefit of running one CI-specific test.  There are a few different ways that this could be addressed from using separate test tasks to rewriting the one test to avoid the need for `@EnabledForTestGroups(CI)`. I'm not sure what the best option is in terms of meeting the team's testing needs while also maximising the number of build tasks that are cacheable. Hopefully we can use this issue to figure that out.","closed","type: task,","wilkinsona","2019-11-04T11:00:56Z","2019-11-04T14:45:30Z"
"","23999","Use @MessageMapping method signature to constrain RSocket interaction model","Currently, our RSocket support is mapping `REQUEST_FNF`, `REQUEST_RESPONSE`, `REQUEST_STREAM` and `REQUEST_CHANNEL` on `@MessageMapping` annotated handler methods on one side, `SETUP` and `METADATA_PUSH` on `@ConnectMapping` on the other.  ## Context of the issue  The case of ""fire and forget"" requests, where the requester sends a request and does not expect any response, can be interesting here in the context of our flexible signature support and the current mapping process.  While looking at our RSocket support with @snicoll, we considered a Controller handler that returns a response stream:  ``` @MessageMapping(""test"") public Flux test() { 	return Flux.interval(Duration.ofSeconds(1)); } ```  If a requester calls this handler with a fire and forget interaction type: ``` Mono done = requesterBuilder.dataMimeType(MediaType.APPLICATION_CBOR) 		.connectTcp(""localhost"", this.localPort) 		.flatMap(req -> req.route(""test"").send()); ```  Then we're getting the following exception on the server side: ``` java.lang.IllegalArgumentException: Missing 'rsocketResponse' 	at org.springframework.util.Assert.notNull(Assert.java:198) 	at org.springframework.messaging.rsocket.annotation.support.RSocketPayloadReturnValueHandler.handleEncodedContent(RSocketPayloadReturnValueHandler.java:65) 	at org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler.lambda$handleReturnValue$0(AbstractEncoderMethodReturnValueHandler.java:124) 	at org.springframework.messaging.handler.invocation.reactive.ChannelSendOperator$WriteBarrier.onNext(ChannelSendOperator.java:194) ```  In this particular case (and in general), we can find pairs of handler definitions / rsocket interactions that  mismatch in our mapping infrastructure. For example, a request can be mapped to a handler, the handler is executed but the returned subscriber is not subscribed to.   After chatting with @rstoyanchev, we thought that we should enforce a few design choices in our implementation.  ## Refining message mappings with handler return types  First, when mapping requests on handlers, returning more elements than expected should not be allowed, but returning less than expected should be permitted. For example:  * a `REQUEST_FNF` should only be mapped on handlers that return `Mono` or `void`. Other types (even `Mono`) should not be considered for mapping. * a `REQUEST_RESPONSE` should only be mapped on `Mono` types, as `Flux` might return more than expected. In this case, we could automatically `take(1)` on the returned publisher, but this goes against the general behavior we've established in reactor and webflux so far.  ## Not allowing ambiguous mappings  Even in the light of this (restricting message mapping depending on the handler return type), we should not allow multiple handlers with the same route. If this happens, this will be treated as an error since the mapping is ambiguous.","closed","type: enhancement,","bclozel","2019-11-14T13:26:45Z","2019-11-18T19:07:09Z"
"","24163","Allow programmatic registration of completion and error callbacks to transactional event listeners","Currently, event listeners bound to transaction commits, rollbacks or completion in general can only be used via the @TransactionalEventListener annotation. It would be nice if there was a way to programmatically register those via `context.addApplicationListener(…)`, pointing to a method, configuring the transaction phase to apply the listener in etc.  After revisiting this with @jhoeller, here's the current state and derived ideas for what to improve on: `ApplicationListenerMethodTransactionalAdapter` is currently package protected and thus prevents programatic access to transactional event listeners as there's no type you can refer to even in instance of checks. We had the idea to introduce a public type that `ALMTA` would extend / implement that exposes the following API:  - the transaction phase the listener is bound to - a (nullable) identifier whose default is derived from the annotated method's name, potentially overridable via a to be introduced annotation attribute on `@TransactionalEventListener` or via the to be introduced programatic API - a `….registerCompletionCallback(Consumer)` that will be called for every successfully completed invocation of the listener - a `….registerErrorCallback(Consumer)` that will be called in case the listener threw an exception. If that callback is registered the `Throwable` would not be propagated, so that `TransactionSynchronizationUtils.invokeAfterCompletion(…)` would not actually see the `Throwable` and avoid the logging. - if the type to be introduced would become an interface, it would be nice if it also exposed `ApplicationListenerMethodAdapter.processEvent(…)` to make sure the listener instance can be invoked explicitly. This is needed in the context of transactional even listeners as the already externally accessible `onApplicationEvent(…)` implements the event publication by registering a transaction synchronization, which does not immediately execute the listener.  Most of this is driven by a prototypical event publication log implementation that makes sure that events handled by transactional event listeners do not get lost in case of exceptions occurring during the handling or unanticipated application shutdowns during that work. That work can be found [here](https://github.com/odrotbohm/spring-domain-events). The implementation currently relies on deep reflection inspection of framework internals and AOP usage to implement the log and log entry completion. That implementation would become significantly simpler.  Another aspect that makes this worthwhile is the general ability to use event listener registrations programmatically to avoid reflection and annotation detection overhead which in turn aligns with our functional bean registration API efforts.","closed","type: enhancement,","odrotbohm","2019-12-08T12:25:01Z","2020-10-22T13:20:39Z"
"","24497","ExecutorConfigurationSupport API refinement to control internal executor shutdown","Currently, `ExecutorConfigurationSupport#shutdown()` encapsulate multiple scenarios for shutting down internal `ExecutorService`.  The single method `shutdown()` performs `shutdown()/shutdownNow()`(non-blocking) and `awaitTermination()`(blocking) based on its property.  I am writing a graceful shutdown logic for task executor/scheduler. The logic for graceful shutdown is to retrieve all task executor/schedulers and apply: - Call `shutdown()` to not accept anymore tasks - Wait currently running task for the duration of graceful period  With current available API, I need to do following:  ```java Instant deadline = start.plus(gracefulShutdownTimeout);  // stop receiving anymore request while keep running active ones for (ExecutorConfigurationSupport executorConfigurationSupport : this.executorConfigurationSupports) { 	executorConfigurationSupport.setWaitForTasksToCompleteOnShutdown(true); 	executorConfigurationSupport.shutdown(); // non-blocking }  // Previously, executors are called ""shutdown()""; so, no more new tasks are scheduled. // Now, call ""awaitTermination()"" to wait current tasks to finish while // the container is shutting down in parallel. for (ExecutorConfigurationSupport executorConfigurationSupport : this.executorConfigurationSupports) { 	int awaitTerminationSeconds = Math.toIntExact(Duration.between(Instant.now(), deadline).getSeconds()); 	executorConfigurationSupport.setAwaitTerminationSeconds(awaitTerminationSeconds); 	executorConfigurationSupport.shutdown();  // blocking } ```  Since this calls `shutdown()` twice with different parameter in order to achieve `shutdown()` and `awaitTermination()` for underlying executor, it is not so intuitive. Also requires to know the detail about what `ExecutorConfigurationSupport#shutdown()` does.  Another workaround is to retrieve internal `ExecutorService` and call `shutdown()` and `awaitTermination()`.  ```java List executorServices = new ArrayList<>();  for (ExecutorConfigurationSupport executorConfigurationSupport : this.executorConfigurationSupports) { 	if (executorConfigurationSupport instanceof ThreadPoolTaskExecutor) { 		executorServices.add(((ThreadPoolTaskExecutor)executorConfigurationSupport).getThreadPoolExecutor()); 	} 	else if (executorConfigurationSupport instanceof ThreadPoolTaskScheduler) { 		executorServices.add(((ThreadPoolTaskScheduler)executorConfigurationSupport).getScheduledExecutor()); 	} }  for(ExecutorService executorService : executorServices) { 	executorService.shutdown(); }  for(ExecutorService executorService : executorServices) { 	executorService.awaitTermination(...); }  ```  I think it would be nice to have some API refinement for task executor/scheduler to easily control underlying `ExecutorService`.  Simple solution is to to add a getter to `ExecutorConfigurationSupport` to expose internal `ExecutorService`. This way, in addition to existing `shutdown()`, if user needs to do more fine control on shutdown, getter can expose the `ExecutorService`. Another way is to provide blocking(`awaitTermination`) and non-blocking(`shutdown/shutdownNow`) methods on `ExecutorConfigurationSupport` instead or in addition to the current `shutdown()` method.","open","type: enhancement,","ttddyy","2020-02-10T08:08:56Z","2022-04-06T19:40:06Z"
"","24785","Simplify conversion of ByteArrayOutputStream to String","Currently we often convert BAOS to String as ```java String contents = new String(baos.toByteArray(), StandardCharsets.ISO_8859_1); ``` which can be made more simple and effective as ```java String contents = baos.toString(StandardCharsets.ISO_8859_1.name()); ``` `BAOS.toByteArray()` creates a copy of underlying array which is later decoded inside of `String` constructor, while `BAOS.toString()` doesn't create intermediate copy making convertion more memory-effective.  For JDK 8 I've got following results: ``` Benchmark                                                        (length)  Mode     Score     Error   Units ByteArrayOutputStreamBenchmark.newString                               10  avgt    97.420 ±   7.340   ns/op ByteArrayOutputStreamBenchmark.newString                              100  avgt   480.689 ±  20.615   ns/op ByteArrayOutputStreamBenchmark.newString                             1000  avgt  4717.681 ± 175.550   ns/op  ByteArrayOutputStreamBenchmark.toString                                10  avgt    85.578 ±   5.233   ns/op ByteArrayOutputStreamBenchmark.toString                               100  avgt   533.850 ±  23.902   ns/op ByteArrayOutputStreamBenchmark.toString                              1000  avgt  4703.280 ± 113.713   ns/op  ByteArrayOutputStreamBenchmark.newString:·gc.alloc.rate.norm           10  avgt   134.400 ±  15.271    B/op ByteArrayOutputStreamBenchmark.newString:·gc.alloc.rate.norm          100  avgt   722.401 ±  10.494    B/op ByteArrayOutputStreamBenchmark.newString:·gc.alloc.rate.norm         1000  avgt  6380.016 ±  46.441    B/op  ByteArrayOutputStreamBenchmark.toString:·gc.alloc.rate.norm            10  avgt   109.600 ±  14.586    B/op ByteArrayOutputStreamBenchmark.toString:·gc.alloc.rate.norm           100  avgt   664.002 ±  16.986    B/op ByteArrayOutputStreamBenchmark.toString:·gc.alloc.rate.norm          1000  avgt  5433.618 ±  39.002    B/op","closed","type: enhancement,","stsypanov","2020-03-26T09:04:59Z","2020-03-26T18:27:13Z"
"","24535","PartsHttpMessageWriter introduced","Currently there is no option to pass `Flux` as body via `WebClient`. This pr extends `WebClient` functionality and allows accept  `Flux` as body.","closed","type: enhancement,","kptfh","2020-02-17T07:52:06Z","2020-05-08T08:40:09Z"
"","23917","Improve BeanPropertyRowMapper.underscoreName()","Currently the method allocates a substring of length = 1 for each character in field name. This can be improved by using `char` instead of `String`.  Also I doubt that we need name's length check: in fact there can be no property with empty name or one consisting of  exclusively whitespaces/tabs. I think this check can be removed, and even if the code throws after transformation this indicates a problem on the upper level.","closed","type: enhancement,","stsypanov","2019-11-04T09:24:37Z","2021-04-27T11:33:09Z"
"","24614","Enhance @DependsOn to be also configurable via class type","Currently the `@DependsOn(...)` annotation is only configurable using `String`, it would be nice to also support class type.  Example: 1- Current situation:  ``` @Configuration public class Config {      @Bean    public Bean1 bean1(){    return new Bean1();   }    @Bean    @DependsOn(value={""bean1""})   public Bean2 bean2(){    return new Bean2();   } } ``` Enhancement:  ``` @Configuration public class Config {      @Bean    public Bean1 bean1(){    return new Bean1();   }    @Bean    @DependsOn(value={Bean1.class})   public Bean2 bean2(){    return new Bean2();   } } ``` It's easier to remember the class than bean name. Thanks","open","in: core,","akuma8","2020-02-28T17:43:41Z","2021-11-12T12:55:25Z"
"","24649","CglibAopProxy: Skip non-overridden methods of Object.class as those which for sure have no advice","Currently in case of frozen AOP chain `CglibAopProxy` creates fixed callbacks for all methods of the target class, while in many cases only a couple of them actually need to have advices. Other methods like native ones of `java.lang.Object` and others non-overridden can be skipped saving some time and memory without breaking functionality.  I've used a [benchmark](https://github.com/stsypanov/spring-benchmark/blob/master/src/main/java/org/tsypanov/sb/aspect/benchmark/AspectPrototypeBenchmark.java) measuring costs of creating a prototype bean with one aspected method and got those results: ``` before  Benchmark                                                             Mode  Cnt      Score     Error   Units AspectPrototypeBenchmark.getAdvisedBean                               avgt  100     14.024 ±   0.164   us/op AspectPrototypeBenchmark.getAdvisedBean:·gc.alloc.rate                avgt  100    498.209 ±   4.753  MB/sec AspectPrototypeBenchmark.getAdvisedBean:·gc.alloc.rate.norm           avgt  100  10983.307 ±  14.193    B/op AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Eden_Space       avgt  100    498.314 ±  22.655  MB/sec AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Eden_Space.norm  avgt  100  10992.978 ± 505.995    B/op AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Old_Gen          avgt  100      0.001 ±   0.001  MB/sec AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Old_Gen.norm     avgt  100      0.025 ±   0.010    B/op AspectPrototypeBenchmark.getAdvisedBean:·gc.count                     avgt  100    327.000            counts AspectPrototypeBenchmark.getAdvisedBean:·gc.time                      avgt  100    357.000                ms  after  Benchmark                                                             Mode  Cnt     Score     Error   Units AspectPrototypeBenchmark.getAdvisedBean                               avgt  100     8.150 ±   0.202   us/op AspectPrototypeBenchmark.getAdvisedBean:·gc.alloc.rate                avgt  100   558.719 ±  11.480  MB/sec AspectPrototypeBenchmark.getAdvisedBean:·gc.alloc.rate.norm           avgt  100  7133.664 ±   5.594    B/op AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Eden_Space       avgt  100   560.401 ±  26.718  MB/sec AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Eden_Space.norm  avgt  100  7159.093 ± 316.966    B/op AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Old_Gen          avgt  100     0.001 ±   0.001  MB/sec AspectPrototypeBenchmark.getAdvisedBean:·gc.churn.G1_Old_Gen.norm     avgt  100     0.012 ±   0.005    B/op AspectPrototypeBenchmark.getAdvisedBean:·gc.count                     avgt  100   330.000            counts AspectPrototypeBenchmark.getAdvisedBean:·gc.time                      avgt  100   412.000                ms  ```","open","type: enhancement,","stsypanov","2020-03-05T15:47:41Z","2022-08-01T11:37:03Z"
"","24361","Avoid setting special Content-* response headers in TomcatHeadersAdapter","Currently `TomcatHeadersAdapter` directly writes to the `MimeHeaders` map, as part of the performance improvements in #21783. We are also applying specific changes on the response in `org.springframework.http.server.reactive.TomcatHttpHandlerAdapter.TomcatServerHttpResponse` for the `Content-Length` and `Content-Type` response headers.  The problem is we're still writing those headers to the underlying map, which means those headers are written no matter what happens to the response, even if other parts of Tomcat codebase are removing them using the expected API.  We should never add those headers to the map in the first place.  See [Tomcat issue for background information](https://bz.apache.org/bugzilla/show_bug.cgi?id=64073).","closed","type: bug,","bclozel","2020-01-15T12:56:04Z","2020-01-17T14:14:50Z"
"","24107","Constructor based bean binding should support url path variables, not only request parameters","Currently (Spring 5.2) we can not use constructor based bean binding of path variables as we can with request parameters. This is somewhat an inconsistent way of binding url data. Bean property binding is supported for both types of parameters but therefor a mutable object is required.  In method `constructAttribute` (`ModelAttributeMethodProcessor.java:277`) the values for constructor parameters are only taken from `webRequest.getParameterValues(paramName)` so no path variables are taken into account here. It's only when that constructed attribute object is bind by `bindRequestParameters(binder, webRequest)` in method `resolveArgument` (`ModelAttributeMethodProcessor.java:160`) that the path variables (as well as the request parameters again) are eventually added for bean property binding in method `ServletRequestDataBinder#bind`.   I mentioned this problem in [issue 22600](https://github.com/spring-projects/spring-framework/issues/22600#issuecomment-559266402) and was [correctly advised](https://github.com/spring-projects/spring-framework/issues/22600#issuecomment-559729029) to create a separate issue for this to avoid a mixed conversation.","closed","type: enhancement,","rob-valor","2019-11-30T21:33:47Z","2020-08-06T16:29:15Z"
"","24691","Do not mention credentials as enabled by default in CorsRegistry","Credentials are not enabled by default contrary to the javadocs.  The credentials support must be enabled via #allowCredentials.","closed","in: web,","mdindoffer","2020-03-13T14:09:21Z","2020-03-13T14:22:07Z"
"","24616","Release version 5.1.0.RELEASE","create the branch for recording some annotations when reading source code","closed","status: invalid,","flasherwang","2020-02-29T07:22:04Z","2020-02-29T09:00:35Z"
"","24783","i need to know which version of gradle you are using","Could not fetch model of type 'EclipseProject' using Gradle installation 'E:\gradle-3.1'.  i use ide of spring tool suite","closed","for: stackoverflow,","eric521237","2020-03-26T07:21:51Z","2020-03-26T08:54:15Z"
"","24029","Unsafe invocation of .value() on annotations in SynthesizedMergedAnnotationInvocationHandler prevents backwards-compatible additions to @annotation interfaces","Context ---  I have a scenario where I am extending an annotation API from      @interface MyAnnotation {         String[] old();     }   to      @interface MyAnnotation {         String[] value();             @deprecated         String[] old() default {}     }  Here, old libraries compiled with the old annotation are still supported as the change is binary compatible. It is only that I as a framework author need to handle the case of an invocation of value() throwing an `IncompleteAnnotationException`.  I believe allowing this is crucial to evolution of annotations without forcing all implementors to re-compile.  Issue in Spring Core ---  When calling `org.springframework.beans.factory.ListableBeanFactory#findAnnotationOnBean`,  Spring tries to build a proxy for the found annotation. In the process, spring attempts to load the value of all annotation attributes via `org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#getAttributeValue`. This fails for the newly added annotation attribute as mentioned above:  ``` java.lang.annotation.IncompleteAnnotationException: MyAnnotation missing element value 	at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:81) 	at com.sun.proxy.$Proxy180.value(Unknown Source) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:279) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:263) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.TypeMappedAnnotation.getValue(TypeMappedAnnotation.java:429) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.TypeMappedAnnotation.getValue(TypeMappedAnnotation.java:399) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.TypeMappedAnnotation.getAttributeValue(TypeMappedAnnotation.java:384) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.AbstractMergedAnnotation.getValue(AbstractMergedAnnotation.java:178) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.getAttributeValue(SynthesizedMergedAnnotationInvocationHandler.java:176) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.(SynthesizedMergedAnnotationInvocationHandler.java:66) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.createProxy(SynthesizedMergedAnnotationInvocationHandler.java:184) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.TypeMappedAnnotation.createSynthesized(TypeMappedAnnotation.java:335) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.AbstractMergedAnnotation.synthesize(AbstractMergedAnnotation.java:210) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.core.annotation.AbstractMergedAnnotation.synthesize(AbstractMergedAnnotation.java:200) [org.apache.servicemix.bundles.spring-core:5.2.0.RELEASE_1] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAnnotationOnBean(DefaultListableBeanFactory.java:680) [io.neba.spring-beans:5.2.0.RELEASE_1] ``` Here, I believe the implementation should not expected values to be complete. I am not even sure as to why `org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#SynthesizedMergedAnnotationInvocationHandler` loads the values in the first place.","closed","in: core,","olaf-otto","2019-11-19T11:52:51Z","2019-11-22T18:59:25Z"
"","24468","ContentResultMatchers.string(String expectedContent)  cannot work in Spring Framework 5.2.3.RELEASE","ContentResultMatchers.string(String expectedContent)  cannot work  in Spring Framework 5.2.3.RELEASE.  Here is my pom.xml:  ```xml    4.0.0   com.waylau.spring5   mvc-test   1.0.0   mvc-test   jar      	waylau.com   	https://waylau.com    	 		UTF-8 		1.8 		1.8 		2.22.2 		5.2.3.RELEASE 		4.0.1 		5.6.0 		1.3.2      	 	     	        org.springframework 	        spring-context 	        ${spring.version} 	     	     	        org.springframework 	        spring-webmvc 	        ${spring.version} 	     	     			javax.servlet 			javax.servlet-api 			${servlet.version} 			provided 		 	     	        org.springframework 	        spring-test 	        ${spring.version} 			test 		 		 			org.junit.jupiter 			junit-jupiter 			${junit-jupiter.version} 			test 		 	 	 		 			 				 				 					maven-surefire-plugin 					${maven-surefire-plugin.version} 				 			 		 	  ```  Here is my RestController :  ```java package com.waylau.spring.hello.controller;  import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  /**  * Hello 控制器.  *   * @since 1.0.0 2020年2月2日  * @author Way Lau  */ @RestController public class HelloController {  	@RequestMapping(""/hello"") 	public String hello() { 	    return ""Hello World! Welcome to visit waylau.com!""; 	} } ```  Here is my Spring XML configration:  ```xml                    ```  and here is my test case:  ```java /**  * Welcome to https://waylau.com  */ package com.waylau.spring.hello.controller;  import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;   import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;   import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.http.MediaType; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit.jupiter.SpringExtension; import org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig; import org.springframework.test.context.web.WebAppConfiguration; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.springframework.web.context.WebApplicationContext;    /**  * HelloController Test.  *   * @since 1.0.0 2018年12月10日  * @author Way Lau   */ @ExtendWith(value={SpringExtension.class}) @ContextConfiguration(""classpath:spring.xml"") @WebAppConfiguration public class HelloControllerTest {  	MockMvc mockMvc;      @BeforeEach     void setup(WebApplicationContext wac) {         this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();     }  	@Test     void testHello() throws Exception {         this.mockMvc.perform(get(""/hello"")                 .accept(MediaType.APPLICATION_JSON))             .andExpect(status().isOk())             .andExpect(content().contentType(""application/json""))             .andExpect(content().string(""Hello World! Welcome to visit waylau.com!""));             ;     } } ```  The complete source code can be found here:","closed","for: stackoverflow,","waylau","2020-02-02T09:23:03Z","2020-02-03T09:03:07Z"
"","24469","Improve ConcurrentLruCache performance","ConcurrentLruCache can be improved.  - manage collection size manually (size operation of concurrent collections can be heavy) - check cache hit first (size check will be useless if cache miss) - reduce read-lock scope - use `map.get` to test cache instead of `queue.remove`  And, I think that using ConcurrentLrCache spring widely instead of some synchronized + LinkedHashMap  will improve performance.","closed","type: enhancement,","bananayong","2020-02-03T09:38:17Z","2020-03-22T20:59:10Z"
"","24715","Use io.spring.javadoc-aggregate","Closes gh-24653","open","status: feedback-provided,","rwinch","2020-03-18T02:36:54Z","2021-11-11T10:34:01Z"
"","24069","Add flexible Duration value parsing in scheduled tasks","Closes gh-22013  Add flexible Duration value parsing in scheduled tasks like in Spring Boot for configuration's consistency.  Reasoning about decisions: - The solution is based on a [corresponding commit in Spring Boot](https://github.com/spring-projects/spring-boot/commit/99afc4bc1f3e5c57fcabf6ee9551034a266bb5ab) - The logic for parsing delay is not extracted into a separate class following the decision made before by implementors of `ScheduledAnnotationBeanPostProcessor` class - However, it is extracted into a separate method, because now it became more complex, and in my opinion, separating it in a different method simplifies the code - Added method `parseDelayAsLong` is not documented using `JavaDoc` because as observed from the code private methods are not documented in Spring","open","in: core,","ilyavy","2019-11-25T06:50:03Z","2021-11-10T12:03:13Z"
"","24571","Issue #24291 - Merge transactional attributes","Changes to spring-tx as discribed in #24291","open","in: data,","elab","2020-02-22T22:42:06Z","2021-11-10T09:27:07Z"
"","24576","Turn off useSuffixPatternMatching by default","Changes for issue #23915.","closed","status: superseded,","mikesmithson","2020-02-23T23:42:10Z","2020-05-05T17:25:39Z"
"","24809","entityManager.createQuery() taking lot of time to build query and bind the parameters. Performance affected","Can you please help on this issue raised in stackoverflow: https://stackoverflow.com/questions/60886012/entitymanager-createquery-taking-lot-of-time-to-build-query-and-bind-the-param  The org.hibernate.Criteria, fetches results in milliseconds, where ""CriterialBuilder"" takes a lot of time in:  CriteriaCompiler.compile CriteriaQueryImpl$1.buildCompiledQuery CriteriaCompiler$1$1.bind  Please help here.","closed","for: stackoverflow,","githubsree","2020-03-29T08:22:42Z","2020-03-30T09:57:04Z"
"","23909","WebClient retry() doesn't re-run filters","Calling `retry()` on a `Mono<>` produced by calling `WebClient.exchange()` won't re-run the filters. This means any modifications made to the request by filters (like changing the URL for load-balancing purposes) won't be repeated.  `DefaultWebClient` seems to run all the filters synchronously, including generating the URL. Then `DefaultExchangeFunction` calls `ClientHttpConnection`. It's the http connection that does the actual connection asnychronously, producing a `Mono<>`. Specifically, filters get run when you call `exchange()` or `retrieve()`, not when you actually subscribe.  Related: https://github.com/spring-cloud/spring-cloud-commons/issues/579","closed","type: backport,","Anusien","2019-11-01T19:48:48Z","2019-11-07T15:42:09Z"
"","23868","hasCorsConfigurationSource() now supports HandlerExecutionChain","Call `AbstractHandlerMapping#hasCorsConfigurationSource` again with the actual handler if the passed object is a wrapper. This solves issue gh-23843 in our situation.","closed","status: declined,","jbrokamp","2019-10-24T20:31:31Z","2019-10-29T14:50:19Z"
"","24532","Polish some test classes by using predefined constants","By changing the magic number to a constant, it has been improved to safer test code.","closed","type: task,","hyeonisism","2020-02-16T14:36:42Z","2020-02-19T11:11:40Z"
"","24778","Wrap XMLStreamException in DecodingException","Both `XmlEventDecoder` and `Jaxb2XmlDecoder` catch `XMLStreamException`s and rethrow them using `Exceptions.propagate`. According to the Decoder contract, these should be `DecodingException`s instead.","closed","type: enhancement,","poutsma","2020-03-25T14:37:14Z","2020-06-10T13:59:32Z"
"","24240","Blocking call under LocalVariableTableParameterNameDiscoverer with Boot JAR loader","Blockhound detects blocking call.  Spring version spring-webflux 5.1.9.RELEASE  JVM version (e.g. java -version) java 11.0.3 2019-04-16 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode)  OS version (e.g. uname -a) macOS Mojave 10.14.5  ``` 	at reactor.blockhound.BlockHound$Builder.lambda$install$8(BlockHound.java:259) 	at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:43) 	at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) 	at java.base/java.io.RandomAccessFile.read(RandomAccessFile.java:406) 	at org.springframework.boot.loader.data.RandomAccessDataFile$FileAccess.read(RandomAccessDataFile.java:222) 	at org.springframework.boot.loader.data.RandomAccessDataFile$FileAccess.access$400(RandomAccessDataFile.java:205) 	at org.springframework.boot.loader.data.RandomAccessDataFile.read(RandomAccessDataFile.java:117) 	at org.springframework.boot.loader.data.RandomAccessDataFile.access$700(RandomAccessDataFile.java:33) 	at org.springframework.boot.loader.data.RandomAccessDataFile$DataInputStream.doRead(RandomAccessDataFile.java:175) 	at org.springframework.boot.loader.data.RandomAccessDataFile$DataInputStream.read(RandomAccessDataFile.java:155) 	at java.base/java.util.zip.InflaterInputStream.fill(InflaterInputStream.java:243) 	at org.springframework.boot.loader.jar.ZipInflaterInputStream.fill(ZipInflaterInputStream.java:68) 	at java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) 	at org.springframework.boot.loader.jar.ZipInflaterInputStream.read(ZipInflaterInputStream.java:52) 	at org.springframework.asm.ClassReader.readStream(ClassReader.java:306) 	at org.springframework.asm.ClassReader.(ClassReader.java:273) 	at org.springframework.core.LocalVariableTableParameterNameDiscoverer.inspectClass(LocalVariableTableParameterNameDiscoverer.java:114) 	at org.springframework.core.LocalVariableTableParameterNameDiscoverer.getParameterNames(LocalVariableTableParameterNameDiscoverer.java:74) 	at org.springframework.core.PrioritizedParameterNameDiscoverer.getParameterNames(PrioritizedParameterNameDiscoverer.java:55) 	at org.springframework.core.MethodParameter.getParameterName(MethodParameter.java:622) 	at org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver.updateNamedValueInfo(AbstractNamedValueArgumentResolver.java:145) 	at org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver.getNamedValueInfo(AbstractNamedValueArgumentResolver.java:123) 	at org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver.resolveArgument(AbstractNamedValueArgumentResolver.java:92) 	at org.springframework.web.reactive.result.method.annotation.AbstractNamedValueSyncArgumentResolver.resolveArgument(AbstractNamedValueSyncArgumentResolver.java:64) 	at org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:123) 	at org.springframework.web.reactive.result.method.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:190) 	at org.springframework.web.reactive.result.method.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:133) 	at org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.lambda$handle$1(RequestMappingHandlerAdapter.java:200) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:442) 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:442) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1879) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1753) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:426) 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:426) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core.publisher.MonoCallableOnAssembly.subscribe(MonoCallableOnAssembly.java:82) 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:426) 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) 	at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:122) 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) 	at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:122) 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247) 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:345) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:442) 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:318) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:426) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core.publisher.MonoCallableOnAssembly.subscribe(MonoCallableOnAssembly.java:82) 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:70) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64) 	at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:226) 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:442) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:161) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302) 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:794) 	at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:424) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:326) 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","in: web,","IrishkA13","2019-12-20T15:25:49Z","2020-02-21T16:12:17Z"
"","24272","Blocking calls detected by Blockhound when calling Swagger endpoint","Blockhound detects blocking call.  Spring version spring-webflux 5.1.9.RELEASE  JVM version (e.g. java -version) java 11.0.3 2019-04-16 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode)  OS version (e.g. uname -a) macOS Mojave 10.14.5  1) ``` 	at reactor.blockhound.BlockHound$Builder.lambda$install$8(BlockHound.java:259) ~[blockhound-1.0.0.M4.jar:?] 	at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:43) ~[blockhound-1.0.0.M4.jar:?] 	at java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[?:?] 	at java.io.RandomAccessFile.read(RandomAccessFile.java:406) ~[?:?] 	at java.io.RandomAccessFile.readFully(RandomAccessFile.java:470) ~[?:?] 	at java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1304) ~[?:?] 	at java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:998) ~[?:?] 	at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:1013) ~[?:?] 	at java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:468) ~[?:?] 	at java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) ~[?:?] 	at java.io.InputStream.readNBytes(InputStream.java:490) ~[?:?] 	at java.util.jar.JarFile.getBytes(JarFile.java:805) ~[?:?] 	at java.util.jar.JarFile.checkForSpecialAttributes(JarFile.java:1005) ~[?:?] 	at java.util.jar.JarFile.isMultiRelease(JarFile.java:388) ~[?:?] 	at java.util.jar.JarFile.getEntry(JarFile.java:507) ~[?:?] 	at sun.net.www.protocol.jar.URLJarFile.getEntry(URLJarFile.java:131) ~[?:?] 	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:137) ~[?:?] 	at sun.net.www.protocol.jar.JarURLConnection.getContentLengthLong(JarURLConnection.java:182) ~[?:?] 	at org.springframework.core.io.AbstractFileResolvingResource.isReadable(AbstractFileResolvingResource.java:109) ~[spring-core-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.web.reactive.resource.PathResourceResolver.getResource(PathResourceResolver.java:117) ~[spring-webflux-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.web.reactive.resource.PathResourceResolver.lambda$getResource$1(PathResourceResolver.java:99) ~[spring-webflux-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:368) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1879) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1753) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:318) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:70) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:226) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:442) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:161) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328) [netty-codec-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302) [netty-codec-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe.readReady(AbstractKQueueStreamChannel.java:544) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe.readReady(AbstractKQueueChannel.java:376) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.KQueueEventLoop.processReady(KQueueEventLoop.java:211) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.KQueueEventLoop.run(KQueueEventLoop.java:289) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) [netty-common-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.39.Final.jar:4.1.39.Final] 	at java.lang.Thread.run(Thread.java:834) [?:?] ```  2)  ``` 	at reactor.blockhound.BlockHound$Builder.lambda$install$8(BlockHound.java:259) ~[blockhound-1.0.0.M4.jar:?] 	at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:43) ~[blockhound-1.0.0.M4.jar:?] 	at java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[?:?] 	at java.io.RandomAccessFile.read(RandomAccessFile.java:406) ~[?:?] 	at java.io.RandomAccessFile.readFully(RandomAccessFile.java:470) ~[?:?] 	at java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1304) ~[?:?] 	at java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:998) ~[?:?] 	at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:1013) ~[?:?] 	at java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:468) ~[?:?] 	at java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) ~[?:?] 	at java.io.FilterInputStream.read(FilterInputStream.java:133) ~[?:?] 	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) ~[?:?] 	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) ~[?:?] 	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) ~[?:?] 	at java.io.InputStreamReader.read(InputStreamReader.java:185) ~[?:?] 	at java.io.BufferedReader.fill(BufferedReader.java:161) ~[?:?] 	at java.io.BufferedReader.readLine(BufferedReader.java:326) ~[?:?] 	at java.io.BufferedReader.readLine(BufferedReader.java:392) ~[?:?] 	at org.springframework.http.MediaTypeFactory.parseMimeTypes(MediaTypeFactory.java:71) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.http.MediaTypeFactory.(MediaTypeFactory.java:47) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.web.reactive.resource.ResourceWebHandler.lambda$handle$1(ResourceWebHandler.java:354) ~[spring-webflux-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:422) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1879) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1753) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:318) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3858) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:70) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) [reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] 	at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:226) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:442) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:161) [reactor-netty-0.8.11.RELEASE.jar:0.8.11.RELEASE] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328) [netty-codec-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302) [netty-codec-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) [netty-transport-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe.readReady(AbstractKQueueStreamChannel.java:544) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe.readReady(AbstractKQueueChannel.java:376) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.KQueueEventLoop.processReady(KQueueEventLoop.java:211) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.channel.kqueue.KQueueEventLoop.run(KQueueEventLoop.java:289) [netty-all-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) [netty-common-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.39.Final.jar:4.1.39.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.39.Final.jar:4.1.39.Final] 	at java.lang.Thread.run(Thread.java:834) [?:?] ```","closed","type: enhancement,","IrishkA13","2019-12-29T18:54:38Z","2021-03-10T20:53:24Z"
"","24047","Already failed contexts should not be started again for each test","Before this commit, Spring Test Framework caches contexts shared among different test methods. However, context failures are not cached and failing context is started again and again for each test method the context match.  Starting a context is often a time and space consuming operation. It should be avoided when not necessary. If context fails once, there rather not possible it run second time.  This commit remembers failed context and save resources by not starting them again","open","type: enhancement,","michaldo","2019-11-20T22:29:23Z","2021-10-30T19:46:27Z"
"","24194","ClientCodecConfigurer drops MultipartHttpMessageWriter.partWriters when mutated","Before being configured a WebClient has several partWriters: ![image](https://user-images.githubusercontent.com/294891/70667869-d40a4800-1c26-11ea-99c2-65f803240b45.png) after being configured it doesn't have any: ![image](https://user-images.githubusercontent.com/294891/70667909-f56b3400-1c26-11ea-949c-c2d8b777832f.png)  This prevents multipart files from being serialized by a configured WebClient: ``` org.springframework.core.codec.CodecException: No suitable writer found for part: input_image 	at org.springframework.http.codec.multipart.MultipartHttpMessageWriter.encodePart(MultipartHttpMessageWriter.java:299) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Request to PUT https://[redacted] [DefaultWebClient] Stack trace: 		at org.springframework.http.codec.multipart.MultipartHttpMessageWriter.encodePart(MultipartHttpMessageWriter.java:299) 		at org.springframework.http.codec.multipart.MultipartHttpMessageWriter.lambda$encodePartValues$4(MultipartHttpMessageWriter.java:252) ```","closed","type: regression,","totof3110","2019-12-11T23:03:54Z","2019-12-13T10:03:41Z"
"","23933","Allow schemaZip Gradle task to execute on MS Windows","Because of the different file separators in different operating systems, the schemazip task in Windows system cannot be executed. Now it has been repaired","closed","type: bug,","y987425112","2019-11-05T08:47:07Z","2019-11-15T01:29:24Z"
"","24711","Enhance Spring Core documentation, section 1.9.2. Using @Autowired","Based on version [5.2.4.RELEASE](https://docs.spring.io/spring/docs/5.2.4.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation), the documentation in section 1.9.2. Using @Autowired does not correspond to how a framework works in reality.  There is a highlighted note saying:  > Only one constructor of any given bean class may declare @Autowired with the required attribute set to true, indicating the constructor to autowire when used as a Spring bean. Furthermore, if  the required attribute is set to true, only a single constructor may be annotated with @Autowired. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public.  1) The `required` attribute is true by default - hence having `@Autowire` on some constructor means, you cannot declare it on any other constructors! One can say: unless you specify `required=false`, what actually does not make any difference (example below). 2)  The following part is not true and should be removed: > ... If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen...  Here is a simple code:  ``` @Service public class A { }  @Service public class B { }   @Service public class C {      private A a;     private B b;      @Autowired(required = false)     public C(A a) {         this.a = a;     }      @Autowired(required = false)     public C(B b) {         this.b = b;     }      @Autowired     public C(A a, B b) {         this.a = a;         this.b = b;     }  }  @Configuration @ComponentScan(basePackages = ""a.b.c"") public class Config { }  ``` And when I try to do `var ctx = new AnnotationConfigApplicationContext(Config.class);` I will get: > Exception in thread ""main"" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'c': Invalid autowire-marked constructor: public a.b.c.C(a.b.c.B). > Found constructor with 'required' Autowired annotation already: public a.b.c.C(a.b.c.A, a.b.c.B) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:339) .....  Based on this and the documentation, I'd say it is not possible to have `@Autowired` on multiple constructors.   - It would be nice to get the obsolete section removed. And @Autowire javadoc updated.  - If somehow it is possible - a real-world example to be added to the documentation.  - If there are any tests created based on this documentation (e.g. certification tests or something), it would be fair to have them revisited.  - If there are other (known) places saying that we can have multiple constructors with `@Autowired` - to be revisited as well.","closed","in: core,","ikos23","2020-03-17T11:59:22Z","2020-03-23T17:03:30Z"
"","24827","Recursively copy directory with symbolic link","Backport of gh-24823","closed","type: backport,","spring-projects-issues","2020-03-31T13:02:34Z","2020-04-03T19:58:59Z"
"","24826","Recursively copy directory with symbolic link","Backport of gh-24823","closed","type: backport,","spring-projects-issues","2020-03-31T13:02:27Z","2020-04-03T19:53:47Z"
"","24780","Using UriComponentsBuilder.cloneBuilder does not copy uriVariables","Backport of gh-24772","closed","type: backport,","spring-projects-issues","2020-03-25T18:02:32Z","2020-03-26T16:46:59Z"
"","24779","Using UriComponentsBuilder.cloneBuilder does not copy uriVariables","Backport of gh-24772","closed","type: backport,","spring-projects-issues","2020-03-25T18:02:23Z","2020-03-26T16:41:48Z"
"","24751","Missing nullability declarations for package web.socket.server.jetty","Backport of gh-24745","closed","type: backport,","spring-projects-issues","2020-03-20T22:46:49Z","2020-03-24T00:23:37Z"
"","24750","Missing nullability declarations for package web.socket.server.jetty","Backport of gh-24745","closed","type: backport,","spring-projects-issues","2020-03-20T22:46:36Z","2020-03-24T00:06:04Z"
"","24749","MediaTypeNotSupportedStatusException seems unused","Backport of gh-24743","closed","type: backport,","spring-projects-issues","2020-03-20T22:45:00Z","2020-03-24T00:23:37Z"
"","24748","MediaTypeNotSupportedStatusException seems unused","Backport of gh-24743","closed","type: backport,","spring-projects-issues","2020-03-20T22:44:52Z","2020-03-24T00:06:04Z"
"","24791","Illegal reflective access warning for interface-based lookup method injection","Backport of gh-24657","closed","type: backport,","spring-projects-issues","2020-03-26T13:43:41Z","2020-03-26T16:34:02Z"
"","24692","Spring generates huge callstack for async requests","Backport of gh-24652","closed","type: backport,","spring-projects-issues","2020-03-13T15:10:06Z","2020-03-23T23:48:50Z"
"","24640","addCandidateComponentsFromIndex should create ScannedGenericBeanDefinitions","Backport of gh-24638","closed","type: backport,","spring-projects-issues","2020-03-04T12:06:59Z","2020-03-13T22:52:08Z"
"","24639","addCandidateComponentsFromIndex should create ScannedGenericBeanDefinitions","Backport of gh-24638","closed","type: backport,","spring-projects-issues","2020-03-04T12:06:32Z","2020-03-13T22:43:31Z"
"","24584","Clarify AbstractResourceBasedMessageSource.setCacheMillis vs java.util.ResourceBundle","Backport of gh-24563","closed","type: backport,","spring-projects-issues","2020-02-24T17:40:55Z","2020-02-24T18:44:55Z"
"","24516","Consistent ROLE_INFRASTRUCTURE declarations for internal configuration classes","Backport of gh-24509","closed","type: backport,","spring-projects-issues","2020-02-12T16:42:56Z","2020-02-12T17:25:13Z"
"","24515","Consistent ROLE_INFRASTRUCTURE declarations for internal configuration classes","Backport of gh-24509","closed","type: backport,","spring-projects-issues","2020-02-12T16:42:46Z","2020-02-12T17:14:33Z"
"","24514","Consistent ROLE_INFRASTRUCTURE declarations for internal configuration classes","Backport of gh-24509","closed","type: backport,","spring-projects-issues","2020-02-12T16:14:27Z","2020-02-12T16:58:53Z"
"","24505","Update advice on RestTemplate","Backport of gh-24503","closed","type: backport,","spring-projects-issues","2020-02-11T14:08:11Z","2020-02-12T16:58:53Z"
"","24504","Update advice on RestTemplate","Backport of gh-24503","closed","type: backport,","spring-projects-issues","2020-02-11T14:07:58Z","2020-02-12T17:14:32Z"
"","24513","Raise log level for exceptions from EntityManager close call","Backport of gh-24501","closed","type: backport,","spring-projects-issues","2020-02-12T16:14:14Z","2020-02-12T16:58:53Z"
"","24542","AbstractJackson2Decoder is not aware of jackson's non-blocking parser only supporting UTF-8","Backport of gh-24489","closed","type: backport,","spring-projects-issues","2020-02-17T15:34:41Z","2020-02-20T10:30:46Z"
"","24500","MockRestServiceServer reset does not clear failedRequests","Backport of gh-24486","closed","","spring-projects-issues","2020-02-10T14:57:10Z","2020-02-10T14:58:36Z"
"","24487","BigDecimal in multi-value request body deserializes differently than single-value","Backport of gh-24479","closed","type: backport,","spring-projects-issues","2020-02-06T15:42:50Z","2020-02-07T13:56:21Z"
"","24462","Polish documentation format","Backport of gh-24460","closed","type: backport,","spring-projects-issues","2020-01-31T07:55:21Z","2020-02-12T14:53:03Z"
"","24449","Add Informix to supported database products for procedure calls","Backport of gh-24443","closed","type: backport,","spring-projects-issues","2020-01-28T11:47:06Z","2020-01-28T20:25:29Z"
"","24451","Cycle in LogAdapter.Log4jLog initialization within log appender","Backport of gh-24440","closed","type: backport,","spring-projects-issues","2020-01-28T12:15:13Z","2020-01-28T20:31:23Z"
"","24450","Cycle in LogAdapter.Log4jLog initialization within log appender","Backport of gh-24440","closed","type: backport,","spring-projects-issues","2020-01-28T12:15:03Z","2020-01-28T20:25:29Z"
"","24448","Solve ReflectPermission issue in sandbox security policy model for repackaged CGLIB ReflectUtils","Backport of gh-24420","closed","type: backport,","spring-projects-issues","2020-01-28T11:46:42Z","2020-01-28T20:25:29Z"
"","24387","Avoid setting special Content-* response headers in TomcatHeadersAdapter","Backport of gh-24361","closed","type: backport,","spring-projects-issues","2020-01-17T14:01:24Z","2020-01-20T12:14:04Z"
"","24362","IncompatibleClassChangeError encountered on execution of compiled SPEL expressions","Backport of gh-24357","closed","type: backport,","spring-projects-issues","2020-01-15T13:44:19Z","2020-02-12T14:53:03Z"
"","24343","Document Objenesis license in license.txt","Backport of gh-24340","closed","type: backport,","spring-projects-issues","2020-01-13T13:44:56Z","2020-01-13T15:20:40Z"
"","24342","Document Objenesis license in license.txt","Backport of gh-24340","closed","type: backport,","spring-projects-issues","2020-01-13T13:44:39Z","2020-01-13T15:21:18Z"
"","24341","Document Objenesis license in license.txt","Backport of gh-24340","closed","type: backport,","spring-projects-issues","2020-01-13T13:44:05Z","2020-01-13T15:21:13Z"
"","24346","StringDecoder buffer leak related to maxInMemorySize limit","Backport of gh-24339","closed","type: backport,","spring-projects-issues","2020-01-13T15:41:51Z","2020-01-14T08:06:41Z"
"","24330","Cloning a WebClient.Builder instance does not copy strategiesConfigurers","Backport of gh-24329","closed","type: backport,","spring-projects-issues","2020-01-10T14:49:16Z","2020-01-13T15:32:27Z"
"","24365","Include Objenesis NOTICE file contents in binary distributions","Backport of gh-24326","closed","type: backport,","spring-projects-issues","2020-01-15T13:45:18Z","2020-01-16T09:58:24Z"
"","24364","Include Objenesis NOTICE file contents in binary distributions","Backport of gh-24326","closed","type: backport,","spring-projects-issues","2020-01-15T13:45:09Z","2020-01-16T09:56:03Z"
"","24363","Include Objenesis NOTICE file contents in binary distributions","Backport of gh-24326","closed","type: backport,","spring-projects-issues","2020-01-15T13:44:59Z","2020-01-16T09:54:55Z"
"","24308","Unsafe double-checked locking in SpelExpression#compileExpression","Backport of gh-24265","closed","type: backport,","spring-projects-issues","2020-01-07T08:29:34Z","2020-01-10T14:05:18Z"
"","24307","Unsafe double-checked locking in SpelExpression#compileExpression","Backport of gh-24265","closed","type: backport,","spring-projects-issues","2020-01-07T08:29:24Z","2020-01-10T13:31:10Z"
"","24306","Unsafe double-checked locking in SpelExpression#compileExpression","Backport of gh-24265","closed","type: backport,","spring-projects-issues","2020-01-07T08:29:15Z","2020-01-09T15:18:44Z"
"","24284","Support headers with multiple values in ResponseStatusException","Backport of gh-24261","closed","type: backport,","spring-projects-issues","2020-01-02T14:56:43Z","2020-01-06T22:16:06Z"
"","24229","Ensure CORS processing does not add Vary header twice on async requests","Backport of gh-24223","closed","type: backport,","spring-projects-issues","2019-12-19T12:59:27Z","2020-01-06T22:16:06Z"
"","24230","Escape quotes in filename in ContentDisposition.Builder when charset not specified","Backport of gh-24220","closed","type: backport,","spring-projects-issues","2019-12-19T13:42:22Z","2020-01-07T07:18:37Z"
"","24224","Escape quotes in filename in ContentDisposition.Builder when charset not specified","Backport of gh-24220","closed","type: backport,","spring-projects-issues","2019-12-18T09:42:12Z","2020-01-06T22:16:06Z"
"","24217","Un-deprecate PathResource (for java.nio.file.Path resolution in createRelative)","Backport of gh-24211","closed","type: backport,","spring-projects-issues","2019-12-16T13:45:31Z","2019-12-16T16:06:52Z"
"","24209","ClassUtils.getInterfaceMethodIfPossible overhead in cached methods for SpEL key/condition expressions","Backport of gh-24206","closed","type: backport,","spring-projects-issues","2019-12-14T11:15:10Z","2019-12-16T16:06:52Z"
"","24412","JSON decoding error parsing stream encoded with Jackson Smile","Backport of gh-24198","closed","type: backport,","spring-projects-issues","2020-01-22T09:03:42Z","2020-01-28T13:29:41Z"
"","24202","ClientCodecConfigurer drops MultipartHttpMessageWriter.partWriters when mutated","Backport of gh-24194","closed","type: backport,","spring-projects-issues","2019-12-12T22:00:24Z","2019-12-13T10:03:32Z"
"","24154","Let UriUtils.encode…(…) methods optimize for sources without the need to be encoded","Backport of gh-24152","closed","type: backport,","spring-projects-issues","2019-12-06T16:26:17Z","2019-12-09T12:57:24Z"
"","24150","Support variable resolution of wildcard types","Backport of gh-24145","closed","type: backport,","spring-projects-issues","2019-12-06T12:48:44Z","2019-12-09T12:57:24Z"
"","24134","TOC generated by asciidoc for core-beans.adoc is truncated","Backport of gh-24132","closed","type: backport,","spring-projects-issues","2019-12-04T15:53:12Z","2019-12-04T16:07:31Z"
"","24754","Implementing interface in abstract class does not expose parameter annotations","Backport of gh-24127","closed","type: backport,","spring-projects-issues","2020-03-21T14:31:40Z","2020-03-24T00:06:04Z"
"","24201","Improve configuration API of ClientCodecConfigurer.CustomCodecs","Backport of gh-24124","closed","type: backport,","spring-projects-issues","2019-12-12T20:51:54Z","2019-12-13T09:57:51Z"
"","24182","StringHttpMessageConverter lost a fix that assumed charset UTF-8 for ""application/json""","Backport of gh-24123","closed","status: invalid,","spring-projects-issues","2019-12-10T16:58:48Z","2019-12-13T10:00:21Z"
"","24119","Provide default codecs config callback to custom codecs","Backport of gh-24118","closed","type: backport,","spring-projects-issues","2019-12-02T21:54:58Z","2019-12-02T22:17:53Z"
"","24148","ContentDisposition cannot parse encoded filename with leading space","Backport of gh-24112","closed","type: backport,","spring-projects-issues","2019-12-06T09:45:08Z","2019-12-13T09:57:52Z"
"","24109","Cache result of String.getBytes() in ExtendedBeanInfo.PropertyDescriptorComparator","Backport of gh-24072","closed","type: backport,","spring-projects-issues","2019-12-01T09:49:35Z","2019-12-01T10:07:46Z"
"","24095","Cache result of String.getBytes() in ExtendedBeanInfo.PropertyDescriptorComparator","Backport of gh-24072","closed","type: backport,","spring-projects-issues","2019-11-27T18:21:13Z","2019-12-01T00:03:45Z"
"","24061","Jackson2TokenizerTest is missing a call to verify","Backport of gh-24056","closed","type: backport,","spring-projects-issues","2019-11-22T16:30:53Z","2019-11-22T16:59:17Z"
"","24060","IOException ""Closed while Pending/Unready"" with WebFlux on Jetty","Backport of gh-24050","closed","type: backport,","spring-projects-issues","2019-11-22T15:27:35Z","2019-11-22T16:59:02Z"
"","24054","Revise AbstractBeanDefinition equals implementation","Backport of gh-24048","closed","type: backport,","spring-projects-issues","2019-11-21T17:22:28Z","2019-11-22T16:58:39Z"
"","24045","SqlRowSet accessor methods should be marked @Nullable","Backport of gh-24042","closed","type: backport,","spring-projects-issues","2019-11-20T14:56:48Z","2019-11-20T17:18:31Z"
"","24044","SqlRowSet accessor methods should be marked @Nullable","Backport of gh-24042","closed","type: backport,","spring-projects-issues","2019-11-20T14:56:37Z","2019-11-20T17:18:20Z"
"","24026","Avoid substring allocation in StringUtils.replace","Backport of gh-24023","closed","type: backport,","spring-projects-issues","2019-11-19T10:22:59Z","2019-11-19T14:56:08Z"
"","24025","Avoid substring allocation in StringUtils.replace","Backport of gh-24023","closed","type: backport,","spring-projects-issues","2019-11-19T10:22:52Z","2019-11-19T14:55:43Z"
"","24024","Avoid substring allocation in StringUtils.replace","Backport of gh-24023","closed","type: backport,","spring-projects-issues","2019-11-19T10:22:45Z","2019-11-19T14:25:46Z"
"","24018","ControllerAdviceBean.findAnnotatedBeans() finds proxies as well as their target beans, resulting in double registration","Backport of gh-24017","closed","type: backport,","spring-projects-issues","2019-11-18T16:43:28Z","2019-11-19T14:24:03Z"
"","24076","NullPointerException in JSON codec parsing stream encoded with Jackson Smile","Backport of gh-24009","closed","type: backport,","spring-projects-issues","2019-11-25T15:15:54Z","2019-11-25T15:42:53Z"
"","24001","TypeDescriptor#getElementTypeDescriptor does not throw IllegalStateException anymore","Backport of gh-23996","closed","type: backport,","spring-projects-issues","2019-11-14T17:50:01Z","2019-11-14T17:52:24Z"
"","23998","TypeDescriptor#getElementTypeDescriptor does not throw IllegalStateException anymore","Backport of gh-23996","closed","type: backport,","spring-projects-issues","2019-11-14T12:39:18Z","2019-11-14T17:52:36Z"
"","23997","TypeDescriptor#getElementTypeDescriptor does not throw IllegalStateException anymore","Backport of gh-23996","closed","type: backport,","spring-projects-issues","2019-11-14T12:38:42Z","2019-11-14T17:52:46Z"
"","23975","Support for new MySQL 8 error code 3572","Backport of gh-23972","closed","type: backport,","spring-projects-issues","2019-11-11T13:48:04Z","2019-11-13T17:12:00Z"
"","23974","Support for new MySQL 8 error code 3572","Backport of gh-23972","closed","type: backport,","spring-projects-issues","2019-11-11T13:47:56Z","2019-11-13T16:45:26Z"
"","23973","Support for new MySQL 8 error code 3572","Backport of gh-23972","closed","type: backport,","spring-projects-issues","2019-11-11T13:46:11Z","2019-11-13T15:54:33Z"
"","24106","Allow ExchangeStrategies customizations in WebClient","Backport of gh-23961","closed","type: backport,","spring-projects-issues","2019-11-29T21:55:34Z","2019-12-02T17:11:24Z"
"","23964","DEFAULT_PHASE of SmartLifecycle interface has incorrect Javadoc","Backport of gh-23956","closed","type: backport,","spring-projects-issues","2019-11-09T16:55:34Z","2019-11-09T17:04:28Z"
"","23990","Different behavior when injecting beans from local @Configuration class vs. external @Configuration classes","Backport of gh-23934","closed","type: backport,","spring-projects-issues","2019-11-13T15:44:07Z","2019-11-13T15:54:33Z"
"","23989","Allow schemaZip Gradle task to execute on MS Windows","Backport of gh-23933","closed","type: backport,","spring-projects-issues","2019-11-13T13:29:41Z","2019-11-13T14:17:48Z"
"","23988","Allow schemaZip Gradle task to execute on MS Windows","Backport of gh-23933","closed","type: backport,","spring-projects-issues","2019-11-13T13:29:32Z","2019-11-13T14:11:21Z"
"","23987","Allow schemaZip Gradle task to execute on MS Windows","Backport of gh-23933","closed","type: backport,","spring-projects-issues","2019-11-13T13:29:23Z","2019-11-13T14:09:43Z"
"","23928","ResponseCookie to allow leading dot in domain name","Backport of gh-23924","closed","type: backport,","spring-projects-issues","2019-11-04T16:58:48Z","2019-11-06T21:33:15Z"
"","23926","Correct Javadoc for WebMvcConfigurer#addInterceptors","Backport of gh-23922","closed","type: backport,","spring-projects-issues","2019-11-04T15:48:14Z","2019-11-19T10:15:40Z"
"","23913","Correct Javadoc for WebMvcConfigurer#addInterceptors","Backport of gh-23922","closed","type: backport,","spring-projects-issues","2019-11-03T11:21:20Z","2019-11-19T10:16:18Z"
"","23920","Regression in spring-test's 5.2.1 MockCookie parse implementation","Backport of gh-23911","closed","type: backport,","spring-projects-issues","2019-11-04T11:25:21Z","2019-11-06T21:30:12Z"
"","23919","useSuffixPatternMatch ignored if pathPrefix is also used","Backport of gh-23907","closed","type: backport,","spring-projects-issues","2019-11-04T11:10:57Z","2019-11-06T21:08:08Z"
"","23993","Ensure InstantFormatter can properly deserialize ISO-formatted dates","Backport of gh-23895","closed","type: backport,","spring-projects-issues","2019-11-14T09:08:08Z","2019-11-14T12:11:46Z"
"","23896","Reorder date formatting converter in registrar","Backport of gh-23893","closed","type: backport,","spring-projects-issues","2019-10-30T15:55:50Z","2019-10-30T16:35:19Z"
"","23885","Support for limits on input stream processing in WebFlux codecs","Backport of gh-23884","closed","type: backport,","spring-projects-issues","2019-10-29T11:48:25Z","2019-10-30T09:51:55Z"
"","23894","Race condition affecting performance in AbstractJaxb2HttpMessageConverter - JAXBContext creation","Backport of gh-23879","closed","type: backport,","spring-projects-issues","2019-10-30T13:33:08Z","2019-10-30T15:46:18Z"
"","23831","Incorrect value of the MediaType.APPLICATION_PROBLEM_JSON_UTF8","Backport of gh-23825","closed","type: backport,","spring-projects-issues","2019-10-18T09:53:19Z","2019-10-30T10:23:56Z"
"","23941","ShallowETagHeaderFilter overwrites ETag","Backport of gh-23775","closed","type: backport,","spring-projects-issues","2019-11-06T15:36:46Z","2019-11-06T21:33:31Z"
"","23881","Preserve expires attribute in MockCookie","Backport of gh-23769","closed","type: backport,","spring-projects-issues","2019-10-28T17:56:17Z","2019-10-29T12:59:34Z"
"","23948","Corrupted multipart + correct content-length lead to Flux hanging","Backport of gh-23768","closed","type: backport,","spring-projects-issues","2019-11-07T15:47:55Z","2019-12-03T11:21:02Z"
"","23888","MockServletContext should treat InvalidPathException like an IOException","Backport of gh-23717","closed","type: backport,","spring-projects-issues","2019-10-29T16:59:40Z","2019-10-30T15:22:51Z"
"","23947","Improve Javadoc of ContentNegotiationManagerFactoryBean","Backport of gh-23409","closed","type: backport,","spring-projects-issues","2019-11-07T13:35:55Z","2019-11-11T12:12:19Z"
"","24181","WebFlux documentation states incorrectly that BindingResult is supported after @RequestBody","Backport of gh-22997","closed","type: backport,","spring-projects-issues","2019-12-10T16:55:38Z","2019-12-13T09:57:52Z"
"","24553","BeanPostProcessor can eagerly initialize factory beans that use constructor injection","Auto configuration of `MethodValidationPostProcessor` in class `org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration` requires instance of Environment. Since the envirnonemt does not have `@Lazy` annotation it triggers autowire candidate resolution with `lazyInit=true` which in turn results in initialization of (at least) FactoryBeans.  Bean post processors should NOT use autowiring since the beans created just to check that they do not implement Environment are later not eligible for all other bean post processors - which is actually confirmed in log by lots of:  ``` Bean 'xxx' of type [XXX] is not eligible for getting processed by all BeanPostProcessors ```  I have implemented custom `ImportBeanDefinitionRegistrar`. When I use it like this:  ```java @SpringBootApplication @Import(GenesysRegistrar.class) public class IntegrationServer { ... } ```  everything works fine. But if I create my own auto-configuration class:  ```java @Configuration @Import(GenesysRegistrar.class) public class GenesysAutoConfiguration { } ```  then bean definitions registered by `GenesysRegistrar` are created BEFORE `MethodValidationPostProcessor` during search for bean implementing Environment interface.","open","in: core,","AlesD","2020-02-18T16:01:26Z","2021-11-10T11:58:05Z"
"","23895","Ensure InstantFormatter can properly deserialize ISO-formatted dates","At the moment `InstantFormatter` can serialize an `Instant` that is far in the future (or in the past), but cannot properly deserialize it, because in this case ISO-formatted instant will start with `+`/`-`-sign. This PR fixes this issue, while maintaining the previous contract. Also, it introduces tests for `InstantFormatter` :slightly_smiling_face:","closed","in: core,","monosoul","2019-10-30T14:18:19Z","2019-11-14T09:08:07Z"
"","24372","Failure to bind a component of a form backing object using constructor binding causes the object to be null","Assuming a form backing object:  ```java class Form {    private final LocalDate date;   private final LocalTime time;    public Form(LocalDate date, LocalTime time) {     this.date = date;     this.time = time;   }    // Getters omitted } ```  and a controller method  ```java class FormController {    @PostMapping(""/form"")   String postForm(@ModelAttribute Form form, BindingResult result) {     …   } } ```  If the there's a binding error for one of the components of `Form`, `form` will be `null` which is unexpected as the binding invalidly assumes that `Form` is not able to deal with `null` values for its components.  In contrast to binding via setters, it's not really possible to use the partially bound instance to redisplay the form even partially bound. I've also tried to explicitly annotate the constructor arguments with `@Nullable` but that doesn't seem to change anything.","closed","type: enhancement,","odrotbohm","2020-01-15T22:13:10Z","2020-09-01T17:13:19Z"
"","24734","WebClient decodes string array as one string","Assume we have an endpoint that returns string array, like this (ContentType is application/json) ```json [""a"",""a"",""a""] ``` and retrieve it's response as `Flux` ```java webClient.get().uri().retrieve() .bodyToFlux(String.class) .subscribe(s -> println(s)) ``` In my opinion, it should print ""a"" for three times, but only prints `[""a"",""a"",""a""]`. However, **there is a workaround**, we can replace `String.class` with `String[].class`, but the result returned in semantic isn't a `Flux` anymore, but a `Mono`. (The version of Spring Webflux is 5.2.3-RELEASE)","closed","status: declined,","bringyou","2020-03-19T07:50:42Z","2021-05-27T05:49:11Z"
"","24356","continue for loop if the bean definition cannot be enhanced","As the log says, `Cannot enhance @Configuration bean definition since its singleton instance has been created too early. The typical cause is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor`. So, I think this `if` block should `continue` for loop.","open","in: core,","chenqimiao","2020-01-14T13:58:29Z","2021-04-27T05:06:12Z"
"","24355","Upgrade to Reactor Dysprosium SR5","As part of upgrade arounds for: * https://github.com/reactor/reactor-netty/issues/948 in `ErrorHandlerIntegrationTests` * https://github.com/reactor/reactor-core/issues/1925 (if available) in `StringDecoder`","closed","type: dependency-upgrade,","rstoyanchev","2020-01-14T12:30:56Z","2020-02-24T17:09:20Z"
"","24788","Connection leak with WebClient retrieve().toBodilessEntity()","As part of investigation for https://github.com/reactor/reactor-netty/issues/1041, it was uncovered that `retrieve().toBodilessEntity()` leaves the connection active, and subsequent requests cause the number of active connections to grow.  This is due to a (no-op) call to `response.releaseBody()` from `doOnNext` in `DefaultWebClient`.","closed","type: bug,","rstoyanchev","2020-03-26T10:41:07Z","2020-03-26T16:00:53Z"
"","23985","Regression: ControllerAdviceBean#getOrder() causes BeanCreationException for request scoped advice beans","As of Spring Framework 5.2, the way of define order value is changed. https://github.com/spring-projects/spring-framework/commit/9239ab1891385a389a1dea68e703b153eb5d9a66#diff-e6efe5c07f3b7003d9229a7140948cebL120 https://github.com/spring-projects/spring-framework/commit/9239ab1891385a389a1dea68e703b153eb5d9a66#diff-e6efe5c07f3b7003d9229a7140948cebL243-L249  But This change breaks backward compatibility, https://github.com/spring-projects/spring-framework/commit/9239ab1891385a389a1dea68e703b153eb5d9a66#diff-e6efe5c07f3b7003d9229a7140948cebR136-R147  In this method, order will be decided by Spring component instance primary, But before Spring Framework 5.2.0, order will be decided from bean type if beanType is not null. In Spring Framework 5.2,   1. org.springframework.web.method.ControllerAdviceBean#getOrder is called in spring initialize phase    (Thread of initialize phase is request or session scope) 2. thread of initialize get order of component with trying initiate component via BeanFactory 3. BeanFactory throws Exception because thread of (2) is different from `@Scope` annotated component(ex. scope is like request, session...etc)  If I integrate my applicaiton with Spring Boot 2.2.1, Application won't be failed to start.  ``` 2019-11-13 07:43:05,313 ERROR [] [main] [N/A] SpringApplication - Application run failed org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Jetty web server 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:156) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:544) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) 	at  Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Jetty web server 	at org.springframework.boot.web.embedded.jetty.JettyWebServer.initialize(JettyWebServer.java:114) 	at org.springframework.boot.web.embedded.jetty.JettyWebServer.(JettyWebServer.java:86) 	at org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory.getJettyWebServer(JettyServletWebServerFactory.java:401) 	at (:59) 	at org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory.getWebServer(JettyServletWebServerFactory.java:155) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:180) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:153) 	... 7 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter': Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '': Scope 'request' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request. 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1803) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) 	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401) 	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292) 	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103) 	at ContextLoaderListener.contextInitialized(.java:23) 	at org.eclipse.jetty.server.handler.ContextHandler.callContextInitialized(ContextHandler.java:921) 	at org.eclipse.jetty.servlet.ServletContextHandler.callContextInitialized(ServletContextHandler.java:554) 	at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:888) 	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:357) 	at org.eclipse.jetty.webapp.WebAppContext.startWebapp(WebAppContext.java:1443) 	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1407) 	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:821) 	at org.eclipse.jetty.servlet.ServletContextHandler.doStart(ServletContextHandler.java:276) 	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:524) 	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72) 	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169) 	at org.eclipse.jetty.server.Server.start(Server.java:407) 	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110) 	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:106) 	at org.eclipse.jetty.server.Server.doStart(Server.java:371) 	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72) 	at org.springframework.boot.web.embedded.jetty.JettyWebServer.initialize(JettyWebServer.java:108) 	... 13 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '': Scope 'request' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request. 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:368) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108) 	at org.springframework.web.method.ControllerAdviceBean.resolveBean(ControllerAdviceBean.java:173) 	at org.springframework.web.method.ControllerAdviceBean.getOrder(ControllerAdviceBean.java:139) 	at org.springframework.core.OrderComparator.findOrder(OrderComparator.java:146) 	at org.springframework.core.OrderComparator.getOrder(OrderComparator.java:129) 	at org.springframework.core.OrderComparator.getOrder(OrderComparator.java:117) 	at org.springframework.core.OrderComparator.doCompare(OrderComparator.java:87) 	at org.springframework.core.OrderComparator.compare(OrderComparator.java:73) 	at java.util.TimSort.countRunAndMakeAscending(TimSort.java:355) 	at java.util.TimSort.sort(TimSort.java:220) 	at java.util.Arrays.sort(Arrays.java:1512) 	at java.util.ArrayList.sort(ArrayList.java:1462) 	at org.springframework.core.OrderComparator.sort(OrderComparator.java:175) 	at org.springframework.web.method.ControllerAdviceBean.findAnnotatedBeans(ControllerAdviceBean.java:238) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.initControllerAdviceCache(RequestMappingHandlerAdapter.java:580) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.afterPropertiesSet(RequestMappingHandlerAdapter.java:559) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1862) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1799) 	... 43 common frames omitted ```  So It is good, try to decide order by beanType primarily, I think.","closed","type: regression,","yokotaso","2019-11-13T08:50:27Z","2019-11-19T01:53:42Z"
"","24538","Configure quiet period for shutting down Netty resources","As of reactor/reactor-netty#860, Reactor Netty allows to configure the quiet period when disposing of the Netty resources.  We should expose this as an option in `ReactorResourceFactory`, as the default quiet period of 2 seconds can be a problem in test suites or while developing an application (e.g. Spring Boot devtools).","closed","type: enhancement,","bclozel","2020-02-17T10:06:22Z","2020-02-24T17:16:17Z"
"","24118","Provide default codecs config callback to custom codecs","As of #23961, developers can now configure `ExchangeStrategies` and the underlying codec infrastructure without overriding other preferences. Some of those preferences, like limit on buffer sizes and logging request details are only applied to default codecs, as custom codecs might have different opinions.  We now need to let custom codecs know about those opinions set on the defaults, otherwise they would have no chance to align there if they wanted to.","closed","type: enhancement,","bclozel","2019-12-02T20:41:54Z","2019-12-02T21:55:22Z"
"","24509","Consistent ROLE_INFRASTRUCTURE declarations for internal configuration classes","As indicated by #24508, we inconsistently use `@Role(BeanDefinition.ROLE_INFRASTRUCTURE)` at the class level of our internal configuration classes: not only affecting `ProxyTransactionManagementConfiguration` but also AspectJ configuration variants as well as `LoadTimeWeavingConfiguration` and `MBeanExportConfiguration`. We should sort this out for good and also backport it, even for cases where it does not cause a regression in terms of warn log entries.","closed","type: enhancement,","jhoeller","2020-02-12T14:07:43Z","2020-02-12T16:42:56Z"
"","23865","Specify params of @PostMapping based on @RequestBody","As described in [this question](https://stackoverflow.com/questions/58522021/distinguish-spring-boot-postmapping-based-on-key-in-requestbody/58522430#58522430), I'd like to be able to use the params value of the PostMapping to distinguish between two endpoins based on existence of a key in the body.  ```Java @PostMapping(value = ""/classes"", params = {""specialKey""}) public ResponseEntity createClass(@Valid @RequestBody SpecialClass class) throws URISyntaxException {     // do something special }  @PostMapping(""/classes"") public ResponseEntity createClass(@Valid @RequestBody Class class) throws URISyntaxException {     // do something } ```","closed","status: declined,","Evertude","2019-10-24T14:49:12Z","2019-10-29T18:07:51Z"
"","24238","Remove Content-* response headers before error handling in WebFlux","As a follow up of #22034 and other related issues, we should clear all `Content-*` response headers in case of errors, if the response is not committed already.  In this case, we need to remove all assumptions about the response that was going to be written when the error happened. WebFlux error handlers may write a very different response body, or not response body at all.  We should then remove the following headers, in `AbstractServerHttpResponse`: * `Content-Length` (already done in `AbstractServerHttpResponse` * `Content-Type` (already done in `RequestMappingHandlerAdapter`, this should move to the response itself) * `Content-Disposition` * `Content-Encoding` * `Content-Location` * `Content-Language` * `Content-Range`","closed","type: enhancement,","bclozel","2019-12-20T10:43:51Z","2020-01-06T16:07:01Z"
"","24644","Sort detected PersistenceExceptionTranslator beans","Apply sorting on detected `PersistenceExceptionTranslators`.  Relates to #24634","closed","type: enhancement,","ttddyy","2020-03-05T01:53:18Z","2021-01-20T23:00:22Z"
"","24572","fix missing backtick typo","append backtick","closed","status: superseded,","moonchanyong","2020-02-23T03:22:23Z","2020-02-24T14:11:36Z"
"","24835","Cannot dispatch without an AsyncContext when an expected error is thrown","An `IllegalArgumentException` is thrown when an expected error occurs during the execution of a `StreamingResponseBody`. For example:  ```java @GetMapping(""/read"") public ResponseEntity read(@RequestHeader Map headers) {     return new ResponseEntity<>(outputStream -> {         throw new IOException(""error"");     }, HttpStatus.OK); } ``` Produces the following log entry: ``` 2020-04-01 06:37:33.897  WARN 71407 --- [nio-8080-exec-2] o.apache.catalina.core.AsyncContextImpl  : onError() call failed for listener of type [org.apache.catalina.core.AsyncListenerWrapper]  java.lang.IllegalArgumentException: Cannot dispatch without an AsyncContext 	at org.springframework.util.Assert.notNull(Assert.java:198) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.dispatch(StandardServletAsyncWebRequest.java:131) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.context.request.async.WebAsyncManager.setConcurrentResultAndDispatch(WebAsyncManager.java:391) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.context.request.async.WebAsyncManager.lambda$startCallableProcessing$2(WebAsyncManager.java:315) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.lambda$onError$0(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) ~[na:na] 	at org.springframework.web.context.request.async.StandardServletAsyncWebRequest.onError(StandardServletAsyncWebRequest.java:146) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.apache.catalina.core.AsyncListenerWrapper.fireOnError(AsyncListenerWrapper.java:49) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.catalina.core.AsyncContextImpl.setErrorState(AsyncContextImpl.java:422) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:239) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:237) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.33.jar:9.0.33] 	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na] ```  The expected `IOException` is handled well during the execution, and on the client side, a well formed JSON with the expected error payload is received. However, the error is adding noise to the log entry.","closed","type: bug,","frankgh","2020-04-01T13:46:35Z","2021-01-30T08:46:52Z"
"","24517","Compatibility with JDK 15","Along the lines of #24453, this issue aims to track JDK 15 compatibility.  For the time being (i.e., during the 5.2.x time frame), we'll simply set up a CI build compiling and executing tests against JDK 15 early access builds.","closed","in: core,","sbrannen","2020-02-12T20:30:59Z","2020-09-08T15:20:49Z"
"","24367","Expose property for handling of Ping frames with Reactor Netty WebSocket client and server","Allow configuration of ping frame handling for client and server via the `proxyPing` property.  Closes gh-24331","closed","type: enhancement,","JacobASeverson","2020-01-15T14:53:46Z","2020-01-16T16:06:57Z"
"","24602","Update core-aop.adoc","Align Kotlin example with Java code.","closed","in: core,","AndreasVolkmann","2020-02-26T16:51:23Z","2020-02-26T21:00:05Z"
"","23911","Regression in spring-test's 5.2.1 MockCookie parse implementation","After upgrading to Spring 5.2.1 many unit tests mocking responses using Spring's `MockHttpServletResponse` which set a `Set-Cookie` header including `Expires=0` suddenly fail like this:  ``` java.time.format.DateTimeParseException: Text '0' could not be parsed at index 1 	at java.base/java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:2046) 	at java.base/java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1948) 	at java.base/java.time.ZonedDateTime.parse(ZonedDateTime.java:598) 	at org.springframework.mock.web.MockCookie.parse(MockCookie.java:122) ```  The reason seems to be the current implementation of following new feature: **Preserve expires attribute in MockCookie #23769**, which according to my understanding does not correctly handle all `Cookie` attribute values of the `Expires` attribute.  See also [RFC 2616 14.21](https://tools.ietf.org/html/rfc2616#section-14.21), [RFC 6265 5.3](https://tools.ietf.org/html/rfc6265#section-5.2.1), and [RFC 7234 5.3](https://tools.ietf.org/html/rfc7234#section-5.3).  > A cache recipient MUST interpret invalid date formats, especially the value ""0"", as representing a time in the past (i.e., ""already expired"").  Relevant commit introducing the regression: 9b2087618bba6cd546066e2f27deb166f6870a64  I think a parse error should at least be caught and ignored here.","closed","type: regression,","e-hubert","2019-11-02T21:45:08Z","2019-11-06T17:30:33Z"
"","23840","Make Kotlin functions accessible in CoroutinesUtils","After updating to spring-webflux 5.2 i noticed that `@ExceptionHandler`'s in private Kotlin-Classes stopped working.  After debbuging I found that this regression was introduced with kotlin-coroutines support for reactive Webflux and reactive Messaging handlers.   The Problem is that when converting Java methods to Kotlin functions the information if a method is accessible or not will not be copied and the Kotlin function has to be made accessible again via its `isAccessible` setter.  For this I introduced a new very simple `KotlinReflectionUtils` class which both `InvocableHandlerMethod's` use when Kotlin is available. I'm not 100% sure if this is the best solution and if its worth to introduce a new utils class for this.","closed","in: web,","mgmeiner","2019-10-21T12:34:59Z","2022-02-14T09:57:02Z"
"","27503","Websocket broker disconnects when client enable heartbeats","After a spring boot websocket client connects to the websocket spring boot server, the server send some heartbeats, and then after some minutes in the trace logs shows ""Connection to broker closed."". Removing setTaskScheduler() from the client seems to work without problems.   Websocket client with SockJsClient and heartbeats enabled. Websocket server with enableStompBrokerRelay() (ActiveMQ) and withSockJS()  Here a POC with the client and server, it needs a ActiveMQ broker: https://github.com/rd-o/websocket-spring-boot-bug","open","in: web,","rd-o","2020-01-02T21:18:02Z","2021-11-10T11:43:13Z"
"","24348","Inconsistent bean validation behavior on nested objects","Affects: Spring 5.0.9 / Boot 2.0.5  We have a Spring Web Mvc REST service implemented using DTO models which are validated using `@Valid` on controller method signatures. Those DTO models had simple public fields like `String, Instant` etc. and validation worked fine. Then we introduced nested complex objects and referenced them via `@Valid` from the root object. After that we encountered, that Spring was complaining about not being able to find bean properties for the complex objects. After we setup the controllers using direct field access via `@InitBinder` that started to work again.  The first question that came up was: why is there inconsistent behavior? The binding of public simple fields without getter/setters is apparently working with the default (=bean property binding) config. But as soon as someone is adding nested complex objects, it starts to fail. This seems at least odd to us. Is this expected behavior?  What we also encountered is, if those complex nested objects, are ""after"" a collection, like a `Set` or `List`, in the object graph, validation still seems to work properly (using public fields, without having to enable direct field access). Is this a known issue or a bug?","open","in: web,","vghero","2020-01-13T16:02:06Z","2021-11-12T14:08:43Z"
"","24813","RestController returning JSON String producing incorrect Content-Type charset","Affects: 5.2.2.RELEASE (via spring-boot-starter 2.2.2.RELEASE - but would also affect the ""master"")  Hi,  I do have a `@RestController`  annotated class which looks like this (removed any unrelevant things):  ```java import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  @RestController @RequestMapping(""/api/cart"") public class CartApiController {     @GetMapping(path = ""/get"", produces = MediaType.APPLICATION_JSON_VALUE)     public String getCart() {         return ""{success: true}"";     } } ```  that method getCart() is supposed to return ""application/json"" content type. If I check that within a browser, I find the follwing response header:  ![2020-03-30_10h06_50](https://user-images.githubusercontent.com/2911492/77889489-35096a80-726e-11ea-83c3-b2e8f47f5ea7.png)  **application/json;charset=ISO-8859-1**  which is not right to my understanding.  I think, I have tracked it down to the following class:  https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java  Where on line 49 it states  `	public static final Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;`  which causes this issue.  Our workaorund at the moment is to use the following annotation config insteadwhich enforces UTF-8: `@GetMapping(path = ""/get"", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)`  but that makes use of a deprecated (due to #22788) field , which we don't want to do obviously.  Is this supposed to be like that and if not can you maybe fix this?  Thanks and best regards.","closed","in: web,","OmarHawk","2020-03-30T08:14:56Z","2020-03-30T14:13:55Z"
"","24078","oracle timestamp with local time zone type query result with JdbcTemplate not readable","Affects: 5.2.0.RELEASE ``` import java.util.List; import java.util.Map; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.datasource.DriverManagerDataSource;  public class Test {    public static void main(String[] args) {     String host = """";     int port = 1521;     String username = """";     String password = """";      DriverManagerDataSource dataSource = new DriverManagerDataSource();     dataSource.setDriverClassName(""oracle.jdbc.driver.OracleDriver"");     dataSource.setUrl(String.format(""jdbc:oracle:thin:@%s:%d:orcl"", host, port));     dataSource.setUsername(username);     dataSource.setPassword(password);      JdbcTemplate template = new JdbcTemplate(dataSource);     try {       template.execute(           ""create table ORACLE_TIMESTAMPLTZ\n""               + ""(\n""               + ""    timestamp TIMESTAMP(6),\n""               + ""    timestampltz TIMESTAMP(6) WITH LOCAL TIME ZONE\n""               + "")"");     } catch (Exception e) {     }      template.execute(         String.format(""insert into %s.ORACLE_TIMESTAMPLTZ values (sysdate,sysdate)"", username));      List> result =         template.queryForList(String.format(""select * from %s.ORACLE_TIMESTAMPLTZ"", username));      System.out.println(result);     //  output     //    [{TIMESTAMP=2019-11-26 10:31:21.0, TIMESTAMPLTZ=oracle.sql.TIMESTAMPLTZ@22c86919}]     // expected a result like TIMESTAMP   } } ```","closed","for: stackoverflow,","wangxufire","2019-11-26T02:43:37Z","2019-11-26T08:28:28Z"
"","24663","Ignore empty domain string in ResponseCookie","Affects `v5.2.4.RELEASE`, though I think response cookie validation was added in `v5.2.x`.  We're calling a 3rd party service that returns a `Set-Cookie` header with a `domain=""""` value. This is non-compliant with [rfc6265](https://tools.ietf.org/html/rfc6265) so _is_ technically wrong.  However, Spring's now throwing an exception when encountering this header, so the entire request fails and the application is unable to consume the response.  Is this intended behaviour? I think in this case Spring should [""be conservative in what it does, be liberal in what it accepts from others""](https://en.wikipedia.org/wiki/Robustness_principle).","closed","type: enhancement,","34875634567","2020-03-09T12:36:34Z","2020-03-12T12:23:36Z"
"","24431","@PreDestroy methods: messages logged with logback are lost","Affected: Spring MVC: 5.2.2 (and older most likely) Logback Version: 1.2.3  When using SLF4J with logback to log in a `@PreDestroy` method of a `@Service` class, the messages are lost because apparently logback shuts itself down before the user's `@PreDestroy` methods complete. Its easy to not notice the missing logs for a while.  The current workaround is to disable the servlet lifecycle feature of logback. Ideally either Spring or Logback would figure out when to shut Logback down without users having to workaround this (btw, i don't know if the current workaround has any negative effects like preventing proper Logback shutdown).  This is basically the same issue as: https://stackoverflow.com/questions/47184045/spring-predestroy-no-logging-because-logback-stops-too-soon and similar to (but for Spring instead of Spring Boot and logback instead of Log4j2): https://github.com/spring-projects/spring-boot/issues/11360","closed","","Katharsas","2020-01-26T22:59:05Z","2020-02-10T17:26:06Z"
"","23907","useSuffixPatternMatch ignored if pathPrefix is also used","Affected version: 5.1.8  I am trying to disable suffix pattern matching so that PathVariables containing dots will not be truncated. The [documented solution](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match) for this problem  `webMvcConfigurer.setUseSuffixPatternMatch(false)`  works fine, but it breaks if I also try to add a path prefix  `webMvcConfigurer.addPathPrefix(""/api"", HandlerTypePredicate.forAnnotation(RestController.class))`  The problem is in PatternsRequestCondition.combine(PatternRequestCondition other) at line 179. Here the useSuffixPatternMatch on my url is ignored in favor of the value on the '/api' Condition create at RequestMappingHandlerMapping.228  RequestMappingHandlerMapping.java ```java @Override @Nullable protected RequestMappingInfo getMappingForMethod(Method method, Class handlerType) { 		RequestMappingInfo info = createRequestMappingInfo(method); 	if (info != null) { 		RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType); 		if (typeInfo != null) { 			info = typeInfo.combine(info); 		} 		String prefix = getPathPrefix(handlerType); 		if (prefix != null) {                         // PROBLEM HERE 			info = RequestMappingInfo.paths(prefix).build().combine(info);** 		} 	} 	return info; } ``` PatternsRequestCondition.java ```java @Override public PatternsRequestCondition combine(PatternsRequestCondition other) { 	Set result = new LinkedHashSet<>(); 	if (!this.patterns.isEmpty() && !other.patterns.isEmpty()) { 		for (String pattern1 : this.patterns) { 			for (String pattern2 : other.patterns) { 				result.add(this.pathMatcher.combine(pattern1, pattern2)); 			} 		} 	} 	else if (!this.patterns.isEmpty()) { 		result.addAll(this.patterns); 	} 	else if (!other.patterns.isEmpty()) { 		result.addAll(other.patterns); 	} 	else { 		result.add(""""); 	}         // PROBLEM HERE 	return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, 			this.useSuffixPatternMatch, this.useTrailingSlashMatch, this.fileExtensions); } `","closed","type: bug,","tpischke-bedag","2019-11-01T12:28:20Z","2019-11-06T21:06:36Z"
"","24728","Support for X-Forwarded-Prefix in UrlComponentsBuilder","Adds support in UriComponentsBuilder to handle X-Forwarded-Prefix header used by reverse proxies to specify the segment of the URL path that has been stripped by that reverse proxy. It is especially useful in conjunction with the X-Forwarded-Host header for building location-dependent content such as HATEOAS links, where the generated links should direct the client to further resources via the proxy rather than the target server.  The ForwardedHeaderTransformer does not need to handle the X-Forwarded-Prefix header as a special case as it is now handled by the UrlComponentsBuilder.  Closes #24723","closed","status: declined,","stuartwakefield","2020-03-18T22:53:08Z","2020-03-19T11:40:30Z"
"","24428","Test ObjectUtils.containsElement()","Added test code for object utils.","closed","type: task,","hyeonisism","2020-01-25T02:51:31Z","2020-02-09T14:42:51Z"
"","24518","Added  debug logging to DefaultWebSessionManager","Added some debug logs regarding session expiration to the DefaultWebSessionManager.","closed","type: task,","pulse00","2020-02-13T07:40:23Z","2020-02-20T15:59:29Z"
"","23903","kotlin message converter extensions","Added kotlin message converter extension functions","open","in: messaging,","sokomishalov","2019-10-31T22:25:52Z","2021-11-12T13:42:45Z"
"","24661","added HttpHeaders.CONTENT_ID","Added HTTP Header `Content-ID` as per [RFC 2392](https://tools.ietf.org/html/rfc2392)","closed","status: declined,","alan-czajkowski","2020-03-09T03:31:11Z","2020-03-12T12:39:46Z"
"","24351","Add tests for StringUtils split() method","Add test code split method","closed","in: core,","hyeonisism","2020-01-14T01:35:44Z","2020-01-16T15:31:35Z"
"","24314","Ignore range requests for resources of unknown content lengths","Add support for unknown content lengths.  One use case is: Currently there is no way to ignore Range requests for Resources that are not specifically InputStreamResource (not even its subclasses). The crux of the matter is that we are trying to ignore Range requests for streams whose content lengths cannot be determined, instead we do it in a roundabout way by excluding specifically InputStreamResource.  For instance: - I have a custom InputStream that needs to ignore Range requests. It additionally needs to be lazily initialized (i.e. only when the Resource.getInputStream() is called). Its content length is unknown. - Cannot use any other Resource class other than InputStreamResource because they all will try accepting Range requests and when the content length is unknown, will throw 416s. - Cannot put the stream in InputStreamResource because of the lazy instantiation requirement - Cannot subclass InputStreamResource and override the getInputStream() method because the subclass will now accept Range requests and throw a 416  This PR excludes Resources with unknown content lengths from trying to do Partial Range support (which only results in 416s, instead of just a 200 with a full resource)  A more complete redesign would allow the unknown lengths partial support, perhaps using ""*"" in the Content-Range header","closed","type: enhancement,","randomnicode","2020-01-07T19:28:21Z","2021-12-03T10:05:55Z"
"","24406","Support URI templates in RequestEntity","Add String based URI template and vararg to builder #22083","closed","type: enhancement,","parviz-93","2020-01-20T18:06:01Z","2020-06-15T13:33:01Z"
"","23980","Add queryParam method to MockHttpServletRequestBuilder","add queryParam() which calls param() and updates queryString  Fixes #23296  @rstoyanchev opened a new pr because I had to force push to the branch and GitHub couldn't connect the branch to the old repo","closed","type: enhancement,","jo2","2019-11-12T13:39:06Z","2019-11-12T16:17:30Z"
"","24398","Add more lambda expressions in data-access code examples","add more java8 lambda expressions in documentation for data-access","closed","status: feedback-provided,","maxxedev","2020-01-20T00:55:04Z","2020-03-22T19:35:15Z"
"","24683","Extract isDebugEnabled() checks to local variables","Add log level checks before log input in some classes.","closed","status: feedback-provided,","chenqimiao","2020-03-12T06:12:48Z","2020-03-16T14:59:59Z"
"","23946","RestClientResponseException.getResponseBodyAsString() encodes JSON wrongly with ISO_8859_1","Accoring to the [JSON spec](https://tools.ietf.org/html/rfc7159#page-9) the default encoding for JSON is UTF-8:  > JSON text SHALL be encoded in UTF-8, UTF-16, or UTF-32.  The default    encoding is UTF-8  I happend to see a service which responds an http error with a JSON body, the content type was application/json and no explicit character encoding was given:  > Content-Type: application/json  I would assume then, that RestClientResponseException.getResponseBodyAsString() would correctly return the String with the JSON default encoding, i.e. UTF-8. But it does return it converted into ISO_8859_1, which breaks UTF-8 encoded Umlaute.  **Edit: Oh, I see. In the latest RestClientResponseException the default charset became UTF-8. Sorry, I was on an outdated Spring version. I close this.**","closed","","markus-scalable","2019-11-07T12:24:42Z","2022-02-18T19:07:17Z"
"","24772","Using UriComponentsBuilder.cloneBuilder does not copy uriVariables","According to the docs, when you do `UriComponentsBuilder.cloneBuilder` (`v5.2.5.RELEASE`) it should create a deep clone:  https://github.com/spring-projects/spring-framework/blob/c08e31b7d613bf91cbe2beac2dad66714403faee/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L146-L162  However, if your builder has `pathSegment`s the `uriVariables` will not be preserved.  Imagine the following scenario - you have a `base` builder which you are going to receive and you need to append path(s) to it. Here is an oversimplified example:  ```java public UriComponentsBuilder getStorageBuilder(int userId, String storageName) {     HashMap uriVariables = new HashMap<>();     uriVariables.put(""userId"", userId);     uriVariables.put(""storageId"", storageName);      UriComponentsBuilder baseBuilder = ServletUriComponentsBuilder.fromCurrentRequest();     baseBuilder.replacePath(""/storages"");     baseBuilder.pathSegment(""{userId}"");     baseBuilder.pathSegment(""{storageName}"");     baseBuilder.uriVariables(uriVariables);      return baseBuilder; } ....  // Receive a configured `builder` (something else calls `getStorageBuilder` before this method and it's passed as an argument here) public UriComponentsBuilder getStorageDirectoryListing(UriComponentsBuilder baseBuilder, String path) {     // http://localhost/storages/%7BuserId%7D/%7BstorageName%7D/some/path     return baseBuilder.cloneBuilder().path(path).toUriString(); } ```  In this case the `cloned` builder will not have the `uriVariables` copied. Furthermore, there is no `getter` method for the `uriVariables` so you can't manually copy them. A quick'n'dirty workaround to this is would be:  ```java String fileUrl = UriComponentsBuilder.fromUriString(baseBuilder.toUriString())                                      .path(""/some/path"").build().toUriString(); ```  Unfortunately this removes the ability to change anything in the `pathSegments`. Is there anything I'm missing here for `uriVariables` to be excluded when cloning or is this simply missing at the moment?","closed","status: superseded,","steve-todorov","2020-03-25T02:32:46Z","2020-03-26T16:11:24Z"
"","23968","Converters annotated with @Converter cannot be autowired into","According to #20852, spring framework and hibernate support dependency injection into `AttributeConverter` instances, but only as long as you do not annotate your implementation with `@Converter`, which is required by JSR-338 chapter 10.6, page 421.  The following stacktrace suggests that Spring ORM still indirectly calls `AttributeConverterDefinition`, which is deprecated as of Hibernate 5.3 ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is org.hibernate.AnnotationException: Unable to instantiate AttributeConverter [lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1745) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:576) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1083) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:853) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) 	at lt.saltyjuice.dragas.configuration.SigningApplication.main(SigningApplication.java:23) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.boot.maven.AbstractRunMojo$LaunchRunner.run(AbstractRunMojo.java:558) 	at java.lang.Thread.run(Thread.java:748) Caused by: org.hibernate.AnnotationException: Unable to instantiate AttributeConverter [lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter] 	at org.hibernate.cfg.AttributeConverterDefinition.instantiateAttributeConverter(AttributeConverterDefinition.java:63) 	at org.hibernate.cfg.AttributeConverterDefinition.from(AttributeConverterDefinition.java:80) 	at org.hibernate.boot.model.process.internal.ScanningCoordinator.applyScanResultsToManagedResources(ScanningCoordinator.java:235) 	at org.hibernate.boot.model.process.internal.ScanningCoordinator.coordinateScan(ScanningCoordinator.java:82) 	at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.prepare(MetadataBuildingProcess.java:99) 	at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.(EntityManagerFactoryBuilderImpl.java:232) 	at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.(EntityManagerFactoryBuilderImpl.java:167) 	at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:51) 	at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:390) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:377) 	at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1804) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1741) 	... 22 common frames omitted Caused by: java.lang.InstantiationException: lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter 	at java.lang.Class.newInstance(Class.java:427) 	at org.hibernate.cfg.AttributeConverterDefinition.instantiateAttributeConverter(AttributeConverterDefinition.java:59) 	... 35 common frames omitted Caused by: java.lang.NoSuchMethodException: lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter.() 	at java.lang.Class.getConstructor0(Class.java:3082) 	at java.lang.Class.newInstance(Class.java:412) 	... 36 common frames omitted java.lang.reflect.InvocationTargetException 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.boot.maven.AbstractRunMojo$LaunchRunner.run(AbstractRunMojo.java:558) 	at java.lang.Thread.run(Thread.java:748) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is org.hibernate.AnnotationException: Unable to instantiate AttributeConverter [lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1745) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:576) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1083) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:853) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) 	at lt.saltyjuice.dragas.configuration.SigningApplication.main(SigningApplication.java:23) 	... 6 more Caused by: org.hibernate.AnnotationException: Unable to instantiate AttributeConverter [lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter] 	at org.hibernate.cfg.AttributeConverterDefinition.instantiateAttributeConverter(AttributeConverterDefinition.java:63) 	at org.hibernate.cfg.AttributeConverterDefinition.from(AttributeConverterDefinition.java:80) 	at org.hibernate.boot.model.process.internal.ScanningCoordinator.applyScanResultsToManagedResources(ScanningCoordinator.java:235) 	at org.hibernate.boot.model.process.internal.ScanningCoordinator.coordinateScan(ScanningCoordinator.java:82) 	at org.hibernate.boot.model.process.spi.MetadataBuildingProcess.prepare(MetadataBuildingProcess.java:99) 	at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.(EntityManagerFactoryBuilderImpl.java:232) 	at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.(EntityManagerFactoryBuilderImpl.java:167) 	at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:51) 	at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:390) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:377) 	at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1804) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1741) 	... 22 more Caused by: java.lang.InstantiationException: lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter 	at java.lang.Class.newInstance(Class.java:427) 	at org.hibernate.cfg.AttributeConverterDefinition.instantiateAttributeConverter(AttributeConverterDefinition.java:59) 	... 35 more Caused by: java.lang.NoSuchMethodException: lt.saltyjuice.dragas.configuration.AtomicEventContextMapConverter.() 	at java.lang.Class.getConstructor0(Class.java:3082) 	at java.lang.Class.newInstance(Class.java:412) 	... 36 more ```","open","in: core,","Dragas","2019-11-11T11:42:28Z","2021-11-10T11:58:04Z"
"","24110","Regression: default values for implicit aliases no longer honored in MergedAnnotations","A single low-level annotation attribute can change a high-level attribute via `@AliasFor`, but when some low-level attribute is mirrored and is the default value, the high-level attribute will not be changed.  I think this is unreasonable.","closed","status: feedback-provided,","iiiron","2019-12-01T12:26:55Z","2019-12-03T16:25:10Z"
"","24171","Upgrade to Kotlin 1.4 RC","A placeholder ticket for upgrading to Kotlin 1.4 in our Spring Framework 5.3 timeframe.","closed","type: dependency-upgrade,","jhoeller","2019-12-09T18:09:13Z","2020-07-30T08:20:19Z"
"","24236","Introduce AnnotationConfigGenericWebApplicationContext","A copy of Spring-boot 2.1.8 `AnnotationConfigServletWebServerApplicationContext`, except that it does not use its own WebServer (other super class).  Also See `AnnotationConfigApplicationContext` (Same as this but uses GenericApplicationContext instead of GenericWebApplicationContext)  In contrast to `org.springframework.web.context.support.AnnotationConfigWebApplicationContext`, this class uses the GenericWebApplicationContext, which allows registering beans using a Supplier `#registerBean(Class, Supplier, BeanDefinitionCustomizer...)`","closed","status: declined,","bytewright","2019-12-20T09:16:44Z","2021-12-07T11:03:49Z"
"","24129","XmlValidationModeDetector can't detect doctype when a comment follows the doctype declaration","`XmlValidationModeDetector` can't detect doctype when has comment after doctype.  With XML like this, the comment is start after doctype line...  ```xml   ```  ... it will fail to detect DTD.","closed","in: core,","gravin","2019-12-04T07:06:29Z","2019-12-19T15:56:00Z"
"","24122","Why does XmlBeanDefinitionReader store resourcesCurrentlyBeingLoaded in ThreadLocal?","`XmlBeanDefinitionReader` stores `resourcesCurrentlyBeingLoaded` in a `ThreadLocal`.  Because I have lots of small bean files in my project, I am trying to using multiple threads to load bean definitions, which causes errors.  Why it is designed like this?","closed","status: duplicate,","gravin","2019-12-03T09:54:17Z","2020-04-01T19:38:16Z"
"","23924","ResponseCookie to allow leading dot in domain name again","`ResponseCookie` was changed and now applies Rfc6265Utils to validate attributes. As stated on issue #23776, **we should be strict with output and lenient with input**.  Reality is that `ReactorClientHttpResponse` and `JettyClientHttpResponse` are using `ResponseCookie` to propagate cookies received. This scenario is cleary input and yet it's still failing when hitting endpoints behind Cloudflare, as they add the HttpOnly cookie with `domain=.domain.com` as stated [here](https://support.cloudflare.com/hc/en-us/articles/200170156-Understanding-the-Cloudflare-Cookies).  Regarding possible solutions, I think the builder itself could have some kind of flag to disable validation, allowing both `ReactorClientHttpResponse` and `JettyClientHttpResponse` use it when just propagating cookies from the cookie header.","closed","type: regression,","rubasace","2019-11-04T14:49:46Z","2019-11-14T13:27:24Z"
"","24696","Improve Javadoc in InstantiationAwareBeanPostProcessor","`Post-process the given property values before the factory applies them to the given bean` If I understand correctly, `AbstractAutowireCapableBeanFactory#applyPropertyValues` represents `the factory applies them to the given bean`. So, suggest adding the method link in Javadoc to make the documentation clearer.","closed","in: core,","chenqimiao","2020-03-14T02:54:44Z","2021-12-21T08:45:00Z"
"","24151","AnnotationAwareOrderComparator fallback order doesn't allow to add beans after","`org.springframework.core.annotation.AnnotationAwareOrderComparator` extends `org.springframework.core.OrderComparator` and ultimately ends up calling this method:  ``` java protected int getOrder(@Nullable Object obj) { 		if (obj != null) { 			Integer order = findOrder(obj); 			if (order != null) { 				return order; 			} 		} 		return Ordered.LOWEST_PRECEDENCE; 	} ```  Very similar to the problem in #24058 , this defaulting is causing some third-party `RestTemplateCustomizer` instances, that don't specify any sorting, to be added at the end of the list, making it impossible for me to add a RestTemplateCustomizer that operates after the third-party one.  I'm not sure about the implications of such a change, but is there any reason why the fallback value isn't `0` or even `Ordered.LOWEST_PRECEDENCE-1`?  Ideally, and without knowing the implications, 0 is what makes the most sense to me, but anything that isn't `LOWEST_PRECEDENCE` would at least offer a way of adding things after.","open","in: core,","rubasace","2019-12-06T15:21:27Z","2021-11-11T10:12:42Z"
"","24197","Concurrent access to ParsedSql cache in NamedParameterJdbcTemplate","`NamedParameterJdbcTemplate.getParsedSql(Sting)` can be a bottleneck under high load as it holds a global lock by `this.parsedSqlCache`.   ```java 		synchronized (this.parsedSqlCache) { 			ParsedSql parsedSql = this.parsedSqlCache.get(sql); 			if (parsedSql == null) { 				parsedSql = NamedParameterUtils.parseSqlStatement(sql); 				this.parsedSqlCache.put(sql, parsedSql); 			} 			return parsedSql; 		} ```  This PR tried to improve the performance by the combination of a ConcurrentHashMap and a LinkedHashMap.  I referenced https://github.com/spring-projects/spring-framework/commit/06c6cbb6b92 and  https://github.com/spring-projects/spring-framework/issues/7831#issuecomment-453315164","closed","type: enhancement,","benelog","2019-12-12T12:46:09Z","2020-09-02T20:50:23Z"
"","24744","Remove unnecessary null check in ConvertingEncoderDecoderSupport","`instanceof` check contains `null check`, I think we can remove leading `null` check.","closed","type: task,","chenqimiao","2020-03-20T13:17:51Z","2021-05-14T06:48:53Z"
"","24200","MappingJackson2MessageConverter: fix javadoc typo","`getJavaTypeForMessage()` - wrong parameter description.","closed","type: documentation,","garyrussell","2019-12-12T18:59:40Z","2019-12-13T16:20:02Z"
"","24457","HttpHeaders getContentLength should check for non-empty String","`getContentLength` method in spring-web `HttpHeaders` class is prone to `NumberFormatException`. Due to some reason, my content length is not getting set in response. Hence value of content length is returned as empty string from `getFirst` method. When this empty string is parsed, `NumberFormatException` is thrown. ```java public long getContentLength() { 	String value = getFirst(CONTENT_LENGTH); 	return (value != null ? Long.parseLong(value) : -1); } ```","closed","type: enhancement,","rashid442000","2020-01-30T03:48:47Z","2020-02-03T17:35:10Z"
"","24213","WebFlux EncodedResource wrong mapping for encoding","`EncodedResource` calls `original.createRelative(original.getFilename() + extension)` that resolves the name twice:  `/a.html` becomes `/a.html/a.html.gz` or `/a.html/a.html.br`  Must be changed to resolve via original `URL` or check for Resource type and use it (FileSystemResource, ClasspathResource, etc...)","closed","status: invalid,","userquin","2019-12-15T03:26:00Z","2019-12-16T17:44:33Z"
"","24688","Improve Javadoc in AutoProxyRegistrar","`EnableAspectJAutoProxy` doesn't have `mode` attribute, a bit mismatch with the logic of `registerBeanDefinitions` method in `AutoProxyRegistrar`. Suggest adjusting `EnableAspectJAutoProxy` to `EnableCaching `.","closed","in: core,","chenqimiao","2020-03-13T06:36:48Z","2020-03-13T10:02:20Z"
"","24680","Improve efficiency of mutating of ClientHttpResponse and ServerHttpRequest","`DefaultClientResponse` has `from(ClientResponse)` which copies status, headers, and cookies. It is only half as useful because it ignores the body which is [easy to forget](https://github.com/spring-projects/spring-framework/issues/24126#issuecomment-562519509) or otherwise leads to code like this as a starting point:  ```java ClientResponse.from(response).body(response.bodyToFlux(DataBuffer.class) ```  We should add `ClientResponse.mutate()` matching to similar options on the server side. Also both client and server `mutate()` should be careful not to parse cookies unnecessarily which can lead to surprises, see  #24663.  In addition since mutation can be quite common, it should be made as optimal as possible, avoiding object creation in parts not mutated, and also optimizing for repeated use, e.g. [response headers](https://github.com/spring-projects/spring-framework/blob/0dc1c7eb8b4ca17996567406f3e16267ff544a6d/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java#L85)).","closed","type: enhancement,","rstoyanchev","2020-03-11T18:45:33Z","2020-05-11T07:52:21Z"
"","24231","Update ContentDisposition to refer to RFC 6266","`ContentDisposition` was originally created in reference to [RFC 2183](https://tools.ietf.org/html/rfc2183) which is a non-HTTP spec. This was what the old HTTP spec [RFC 2616 refers to](https://tools.ietf.org/html/rfc2616#section-19.5.1) (via RFC 1806, later updated by 2183).  [RFC 6266](https://tools.ietf.org/html/rfc6266) is the current HTTP spec that defines the use of `Content-Disposition` in HTTP and supersedes the same from RFC 2616.   [Appendix B](https://tools.ietf.org/html/rfc6266#appendix-B) of RFC 6266 lists several fields from RFC 2183 that are omitted including ""creation-date"", ""modification-date"", ""read-date"", and ""size"". We can deprecate those in `ContentDisposition` to be removed eventually.","closed","type: task,","rstoyanchev","2019-12-19T16:23:04Z","2019-12-20T11:04:10Z"
"","24580","Backport of ContentDisposition fixes to HttpHeaders","`ContentDisposition` was created in 5.0, supporting all Content-Disposition types including ""form-data"", ""inline"" and ""attachment"" for use in client and server scenarios. Prior to that,  `HttpHeaders` did have support for Content-Disposition of type ""form-data"", for use in client scenarios with the `RestTemplate`. This ticket is to review fixes in `ContentDisposition` that may be worth backporting to HttpHeaders in the 4.3.x branch for consistency.","closed","type: enhancement,","rstoyanchev","2020-02-24T12:01:51Z","2020-04-21T07:29:56Z"
"","24718","Use try with resource to close ByteArrayBuilder in AbstractJackson2Encoder","`ByteArrayBuilder` extends `OutputStream`, so I think we can close it by using `try with resource` after each use.","closed","","chenqimiao","2020-03-18T07:53:49Z","2020-03-18T17:28:18Z"
"","24695","Support a `RowMapper` for Java record classes","`BeanPropertyRowMapper` is ill-suited to the task, however, since that requires a no-arg constructor that records don't have and since the properties in records don't look like normal JavaBean properties - they're `int foo()`/`foo(int)` instead of `int getFoo()`/`setFoo(int)`.","closed","type: enhancement,","joshlong","2020-03-14T01:42:47Z","2020-08-28T16:54:22Z"
"","24716","Storing JVM system properties in the Spring Environment as Properties can degrade performance due to synchronization","``systemProperties`` PropertySource in Environment implemented with Properties ,But Properties is synchronous, which will reduce performance !!!","open","status: feedback-provided,","brucelwl","2020-03-18T03:34:04Z","2020-07-21T12:41:01Z"
"","24708","fix NPE in SynchronossPartGenerator#hookOnNext","``listener`` is Nullable, so we should check it before using it","closed","status: invalid,","GungnirLaevatain","2020-03-17T02:54:54Z","2021-06-17T05:09:22Z"
"","24305","Merge getCallableInterceptors and getDeferredResultInterceptors","``getCallableInterceptors`` is same as ``getDeferredResultInterceptors``, so could merge them","closed","type: enhancement,","GungnirLaevatain","2020-01-07T08:17:27Z","2020-01-08T07:53:10Z"
"","24601","pom.xml give the problem","```xml    4.0.0    com.b2ecoder.springcore   javaproj2   0.0.1-SNAPSHOT   jar    javaproj2   http://maven.apache.org             5.0.3.RELEASE                                  org.springframework             spring-core             ${springframework.version}                               org.springframework             spring-context             ${springframework.version}                                                                               org.apache.maven.plugins                     maven-compiler-plugin                     3.2                                              1.8                         1.8                                                                    ```","closed","status: invalid,","Dhruvjava","2020-02-26T16:42:07Z","2020-02-26T18:38:42Z"
"","24036","RestTemplate upload file with parameter generate duplication http body","```xml      org.springframework.boot     spring-boot-starter-parent      1.4.3.RELEASE     2.2.1.RELEASE       ```  I update spring version and found RestTemplate upload file with parameter generate duplication http body.  ```java HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); MultiValueMap body= new LinkedMultiValueMap<>(); body.add(""OSSAccessKeyId"", """"); body.add(""signature"", """"); body.add(""key"", """"); body.add(""policy"", """"); body.add(""file"", new FileSystemResource(path));  HttpEntity> files = new HttpEntity<>(body, headers); ResponseEntity responseEntity = restTemplate.postForEntity(url, files, String.class); ```  I print detail error log, application/octet-stream generate  duplication http body can be seen:  ``` Content-Disposition: form-data; name=""OSSAccessKeyId"" Content-Type: text/plain;charset=UTF-8 Content-Length: 16  hObpgEXoca42qH3V --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""signature"" Content-Type: text/plain;charset=UTF-8 Content-Length: 28  lb51qqJHXxbKaNOuNJf7ciwRyg8= --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""key"" Content-Type: text/plain;charset=UTF-8 Content-Length: 69  1875170851096596/business_license/7742cef3ebc147a186eaee02f2e10f87jpg --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""policy"" Content-Type: text/plain;charset=UTF-8 Content-Length: 256  eyJleHBpcmF0aW9uIjoiMjAxOS0xMS0xOVQwODo0Mjo0MC40NzZaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMjA0ODAwMF0sWyJzdGFydHMtd2l0aCIsIiRrZXkiLCIxODc1MTcwODUxMDk2NTk2L2J1c2luZXNzX2xpY2Vuc2UiXSxbImVxIiwiJGJ1Y2tldCIsInRyYWRlLW1hcmstdXNlci11cGxvYWQiXV19 --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""file""; filename=""7742cef3ebc147a186eaee02f2e10f87jpg"" Content-Type: application/octet-stream Content-Length: 101128  ���� JFIF  x x  �� C  >�s��Њ�z��F�'�os1n�|�]�ώ1���q�I+��5���������""�U8����|࿍�bgF0��^�c��]���Sx����}^�a��75����S�riV+�XK�rk��*����f9╈^1L�U�)�Mi㕸<�&�f��|�:�5s$�g�x�G��Kn�u{�ޢ�dV� ����s�$Y_����z��<}�?��·5��{u?{�MZ��ꠏqTt�[���0Ẓ���Ci=��K�m5�w_��q��)VE[""�D�u�#�o^��S�9?(�_;|D������Yc텭��2q�|�&Y�(������ӟ���q�K�u�Z@+�w�_�--EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""OSSAccessKeyId"" Content-Type: text/plain;charset=UTF-8 Content-Length: 16  hObpgEXoca42qH3V --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""signature"" Content-Type: text/plain;charset=UTF-8 Content-Length: 28  lb51qqJHXxbKaNOuNJf7ciwRyg8= --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""key"" Content-Type: text/plain;charset=UTF-8 Content-Length: 69  1875170851096596/business_license/7742cef3ebc147a186eaee02f2e10f87jpg --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""policy"" Content-Type: text/plain;charset=UTF-8 Content-Length: 256  eyJleHBpcmF0aW9uIjoiMjAxOS0xMS0xOVQwODo0Mjo0MC40NzZaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMjA0ODAwMF0sWyJzdGFydHMtd2l0aCIsIiRrZXkiLCIxODc1MTcwODUxMDk2NTk2L2J1c2luZXNzX2xpY2Vuc2UiXSxbImVxIiwiJGJ1Y2tldCIsInRyYWRlLW1hcmstdXNlci11cGxvYWQiXV19 --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi Content-Disposition: form-data; name=""file""; filename=""7742cef3ebc147a186eaee02f2e10f87jpg"" Content-Type: application/octet-stream Content-Length: 101128  ���� JFIF  x x  �� C  �gsm�~��n��éB���Xc��rS<M�ƺǆ�,�_&x��s_5�M�k2���W�~�[k˻ !�$-|��=���o�_��2��f�lY^1J�ܝ��\���7{R��p���x� �����|1�/5e7|D`�J�l����%�A�$W���a�w�.�F�5�Q9+#� 󏶿����I_2?�� --EZ4L1ynVZq9Ey08YG9cTHMBJaiLJ8fNi-- ```  Before the upgrade spring version, Is the correct body of the HTTP request like this:  ``` Content-Disposition: form-data; name=""OSSAccessKeyId"" Content-Type: text/plain;charset=UTF-8 Content-Length: 16  hObpgEXoca42qH3V --rpYfR9Cw4UkmMqbRr-_sYlVRJRcCZv-2w Content-Disposition: form-data; name=""signature"" Content-Type: text/plain;charset=UTF-8 Content-Length: 28  iG2hr58fjgqN4DGC20lL+/z3MQA= --rpYfR9Cw4UkmMqbRr-_sYlVRJRcCZv-2w Content-Disposition: form-data; name=""key"" Content-Type: text/plain;charset=UTF-8 Content-Length: 69  1875170851096596/business_license/2d78ea0ea7bf47b9b3e590a3da56a040jpg --rpYfR9Cw4UkmMqbRr-_sYlVRJRcCZv-2w Content-Disposition: form-data; name=""policy"" Content-Type: text/plain;charset=UTF-8 Content-Length: 256  eyJleHBpcmF0aW9uIjoiMjAxOS0xMS0xOVQwODo0MDozOS4xNzBaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMjA0ODAwMF0sWyJzdGFydHMtd2l0aCIsIiRrZXkiLCIxODc1MTcwODUxMDk2NTk2L2J1c2luZXNzX2xpY2Vuc2UiXSxbImVxIiwiJGJ1Y2tldCIsInRyYWRlLW1hcmstdXNlci11cGxvYWQiXV19 --rpYfR9Cw4UkmMqbRr-_sYlVRJRcCZv-2w Content-Disposition: form-data; name=""file""; filename=""2d78ea0ea7bf47b9b3e590a3da56a040jpg"" Content-Type: application/octet-stream Content-Length: 101128  ���� JFIF  x x  �� C    �� ��"" ��            --rpYfR9Cw4UkmMqbRr-_sYlVRJRcCZv-2w-- ```","closed","","sunyl-git","2019-11-20T02:48:05Z","2019-12-11T14:53:51Z"
"","24149","ExtendedBeanInfo#isCandidateWriteMethod is wrong?","```java public static boolean isCandidateWriteMethod(Method method) { 		String methodName = method.getName(); 		int nParams = method.getParameterCount(); 		return (methodName.length() > 3 && methodName.startsWith(""set"") && Modifier.isPublic(method.getModifiers()) && 				(!void.class.isAssignableFrom(method.getReturnType()) || Modifier.isStatic(method.getModifiers())) && 				(nParams == 1 || (nParams == 2 && int.class == method.getParameterTypes()[0]))); 	} ```  This method is from `ExtendedBeanInfo`. I think it determines whether the method is 'set' method. But `!void.class.isAssignableFrom(method.getReturnType()` is wrong?","closed","in: core,","qianpingmao","2019-12-06T10:31:44Z","2019-12-06T12:43:19Z"
"","24521","Collection type field annotated with Autowired, the field do not be injected into all beans.","```java public class User {  	private Long id;  	public Long getId() { 		return id; 	}  	public void setId(Long id) { 		this.id = id; 	}  	@Override 	public String toString() { 		return ""User{"" + 				""id="" + id + 				'}'; 	}  	public User(Long id) { 		this.id = id; 	} } ``` ```java @Configuration public class OtherUserConfiguration {  	@Bean 	public User user3(){ 		return new User(3L); 	}  	@Bean 	public User user4(){ 		return new User(4L); 	} } ``` ```java @Configuration public class AutowiredDependencyInjectionDemo {  	@Autowired 	private Collection allUsers;   	@Bean 	public User user1(){ 		return new User(1L); 	}  	@Bean 	public User user2(){ 		return new User(2L); 	}  	public static void main(String args[]){ 		AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(); 		ac.register(AutowiredDependencyInjectionDemo.class); 		ac.register(OtherUserConfiguration.class); 		ac.refresh(); 		AutowiredDependencyInjectionDemo demo = ac.getBean(AutowiredDependencyInjectionDemo.class); 		System.out.println(demo.allUsers);  	}  } ``` First, I define four beans called `user1`, `user 2`, `user 3`, `user4`, where `user1` and `user2` is defined in `AutowiredDependencyInjectionDemo`, and `user3` and `user4` is defined in `OtherUserConfiguration`.Then, I use `@Autowired` to annotate the field named `allUsers` of Collection type, I expect user1 ~ user4 to be injected into `allUsers`, but things go wrong.  Run the main of `AutowiredDependencyInjectionDemo`.The program will only print `user3` and `user4`. Why `user1` and `user2` is not injected into `allUsers`? Actually, I'm looking forward to output `user1`, `user2`, `user3` and `user4`. What's more confusing to me is when I remove this sentence `ac.register(OtherUserConfiguration.class);`, the program will can print `user1` and `user2`.  I feel this is very confusing for developers.What do you think? Thank you for your reading and looking forward to your reply.","closed","status: duplicate,","chenqimiao","2020-02-14T05:42:15Z","2020-02-18T06:45:08Z"
"","24765","CronSequenceGenerator doNext method optimization","```java private void doNext(Calendar calendar, int dot) {         List resets = new ArrayList();         int second = calendar.get(13);         List emptyList = Collections.emptyList();         int updateSecond = this.findNext(this.seconds, second, calendar, 13, 12, emptyList);         if (second == updateSecond) {             resets.add(13);         }          int minute = calendar.get(12);         int updateMinute = this.findNext(this.minutes, minute, calendar, 12, 11, resets);         if (minute == updateMinute) {             resets.add(12);         } else {             this.doNext(calendar, dot);             return; //----------------------------------------可以直接返回 在后面走可能就是多余的         }          int hour = calendar.get(11);         int updateHour = this.findNext(this.hours, hour, calendar, 11, 7, resets);         if (hour == updateHour) {             resets.add(11);         } else {             this.doNext(calendar, dot);             return; //----------------------------------------可以直接返回 在后面走可能就是多余的         }          int dayOfWeek = calendar.get(7);         int dayOfMonth = calendar.get(5);         int updateDayOfMonth = this.findNextDay(calendar, this.daysOfMonth, dayOfMonth, this.daysOfWeek, dayOfWeek, resets);         if (dayOfMonth == updateDayOfMonth) {             resets.add(5);         } else {             this.doNext(calendar, dot);             return; //----------------------------------------可以直接返回 在后面走可能就是多余的         }          int month = calendar.get(2);         int updateMonth = this.findNext(this.months, month, calendar, 2, 1, resets);         if (month != updateMonth) {             if (calendar.get(1) - dot > 4) {                 throw new IllegalArgumentException(""Invalid cron expression \"""" + this.expression + ""\"" led to runaway search for next trigger"");             }              this.doNext(calendar, dot);         }     } ```  如果doNext在递归时  内层的doNext会检测新值和旧值是否相等并重置时间  等内层的doNext 执行完成后 外层的doNext 在判断是一定是相等的","closed","status: superseded,","17683908932","2020-03-23T12:22:39Z","2021-04-28T08:28:18Z"
"","24156","Conflicting Conditional bean behavior","```java package com.example.springbootdemo;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Condition; import org.springframework.context.annotation.ConditionContext; import org.springframework.context.annotation.Conditional; import org.springframework.context.annotation.Configuration; import org.springframework.core.type.AnnotatedTypeMetadata;  @SpringBootApplication public class SpringBootDemoApplication {      public static void main(String[] args) {         ApplicationContext ctx = SpringApplication.run(SpringBootDemoApplication.class, args);         System.out.println(""Bean found ? "" + (ctx.getBean(Foo.class) != null));     } }  @Configuration class TestConfiguration {      @Bean     @Conditional(AlwaysMismatch.class)     public Foo foo(int dummy) {         return new Foo();     }      @Bean     @Conditional(AlwaysMatch.class)     public Foo foo() {         return new Foo();     }  }  class AlwaysMatch implements Condition {     @Override     public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {         return true;     } }  class AlwaysMismatch implements Condition {     @Override     public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {         return false;     } }   class Foo { } ```  **Expectation**  With above code I expect one bean of type `com.example.springbootdemo.Foo` contributed with bean-name `foo`.  **Actual behavior** No bean of type `com.example.springbootdemo.Foo` is registered.  With a slight change in above code.   From  ```java @Configuration class TestConfiguration {      @Bean     @Conditional(AlwaysMismatch.class)     public Foo foo(int dummy) {         return new Foo();     }      @Bean     @Conditional(AlwaysMatch.class)     public Foo foo() {         return new Foo();     } } ```  to  ```java @Configuration class TestConfiguration {      @Bean     @Conditional(AlwaysMismatch.class)     public Foo foo(int dummy) {         return new Foo();     }      @Bean     @Conditional(AlwaysMatch.class)     public Foo foo1() {         return new Foo();     } } ```  bean of type `com.example.springbootdemo.Foo` is registered.","closed","in: core,","JigarJoshi","2019-12-06T18:36:09Z","2019-12-07T12:16:14Z"
"","24102","Why does Spring use my custom annotation's value for the bean name?","```java @Service @TopicName(value=""topic22"") public class TopicService implements TopicComsumerMsg {      @Override     public void omTopic(MqMsgDto mqMsgDto) {         System.out.println(""接收到了消息，我是topic22"");     } } ``` ```java  @Service @TopicName(value=""topic22"") public class TopicService2 implements TopicComsumerMsg {      @Override     public void omTopic(MqMsgDto mqMsgDto) {         System.out.println(""接收到了消息TopicService2，我是topic22"");     } } ```  why spring use My custom annotations's value for the beanName,if I use  name=“topic22” is right","closed","for: stackoverflow,","authorZhao","2019-11-29T10:13:59Z","2019-11-29T15:23:13Z"
"","24271","Is this a wrong practice","```java @Controller public class View implements InitializingBean {      @GetMapping(""log"")     public String log() {         return ""log"";     }      @Override     public void afterPropertiesSet() throws Exception {         System.out.println(""init"");     } } ```  ths in advance :)","closed","for: stackoverflow,","chenshun00","2019-12-27T13:40:14Z","2019-12-27T13:42:36Z"
"","24670","@RestController exceptional response body missing for MediaTypes != json","``` @RestController public class ErrorServlet { 	@GetMapping(value = ""/test"", produces = MediaType.TEXT_PLAIN_VALUE) 	public String test() { 		throw new ResponseStatusException(HttpStatus.NOT_IMPLEMENTED, ""you should not call this method""); 	} } ```  `localhost:8080/test` without accept header produces: ``` {     ""timestamp"": ""2020-03-10T10:27:53.965+0000"",     ""status"": 501,     ""error"": ""Not Implemented"",     ""message"": ""you should not call this method"",     ""path"": ""/test"" } ``` (even though I configured my endpoint to NOT output JSON here. But that's ok, as clients will benefit from error body).  Now, what if the client sends a request that matches the `produces` field. I'd still expect a error message in the body. BUT, currently the body is dropped:  `localhost:8080/test` with `Accept: plain/text` produces an *empty* body (while http status code `501` is still correct).  What is strange: if I change the endpoint to `produces = MediaType.APPLICATION_XML_VALUE` and send a request with `accept: application/xml`, the message body is still empty. Shouldn't spring convert the error at least to xml output here?  If this is not a bug: how could I possibly preserve the json error response for this endpoint?  spring-boot.2.2.5.RELEASE.","closed","status: duplicate,","membersound","2020-03-10T10:32:14Z","2020-03-10T16:27:54Z"
"","24665","HttpClientErrorException returns statuscode 500 instead of status from exception","``` @RestController public class ErrorServlet { 	@GetMapping 	public void get() { 		throw HttpClientErrorException.create(HttpStatus.LOCKED, ""status should be locked"", null, null, null); 	} } ```  Expected: a `423` http status should be returned. Current result: ``` {     ""timestamp"": ""2020-03-09T14:53:41.812+0000"",     ""status"": 500,     ""error"": ""Internal Server Error"",     ""message"": ""423 status should be locked"",     ""path"": ""/"" } ```  spring-boot.2.2.5.RELEASE","closed","status: declined,","membersound","2020-03-09T14:55:38Z","2020-03-11T13:54:46Z"
"","24260","MockMVC is not triggering Javax.Constraint.Validation for List of Objects","``` @RestController @Validated @Slf4j public class TestController {    @PostMapping(value = ""/v1/test"", produces = ""application/json"", consumes = ""application/json"")   @ResponseStatus(HttpStatus.CREATED)   public void postTest(@Valid @RequestBody List testList) {   } } ```  MockMVC is not throwing BadRequest but when service is hit from postman we get BadRequest","closed","status: duplicate,","SumithraPrasad","2019-12-24T11:41:24Z","2019-12-26T09:00:43Z"
"","23852","springboot rsocket 2.2.0.RELEASE bug","``` @Controller public class ServerController {      @MessageMapping(value = ""market"")     public MarketResponse getMarket(Market market) {         return new MarketResponse(market.getName());     } } ``` ``` @RestController public class ConsumerController {      private final RSocketRequester rSocketRequester;      public ConsumerController(RSocketRequester rSocketRequester) {         this.rSocketRequester = rSocketRequester;     }      @GetMapping(path = ""/market/{name}"")     public Publisher getMarket(@PathVariable String name) {         return rSocketRequester.route(""market"").data(new Market(name)).retrieveMono(MarketResponse.class);     } } ```  ``` java.lang.IllegalArgumentException: No decoder for com.example.rsocketclient.MarketResponse 	at org.springframework.messaging.rsocket.RSocketStrategies.decoder(RSocketStrategies.java:92) ~[spring-messaging-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ HTTP GET ""/market/test"" [ExceptionHandlingWebHandler] ```","closed","status: invalid,","huangshayang","2019-10-23T09:05:35Z","2022-03-30T01:15:17Z"
"","23983","Order of @Configuration on Condition","``` @Configuration @ConditionalOnBean(Resource.class) public class AConfig {     @Bean     public Dependent dependent() {         return new Dependent();     } } ```  ``` @Configuration public class ResourceConfig {     @Bean     public Resource resource() {         return new Resource();     } } ```  The first configuration class `AConfig` will never be scanned and `Dependent` bean will never be created. If the First `Configuration` class is renamed to `ZConfig` to come in order after `ResourceConfig` it works fine.","closed","status: invalid,","hadielmougy","2019-11-12T20:44:17Z","2019-11-13T05:58:51Z"
"","23850","Provide mechanism to control trimming in StringToArrayConverter and StringToCollectionConverter","`@RequestParams` (i.e. HTTP query parameters) with leading or trailing spaces, including single parameters or delimited parameters, are trimmed when mapping them to a collection. It is likely this happens for other cases. A query parameter with a leading/trailing space is a perfectly reasonable construct provided it is encoded correctly. However by the time it gets into a controller, the space(s) have been trimmed.  I can see this happening in at least two Boot classes, and there are probably more: - `StringToCollectionConverter` - `DelimitedStringToCollectionConverter`  Simply removing the `trim()` calls is not the right choice as these are also used for parsing `application.yml`, and possibly have other uses. I suggest these converters should accept a trim? parameter at construction time, and the `WebConversionService` be given its own instances of the converters with `trim=false` so query params with leading/trailing spaces can be properly passed. Something like that anyway...","open","status: pending-design-work,","SingleShot","2019-10-22T23:25:16Z","2020-08-25T14:37:00Z"
"","23966","Fix @Configuration class's setBeanFactory method is called multiple times","`@Configuration` class's `setBeanFactory` method is called multiple times.  - First point is `AbstractAutowireCapableBeanFactory#invokeAwareMethods`. - Second point is `ImportAwareBeanPostProcessor#postProcessProperties`.  So, I think we can clean some code.  I don't know if I am right, I am looking forward to your answer.","open","in: core,","chenqimiao","2019-11-11T09:01:51Z","2021-04-27T05:06:11Z"
"","24752","Declare proxyBeanMethods=false in JmsBootstrapConfiguration","`@Bean` annotated methods are not explicitly called by other methods in `JmsBootstrapConfiguration`, so I think we can set `proxyBeansMethod` attribute of `@Configuration` to false to avoid CGLIB subclass processing. This can improve performance, although not a lot.","closed","type: enhancement,","chenqimiao","2020-03-21T09:29:33Z","2020-03-25T03:01:07Z"
"","24753","Improve Javadoc in @Configuration","`'inter-bean references'`, I feel this description is a bit vague. I feel that this description may be interpreted as a Bean reference through method parameters, like this: ```java @Configuration public class MyConfiguration {  	@Bean 	public User user{ 		return new User(); 	} 	 	@Bean 	public UserHolder userHolder(User user){ 		UserHolder userHolder = new UserHolder(); 		userHolder.setUser(user); 		return userHolder; 	} } ``` So, I suggest adding `via direct method call` after the previous description.","closed","in: core,","chenqimiao","2020-03-21T10:35:57Z","2020-04-10T01:43:39Z"
"","23830","Consider moving JSON support from spring-web to its own module","_Disclaimer:_ this is a philosophical question to which there are only two possible reactions: a fast ""LOL, no! -> close issue"" and a slow ""let's deprecate a chunk of functionality in spring-web and move it to a different place"".  Ideally, full JSON support should be able to get autoconfigured without a dependency on `spring-web`, as JSON has evolved beyond it web roots into a popular application data interchange format. I've raised spring-projects/spring-boot#18639 for the possibility of `spring-boot-starter-json` removing its dependency on `spring-web`, but that's not a reasonable request while the logic itself [lives in `spring-web`](https://github.com/spring-projects/spring-framework/tree/053b95ceeb12faced172c8f3d7069315c49cab18/spring-web/src/main/java/org/springframework/http/converter/json).  For `spring-cloud-stream` applications, there is often no need to depend on any web functionality, but there is often a requirement for JSON-to-Object conversion. Basic conversion works fine with just a `com.fasterxml.jackson.core:jackson-core` dependency, but Java 8 date conversion needs `jackson-datatype-jsr310`, which for all applications depending on `spring-web` is conveniently handled by `Jackson2ObjectMapperBuilder.registerWellKnownModulesIfAvailable()`.  It would be great to have the same autoconfigured functionality available to non-web applications automatically by pulling in a starter.","closed","status: duplicate,","elefeint","2019-10-17T19:59:08Z","2019-10-18T08:50:16Z"
"","24579","Spring Core - IoC issue","[test.zip](https://github.com/spring-projects/spring-framework/files/4243459/test.zip)  ```xml 2.2.4.RELEASE 5.2.3.RELEASE ```  I uploaded bug in IoC.  Autowired inject bad bean.  ```java @Configuration @EnableAutoConfiguration @ComponentScan(basePackages = {""app""}) @Import(value = {}) public class SpringAppConfig { 	@Bean(""currentAppDir1"") 	public String currentAppDir1() { 		return ""test1""; 	} 	@Bean(""currentAppDir2"") 	public String currentAppDir2() { 		return ""test2""; 	} 	@Bean(""currentAppDir3"") 	public String currentAppDir3() { 		return ""test3""; 	} 	@Bean(""javaMailSenderMailFromString"") 	String[] javaMailSenderMailFromString() { 		return new String[]{""test"", ""test""}; 	} 	public static void main(String[] args) { 		try { 			System.out.println(""Start""); 			ConfigurableApplicationContext c = new SpringApplicationBuilder(SpringAppConfig.class).web(WebApplicationType.NONE).run(args); 			EmailService test = c.getBean(EmailService.class); 			// !Should be length 2 but it inject currentAppDir1 currentAppDir2 currentAppDir3 not javaMailSenderMailFromString! 			System.out.println(test.javaMailSenderMailFromString.length); 			System.out.println(""End""); 		} catch (Throwable e) { 			e.printStackTrace(); 		} 	} 	@Component 	public class EmailService { 		@Autowired 		//@Qualifier(""javaMailSenderMailFromString"") 		public String[] javaMailSenderMailFromString; 	} } ```","closed","status: feedback-provided,","PiotrTraczynski","2020-02-24T08:07:44Z","2020-02-24T16:32:03Z"
"","24286","Use SingletonSupplier to create singletons","[SingletonSupplier](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/function/SingletonSupplier.java) is introduced since 5.1, we could reuse this to create singleton such as [DefaultConversionService](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/DefaultConversionService.java)  for example ``` 	private static SingletonSupplier singletonSupplier = SingletonSupplier 			.of(DefaultConversionService::new);  	public static DefaultConversionService getSharedInstance() { 		return singletonSupplier.obtain(); 	} ```","closed","status: superseded,","quaff","2020-01-03T02:14:42Z","2020-01-07T12:24:28Z"
"","24203","GenericConversionService","[org/springframework/core/convert/support/GenericConversionService](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java)  ``` 542  @Nullable 543  public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) { 544      // Search the full type hierarchy 545      List> sourceCandidates = getClassHierarchy(sourceType.getType()); 546      List> targetCandidates = getClassHierarchy(targetType.getType()); 547      for (Class sourceCandidate : sourceCandidates) { 548          for (Class targetCandidate : targetCandidates) { 549              ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate); 550              GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair); 551              if (converter != null) { 552                  return converter; 553              } 554          } 555      } 556      return null; 557  } 558 559  @Nullable 560  private GenericConverter getRegisteredConverter(TypeDescriptor sourceType, 561          TypeDescriptor targetType, ConvertiblePair convertiblePair) { 562 563      // Check specifically registered converters 564      ConvertersForPair convertersForPair = this.converters.get(convertiblePair); 565      if (convertersForPair != null) { 566          GenericConverter converter = convertersForPair.getConverter(sourceType, targetType); 567          if (converter != null) { 568              return converter; 569          } 570      } 571      // Check ConditionalConverters for a dynamic match 572      for (GenericConverter globalConverter : this.globalConverters) { 573          if (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) { 574              return globalConverter; 575          } 576      } 577        return null; 578  } ```  line 550 maybe   ``` GenericConverter converter = getRegisteredConverter(TypeDescriptor.valueOf(sourceCandidate), TypeDescriptor.valueOf(targetCandidate), convertiblePair); ``` not  ``` GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair); ``` because line572-576 repeat execute many times with same paramters sourceType and targetType","closed","","wangjunjie-lnnf","2019-12-13T08:48:20Z","2020-01-22T21:15:25Z"
"","23863","Small readability update.","[method runs before any ""before methods"" of the underlying test framework] is more readable than [method runs before any before methods of the underlying test framework]","closed","","sparkie999","2019-10-24T16:07:55Z","2022-02-18T19:07:19Z"
"","24180","HiddenHttpMethodFilter consumes input stream of POST request","[HiddenHttpMethodFilter](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/filter/HiddenHttpMethodFilter.java) implementation consumes input stream without replacing it by any substitution in the wrapper being returned. This causes serious issues in Spring Boot applications where the input stream is read.","closed","status: declined,","MatejLiszkaCGI","2019-12-10T15:17:24Z","2019-12-11T12:36:55Z"
"","24793","Upgrade to Gradle Build Scan Plugin 3.2","[Here's a scan](https://ge.spring.io/s/ibc4phzzfmf6o) from a local build using the new version.","closed","type: task,","wilkinsona","2020-03-26T14:31:42Z","2020-03-26T15:27:13Z"
"","24274","@Validated with MockMVC is not working. Postman request works","@Validated with MockMVC is not working.   ``` @RunWith(MockitoJUnitRunner.class) @Slf4j public class TestController { 	private MockMvc mvc;  	@Mock 	private TestService service;  	@InjectMocks 	private Controller controller;  	private ObjectMapper mapper = new ObjectMapper();  	@Before 	public void setup() { // MockMvc standalone approach mvc = 		mvc = MockMvcBuilders.standaloneSetup(controller).setValidator(validator()).setControllerAdvice(new InvoiceServiceExceptionHandler()) 				.build(); 	}  	@Test 	public void whenNullValue_thenReturns400() throws JsonProcessingException, Exception {  		TestDTO testDTO = new TestDTO(); 		testDTO.setId(null);  		ArrayList testList = new ArrayList(Arrays.asList(testDTO));  		String jsonTestList = mapper.writeValueAsString(testList); 		  		MvcResult responseMVC = mvc.perform(post(""/v1/test"").content(jsonTestList).header(HttpHeaders.CONTENT_TYPE, 				MediaType.APPLICATION_JSON)).andExpect(status().isBadRequest()).andReturn();  	} ```  _Originally posted by @SumithraPrasad in https://github.com/spring-projects/spring-framework/issues/16917#issuecomment-568962750_","closed","status: duplicate,","SumithraPrasad","2019-12-30T08:53:25Z","2019-12-30T08:57:27Z"
"","23931","Transform upper keys to coroutines context fix #23859","@sdeleuze , I think it would be better if keys which are coroutinesContext will be transform in upper keys, but not only as keys to ReactorContext. ReactorContext is uncomfortable to use.  See #23859","closed","status: declined,","kostya05983","2019-11-05T03:41:11Z","2021-12-13T11:44:20Z"
"","23848","Update Spring Boot references in testing documentation","@pivotal-issuemaster This is an Obvious Fix  References to Spring Boot have been updated to point to the correct url.  Reference to old @WebIntegrationTest has been replaced with @SpringBootTest.","closed","type: documentation,","pdeneve","2019-10-22T19:14:14Z","2019-10-23T20:14:58Z"
"","24560","Add execution metadata to scheduled tasks","@enesify requested an enhancement on Spring Boot, where actuator endpoints could provide more information about scheduled tasks.  Currently, the `/actuator/scheduledtasks` [actuator endpoint](https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/actuator-api/html/#scheduled-tasks) provides information about scheduled tasks, including their type, target and scheduling information.  The enhancement request would require more metadata being present on the tasks themselves, such as:  * last Execution Time * last Execution Status * next Execution Time  The issue also requests the ability to change a cron expression or to manually trigger a task. For that, Spring Boot would need a unique identifier for each task, which they don't have at the moment.  See spring-projects/spring-boot#17585 for context.","open","type: enhancement,","bclozel","2020-02-20T22:25:22Z","2022-05-12T06:36:17Z"
"","23937","Cannot bind for the generic collection property extended from super class","Hello everyone!! Here is code: ### Form.java (super class) ```java public class Form{     private String code;     private Integer uid;     private List items; // getter...  // setter... } ``` ### XyzForm.java ```java public class XyzForm extends Form{ // ... } ``` ### XyzFormItem.java ```java public class XyzFormItem{ private String name; private float price; // getter ... // setter ... } ``` =================  ### Ajax post data: ```json {   ""code"":"""",   ""uid"": """",   ""items[0].name"":""apple"",   ""items[0].price"": 3.5,   ""items[1].name"":""pear"",   ""items[1].price"": 2.0 } ```  ### IndexController.java ```java @PostMapping(""/save"") public Object save(XyzForm entity){ // TODO save     return 1; } ``` Then I got: ``` Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0         at java.util.ArrayList.rangeCheck(ArrayList.java:657) ~[?:1.8.0_211]         at java.util.ArrayList.get(ArrayList.java:433) ~[?:1.8.0_211]         at org.springframework.beans.AbstractNestablePropertyAccessor.getPropertyValue(AbstractNestablePropertyAccessor.java:638) ~[classes/:5.0.6.RELEASE] ``` eh.... After perusing the source code, I made a little change to method:`AbstractNestablePropertyAccessor.growCollectionIfNecessary`,  ```java private void growCollectionIfNecessary(Collection collection, int index, String name, PropertyHandler ph, int nestingLevel) { 		if (!isAutoGrowNestedPaths()) { 			return; 		} 		int size = collection.size(); 		if (index >= size && index < this.autoGrowCollectionLimit) { 			// Class elementType = ph.getResolvableType().getNested(nestingLevel).asCollection().resolveGeneric();                             Class elementType = ph.toTypeDescriptor().getResolvableType().getNested(nestingLevel).asCollection().resolveGeneric(); 			if (elementType != null) { 				for (int i = collection.size(); i < index + 1; i++) { 					collection.add(newValue(elementType, null, name)); 				} 			} 		} 	} ```  It's seems good to me. But is there any danger or side effects to the framework?? Or it's just a bug...","closed","status: invalid,","ScOrPiOzzy","2019-11-05T13:55:12Z","2019-11-13T10:44:51Z"
"","24222","Aysnc request cors Interceptor will repeat set Vary header","## version `2.2.2` ## example   `WebMvcConfigurer` ``` CorsRegistration corsRegistration = registry.addMapping(""/**"")                 .allowCredentials(true); corsRegistration.allowedHeaders(""*"")                 .maxAge(1800L)                 .allowedMethods(HttpMethod.GET.name(),                         HttpMethod.POST.name(),                         HttpMethod.PUT.name(),                         HttpMethod.OPTIONS.name(),                         HttpMethod.DELETE.name())                 .exposedHeaders(""Content-Length""); ``` `controller` ``` @RequestMapping(""/test) @RestController public class ExampleController {     @GetMapping     public CompletableFuture test() {         // do something     } } ```  `reponse headers` ``` Vary | Origin Vary | Access-Control-Request-Method Vary | Access-Control-Request-Headers Vary | Origin Vary | Access-Control-Request-Method Vary | Access-Control-Request-Headers ```","closed","status: superseded,","blackstorm","2019-12-18T04:19:19Z","2019-12-18T16:27:29Z"
"","24177","Failure in BeanUtils.copyProperties(source, target)","**Affects:** Version 5.0 and above  ---   **Issue:** Failure in BeanUtils.copyProperties(source, target)  **Stack Trace:**  Exception in thread ""main"" java.lang.NullPointerException 	at org.springframework.core.BridgeMethodResolver.findBridgedMethod(BridgeMethodResolver.java:69) 	at org.springframework.beans.GenericTypeAwarePropertyDescriptor.(GenericTypeAwarePropertyDescriptor.java:70) 	at org.springframework.beans.CachedIntrospectionResults.buildGenericTypeAwarePropertyDescriptor(CachedIntrospectionResults.java:359) 	at org.springframework.beans.CachedIntrospectionResults.(CachedIntrospectionResults.java:316) 	at org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:186) 	at org.springframework.beans.BeanUtils.getPropertyDescriptors(BeanUtils.java:360) 	at org.springframework.beans.BeanUtils.copyProperties(BeanUtils.java:608) 	at org.springframework.beans.BeanUtils.copyProperties(BeanUtils.java:579)   **Initial Analysis:**  - findBridgedMethod(Method bridgeMethod) method of BridgeMethodResolver was refactored as part of Spring 5.0 release. - Whenever this method is invoked for getting writeMethodToUse for propertyName = class, it results in Null Pointer exception as isBridge() method of bridgeMethod is invoked which is null.","closed","","DhavalShewale","2019-12-10T10:53:38Z","2021-01-08T13:09:15Z"
"","24546","Wss4jSecurityInterceptor not propagating time to live values when validating ws-security soap header timestamp","**Affects:** spring-ws-security-3.0.8.RELEASE  ---  # Description # I have spring web services deployed to remote hosts offshore that may not be using NTP services to keep their clocks synchronised resulting in potential skewing of those server system clocks.  This is out of my control and causes an issue with the web service ws-security handling specifically relating to the ws-security header timestamp validation of the received message.  I attempted to increase the time to live attributes on the definition of the Wss4jSecurityInterceptor bean for example by setting these 3: ```xml                      ``` The full bean definition: ```xml                                                                                                                                                                                                                     ``` # Problem # Strangely, the problem did not improve.  The timestamp validation was still failing.  I had increased the ttl values to 420 seconds (7 minutes) but it appeared the update had no effect. I've done some analysis debugging the `Wss4jSecurityInterceptor` locally and came up with the following observations: Default values from `Wss4jSecurityInterceptor`: ```java private boolean timestampStrict = true; private int validationTimeToLive = 300; private int futureTimeToLive = 60; ``` The `TimestampValidator.validate()` method is actually called twice within the `Wss4jSecurityInterceptor.validateMessage()` method.   **Firstly** in the `securityEngine.processSecurityHeader()` and **subsequently** in the `verifyTimestamp()` method. It appears that the `TimestampValidator.validate()` method requires an initialised `RequestData` object passed in with the various time to live attributes propagated from the attributes of the `Wss4jSecurityInterceptor`.    Within the code of the `Wss4jSecurityInterceptor.validateMessage()` method there is an attempt to do just that via `initializeValidationRequestData()`: ```java @Override protected void validateMessage(SoapMessage soapMessage, MessageContext messageContext) 			throws WsSecurityValidationException { ... RequestData validationData = initializeValidationRequestData(messageContext); WSHandlerResult result = securityEngine 				.processSecurityHeader(elem, validationData); ... verifyTimestamp(result); ``` However, the `initializeValidationRequestData()` method doesn't propagate the attributes.  Therefore the `processSecurityHeader()` processing ends up using the default values contained in the `RequestData` object being: ```java     /**      * The time in seconds between creation and expiry for a Timestamp. The default      * is 300 seconds (5 minutes).      */     private int timeStampTTL = 300;      /**      * The time in seconds in the future within which the Created time of an incoming      * Timestamp is valid. The default is 60 seconds.      */     private int timeStampFutureTTL = 60; ``` This is why the overall ws-security header validation still fails because it's using these default values instead of those I had explicitly set on the `Wss4jSecurityInterceptor` bean.  # Workaround # To address this, I extended `Wss4jSecurityInterceptor` and overrode the `initializeValidationRequestData()` method as follows: ```java     /**      * Fix: The parent calls a processSecurityHeader method on the WSSecurityEngine      * prior to calling the verifyTimestamp as part of the validateMessage method.      * The problem is that the necessary time to live attributes are not propagated       * during the initializeValidationRequestData method in the parent so we need      * to do it explicitly here unfortunately.      */     @Override     protected RequestData initializeValidationRequestData(MessageContext messageContext)     {         RequestData requestData = new RequestData();         requestData = super.initializeValidationRequestData(messageContext);         requestData.setTimeStampFutureTTL(futureTimeToLive);         requestData.setTimeStampTTL(validationTimeToLive);         requestData.setTimeStampStrict(timestampStrict);         return requestData;     } ``` This ensures that the `RequestData` object is correctly configured before either of the two calls to verify the timestamps.  Without this, the `processSecurityHeader()` would fail the timestamp validation as it wasn't picking up the specified ttl values from the bean.  I think the `initializeValidationRequestData()` method in `Wss4jSecurityInterceptor` class should propagate the values to the `RequestData` object as per my overridden method and that would solve this bug.  Perhaps then the correctly initialised `RequestData` object could be passed to the `verifyTimestamp()` method too precluding the need for a new object to be created again inside that method.","closed","for: external-project,","mightybeaker","2020-02-18T04:49:45Z","2020-02-19T03:23:15Z"
"","24479","BigDecimal in multi-value request body deserializes differently than single-value","**Affects:** spring-webflux:5.2.3.RELEASE  ---  **Given** a WebFlux RestController has an endpoint mapped, with `@RequestBody` of type `Flux` and returns the first value of reactive stream as a response, **when** calling the endpoint with payload `[ -1E+2 ]` (array of floats written in E notation), **then** response contains `-100.0`, instead of `-1E+2`.  _(Note: problem lays in deserialization of request body, not serialization of the response)_  When request body is mapped as a single-value, i.e. `Mono`, the request body is not normalized and response looks as expected. Non-reactive servlet controller also works consistently, as expected, for both single-value `BigDecimal` request body and multi-value `List`.  Test to reproduce (single-value testcase passes, multi-values testcase fails): ```java package com.example.demo;  import org.junit.jupiter.api.Test; import org.springframework.http.MediaType; import org.springframework.test.web.reactive.server.WebTestClient; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; import reactor.core.publisher.Mono;  import java.math.BigDecimal;  class MyTest {     private final WebTestClient client = WebTestClient.bindToController(new TestController()).build();      @Test     void shouldDeserializeSingleBigDecimal() {         client.post().uri(""/single"")               .contentType(MediaType.APPLICATION_JSON)               .bodyValue(""-1E+2"")               .exchange()               .expectStatus().isOk()               .expectBody().json(""-1E+2"");     }      @Test     void shouldDeserializeMultipleBigDecimals() {         client.post().uri(""/multiple"")               .contentType(MediaType.APPLICATION_JSON)               .bodyValue(""[ -1E+2 ]"")               .exchange()               .expectStatus().isOk()               .expectBody().json(""-1E+2"");     }      @RestController     static class TestController {          @PostMapping(""/single"")         Mono single(@RequestBody Mono entity) {             return entity;         }          @PostMapping(""/multiple"")         Mono multiple(@RequestBody Flux values) {             return values.single();         }     } } ```","closed","type: enhancement,","xdom","2020-02-04T21:00:18Z","2020-05-11T14:36:35Z"
"","24737","[Spring-messaging] Spring Websocket incorrect message handling","**Affects:** spring-messaging:5.2.1-RELEASE --- Problem: Wrong broadcasting behavior. I'm using spring-messaging to deal with websockets and STOMP as subprotocol. When some clients subscrib to specific topic my application starts broadcasting all sessions with: `SimpMessagingTemplate.convertAndSend(String destination, Object payload);` method.  As I can see in `SimpleBrokerMessageHandler` logs all subscribers get their messages.  But then spring triggers `HeartbeatTask` (inside `SimpleBrokerMessageHandler`) and sends **DISCONNECT_ACK** frame to the client and removes session (`SessionInfo`) from cache.  So as a result we can not send messages to the user anymore.  This happens because I use `convertAndSend` instead of `convertAndSendToUser` so  `updateSessionReadTime(sessionId);` method is ignored (when using convertAndSend no sessionId is sent).  I suppose that we should update _lastReadTime_ in `sendMessageToSubscribers()` as it happens with _lastWriteTime_ or rewrite `updateSessionReadTime()` that will handle sessions according to destinations.","closed","status: invalid,","Maxim-Gadalov","2020-03-19T16:13:18Z","2020-03-25T20:26:56Z"
"","24146","Add accessor for logPrefix in ClientResponse to allow tying a ClientRequest to a ClientResponse","**Affects:** spring-framework:spring-webflux:5.1.9.RELEASE  ---   Hello,  I have a use case while making webclient requests where we use parts of the clientrequest and clientresponse together to form a log. In the clientRequest, logPrefix is an accessible unique identifier that is passed from the request to the response, yet when we try to do the same for the clientResponse, the field is present but not accessible.  We've considered a workaround where we create a custom ExchangeFunction that forces the logPrefix id into the headers of the clientRequest so that it can be read in the response, but even then, DefaultClientResponse is package-protected, which makes creating the ExchangeFunction difficult.  There is also a possibility we've overlooked a solution for this, so if there's a way to easily tie together a webclient request and response, please let me know.  If not, our proposed fix is simply to expose the logPrefix like all the other clientResponse fields.  Thank you!","closed","type: enhancement,","epiwd","2019-12-06T00:47:08Z","2019-12-13T18:20:58Z"
"","24034","@Validated is not honored for local service method invocations","**Affects:** Spring Framework 5.1  ---  Having a `Service `and `Validated` annotated class makes it possible to add validation annotations to its service methods (e.g. as described in this [tutorial](https://reflectoring.io/bean-validation-with-spring-boot/#validating-input-to-a-spring-service-method)).  This works fine: ```java  @Service @Validated class ValidatingService {      void validateInput(@Valid @NotNull String input1,                        @Valid @NotEmpty Map input2) {       // input1 is for sure not null and input2 is for sure not empty     }  } ``` But this not:  ```java @Service @Validated class ValidatingService {      public void validateInput(String input1, Map input2) {        if (something)          internalValidateInput(input1);        else          internalValidateInput(input2);     }     public void internalValidateInput(@Valid @NotNull String input) {       // input is not validated at all, why?     }      public void internalValidateInput(@Valid @NotEmpty Map input) {       // input is not validated at all, why?     }  } ``` The simple and working first approach cannot be used, since the use case is that in `validateInput` either only one of the inputs is provided, thus the other one is null/empy and based on the `something` strategy either the one or the other should be validated, but never both together. The second approach with `internalValidateInput` methods is just not working.  Nevertheless when the validation is extracted in a separate validation service class it works, but it looks weird: ```java @Service class ValidatingService {      @Autowired     private CustomValidator validator;      public void validateInput(String input1, Map input2) {        if (something)          internalValidateInput(input1);        else          internalValidateInput(input2);     }     public void internalValidateInput(String input) {       this.validator.validate(input);       // now the validation works and input is for sure not null     }      public void internalValidateInput(Map input) {       this.validator.validate(input);       // now the validation works and input is for sure not empty     }  }  @Service @Validated class CustomValidator {      void validate(@Valid @NotNull String input) {         // remains an empty implementation, kind of dirty hack :)?     }     void validate(@Valid @NotEmpty Map input) {         // remains an empty implementation, kind of dirty hack :)?    } } ```","closed","in: core,","hadjiski","2019-11-19T18:55:51Z","2019-11-20T15:10:10Z"
"","24011","Spring Batch: AbstractFileItemWriter should support java.nio","**Affects:** Spring Batch / spring-batch-infrastructure (master)  ---   Spring Batch / spring-batch-infrastructure: [AbstractFileItemWriter.java ](https://github.com/spring-projects/spring-batch/blob/d8fc58338d3b059b67b5f777adc132d2564d7402/spring-batch-infrastructure/src/main/java/org/springframework/batch/item/support/AbstractFileItemWriter.java) always uses java.io no matter which `org.springframework.core.io.Resource` is used.  As the class represents a `FileItemWriter`, Resource could be specialized to a `WritableResource`. This allows a `AbstractFileItemWriter` java.nio based implementation.","closed","for: external-project,","rowi1de","2019-11-17T16:10:07Z","2019-11-17T16:12:14Z"
"","24248","IllegalArgumentException with Spring AOP","**Affects:** Spring AOP 5.0.7.RELEASE  I'm building an application and I'm using aspects to modify some of my business objects. When I'm starting my application I get the following stacktrace (only the root is shown):  ```java java.lang.IllegalArgumentException: methods with same signature get() but incompatible return types: [interface main.DomainObjectInterfaceA, interface main.DomainObjectInterfaceB] 	at sun.misc.ProxyGenerator.checkReturnTypes(ProxyGenerator.java:712) 	at sun.misc.ProxyGenerator.generateClassFile(ProxyGenerator.java:461) 	at sun.misc.ProxyGenerator.generateProxyClass(ProxyGenerator.java:339) 	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:639) 	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:557) 	at java.lang.reflect.WeakCache$Factory.get(WeakCache.java:230) 	at java.lang.reflect.WeakCache.get(WeakCache.java:127) 	at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:419) 	at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:719) 	at org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:123) 	at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) 	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:473) 	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:355) 	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:304) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:439) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1712) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:581) 	... 10 more ```   I extracted this in a minimal code snippet from my application to reproduce this stacktrace.   My domain model consists of three classes:  ```java package main; public interface DomainObjectInterfaceA { } package main; public interface DomainObjectInterfaceB{ } package main; public class DomainObjectImplementation implements DomainObjectInterfaceA, DomainObjectInterfaceB {    private int fieldToModifyThroughAspect = 0;    public int getFieldToModifyThroughAspect() {     return fieldToModifyThroughAspect;   }    public void setFieldToModifyThroughAspect( int aFieldToModify ) {     fieldToModifyThroughAspect = aFieldToModify;   } } ```  Furthermore I have the following two Spring components:  ```java package main; @Component public class ComponentImplementation implements ComponentInterfaceA, ComponentInterfaceB {    public DomainObjectImplementation get() {     return new DomainObjectImplementation();   } }  package main; @org.aspectj.lang.annotation.Aspect @Component public class Aspect {    @Pointcut( ""execution(public DomainObjectImplementation main.ComponentImplementation.*(..))"" )   public void anyPublicOperation() {   }    @AfterReturning( pointcut = ""anyPublicOperation()"", returning = ""aObject"" )   public Object get( Object aObject ) {     DomainObjectImplementation returningObject = ( DomainObjectImplementation ) aObject;     returningObject.setFieldToModifyThroughAspect( 5);     return returningObject;   }  } ```  The crucial part in reproducing the issue are the following two generic interfaces which are implemented by `ComponentImplementation`:  ```java package main; public interface ComponentInterfaceA {    T get();  } package main; public interface ComponentInterfaceB {    T get();  } ```  The above two interfaces share a method with the same signature, but a different generic type. `ComponentImplementation` implements those two interfaces with a class that satisfies both of those generic arguments.   The last two required classes are of course the `Main` class and the `Spring` Config class which are declared below:  ```java package main; @Configuration @EnableAspectJAutoProxy @ComponentScan( basePackageClasses = Config.class ) public class Config { }  package main; public class Main {    public static void main( String[] args ) {      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( Config.class );     ComponentImplementation bean = context.getBean( ComponentImplementation.class );     DomainObjectImplementation domainObject = bean.get();      System.err.println(""Aspect modified get method = "" + ( domainObject.getFieldToModifyThroughAspect() == 5));   }  } ```  I also tried to configure `EnableAspectJAutoProxy` with `proxyTargetClass = true`, but then the same stacktrace is thrown with a slightly different start (namely the JDK proxy vs the Cglib)   The complete dependencies list:  ```xml                    org.springframework       spring-aop       5.0.7.RELEASE                  org.springframework       spring-context       5.0.7.RELEASE                 org.springframework       spring-context-support       5.0.7.RELEASE                       org.aspectj       aspectjweaver       1.9.5                       aspectj       aspectjrt       1.5.4            ```","closed","for: stackoverflow,","peeterskristof","2019-12-23T10:14:52Z","2020-01-13T02:01:51Z"
"","24249","WebSocket - Problem with headers trying to use convertAndSendToUser method","**Affects:** Spring 2.1.10.RELEASE  ---  I'm trying to send a message directly to an user using `SimpMessageSendingOperations` or `SimpMessagingTemplate` but both doesn't work.  ``` simpMessagingTemplate.convertAndSend(""/user/"" + userSessionId + ""/queue/greetings"", ""Message One"");  messagingTemplate.convertAndSendToUser(userSessionId, ""/queue/greetings"", ""Message Two""); ```  I already inspected the internal classes to understand the problem and seems to be the headers. For example, if I create a `StompHeaderAccessor` and specially add any `nativeHeaders` and also set the SessionId and send as the last parameter of `convertAndSendToUser` it works.  ``` StompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.SEND); headerAccessor.setSessionId(purchaseReport.getSessionId()); headerAccessor.setNativeHeader(""Any header"", ""Any header"");  messagingTemplate.convertAndSendToUser(purchaseReport.getSessionId(), ""/queue/greetings"", ""Message Two"", headerAccessor.toMap()); ```  Because inside the `SimpMessagingTemplate` class there is a method called `processHeadersToSend` and if there is any Native headers it returns the same headers so in `AbstractMessageSendingTemplate` class the type of `headersToUse` variable changes to a HashMap and the behavior is different.  I also created a method annotated with `@SendToUser` to understand the idea and the same behavior happens:  ``` @MessageMapping({ ""/hello/{id}/websocket"" }) @SendToUser(value = ""/queue/greetings"") String generate(@DestinationVariable Integer id, @Payload Report report,                   SimpMessageHeaderAccessor headerAccessor) throws Exception {  messagingTemplate.convertAndSendToUser(headerAccessor.getHeader(""simpSessionId"").toString(),                 ""/queue/greetings"", ""This message doesn't work"");   messagingTemplate.convertAndSendToUser(headerAccessor.getHeader(""simpSessionId"").toString(),                 ""/queue/greetings"", ""This one works because have native headers"", headerAccessor.toMap());   return ""This one send by annotation works too""; ```  I'd like to know what I'm doing wrong or if I really need to always instantiate a HeaderAccessor and add any native headers to work?  Thanks in advance.","closed","status: invalid,","guibernardi","2019-12-23T13:45:05Z","2022-05-19T16:06:44Z"
"","24161","spring.io site document display issue","**Affects:** current  there is something wrong in this document. docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html  From somewhere the markdown grammar cannot be parsed. The categories on left panel only contains link before .1.9.4. it is displaying raw string, ==== Receiving Lifecycle Callbacks, rather than rendered markdown title. However the document in previous version displays well. [link](https://docs.spring.io/spring/docs/5.1.12.RELEASE/spring-framework-reference/core.html#spring-core)  I am not sure if this is the right place to raise the issue. If not, could help guide me to the right one?     ---","closed","status: duplicate,","doggerFrankXu","2019-12-08T08:49:55Z","2019-12-08T13:00:50Z"
"","24568","A wrong logical for ConvertersForPair#getConverter","**Affects:** \<5.2.3> --- ```java if (!(converter instanceof ConditionalGenericConverter) ||         ((ConditionalGenericConverter) converter).matches(sourceType, targetType)) {     return converter; } ```  it should be  ```java if ((converter instanceof ConditionalGenericConverter) &&         ((ConditionalGenericConverter) converter).matches(sourceType, targetType)) {     return converter; } ```","closed","status: feedback-reminder,","bonaluo","2020-02-22T10:30:08Z","2022-02-18T19:06:46Z"
"","24313","org.springframework.web.server.WebFilter Not working , while we have spring-boot-starter-web on classpath","**Affects:** \<5.2.2> Hi,  i have implemented custom webfilter for org.springframework.web.server.WebFilter , and i dont see incoming request being filtered when im having below 2 dependencies in my Project. 1) spring-boot-starter-web 2) spring-boot-starter-webflux  if i remove ""spring-boot-starter-web"" , every thing works just fine , but my project need has to have both the dependency for now , and i dont see any solution being given any where.  ---","closed","for: stackoverflow,","santhoshgs","2020-01-07T18:35:47Z","2020-01-10T08:09:13Z"
"","24304","Docs should warn against split URL handling across handler mappings","**Affects:** \<5.1.9.RELEASE>  ---  > This issue should also exist in older versions！      At the same time, through the custom controller and implement org.springframework.web.servlet.config.annotation.WebMvcConfigurer#addViewControllers to register the mapping of different methods with the url, a 405 error will occur. ```     @Override     public void addViewControllers(ViewControllerRegistry registry) {         registry.addViewController(""/foo"").setViewName(""foo"");     } ``` ```     @PostMapping(""/foo"")     public ResponseEntity foo() {         return ResponseEntity.ok(""Success!"");     } ```","closed","in: web,","xiaoqiang0-0","2020-01-07T04:48:20Z","2020-01-13T21:33:47Z"
"","24193","import spring-framework5.1.x to Idea","**Affects:** \ 5.1.x  \ 1.8.0_25  \ 4.9  spring-framework-5.1.x\spring-beans\src\main\java\org\springframework\beans\support\PropertyComparator.java:138: error：Incompatible types: PropertyComparatorCannot be converted toComparator 			source.sort(new PropertyComparator<>(sortDefinition)); 			            ^   Where CAP # 1 is a new type variable:     CAP # 1 capture extension object from? Note: Some messages have been simplified; use -Xdiags: verbose to recompile for full output  ---","closed","status: invalid,","Ifdevil","2019-12-12T09:32:07Z","2019-12-16T09:24:38Z"
"","23953","webClient filter superimposed by the number of requests","**Affects:** \ 5.1.10-REALEASE ![image](https://user-images.githubusercontent.com/36101454/68452964-0e9b5200-022f-11ea-9cf7-a79ccef00521.png)   ---","closed","status: invalid,","yuguhan","2019-11-08T05:52:58Z","2019-11-08T08:57:23Z"
"","24003","Cannot add a custom annotation to the defaults in AutowiredAnnotationBeanPostProcessor","**Affects:** \  ---  when set my own (non-Spring-specific) annotation type to indicate that a member is supposed to be autowired,but I found that I empty the original annotation (Autowired、Value) every time.I hope to add extra custom annotations just on the basis of the original. can remove this.autowiredAnnotationTypes.clear(); ? ![{C78F474A-748A-402C-B41E-4FEF5D1F22FC}_20191115103431](https://user-images.githubusercontent.com/33364651/68912589-87506000-0793-11ea-9931-45923fffda26.jpg)","closed","status: feedback-provided,","kse-music","2019-11-15T02:40:47Z","2019-11-18T10:20:34Z"
"","24821","spring.io can support more language for User of The world","**Affects:** \  ---    spring.io can support more language for User of The world?","closed","for: external-project,","AnswerNo2","2020-03-31T06:00:53Z","2020-03-31T10:47:30Z"
"","24113","BeanNameGenerator include package name","**Affects:** \  ---","closed","","torsten-github","2019-12-02T09:31:34Z","2019-12-02T09:32:07Z"
"","24071","SmartApplicationListener","**Affects:** \  ---","closed","","averycheng","2019-11-25T09:44:46Z","2019-11-25T09:44:59Z"
"","24016","Improve SimpleCommandLineArgsParser's javadoc - add other invalid example","**Affects:** 5.x (perhaps olders)  ---   I have the following situation:  * [Spring Framework: Why command line argument “--argument-name=” throws Invalid argument syntax?](https://stackoverflow.com/questions/58904260/spring-framework-why-command-line-argument-argument-name-throws-invalid-ar)  I read the javadoc of the [SimpleCommandLineArgsParser](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/SimpleCommandLineArgsParser.java#L19) class  Through a comment of the post, now is clear the reason, therefore I think has sense to include a new invalid scenario:  * `--foo=`  If it is acceptable I would add that scenario and send a pull request. But I need your confirmation first.  Thanks","open","in: core,","manueljordan","2019-11-18T12:44:04Z","2021-11-11T10:12:42Z"
"","24652","Spring generates huge callstack for async requests","**Affects:** 5.2.4.RELEASE  For coroutines response, Spring generates a lot of intermediate classes and produce deep callstack.  **Question:** is it bug or feature?  Potentially this can lead to increased memory traffic and performance degradation.  Possible fix - use kotlin inside the spring (which produce smaller callstack, because of set of optimizations) or return initial mono if no additional actions is needed (e.g. try avoid creation new Mono object if possible)  Callstack example:  ``` 	at org.springframework.web.reactive.function.server.CoRouterFunctionDsl$asHandlerFunction$1$1.invokeSuspend(CoRouterFunctionDsl.kt:599) 	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) 	at kotlinx.coroutines.DispatchedContinuationKt.resumeCancellableWith(DispatchedContinuation.kt:313) 	at kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:26) 	at kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt:109) 	at kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt:158) 	at kotlinx.coroutines.reactor.MonoKt$monoInternal$1.accept(Mono.kt:55) 	at kotlinx.coroutines.reactor.MonoKt$monoInternal$1.accept(Mono.kt) 	at reactor.core.publisher.MonoCreate.subscribe(MonoCreate.java:57) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:55) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:274) 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:851) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2267) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2075) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1949) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:55) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	at reactor.core.publisher.Operators.complete(Operators.java:135) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:441) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:211) 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:161) 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:55) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4110) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:55) 	at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64) 	at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:228) 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:465) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:90) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) 	at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:170) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:321) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:295) 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 	at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:792) 	at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1.run(AbstractEpollChannel.java:387) 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","type: bug,","imanushin","2020-03-06T11:29:29Z","2020-03-24T18:08:45Z"
"","24622","Jaxb2XmlDecoder Does Not Throw Codec Exception For Invalid XML","**Affects:** 5.2.4 ---  Affected area: Web client decoders (`org.springframework.core.codec.Decoder`)  **Expected Behaviour** Decoders throw an instance of a CodecException when unmarshalling of response to POJO fails.   **Actual behaviour** `Jaxb2XmlDecoder` throws `NoSuchElementException` when the xml returned from the downstream is not valid ie. missing close tag. The exception is actually thrown by the `XmlEventDecoder` which does not look to be consistent in it's exception handling against all other implementations of the `Decoder` interface.  I've created a sample test in the project below that shows the failure when handling invalid xml responses and another test showing how the same failure with an invalid json body is handled correctly. https://github.com/michaelmcfadyen/spring-xml-decoder-issue","closed","type: enhancement,","michaelmcfadyensky","2020-03-01T17:01:05Z","2020-03-25T15:40:32Z"
"","24761","Prepare for Postgres JDBC driver backward incompatible change","**Affects:** 5.2.4  Postgres driver 42.2.11 introduces this change https://github.com/pgjdbc/pgjdbc/pull/1729. Basically it makes commit fail if a JDBC command in the transaction failed. It is possibly a breaking change since code like this will start to throw an exception on transaction commit.  ```java     @org.springframework.transaction.annotation.Transactional     public void insert() {         try {             jdbcTemplate.update(""insert into my_table values('test')"");         } catch(DataAccessException e) {             // ignored, expected behavior             logger.info(""action=error_on_insert {}"", e.getMessage());         }     } ``` It's reproduced here https://github.com/lukas-krecan/datasource-demo  See https://github.com/pgjdbc/pgjdbc/issues/1739 for details and discussion. I do not know if Spring can do something to prevent the issue, I just wanted to give you heads-up.","closed","","lukas-krecan","2020-03-22T16:54:28Z","2022-02-18T19:06:47Z"
"","24461","Error in link for @ControllerAdvice in Webflux doc","**Affects:** 5.2.3.RELEASE  --- The link for the word ""@ControllerAdvice"" in the page https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-controller-exceptions is broken. Currently, the link goes to https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#mvc-ann-controller-advice but it should go to https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice","closed","type: task,","admoca60","2020-01-30T17:22:56Z","2020-01-31T10:28:43Z"
"","24498","Type erasure during serialization of polymorphic JSON in Optional/Page","**Affects:** 5.2.3.RELEASE  ---   Given an endpoint that returns a polymorphic JSON type, eg.  ```java @JsonTypeInfo(use = JsonTypeInfo.Id.NAME) @JsonSubTypes({Impl1.class, Impl2.class}) public interface Parent { }  public class Impl1 implements Parent { }  public class Impl2 implements Parent { }  @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE) public Parent get() {     return new Impl1(); } ```  Jackson will serialize it with the property `@type`, eg. ```json {     ""@type"": ""Impl1"" } ```  However, when wrapping it with an `Optional`/[Page](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Page.html), the JSON polymorphism no longer works. Eg. ```java @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE) public Optional getOptional() {     return Optional.of(new Impl1()); } ``` returns: ```json {} ```  According to FasterXML/jackson-databind#1594 this is due to type erasure, however the JSON polymorphism still works when wrapping with built-in `Collection`s (eg. `List`/`Set`/`Map`), eg. ```java @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE) public Collection getCollection() {     return Collections.singleton(new Impl1()); } ```  So it seems like Spring has special handling for built-in `Collection`s. Is it possible to apply them to `Optional`/[Page](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Page.html) as well?  Currently the workaround is to create custom `JsonSerializer`s for `Optional`/[Page](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Page.html), eg. ```java @JsonComponent public class OptionalSerializer extends JsonSerializer> {     @Override     public void serialize(Optional value, JsonGenerator gen, SerializerProvider serializers) throws IOException {         if (value.isPresent()) {             gen.writeObject(value.get());         }     } } ```","open","in: web,","daniel-shuy","2020-02-10T08:19:18Z","2020-08-21T13:38:48Z"
"","24132","TOC generated by asciidoc for core-beans.adoc is truncated","**Affects:** 5.2.2.RELEASE ---   This is a trivial issue with table of contents which are generated by asciidoc. Look at the picture I uploaded some tocs were missing. Last three days I had been reading the spring-framework-reference with previous RELEASE(maybe 5.1.9RELEASE). When I open the newest reference website, the missing happened. ![11575470056_ pic_hd](https://user-images.githubusercontent.com/5013543/70151290-5a360400-16e6-11ea-844c-1d06f049b8da.jpg)  I've been comparing the diff between previous RELEASE and 5.2.2 RELEASE, something wrong in **core/core-beans.adoc** ![21575471072_ pic_hd](https://user-images.githubusercontent.com/5013543/70152672-9c604500-16e8-11ea-9d78-aa4fbb92ab2b.jpg)  After I delete the four equal marks which stand for Level 3 Section in asciidoc, and execute ` ./gradlew asciidoctor` the reference generated in my computer has the complete tocs. ![31575471652_ pic_hd](https://user-images.githubusercontent.com/5013543/70153476-f7df0280-16e9-11ea-9b99-41227587b4d8.jpg)","closed","type: documentation,","Farteen","2019-12-04T15:01:52Z","2019-12-06T12:58:39Z"
"","24227","Incomplete table of content in spring core reference doc","**Affects:** 5.2.2-RELEASE  ---   In the [spring core reference doc](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#spring-core), the table of content shows only one chapter: ""1. The IoC Container"", all other chapters are not listed. All content seems visible though.","closed","status: duplicate,","JohnWu-Pro","2019-12-18T14:20:38Z","2019-12-20T09:10:37Z"
"","24502","@Transactional on one interface is propagated to all interfaces implemented by target class","**Affects:** 5.2.2  --- Currently we are migrating from from Spring 4.3.23 to 5.2.2(3). During the process we found out that some of our methods, which should be running **without transaction**, started to fail because of missing context (related to our application) **to start transaction**.  In example below (only for idea, not really tested) only one method will create transaction in 4.3 (expected) but both methods will create transactions in 5.2 (wrong):  ``` @Transactional(propagation=Propagation.REQUIRED) interface TransactionalInterface {   void transactionalMethod(); }  interface NormalInterface {   void normalMethod(); }  class TargetClass implements TransactionalInterface, NormalInterface {   @Override   public void transactionalMethod() {     System.out.println(""Method starting transaction"");   }    @Override   public void normalMethod() {     System.out.println(""Method shouldn't start transaction but does"");   } } ```  After some debugging I found out that behavior changed after commit https://github.com/spring-projects/spring-framework/commit/42d6d7ec4e2ddabc9c50dab6d6ac572ef46d2a6a. Removing check for existing annotations on passed element in _AnnotationTransactionAttributeSource#determineTransactionAttribute_ caused that all @Transactional annotations from target class hierarchy are merged (as far as I understand it) and returned already for target class level (second lookup in _AbstractFallbackTransactionAttributeSource#computeTransactionAttribute_). By disregarding next two lookups for annotations on original method or its class/interface it basically ""propagate"" @Transactional to all implemented interfaces. And that's wrong behavior from my point of view.","open","in: data,","bambi73","2020-02-11T12:22:03Z","2021-11-10T09:27:06Z"
"","24400","Allow non-standard HttpStatus in reactive ServerHttpResponse","**Affects:** 5.2.1.RELEASE --- in `org.springframework.http.server.reactive.ServerHttpResponse` we have the following method :  `boolean setStatusCode(@Nullable HttpStatus status);` that is supposed to allow us to set the http status code for the response. The problem is that we can't use a simple int value and we have to pass through HttpStatus that cannot resolve non-standard Http status codes (498 in my case)  I've already asked on SO and apparently there is no way to make this work in the current release ?","closed","type: enhancement,","saad14092","2020-01-20T09:07:01Z","2020-01-30T10:11:22Z"
"","24098","RSocket vs HTTP performance","**Affects:** 5.2.1  I have done some research on the performance of RSocket vs HTTP for a service-to-service communication of [FHIR](http://hl7.org/implement/standards/fhir/) resources. According to the initial results, the RSocket performance seems to be lower (or, at most, equal) to the one provided by HTTP (using REST).  The full details of the research and the performance issues are thoroughly detailed in [this](https://stackoverflow.com/questions/59081073/rsocket-vs-http-performance-for-transferring-fhir-resources) StackOverflow post.  I am aware the discussion/issue would be more appropriate to be posted on the [RSocket community](https://community.netifi.com/) space. As the page is not working and the StackOverflow issue may not be read by the appropriate people, I have posted the question also here. My apologies if it will be considered an inappropriate place.","closed","status: superseded,","bogdansolga","2019-11-28T12:33:23Z","2019-11-28T14:04:27Z"
"","24020","Alternative to @Qualifier for group beans","**Affects:** 5.2.1  ---   At the moment, we can autowire a bean within specialized scope using `@Qualifier` annotation, e.g.  ```java @Bean @Qualifier(""specialized-scope"") Dependency dependency() { /* code */ }  @Bean Service service(@Qualifier(""specialized-scope"") Dependency dependency) { /* code */ } ```  But the process might become tedious and error prone, once we have multiple bean with the same qualifiers, for example:  ```java @Configuration class GlobalModule {    @Bean   @Qualifier(""specialized-scope"")   Dependency1 dependency1() { /* code */ }    @Bean   @Qualifier(""specialized-scope"")   Dependency2 dependency2(@Qualifier(""specialized-scope"") Dependency1  dependency1) { /* code */ }    @Bean   @Qualifier(""specialized-scope"")   Dependency3 dependency3(@Qualifier(""specialized-scope"") Dependency1  dependency1, @Qualifier(""specialized-scope"") Dependency2  dependency2) { /* code */ }    // I want to expose only this bean to the global scope   @Bean   Service service(@Qualifier(""specialized-scope"") Dependency3 dependency3) { /* code */ } } ```  Is it possible to create the qualifier once like below and have all the beans inherit the qualifier from configuration scope?  ```java @Configuration @Qualifier(""specialized-scope"") class SpecializedModule {    @Bean   Dependency1 dependency1() { /* code */ }    @Bean   Dependency2 dependency2(Dependency1 dependency1) { /* code */ }    @Bean   Dependency3 dependency3(Dependency1 dependency1, Dependency2 dependency2) { /* code */ } }  @Configuration class GlobalModule {    @Bean   Service service(@Qualifier(""specialized-scope"") Dependency3 dependency3) { /* code */ } } ```","closed","status: invalid,","ntviet18","2019-11-18T23:20:10Z","2019-11-19T15:21:04Z"
"","23932","Specified transaction manager is not a ReactiveTransactionManager","**Affects:** 5.2.0.RELEASE  after upgrade to spring boot 2.2 method with `@Transactional` will throw exception ``` java.lang.IllegalStateException: Specified transaction manager is not a ReactiveTransactionManager: org.springframework.orm.jpa.JpaTransactionManager@4674ac4d 	at org.springframework.transaction.interceptor.TransactionAspectSupport$ReactiveTransactionSupport.asReactiveTransactionManager(TransactionAspectSupport.java:957) ~[spring-tx-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.transaction.interceptor.TransactionAspectSupport$ReactiveTransactionSupport.determineTransactionManager(TransactionAspectSupport.java:929) ~[spring-tx-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.transaction.interceptor.TransactionAspectSupport$ReactiveTransactionSupport.invokeWithinTransaction(TransactionAspectSupport.java:848) ~[spring-tx-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:335) ~[spring-tx-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99) ~[spring-tx-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) ~[spring-aop-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at com.tencent.cloud.iov.account.service.CAMService$$EnhancerBySpringCGLIB$$fcb5db19.process() ~[main/:na] ``` it's look like because there is graphql-java in classpath, which depend reactivestreams and spring do reactive transaction due to reactivestreams in classpath but my application is a spring mvc application ```java 	/** 	 * Reactive Streams API present on the classpath? 	 */ 	private static final boolean reactiveStreamsPresent = 			ClassUtils.isPresent(""org.reactivestreams.Publisher"", TransactionAspectSupport.class.getClassLoader()); ```  expected result: work normal as spring 5.1/ spring boot 2.1","closed","status: duplicate,","okhowang","2019-11-05T07:04:20Z","2019-11-05T08:06:02Z"
"","24144","JmsTemplate ignoring TTL on message level","**Affects:** 5.1.x   ---  On sending message to JMS expiration header is ignored by JmsTemplate.  TTL may be set per message - [`Message.setJMSExpiration(long expiration)`](https://docs.oracle.com/javaee/7/api/javax/jms/Message.html#setJMSExpiration-long-). For now JmsTesmpate support expiration of message per producer - any message level TTL is [ignored](https://github.com/spring-projects/spring-framework/blob/master/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java) ``` 	 /** 	 * Actually send the given JMS message. 	 * @param producer the JMS MessageProducer to send with 	 * @param message the JMS Message to send 	 * @throws JMSException if thrown by JMS API methods 	 */ 	protected void doSend(MessageProducer producer, Message message) throws JMSException { 		if (this.deliveryDelay >= 0) { 			producer.setDeliveryDelay(this.deliveryDelay); 		} 		if (isExplicitQosEnabled()) { 			producer.send(message, getDeliveryMode(), getPriority(), getTimeToLive()); 		} 		else { 			producer.send(message); 		} 	} ```  **Suggestion:** resolve TTL of message in following way: 1. TTL per message - if not set then 2. TTL per producer  Current `JmsTemplate` implementation checks for 2 ignoring message level.  Example of fix: ``` 	 /** 	 * Actually send the given JMS message. 	 * @param producer the JMS MessageProducer to send with 	 * @param message the JMS Message to send 	 * @throws JMSException if thrown by JMS API methods 	 */ 	protected void doSend(MessageProducer producer, Message message) throws JMSException { 		if (this.deliveryDelay >= 0) { 			producer.setDeliveryDelay(this.deliveryDelay); 		}                                 producer.setTimeToLive(resolveTimeToLive(message));  		if (isExplicitQosEnabled()) { 			producer.setDeliveryMode(getDeliveryMode()); 			producer.setPriority(getPriority()); 		}  		producer.send(message); 	}  	private long resolveTimeToLive(Message message){        		long messageTimeToLive = message.getJMSExpiration();  		if (messageTimeToLive > 0{                 	return  messageTimeToLive ; 		} else {                 	return  getTimeToLive()); 		} 	} ```  PR could be created and provided.","closed","status: invalid,","cynicLT","2019-12-05T18:12:26Z","2019-12-07T15:14:40Z"
"","24035","Handler Interceptor Adapter","**Affects:** 5.1.9  --- This is related to  issue #21797. I am creating this here as I haven't been able to hear anything on [Stackoverflow](https://stackoverflow.com/questions/58810122/spring-webflux-handler-interceptor-adapter) and Gitter.   I am migrating a Spring MVC library to Spring WebFlux. There is a feature that lets our clients annotate their controller methods to perform custom validation (and applying some business rules) on incoming headers before granting access to the API.  In Spring MVC we had that accomplished by using HandlerInterceptorAdapter. Since WebFlux doesn't have anything similar I was trying out the solution as suggested by @rstoyanchev  in issue #21797. However it doesn't work for this use case since the method handler info is only available in onSuccess operator and its too late to get the info for annotation processing.  I was trying out the other approach suggested there using `@ModelAttribute` method on a `@ControllerAdvice` but that only work if the annotation is applied to the Controller class in our case the annotation is applied on methods of controller class.  I wanted to know if annotation processing is going to be supported the way it . has been with MVC or what's the recommended way to implement annotations in WebFlux  Here is a sample https://github.com/ranarula/handleInterceptor with the issue","closed","status: declined,","ranarula","2019-11-19T22:21:59Z","2021-01-27T03:51:29Z"
"","23889","Exception loading LocalSessionFactoryBean -  signer information does not match signer information of other classes in the same package","**Affects:** 5.1.4.RELEASE  ---   Hello,  My application is running on Java 11 and I am using Spring 5.1.4.RELEASE with Hibernate Core 5.3.7.Final.  I am trying to run my application in Jetty via Maven and in the stack trace I see:   `java.lang.SecurityException: class ""javax.transaction.SystemException""'s signer information does not match signer information of other classes in the same package`  The full stack trace is shown in the attached file.  I can see from it that this happens when intialising the bean org.springframework.orm.hibernate5.LocalSessionFactoryBean .    Also Attached is a copy of my Application Context with the bean definitions.  [security-datasource-context.xml.txt](https://github.com/spring-projects/spring-framework/files/3785233/security-datasource-context.xml.txt)  [stacktrace.txt](https://github.com/spring-projects/spring-framework/files/3785172/stacktrace.txt)","open","in: data,","SachinSharmaEarthport","2019-10-29T18:43:06Z","2021-11-10T12:13:42Z"
"","24247","LocalValidatorFactoryBean makes blocking call (detected by blockhound)","**Affects:** 5.1.12.RELEASE  ---  Blockhound detects a blocking call when `LocalValidatorFactoryBean` performs validation  Stack trace below:   ``` reactor.core.Exceptions$ReactiveException: java.lang.Error: Blocking call! java.io.FileInputStream#readBytes  	at reactor.core.Exceptions.propagate(Exceptions.java:356) 	at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:91) 	at reactor.core.publisher.Mono.block(Mono.java:1495) 	at com.mycompany.myapp.FailValidationIT.test(FailValidationIT.java:19) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:532) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:171) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:167) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:114) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:59) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:108) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:112) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$4(NodeTestTask.java:112) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:98) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:74) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:93) 		... 41 more Caused by: java.lang.Error: Blocking call! java.io.FileInputStream#readBytes 	at reactor.blockhound.BlockHound$Builder.lambda$new$0(BlockHound.java:196) 	at reactor.blockhound.BlockHound$Builder.lambda$install$6(BlockHound.java:318) 	at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:46) 	at java.base/java.io.FileInputStream.readBytes(FileInputStream.java) 	at java.base/java.io.FileInputStream.read(FileInputStream.java:279) 	at java.base/java.io.BufferedInputStream.fill(BufferedInputStream.java:252) 	at java.base/java.io.BufferedInputStream.read1(BufferedInputStream.java:292) 	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:351) 	at org.springframework.asm.ClassReader.readStream(ClassReader.java:306) 	at org.springframework.asm.ClassReader.(ClassReader.java:273) 	at org.springframework.core.LocalVariableTableParameterNameDiscoverer.inspectClass(LocalVariableTableParameterNameDiscoverer.java:114) 	at org.springframework.core.LocalVariableTableParameterNameDiscoverer.getParameterNames(LocalVariableTableParameterNameDiscoverer.java:74) 	at org.springframework.core.PrioritizedParameterNameDiscoverer.getParameterNames(PrioritizedParameterNameDiscoverer.java:55) 	at org.springframework.validation.beanvalidation.LocalValidatorFactoryBean$1.getParameterNames(LocalValidatorFactoryBean.java:325) 	at org.hibernate.validator.internal.util.ExecutableParameterNameProvider.getParameterNames(ExecutableParameterNameProvider.java:37) 	at org.hibernate.validator.internal.metadata.aggregated.ParameterMetaData$Builder.build(ParameterMetaData.java:169) 	at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.findParameterMetaData(ExecutableMetaData.java:435) 	at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:388) 	at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) 	at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:204) 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:166) 	at org.hibernate.validator.internal.engine.ValidatorImpl.validate(ValidatorImpl.java:157) 	at org.springframework.validation.beanvalidation.SpringValidatorAdapter.validate(SpringValidatorAdapter.java:358) 	at org.springframework.data.mongodb.core.mapping.event.ValidatingMongoEventListener.onBeforeSave(ValidatingMongoEventListener.java:61) 	at org.springframework.data.mongodb.core.mapping.event.AbstractMongoEventListener.onApplicationEvent(AbstractMongoEventListener.java:89) 	at org.springframework.data.mongodb.core.mapping.event.AbstractMongoEventListener.onApplicationEvent(AbstractMongoEventListener.java:31) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:402) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:359) 	at org.springframework.data.mongodb.core.ReactiveMongoTemplate.maybeEmitEvent(ReactiveMongoTemplate.java:2432) 	at org.springframework.data.mongodb.core.ReactiveMongoTemplate.lambda$doInsert$24(ReactiveMongoTemplate.java:1252) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44) 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) 	at reactor.core.publisher.MonoLiftFuseable.subscribe(MonoLiftFuseable.java:55) 	at reactor.core.publisher.Mono.subscribe(Mono.java:3877) 	at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:123) 	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84) 	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.lang.Thread.run(Thread.java:834) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Assembly trace from producer [reactor.core.publisher.MonoDefer] : 	reactor.core.publisher.Mono.defer(Mono.java:199) 	org.springframework.data.mongodb.core.ReactiveMongoTemplate.doInsert(ReactiveMongoTemplate.java:1241) Error has been observed by the following operator(s): 	|_	Mono.defer ⇢ org.springframework.data.mongodb.core.ReactiveMongoTemplate.doInsert(ReactiveMongoTemplate.java:1241) 	|_	Mono.subscribeOn ⇢ com.mycompany.myapp.FailValidationIT.test(FailValidationIT.java:19) ```   To reproduce, clone [this example project](https://github.com/cbornet/spring-validation-blocking) and run test `FailValidationIT`  This issue has similarities with #24240 (also going through `PrioritizedParameterNameDiscoverer::getParameterNames`)","closed","status: superseded,","cbornet","2019-12-22T14:56:36Z","2020-02-24T20:14:53Z"
"","24354","It is impossible to configure readTimeout and connectionTimeout for AccessTokenProvider in OAuth2RestTemplate","**Affects:** 5.1.10  ---  Hello,  I needed to configure connectionTimeout and readTimeout for access token providers that are used in OAuth2RestTemplate (by default both those values ar set to hang for ever waiting for either connection or read to succeed). In order to set some values to those timeouts I had to create my own OAuth2RestTemplate deriving from `org.springframework.security.oauth2.client.OAuth2RestTemplate` that provided possibility to set them up (code pasted below).   I'm using spring-security-oauth2 in version 2.0.10.RELEASE.  Is there a better way to do it?  If not could you provide such possibility?  ``` class OAuth2RestTemplate extends org.springframework.security.oauth2.client.OAuth2RestTemplate {     private Integer accessProviderConnectionTimeout;     private Integer accessProviderReadTimeout;      public OAuth2RestTemplate(OAuth2ProtectedResourceDetails resource) {         this(resource, new DefaultOAuth2ClientContext());     }          public OAuth2RestTemplate(OAuth2ProtectedResourceDetails resource, OAuth2ClientContext context) {         this(resource, context, null, null);     }          public OAuth2RestTemplate(OAuth2ProtectedResourceDetails resource, OAuth2ClientContext context,                               Integer accessProviderConnectionTimeout, Integer accessProviderReadTimeout) {         super(resource, context);         this.accessProviderConnectionTimeout = accessProviderConnectionTimeout;         this.accessProviderReadTimeout = accessProviderReadTimeout;         setupRequestFactory();     }       private void setupProvidersRequestFactory(OAuth2AccessTokenSupport provider) {         SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory() {             protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {                 super.prepareConnection(connection, httpMethod);                 connection.setInstanceFollowRedirects(false);                 connection.setUseCaches(false);             }         };          if(accessProviderConnectionTimeout !=null)             requestFactory.setConnectTimeout(accessProviderConnectionTimeout);         if(accessProviderReadTimeout !=null)             requestFactory.setReadTimeout(accessProviderReadTimeout);          provider.setRequestFactory(requestFactory);     }      private void setupRequestFactory() {          List providersList = Stream.of(                 new AuthorizationCodeAccessTokenProvider(),                 new ImplicitAccessTokenProvider(),                 new ResourceOwnerPasswordAccessTokenProvider(),                 new ClientCredentialsAccessTokenProvider()         )                 .peek(this::setupProvidersRequestFactory)                 .collect(Collectors.toList());          this.setAccessTokenProvider(new AccessTokenProviderChain(providersList));     }  } ```","closed","for: external-project,","mareksoluch","2020-01-14T11:29:51Z","2020-03-12T17:39:42Z"
"","24264","Issue with uri Variable in RestTemplate.exchange method","**Affects:** 5.0.6.RELEASE  ---  I am using spring-web version 5.0.6.RELEASE.  I tried calling the GET exchange method with the URI variable map, but these URI variables are not set to the final URL which hit the external system.  My code snippet is as below  ``` Map queryParam =  new HashMap<>(); queryParam.put(""id"", 1); queryParam.put(""name"", ""ABC""); ResponseEntity> responseEntity = restTemplate.exchange(serverUrl.toString(),HttpMethod.GET,null,                         new ParameterizedTypeReference>(){}, queryParam); ``` When I debugged , I found RestTemplate.execute method have a URI creation code `URI expanded = getUriTemplateHandler().expand(url, uriVariables);` which does not set the URI params to `URI` class.  I further debugged and found that in `DefaultUriBuilderFactory.build()` method the URI variable is not passed or set to URI component builder  `UriComponents uriComponents = this.uriComponentsBuilder.build().expand(uriVars);` which causes `HierarchicalUriComponents expandInternal(UriTemplateVariables uriVariables)` method of `HierarchicalUriComponents` class to set the URI variable as empty.  This seems to be an issue, can anyone check this?  Raised the same on StackOverflow, but did not receive any response. [StackOverflow link](https://stackoverflow.com/questions/59456693/issue-with-urivariable-in-resttemplate-exchange-method) Thanks.","closed","for: stackoverflow,","manish-birdeye","2019-12-25T14:38:39Z","2019-12-26T08:48:02Z"
"","24563","Clarify AbstractResourceBasedMessageSource.setCacheMillis vs java.util.ResourceBundle","**Affects:** 4.x, 5.x  ---   In Javadoc of  `org.springframework.context.support.AbstractResourceBasedMessageSource#setCacheMillis` it says:  > Default is ""-1"", indicating to cache forever (just like java.util.ResourceBundle).  However -1 in `java.util.ResourceBundle` is `TTL_DONT_CACHE` and its effect is not _cache forever_.  It should be `TTL_NO_EXPIRATION_CONTROL = -2` to have the _cache forever_ effect.  Hence I think implementation of `org.springframework.context.support.ResourceBundleMessageSource#getResourceBundle` is inconsistent with `java.util.ResourceBundle`.  it caches forever for any value less than 0. In order to be consistent with `java.util.ResourceBundle` it should be as follows  ```java if (getCacheMillis() >= -1) { 	return doGetBundle(basename, locale); } else { 	// Cache forever... } ```  and call `doGetBundle` for `TTL_DONT_CACHE = -1` as well.  @jhoeller what do you think about it?","closed","in: core,","destan","2020-02-21T12:09:53Z","2020-02-24T18:08:54Z"
"","24816","Documentation: AbstractBeanDefinition.getBeanClass() vs BeanFactory.getType","**Affects:**  all version ---  I try to know the beanClass of `BeanDefinition`, however, I found some subClass of BeanDefinition has no `beanClass`.  Such as `ConfigurationClassBeanDefinition` in `ConfigurationClassBeanDefinitionReader`, when `ConfigurationClassPostProcessor` parse `@Bean` method to a `BeanDefinition`(`ConfigurationClassBeanDefinition`), whose `beanClass` field is null. So far as I know,  `beanClass` stand for it's `bean` type. I wan to know why `beanClass` in `BeanDefinition` can be null, and how I get it's `bean` type from some of it's subClass.","closed","in: core,","anLA7856","2020-03-30T15:02:00Z","2020-04-03T19:15:31Z"
"","24771","Add support for using colon as a separator for custom methods","**Affects:**  5.1.7 ---   Google's API Design Guide has the concept of a [custom method](https://cloud.google.com/apis/design/custom_methods) which is identified by using the colon character `:`. The colon character is used to separate the custom verb from the resource.   Spring-WebFlux currently treats colon as any other character. Although it is possible to create custom method endpoints using the version mentioned above, we run into weird errors such as: 1. If we have two endpoints `GET /resources/{id}` and `POST /resources/{id}:customVerb`, and the user mistakenly sends a request to `GET /resources/{id}:customVerb`, the `GET /resources/{id}` endpoint gets hit instead of returning a 405 error 2. If we put a `@RequestMapping(path = ""/resources"")` on the controller and a `PostMapping(path = "":customVerb""` on the method, it gets mapped to `POST /resources/:customVerb` instead of `POST /resources:customVerb`. A workaround we have found for this was to stop using the `@RequestMapping` annotation and instead put the full path in the custom method's mapping itself.  So, it would be great if the the team at Spring could provide first class support to the colon character as a custom method separator.  Thanks!","closed","status: declined,","deepak-auto","2020-03-24T15:19:18Z","2020-03-26T19:17:36Z"
"","24246","branch 3.2.x cant compile",":spring-orm-hibernate4:processResources UP-TO-DATE :spring-orm-hibernate4:classes :spring-orm:jar :spring-aspects:compileJava [ant:iajc] E:\src\spring-framework\spring-aspects\src\main\java\org\springframework\beans\factory\aspectj\AbstractBeanConfigurerAspect.aj:1 [error] The type java.lang.CharSequence cannot be resolved. It is indirectly referenced from required .class files [ant:iajc] (no source information available) [ant:iajc] E:\src\spring-framework\spring-aspects\src\main\java\org\springframework\mock\staticmock\AbstractMethodMockingControl.aj:1 [error] The type java.io.ObjectInputStream cannot be resolved. It is indirectly referenced from required .class files [ant:iajc] (no source information available) [ant:iajc] E:\src\spring-framework\spring-aspects\src\main\java\org\springframework\mock\staticmock\AbstractMethodMockingControl.aj:19 [error] The import java.util.Arrays cannot be resolved [ant:iajc] import java.util.Arrays; [ant:iajc]        ^^^^^^^^^^^^^^^ [ant:iajc] E:\src\spring-framework\spring-aspects\src\main\java\org\springframework\mock\staticmock\AbstractMethodMockingControl.aj:103 [error] Arrays cannot be resolved [ant:iajc] if (!Arrays.equals(this.args, args)) { [ant:iajc]      ^ [ant:iajc]  [ant:iajc] 4 errors :spring-aspects:compileJava FAILED  FAILURE: Build failed with an exception.","closed","status: invalid,","gravin","2019-12-22T12:57:38Z","2019-12-31T18:01:05Z"
"","24671","MimeTypeUtils performance degradation","85.32%(255967.32 ms) org.springframework.util.MimeTypeUtils$ConcurrentLruCache.get 85.32%(255967.32 ms) org.springframework.util.MimeTypeUtils.parseMimeType     https://stackoverflow.com/questions/59879550/spring-boot-2-2-x-increased-cpu  It's similar to what this link describes, but I Running 10 days later Appear  spring boot 2.1.x is well, but 2.2.x cpu 90%","closed","type: regression,","Percy0601","2020-03-10T10:23:59Z","2020-04-09T09:23:02Z"
"","24592","Response Body coming null in Code but coming proper using PostMan","4.3.20.RELEASE   ResponseEntity response = restTemplate.exchange(builder.toUriString(), HttpMethod.POST, entity, OtdsOauthToken.class);  // Getting response object body as null, header is coming and Status is 200 ![response](https://user-images.githubusercontent.com/43573402/75266440-5a8ef880-5818-11ea-9b20-e64e5fdb4cbe.PNG)","closed","for: stackoverflow,","BaljinderSingh007","2020-02-25T16:17:26Z","2020-02-27T13:08:30Z"
"","24066","Merge pull request #2 from spring-projects/master","201811241 pull","closed","status: invalid,","roadWithDream","2019-11-24T09:04:46Z","2019-11-24T10:32:19Z"
"","24002","Simplify AbstractAsyncConfiguration","1. There is simpler way to express that 0 or 1 bean only is allowed 2. This commit allows flexible AsyncConfigurer substitution with `@Primary`","open","in: core,","michaldo","2019-11-14T22:06:07Z","2022-06-10T20:22:10Z"
"","23981","Polish AbstractAutowireCapableBeanFactory#populateBean","1.  if **postProcessAfterInstantiation** return false,  it could return immediately 2.  **instanceof** could replace **isInstance**","closed","in: core,","GungnirLaevatain","2019-11-12T15:56:59Z","2020-01-08T07:53:11Z"
"","24205","Simplify AdvisedSupport.removeAdvisor()","1) it's not necessary to call `IntroductionAdvisor.getInterfaces()` twice for each iteration 2) instead of calling `ArrayList.get()` and then `ArrayList.remove()` we can once call `ArrayList.remove()` to get and remove item by its index","closed","type: enhancement,","stsypanov","2019-12-13T15:57:54Z","2019-12-16T09:23:11Z"
"","24481","Upgrade to Spring Asciidoctor Extensions 0.4.0.RELEASE","0.4.0 provides built-in support for remembering a user's selections using local storage. This replaces the custom switch language JavaScript.  The selection is stored using a key derived from the options that were available. Concretely, when the options are Java or Kotlin, the local storage key is java-kotlin. Similarly, if the choices were Java, Kotlin, and XML, the key would be java-kotlin-xml.  Given local storage's domain and protocol scoping, the nature of the key that's used for storage will allow a user's selections to be applied across all documentation hosted on https://docs.spring.io that offer the same options.","closed","type: documentation,","wilkinsona","2020-02-05T13:55:07Z","2020-02-07T11:16:10Z"
"","24475","""Status and headers already sent"" ISE exception from Reactor Netty on WebSocket upgrade","- Spring Boot 2.2.4.RELEASE + webflux  From the server log I quite often see this nasty exception. We are mixing Weblux + Websockets  ``` java.lang.IllegalStateException: Status and headers already sent 	at reactor.netty.http.server.HttpServerOperations.addHeader(HttpServerOperations.java:192) ~[reactor-netty-0.9.4.RELEASE.jar:0.9.4.RELEASE] 	at org.springframework.http.server.reactive.ReactorServerHttpResponse.applyCookies(ReactorServerHttpResponse.java:97) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.http.server.reactive.AbstractServerHttpResponse.lambda$doCommit$11(AbstractServerHttpResponse.java:238) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at reactor.core.publisher.MonoRunnable.subscribe(MonoRunnable.java:49) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4105) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:207) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:80) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFromFluxOperator.subscribe(MonoFromFluxOperator.java:72) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1871) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:292) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1871) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1871) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1871) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1871) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:189) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:260) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onComplete(FluxContextStart.java:122) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onComplete(FluxContextStart.java:122) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:174) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:144) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:189) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:260) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onComplete(FluxContextStart.java:122) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:189) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:260) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:174) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:174) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:144) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1871) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:395) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:174) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:189) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:260) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:144) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxHide$SuppressFuseableSubscriber.onComplete(FluxHide.java:137) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.core.publisher.FluxDoOnEach$DoOnEachSubscriber.onComplete(FluxDoOnEach.java:209) ~[reactor-core-3.3.2.RELEASE.jar:3.3.2.RELEASE] 	at reactor.netty.FutureMono$FutureSubscription.operationComplete(FutureMono.java:188) ~[reactor-netty-0.9.4.RELEASE.jar:0.9.4.RELEASE] 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.setSuccess(DefaultPromise.java:96) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.DefaultChannelPromise.setSuccess(DefaultChannelPromise.java:78) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.DefaultChannelPromise.setSuccess(DefaultChannelPromise.java:73) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker$1.operationComplete(WebSocketServerHandshaker.java:227) ~[netty-codec-http-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker$1.operationComplete(WebSocketServerHandshaker.java:221) ~[netty-codec-http-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.internal.PromiseNotificationUtil.trySuccess(PromiseNotificationUtil.java:48) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.ChannelOutboundBuffer.safeSuccess(ChannelOutboundBuffer.java:717) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:272) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:352) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.epoll.AbstractEpollChannel.doWriteBytes(AbstractEpollChannel.java:363) ~[netty-transport-native-epoll-4.1.45.Final-linux-x86_64.jar:4.1.45.Final] 	at io.netty.channel.epoll.AbstractEpollStreamChannel.writeBytes(AbstractEpollStreamChannel.java:260) ~[netty-transport-native-epoll-4.1.45.Final-linux-x86_64.jar:4.1.45.Final] 	at io.netty.channel.epoll.AbstractEpollStreamChannel.doWriteSingle(AbstractEpollStreamChannel.java:471) ~[netty-transport-native-epoll-4.1.45.Final-linux-x86_64.jar:4.1.45.Final] 	at io.netty.channel.epoll.AbstractEpollStreamChannel.doWrite(AbstractEpollStreamChannel.java:429) ~[netty-transport-native-epoll-4.1.45.Final-linux-x86_64.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:930) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.flush0(AbstractEpollChannel.java:519) ~[netty-transport-native-epoll-4.1.45.Final-linux-x86_64.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:897) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1372) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:748) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:740) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:726) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.flush(CombinedChannelDuplexHandler.java:531) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:125) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.CombinedChannelDuplexHandler.flush(CombinedChannelDuplexHandler.java:356) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:748) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:763) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1089) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384) ~[netty-transport-native-epoll-4.1.45.Final-linux-x86_64.jar:4.1.45.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] 	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]``` ```   My websocket configuration: ```java @Configuration public class ReactiveWebSocketConfiguration {      private final WebSocketHandler webSocketHandler;      public ReactiveWebSocketConfiguration(@Qualifier(""ReactiveWebSocketHandler"") WebSocketHandler webSocketHandler) {         this.webSocketHandler = webSocketHandler;     }      @Bean     public HandlerMapping webSocketHandlerMapping() {         Map map = new HashMap<>();         map.put(""/event-emitter"", webSocketHandler);          SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();         handlerMapping.setOrder(1);         handlerMapping.setUrlMap(map);         return handlerMapping;     }      @Bean     public WebSocketHandlerAdapter handlerAdapter() {         return new WebSocketHandlerAdapter();     } } ```  ```java @Component(""ReactiveWebSocketHandler"") public class ReactiveWebSocketHandler implements WebSocketHandler {      final DataService dataService;      public ReactiveWebSocketHandler(DataService dataService) {         this.dataService = dataService;     }      @Override     public Mono handle(WebSocketSession webSocketSession) {         return webSocketSession.send(dataService.getEventFlux()           .map(webSocketSession::textMessage))           .and(webSocketSession.receive()             .map(WebSocketMessage::getPayloadAsText).log());     } } ``` DataService is providing text String.  Browser side: ```javascript function connectEvents() {      function createWebSocket(path) {         var protocolPrefix = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';         return new WebSocket(protocolPrefix + '//' + location.host + path);     }      var clientWebSocket = createWebSocket(location.pathname + 'event-emitter');      clientWebSocket.onopen = function () {         console.log(""clientWebSocket.onopen"", clientWebSocket);         console.log(""clientWebSocket.readyState"", ""websocketstatus"");         clientWebSocket.send(""event-me-from-browser"");     };     clientWebSocket.onclose = function (event) {         console.log(""clientWebSocket.onclose"", clientWebSocket, event);          console.log('Socket is closed. Reconnect will be attempted in 10 seconds.', event ? event.reason: '');         setTimeout(function() {             console.log('10s websocket reconnecting');             connectEvents();         }, 10000);     };     clientWebSocket.onerror = function (event) {         console.log(""clientWebSocket.onerror"", clientWebSocket, event);     };     clientWebSocket.onmessage = function (event) {         console.log(""clientWebSocket.onmessage"", clientWebSocket, event);         processEvents(JSON.parse(event.data));     };  }  $(function () {     connectEvents(); }); ```  It's difficult to debug - maybe it's related to cookies somehow(last 2 methods in the exception). Let me know If I can provide more information.","closed","type: bug,","Vity01","2020-02-04T07:58:17Z","2020-02-13T20:43:30Z"
"","24384","Upgrade to Gradle 6.2","- Build Scan plugin is now Gradle Enterprise plugin applied in settings - Compile task dependencies are now defined through classpath - Test fixture publication can be disabled through public API","closed","type: task,","jjohannes","2020-01-17T10:57:48Z","2020-08-20T09:18:00Z"
"","24805","Improve usage of ByteArrayOutputStream/ByteArrayInputStream","- `ByteArrayInputStream.flush()` is no-op method along with `ByteArrayInputStream.close()`, `ByteArrayOutputStream.flush()` and `ByteArrayOutputStream.close()`. So we can drop `try-with-resources` statements as well as explicit calls to `flush()`/`close()` - `new String(BAOS.toByteArray(), charset)` replaced with call to `StreamUtils.baosToString(baos, charset)` to swallow `UnsupportedEncodingException` which is actually never thrown as `charset` is already available at invocation point  As of performance I've used more precise benchmark: ```java @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(jvmArgsAppend = {""-Xms2g"", ""-Xmx2g"", ""-XX:+UseParallelGC""}) public class ByteArrayOutputStreamBenchmark {    @Benchmark   public String toString(Data data) throws UnsupportedEncodingException {     return data.baos.toString(data.charset.name());   }    @Benchmark   public String newString(Data data) {     return new String(data.baos.toByteArray(), data.charset);   }    @Benchmark   public String toString_noCS(Data data) {     return data.baos.toString();   }    @Benchmark   public String newString_noCS(Data data) {     return new String(data.baos.toByteArray());   }    @State(Scope.Thread)   public static class Data {      @Param({""0"", ""10"", ""100"", ""1000""})     private int length;      private final Charset charset = Charset.defaultCharset();      private ByteArrayOutputStream baos;      @Setup     public void setup() throws IOException {       byte[] bytes = StringUtils.repeat('a', length).getBytes(charset);        baos = new ByteArrayOutputStream(length);       baos.write(bytes);     }   }  } ``` Which demonstrates improvement in both time and memory consumption ``` JDK 8                                        (length)  Mode      Score     Error   Units  newString                                     0  avgt     66.084 ±   2.121   ns/op toString                                      0  avgt     44.601 ±   0.656   ns/op newString_noCS                                0  avgt     69.694 ±   1.949   ns/op toString_noCS                                 0  avgt     43.758 ±   0.333   ns/op  newString                                    10  avgt     53.232 ±   1.569   ns/op toString                                     10  avgt     45.151 ±   0.397   ns/op newString_noCS                               10  avgt     52.005 ±   0.473   ns/op toString_noCS                                10  avgt     45.657 ±   4.325   ns/op  newString                                   100  avgt     96.067 ±   1.466   ns/op toString                                    100  avgt     77.924 ±   0.645   ns/op newString_noCS                              100  avgt     94.716 ±   3.138   ns/op toString_noCS                               100  avgt     80.460 ±   1.375   ns/op  newString                                  1000  avgt    667.188 ±  33.071   ns/op toString                                   1000  avgt    511.302 ±   1.730   ns/op newString_noCS                             1000  avgt    624.721 ±  20.786   ns/op toString_noCS                              1000  avgt    530.833 ±  11.087   ns/op  newString:·gc.alloc.rate.norm                 0  avgt     96.000 ±   0.001    B/op toString:·gc.alloc.rate.norm                  0  avgt     40.000 ±   0.001    B/op newString_noCS:·gc.alloc.rate.norm            0  avgt     56.000 ±   0.001    B/op toString_noCS:·gc.alloc.rate.norm             0  avgt     40.000 ±   0.001    B/op  newString:·gc.alloc.rate.norm                10  avgt    136.000 ±   0.001    B/op toString:·gc.alloc.rate.norm                 10  avgt     64.000 ±   0.001    B/op newString_noCS:·gc.alloc.rate.norm           10  avgt     96.000 ±   0.001    B/op toString_noCS:·gc.alloc.rate.norm            10  avgt     64.000 ±   0.001    B/op  newString:·gc.alloc.rate.norm               100  avgt    400.000 ±   0.001    B/op toString:·gc.alloc.rate.norm                100  avgt    240.000 ±   0.001    B/op newString_noCS:·gc.alloc.rate.norm          100  avgt    360.000 ±   0.001    B/op toString_noCS:·gc.alloc.rate.norm           100  avgt    240.000 ±   0.001    B/op  newString:·gc.alloc.rate.norm              1000  avgt   3096.001 ±   0.001    B/op toString:·gc.alloc.rate.norm               1000  avgt   2040.001 ±   0.001    B/op newString_noCS:·gc.alloc.rate.norm         1000  avgt   3056.001 ±   0.001    B/op toString_noCS:·gc.alloc.rate.norm          1000  avgt   2040.001 ±   0.001    B/op ```","closed","type: enhancement,","stsypanov","2020-03-28T17:40:57Z","2020-03-31T07:16:06Z"
"","24136","Annotation scanning in enclosing class hierarchy results in NoClassDefFound","**Version:** `2.2.[0|1].RELEASE`  **Context:** * Custom starter library has webflux and webmvc at ""provided"" scope * Custom starter has auto-configuration that has a conditional nested configuration on each tech * Consuming webmvc based application includes starter (has no webflux dep)  Behavior in `2.1.x.RELEASE` was that the webflux gated config would  be excluded and all was well.   Behavior w/ `2.2.x.RELEASE` is startup fails w/ following:  ``` java.lang.NoClassDefFoundError: org/springframework/web/reactive/config/WebFluxConfigurer 	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_102] 	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_102] 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_102] 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_102] 	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_102] 	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_102] 	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_102] 	at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_102] 	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_102] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_102] 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_102] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_102] 	at java.lang.Class.getDeclaringClass0(Native Method) ~[na:1.8.0_102] 	at java.lang.Class.getDeclaringClass(Class.java:1235) ~[na:1.8.0_102] 	at java.lang.Class.getEnclosingClass(Class.java:1277) ~[na:1.8.0_102] 	at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:233) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.AnnotationsScanner.processClassHierarchy(AnnotationsScanner.java:194) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.AnnotationsScanner.processClass(AnnotationsScanner.java:130) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.AnnotationsScanner.process(AnnotationsScanner.java:107) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:97) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:78) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.TypeMappedAnnotations.scan(TypeMappedAnnotations.java:242) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.core.annotation.TypeMappedAnnotations.isPresent(TypeMappedAnnotations.java:98) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesBindConstructorProvider.isConstructorBindingAnnotatedType(ConfigurationPropertiesBindConstructorProvider.java:81) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesBindConstructorProvider.getBindConstructor(ConfigurationPropertiesBindConstructorProvider.java:49) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesBean$BindMethod.forType(ConfigurationPropertiesBean.java:311) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator.validate(ConfigurationPropertiesBeanDefinitionValidator.java:61) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator.postProcessBeanFactory(ConfigurationPropertiesBeanDefinitionValidator.java:44) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:286) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:174) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:706) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) [spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) [spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at com.example.demo.DemoApplication.main(DemoApplication.java:10) [classes/:na] Caused by: java.lang.ClassNotFoundException: org.springframework.web.reactive.config.WebFluxConfigurer 	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_102] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_102] 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_102] 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_102] 	... 39 common frames omitted ```  ### Starter snippet pom.xml ```xml  	org.springframework.boot 	spring-boot-starter-web 	provided    	org.springframework.boot 	spring-boot-starter-webflux 	provided  ```  ### Starter auto-config ```java @Configuration @ConditionalOnWebApplication @EnableConfigurationProperties(DemoProperties.class) public class DemoAutoConfiguration {      @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)     @ConditionalOnClass(WebMvcConfigurer.class)     @Configuration     static class DemoWebMvcConfiguration implements WebMvcConfigurer {          @PostConstruct         public void init() {             System.out.println(""DemoWebMvcConfiguration.init()"");         }     }      @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)     @ConditionalOnClass(WebFluxConfigurer.class)     @Configuration     static class DemoWebFluxConfiguration implements WebFluxConfigurer {          @PostConstruct         public void init() {             System.out.println(""DemoWebFluxConfiguration.init()"");         }     } } ```  ### Consuming app pom.xml snippet  ```xml  	org.springframework.boot 	spring-boot-starter-web    	com.example 	demolib 	0.0.1-SNAPSHOT 		 ```  *NOTE:* If I comment out the `DemoWebMvcConfiguration` the conditional behaves and the webflux gated config is excluded and all is well. It seems that when they are both present the config properties annotation scan tries to load the classes.","closed","in: core,","onobc","2019-11-08T21:35:04Z","2019-12-11T10:57:53Z"
"","24699","spring-mvc:chunked responses with status 500 are damaged","**version**: Spring Boot 2.2.5.RELEASE **environment**: java: Java(TM) SE Runtime Environment (build 1.8.0_172-b11) **os**: mac. os and linux  **contrainer**: tomcat  the bug is related to here I have worked for days to reproduced the problem  https://github.com/spring-cloud/spring-cloud-gateway/issues/1600  when I create a controller and just return ResponseEntity there will be return  ``` curl: (56) Illegal or missing hexadecimal sequence in chunked-encoding ``` my code ```java @RequestMapping(""api/v1"") @RestController public class ProxyController {      @GetMapping(""/proxy500"")     public ResponseEntity proxy500(ProxyExchange proxy) {         MultiValueMap multiValueMap = new HttpHeaders();         multiValueMap.put(""Transfer-Encoding"", Collections.singletonList(""chunked""));         multiValueMap.put(""Connection"", Collections.singletonList(""close""));         return new ResponseEntity<>(""{"", multiValueMap, HttpStatus.INTERNAL_SERVER_ERROR);     } } ```  **detail**  ``` curl http://localhost:8080/api/v1/proxy500 -vvv *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /api/v1/proxy500 HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* >  < HTTP/1.1 500  < Transfer-Encoding: chunked < Connection: close < Content-Type: text/plain;charset=UTF-8 < Date: Sat, 14 Mar 2020 17:13:04 GMT <  * Illegal or missing hexadecimal sequence in chunked-encoding * stopped the pause stream! * Closing connection 0 curl: (56) Illegal or missing hexadecimal sequence in chunked-encoding ```  reason maybe here , the header info send flush until message send  org.springframework.http.converter.StringHttpMessageConverter#writeInternal  ```java @Override protected void writeInternal(String str, HttpOutputMessage outputMessage) throws IOException {     HttpHeaders headers = outputMessage.getHeaders();     if (this.writeAcceptCharset && headers.get(HttpHeaders.ACCEPT_CHARSET) == null) {         headers.setAcceptCharset(getAcceptedCharsets());     }     Charset charset = getContentTypeCharset(headers.getContentType());     StreamUtils.copy(str, charset, outputMessage.getBody()); } ```  this my source code  https://github.com/taojiaenx/spring-chunk-bug.git","closed","for: external-project,","taojiaenx","2020-03-14T17:22:43Z","2021-03-24T08:36:04Z"
"","24031","MultipartBodyBuilder should mention more explicitly it is for use in reactive applications","**Type:** Bug or missing/incomplete documentation **Affects:** spring-web 5.2.1  If I try to use [`org.springframework.http.client.MultipartBodyBuilder`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/client/MultipartBodyBuilder.java#L80) it instantly fails with:  ```` Caused by: java.lang.NoClassDefFoundError: org/reactivestreams/Publisher 	at test.InvalidRequestExceptionHandlerTest.test(InvalidRequestExceptionHandlerTest.java:97) 	at org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:55) 	... 70 more Caused by: java.lang.ClassNotFoundException: org.reactivestreams.Publisher 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	... 72 more ````  If this class is only for reactive application this should be documented. This might become more obvious if the import for the [`WebClient`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/client/MultipartBodyBuilder.java#L44) is added, but currently this is unexpected. It would be nice if the class contains a link to the non-reactive version.  ## Steps to reproduce  Add spring-web 5.2.1 to your dependencies. Invoke the follwoing code:  ````java new MultipartBodyBuilder().build() ````  ## Possible workaround  * Add the dependency for `org.reactivestreams.Publisher` to the classpath.  ## Related issues  * https://github.com/spring-projects/spring-framework/issues/22876 (maybe)","closed","type: task,","ST-DDT","2019-11-19T15:42:30Z","2019-11-28T12:23:26Z"
"","24794","AspectJ, multi-context, @Lock: no transaction is in progress","**Spring Boot 2.2.5.RELEASE**  Sample project: https://github.com/cdalexndr/spring-boot-issue-20683 Run `gradlew test`  For this error to occur it seems that the following conditions need to be met: 1. Use transaction management with AspectJ 2. Call repository method annotated with `@Lock` 3. Run tests with multi contexts  I've added the following comments in source: `//comment this line for tests to work` If you change the test order, or run only the failed test (single context), then the test will succeed.     Log error:  ``` no transaction is in progress; nested exception is javax.persistence.TransactionRequiredException: no transaction is in progress org.springframework.dao.InvalidDataAccessApiUsageException: no transaction is in progress; nested exception is javax.persistence.TransactionRequiredException: no transaction is in progress 	at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:403) 	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:257) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:528) 	at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) 	at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:242) 	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:153) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:149) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) 	at com.sun.proxy.$Proxy93.getByName(Unknown Source) 	at example.PersonService.transactionalMethod_aroundBody0(PersonService.java:13) 	at example.PersonService$AjcClosure1.run(PersonService.java:1) 	at org.springframework.transaction.aspectj.AbstractTransactionAspect.ajc$around$org_springframework_transaction_aspectj_AbstractTransactionAspect$1$2a73e96cproceed(AbstractTransactionAspect.aj:66) 	at org.springframework.transaction.aspectj.AbstractTransactionAspect$AbstractTransactionAspect$1.proceedWithInvocation(AbstractTransactionAspect.aj:72) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366) 	at org.springframework.transaction.aspectj.AbstractTransactionAspect.ajc$around$org_springframework_transaction_aspectj_AbstractTransactionAspect$1$2a73e96c(AbstractTransactionAspect.aj:70) 	at example.PersonService.transactionalMethod(PersonService.java:13) 	at example.SecondPersonServiceTest.test(SecondPersonServiceTest.java:18) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:133) 	at org.testng.internal.MethodInvocationHelper$1.runTestMethod(MethodInvocationHelper.java:239) 	at org.springframework.test.context.testng.AbstractTestNGSpringContextTests.run(AbstractTestNGSpringContextTests.java:181) 	at org.testng.internal.MethodInvocationHelper.invokeHookable(MethodInvocationHelper.java:251) 	at org.testng.internal.TestInvoker.invokeMethod(TestInvoker.java:580) 	at org.testng.internal.TestInvoker.invokeTestMethod(TestInvoker.java:172) 	at org.testng.internal.MethodRunner.runInSequence(MethodRunner.java:46) 	at org.testng.internal.TestInvoker$MethodInvocationAgent.invoke(TestInvoker.java:804) 	at org.testng.internal.TestInvoker.invokeTestMethods(TestInvoker.java:145) 	at org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:146) 	at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:128) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.testng.TestRunner.privateRun(TestRunner.java:770) 	at org.testng.TestRunner.run(TestRunner.java:591) 	at org.testng.SuiteRunner.runTest(SuiteRunner.java:402) 	at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:396) 	at org.testng.SuiteRunner.privateRun(SuiteRunner.java:355) 	at org.testng.SuiteRunner.run(SuiteRunner.java:304) 	at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:53) 	at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:96) 	at org.testng.TestNG.runSuitesSequentially(TestNG.java:1180) 	at org.testng.TestNG.runSuitesLocally(TestNG.java:1102) 	at org.testng.TestNG.runSuites(TestNG.java:1032) 	at org.testng.TestNG.run(TestNG.java:1000) 	at org.gradle.api.internal.tasks.testing.testng.TestNGTestClassProcessor.runTests(TestNGTestClassProcessor.java:141) 	at org.gradle.api.internal.tasks.testing.testng.TestNGTestClassProcessor.stop(TestNGTestClassProcessor.java:90) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93) 	at com.sun.proxy.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:132) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:175) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:157) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55) 	at java.base/java.lang.Thread.run(Thread.java:834) Caused by: javax.persistence.TransactionRequiredException: no transaction is in progress 	at org.hibernate.query.internal.AbstractProducedQuery.doList(AbstractProducedQuery.java:1557) 	at org.hibernate.query.internal.AbstractProducedQuery.list(AbstractProducedQuery.java:1530) 	at org.hibernate.query.internal.AbstractProducedQuery.getSingleResult(AbstractProducedQuery.java:1578) 	at org.hibernate.query.criteria.internal.compile.CriteriaQueryTypeQueryAdapter.getSingleResult(CriteriaQueryTypeQueryAdapter.java:111) 	at org.springframework.data.jpa.repository.query.JpaQueryExecution$SingleEntityExecution.doExecute(JpaQueryExecution.java:196) 	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:88) 	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:154) 	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:142) 	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:618) 	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:605) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:80) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139) 	... 71 more ```","open","in: data,","cdalexndr","2020-03-26T01:08:49Z","2020-08-18T17:52:08Z"
"","24798","Support conversion from multiple source objects to a single target object in Converter API","**Spring Boot 2.2.5.RELEASE**  Interfaces: - org.springframework.core.convert.converter.Converter - org.springframework.core.convert.ConversionService  Currently the Spring converter only supports the signature  so you could do something like this with it:  **Convert A to C**  But.. What if we need another object, say B, to convert to C. In my case I need this:  **Convert A and B to C**  This is not possible but it would be very nice if it was flexible enough to also handle this requirement. In this feature request I would like to request support for the ConversionService to handle more objects if needed so the Converter is more flexible.  I found [this](https://stackoverflow.com/questions/52156482/best-way-to-implement-springs-converter-interface-when-you-need-to-pass-multipl#) post on stackoverflow where some others also seeking for this flexibility.","closed","type: enhancement,","ssgtcookie","2020-03-27T09:09:54Z","2020-03-27T13:54:55Z"
"","24046","AspectJ around aspect called twice when using a Mockito Spy","**Spring Boot 2.2.0.RELEASE**  Using `@Async` returning a Future cannot be canceled if the `@Async` method is called from a `@SpyBean`.  From debugging, it seems the `@Async` aspect is called twice, first before mockito handling method call then after Mockito calls method so the returned `Future` is invalid.  Sample project: https://github.com/cdalexndr/spring-boot-issue-18771  Just run `gradlew test`","open","in: core,","cdalexndr","2019-10-28T19:16:25Z","2019-11-22T13:21:13Z"
"","24359","Document supported characters for identifiers in SpEL expressions","**Original title**: Does SpEL support Chinese variables?  I try to use SpEL to execute some code which includes some Chinese variables.  ```java void test() {         SimpleEvaluationContext evaluationContext = SimpleEvaluationContext                 .forReadWriteDataBinding()                 .withMethodResolvers(DataBindingMethodResolver.forInstanceMethodInvocation())                 .build();          evaluationContext.setVariable(""中文"", 1);          ExpressionParser parser = new SpelExpressionParser();         Expression expression = parser.parseExpression(""#中文 == 1"");          Boolean value = expression.getValue(evaluationContext, Boolean.class);          System.out.println(value);  } ```  Exception stack trace:  ``` java.lang.IllegalStateException: Cannot handle (20013) '中' 	at org.springframework.expression.spel.standard.Tokenizer.process(Tokenizer.java:268) 	at org.springframework.expression.spel.standard.InternalSpelExpressionParser.doParseExpression(InternalSpelExpressionParser.java:127) 	at org.springframework.expression.spel.standard.SpelExpressionParser.doParseExpression(SpelExpressionParser.java:61) 	at org.springframework.expression.spel.standard.SpelExpressionParser.doParseExpression(SpelExpressionParser.java:33) 	at org.springframework.expression.common.TemplateAwareExpressionParser.parseExpression(TemplateAwareExpressionParser.java:52) 	at org.springframework.expression.common.TemplateAwareExpressionParser.parseExpression(TemplateAwareExpressionParser.java:43) ```","closed","type: documentation,","holicc","2020-01-15T09:53:11Z","2020-01-15T12:53:42Z"
"","24637","Response body available in both message and exception","**Observation**  When the status code is unknown a message will be constructed but the thrown exception does not contain the body anymore.  **Wanted behavior**  The `UnknownHttpStatusCodeException.getResponseBodyAsString()` returns the body and does not return `""""`  **Fix**  Same as the method `protected void handleError(ClientHttpResponse response, HttpStatus statusCode)` assign the body to a local variable and use it in the message and pass that one to the constructor of the `UnknownHttpStatusCodeException`","closed","in: web,","nbaars","2020-03-04T10:42:10Z","2020-03-06T16:03:02Z"
"","24657","Illegal reflective access warning for interface-based lookup method injection","**Java: 11.0.6** **Spring Framework: 5.2.4.RELEASE**  In our Spring-based application we use [lookup method injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lookup-method-injection). After switching to the Java 11 the beans which use the lookup method injection produces the illegal reflective access warnings.  **I see the issue tracker is full of similar issues. But I believe my case is special. Please let me prove it.**  I created a small demo application demonstrating my case: https://github.com/feerbach/spring-enhancer-bug  The important thing is: the illegal reflective access warning occurs in case the bean declared with the lookup method injection references an interface in the ```class``` attribute.   If the demo application is executed with the ```--illegal-access=debug``` VM option it produces error like: ``` WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (file:/Users/sgarifulin/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/5.2.4.RELEASE/155344a8b1a5e98c03c0a102b2aa008d2178f7a1/spring-core-5.2.4.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:533) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:582) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:569) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:416) 	at org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy$CglibSubclassCreator.createEnhancedSubclass(CglibSubclassingInstantiationStrategy.java:154) 	at org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy$CglibSubclassCreator.instantiate(CglibSubclassingInstantiationStrategy.java:116) 	at org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection(CglibSubclassingInstantiationStrategy.java:84) 	at org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection(CglibSubclassingInstantiationStrategy.java:76) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:91) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1312) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1214) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ```  Here it is a snippet from the xml application context file of the demo application: ```          ```  The ```com.example.demo.SomeFactory``` is an interface. Under the hood the Spring creates an ```org.springframework.cglib.proxy.Enhancer``` instance to generate implementation class of the ```someFactory``` bean. In the debugger I see the ```Enhancer``` instance passes ```null``` as the ```contextClass``` when it invokes the ```ReflectUtils.defineClass``` method.  The ```contextClass``` field of the Enhancer instance created for the ```someFactory``` bean is not initialized: when the Enhancer instance is being created the ```Enhancer.setSuperclass``` is called with the ```com.example.demo.SomeBean``` interface as the ```superclass``` argument but the ```contextClass``` field is initialized only if the passed superclass is a concrete class.  The question is: was it intended the Enhancer does not specify contextClass in case the superclass is an interface?","closed","in: core,","feerbach","2020-03-07T18:33:11Z","2020-03-26T16:30:59Z"
"","24414","illegal reflective access operation","**java version : adoptOpenJdk 11.0.5 spring-boot : 2.1.2.release**  WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access using Lookup on org.springframework.cglib.core.ReflectUtils (file:/home/tarik/.m2/repository/org/springframework/spring-core/5.1.4.RELEASE/spring-core-5.1.4.RELEASE.jar) to class java.lang.Object WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release","closed","status: duplicate,","xbaker","2020-01-22T12:24:08Z","2020-04-01T19:44:08Z"
"","23839","Regression: Resource bundle message source custom validation message no longer resolved","**Issue:**  Resource bundle message source custom validation message no longer resolved following upgrade from Spring 5.1.6.RELEASE to Spring 5.2.0.RELEASE.  DefaultListableBeanFactory preinstantiateSingletons() bean instantiation order:  1. LocalValidatorFactoryBean ""defaultValidator"" 2. RequestMappingHandlerAdapter ""requestMappingHandlerAdapter"" 3. LocalValidatorFactoryBean ""mvcValidator""  **Spring 5.1.6 behaviour:**  `WebMvcConfigurationSupport requestMappingHandlerAdapter()` `@Bean` method takes no args. It calls `WebMvcAutoConfiguration mvcValidator()` which calls `WebMvcConfigurerComposite getValidator()` which calls the `getValidator()` `@Override` in my Configuration class, which creates a `LocalValidatorFactoryBean` setting the `ValidationMessageSource` to my `ReloadableResourceBundleMessageSource` messageSource.  _Upshot:_ `requestMappingHandlerAdapter` configured with the `userResourceBundleLocator` set to `MessageSourceResoureBundleLocator` as expected.  **Spring 5.2.0 behaviour:**  `WebMvcConfigurationSupport requestMappingHandlerAdapter()` `@Bean` method now takes a `Validator`. It is instantiated with the ""defaultValidator"" `LocalValidatorFactoryBean`. That has a `PlatformResourceBundleLocator` as the userResourceBundleLocator.  _Upshot:_ `requestMappingHandlerAdapter` configured with the `userResourceBundleLocator` set to `PlatformResoureBundleLocator`.  Subsequently, the `mvcValidator()` `@Bean` is instantiated, but too late for use in the `requestMappingHandlerAdapter`.","closed","for: external-project,","rgolder1","2019-10-21T10:33:10Z","2019-10-31T12:33:58Z"
"","24292","Add ContentLength support for InputStreamResource created in ResourceHttpMessageConverter and ResourceDecoder","**Issue** InputStreamResource created in ResourceHttpMessageConverter /ResourceDecoder doesn't properly support contentLength. contentLength() method consumes input stream to calculate size instead of just providing predefined value.  **Motivation** Streaming use case, where application acts as a proxy for large amount of data.  **Fix** ResourceHttpMessageConverter should read HTTP Content-Length header. ResourceDecoder creates ISR based on byte array, so size is always known.  **Caveats** contentLength() for InputStreamResource created in ResourceHttpMessageConverter  can be -1 if Content-Length header is missing.","closed","type: enhancement,","ofaizulin","2020-01-04T08:52:43Z","2020-01-08T16:53:18Z"
"","24294","Broken guide : Accessing data with MySQL in spring.io","**I import project ""complete"" from ""Accessing data with MySQL"" in Android Studio and everything looks fine. But when i close the project and open it again, i take the following error message:**  APPLICATION FAILED TO START  Description: **Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured. Reason: Failed to determine a suitable driver class** Action: Consider the following: 	If you want an embedded database (H2, HSQL or Derby), please put it on the classpath. 	If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).  **What is wrong with this project. It should be a running guide.** https://spring.io/guides/gs/accessing-data-mysql/","closed","for: external-project,","jimsar","2020-01-04T21:43:51Z","2020-01-05T16:14:10Z"
"","24315","Port number is not set at Host header with HTTP request if accessing via proxy with CONNECT method","**Description:** Please suppose that you access your target site via proxy with CONNECT method (i.e., accessing proxy with HTTP tunnelling) by such code.  ```java UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(""https://your.target.site.com:443"");  HttpEntity entity = new HttpEntity(SOME_DOCS, HEADERS); SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setProxy(new Proxy(Type.HTTP, new InetSocketAddress(PROXY_HOST, PROXY_PORT))); ```  Then, port number is not set at Host header with the HTTP request for the proxy as below. `HOST: your.target.site.com`  Although it's expected as below. `HOST: your.target.site.com:443`  **How to reproduce the issue:** 1. Prepare reverse proxy with enabling HTTP tunnelling for HTTPS access. In my case, I reconfigure my NGIX server as a reverse proxy by adding the following kind of setting with nginx.conf. ```   # Reverse proxy configuration server {   listen 3128;   ssl on;   ssl_certificate     ""/etc/nginx/ssl/nginx.crt"";   ssl_certificate_key ""/etc/nginx/ssl/nginx.key"";   ssl_prefer_server_ciphers On;   ssl_protocols TLSv1.2;   ssl_ciphers DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK;   proxy_set_header Host $http_host;   proxy_set_header X-Forwarded-Proto $scheme;   location / {       proxy_pass https://your.target.site.com:443/;       proxy_redirect http:// https://;   } } ``` 2. Prepare your target web application with enabling HTTPS access via reverse proxy prepared at the step 1. 3. Extract attached zip file - [SampleReproducer.zip](https://github.com/spring-projects/spring-framework/files/4033680/SampleReproducer.zip) 4. From files extracted at the step 3., modify the following variables of one of the app source code (TestController.java) - HOST (target app host name or ip / URI), PROXY_HOST, PROXY_PORT 5. Compile extracted files as a Spring Boot app and deploy it on your app server 6. Monitor HTTP request for the target app with using tcpdump or your favorite tool - ex. `tcpdump -X > file.dump` 7. Access the reproducer with using curl or your favorite tool to access via Spring HTTP client implementation - ex. `curl -v http://path.to.reproducer.org/spring` 8. Check tcp dump file extracted via the step 6.. You should see there are no port number with Host header value with HTTP request for the proxy (based on CONNECT method). 9. **[Optional]** Access the reproducer via Apache HTTP client implementation - ex. `curl -v http://path.to.reproducer.org/ap-closable`. Now you can see the port number (in this case, 443) with Host header value with HTTP request for the proxy.  **Note 1:** Based on RFC-2817, I check the specification for Host header format in the case of http tunnelling.  https://www.ietf.org/rfc/rfc2817.txt​  According to the section 5.2 and 5.3 of this RFC, Host header format should be like the following in the case of http tunnelling. ​ `Host: server.example.com:80`  So, I think port number should be added with Host header value.  **Note 2:** If accessing to reverse proxy with PUT method (i.e., not applying http tunneling), I certainly observe that the port number is added with Host header value with using Spring HTTP client implementation.  So, I think port number should be added in spite of access method.","closed","for: external-project,","AkihiroKitada","2020-01-08T00:45:46Z","2020-01-17T09:41:41Z"
"","24190","Fix a disabled Test within AbstractAspectJAdvisorFactoryTests","**Current Disabled failed Test**  `AbstractAspectJAdvisorFactoryTests.testIntroductionWithArgumentBinding` as comment claim the failure is for unknowing reason, here snippet from code source  ,  ```         // TODO: Why does this test fail? It hasn't been run before, so it maybe never actually passed... 	@Test 	@Disabled 	public void testIntroductionWithArgumentBinding() {  ``` **The problem**  After changing the age property of the ITestBean target object, the hash code of the bean change, which causes the creation of a new introduction delegate, that make the proxy unable to retain the state of  `modified `property .  in other words, the proxy that before advice change its property is no longer associated with the target object.  this new Introduction Delegate is created by` DelegatePerTargetObjectIntroductionInterceptor.getIntroductionDelegateFor (Object targetObject)`   **Possible solution**  We could fix the test by changing the `AbstractMakeModifiable.recordModificationIfSetterArgumentDiffersFromOldValue  ` before advice to be an Around advice, in order to execute the target method within the advice, and then changing the proxy state (in this case, it will be the new introduction delegate associated with the updated target bean)  I could provide a pull request if this is the expected behavior.","open","in: core,","medzan","2019-12-11T15:52:56Z","2021-11-11T10:12:43Z"
"","23965","Avoid store all beanName in ApplicationListenerDetector","**ApplicationListenerDetector** only process **ApplicationListener** in method like **postProcessAfterInitialization**,  so it's enough to store beanName that type is **ApplicationListener**","closed","type: enhancement,","GungnirLaevatain","2019-11-10T14:43:12Z","2019-11-11T16:17:29Z"
"","24004","Enhancement - Allow developers to catch the resolved params after getMethodArgumentValues() and before invoking custom handlers in WebFlux","**Affects:** v5.2.1.RELEASE Scenario: WebFlux, Annotated Controllers  What expected: Developers can add a ""filter"" after getMethodArgumentValues() and before invoking custom methods in annotated controllers (between 137 to 146 line in org/springframework/web/reactive/result/method/InvocableHandlerMethod.java)  Why: I want to get all resolved params for controllers in a ""filter"". Although I can achieve the function by resolving the params from requests in WebFilter but it's really wasteful and meaningless to resolve the params twice (one in WebFilter by myself and another by Spring).","closed","status: declined,","JamesChenX","2019-11-15T03:38:34Z","2019-11-19T14:18:51Z"
"","23845","ResponseEntity.of method returns 404 when empty, should return 204","**Affects:** v5.2.0.RELEASE  ---  With the `org.springframework.http.ResponseEntity` class their is the following method for mapping an `Optional` to an HTTP Response.  ```java public static  ResponseEntity of(Optional body) {     Assert.notNull(body, ""Body must not be null"");     return body.map(ResponseEntity::ok).orElse(notFound().build()); } ```  I think returning a 404 NOT FOUND is the incorrect response code. This should be a 204 NO CONTENT. 4XX codes usually indicate a client error: a 404 in this case is usually calling an invalid URI. 204 seems more appropriate.   Happy to make a pull request.","closed","status: declined,","tomhughesnice","2019-10-22T09:26:24Z","2019-10-23T10:10:04Z"
"","24747","Specify custom Boundary in Multipart Form request using WebClient","**Affects:** spring-web-5.2.3.RELEASE Enhancement request.  Context: Posting Multipart Form requests using WebClient.  Problem: Unable to specify boundary. MultipartHttpMessageWriter uses static method generateMultipartBoundary to generate boundaries.","closed","","privettoli","2020-03-20T17:58:12Z","2020-08-04T06:25:29Z"
"","24522","ContentLength for InputStreamResource subclasses","**Affects:** spring-web-5.2.3  --- Dear all  I could see that the treatment of subclasses of `InputStreamResource` is not really good in some converters or codecs for `Resource` instances. Exactly, I could see that there are some classes that they don't take into account that `InputStreamResource` could have subclasses (as my case). These examples classes are `org.springframework.http.codec.ResourceHttpMessageWriter` (method `lengthOf(Resource)` line `if (InputStreamResource.class != resource.getClass()) {`) or `org.springframework.http.converter.ResourceHttpMessageConverter` (method `getContentLength` and line `if (InputStreamResource.class == resource.getClass()) {`  I could see another opened issue about it (#20990) and in it, you talk about the possibility to override the `contentLength` method for all subclasses, but in my opinion, this is a workaround because the right fix should be changing the above lines for something like this: `if (!(resource instanceof InputStreamResource)) {`. In that way, all of subclasses of `InputStreamResource` will have the same treatment, because by definition, all of these subclasses are based on an opened InputStream so the treatment should be the same for all cases.  I'm open to collaborate and send you a PR to fix both cases.  I await your reply!","closed","status: invalid,","admoca60","2020-02-14T10:59:55Z","2020-03-23T15:07:45Z"
"","24596","Disconnected client not always correctly detected with Reactor Netty server","**Affects:** spring-web 5.2.3.RELEASE  ---  Runtime Environment: AWS Corretto JDK 11.0.5.10  I am running a web server (serving an API) with Spring Webflux. Sporadically (once a day) I get an error log by the `org.springframework.web.server.adapter.HttpWebHandlerAdapter` class that looks like the following:  ``` [ff862e23] Error [reactor.netty.ReactorNetty$InternalNettyException: java.nio.channels.ClosedChannelException] for HTTP GET ""/some/path"", but ServerHttpResponse already committed (200 OK) ```  After some digging around I could reproduce this error locally in the following way:  1. Put a breakpoint in [ReactorServerHttpResponse.applyStatusCode](https://github.com/spring-projects/spring-framework/blob/0ad942f33720f08210a85ad6380051d2f5dfdc1e/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorServerHttpResponse.java#L78) 2. Do a curl request against one of my endpoints 3. With the debugger, step over the line in the breakpoint from 1) and rather fast abort the curl request with ctrl+c 4. Resume execution of the program  Not 100% of the time but often enough this will trigger the following line in `netty`: [AbstractChannel.write](https://github.com/netty/netty/blob/9ae782d632ff18f7c9e645c58458b3180d257ff3/transport/src/main/java/io/netty/channel/AbstractChannel.java#L865).  This in turn will end up in [HttpWebHandlerAdapter.handleUnresolvedError](https://github.com/spring-projects/spring-framework/blob/0ad942f33720f08210a85ad6380051d2f5dfdc1e/spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java#L271) but _not_ be detected as a client disconnected error in the `isDisconnectedClientError` method (since neither the message or exception class match what is there).  From the test setup it looks like this should be handled as a client disconnect error.  Since there is no easy way to suppress these error message (either by registering a handler for them or configuring the logging level separately from the generic HTTP 500 error logging) I am sadly getting alerts in my setup for errors that I can do nothing about.  I don't have a suggestion on how the `isDisconnectedClientError` method could be changed - including `InternalNettyException` in the `DISCONNECTED_CLIENT_EXCEPTIONS` seems dangerous. `NestedExceptionUtils.getMostSpecificCause(ex).getMessage()` returns `null` so no message check available. Potentially `NestedExceptionUtils.getMostSpecificCause(ex)` could be checked for `java.nio.channels.ClosedChannelException`?","closed","for: external-project,","FrontierPsychiatrist","2020-02-26T09:04:52Z","2020-03-25T08:07:59Z"
"","24261","Support headers with multiple values in ResponseStatusException","**Affects:** Spring-web 5.1.11 & 5.2.1  Spring-web got in version 5.1.11 very useful feature to transfer headers from `ResponseExceptions` to `ResponseStatusExceptionHandler` (first mentioned in https://github.com/spring-projects/spring-framework/issues/23741 and implements in https://github.com/spring-projects/spring-framework/commit/614c7b0f8e331dcd665a17caa0ee567254cb8889).  Faced with problem: new mechanism can't transfer multivalues headers like  ``` WWW-Authenticate: Negotiate, NTLM ``` in raw-style (in a `Map>` in this case).  ResponseStatusException.getHeaders returns simple `java.util.Map`.  Nowadays I can transfer multivalues only by converting to delimeted string (for example) and from it in exception handler. Looks lile a bycicle :(  Listing in `org.springframework.web.server.ResponseStatusException` ```java /**  * Return response headers associated with the exception, possibly required  * for the given status code (e.g. ""Allow"", ""Accept"").  * @since 5.1.11  */ public Map getHeaders() {     return Collections.emptyMap(); } ``` Listing in org.springframework.web.server.handler.ResponseStatusExceptionHandler ```java private boolean updateResponse(ServerHttpResponse response, Throwable ex) {     boolean result = false;     HttpStatus status = determineStatus(ex);     if (status != null) {         if (response.setStatusCode(status)) {             if (ex instanceof ResponseStatusException) {                 ((ResponseStatusException) ex).getHeaders()                         .forEach((name, value) -> response.getHeaders().add(name, value));             }             result = true;         }     }     else {         Throwable cause = ex.getCause();         if (cause != null) {             result = updateResponse(response, cause);         }     }     return result; } ``` Note, that `ServerHttpResponse.getHeaders()` returns `HttpHeaders` that implements `MultiValueMap`  Are any restrictions here for using `MultiValueMap` in `ResponseStatusException.getHeaders()` instead of `Map`?   Seems better to have more flexible mech","closed","type: enhancement,","KanyCTa","2019-12-24T15:23:03Z","2020-01-06T22:15:06Z"
"","24325","my project run fail in jar but success in local intellliJ,show exception has been injected into other beans...","**Affects:** spring-framwork 5.1.9.RELEASE  ---  First,my project exist circle reference.But run in intellij  IDEA no problem.in jar run failed. I am very worried about it.  The exception is as follows:  > org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'attributeDateTimeDaoImpl': Bean with name 'attributeDateTimeDaoImpl' **has been injected into other beans** [attributeDateTimeServiceImpl] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.","closed","for: stackoverflow,","kse-music","2020-01-10T10:31:15Z","2020-01-10T13:42:07Z"
"","24722","Usage of java 14 record throws java.lang.UnsupportedOperationException: This feature requires ASM8_EXPERIMENTAL","**Affects:** spring-core 5.2.4.RELEASE  --- I'm using the java 14 records in my application. Since the upgrade from `5.2.3.RELEASE` to `5.2.4.RELEASE`, I'm facing this kind of issue when running the application: ``` org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [/Users/kleturc/ws_perso/spring-boot-java14-record/target/classes/fr/kevinleturc/java/record/Point.class]; nested exception is java.lang.UnsupportedOperationException: This feature requires ASM8_EXPERIMENTAL   at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:454)   at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:316)   at org.springframework.boot.test.context.AnnotatedClassFinder.scanPackage(AnnotatedClassFinder.java:90)   at org.springframework.boot.test.context.AnnotatedClassFinder.findFromPackage(AnnotatedClassFinder.java:82)   at org.springframework.boot.test.context.AnnotatedClassFinder.findFromClass(AnnotatedClassFinder.java:68)   at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getOrFindConfigurationClasses(SpringBootTestContextBootstrapper.java:232)   at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:149)   at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:395)   at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:312)   at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:265)   at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:108)   at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:99)   at org.springframework.test.context.TestContextManager.(TestContextManager.java:137)   at org.springframework.test.context.TestContextManager.(TestContextManager.java:122)   at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$0(ExtensionValuesStore.java:81)   at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:182)   at org.junit.jupiter.engine.execution.ExtensionValuesStore.remove(ExtensionValuesStore.java:98)   at org.junit.jupiter.engine.execution.NamespaceAwareStore.remove(NamespaceAwareStore.java:73)   at org.springframework.test.context.junit.jupiter.SpringExtension.afterAll(SpringExtension.java:89)   at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeAfterAllCallbacks$13(ClassBasedTestDescriptor.java:421)   at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)   at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeAfterAllCallbacks$14(ClassBasedTestDescriptor.java:421)   at java.base/java.util.ArrayList.forEach(ArrayList.java:1510)   at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeAfterAllCallbacks(ClassBasedTestDescriptor.java:421)   at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.after(ClassBasedTestDescriptor.java:213)   at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.after(ClassBasedTestDescriptor.java:77)   at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:145)   at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)   at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:145)   ... 27 more Caused by: java.lang.UnsupportedOperationException: This feature requires ASM8_EXPERIMENTAL   at org.springframework.asm.ClassVisitor.visitRecordComponentExperimental(ClassVisitor.java:305)   at org.springframework.asm.ClassReader.readRecordComponent(ClassReader.java:931)   at org.springframework.asm.ClassReader.accept(ClassReader.java:705)   at org.springframework.asm.ClassReader.accept(ClassReader.java:401)   at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:50)   at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103)   at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:132)   at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:430)   ... 55 more ```  I created a sample project which highlights the issue: https://github.com/kevinleturc/spring-boot-java14-record  Just run command below to get the test failing: ``` mvn clean install -Dspring-core.version=5.2.4.RELEASE ```  Culprit seems to be the upgrade of ASM to `7.3.1` (#24438). It makes java record a `ASM8_EXPERIMENTAL` feature.","closed","type: enhancement,","kevinleturc","2020-03-18T13:42:47Z","2020-03-23T17:03:30Z"
"","23929","Regression: AnnotationUtils.findAnnotation no longer finds non-inherited ""java."" annotations on superclasses","**Affects:** spring-core 5.2.1 --- When updating from 5.1.10 to 5.2.0 / 5.2.1, then `AnnotationUtils.findAnnotation(Class clazz, @Nullable Class annotationType)` no longer finds annotations that are created on the parent.  Example project https://github.com/sellersj/spring-annotationutils-issue  I thought that https://github.com/spring-projects/spring-framework/issues/23856 was the same issue, but updating to 5.2.1 didn't fix the issue.","closed","in: core,","sellersj","2019-11-04T19:13:59Z","2019-11-12T10:52:31Z"
"","24757","Clarify name generation responsibility for PropertySourceFactory implementations","**Affects:** spring-context 5.2.3  ---  I'd like to discuss an enhancement to the documentation based on an issue that I encountered while implementing a custom `PropertySourceFactory`.  Current documentation for the `name()` method of the annotation reads:  > Indicate the name of this property source. If omitted, a name will be generated based on the description of the underlying resource.  I implemented my own factory not worrying about _nullable_ name parameter of method `createPropertySource`.  When I used properties without explicit I encountered an issue - my resources were overridden instead of merged themselves because of the same name (null) and thus same hashCode (`ConfigurationClassParser` lines [#437](https://github.com/spring-projects/spring-framework/blob/v5.2.3.RELEASE/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L437) and [#475](https://github.com/spring-projects/spring-framework/blob/v5.2.3.RELEASE/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L475)).  This led me to believe there is a bug and the name is not generated as the documentation states.  Yet, it is - but only by `DefaultPropertySourceFactory` ([DefaultPropertySourceFactory#37](https://github.com/spring-projects/spring-framework/blob/v5.2.3.RELEASE/spring-core/src/main/java/org/springframework/core/io/support/DefaultPropertySourceFactory.java#L37) and [ResourcePropertySource#67](https://github.com/spring-projects/spring-framework/blob/v5.2.3.RELEASE/spring-core/src/main/java/org/springframework/core/io/support/ResourcePropertySource.java)).  Suggestion from top of my head:   1. update the documentation to state that generation is performed only by the `DefaultPropertySourceFactory` 2. update the contract of the `PropertySourceFactory` to be responsible for the name generation 3. make the `@PropertySource.name()` required && notBlank and skip generation","closed","in: core,","zeratul021","2020-03-22T01:22:56Z","2020-03-23T17:03:30Z"
"","24099","Allow class attribute for XML bean definitions together with factory-bean","**Affects:** spring-beans-5.2.0  Please allow the `class` attribute for XML bean definitions which define the `factory-bean` attribute. I got the point - The type is implicitly defined by the factory method's return type. So there is no need to define the `class` attribute, because it's already ""known"".   But did you consider polymorph results of the factory bean? The `class` attribute would allow me to specify the concrete type and I'd expect Spring to provide it with this type for injections (`@Autowired`)  This would be helpful for Apache CXF jaxws, for example. From the manual (http://cxf.apache.org/docs/writing-a-service-with-spring.html):  ```xml                      ```  (I assume that the CXF authors didn't know that the `class` attribute of the second bean is ignored.)  I couldn't find a way to inject `demo.spring.HelloWorld` via `@Autowired`. Even if I use `@Qualifier` it says ""(...) required a bean of type 'demo.spring.HelloWorld' that could not be found.'  I think it's because of the polymorph return type `Object` of the factory method (`create()`).  However, this wouldn't be a problem with java-based configuration. I can get rid of the error message by replacing the second bean above with this code:  ```java @Autowired @Qualifier(""proxyFactory"") private JaxWsProxyFactoryBean proxyFactory;  @Bean public demo.spring.HelloWorld client() {     return (demo.spring.HelloWorld) proxyFactory.create(); } ```  But I'd really prefer to have everything in the xml file as shown above. This would be possible if Spring respected the `class` attribute.  Probably you wonder why I don't simply use the `` handler provided by CXF. Well, unfortunately they don't resolve property expressions (${user}). The issue is documented here: #20382 . Actually I'm using spring boot with `@ImportResource` to load the XML file. It looks like the XML is imported before properties of `application.properties` are available. See also this SO answer: https://stackoverflow.com/a/43980685/395879","open","in: core,","fishbone1","2019-11-28T13:02:34Z","2019-11-29T17:02:42Z"
"","24693","Unable to provide a custom LocaleContextResolver","**Affects:** Spring WebFlux 5.2.4.RELEASE Spring Boot:2.2.5.RELEASE  We are trying to provide a custom `LocaleContextResolver` in WebFlux but it appears the only way of doing this is by extending from `DelegatingWebFluxConfiguration`. If we do so, the application gets the wrong ObjectMapper on the context (I have the `spring.jackson.serialization` properties on my YML file). As soon as I delete my `DelegatingWebFluxConfiguration`, the app gets the correct the ObjectMapper.   I tried finding another way of providing my `LocaleContextResolver` but it does not seem there is one.","open","in: web,","jonathannaguin","2020-03-13T15:17:43Z","2021-11-10T11:46:07Z"
"","24763","CorsConfiguration based on pattern matching","**Affects:** Spring Web 5.2.4.RELEASE  --- Initial issue opened in Spring Cloud Gateway: https://github.com/spring-cloud/spring-cloud-gateway/issues/1607  Application APIs can be called by multiple origins. For applications that represent some kind of platform within a company it often makes sense to accept all request from orings coming from company domain, basically accept all request with origin matching a pattern **\*.company.com**. Currently default spring `CorsConfiguration ` supports only list of origins, I think this might not be flexible enough, as it will require configuration change every time new application within a company wants to call that REST api (especially in case of an API Gateway).  **Proposal**: add support for CORS configuration based on a pattern matching. One option would'be, I guess, to extend existing `CorsConfiguration`  class with additional fields `allowedOriginPatterns` and modify `checkOrigin` to use this property. Or have separate `CorsConfiguration` implementation that is using pattern matching.  While current solution is extendible and this approach can be implemented within the application itself, I think this should be a part of framework because it's a widely used functionality and is supported by other frameworks that are used for API implementation.  For example vert.x CorsHandler suipports that: https://github.com/vert-x3/vertx-web/blob/5cd7ecaa6bead1b246b5327537ee9b82c22187bc/vertx-web/src/main/java/io/vertx/ext/web/handler/CorsHandler.java#L42 Also, [Kong](https://docs.konghq.com/hub/kong-inc/cors/) supports pattern based origins as well.","closed","type: enhancement,","korektur","2020-03-22T22:44:47Z","2020-07-06T14:08:00Z"
"","24210","ResourceRegions converter opens and closes InputStream multiple times for multiple HttpRanges","**Affects:** Spring Web 5.2.2  Trying to utilize the `Range` header in an HTTP request to download a (portion of a) dynamically generated resource. The operative code isn't too exciting: ``` @GetMapping public ResponseEntity handleRequest(...) {   CustomInputStream is = ... //dynamically generated input stream with known fixed length   return ResponseEntity.ok().headers(...).body(new CustomResource(is)); //InputStreamResource not used so Range requests may be accomodated } ``` The issue is that for multiple byte ranges, the CustomInputStream underlying the Resource wrapper is closed multiple times: https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/ResourceRegionHttpMessageConverter.java#L182-L211. The CustomResource is provided to multiple ResourceRegion objects, each of which tries to open and close the underlying CustomInputStream separately. It also throws the following Exception (due to the InputStreamResource being opened again and again for multiple byte ranges): ``` java.lang.IllegalStateException: InputStream has already been read - do not use InputStreamResource if a stream needs to be read multiple times 	at org.springframework.core.io.InputStreamResource.getInputStream(InputStreamResource.java:97) ~[spring-core-5.2.2.RELEASE.jar:5.2.2.RELEASE] 	at org.springframework.http.converter.ResourceRegionHttpMessageConverter.writeResourceRegionCollection(ResourceRegionHttpMessageConverter.java:185) ~[spring-web-5.2.2.RELEASE.jar:5.2.2.RELEASE] 	at org.springframework.http.converter.ResourceRegionHttpMessageConverter.writeInternal(ResourceRegionHttpMessageConverter.java:139) ~[spring-web-5.2.2.RELEASE.jar:5.2.2.RELEASE] 	at org.springframework.http.converter.AbstractGenericHttpMessageConverter.write(AbstractGenericHttpMessageConverter.java:104) ~[spring-web-5.2.2.RELEASE.jar:5.2.2.RELEASE] ```  This wouldn't be a big problem for static assets (streams can be opened and closed), but because the stream is being generated dynamically, it cannot be regenerated (for context, it is using a circular buffer where another stream is writing to its read buffer).  Overriding the `close()` method of the `(Custom)InputStream` to ignore and not actually close the stream is not a good solution, because then the stream remains open and does not know when to actually close (i.e., after the request has been serviced and all the HttpRange regions have been written).  Overriding the `CustomResource` may get rid of the exception, but the underlying problem remains. The underlying stream is being closed again and again at every iteration of the loop, and the next iteration tries opening it again.  For now a decent solution may be to reuse the InputStream if available and not close it at the end of every loop iteration. Only call `close()` on all used InputStreams once all the iterations are done.  Additionally, perhaps the concept of a ResourceRegion needs to be reimplemented? I would expect it to perhaps contain the one Resource (that all the ranges are built on) and one or more ranges. Otherwise, we seem to be creating multiple ResourceRegion objects each containing the same Resource object, and expecting it to be okay when all the different objects open and close the underlying stream of the same object.","closed","status: superseded,","randomnicode","2019-12-14T18:06:39Z","2019-12-16T10:27:13Z"
"","23939","Empty or blank required UUID header validation results in 200 response status","**Affects:** Spring MVC 5.1.9.RELEASE  --- Hi,  My REST API takes as input a mandatory `X-Request-ID` header that is transformed to a `UUID` object.  So my REST controller method has this parameter: `@RequestHeader(value=""X-Request-ID"", required=true) UUID xRequestID`  However, if the `X-Request-ID` HTTP header: - is absent : 400 Bad Request (OK) - is empty (i.e. the empty string) : 200 OK **(NOK, should be 400)** - is blank (i.e. a string with whitespace only) : 200 OK **(NOK, should be 400)** - is not a UUID (for instance `""foobar""`) : 400 Bad Request (OK)  It seems that the problem comes from:  1. 'is empty' case: `StringToUUIDConverter` returns `null` 2. 'is blank' case: `StringToUUIDConverter` fails, then Spring MVC defaults to `UUIDEditor` that returns `null`.","closed","type: enhancement,","maxdewil","2019-11-06T09:52:39Z","2020-10-12T16:07:36Z"
"","24832","SPEL: ternary operator always returns ""false value"" if used in property","**Affects:** Spring Framework\5.2.5, Spring Boot\2.2.6 --- If the SPEL ternary operator is used in @Value, application.properties or application.yml its not evaluated correctly. Not matter what the expression result is it always returns the ""false value"".  The following application ``` @SpringBootApplication @ConfigurationProperties(prefix = ""application"") class SpelTernaryApplication {     var spel = """"     var spel2 = """"      @Value(""\${true ? 'trueExp' : 'falseExp'}"")     lateinit var spel3: String } ```  ``` application.spel=${true ? trueExp : falseExp} application.spel2=${2 > 1 ? a : b} ```  ``` @SpringBootTest class SpelTernaryApplicationTests {     @Autowired     lateinit var bean: SpelTernaryApplication      @Test     fun spelEvaluation() {         val parser: ExpressionParser = SpelExpressionParser()         val parserResult = parser.parseExpression(""true ? 'trueExp' : 'falseExp'"").getValue(String::class.java)          println(""parser: $parserResult"")         println(""property: ${bean.spel}"")         println(""property: ${bean.spel2}"")         println(""@Value property: ${bean.spel3}"")          assert(""trueExp"" == parserResult) { ""parser: $parserResult"" }         assert(""trueExp"" == bean.spel) { ""property: ${bean.spel}"" }         assert(""a"" == bean.spel2) { ""property: ${bean.spel2}"" }         assert(""trueExp"" == bean.spel3) { ""@Value property: ${bean.spel3}"" }     } } ```  produces > parser: trueExp > property:  falseExp > property:  b > @Value property:  'falseExp' >  > property:  falseExp > java.lang.AssertionError: property:  falseExp > 	at com.example.spelternary.SpelTernaryApplicationTests.spelEvaluation(SpelTernaryApplicationTests.kt:26) > [...]  example project: https://github.com/jackhammer2k/spring-spel-ternary-issue","closed","status: invalid,","jackhammer2k","2020-04-01T08:23:39Z","2020-04-01T10:37:41Z"
"","24480","PathMatchingResourcePatternResolver does not always work with JAR manifest class paths","**Affects:** Spring Framework 5.2.2  When trying to find a class from the class path using `PathMatchingResourcePatternResolver` you will not find the class if your search pattern starts with `classpath*:**/` and your are running your application with a single JAR containing a MANIFEST.MF with `Class-path` that defines the class path.  For instance, `com.vaadin`/`flow-server` contains a class named `Tag` in the `com.vaadin.flow.component` package. If you do ``` PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); for (Resource res : resolver.getResources(""classpath*:**/component/Tag.class"")) {     System.out.println(res); } ```  and run the application through VS Code, which happens to use the manifest based class path approach, there are no matches. On the other hand if you run with a ""normal"" classpath, a URL for the `Tag.class` will be printed  If you change the pattern to be `classpath*:com/**/component/Tag.class` i.e.  let it start with `com/`, then both ways of running the application outputs the `Tag.class` URL.  Example project based on Spring Boot here: https://github.com/Artur-/PathMatchingResourcePatternResolver-jarmanifest","closed","for: external-project,","Artur-","2020-02-05T08:45:02Z","2022-04-02T12:52:24Z"
"","24610","Invalid request results in 500 INTERNAL ERROR instead of 400 BAD REQUEST (with Lombok and Kotlin)","**Affects:** Spring Boot 2.2.5 More specifically spring-web 5.2.4  # Scenario Assume a bean definition with Lombok annotations used for annotation, for instance:  ```java import lombok.Builder; import lombok.NonNull; import lombok.Value;  import java.util.Map;  @Value @Builder public class InformationReceivedRequest {     @NonNull     private String informationType;     private Map data; } ```  when making a JSON request with `null` as `informationType`, Jackson fails to create the corresponding object due to the non-null restriction, creating a `ValueInstantiationException`. This exception extends `JsonMappingException`, which extends `JsonProcessingException`.  In spring-web 5.2.3, class `AbstractJackson2HttpMessageConverter` would convert any `JsonProcessingException` to `HttpMessageNotReadableException`. This second exception is then treated at `DefaultHandlerExceptionResolver` (part of spring-webmvc), and transformed into a `400 BAD REQUEST` response.  However, in spring-web 5.2.4, the class `AbstractJackson2HttpMessageConverter` has been modified so as to convert `JsonMappingException` into `HttpMessageConversionException`. This exception is not covered by `DefaultHandlerExceptionResolver`, which means the exception bubbles up to produce a `500 INTERNAL ERROR` response.  This means that the same `ValueInstantiationException` that used to result in a `400 BAD REQUEST` response (as expected), now results in a `500 INTERNAL ERROR` response.","closed","type: regression,","quiram","2020-02-28T13:20:36Z","2020-03-11T13:57:23Z"
"","24218","Get Parameters mapping to sub objects","**Affects:** Spring Boot 2.2.2.RELEASE  consider a resource like this: ```kotlin @RequestMapping(value = ""/reservation"",         method = RequestMethod.GET,         produces = MediaType.APPLICATION_JSON_VALUE) fun loadReservations(ReservationCriteria criteria) : List = service.loadReservations(criteria) ``` with request params container object as:  ```kotlin data class ReservationCriteria (     val hotelName:String,     val filter : Details )  data class Details (     val type : String,     val stars : Int ) ``` With a request: `/reservation?hotelName=myHotel`  myHotel will be bound to hotelName in ReservationCriteria object.  But how can I bind parameters to the nested object Details?   I thought a request like: `/reservation?hotelName=myHotel&filter.type=luxury&filter.stars=4`  Does not seem to be working in the SB 2.2.2.RELEASE  The sub object `reservationDateRange` is always getting null values( for `to` and `from` as per the above mentioned question)  Here is a simple project with a test failing: https://github.com/piyushmor/spring-param-bug  Related [StackOverflow discussion](https://stackoverflow.com/questions/36650051/spring-rest-binding-get-parameters-to-nested-objects/55507251).","closed","status: declined,","piyushmor","2019-12-16T14:03:09Z","2020-01-02T16:50:12Z"
"","24755","No qualifying bean of type 'Resource' available while building in Docker","**Affects:** Spring 5.3.2.RELEASE, Spring Boot 2.2.4.RELEASE --- (I'm not sure if it's a Spring issue of Spring Boot issue.) I try to inject a resource from the classpath using the following syntax and everything works like a charm: ``` @Configuration @RequiredArgsConstructor public class MyConfiguration {   @Value(""classpath:${my-file}"")   private final Resource myFile;   // a lot of codes here; } ``` But when I try to build the project (and run tests) in Docker, it fails with: > No qualifying bean of type 'org.springframework.core.io.Resource' available: expected at least 1...  I managed to resolve it by removing `final` keyword from the field. But just wanted to know why it fails. Thanks.","open","in: core,","akefirad","2020-03-21T16:42:42Z","2022-04-13T12:46:23Z"
"","24775","TransactionalTestExecutionListener Hotspot","**Affects:** Spring 5.2.4  ---  We have a relatively large, monolithic Spring Boot application and I have been doing some profiling of our integration tests. For context, our application has 1127 bean definitions and a majority of our performance issues are in our code base.  However, I did find a hotspot in the `TransactionalTestExecutionListener`. It has two methods to find annotated methods on the test class: `runBeforeTransactionMethods()` and `runAfterTransactionMethods`.  I am using JProfiler with full instrumentation, so the times are skewed :   ![TransactionalTestExecutionListener](https://user-images.githubusercontent.com/1878529/77509458-fd439280-6e29-11ea-80e0-9fc48c4197a7.png)   After looking at the code for a bit, I extended the listener to cache the list of methods for a given class and replaced the the default listener with our custom listener:   ```java public class CachingTransactionalTestExecutionListener extends TransactionalTestExecutionListener { 	  	/** 	 * A cache of class -> methods annotated with BeforeTransaction. 	 */ 	private static LruClassMethodCache beforeTransactionMethodCache = new LruClassMethodCache(4);  	/** 	 * A cache of class -> methods annotated with AfterTransaction. 	 */ 	private static LruClassMethodCache afterTransactionMethodCache = new LruClassMethodCache(4);  	@Override 	protected void runBeforeTransactionMethods(TestContext testContext) throws Exception {  		try { 			List methods = beforeTransactionMethodCache.get(testContext.getTestClass()); 			if (methods == null) { 		 				methods = getAnnotatedMethods(testContext.getTestClass(), BeforeTransaction.class); 				Collections.reverse(methods); 				for (Method method : methods) { 					ReflectionUtils.makeAccessible(method); 				} 				beforeTransactionMethodCache.put(testContext.getTestClass(), methods); 			} 			for (Method method : methods) { 				if (logger.isDebugEnabled()) { 					logger.debug(""Executing @BeforeTransaction method ["" + method + ""] for test context "" + testContext); 				} 				method.invoke(testContext.getTestInstance()); 			}			 		} 		catch (InvocationTargetException ex) { 			if (logger.isErrorEnabled()) { 				logger.error(""Exception encountered while executing @BeforeTransaction methods for test context "" + 						testContext + ""."", ex.getTargetException()); 			} 			ReflectionUtils.rethrowException(ex.getTargetException()); 		} 	}  	protected void runAfterTransactionMethods(TestContext testContext) throws Exception { 		Throwable afterTransactionException = null;  		List methods = afterTransactionMethodCache.get(testContext.getTestClass()); 		if (methods == null) { 			methods = getAnnotatedMethods(testContext.getTestClass(), AfterTransaction.class); 			for (Method method : methods) {			 					if (logger.isDebugEnabled()) { 						logger.debug(""Executing @AfterTransaction method ["" + method + ""] for test context "" + testContext); 					} 					ReflectionUtils.makeAccessible(method); 			} 			afterTransactionMethodCache.put(testContext.getTestClass(), methods); 		} 		 		for (Method method : methods) {			 			try { 				if (logger.isDebugEnabled()) { 					logger.debug(""Executing @AfterTransaction method ["" + method + ""] for test context "" + testContext); 				} 				method.invoke(testContext.getTestInstance()); 			} 			catch (InvocationTargetException ex) { 				Throwable targetException = ex.getTargetException(); 				if (afterTransactionException == null) { 					afterTransactionException = targetException; 				} 				logger.error(""Exception encountered while executing @AfterTransaction method ["" + method + 						""] for test context "" + testContext, targetException); 			} 			catch (Exception ex) { 				if (afterTransactionException == null) { 					afterTransactionException = ex; 				} 				logger.error(""Exception encountered while executing @AfterTransaction method ["" + method + 						""] for test context "" + testContext, ex); 			} 		}  		if (afterTransactionException != null) { 			ReflectionUtils.rethrowException(afterTransactionException); 		} 	}  // ...  	private static class LruClassMethodCache extends LinkedHashMap, List> {  		/** 		 * Create a new {@code LruCache} with the supplied initial capacity 		 * and load factor. 		 * @param initialCapacity the initial capacity 		 * @param loadFactor the load factor 		 */ 		LruClassMethodCache(int initialCapacity) { 			super(initialCapacity); 		}  		@Override 		protected boolean removeEldestEntry(Map.Entry, List> eldest) { 			if (size() > 4) { 				return true; 			} else { 				return false; 			} 		} 	}  	static class PostProcessor implements DefaultTestExecutionListenersPostProcessor {  		@Override 		public Set> postProcessDefaultTestExecutionListeners( 				Set> listeners) { 			Set> updated = new LinkedHashSet<>(listeners.size()); 			for (Class listener : listeners) {				updated.add(listener.equals(TransactionalTestExecutionListener.class) 						? CachingTransactionalTestExecutionListener.class : listener); 			} 			return updated; 		}   ```  To test this, I created 10 IT classes (each with 50 methods), and just do a simple assert. :   ```java public class Example1IT  extends BaseDaoTest  {  	@Test 	public void test1() { 		assertThat(""This String"").isNotNull(); 	} 	@Test 	public void test2() { 		assertThat(""This String"").isNotNull(); 	}  	// ...  	@Test 	public void test50() { 		assertThat(""This String"").isNotNull(); 	} ```  There is some ""noise"" because I am running this on my machine but the results look promising (but definitely not scientific 8)   After this change, the hotspot is no longer present in our profiling results and when running those 500 tests with no profiler in play:  Before:    After:    I wish I could report back how this change impacts our 8000+ integration test but I am currently working from home and the database activity over the VPN makes it very difficult to get repeatable results.","closed","type: enhancement,","tkvangorder","2020-03-25T07:07:44Z","2020-03-27T14:47:40Z"
"","23901","Regression: custom composed @Profile annotation without runtime retention no longer supported with component scanning","**Affects:** Spring 5.2  ---  If I create custom `@Profile` annotation such as this:  ```java @Profile(""sapConnector"") public @interface SapConnectorProfile { } ```  and then annotate some bean with `@SapConnectorProfile` and set the property `spring.profiles.active=demoConnector`, the bean **is** still loaded.  If I use `@Profile(""sapConnector"")` directly on the bean, the bean is **not** loaded.  My original question on stack overflow: https://stackoverflow.com/questions/58554912/custom-spring-profile-annotation","closed","status: feedback-provided,","pavelspicak","2019-10-31T11:32:32Z","2019-11-04T06:03:28Z"
"","24347","Allow re-initialization of DataBinder to and from direct field or bean property access","**Affects:** Spring 5.0.9 / Boot 2.0.5  We have a Spring Web Mvc REST service implemented using complex nested DTO models which are validated using `@Valid` on controller method signatures. We created a global `RestControllerAdvice` which uses `@InitBinder` to set it to direct field access. This seems to work as expected.  Now we have one controller, that has to deal with bean property style models and needs a different `InitBinder` setup. Having the hope of being able to override the global default one, by specifying it on the special controller itself, sadly failed with an error message of the `InitBinder` about an already initialized binding. Also there does not seem to exist some kind of `exclude` parameter on `RestControllerAdvice` that would allow us to exclude that special controller. Trying to use a special annotation on the other controllers and specifying it via `annotations` parameter on `RestControllerAdvice` also didn't work out during Mock Mvc Tests - ignoring the global one.  Finally, we ended up specifying `@InitBinder` on each controller separately - which works in all cases, but is quite cumbersome. Since we want to define the default globally and transparently for all controllers. Without having to remember, to specify packages, controller classes etc. on the global controller advice for new controllers to work properly - e.g. during validation.  Are there any plans to add some kind of exclude to the advice or being able to override a global default on controller level? This would be very helpful.","closed","type: enhancement,","vghero","2020-01-13T15:48:21Z","2020-05-14T14:43:17Z"
"","24335","ClassPathResource can not find resources in named module","**Affects:** org.springframework 5.2.2  ---  After updating java to jdk13, I used the named module in the project, because the unnamed module could not correctly handle some module relationships. At this time, I found that almost all the `ClassPathResource` that originally ran correctly in java8 failed, and the `ClassPathResource` should also run correctly in the unnamed module, the problem seems to exist in the named module only.       I try to use class to load resources directly. The result is different from what I expected. The modular JDK should change the processing of resources. When I find resources through module, I can get the resources correctly.  Before that, I didn't find a anything of this problem, so maybe it's a bug?","open","in: core,","SW-Fantastic","2020-01-12T00:50:12Z","2021-11-11T10:12:43Z"
"","24405","Reconsider recommended connection pools","**Affects:** master --- [DriverManagerDataSource javadoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/DriverManagerDataSource.html) recommends to use commons-dbcp or c3p0:  https://github.com/spring-projects/spring-framework/blob/c20a7b4636c9849f02f8b544eef3fef77a5a2ae5/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DriverManagerDataSource.java#L55-L60  It seems like this can be revised. At least, I'd suggest the following - mention HikariCP - remove apache dbcp or explicitly say that v2 is preferred","closed","type: documentation,","php-coder","2020-01-20T15:04:55Z","2020-01-24T13:56:03Z"
"","24328","AntPatternComparator not comparing/sorting correctly","**Affects:** All Versions  ---  The `AntPathMatcher.AntPatternComparator` doesn't appear to be comparing correctly.  Scenario:  - Pattern 1: `/api/v1/path/**` - Pattern 2: `/api/v1/path/{pathId}/**` - Pattern 3: `/**` - Pattern 4: `/api/**` - Path: `/api/v1/path/12345/hello`  Run the following  ```java Arrays.asList(""/api/v1/path/**"", ""/api/v1/path/{pathId}/**"", ""/**"", ""/api/**"")     .stream()     .sorted(new AntPathMatcher().getPatternComparator(""/api/v1/path/12345/hello""))     .collect(Collectors.toList()) ```  What Actually Happened:  ``` /api/v1/path/** /api/** /api/v1/path/{pathId}/** /** ```  What I Expected:  ``` /api/v1/path/{pathId}/** /api/v1/path/** /api/** /** ```","closed","status: duplicate,","kalypzo","2020-01-10T14:08:04Z","2020-04-02T20:09:47Z"
"","24338","Document that @Validated results in the use of a proxy and warn users about the side-effects","**Affects:** All supported versions  Using `@Validated` can result in a CGLib proxy being created for a bean. This has the sometimes unexpected side-effect of changing how the bean's fields behave when accessed directly. Please see [this Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/19638) for an example of a problem that this unexpected behavior can cause.  I think it would be good if the Framework reference documentation noted the use of a proxy and forewarned users about the side-effects.","closed","in: core,","wilkinsona","2020-01-13T12:29:06Z","2020-01-16T16:04:09Z"
"","24000","Inconsistent validation of query parameters when using MockMvc","**Affects:** `spring-test:5.1.6`  ---  When using `MockMvc` to perform test requests of a `@Validated` controller endpoint, validations (javax.validation.constraints) are not applied in certain cases depending on the formatting of the URI.  ```java mockMvc.perform(get(""/my-endpoint?param={param}"", ""value""))... // Works mockMvc.perform(get(format(""/my-endpoint?param=%s"", ""value"")))... // Works  mockMvc.perform(get(""/my-endpoint?param=%s"", ""value""))... // Works, but not when doing validation mockMvc.perform(get(""/my-endpoint?param={}"", ""value""))... // Works, but not when doing validation ```  Just raising this in case it can be made more consistent or if this might help someone else in the future.","closed","status: feedback-provided,","mharward","2019-11-14T17:11:58Z","2019-11-20T10:11:34Z"
"","24187","Honor generic type information when copying properties with BeanUtils","**Affects:** `spring-beans-5.1.2.RELEASE`  ```java class XA{}  class XB{}  class A{     List a = new ArrayList<>();     private String b;     private String c;     public List getA() {         return a;     }     public void setA(List a) {         this.a = a;     }      public String getB() {         return b;     }      public void setB(String b) {         this.b = b;     }      public String getC() {         return c;     }      public void setC(String c) {         this.c = c;     } }  class B {      List a = new ArrayList<>();       private String b;       private String c;      public List getA() {         return a;     }      public void setA(List a) {         this.a = a;     }      public String getB() {         return b;     }      public void setB(String b) {         this.b = b;     }      public String getC() {         return c;     }      public void setC(String c) {         this.c = c;     } } ```  ```java public class TestBeanUtils{         public static void main(String[] args) {             A a = new A();             a.getA().add(new XA());             B b= new B();             BeanUtils.copyProperties(a,b);             List a1 = b.getA();             for (XB xb : a1) {                 System.out.println(""AAA"");             }             List a2 = a.getA();             for (XA xb : a2) {                 System.out.println(""AAA"");             }         } } ```  run the main method , then there will throw a `java.lang.ClassCastException`;","closed","status: superseded,","GoWith","2019-12-11T07:16:26Z","2020-04-13T13:22:19Z"
"","24550","SpringBoot Error w/SecurityManager and AllPermission","**Affects:** \v5.2.0.RELEASE --- Running with Spring Boot v2.2.0.RELEASE, Spring v5.2.0.RELEASE  I have been working on getting webgoat to run with springboot with a securitymanager.  To minimize likelihood of user coding problems on my part, I'm using java.lang.SecurityManager as the test.  I am running with the following policies, ``` grant {    permission java.security.AllPermission;   permission java.lang.reflect.ReflectPermission ""suppressAccessChecks""; }; ``` With SecurityManager enabled and the previous policies, no access control checks should fail.  Following is the command line I use to execute springboot with webgoat.  java -classpath ./webgoat-server-8.0.0.M26.jar:./JVMXRay-0.0.1-SNAPSHOT.jar -Djava.security.manager=java.lang.SecurityManager -Djava.security.policy==/Users/milton/zwebgoat/nulljava.policy org.springframework.boot.loader.JarLauncher --server.port=8080 --server.address=localhost  The problem is that org.owasp.webgoat.HSQLDBDatabaseConfig is not found and server exists.  However, if remove the SecurityManager and policy file from the command line the server starts as expected.  The expected behavior with SecurityManager and the AllPermission policies should be the same as no SecurityManager.  I reviewed some of the code near,  `org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1465`  I noticed that a different classloader may be used depending on whether springboot is initialized with a SecurityManager or not, regardless of policy settings.  That's about as far as I got in the code.  I checked to see if I could identify a SecurityManager unit test where this code path is exercised but didn't notice anything.  I reviewed the next and other bug submissions to the spring project but didn't notice anything similar.  I'm hope this information is helpful.  -----FULL STACKTRACE FOLLOWS------ ``` Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2020-02-18 19:36:33.199 ERROR 38449 --- [           main] o.s.boot.SpringApplication               : Application run failed  org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: URL [jar:file:/Users/milton/zwebgoat/webgoat-server-8.0.0.M26.jar!/BOOT-INF/classes!/org/owasp/webgoat/StartWebGoat.class]; nested exception is org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [org.owasp.webgoat.HSQLDBDatabaseConfig] for bean with name 'HSQLDBDatabaseConfig' defined in URL [jar:file:/Users/milton/zwebgoat/webgoat-server-8.0.0.M26.jar!/BOOT-INF/classes!/org/owasp/webgoat/HSQLDBDatabaseConfig.class]; nested exception is java.lang.ClassNotFoundException: org.owasp.webgoat.HSQLDBDatabaseConfig 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:454) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:316) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesScanRegistrar.scan(ConfigurationPropertiesScanRegistrar.java:83) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.context.properties.ConfigurationPropertiesScanRegistrar.registerBeanDefinitions(ConfigurationPropertiesScanRegistrar.java:60) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.context.annotation.ImportBeanDefinitionRegistrar.registerBeanDefinitions(ImportBeanDefinitionRegistrar.java:86) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.lambda$loadBeanDefinitionsFromRegistrars$1(ConfigurationClassBeanDefinitionReader.java:385) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:684) ~[na:na] 	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsFromRegistrars(ConfigurationClassBeanDefinitionReader.java:384) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:148) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:120) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:337) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:242) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:706) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.owasp.webgoat.StartWebGoat.main(StartWebGoat.java:47) ~[classes!/:8.0.0.M26] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) ~[na:na] 	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48) ~[webgoat-server-8.0.0.M26.jar:8.0.0.M26] 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) ~[webgoat-server-8.0.0.M26.jar:8.0.0.M26] 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:51) ~[webgoat-server-8.0.0.M26.jar:8.0.0.M26] 	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:52) ~[webgoat-server-8.0.0.M26.jar:8.0.0.M26] Caused by: org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [org.owasp.webgoat.HSQLDBDatabaseConfig] for bean with name 'HSQLDBDatabaseConfig' defined in URL [jar:file:/Users/milton/zwebgoat/webgoat-server-8.0.0.M26.jar!/BOOT-INF/classes!/org/owasp/webgoat/HSQLDBDatabaseConfig.class]; nested exception is java.lang.ClassNotFoundException: org.owasp.webgoat.HSQLDBDatabaseConfig 	at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1474) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:682) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:649) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1605) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:520) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:491) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:613) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:605) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.boot.context.TypeExcludeFilter.getDelegates(TypeExcludeFilter.java:77) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.boot.context.TypeExcludeFilter.match(TypeExcludeFilter.java:65) ~[spring-boot-2.2.0.RELEASE.jar!/:2.2.0.RELEASE] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.isCandidateComponent(ClassPathScanningCandidateComponentProvider.java:492) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:431) ~[spring-context-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	... 30 common frames omitted Caused by: java.lang.ClassNotFoundException: org.owasp.webgoat.HSQLDBDatabaseConfig 	at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:436) ~[na:na] 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:588) ~[na:na] 	at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:92) ~[webgoat-server-8.0.0.M26.jar:8.0.0.M26] 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[na:na] 	at java.base/java.lang.Class.forName0(Native Method) ~[na:na] 	at java.base/java.lang.Class.forName(Class.java:415) ~[na:na] 	at org.springframework.util.ClassUtils.forName(ClassUtils.java:277) ~[spring-core-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanDefinition.resolveBeanClass(AbstractBeanDefinition.java:456) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doResolveBeanClass(AbstractBeanFactory.java:1542) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$resolveBeanClass$5(AbstractBeanFactory.java:1466) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:688) ~[na:na] 	at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1465) ~[spring-beans-5.2.0.RELEASE.jar!/:5.2.0.RELEASE] 	... 41 common frames omitted ```","closed","status: invalid,","spoofzu","2020-02-19T04:01:37Z","2020-09-18T16:20:25Z"
"","24050","IOException ""Closed while Pending/Unready"" with WebFlux on Jetty","**Affects:** \Greenwich.SR3  Avoid calling Servlet APIs such as ServletOutputStream.close() or AsyncContext.complete() when previous writes are pending  > 10:24:13.788 [qtp640161448-137] TRACE org.springframework.http.server.reactive.ServletHttpHandlerAdapter - [5df01b5c] Handling completed > 10:24:13.785 [qtp640161448-20] WARN  org.eclipse.jetty.server.HttpOutput - java.io.IOException: Closed while Pending/Unready  You can find more details in [Guys from jetty investigation](https://github.com/jetty-project/jetty-reactive-httpclient/issues/20)  It can be easily  reproduced with [Reactive Feign test](https://github.com/Playtika/feign-reactive/blob/latest-jetty/feign-reactor-jetty/src/test/java/reactivefeign/jetty/h2c/AllFeaturesTest.java)","closed","type: enhancement,","kptfh","2019-11-21T08:43:30Z","2019-11-27T16:30:13Z"
"","24824","Allow setting SerializationInclusion with JsonInclude.Value","**Affects:** \5.2.5 Enhancement  * There is a method `Jackson2ObjectMapperBuilder.serializationInclusion(JsonInclude.Include serializationInclusion)` which is an equivalent to Jackson's `ObjectMapper setSerializationInclusion(JsonInclude.Include incl)` * Unfortunately there is no equivalent to `ObjectMapper.setPropertyInclusion(JsonInclude.Value incl)` which allows more elaborate configuration.  # Suggestion #1  * Replace (or add) `Jackson2ObjectMapperBuilder.serializationInclusion(JsonInclude.Include serializationInclusion)` with `Jackson2ObjectMapperBuilder.serializationInclusion(JsonInclude.Value serializationInclusion)` which covers more cases.  # Suggestion #2  * Add an object mapper post-processor to `Jackson2ObjectMapperBuilder` which would allow to perform exotic configurations not supported by builder by default. * This would remove the need of extending builder class which comes handy in Spring Boot applications.  ```java //example class Jackson2ObjectMapperBuilder {      private Consumer postProcessor;      public void configure(ObjectMapper objectMapper) {         // ...         if (postProcessor != null) {             postProcessor.accept(objectMapper);         }     } ```","closed","type: enhancement,","vkuzel","2020-03-31T11:37:21Z","2020-05-13T11:33:12Z"
"","24434","Sonatype vulnerability CVE-2016-1000027 in Spring-web project","**Affects:** \5.2.3.RELEASE  Issue Title : Sonartype vulnerability CVE-2016-1000027 in Spring-web project  Description Description from CVE Pivotal Spring Framework 4.1.4 suffers from a potential remote code execution (RCE) issue if used for Java deserialization of untrusted data. Depending on how the library is implemented within a product, this issue may or not occur, and authentication may be required. Explanation The org.springframework:spring-web package is vulnerable to deserialization of untrusted data leading to Remote Code Execution (RCE). The readRemoteInvocation method in HttpInvokerServiceExporter.class does not properly verify or restrict untrusted objects prior to deserializing them. An attacker can exploit this vulnerability by sending malicious requests containing crafted objects, which when deserialized, execute arbitrary code on the vulnerable system.  NOTE: This vulnerability is related to a previously reported deserialization vulnerability (CVE-2011-2894) within the package, impacting a different class.  Detection The application is vulnerable by using this component under specific scenarios as listed out in the advisory.  Reference: https://www.tenable.com/security/research/tra-2016-20  Recommendation There is no non-vulnerable upgrade path for this component/package. We recommend investigating alternative components or a potential mitigating control.  A warning has been provided in the official Javadocs of the HttpInvokerServiceExporter class:  ""WARNING: Be aware of vulnerabilities due to unsafe Java deserialization: Manipulated input streams could lead to unwanted code execution on the server during the deserialization step. As a consequence, do not expose HTTP invoker endpoints to untrusted clients but rather just between your own services. In general, we strongly recommend any other message format (e.g. JSON) instead.""  The developer's general advice also states:  ""Do not use Java serialization for external endpoints, in particular not for unauthorized ones. HTTP invoker is not a well-kept secret (or an ""oversight"") but rather the typical case of how a Spring application would expose serialization endpoints to begin with... he has a point that we should make this case all across our documentation, including the javadoc. But I don't really see a CVE case here, just a documentation improvement.  Pivoltal will enhance their documentation for the 4.2.6 and 3.2.17 releases.""  Reference: https://www.tenable.com/security/research/tra-2016-20  Root Cause spring-web-5.2.3.RELEASE.jar <= org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.class : [2.5.1,) Advisories Third Party: https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-1000027  Third Party: https://www.tenable.com/security/research/tra-2016-20 CVSS Details CVE CVSS 3: 9.8  CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","closed","status: invalid,","gauravdeshmukh612","2020-01-27T06:46:04Z","2022-07-18T07:24:57Z"
"","23877","Log message when @ModelAttribute on a void method has a name attribute","**Affects:** \5.1.9.RELEASE  --- given:  ```java public abstract class AbstractestController {     @ModelAttribute(""checkC"")     public void checkC() {         int a = 0;     } }  public abstract class AbstracterController extends AbstractestController {     @ModelAttribute(""checkB"")     public void checkB(@ModelAttribute(""checkC"") Void o) {         int a = 0;     } }  public abstract class AbstractController extends AbstracterController {     @ModelAttribute(""checkA"")     public void checkA(@ModelAttribute(""checkB"") Void checkB) {         int a = 0;     } }  @RestController public class TestController extends AbstractController {     @PostMapping(""/test"")     public void test() {     } } ```  When POSTing to /test I expect all three check methods to be called. However `checkB` is not called.  Workaround:  ```java public abstract class AbstractestController {     @ModelAttribute(""checkC"")     public Object checkC() {         int a = 0;         return new Object();     } }  public abstract class AbstracterController extends AbstractestController {     @ModelAttribute(""checkB"")     public Object checkB(@ModelAttribute(""checkC"") Object o) {         int a = 0;         return o;     } }  public abstract class AbstractController extends AbstracterController {     @ModelAttribute(""checkA"")     public Object checkA(@ModelAttribute(""checkB"") Object o) {         int a = 0;         return o;     } }  @RestController public class TestController extends AbstractController {     @PostMapping(""/test"")     public void test() {     } } ```","closed","type: task,","ravenblackdusk","2019-10-28T09:19:09Z","2020-05-06T09:54:44Z"
"","23908","Incorrect Javadoc for WebMvcConfigurer#addInterceptors","**Affects:** \<5.1.x, 5.0.x>  --- In spring 5.1.x also in 5.0.x, resourceHandlerMapping picks up interceptors configured for controllers only.  [WebMvcConfigurationSupport.java](https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L499)  ```java @Bean @Nullable public HandlerMapping resourceHandlerMapping() { 	Assert.state(this.applicationContext != null, ""No ApplicationContext set""); 	Assert.state(this.servletContext != null, ""No ServletContext set"");  	ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext, 			this.servletContext, mvcContentNegotiationManager(), mvcUrlPathHelper()); 	addResourceHandlers(registry);  	AbstractHandlerMapping handlerMapping = registry.getHandlerMapping(); 	if (handlerMapping == null) { 		return null; 	} 	handlerMapping.setPathMatcher(mvcPathMatcher()); 	handlerMapping.setUrlPathHelper(mvcUrlPathHelper()); 	handlerMapping.setInterceptors(getInterceptors()); // ==> here it adds all configured interceptors even those which are for controllers only. 	handlerMapping.setCorsConfigurations(getCorsConfigurations()); 	return handlerMapping; } ```  As per documentation of [WebMvcConfigurer](https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.java#L103) ``` 	/** 	 * Add Spring MVC lifecycle interceptors for pre- and post-processing of 	 * controller method invocations. Interceptors can be registered to apply 	 * to all requests or be limited to a subset of URL patterns. 	 * Note that interceptors registered here only apply to 	 * controllers and not to resource handler requests. To intercept requests for 	 * static resources either declare a 	 * {@link org.springframework.web.servlet.handler.MappedInterceptor MappedInterceptor} 	 * bean or switch to advanced configuration mode by extending 	 * {@link org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport 	 * WebMvcConfigurationSupport} and then override {@code resourceHandlerMapping}. 	 */ 	default void addInterceptors(InterceptorRegistry registry) { 	} ```  So any interceptor added using **addInterceptors** in WebMvcConfigurerAdapter or WebMvcConfigurer should not apply to resource handlerMapping which is not happening anymore.","closed","status: superseded,","samarthrastogi","2019-11-01T14:28:15Z","2019-11-06T21:59:14Z"
"","24410","Wrong version in LocalSessionFactoryBean javadoc","**Affects:** \ Spring 5.x  --- In the `org.springframework.orm.hibernate5.LocalSessionFactoryBean` javadoc we can read: ``` /**  * Specify an asynchronous executor for background bootstrapping,  * ...  *  * @since 4.3  * @see LocalSessionFactoryBuilder#buildSessionFactory(AsyncTaskExecutor)  */ public void setBootstrapExecutor(AsyncTaskExecutor bootstrapExecutor) { 	this.bootstrapExecutor = bootstrapExecutor; } ```  IMHO `@since 4.3` is a copy-paste error. The source code of the Spring 4.3 reveals that the method `setBootstrapExecutor` is not present in the [LocalSessionFactoryBean](https://github.com/spring-projects/spring-framework/blob/4.3.x/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBean.java). I guss this javadoc was copied from the `AbstractEntityManagerFactoryBean`, where this method really has been introduced in the Spring 4.3.  Please correct the javadoc to point to version 5.0.","closed","status: invalid,","gdemecki","2020-01-21T13:10:14Z","2020-01-21T13:22:49Z"
"","24234","@RestController returns {} with Gson when return value is interface with generic type","**Affects:** \ 4.2.5  I defined a method in Controller that returns a Page interface, but in fact I return a PageImpl implementation class object, but I receive a response value of {}  Postman Request result： ![image](https://user-images.githubusercontent.com/23075587/71227072-0435a300-2319-11ea-8d3c-3354a87f370d.png)  Controller RequestMapping: ![image](https://user-images.githubusercontent.com/23075587/71227127-2c250680-2319-11ea-9489-c0072b881a0b.png)  Page: ```java public interface Page {      int getTotalPages();      int getNumber();      int getSize();      int getNumberOfElements();      List getContent();      boolean hasContent();      boolean isFirst();      boolean isLast();      boolean hasNext();      boolean hasPrevious();      long getTotalElements();  } ```  PageImpl:  ```java  public class PageImpl implements Page,Serializable {     private static final long serialVersionUID = 2693326466571693579L;     private List content = new ArrayList();     private long total;     private PageRequest pageable;      public PageImpl(){      }      public PageImpl(List content, PageRequest pageable, long total){         this.content.addAll(content);         this.pageable = pageable;         this.total = !content.isEmpty() && pageable != null && (long)(pageable.getOffset() + pageable.getPageSize()) > total?(long)(pageable.getOffset() + content.size()):total;     }       @Override     public int getTotalPages() {         return this.getSize() == 0?1:(int)Math.ceil((double)this.total / (double)this.getSize());     }      @Override     public int getNumber() {         return this.pageable == null?0:this.pageable.getPageNumber();      }      @Override     public int getSize() {         return this.pageable == null?0:this.pageable.getPageSize();     }      @Override     public int getNumberOfElements() {         return this.content.size();     }      @Override     public List getContent() {         return Collections.unmodifiableList(this.content);    }      @Override     public boolean hasContent() {         return !this.content.isEmpty();     }      @Override     public boolean isFirst() {         return !this.hasPrevious();     }      @Override     public boolean isLast() {         return !this.hasNext();     }      @Override     public boolean hasNext() {         return this.getNumber() + 1 < this.getTotalPages();     }      @Override     public boolean hasPrevious() {         return this.getNumber() > 0;     }      @Override     public long getTotalElements() {         return this.total;     } } ```  I tried analyzing the code and found that in the AbstractMessageConverterMethodProcessor class  ![image](https://user-images.githubusercontent.com/23075587/71227318-be2d0f00-2319-11ea-9932-c996519376e7.png)  The Type obtained here is the Type of the interface, not the Type of the implementation class. I analyzed the source code of Gson and found that Gson is a set of attributes obtained based on the byte code of the passed Type. The interface itself does not have any fields. The cause of this problem.","closed","in: web,","iwangjie","2019-12-20T03:15:16Z","2019-12-20T13:55:43Z"
"","24373","WebClient overrides exchange strategies","**Affects:** \  WebClient doesn't retain existing exchange strategies while mutating. it seems similar bug was filed here - https://github.com/spring-projects/spring-hateoas/issues/867 and that was corrected but in spring Hateoas version 1.0.0.M1.  We can still notice this behaviour in spring-webflux-5.2.2.RELEASE. Not sure why the fix was not ported into web flux package. is it intentional/desired behaviour? Attached screenshot for same(w/o web client mutate)","closed","status: duplicate,","samarprakash","2020-01-16T04:12:06Z","2020-01-16T10:12:38Z"
"","24611","Improve Javadoc of URI related options in WebClient.Builder","**Affects:** \  ---  Please see a demo . ```java public static void main(String args[]){     DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory();     uriBuilderFactory.setEncodingMode(EncodingMode.NONE);     WebClient webClient = WebClient.builder().uriBuilderFactory(uriBuilderFactory)         .baseUrl(""http://localhots:9090"").build();     webClient.get().uri(""/api/v1/query"").retrieve().bodyToMono(String.class).block();   } ``` Maybe you already know what I mean. I want a webClient implementation that does not perform url encoding and decoding and has a baseurl. But unfortunately my code above seems to be able to meet my needs, but in fact baseurl does not take effect. I looked through the source code，the root cause is found in the following code. ```java private UriBuilderFactory initUriBuilderFactory() {  if (this.uriBuilderFactory != null) { 	return this.uriBuilderFactory;  }  DefaultUriBuilderFactory factory = this.baseUrl != null ? 		new DefaultUriBuilderFactory(this.baseUrl) : new DefaultUriBuilderFactory();  factory.setDefaultUriVariables(this.defaultUriVariables);  return factory; } ``` If `uriBuilderFactory` is set, `baseurl` will be ignored.I looked at the specific implementation of `DefaultUriBuilderFactory` again，At this point I understand that the correct way should be to set the `baseurl` through the constructor of `DefaultUriBuilderFactory`.  I think this kind of API design that If `uriBuilderFactory` is set, `baseurl` will be ignored  will cause some confusion.I wonder if you think so.Is it possible to eliminate this confusion by improving the `DefaultUriBuilderFactory` and related code. Thank you for reading and sincerely look forward to your reply.","closed","type: task,","chenqimiao","2020-02-28T14:43:56Z","2020-02-28T16:34:19Z"
"","24309","@Transaction and @Async annotations do not work together in Spring 5 for AspectJ advice mode","**Affects:** 5.x.x  --- Since Spring 5 (spring-aspects 5.x.x), it looks like `@Transactional` is ignored on the method with `@Async` when using `AdviceMode.ASPECTJ` for both `@EnableTransactionManagement` and `@EnableAsync`.  Please take a look on following demo: https://github.com/kklepacz/spring-async-transaction-demo  After running `mvn clean test` you should see following output:  ``` 2020-01-07 12:02:50.729  INFO 29454 --- [ async-thread-1] c.e.asynctransactiondemo.AsyncListener   : Transaction in async listener? false ```  So even if `@Transactional` annotation is present on `handle` method, transaction is not active.  Now, let's change Spring version. Update pom to use Spring 4 + Spring Boot 1.5.x  ``` 	 		org.springframework.boot 		spring-boot-starter-parent 		1.5.22.RELEASE 		  	 ```  Run `mvn clean test` again. Output:  ``` 2020-01-07 12:06:38.082 DEBUG 29675 --- [ async-thread-1] o.s.orm.jpa.JpaTransactionManager        : Creating new transaction with name [com.example.asynctransactiondemo.AsyncListener.handle]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2020-01-07 12:06:38.082 DEBUG 29675 --- [ async-thread-1] o.s.orm.jpa.JpaTransactionManager        : Opened new EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@3bcd99f8] for JPA transaction 2020-01-07 12:06:38.083 DEBUG 29675 --- [ async-thread-1] o.s.orm.jpa.JpaTransactionManager        : Exposing JPA transaction as JDBC transaction [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@350a70f1] 2020-01-07 12:06:38.083  INFO 29675 --- [ async-thread-1] c.e.asynctransactiondemo.AsyncListener   : Transaction in async listener? true 2020-01-07 12:06:38.085 DEBUG 29675 --- [ async-thread-1] o.s.orm.jpa.JpaTransactionManager        : Initiating transaction commit 2020-01-07 12:06:38.085 DEBUG 29675 --- [ async-thread-1] o.s.orm.jpa.JpaTransactionManager        : Committing JPA transaction on EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@3bcd99f8] 2020-01-07 12:06:38.085 DEBUG 29675 --- [ async-thread-1] o.s.orm.jpa.JpaTransactionManager        : Closing JPA EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@3bcd99f8] after transaction ```  Transaction is active.   Is it a bug or a feature and I need some extra configuration to have my Spring Boot 2 version working as expected?   Is it related to AJC compilation anyhow? I can see a difference between an order of compilation in maven output. For Spring Aspects 5.x: ``` [INFO] Showing AJC message detail for messages of types: [error, warning, fail] [INFO] Join point 'method-execution(void com.example.asynctransactiondemo.AsyncListener.handle(com.example.asynctransactiondemo.SomeEntitySaved))' in Type 'com.example.asynctransactiondemo.AsyncListener' (AsyncListener.java:19) advised by around advice from 'org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect' (spring-aspects-5.1.9.RELEASE.jar!AbstractAsyncExecutionAspect.class:65(from AbstractAsyncExecutionAspect.aj)) [INFO] Join point 'method-execution(void com.example.asynctransactiondemo.AsyncListener.handle(com.example.asynctransactiondemo.SomeEntitySaved))' in Type 'com.example.asynctransactiondemo.AsyncListener' (AsyncListener.java:19) advised by around advice from 'org.springframework.transaction.aspectj.AnnotationTransactionAspect' (spring-aspects-5.1.9.RELEASE.jar!AbstractTransactionAspect.class:66(from AbstractTransactionAspect.aj)) ``` For Spring Aspects 4.x - order is different: ``` [INFO] Showing AJC message detail for messages of types: [error, warning, fail] [INFO] Join point 'method-execution(void com.example.asynctransactiondemo.AsyncListener.handle(com.example.asynctransactiondemo.SomeEntitySaved))' in Type 'com.example.asynctransactiondemo.AsyncListener' (AsyncListener.java:19) advised by around advice from 'org.springframework.transaction.aspectj.AnnotationTransactionAspect' (spring-aspects-4.3.25.RELEASE.jar!AbstractTransactionAspect.class:66(from AbstractTransactionAspect.aj)) [INFO] Join point 'method-execution(void com.example.asynctransactiondemo.AsyncListener.handle(com.example.asynctransactiondemo.SomeEntitySaved))' in Type 'com.example.asynctransactiondemo.AsyncListener' (AsyncListener.java:19) advised by around advice from 'org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect' (spring-aspects-4.3.25.RELEASE.jar!AbstractAsyncExecutionAspect.class:65(from AbstractAsyncExecutionAspect.aj)) ```","open","in: core,","kklepacz","2020-01-07T11:14:16Z","2021-11-10T09:51:27Z"
"","24642","Clarify how to avoid favoring path extensions as well as deprecation warnings","**Affects:** 5.2.4.RELEASE  According to [24179](https://github.com/spring-projects/spring-framework/issues/24179) favorPathExtension is deprecated, and we should all use the Accept header, which is perfect for me, since I always use favorPathExtension = false   The setter in ContentNegotiationManagerFactoryBean is Deprecated, but the field value is true (line 108) , so as far as I understand, the use of path seems in fact encouraged, since is the default value and the only way to set as false is Deprecated  Am I getting something wrong?","closed","in: web,","pgrisafi","2020-03-04T20:06:28Z","2020-08-05T14:20:02Z"
"","24685","@DirtiesContext not honored in TestNG test suite","**Affects:** 5.2.4.RELEASE  ``` 5.2.4.RELEASE 7.1.0 1.8 1.8 2.22.2 ```  To reproduce: https://github.com/C-Otto/dirtiescontext  I have a Spring, Maven, Java 8, TestNG setup where one test uses `@DirtiesContext`. In this VERY specific setup the test fails when I use `mvn test`. This seems to be related to the class names and the order in which tests are run.  Notice that the class `AbstractClassSomeUnrelatedTest` does not serve any purpose, but has the same name prefix as the `abstract` test class. Changing the name to something else fixes the problem.   Related to #8560?","closed","status: invalid,","C-Otto","2020-03-12T11:57:23Z","2020-03-13T10:36:48Z"
"","24706","Unable to proxy-upload large file","**Affects:** 5.2.4 (Webflux)  I am building a simple `proxy-upload-service` which takes an uploaded file and uploads it to another web service using `WebClient `  I am hitting some issues when dealing with large file i.e > 30MB, see stack trace below:      java.lang.IllegalStateException: Unable to create the inputStream.             at org.synchronoss.cloud.nio.stream.storage.FileStreamStorage.newFileInputStream(FileStreamStorage.java:324)             Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:      ......     ......     Caused by: java.io.FileNotFoundException: /tmp/nio-file-upload/nio-body-1-73794d7c-1e74-43b6-ac69-54353d717e55.tmp (No such file or directory)         at java.base/java.io.FileInputStream.open0(Native Method)         at java.base/java.io.FileInputStream.open(FileInputStream.java:213)         at java.base/java.io.FileInputStream.(FileInputStream.java:155)         at org.synchronoss.cloud.nio.stream.storage.NameAwarePurgableFileInputStream.(NameAwarePurgableFileInputStream.java:49)         at org.synchronoss.cloud.nio.stream.storage.FileStreamStorage.newFileInputStream(FileStreamStorage.java:322)         at org.synchronoss.cloud.nio.stream.storage.FileStreamStorage.getInputStream(FileStreamStorage.java:245)         at org.springframework.core.io.buffer.DataBufferUtils.lambda$readInputStream$0(DataBufferUtils.java:83)     ......     ......   Code: ```kotlin     @PostMapping(""/files/"")     @ResponseStatus(NO_CONTENT)     fun upload(         @RequestPart(""file"") filePartFlux: Flux     ): Mono = filePartFlux.flatMap { filePart ->       val multiPartData = createFileMultiPartData(filePart)        webClient.method(POST)         .uri(URI.create(""my-upload-uri""))         .contentType(MediaType.MULTIPART_FORM_DATA)         .body(BodyInserters.fromMultipartData(multiPartData))         .retrieve()     }.then()      private fun createFileMultiPartData(filePart: FilePart): MultiValueMap> {         val builder = MultipartBodyBuilder()         builder.asyncPart(""fileData"", filePart.content(), DataBuffer::class.java)             .filename(filePart.filename())             .contentType(MediaType.APPLICATION_OCTET_STREAM)         return builder.build()     } ```","closed","","dkulig","2020-03-16T15:24:15Z","2020-05-21T01:15:03Z"
"","24565","Is it forbidden for a @Service annotated class to extend a @Repository annotated one?","**Affects:** 5.2.3.RELEASE  Hopefully this is not a bug, though I didn't have success looking for information around the net - not even searching on StackOverflow (where I previously asked [a question](https://stackoverflow.com/q/60341372/3127111) too).  Given a `@Repository` annotated class like:  ``` @Repository public class Dao extends JdbcDaoSupport {  	@Autowired 	private DataSource dbDataSource;  	@PostConstruct 	private void initialize() throws Exception { 		setDataSource(dbDataSource); 	}  	/* ... */ ```  Can I have a class like this (note the `@Service` annotation there)? ``` @Service public class Service extends Dao { 	/* ... */ ```  Because `Service` appears to have no jdbcTemplate - when I call `getJdbcTemplate()` it get `null`.  If I get rid of `@Repository` on `Dao`, or replace it with `@Service` it works.","open","in: core,","watery","2020-02-21T16:36:43Z","2021-11-10T11:58:05Z"
"","24138","Core Section of reference guide is wrongly formatted","**Affects:** 5.2.2.RELEASE (haven't checked the new 5.1 release!)  The documentation appears to be garbled. The headers haven't been rendered properly. Text contains things like ==, === and ==== which should lead to headers and a proper index. The index however stops at 1.9.4, whereas the documentation continues.   Appears that it was already fixed with #24132.","closed","status: duplicate,","mdeinum","2019-12-05T07:21:24Z","2020-01-04T10:19:45Z"
"","24285","Support setting spring.test.constructor.autowire.mode via junit-platform.properties file","**Affects:** 5.2.2.RELEASE  --- When using JUnit Jupiter and the `SpringExtension` I want to configure it to be able to use constructor injection without putting `@Autowired` on each parameter. This is supported if I set `spring.test.constructor.autowire.mode=all` in a file named `spring.properties` or set matching system property.  However I'm familiar with configuring how junit runs globally among tests by setting properties in the `junit-platform.properties` file.  Could we add that as an additional lookup for that property to unify this configuration?","closed","type: enhancement,","checketts","2020-01-02T16:55:30Z","2020-05-03T17:04:30Z"
"","24312","ServerSentEventHttpMessageReader does not respect maxInMemorySize and is always limited to 256k messages","**Affects:** 5.2.2, 5.2.1  ---  To reproduce: - Create a ServerSentEventHttpMessageReader with a decoder that has maxInMemorySize > 256k. - Call either `read` or `readMono`  with 256k < len(message body) <= maxInMemorySize - DataBufferLimitException is thrown  Expected: - The configured buffer limit is applied and not error is thrown  The problem is that while the data decoder passed to ServerSentEventHttpMessageReader _is_ properly configured to support a larger maxInMemorySize, that decoder is only used to decode the `data` part of the message. Prior to that, the SSE's body is decoded through a _different_ decoder (`private static final StringDecoder stringDecoder = StringDecoder.textPlainOnly()`) which is not properly configured - nore is it accessible in any way - with the new limit.  Note that to my understanding, prior to 5.2.0 there was no limit at all imposed to the body. Now there is one (see 89d053d7 by @rstoyanchev) , but we have no way to adjust it.","closed","type: regression,","jacqueslemire","2020-01-07T16:04:59Z","2020-01-13T14:57:55Z"
"","24253","Weak ConcurrentReferenceHashMap forgets strongly reachable objects after GC","**Affects:** 5.2.2 and 5.0.12  `ConcurrentReferenceHashMap` with reference type `WEAK` have entries disappear on garbage collections even though the keys and values stored in the map have strong references outside of the map. Given enough memory pressure, `SOFT` entries would probably fail similarly.  I suspect this happens because the `ConcurrentReferenceHashMap.WeakEntryReference` class (which extends `WeakReference`) is the only thing (weakly) referencing any Entry. The `Segment.references` items are all` WeakReference`s. Think you need to refactor the map to directly have `WeakReference` and `WeakReference` instances instead of `WeakReference`.  Soft references appear to be handled the identically, so any fix should be applied to those references as well of course.  Sample failing unit test (fails with AdoptOpenJDK version 8u222, issue was spotted on IBM JDK 8): ```java package test;  import org.junit.Test; import org.springframework.util.Assert; import org.springframework.util.ConcurrentReferenceHashMap;  import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; import java.util.Objects; import java.util.concurrent.ConcurrentMap;  public class WeakConcurrentReferenceHashMapTest {     @Test     public void testWeakConcurrentReferenceHashMap() {         final ConcurrentMap map =                 new ConcurrentReferenceHashMap<>(10, ConcurrentReferenceHashMap.ReferenceType.WEAK);         final List doNotGc = new ArrayList<>();         final Integer key = new Integer(123456);         final Integer value = new Integer(888888);         doNotGc.add(key);         doNotGc.add(value);         final WeakReference weakKey = new WeakReference<>(key);         final WeakReference weakValue = new WeakReference<>(value);          // put it there         map.put(key, value);         Assert.isTrue(Objects.equals(value, map.get(key)), ""1st get"");          // wipe map (comment out to make asserts pass)         System.gc();          // A weak reference to key or value should still be reachable after the GC         Assert.notNull(weakKey.get(), ""weak key ref"");         Assert.notNull(weakValue.get(), ""weak value ref"");         // map.get() returns null         Assert.isTrue(Objects.equals(value, map.get(key)), ""get post-GC"");         Assert.isTrue(doNotGc.size() == 2, ""I still remember all"");     } } ```","open","in: core,","stela","2019-12-23T17:23:19Z","2022-02-18T15:13:01Z"
"","24183","HttpMediaTypeNotAcceptableException: Could not parse 'Accept' header … Invalid token character ':' in token ""http://www.wapforum.org/xhtml""","**Affects:** 5.2.2  When doing this request:      $ ACCEPT='application/xhtml+xml; profile=http://www.wapforum.org/xhtml, application/vnd.wap.xhtml+xml, application/vnd.wap.wmlc, application/vnd.wap.wmlscripc, text/vnd.wap.wml, image/vnd.wap.wbmp, image/gif, image/bmp, audio/amr, audio/imelody, audio/midi, audio/wav, application/vnd.wap.wtls-ca-certifiate, application/x-x509-ca-cert, application/vnd.wap.hashed-certificate, application/vnd.wap.signed-certificate, */*, text/html'     $ curl -vH ""Accept: $ACCEPT"" localhost:8080/anything  Spring responses with a 406 and logs this warning:  > DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: Could not parse 'Accept' header [application/xhtml+xml; profile=http://www.wapforum.org/xhtml, application/vnd.wap.xhtml+xml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, text/vnd.wap.wml, image/vnd.wap.wbmp, image/gif, image/bmp, audio/amr, audio/imelody, audio/midi, audio/wav, application/vnd.wap.wtls-ca-certificate, application/x-x509-ca-cert, application/vnd.wap.hashed-certificate, application/vnd.wap.signed-certificate, */*, text/html]: Invalid mime type ""application/xhtml+xml; profile=http://www.wapforum.org/xhtml"": Invalid token character ':' in token ""http://www.wapforum.org/xhtml""]","closed","status: invalid,","mixcloud-downloader","2019-12-10T20:51:03Z","2019-12-13T12:35:05Z"
"","24254","Table of contents in documentation is broken","**Affects:** 5.2.2  ---  Excuse me if I'm reporting this issue in the wrong place.  https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html  The first ~20% of the page is fine but afterwards all the titles aren't correctly parsed any more. The first title that is broken is `Using Generics as Autowiring Qualifiers`. After that point all titles are parsed as plain text with the `=` as part of the text. This makes it very hard to navigate through the document.  Thanks!","closed","status: duplicate,","iluuu1994","2019-12-23T22:23:39Z","2019-12-24T10:50:57Z"
"","24103","Support multiple matchers in MockMvc Kotlin DSL","**Affects:** 5.2.1.RELEASE  I would expect that in a DSL everything in a lambda block will be executed. But if i try to assert multiple matchers in the `model` block only the last one will be executed. I didn't get any feedback about this behaviour, so i get the false impression that my code is executed, if it isn't.  Doesn't work like expected: ```kotlin mockMvc.get(url)   .andExpect {     model {       attribute(""foo"", ""foo"")       attribute(""bar"", ""bar"")     } } ```  Works, but is redundant code: ```kotlin mockMvc.get(url)   .andExpect {     model { attribute(""foo"", ""foo"") }     model { attribute(""bar"", ""bar"") } } ```","closed","status: feedback-provided,","devtribe","2019-11-29T12:12:16Z","2020-11-22T23:59:00Z"
"","23991","Calling MethodParameter.isOptional() for Kotlin Continuation parameter fails with IndexOutOfBoundsException","**Affects:** 5.2.1.RELEASE  Calling `MethodParameter.isOptional()` for a `kotlin.coroutines.Continuation` parameter of a `suspend fun` fails when introspecting a Coroutines method.  ``` java.lang.IndexOutOfBoundsException: Index: 1, Size: 1  	at java.util.ArrayList.rangeCheck(ArrayList.java:657) 	at java.util.ArrayList.get(ArrayList.java:433) 	at org.springframework.core.MethodParameter$KotlinDelegate.isOptional(MethodParameter.java:899) 	at org.springframework.core.MethodParameter.isOptional(MethodParameter.java:408) ```  The backing collection of `KParameter`s does not contain the parameter and therefore optionality checks fail.","closed","type: bug,","mp911de","2019-11-14T08:25:04Z","2019-11-14T14:35:04Z"
"","24094","UriTemplate unconditionally percent-encodes literal part","**Affects:** 5.2.1 and earlier  When using `UriTemplate` with a properly percent-encoded literal part, the percent sign gets encoded a second time. For example  ```java new UriTemplate(""https://example.org/foo%20and%20bar/{baz}"").expand(""xyzzy"") ```  yields `https://example.org/foo%2520and%2520bar/xyzzy` rather than the expected `https://example.org/foo%20and%20bar/xyzzy`.  `UriTemplate`'s constructor uses `UriComponentsBuilder.build()` without any arguments. One option could be to provide a second constructor with a boolean `encoded` argument mirroring the one-arg version of `UriComponentsBuilder.build()`. If this sounds like a useful addition I can create a small PR.","closed","status: declined,","bodewig","2019-11-27T16:24:25Z","2019-11-29T15:37:09Z"
"","24486","MockRestServiceServer reset does not clear failedRequests","**Affects:** 5.2.1  `MockRestServiceServer` reset does not reset failed requests on `AbstractRequestExpectationManager` introduced in gh-21799  given there are multiple tests using single MockRestServiceServer bean if the first test fails due to expectation, then all following tests will also fail with  ""java.lang.AssertionError: Some requests did not execute successfully.""   ---","closed","type: bug,","LSwiatek","2020-02-06T10:26:38Z","2020-02-10T15:02:57Z"
"","24176","InputStream consumed by DispatcherServlet logRequest","**Affects:** 5.2.1  ---  A few weeks ago I enabled debug logging for my application, today I had forgotten about but noticed that my injected `InputStream` was empty. After a debugging session (first assuming it again was related to the `HiddenHttpMethodFilter`) I ended up at   https://github.com/spring-projects/spring-framework/blob/8d846500eff3e51fc49846a969ae1a7f4671015d/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L955-L965  So every time I enable debug logging I cannot use my injected `InputStream`:  ```java @PostMapping public ResponseEntity doPost(InputStream input, HttpServletRequest request) {     ... ```  I do now get this logging:  ``` 2019-12-10T10:27:46,305 [http-nio-8082-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - POST ""/communication"", parameters={masked} ```  But maybe it would make sense to auto-wrap the request in DEBUG when that logging is active or give a warning when injecting the consumed `InputStream` later and even report who did it 😄   Thanks!  Related to (but not covered by): #22985","closed","status: invalid,","martinvw","2019-12-10T09:33:17Z","2020-01-17T09:40:38Z"
"","24507","MockMvcWebClientBuilder: support for MockHttpSession","**Affects:** 5.2.0.RELEASE  When building a WebClient, a helpful method would be to set the session from an existing MockHttpSession, eg: ``` WebClient webClient = MockMvcWebClientBuilder                 .mockMvcSetup( mockMvc )                 //.session(mockSession) <-- TODO                 .build(); ``` This method could set the required JSESSIONID cookie so that the session is recognized.  ### Use case: **WebClient** requests a page with an **iframe** that loads its contents from a spring **Controller** that uses a mocked **Session scoped bean**.  Mocking the session scoped bean only works for the autowired MockHttpSession that is not used in htmlunit's WebClient.","open","in: web,","cdalexndr","2020-02-11T20:58:49Z","2021-11-08T11:17:41Z"
"","24426","Support @Autowired HttpServletResponse in request-scoped beans","**Affects:** 5.2.0.RELEASE  The following should work for request scoped beans:  ```java     @Component     @RequestScope     public class RequestScopeBean {         @Autowired HttpServletRequest request;         @Autowired HttpServletResponse response; // <-- error     } ```  Additional resources:  - http://jawspeak.com/2010/05/06/injecting-httpservletresponse-into-spring-mvc-request-scoped-interceptors/ - https://stackoverflow.com/questions/6984054/autowired-httpservletresponse","open","in: web,","cdalexndr","2020-01-24T15:06:48Z","2020-01-24T15:44:16Z"
"","23958","Update docs on ShallowEtagHeaderFilter with regards to ASYNC dispatches","**Affects:** 5.2.0.RELEASE  Original issue: https://github.com/spring-projects/spring-boot/issues/18931  Registering **ShallowEtagHeaderFilter** with default configuration **breaks** async web requests, causing timeouts: ```     @Bean     public Filter etagFilter() {         return new ShallowEtagHeaderFilter();     } ``` The correct configuration is: ``` @Bean public FilterRegistrationBean etagFilter() {     FilterRegistrationBean registration = new FilterRegistrationBean<>(new ShallowEtagHeaderFilter());     registration.setDispatcherTypes(EnumSet.of(DispatcherType.REQUEST, DispatcherType.ASYNC));     return registration; } ```  Please update the [documentation ](https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/spring-framework-reference/web.html#filters-shallow-etag)to include this configuration for async requests, or provide a way to automatically configure for async requests.","closed","in: web,","cdalexndr","2019-11-08T16:02:32Z","2019-11-11T14:52:18Z"
"","23904","websocket request blocked by cors policy in 5.2","**Affects:** 5.2.0  Implemented a websocket configurer to allow requests from all origins, but response header does not include the `Access-Control-Allow-Origin: *`   **Code to:** ```java import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.config.annotation.EnableWebSocket; import org.springframework.web.socket.config.annotation.WebSocketConfigurer; import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;  @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer {     @Override     public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {         registry.addHandler(new WsTranportHandler(), ""/ws"").setAllowedOrigins(""*"").withSockJS();     } } ```  It works in spring-websocket-5.1.10","closed","status: duplicate,","chulman","2019-11-01T01:24:38Z","2019-11-01T13:59:24Z"
"","23880","WebClient onStatus order changed","**Affects:** 5.2.0  Hi all,  It looks like the `onStatus` custom error predicates are now evaluated in the inverted order compared to version `5.1.x`  Using the `WebClient` this way:  ```java webClient. // ...   .onStatus(      HttpStatus.BAD_REQUEST::equals,      res -> res.bodyToMono(Void.class).then(Mono.just(new SpecificException()))   )   .onStatus(     HttpStatus::isError,     res -> res.bodyToMono(Void.class).then(Mono.just(new GenericException())))    )  // ... ```  Using `5.1.0` first `onStatus` was evaluated first, using version `5.2.0` with the same `WebClient` usage, last `onStatus` is evaluated first and behavior is significantly changed.  This behavior change was introduced in commit https://github.com/spring-projects/spring-framework/commit/a9b3d95a14c316387f2b77328d6864b8e0a36721  If this `onStatus` evaluation order is not guaranteed, I think that this should be documented.  I can submit a documentation or a fix pull request.  Thomas","closed","type: regression,","trecloux","2019-10-28T16:55:35Z","2019-11-01T12:12:46Z"
"","23843","Missing CORS headers defined in SockJS CORS configuration","**Affects:** 5.2.0  --- I tried to bump Spring and Spring Sec boms to 5.2.0.RELEASE (from 5.1.6.RELEASE, Spring Sec 5.1.5.RELEASE) and ended up with CORS issues: ```` Access to XMLHttpRequest at 'https://ws.something.com/ws/info?t=1571689325027' from origin 'https://something.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. something.d4e1dbafa8d1cd4d94b8.js:1 Stomp connect error. Whoops! Lost connection to https://ws.something.com/ws ```` Headers returned (5.1.6) from the /ws/info endpoint: ```` access-control-allow-credentials: true access-control-allow-origin: https://something.com cache-control: no-store, no-cache, must-revalidate, max-age=0 content-encoding: gzip content-type: application/json;charset=UTF-8 date: Mon, 21 Oct 2019 21:11:08 GMT status: 200 vary: Origin,Accept-Encoding ````  Headers returned (5.2.0) from the /ws/info endpoint. ```` cache-control: no-store, no-cache, must-revalidate, max-age=0 content-encoding: gzip content-type: application/json;charset=UTF-8 date: Mon, 21 Oct 2019 20:22:15 GMT status: 200 vary: Accept-Encoding ````   Config: ````java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractSessionWebSocketMessageBrokerConfigurer {      @Autowired     private JwtAuthenticationWebsocketChannelInterceptorAdapter jwtAuthenticationWebsocketChannelInterceptorAdapter;      @Bean     public ServletServerContainerFactoryBean createWebSocketContainer() {         ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();         container.setMaxTextMessageBufferSize(2048);         container.setMaxBinaryMessageBufferSize(2048);         return container;     }      @Override     protected void configureStompEndpoints(StompEndpointRegistry registry) {         registry.addEndpoint(""/ws"")                 .setAllowedOrigins(""*"")                 .withSockJS()                 .setClientLibraryUrl(""https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.1.4/sockjs.min.js"");     }      @Override     public void configureMessageBroker(MessageBrokerRegistry config) {         config.setApplicationDestinationPrefixes(""/ws"");         config.enableSimpleBroker(""/topic"", ""/queue"", ""/user"");     }      @Override     public void configureClientInboundChannel(ChannelRegistration registration) {         registration.interceptors(jwtAuthenticationWebsocketChannelInterceptorAdapter);     }  } ```` No other changes to the application than the version bump.","closed","type: regression,","stnor","2019-10-21T21:02:32Z","2019-11-01T10:05:17Z"
"","23886","@SendTo doesn't use MessageConverter","**Affects:** 5.2.0  ---  I configured `MappingJackson2MessageConverter`, however the app still fails with `MessageConversionException`.  When I replace `@SendTo` with `template.convertAndSend()`, everything works as expected.  Code to reproduce:  ```java import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.RequiredArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.jms.annotation.EnableJms; import org.springframework.jms.annotation.JmsListener; import org.springframework.jms.annotation.JmsListenerConfigurer; import org.springframework.jms.config.JmsListenerEndpointRegistrar; import org.springframework.jms.core.JmsMessagingTemplate; import org.springframework.messaging.converter.MappingJackson2MessageConverter; import org.springframework.messaging.converter.MessageConverter; import org.springframework.messaging.handler.annotation.SendTo; import org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory;  @SpringBootApplication @EnableJms @RequiredArgsConstructor @Slf4j public class TestApp implements CommandLineRunner, JmsListenerConfigurer {    private final JmsMessagingTemplate template;    @JmsListener(destination = ""queue1"")   @SendTo(""queue2"")   public Payload handle(Payload payload) {     log.info(""Handling message {}"", payload);     return payload;   }    @Bean   public MessageConverter messageConverter() {     return new MappingJackson2MessageConverter();   }    @Bean   public DefaultMessageHandlerMethodFactory handlerMethodFactory() {     DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();     factory.setMessageConverter(messageConverter());     return factory;   }    @Override   public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {     registrar.setMessageHandlerMethodFactory(handlerMethodFactory());   }    @Override   public void run(String... args) {     template.setMessageConverter(messageConverter());     template.convertAndSend(""queue1"", new Payload(""test""));   }    public static void main(String[] args) {     SpringApplication.run(TestApp.class, args);   }    @Data   @AllArgsConstructor   @NoArgsConstructor   private static class Payload {      private String value;   } } ```","open","in: messaging,","b-dzoba","2019-10-29T12:57:36Z","2022-08-02T07:56:26Z"
"","24092","Provide guidance and better diagnostics when dependency injection makes a bean ineligible for complete post-processing","**Affects:** 5.2 (I believe earlier versions are also affected)  When the dependency relationships between beans causes one or more beans to be ineligible for bean post-processing, info messages are logged:  ``` 2019-11-26 19:49:45.834  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'playgroundApplication' of type [com.example.playground.PlaygroundApplication$$EnhancerBySpringCGLIB$$6f378901] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.837  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration' of type [org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleMetricsExportAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.848  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'management.metrics.export.simple-org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleProperties' of type [org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimpleProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.851  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'simpleConfig' of type [org.springframework.boot.actuate.autoconfigure.metrics.export.simple.SimplePropertiesConfigAdapter] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.853  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration' of type [org.springframework.boot.actuate.autoconfigure.metrics.MetricsAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.855  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'micrometerClock' of type [io.micrometer.core.instrument.Clock$1] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.865  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'simpleMeterRegistry' of type [io.micrometer.core.instrument.simple.SimpleMeterRegistry] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2019-11-26 19:49:45.878  INFO 28828 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'someAdvisor' of type [org.springframework.aop.support.DefaultPointcutAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) ```  From what I've seen these messages are often missed or presumed to be unimportant as they're at info level. I wonder if warn level would be more appropriate?  Beyond the level at which the messages are logged, the messages describe the problem but it's difficult to connect them to its cause. In this case, you have to know that AOP relies on proxies, that those proxies are created via a bean post-processor, and that any `Advisor` beans are injected into the post-processor. This chain of events leads to eager initialization of the advisor and its dependencies.  I wonder if it would be possible to provide better diagnostics at runtime to explain why a bean is not eligible for bean post-processing? I'd also welcome some additions to the reference documentation that draw attention to the dangers of injecting dependencies into bean post-processors and also highlight where bean post-processing is used and the care that must then be taken when defining beans used by those post-processors.","open","in: core,","wilkinsona","2019-11-27T09:46:38Z","2022-07-11T09:20:36Z"
"","23956","DEFAULT_PHASE of SmartLifecycle interface has incorrect Javadoc","**Affects:** 5.1.x  Javadoc says:  > The default phase for SmartLifecycle Integer.MAX_VALUE. This is different from the common phase 0 associated with regular Lifecycle implementations, putting the typically auto-started SmartLifecycle beans into a separate **later shutdown phase**  But in fact instances with greater phase property in shutdown phase executed firstly. So there is a bug or staled javadoc?","closed","in: core,","molekyla","2019-11-08T13:41:33Z","2019-11-11T10:40:19Z"
"","24131","WebTestClient cannot block when receive infinity stream of SSE","**Affects:** 5.1.5.RELEASE  --- I try to receive infinity Flux of server sent events represented by strings.  On my test - WebTestClient always throw IllegalStateException, because on the 'exchange' method it uses block with timeout.  **Controller code:**  ```java private final DirectProcessor sseProcessor;  @GetMapping(value = ""/signals"", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux sendSignals() {     return sseProcessor.publishOn(Schedulers.parallel())             .doOnNext(signal -> signal.setSent(ZonedDateTime.now()))             .map(writeSignalAsString())             .filter(Objects::nonNull); } ```  **Model:**  ```java @Data @NoArgsConstructor public class Signal {     private String id;     private Type type;     private ZonedDateTime initiated;     private ZonedDateTime sent;     private ZonedDateTime effective;     private String clue;     private Map data = new HashMap<>();      public enum Type {         TECH_DEDUPLICATION     } } ```  Test code: ```java         FluxExchangeResult sseFlux = client.get()                 .uri(""/v1/signals"")                 .exchange()                 .expectStatus().isOk()                 .expectHeader().contentTypeCompatibleWith(TEXT_EVENT_STREAM)                 .returnResult(String.class);          StepVerifier.create(sseFlux.getResponseBody())                 .assertNext(json -> {                     String signalInstanceId = JsonPath.parse(json).read(""$.data.data.instanceId"");                     assertThat(signalInstanceId, is(duplicateInstanceId));                 })                 .thenCancel().verify(); ```","closed","","Slava96","2019-12-04T13:50:25Z","2019-12-18T16:40:33Z"
"","24352","Provide control over formatting of request in HttpWebHandlerAdapter","**Affects:** 5.1.4-RELEASE  In HttpWebHandlerAdapter, if there is an exception that is not handled, it will log the entire request url.  https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java#L246  This is a problem for us because we have the user query as part of the URL and cannot log it due to security concerns. We want to be 100% sure that we will never log the user query, no matter what.  In order to do this, we had to copy these into our project :  - /src/main/java/org/springframework/web/server/adapter/WebHttpHandlerBuilder.java - /src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java - /src/main/java/org/springframework/web/server/adapter/DefaultServerWebExchange.java  And override HttpHandler bean to use the local version of the class  Suggestion here is to either : 1. Provide a way to override the formatRequest method.  2. Be able to pass a URL transformer object that we can use to control what gets logged.  Any other suggestions are also welcome.","closed","type: enhancement,","pratikmd","2020-01-14T06:16:07Z","2020-01-16T16:04:08Z"
"","24357","IncompatibleClassChangeError encountered on execution of compiled SPEL expressions","**Affects:** 5.1.12, 5.2.2  ---  Since this change in 5.1.8.RELEASE (#22242) we are witnessing failures in evaluation of compiled SpEL expressions.    The following test exposes the issue:  ```java        public void compiledExpression_typeDeclaresInterface() {         final SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, null);         SpelExpressionParser parser = new SpelExpressionParser(config);         final Expression expression = parser.parseExpression(""name"");         Person barney = new Person(""Barney"");         assertThat(expression.getValue(barney), is(""Barney""));         assertThat(expression.getValue(barney), is(""Barney""));         //This time the compiled expression will be used         assertThat(expression.getValue(barney), is(""Barney""));     }      public static class Person implements Named {          private final String name;          public Person(final String name) {             this.name = name;         }          public String getName() {             return name;         }     }      public interface Named {         String getName();     } ```  Running this results in the following exception:  ``` org.springframework.expression.spel.SpelEvaluationException: EL1072E: An exception occurred whilst evaluating a compiled expression 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:194) 	at org.springframework.expression.spel.support.CompiledSpelExpressionTest.compiledExpression_typeDeclaresInterface(CompiledSpelExpressionTest.java:24) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.IncompatibleClassChangeError: Found interface org.springframework.expression.spel.support.CompiledSpelExpressionTest$Named, but class was expected 	at spel.Ex2.getValue(Unknown Source) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:184) ```  The issue looks to be with the compilation - org.springframework.expression.spel.support.ReflectivePropertyAccessor.generateCode contains the following:  ```java              if (this.member instanceof Method) {                  mv.visitMethodInsn((isStatic ? INVOKESTATIC :  INVOKEVIRTUAL), classDesc, this.member.getName(),                         CodeFlow.createSignatureDescriptor((Method) this.member). false);             } ```  As we now are potentially referencing an interface, the following change fixes the issue:  ```java             if (this.member instanceof Method) {                  boolean isInterface = this.member.getDeclaringClass().isInterface();                 mv.visitMethodInsn((isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL), classDesc, this.member.getName(),                         CodeFlow.createSignatureDescriptor((Method) this.member), isInterface);             } ```  This has been tested against Oracle JDK 8u231 and  spring-expression 5.1.12.RELEASE and 5.2.2.RELEASE.  The issue is not encountered in spring-expression 5.1.7 and below.","closed","status: feedback-provided,","Smahlatz","2020-01-14T17:40:57Z","2020-02-12T14:55:40Z"
"","24198","JSON decoding error parsing stream encoded with Jackson Smile","**Affects:** 5.1.12  With #24009 fixed and versions updated, there's still issues with decoding Smile-encoded stream. Looks like a missyncronization between use of generator and parser: ``` org.springframework.core.codec.DecodingException: JSON decoding error: Invalid shared name reference 6;  only got 2 names in buffer (invalid content); nested exception is com.fasterxml.jackson.core.JsonParseException: Invalid shared name reference 6; only got 2 names in buffer (invalid content)  at [Source: UNKNOWN; line: -1, column: 6843033] 	at org.springframework.http.codec.json.Jackson2Tokenizer.tokenize(Jackson2Tokenizer.java:99) 	at reactor.core.publisher.FluxMapSignal$FluxMapSignalSubscriber.onNext(FluxMapSignal.java:137) ```","closed","type: bug,","fedortche","2019-12-12T15:17:25Z","2020-01-22T09:13:54Z"
"","24382","Allow customizing default Smile codec via CodecConfigurer","**Affects:** 5.1.12  Even though Smile codec is configured as part of default codecs in `BaseDefaultCodecs`, there's currently no way to configure it or replace it similar to other default codecs.  The only way arount at the moment is to remove _all_ defaults and reconfigure everything from scratch using only custom codecs. It seems to be even more complicated on the client side where default codecs include specials for SSE and multipart, so unregistering all defaults and building it all back is quite cumbersome.  This is inconsistent with other defaults, but also the whole codec configuration system seems very inconvenient for simple tasks like disabling a particular codec feature (in my case to get around #24198) or more frequent customizations like adding modules or mixins to ObjectMapper.","closed","type: enhancement,","fedortche","2020-01-16T19:04:48Z","2020-01-20T17:32:56Z"
"","24027","InMemoryWebSessionStore makes blocking calls to UUID.randomUUID","**Affects:** 5.1.11.RELEASE  Via @kschlesselmann [on Gitter](https://gitter.im/spring-projects/spring-boot?at=5dd3baeb52b73c7cb244004e):  ``` java.lang.Error: Blocking call! java.io.FileInputStream#readBytes     at reactor.blockhound.BlockHound$Builder.lambda$new$0(BlockHound.java:196) ~[blockhound-1.0.1.RELEASE.jar:na]     at reactor.blockhound.BlockHound$Builder.lambda$install$6(BlockHound.java:318) ~[blockhound-1.0.1.RELEASE.jar:na]     at reactor.blockhound.BlockHoundRuntime.checkBlocking(BlockHoundRuntime.java:46) ~[na:na]     at java.base/java.io.FileInputStream.readBytes(FileInputStream.java) ~[na:na]     at java.base/java.io.FileInputStream.read(FileInputStream.java:279) ~[na:na]     at java.base/java.io.FilterInputStream.read(FilterInputStream.java:133) ~[na:na]     at java.base/sun.security.provider.NativePRNG$RandomIO.readFully(NativePRNG.java:424) ~[na:na]     at java.base/sun.security.provider.NativePRNG$RandomIO.ensureBufferValid(NativePRNG.java:526) ~[na:na]     at java.base/sun.security.provider.NativePRNG$RandomIO.implNextBytes(NativePRNG.java:545) ~[na:na]     at java.base/sun.security.provider.NativePRNG.engineNextBytes(NativePRNG.java:220) ~[na:na]     at java.base/java.security.SecureRandom.nextBytes(SecureRandom.java:741) ~[na:na]     at java.base/java.util.UUID.randomUUID(UUID.java:150) ~[na:na]     at org.springframework.util.JdkIdGenerator.generateId(JdkIdGenerator.java:31) ~[spring-core-5.1.11.RELEASE.jar:5.1.11.RELEASE]     at org.springframework.web.server.session.InMemoryWebSessionStore$InMemoryWebSession.(InMemoryWebSessionStore.java:165) ~[spring-web-5.1.11.RELEASE.jar:5.1.11.RELEASE]     at org.springframework.web.server.session.InMemoryWebSessionStore.lambda$createWebSession$0(InMemoryWebSessionStore.java:116) ~[spring-web-5.1.11.RELEASE.jar:5.1.11.RELEASE]     at reactor.core.publisher.MonoSupplier.subscribe(MonoSupplier.java:56) ~[reactor-core-3.2.12.RELEASE.jar:3.2.12.RELEASE] ... ```","closed","type: bug,","wilkinsona","2019-11-19T11:01:20Z","2019-11-26T12:09:27Z"
"","24009","NullPointerException in JSON codec parsing stream encoded with Jackson Smile","**Affects:** 5.1.11  Using Spring 5.1.11, Spring Boot 2.1.10, Jackson 2.10.1, but it was there in previous versions as well.  There seems to be an issue in Spring Web with #20699, streaming Smile encoded data.   I'm trying to receive a stream of objects created by Spring WebFlux app as `Flux` using Smile encoding. JSON stream works OK.  With Smile most of the time I get `NullPointerException`:  ``` at com.fasterxml.jackson.databind.util.TokenBuffer.copyCurrentEvent(TokenBuffer.java:1032) at org.springframework.http.codec.json.Jackson2Tokenizer.processTokenArray(Jackson2Tokenizer.java:170) at org.springframework.http.codec.json.Jackson2Tokenizer.parseTokenBufferFlux(Jackson2Tokenizer.java:135) at org.springframework.http.codec.json.Jackson2Tokenizer.tokenize(Jackson2Tokenizer.java:94) ```  It seems that current token of parser passed to `copyCurrentEvent` is `null`.  I'm trying now to understand how exactly does it happen but decided to raise the issue anyway.  Unfortunately it's not the easiest one to debug as it goes away if you slow it down, which probably suggests that the problem manifests itself when there's no input available to process as next array element is not received yet.","closed","type: bug,","fedortche","2019-11-16T08:48:50Z","2019-11-25T15:28:18Z"
"","23954","Documentation for ForwardedHeaderFilter does not mention important filter order","**Affects:** 5.1.10  It took me half a day to figure out why my spring hateoas / `ForwardedHeaderFilter` setup did not work as intended.  It appeared that the `HttpServletRequest` used by `ServletUriComponentsBuilder` wasn't the wrapped one, which is caused by the fact that `ForwardedHeaderFilter` was executed AFTER `RequestContextFilter`.  You basically need to do this:  ```java     @Bean     public FilterRegistrationBean forwardedHeaderFilterRegistrationBean() {          FilterRegistrationBean registrationBean = new FilterRegistrationBean<>();          registrationBean.setFilter(new ForwardedHeaderFilter());         registrationBean.addUrlPatterns(""*"");         registrationBean.setOrder(org.springframework.boot.web.servlet.filter.OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - 1);          return registrationBean;     } ```  I didn't find any mention of this in the docs...","closed","in: web,","ctytgat","2019-11-08T09:48:59Z","2019-11-11T12:05:06Z"
"","24206","ClassUtils.getInterfaceMethodIfPossible overhead in cached methods for SpEL key/condition expressions","**Affects:** 5.1.0+  Since 'ReflectiveMethodExecutor invokes interface method if possible' (c4df335a1db090a59de040cc81fdacfb594ebfb9) has been committed there is a new method getInterfaceMethodIfPossible. This method unfortunately triggers exception in reflection code which is being catched and ignored as many times as there are interfaces on a class implementing the method (and all of its superclasses), which has an impact on performance (NoSuchMethodException is not pre-allocated so it is not optimized by OmitStackTraceInFastThrow JVM option) especially when such a method is not found (all interfaces have to be traversed).  The issue has been observed in repository code that uses @Cacheable and @CachePut annotations that use SpEL to select keys and describe conditions under which objects are cached. Spring cache infrastructure creates **a new** SpEL evaluation context for invocation of cached method when `key` or `condition` expressions are specified  and populates that new SpEL context with new instances of reflection accessors. The accessors then will trigger ClassUtils.getInterfaceMethodIfPossible in canRead and then cache the result. However since the new SpEL context is created for each method invocation this is caching ineffective.  This will affect probably any SpEL expression frequently executed in the system that is run with a new evaluation context for each invocation.  One possible remedy is to introduce cache on ClassUtils.getInterfaceMethodIfPossible (which I did) or try to fix the spring caching infrastructure (more complex).  I'm sharing the repository with sample code showing the effect here : https://github.com/tawek/classutils-interface-methods-issue  On my HW the overhead of calling @Cacheable method with issue mentioned above is about 127us  (~ 7800 calls per second). When cache is introduced into  ClassUtils.getInterfaceMethodIfPossible to avoid exception throwing the overhead is reduced to 10us (~91 000 calls per second). The measurements where done on OpenJDK8 ( OpenJDK11 gives similar results).  The issue is visible if SpEL expressions are more complex and use property access or method calls and if there are more interfaces on navigated objects. The workaround is not to use SpEL expressions if you want low cache overhead and perform lots of cached calls. :( Potentially this may hit other heavy users of SpEL since that ClassUtils method is invoked from  org.springframework.expression.spel.support.ReflectivePropertyAccessor.canRead and org.springframework.expression.spel.support.ReflectiveMethodExecutor. which are both quite common.","closed","in: core,","tawek","2019-12-13T23:36:07Z","2019-12-17T07:40:06Z"
"","24444","Avoid opaque to hierarchical reset in UriComponentsBuilder when input is null","**Affects:** 4.2.x  Execute below test case and verify the result:  ```java public void testURIComponentBuilder(){         String uri = ""urn:ietf:wg:oauth:2.0:oob""; 	UriComponentsBuilder redirectUriBuilder =  UriComponentsBuilder.fromUriString(uri); 	redirectUriBuilder.replaceQuery(null); 	redirectUriBuilder.fragment(null); 	redirectUriBuilder.build().toUriString(); 	assertThat(redirectUriBuilder.toUriString()).isEqualTo(uri); } ```  Expected result: `urn:ietf:wg:oauth:2.0:oob`  Actual result: `urn:`","closed","type: enhancement,","kganesh","2020-01-28T01:42:29Z","2020-01-30T10:11:22Z"
"","23867","jdbcTemplate.batchUpdate does not return counters of the BatchUpdateException","**Affects:** 3.0.0.M1 to 5.2.0.RELEASE  # Goal I'm trying to use the jdbcTemplate.batchUpdate and would like to know the exact failed statement.  # Issues 1. Trying to catch the BatchUpdateException which contains the counters does not work because the BatchUpdateException gets removed from the exception stack. 2. Even when the BatchUpdateException gets returned it only contains the counters of the current batch. The successful batch counts need to be communicated back to the caller as well.  # Code to reproduce the problem I use this table to quickly get a unique constraint exception ```sql create table batch_test (     id number primary key ); ``` ## Configuration Spring: 5.1.3.RELEASE Database: Oracle 18c  Code trying to catch the BatchUpdateException ```java final List primaryKeys = Arrays.asList(1, 2, 3, 4, 5, 6, 2, 7, 8, 9); try {     return jdbcTemplate.batchUpdate(             ""insert into batch_test values (?)"",             primaryKeys,             4,             (ps, primaryKey) -> {                 ps.setInt(1, primaryKey);             }     ); } catch (final DataAccessException e) {     final Throwable cause = e.getCause();     if (cause instanceof BatchUpdateException) {         final BatchUpdateException batchUpdateException = (BatchUpdateException) cause;         final long[] updateCounts = batchUpdateException.getLargeUpdateCounts();         // log the exact one that failed         for (int index = 0; index < updateCounts.length; index++) {             if (updateCounts[index] == Statement.EXECUTE_FAILED) {                 logger.debug(""The insert of element "" + index + "" of the array failed"");             }         }         if (updateCounts.length < primaryKeys.size()) {             logger.debug(""The insert of elements "" + (updateCounts.length - 1)                     + "" to "" + (primaryKeys.size() - 1) + "" of the array failed"");         }     }     throw e; } ```  # Possible solutions The problem I'm having happens here: https://github.com/spring-projects/spring-framework/blame/master/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java#L179  The original stack `sqlEx` gets overridden with the next exception and thus the information of the BatchUpdateException gets lost.  I understand the intent to translate the cause into an exception that is a little more meaningful, but IMHO the original BatchUpdateException should not be trashed.  Wherever a new exception is created the original exception should be used for the stack. So instead of: ```java DataAccessException dae = customTranslate(task, sql, sqlEx); DataAccessException customDex = customTranslator.translate(task, sql, sqlEx); DataAccessException customException = createCustomException(task, sql, sqlEx, customTranslation.getExceptionClass()); return new BadSqlGrammarException(task, (sql != null ? sql : """"), sqlEx); ``` the original exception should be used: ```java DataAccessException dae = customTranslate(task, sql, ex); DataAccessException customDex = customTranslator.translate(task, sql, ex); DataAccessException customException = createCustomException(task, sql, ex, customTranslation.getExceptionClass()); return new BadSqlGrammarException(task, (sql != null ? sql : """"), ex); ```  The second issue is probably here: https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java#L1059  `rowsAffected` needs to be communicated back to the caller to pinpoint the problematic update  # Workaround My current solution consist of writing my own Translator, overriding the doTranslate method and setting the translator when I create the jdbcTemplate Bean ```java public class BatchUpdateExceptionTranslator extends SQLErrorCodeSQLExceptionTranslator {     @Override     @Nullable     protected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex) {         // exchanging sqlEx with ex whenever creating a new Exception     } } ```  ```java @Configuration public class MyConfiguration {     @Bean     public JdbcTemplate jdbcTemplate(             final DataSource dataSource     ) {         final JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);         jdbcTemplate.setExceptionTranslator(new BatchUpdateExceptionTranslator());         return jdbcTemplate;     } } ```  The second issue cannot be fixed as easily. Either avoid the use of the batched update or set the batch size very high to not run into that problem","open","in: data,","asollberger","2019-10-24T20:19:52Z","2021-11-10T11:38:07Z"
"","24829","Duplicate Vary headers after enabling CORS filter","**Affects:** 2.2.6 and up, from what i tested.  ---  **Summary** I have noticed strange behavior when requesting a static resource with GET, while having the cors filter enabled by providing a CorsFilter bean. The problem is that the Vary headers get duplicated. This only happens, when the url gets mapped by SimpleUrlHandlerMapping to a request handler that implements CorsConfigurationSource, because then the AbstractHandlerMapping that the SimpleUrlHandlerMapping extends, injects a CorsInterceptor into the HandlerExecutionChain. This CorsInterceptor then uses a DefaultCorsProcessor to process the requests, which in turn automatically appends the Vary headers. The problem is that the CorsFilter also uses this DefaultCorsProcessor, so that's why the Vary headers get duplicated.  **Current behavior** When enabling the cors filter, static file responses contain duplicate Vary headers.  **Expected behavior** When enabling the cors filter, static file responses contain unique Vary headers.  **Configuration** - Spring Boot 2.2.6 - Spring Web 5.2.5 - Java 8  **Sample** https://github.com/rwinch/spring-boot-double-vary-headers/tree/no-security  **Related** Previously i thought this was related to spring security, so i created a ticket there (already resolved). I'm linking it here for reference: https://github.com/spring-projects/spring-security/issues/8245","closed","type: bug,","Moomba42","2020-03-31T16:58:06Z","2020-04-15T09:38:28Z"
"","24199","SpringExtension stops other Extensions after it from working when Autowiring test method","**Affects:** 2.2.1.RELEASE ---  When using `SpringExtension` with JUnit 5 for injecting beans to test methods via `ParameterResolver`, if the test method is annotated with `@Autowired` it Custom Annotations are not invoked by JUnit.  Not sure if this should be a Spring or JUnit issue.  Example 1:   ```java /**  * Order of ExtendsWith right to left  **/ @SpringBootTest @ExtendWith({Reset.class, SpringExtension.class}) class SpringTestBase {             @Autowired            void testWithAutoWiredAnnotation(AutoWirableClass var) {            // ...            } } ```  Example 2:  ```java @SpringBootTest @ExtendWith({Reset.class, SpringExtension.class}) class SpringTestBase {             void testWithAutowiredVariable(@Autowired AutoWirableClass var) {            // ...            } } ```  Custom Extension  ```java public class Reset implements BeforeEachCallback, AfterEachCallback {    @Override   public void beforeEach(ExtensionContext context) {     reload(); }    @Override   public void afterEach(ExtensionContext context) {     reload();   } } ```  With Example 1, `CustomExtension` fails to be called; with Example 2, it works perfectly.  Oddly, in both cases, `SpringExtension` does work and Autowires the beans properly, however, when the annotation is put on the test method instead of each variable, it doesn't work.  As I understand from the documentation, `ParameterResolver` only supports autowiring of constructors and then Parameters marked with `@Autowired` and doesn't check `@Autowired` to be present on the method, however Spring in its own process autowires the test method variables but somewhere interferes with JUnit's test context and stops further Extensions from being called.","closed","status: invalid,","nishantvas","2019-12-12T16:28:36Z","2019-12-13T15:51:39Z"
"","24114","Introduce BeanNameGenerator based on fully qualified class name","**Affects:**  Version 5  `@ComponentScan` will register Beans with a name generated from the class of the component.  **Problem:** Having two classes with the same name `UserMapper` in different packages will result in an `BeanDefinitionStoreException` 1. `org.company.dom -> userMapper` 2. `org.company.web -> userMapper`  **Suggestion:** Include the package in the bean name:  1. `org.company.dom.userMapper`  2. `org.company.web.userMapper`   **Why:** I'm forced to duplicate package information in the class name: 1. `org.company.dom; class domUserMapper` 2. `org.company.web; class webUserMapper`  same giving each Component a package prefixed name: 1. `org.company.dom; @Component(""domUserMapper"") class userMapper` 2.  `org.company.web; @Component(""webUserMapper"") class userMapper`  _Especially with generated sources like `MapStruct` this is not possible._  Or should I write a custom `BeanNamingStrategy`. For this I do not find so much information, so I guess it's not that famous...","closed","status: feedback-provided,","torsten-github","2019-12-02T10:32:59Z","2020-01-07T18:49:54Z"
"","24556","NullPointerException in MockHttpServletRequestBuilder for URI string with no protocol","**Affects:**  spring-boot-starter-test 2.1.6.RELEASE  **Use Case:** When performing an spring integration test over a get controller we add an url as a String to MockHttpServletRequestBuilder to perform such action.  **Issue:** When we add that url String without the protocol (for instance: ""localhost:port..."") the request returns a NullPointerException.  **Code failing:**  ```java MockHttpServletResponse response =      mockMvc.perform(MockMvcRequestBuilders.get(""localhost:port/some domain/etc..."")).andReturn().getResponse(); ```  **Code working:** ```java MockHttpServletResponse response =      mockMvc.perform(MockMvcRequestBuilders.get(""http://localhost:port/some domain/etc..."")).andReturn().getResponse(); ``` Just to clarify the only difference is that the second url contains the http protcol explicitly declared  **Expectation:**  Since http is the default protocol in many other frameworks I expect it to be inferred as url protocl if no other is defined explicitly.  **Cause:**  Inside that `MockMvcRequestBuilders.get(""uri"")` method there is a call to a private constructor who converts that String into an actual URI ```java MockHttpServletRequestBuilder(HttpMethod httpMethod, String url, Object... vars) { 	this(httpMethod.name(), UriComponentsBuilder.fromUriString(url).buildAndExpand(vars).encode().toUri()); } ```  But it does not work properly since this.utl.getRawPath() returns null which later causes updatePathRequestProperties to throw mentioned NullPointerException ![image](https://user-images.githubusercontent.com/28202081/74846333-9580c000-5330-11ea-8f97-694833356157.png)   Thanks in advance!","closed","type: bug,","dFarras","2020-02-19T15:05:51Z","2020-02-20T16:00:40Z"
"","24477","Regression issue with response encoding between Spring Boot 2.1.x and 2.2.x","**Affects:**  Spring Boot 2.2.x  ---  We have identified a regression issue while upgrading from Spring Boot 2.1.11 to Spring Boot 2.2.4.  In Spring 5.2.x `MediaType.APPLICATION_JSON_UTF8` has been deprecated. If we replace `produces = APPLICATION_JSON_UTF8_VALUE` on endpoints with `produces = APPLICATION_JSON_VALUE`our contract tests fails with error ``` java.lang.IllegalStateException: Parsed JSON [{""name"":""David S��der""}] doesn't match the JSON path [$[?(@.['name'] == 'David Söder')]] ```  No change has been made to the contract tests in the upgrade process. This looks very much like #24123 but since we're already using Spring 5.2.3 that is already in place.  I have created a very basic test project which showcases the issue. You can find it [here](https://github.com/dawiking/contracttest).  Are we missing some configuration? Is there another way to solve this in 2.2.x?  Please let me know if more information is needed.","closed","for: external-project,","dawiking","2020-02-04T11:07:09Z","2020-02-05T14:26:29Z"
"","24408","Missing documentation of spring-webmvc-struts","**Affects:**  Documentation for _spring-webmvc-struts_, all versions  ---  Under the link https://javadoc.io/doc/org.springframework/spring-webmvc-struts the following message appears: No JavaDoc is released for artifact org.springframework:spring-webmvc-struts:\. Please try other versions. You can retry or  report to us if you believe this is not expected.  All other spring components have such documentation available","closed","status: invalid,","Ceddaerrix","2020-01-21T11:50:13Z","2020-01-21T13:25:51Z"
"","24440","Cycle in LogAdapter.Log4jLog initialization within log appender","**Affects:**  5.2.x  The Spring implementation of commons-logging has the following logic within the `LogAdapter` for Log4j2...  ``` 		private static final LoggerContext loggerContext = 				LogManager.getContext(Log4jLog.class.getClassLoader(), false);  ...  		public Log4jLog(String name) { 			this.logger = loggerContext.getLogger(name); 		} ```  If a custom appender depends on a class that has a static logger defined, we get an NPE on the `loggerContext` because the constructor is called before the static field is initialized.  For the full context of the issue, see https://github.com/spring-projects/spring-amqp-samples/issues/59 and https://github.com/spring-projects/spring-amqp/issues/1148. The work-around was to defer initialization of the classes with the static loggers until the log system is initialized.  This may be an unsolvable catch-22 but I thought I should at least raise the issue in case the Spring Team has ideas. This was not an issue with Boot 1.5/Spring 4.3.  Here is a simple example that exhibits the behavior:  ```java @SpringBootApplication public class Rgh1148Application {  	public static void main(String[] args) { 		SpringApplication.run(Rgh1148Application.class, args); 	}  }  @Plugin(name = ""Test"", category = ""Core"", elementType = ""appender"", printObject = true) public class MyAppender extends AbstractAppender {  	private final SomeClass someClass = new SomeClass();  	public MyAppender(String name, Filter filter, Layout layout, boolean ignoreExceptions, 			Property[] properties) { 		super(name, filter, layout, ignoreExceptions, properties); 	}  	@PluginFactory 	public static MyAppender create( 			@PluginConfiguration final Configuration configuration, 			@PluginAttribute(""name"") String name, 			@PluginElement(""Layout"") Layout layout, 			@PluginElement(""Filter"") Filter filter, 			@PluginAttribute(""ignoreExceptions"") boolean ignoreExceptions) { 		return new MyAppender(name, filter, layout, ignoreExceptions, null); 	}  	@Override 	public void append(LogEvent event) { 		this.someClass.foo(event); 	}  }  class SomeClass {  	private static final Log logger = LogFactory.getLog(SomeClass.class);  	public void foo(LogEvent event) { 		logger.info(event); 	}  } ```  ```xml   	 		 			 		 		 		 	 	 		 			 		 	  ```  ```xml   	4.0.0 	 		org.springframework.boot 		spring-boot-starter-parent 		2.2.4.RELEASE 		  	 	com.example 	rgh1148 	0.0.1-SNAPSHOT 	rgh1148 	Demo project for Spring Boot  	 		1.8 	  	 		 			org.springframework.boot 			spring-boot-starter 			 				 					org.springframework.boot 					spring-boot-starter-logging 				 			 		  		 			org.springframework.boot 			spring-boot-starter-log4j2 		  		 			org.springframework.boot 			spring-boot-starter-test 			test 			 				 					org.junit.vintage 					junit-vintage-engine 				 			 		 	  	 		 			 				org.springframework.boot 				spring-boot-maven-plugin 			 		 	   ```  ``` 2020-01-27 15:02:40,570 main ERROR Unable to invoke factory method in class com.example.demo.MyAppender for element Test: java.lang.ExceptionInInitializerError java.lang.reflect.InvocationTargetException 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:136) 	at org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:1002) 	at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:942) 	at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:934) 	at org.apache.logging.log4j.core.config.AbstractConfiguration.doConfigure(AbstractConfiguration.java:552) 	at org.apache.logging.log4j.core.config.AbstractConfiguration.initialize(AbstractConfiguration.java:241) 	at org.apache.logging.log4j.core.config.AbstractConfiguration.start(AbstractConfiguration.java:288) 	at org.apache.logging.log4j.core.LoggerContext.setConfiguration(LoggerContext.java:579) 	at org.apache.logging.log4j.core.LoggerContext.reconfigure(LoggerContext.java:651) 	at org.apache.logging.log4j.core.LoggerContext.reconfigure(LoggerContext.java:668) 	at org.apache.logging.log4j.core.LoggerContext.start(LoggerContext.java:253) 	at org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:153) 	at org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:45) 	at org.apache.logging.log4j.LogManager.getContext(LogManager.java:194) 	at org.apache.commons.logging.LogAdapter$Log4jLog.(LogAdapter.java:155) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 	at org.apache.commons.logging.LogAdapter$Log4jAdapter.createLog(LogAdapter.java:122) 	at org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:89) 	at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67) 	at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59) 	at org.springframework.boot.SpringApplication.(SpringApplication.java:196) 	at com.example.demo.Rgh1148Application.main(Rgh1148Application.java:10) Caused by: java.lang.ExceptionInInitializerError 	at com.example.demo.MyAppender.(MyAppender.java:38) 	at com.example.demo.MyAppender.create(MyAppender.java:52) 	... 25 more Caused by: java.lang.NullPointerException 	at org.apache.commons.logging.LogAdapter$Log4jLog.(LogAdapter.java:160) . <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 	at org.apache.commons.logging.LogAdapter$Log4jAdapter.createLog(LogAdapter.java:122) 	at org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:89) 	at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67) 	at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59) 	at com.example.demo.SomeClass.(MyAppender.java:64) 	... 27 more ```","closed","in: core,","garyrussell","2020-01-27T20:18:02Z","2020-01-28T20:07:18Z"
"","24822","ObjectProvider.ifAvailable throws exception for scoped bean without an active scope","**Affects:**  5.2.4 (Spring Boot 2.2.6)  ---  I have a rest service that uses a `@RequestScope` bean to store some data.  Now I want to use the same classes that I use for my service in a background task. However, in this scenario there is of course no `RequestScope`.   My goal is the following:   If there is a `RequestScope`, inject the bean and use it. If there is no `RequestScope`, don't use the bean at all.   This is more or less my code:   ```java  @Autowired  private ObjectProvider logDetailsProvider;    public void doStuff() {     // ...      logDetailsProvider.ifAvailable(logDetails -> logDetails.add(""result"", result));     // ...    } ```  My expectation is that this code also works in a background thread and simply does not use the `LogDetails` class, but instead a `BeanCreationException` is thrown.   ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'scopedTarget.logDetails': Scope 'request' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request. 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:368) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.aop.target.SimpleBeanTargetSource.getTarget(SimpleBeanTargetSource.java:35) ... ```","closed","type: enhancement,","mnisius","2020-03-31T09:24:20Z","2020-06-24T10:13:55Z"
"","23930","Default spring security cache-control disables ShallowETagHeaderFilter","**Affects:**  5.2.0.RELEASE  Using **ShallowETagHeaderFilter**, **ETag** is not checked in request because the response has **Cache-control: no-store** (_CacheControlHeadersWriter.java_). Thus **ShallowETagHeaderFilter** is not compatible with **Spring Security** using _default_ configuration.","closed","status: invalid,","cdalexndr","2019-11-04T19:23:43Z","2019-11-05T10:06:58Z"
"","24413","Negative byte values not properly converted to unsigned int in URI encoding","**Affects:**  5.2.0-Release, current master (2020-01-22)  Line numbers from 5.2.0. spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java:330 ```java 		for (byte b : bytes) { 			if (b < 0) { 				b += 256; 			} 			if (type.isAllowed(b)) { 				bos.write(b); 			} 		[...] ```  The `b += 256` is a no-op as `b` is a `byte` (and so everything is modulo 256). `type.isAllowed(b)` expects an `int` as argument --> a negative `b` is widened to a negative `int` value.  Proposed fix: change the data type of `b` from `byte` to `int`.","closed","type: bug,","Andy-2639","2020-01-22T11:16:36Z","2020-01-24T16:00:50Z"
"","24262","Support fetching Request/Reponse Body in Webflux's ExchangeFilterFunction.ofRequestProcessor/ofResponseProcessor - Required for logging purpose","**Affects:**  Spring Framework : 5.2.1.RELEASE Spring Boot : 2.1.5.RELEASE  Added ExchangeFilterFunction to WebClient which logs request and response but while logging, there is no handle to get the request/response body as a string or JSON.   	public static ExchangeFilterFunction logRequest() { 		return ExchangeFilterFunction.ofRequestProcessor(clientRequest -> {                  //body                  logger.debug(clientRequest.body()); //-> This returns BodyInserter, need to fetch the body as a String/JSON.                  return Mono.just(clientRequest);                  }     }","closed","","ashoke-cube","2019-12-24T15:52:30Z","2020-10-22T05:09:26Z"
"","24041","URL suffix pattern issues","**Affects:** 2.2.1 --- I have some tests that test PUTting a resource to an endpoint. We support using path extensions to determine the content type of the request. The tests that do not include the file suffix in the path pass fine; the test that does include the suffix fails with a 406. The suffix is registered in ContentNegotationConfigurer and I've tried every combination of spring.mvc.pathmatch.use-suffix-pattern, spring.mvc.pathmatch.use-registered-suffix-pattern, spring.mvc.contentnegotiation.favor-path-extension, and spring.mvc.contentnegotiation.favor-parameter to no avail.  The request mapping in question accepts all values and produces html, xml, and json.  Debugging into the DispatcherServlet, I noticed in RequestMappingInfo.getMatchingCondition, the consumes condition properly matches, but the produces condition returns null. Stepping in further, I see the ContentNegotiationManager has 4 strategies, one of them being ServletPathExtensionContentNegotationStrategy. This class has a method resolveMediaTypeKey, which basically tries to look up the extension from registered media types. Because my file extension and media type are registered, it matches and returns the media type for that extension (which is not html, xml or json) and in turn, the ContentNegotationManager returns that value to the ProducesRequestCondition. At this point, the returned media type is compared to the declared produces values. Since the value being returned does not match any of the declared produces values from the controller, the condition fails.  This seems problematic to me. It seems like the behavior implies that if you PUT/POST/whatever a resource to a controller and it uses the file suffix to determine the content type of the request, it also attempts to force it as the return type when attempting to determine the handler mapping, which is not the case.  This was not an issue in Spring Boot 2.1.x. Curious if this is a legitimate issue or if there is something I'm missing.","closed","status: invalid,","joshfix","2019-11-20T12:38:47Z","2019-12-06T10:09:03Z"
"","24112","ContentDisposition cannot parse encoded filename with leading space","**Affects:** - Tested with spring-web 5.2.1.RELEASE - Affects probably all 5.0+ releases.  ---  The [Content-Disposition parser](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/ContentDisposition.java) supports filename encoding. However, if there is a space in front of the encoding, it fails with an `IllegalCharsetNameException`:  ``` Exception in thread ""main"" java.nio.charset.IllegalCharsetNameException:  UTF-8 	at java.nio.charset.Charset.checkName(Charset.java:315) 	at java.nio.charset.Charset.lookup2(Charset.java:484) 	at java.nio.charset.Charset.lookup(Charset.java:464) 	at java.nio.charset.Charset.forName(Charset.java:528) 	at org.springframework.http.ContentDisposition.parse(ContentDisposition.java:285) ```  Note the two spaces in front of the 'UTF-8'. One is from the exception string template, the other is from the parsed value from the response header.  We have an application running on the Undertow webserver. The exact header from an example response looks like this: `Content-Disposition: attachment; filename*= UTF-8''some-file.zip`  This is a valid header format as per [RFC 6266 Section 5 (Examples)](https://tools.ietf.org/html/rfc6266#section-5) where the following example is listed: ```      Content-Disposition: attachment;                           filename*= UTF-8''%e2%82%ac%20rates ```  My suggested fix is to `trim()` the charset before passing it to Java.","closed","type: enhancement,","aaronols","2019-12-02T08:58:53Z","2019-12-10T16:54:49Z"
"","24635","ShallowETagHeaderFilter (still) overwrites ETag and Content-Length","**Affects: Spring 5.2.4.RELEASE** --- Hello,  Despite #22797 and #23775, the ShallowETagHeaderFilter keeps overwriting ETag and Content-Length headers.  Here is a repository with unit tests that feature this issue: https://github.com/mickaeltr/Spring-ShallowEtagHeaderFilter-issue/  ```java @GetMapping(""/stream"") public ResponseEntity stream(HttpServletRequest request) {     // Let's say I have a big input stream for which I want to:     // - provide the Content-Length and ETag (to avoid a heavy calculation by ShallowEtagHeaderFilter)     // - allow caching through If-None-Match     return ResponseEntity.ok()             .contentType(MediaType.TEXT_PLAIN)             .eTag(""demo"") // -> overriden by ShallowETagHeaderFilter             .contentLength(123) // -> overriden by ShallowETagHeaderFilter             .cacheControl(CacheControl.maxAge(1, TimeUnit.HOURS))             .body(new InputStreamResource(new ByteArrayInputStream(""demo"".getBytes()))); } ``` Thanks","closed","type: bug,","mickaeltr","2020-03-03T20:02:44Z","2020-03-04T22:43:53Z"
"","24714","SPR-8389 condense BeanCreationException exception message","#8389  The root cause is the message for `NestedException` included the cause (by concatenating by `; nested exception is ...`), which is `NestedException` as well, so its message will include its own nested exception again, thus the horrible long exception messages. We don't need to include the cause message for stack trace will output its enclosed content at the `Caused by: ` section. My approach is to only return the basic message excluding cause message in getMessage overridden method, via runtime stack trace inspection. Testing case created to demonstrate that cause information is only output once in stack trace result.","open","in: core,","NathanQingyangXu","2020-03-18T00:52:29Z","2021-11-11T09:51:10Z"
"","24073","RSocketRequester allows specifying data more than once","#23649 merged `RSocketRequester.RequestSpec` and `RSocketRequester.ResponseSpec` into one and as a consequence the below is now possible which would send the 3rd data value ""Hello 3"" as the payload data and ignore the first two:  ```java Flux result = requester.route(""route"")     .data(""Hello 1"")     .data(""Hello 2"")     .data(""Hello 3"")     .retrieveFlux(String.class); ```  This was not an intended consequence that should not have been introduced. This issue is to correct it and ensure that after the first call to `data`, it is only possible to see the options for retrieving the response.","closed","type: bug,","rstoyanchev","2019-11-25T11:45:07Z","2019-11-25T11:48:58Z"
"","24297","Update Stream.map() instead of Stream.peek()","#### Motivation When I read `Stream.peek()` in java 8 document, It was for debugging. and `Stream.peek()` has side effect in Java 9. so I updated it with `Stream.map`  #### Modification Update `Stream.peek()` -> `Stream.map()`  #### Reference > Java8 API Note: This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline:  - [Java 8 Document](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-)   Java 9 Issue - [Java9 Stream Count - Peek Issue](https://docs.oracle.com/javase/9/docs/api/java/util/stream/Stream.html#count--)","closed","status: invalid,","NESOY","2020-01-06T10:39:53Z","2020-01-06T11:09:15Z"
"","24539","Improve handling of malformed Accept header for @ExceptionHandler methods","### Used version  * spring-boot: 2.2.4 * spring-web: 5.2.3  ### The issue  If the clients send a malformed `Accept` header, then the server will fail to respond using `@ExceptionHandler` and (spring-boot's) `ErrorController`.  Stacktrace (click to expand)  ````txt 2020-02-17 12:03:22.721  INFO 24996 --- [io-8081-exec-10] .h.e.e.h.AbstractRequestExceptionHandler : Responding with CONFLICT (HTTP-409): configuration.version_exists_already <<<9Q7w+6sRi+BXyxQT/p0xQr2ibHfUtLZAcy7Yx1mGURo>>> 2020-02-17 12:03:23.746  WARN 24996 --- [io-8081-exec-10] .m.m.a.ExceptionHandlerExceptionResolver : Failure in @ExceptionHandler com.example.errorhandling.handler.RestInvalidRequestExceptionHandler#handleApiException(ApiException)  org.springframework.web.HttpMediaTypeNotAcceptableException: Could not parse 'Accept' header [null]: Invalid mime type ""null"": does not contain '/' 	at org.springframework.web.accept.HeaderContentNegotiationStrategy.resolveMediaTypes(HeaderContentNegotiationStrategy.java:59) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.accept.ContentNegotiationManager.resolveMediaTypes(ContentNegotiationManager.java:124) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.getAcceptableMediaTypes(AbstractMessageConverterMethodProcessor.java:404) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:234) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:226) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:124) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:407) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:61) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:141) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:80) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1300) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1111) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) [spring-boot-actuator-2.2.4.RELEASE.jar:2.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.lang.Thread.run(Thread.java:834) [?:?]  2020-02-17 12:03:23.749 ERROR 24996 --- [io-8081-exec-10] o.a.c.c.C.[.[.[.[dispatcherServlet]      : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is com.example.errorhandling.ApiException: configuration.version_exists_already (9Q7w+6sRi+BXyxQT/p0xQr2ibHfUtLZAcy7Yx1mGURo)] with root cause  com.example.errorhandling.ApiException: configuration.version_exists_already (9Q7w+6sRi+BXyxQT/p0xQr2ibHfUtLZAcy7Yx1mGURo) 	at com.example.service.controller.ConfigurationsController.createVersionForType(ConfigurationsController.java:156) ~[classes/:?] 	at com.example.service.controller.ConfigurationsController$$FastClassBySpringCGLIB$$376cd8e3.invoke() ~[classes/:?] 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:120) ~[spring-context-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at com.example.service.controller.ConfigurationsController$$EnhancerBySpringCGLIB$$45cc246d.createVersionForType() ~[classes/:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?] 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?] 	at java.lang.reflect.Method.invoke(Method.java:566) ~[?:?] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) ~[spring-boot-actuator-2.2.4.RELEASE.jar:2.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.lang.Thread.run(Thread.java:834) [?:?]  2020-02-17 12:03:23.750 ERROR 24996 --- [io-8081-exec-10] .h.e.e.h.AbstractRequestExceptionHandler : Responding with INTERNAL_SERVER_ERROR (HTTP-500): http.internal_server_error <<>>  org.springframework.web.util.NestedServletException: Request processing failed; nested exception is com.example.errorhandling.ApiException: configuration.version_exists_already (9Q7w+6sRi+BXyxQT/p0xQr2ibHfUtLZAcy7Yx1mGURo) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) ~[spring-boot-actuator-2.2.4.RELEASE.jar:2.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) ~[tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.lang.Thread.run(Thread.java:834) [?:?] Caused by: com.example.service.errorhandling.ApiException: configuration.version_exists_already (9Q7w+6sRi+BXyxQT/p0xQr2ibHfUtLZAcy7Yx1mGURo) 	at com.example.service.controller.ConfigurationsController.createVersionForType(ConfigurationsController.java:156) ~[classes/:?] 	at com.example.service.controller.ConfigurationsController$$FastClassBySpringCGLIB$$376cd8e3.invoke() ~[classes/:?] 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:120) ~[spring-context-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at com.example.service.controller.ConfigurationsController$$EnhancerBySpringCGLIB$$45cc246d.createVersionForType() ~[classes/:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?] 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?] 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?] 	at java.lang.reflect.Method.invoke(Method.java:566) ~[?:?] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	... 41 more  2020-02-17 12:03:27.169  INFO 24996 --- [io-8081-exec-10] .h.e.e.h.AbstractRequestExceptionHandler : Responding with NOT_ACCEPTABLE (HTTP-406): request.media_not_acceptable <<>> 2020-02-17 12:03:28.650  WARN 24996 --- [io-8081-exec-10] .m.m.a.ExceptionHandlerExceptionResolver : Failure in @ExceptionHandler com.example.errorhandling.handler.InvalidRequestExceptionHandler#handleMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException)  org.springframework.web.HttpMediaTypeNotAcceptableException: Could not parse 'Accept' header [null]: Invalid mime type ""null"": does not contain '/' 	at org.springframework.web.accept.HeaderContentNegotiationStrategy.resolveMediaTypes(HeaderContentNegotiationStrategy.java:59) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.accept.ContentNegotiationManager.resolveMediaTypes(ContentNegotiationManager.java:124) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.getAcceptableMediaTypes(AbstractMessageConverterMethodProcessor.java:404) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:234) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:181) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:124) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:407) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:61) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:141) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:80) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1300) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1111) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:712) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:461) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:384) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:312) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:394) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:253) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:348) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:173) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.30.jar:9.0.30] 	at java.lang.Thread.run(Thread.java:834) [?:?]  2020-02-17 12:03:28.650  WARN 24996 --- [io-8081-exec-10] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: Could not parse 'Accept' header [null]: Invalid mime type ""null"": does not contain '/'] ````    The error flow is somewhat like this:  A) Throwing a handled exception in the controller method:  1. Invoke original method 2. Throw ApiException `configuration_conflict` 4. The `@ExceptionHandler` maps ApiException to an `ErrorDTO` (409) // Expected to end here 3. The server fails to parse the `Accept` header and throws another exception ( `NestedServletException`) 4. The `ErrorController` catches the expection and maps the new exception to an `ErrorDTO` again (500) 5. The server fails to parse the `Accept` header and throws another exception ( `HttpMediaTypeNotAcceptableException`) 6. The `@ExceptionHandler` maps the new exception to an `ErrorDTO` again (406) 7. The server/spring(?) determines it cannot respond and just responds with HTTP-406 without body.  B) Returning any DTO from the method  1. Invoke original method 2. Return some DTO 3. The server is unable to parse the `Accept` header and throws `HttpMediaTypeNotAcceptableException` 4. The `@ExceptionHandler` maps the exception to an `ErrorDTO` (406) // Expected to end here 5. The server fails to parse the `Accept` header 6. The `ErrorController` triggers the fallback handling and maps it to an `ErrorDTO` (406) 7. The server/spring(?) determines it cannot respond and just responds with HTTP-406 without body.   I expliticly added a `HttpMessageConverter` that is able to serialize `ErrorDTO`s to `MediaTypes.ALL` (forced JSON), but it won't get called at all.  ### Reproduce  You can reproduce this error by using the following call:  ````bash $ curl 'http://localhost:8080/test' -H 'Accept: null' -v < HTTP/1.1 406 < Content-Length: 0 ````  The following works as expected:  ````bash $ curl 'http://localhost:8080/test' -H 'Accept: null/null' -v < HTTP/1.1 409 < Content-Type: application/json < Content-Length: 280 < {   ""errorCode"": ""configuration.version_exists_already"",   ""errorId"": ""Qd3fZRkJm+of7kk+v22hrvBtcoHSEjt2J1WIsVtJjYE"",   ""statusCode"": 409 } ````  ## Summary  The message converter for `HttpMediaTypeNotAcceptableException` shouldn't fail due to the very same reason.  Also the `WARN` log `Failure in @ExceptionHandler com.example.errorhandling.handler.InvalidRequestExceptionHandler#handleMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException)` with the stacktrace is confusing, because the method passed successfully, but the server failed to serialize it.   ### workaround (not tested)  * Bypass the `HttpMessageConverter` and return `byte[]` directly and thus (hopefully) bypass the parsing of the `Accept` header.","closed","type: enhancement,","ST-DDT","2020-02-17T13:16:57Z","2021-02-25T18:29:49Z"
"","24626","XML Data loss when using RequestEntity","### Spring Version: v2.0.1.RELEASE ### Problem I am running a spring boot server using RequestEntity interface. When I am doing a POST request with this data #### bookdata.xml  ```xml  	Ashish 	 		 Math 		 Hindi 	   ``` I am getting the following response . ``` {""name"":""Ashish"",""subject"":{""name"":""Hindi""}}  ```  The XML data is getting lost.   Here is the server code  ```java public class GetFunctionData {     public static ResponseEntity call(RequestEntity req) {         return ResponseEntity.ok(req.getBody());     }  } ``` Just to verify the same I ran another server with HttpServletRequest interface and there is no data loss.  Server code with HttpServletRequest ```java  @RestController @EnableAutoConfiguration public class Server {  	@RequestMapping(value = ""/"", method = { RequestMethod.GET, RequestMethod.POST, RequestMethod.DELETE, RequestMethod.PUT }) 	ResponseEntity home(HttpServletRequest request) {  		String body;  		try { 			// Getting headers and Converting header in MultiValueMap format. 			MultiValueMap headers = new LinkedMultiValueMap<>(); 			Enumeration headerNames = request.getHeaderNames(); 			while (headerNames.hasMoreElements()) { 				String key = (String) headerNames.nextElement(); 				String value = request.getHeader(key); 				headers.put(key, singletonList(value)); 			} 			//extract the queryparameters from the request 			StringBuilder newQuery = new StringBuilder(request.getRequestURL().toString()); 			Enumeration parameterNames = request.getParameterNames(); 			Boolean haveQueryParameter = false; 			while (parameterNames.hasMoreElements()) { 				if(!haveQueryParameter) { 					newQuery.append(""?""); 					haveQueryParameter = true; 				}else { 					newQuery.append(""&""); 				} 				String paramName = parameterNames.nextElement(); 				String[] paramValues = request.getParameterValues(paramName);  				for (int paramCount = 0; paramCount < paramValues.length; paramCount++) { 					if(paramCount==0) 						newQuery.append(paramName+""=""+request.getParameterValues(paramName)[paramCount]); 					else 						newQuery.append(""&""+paramName+""=""+request.getParameterValues(paramName)[paramCount]); 				} 			} 			URI newUri = new URI(newQuery.toString());  			//Extract the body from the reqest 			body = request.getReader().lines().collect(Collectors.joining());  			//Get the rawrequest 			RequestEntity rawRequest = new RequestEntity(body,headers,HttpMethod.resolve(request.getMethod()), newUri); 			return ((ResponseEntity) GetFunctionData.call(rawRequest)); 		} catch (Exception e) { 			e.printStackTrace(); 			return ResponseEntity.badRequest().body(e.getMessage()); 		} 	}   	public static void main(String[] args) throws Exception { 		SpringApplication.run(Server.class, args); 	}  }  ``` Here is the gist for the code  https://gist.github.com/anubhav6663/90cf922ce4b07af2c135ca8df4e5d05e ## How to reproduce the issue Run RequestServer.java from the gist. Using terminal:  ```curl -X POST -H 'Content-type:text/xml' -d @bookdata.xml http://localhost:8080```","closed","for: stackoverflow,","anubhav6663","2020-03-02T11:57:00Z","2020-03-09T15:32:24Z"
"","24267","Make BeanUtils copyProperties able to copy Immutable, Mutable and Mixed Java Bean","### Description  the `copyProperties` method in the `BeanUtils` class, is able to copy only public properties or the ones with a public setter method. it would be really useful if this functionality can be extended in order to copy any kind of Java Bean: **Mutable**, **Immutable**, **Mixed**.  ### Solution   Evaluate the possibility to use, behind the scenes, an open-source library that is able to copy Mutable, Immutable and Mixed Java Bean.  A good library that meets the above requirements is [BULL](https://github.com/HotelsDotCom/bull). This library has already been adopted by huge IT companies in their project. This would also make able to copy nested objects.  ### More details about BULL  - DZone: [How to Transform Any Type of Java Bean With BULL](https://dzone.com/articles/how-to-transform-any-type-of-java-bean-with-one-li)  - InfoQ: [How Expedia Is Getting Rid of Java Bean Transformers](https://www.infoq.com/articles/expedia-rid-of-bean-transformers/) [[EN](https://www.infoq.com/articles/expedia-rid-of-bean-transformers/)] [[PT-BR](https://www.infoq.com/br/articles/expedia-rid-of-bean-transformers/)]","closed","status: superseded,","fborriello","2019-12-26T11:23:52Z","2019-12-26T17:38:46Z"
"","23835","Handle %2F in simp messaging usernames [cancelled to recreate based on CONTRIBUTING.md]","### Current State Since messaging destinations are delimited by ""/"", the existing code performs a simple string replacement of ""/"" -> ""%2F"" in usernames.  This allows usernames which contain ""/"" to be used and have messaging destinations parsed correctly.  See [SimpMessagingTemplate.java](https://github.com/spring-projects/spring-framework/blob/243f2890ee9e98c97c8dc7278f033def3bf33f86/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessagingTemplate.java#L227) and [DefaultUserDestinationResolver.java](https://github.com/spring-projects/spring-framework/blob/243f2890ee9e98c97c8dc7278f033def3bf33f86/spring-messaging/src/main/java/org/springframework/messaging/simp/user/DefaultUserDestinationResolver.java#L217)  ### Issue with Current State Usernames that already contain ""%2F"" end up with that character sequence converted to a ""/"" by DefaultUserDestinationResolver.  E.g., `abc%2Fabc` > `abc/abc`; however, `abc/abc` is not the username, so destination matching fails.  [Here is an example test that fails](https://github.com/njlaw/spring-framework/commit/6683c795465f6ec2a91443549357a05a50a910db), resulting in  ``` org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests > handleMessageEncodedUserNameWithPercentTwoEff() FAILED -- org.opentest4j.AssertionFailedError at DefaultUserDestinationResolverTests.java:205   717 tests completed, 1 failed ``` ([Gradle build scan](https://gradle.com/s/rbezilmjwrhhi))  ### Possible Solutions 1. Use a custom encoding scheme that accounts both for ""/"" and whatever ""/"" encodes to in the scheme. 2. Use a known encoding scheme like application/x-www-form-urlencoded or URL-safe Base64 ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5)) and either:   (a) Encode all usernames   (b) Encode only usernames that contain characters that need to be encoded and flag the username as encoded so that only encoded usernames are decoded  ### Sample Solution A sample solution is included in this pull request using 2(b).  ### Outstanding Questions Should an explicit encoding be provided for String > byte[] and byte[] > String?  If so, what?  UTF-8?  Or just let the behavior be undefined if running Java in an environment where the default encoding does not support a particular character?  ### Other Alternatives  - Document ""%2F"" as not supported in a username and add a runtime check for invalid user names instead of the current behavior of just not matching message destinations correctly  Any feedback is appreciated!","closed","","njlaw","2019-10-19T18:17:22Z","2019-11-12T07:06:38Z"
"","23836","Reject ""%2F"" as an invalid sequence in simp messaging usernames","### Current State Since messaging destinations are delimited by ""/"", the existing code performs a simple string replacement of ""/"" -> ""%2F"" in usernames.  This allows usernames which contain ""/"" to be used and have messaging destinations parsed correctly.  See [SimpMessagingTemplate.java](https://github.com/spring-projects/spring-framework/blob/243f2890ee9e98c97c8dc7278f033def3bf33f86/spring-messaging/src/main/java/org/springframework/messaging/simp/SimpMessagingTemplate.java#L227) and [DefaultUserDestinationResolver.java](https://github.com/spring-projects/spring-framework/blob/243f2890ee9e98c97c8dc7278f033def3bf33f86/spring-messaging/src/main/java/org/springframework/messaging/simp/user/DefaultUserDestinationResolver.java#L217)  ### Issue with Current State Usernames that already contain ""%2F"" end up with that character sequence converted to a ""/"" by DefaultUserDestinationResolver.  E.g., `abc%2Fabc` > `abc/abc`; however, `abc/abc` is not the username, so destination matching fails.  [Here is an example test that fails](https://github.com/njlaw/spring-framework/commit/6683c795465f6ec2a91443549357a05a50a910db), resulting in  ``` org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests > handleMessageEncodedUserNameWithPercentTwoEff() FAILED -- org.opentest4j.AssertionFailedError at DefaultUserDestinationResolverTests.java:205   717 tests completed, 1 failed  :spring-messaging:testorg.springframework.messaging.simp.user.DefaultUserDestinationResolverTests » handleMessageEncodedUserNameWithPercentTwoEff() (0.044s) org.opentest4j.AssertionFailedError:   Expecting:  <0> (instead resolves to 0 destinations) to be equal to:  <1> (should resolve to a single destination) but was not. ``` ([Gradle build scan](https://gradle.com/s/rbezilmjwrhhi))  ### Possible Solutions 1. Use a custom encoding scheme that accounts both for ""/"" and whatever ""/"" encodes to in the scheme. 2. Use a known encoding scheme like application/x-www-form-urlencoded or URL-safe Base64 ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5)) and either:   (a) Encode all usernames   (b) Encode only usernames that contain characters that need to be encoded and flag the username as encoded so that only encoded usernames are decoded  ### Sample Solution A sample solution is included in this pull request using 2(b).  ### Outstanding Questions Should an explicit encoding be provided for String > byte[] and byte[] > String?  If so, what?  UTF-8?  Or just let the behavior be undefined if running Java in an environment where the default encoding does not support a particular character?  ### Other Alternatives  - Document ""%2F"" as not supported in a username and add a runtime check for invalid user names instead of the current behavior of just not matching message destinations correctly  Any feedback is appreciated!  As a note, I recreated this pull request since I didn't branch my fork of the code first or squash commits as recommended by the contribution guidelines.","closed","type: enhancement,","njlaw","2019-10-19T19:09:36Z","2019-11-26T16:22:30Z"
"","24186","WebFlux may send incomplete response if the session persistence fails","### Components and interactions  Please have a look at the following test. It contains:  - WebSessionController - a server which replies to /just/{timestamp} HTTP requests and has an exception handler which responds the 500 answer. - WebSessionTestWebSessionManager - sets a concurrent sessions limit to 0 for the sake of testing. - WebSessionTest - a test client which sends /just/12345 HTTP request and waits for the response at most 5 seconds.  WebSessionController:  ```java package com.example;  import java.util.concurrent.Executors;  import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.ResponseStatus; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.server.WebSession;  import reactor.core.publisher.Mono; import reactor.core.scheduler.Scheduler; import reactor.core.scheduler.Schedulers;  import static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;  @RestController public class WebSessionController implements InitializingBean, DisposableBean {     private Scheduler scheduler;      @Override     public void afterPropertiesSet()     {         scheduler = Schedulers.fromExecutorService(Executors.newCachedThreadPool());     }      @Override     public void destroy()     {         scheduler.dispose();     }      @GetMapping(""/just/{timestamp}"")     public Mono> just(@PathVariable String timestamp, WebSession session)     {         return Mono.fromCallable(() -> {             session.getAttributes().putIfAbsent(""test"", timestamp);              return ResponseEntity.status(HttpStatus.OK)                     .header(HttpHeaders.CACHE_CONTROL, ""no-store"")                     .body(timestamp);         }).subscribeOn(scheduler);     }      @ResponseStatus(value= INTERNAL_SERVER_ERROR, reason=""Too many sessions"")     @ExceptionHandler     public void tooManySessions(Exception e)     {     }      /*     No difference how the handler is implemented or does it exist at all.      @ExceptionHandler     public Mono> tooManySessions(Exception e)     {         return Mono.fromCallable(() -> ResponseEntity.status(500).body(e.getMessage())).subscribeOn(scheduler);     }      @ExceptionHandler     public ResponseEntity tooManySessions(Exception e)     {         return ResponseEntity.status(500).body(e.getMessage());     }     */ } ```  WebSessionTestWebSessionManager:  ```java package com.example;  import org.springframework.beans.factory.InitializingBean; import org.springframework.stereotype.Component; import org.springframework.web.server.session.DefaultWebSessionManager; import org.springframework.web.server.session.InMemoryWebSessionStore; import org.springframework.web.server.session.WebSessionManager;  @Component(""webSessionManager"") public class WebSessionTestWebSessionManager extends DefaultWebSessionManager implements WebSessionManager,         InitializingBean {     private final InMemoryWebSessionStore sessionStore = new InMemoryWebSessionStore();      @Override     public void afterPropertiesSet()     {         sessionStore.setMaxSessions(0);         super.setSessionStore(sessionStore);     } } ```  WebSessionTest:  ```java package com.example;  import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpResponse.BodyHandlers; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.web.server.LocalServerPort; import org.springframework.test.context.junit.jupiter.SpringExtension;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull;  @ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,         classes = {WebSessionController.class, WebSessionTestWebSessionManager.class}) @EnableAutoConfiguration public class WebSessionTest {     @LocalServerPort     private int serverPort;      @Test     public void testJustReponse() throws ExecutionException, InterruptedException     {         long timestamp = System.currentTimeMillis();          HttpClient client = HttpClient.newHttpClient();         HttpRequest request = HttpRequest.newBuilder()                 .uri(URI.create(""http://localhost:"" + serverPort + ""/just/"" + timestamp))                 .build();         CompletableFuture> future =                 client.sendAsync(request, BodyHandlers.ofString()).completeOnTimeout(null, 5, TimeUnit.SECONDS);         HttpResponse response = future.get();          assertNotNull(response, ""No response after 5 seconds."");         assertEquals(500, response.statusCode());     } } ```  pom.xml:  ```xml       4.0.0      com.example     com.example.springweb     1.0-SNAPSHOT               11         11                                                  maven-compiler-plugin                                                               -implicit:none                                                                                 maven-jar-plugin                                                                                                                                                             org.springframework             spring-web             5.2.2.RELEASE             test                                org.springframework.boot             spring-boot-test-autoconfigure             2.2.2.RELEASE             test                                org.springframework.boot             spring-boot-starter-webflux             2.2.2.RELEASE             test                               org.springframework             spring-beans             5.2.2.RELEASE             test                               org.springframework.boot             spring-boot-autoconfigure             2.2.2.RELEASE             test                               org.springframework             spring-test             5.2.2.RELEASE             test                               org.hamcrest             hamcrest-core             1.3             test                               org.junit.jupiter             junit-jupiter-api             5.5.2             test                ```  ### Expected result  Client gets 4xx/5xx response or at least ends up with the closed connection caused by exceeded concurrent sessions limit number.  ### Actual result  Client hangs.  ### Additional information  If I suspend the test with the IDE debugger (it blocks the test thread only) and send a request via curl I see the following output:  ``` curl -v http://localhost:53857/just/1234567 *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 53857 (#0) > GET /just/1234567 HTTP/1.1 > Host: localhost:53857 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < Cache-Control: no-store < Content-Type: text/plain;charset=UTF-8 < Content-Length: 7 < ```  Here ""Content-Length: 7"" is the length of 200 response (the contents of the URI's last segment) which WebSessionController sends, so the status line and the headers have been sent but the body hasn't. It looks like if the server had sent the status line and the headers with an exception occurred afterwards which resulted in the inability to send error response.  ### Environment:  * springframework: 5.2.2.RELEASE, * springboot: 2.2.2.RELEASE, * Java version: 11","closed","type: bug,","evgenyvsmirnov","2019-12-11T05:57:13Z","2020-09-11T04:39:26Z"
"","24533","Repeatable Read HttpServletRequest InputStream","### Cannot Read HttpServletRequest,getInputStream() Multi Times. - When I readed HttpServletRequest.getInputStream() in the Filter, then the `@RequestBody` parsing parmeter face an exception like ""java.io.IOException: Stream closed"". - The exception above is that HttpServletRequest,getInputStream() can only be read once, I read HttpServletRequest.getInputStream() in the filter before RequestParamMethodArgumentResolver read. ### The Same Problem In StackOverFlow - https://stackoverflow.com/questions/4449096/how-to-read-request-getinputstream-multiple-times - https://stackoverflow.com/questions/5345173/unable-to-read-request-getinputstream","closed","status: declined,","lixiaolong11000","2020-02-16T14:53:50Z","2020-05-22T14:09:44Z"
"","24293","Improve ExposeInvocationInterceptor exception message","### add exposeInvocationInterceptor exception msg - because ExposeInvocationInterceptor use ThreadLocal to expose MethodInvocation in current Thread, thus ExposeInvocationInterceptor.currentInvocation()  that invoking in other thread will throw Exception. - some spring users face the problem cann't know the reason. for example: _https://stackoverflow.com/questions/7147031/spring-aspect-fails-when-join-point-is-invoked-in-new-thread?r=SearchResults_  Thank you.","closed","type: enhancement,","lixiaolong11000","2020-01-04T14:39:22Z","2020-01-07T10:08:08Z"
"","24321","Improve exception message in AopContext.currentProxy()","### add aopContext exception msg  - because `AopContext` use `ThreadLocal` to expose `Proxy` object in current `Thread`, thus `AopContext.currentProxy()` that invoking in other thread will throw an exception.  - for example:  ```java @Service     public static class AsyncTransactionalTestBean {          @Transactional         public Collection testTransToAsync() {             System.out.println(""testTransToAsync "" + Thread.currentThread().getName());             ((AsyncTransactionalTestBean) AopContext.currentProxy()).testAsyncToAsync();             return null;         }           @Async         public void testAsyncToAsync() {             System.out.println(""testAsyncToAsync "" + Thread.currentThread().getName());             ((AsyncTransactionalTestBean) AopContext.currentProxy()).testAsync();         }          @Async         public void testAsync() {             System.out.println(""testAsync "" + Thread.currentThread().getName());         }     } ```  AsyncTransactionalTestBean.testTransToAsync() will Exception  -  for concrete example：https://github.com/lixiaolong11000/async  Thank you.","closed","type: enhancement,","lixiaolong11000","2020-01-09T14:14:14Z","2020-01-09T14:57:55Z"
"","24067","@Async doesn't work well with AopContext","### @Async doesn't work well with AopContext  #### First, let's see a example below: the demo's link:[https://github.com/lixiaolong11000/async](url)  ``` class AsynApplicationTests {      @Test     void contextLoads() {     }       @Test     public void asynExposeProxy() throws InterruptedException {         AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfigure.class);         AsyncTransactionalTestBean asyncTransactionalTestBean = ctx.getBean(AsyncTransactionalTestBean.class);         AsyncTestBean asyncTestBean = ctx.getBean(AsyncTestBean.class);          assertThat(AopUtils.isAopProxy(asyncTransactionalTestBean)).as(""asyncTransactionalTestBean is not a proxy"").isTrue();         assertThat(AopUtils.isAopProxy(asyncTestBean)).as(""asyncTestBean is not a proxy"").isTrue();          asyncTransactionalTestBean.testTransToAsync();          asyncTransactionalTestBean.testAsyncToAsync();          asyncTestBean.testAsyncToAsyncTOAsync();          ctx.close();     }       @Service     public static class AsyncTransactionalTestBean {          @Transactional         public Collection testTransToAsync() {             System.out.println(""testTransToAsync "" + Thread.currentThread().getName());             ((AsyncTransactionalTestBean) AopContext.currentProxy()).testAsyncToAsync();             return null;         }           @Async         public void testAsyncToAsync() {             System.out.println(""testAsyncToAsync "" + Thread.currentThread().getName());             ((AsyncTransactionalTestBean) AopContext.currentProxy()).testAsync();         }          @Async         public void testAsync() {             System.out.println(""testAsync "" + Thread.currentThread().getName());         }     }       @Service     public static class AsyncTestBean {          @Async         public Collection testAsyncToAsyncTOAsync() {             System.out.println(""testAsyncToAsyncTOAsync "" + Thread.currentThread().getName());             ((AsyncTransactionalTestBean) AopContext.currentProxy()).testAsyncToAsync();             return null;         }          @Async         public void testAsyncToAsync() {             System.out.println(""testAsyncToAsync "" + Thread.currentThread().getName());             ((AsyncTransactionalTestBean) AopContext.currentProxy()).testAsync();         }          @Async         public void testAsync() {             System.out.println(""testAsync "" + Thread.currentThread().getName());         }     }       @EnableAsync     @EnableAspectJAutoProxy(exposeProxy = true)     @Configuration     @EnableTransactionManagement     static class AppConfigure  {          @Bean         public AsyncTransactionalTestBean asyncTransactionalTestBean() {             return new AsyncTransactionalTestBean();         }          @Bean         public AsyncTestBean asyncTestBean() {             return new AsyncTestBean();         }          @Bean         public PlatformTransactionManager txManager() {             return new MockTransactionManager();         }     } } ```  run AsynApplicationTests.asynExposeProxy() we can find the exception:  ``` java.lang.IllegalStateException: Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available. 	at org.springframework.aop.framework.AopContext.currentProxy(AopContext.java:69) ~[spring-aop-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at com.example.asyn.AsynApplicationTests$AsyncTransactionalTestBean.testAsyncToAsync(AsynApplicationTests.java:64) ~[test/:na] 	at com.example.asyn.AsynApplicationTests$AsyncTransactionalTestBean$$FastClassBySpringCGLIB$$adeba3a5.invoke() ~[test/:na] 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769) ~[spring-aop-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747) ~[spring-aop-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.aop.interceptor.AsyncExecutionInterceptor.lambda$invoke$0(AsyncExecutionInterceptor.java:115) ~[spring-aop-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_181] 	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_181] ```  #### Second, I find the reason is : @Async doesn't work well with AopContext. because: - @EnableAspectJAutoProxy(exposeProxy = true) can make AopContext **work in current Thread**,not work in another Thread. so the test above **asyncTransactionalTestBean.testTransToAsync()** result in Exception - the test above **asyncTransactionalTestBean.testAsyncToAsync()** result in Excepton because AsyncAnnotationBeanPostProcessor、AsyncExecutionInterceptor、AsyncAnnotationAdvisor not surport AopContext.  #### Third, summary - When Aop(cglib,jdkproxy) use AopContext,@Async doesn't work well - @Aysnc is also a Aop, but it not suport AopContext   #### Final, I want contribute to spring to enhance it, thanks","open","in: core,","lixiaolong11000","2019-11-24T15:41:47Z","2021-11-10T10:03:00Z"
"","24600","Relax GraalVM checks in DefaultParameterNameDiscoverer","## Status Quo  `DefaultParameterNameDiscoverer` does not register any default discoverers when running within a GraalVM native image; however, the `LocalVariableTableParameterNameDiscoverer` works properly given appropriate entries in the `resource-config.json` and `reflect-config.json` GraalVM native image configuration files.  Though not yet verified, `StandardReflectionParameterNameDiscoverer` may potentially work in a current (or future) GraalVM release.  ## Proposal   We should relax the checks performed in `DefaultParameterNameDiscoverer` in order to give `LocalVariableTableParameterNameDiscoverer` and `StandardReflectionParameterNameDiscoverer` a chance to work.","closed","type: enhancement,","sbrannen","2020-02-26T12:59:19Z","2020-07-27T10:26:54Z"
"","24223","Ensure CORS processing does not add Vary header twice on async requests","## spring boot version `2.2.2` ## example   `WebMvcConfigurer` ``` CorsRegistration corsRegistration = registry.addMapping(""/**"")                 .allowCredentials(true); corsRegistration.allowedHeaders(""*"")                 .maxAge(1800L)                 .allowedMethods(HttpMethod.GET.name(),                         HttpMethod.POST.name(),                         HttpMethod.PUT.name(),                         HttpMethod.OPTIONS.name(),                         HttpMethod.DELETE.name())                 .exposedHeaders(""Content-Length""); ``` `controller` ``` @RequestMapping(""/test) @RestController public class ExampleController {     @GetMapping     public CompletableFuture test() {         // do something     } } ```  `reponse headers` ``` Vary | Origin Vary | Access-Control-Request-Method Vary | Access-Control-Request-Headers Vary | Origin Vary | Access-Control-Request-Method Vary | Access-Control-Request-Headers ```  Ref #24222","closed","type: bug,","blackstorm","2019-12-18T06:17:55Z","2019-12-19T12:59:26Z"
"","24188","Regression: annotation searches no longer handle exceptions","## Overview  While working on #24136, it became apparent that the use of `AnnotationUtils.handleIntrospectionFailure()` was removed in b91ccf038f309dfd1f91101133598b79c0b7efdf and added back as a `private` method in 37255afca49b0787ecfd074a7ba4c91788694e5a.  Consequently, we lost that exception handling support outside of `AnnotationUtils` which will inevitably lead to regressions for some use cases.  ## Potential Candidates  Potential candidates in `AnnotationsScanner` for local exception handling.  - processElement() - processClassInheritedAnnotations() - processClassHierarchy() - processMethodInheritedAnnotations() - processMethodHierarchy()  ## Deliverables  - [x] Start using `AnnotationUtils.handleIntrospectionFailure()` within the new `MergedAnnotation` internals.","closed","in: core,","sbrannen","2019-12-11T10:57:33Z","2019-12-13T15:15:27Z"
"","24017","ControllerAdviceBean.findAnnotatedBeans() finds proxies as well as their target beans, resulting in double registration","## Overview  While implementing a fix for the regression raised in #23985, it became apparent that methods in a `@ControllerAdvice` bean end up being registered and invoked twice if the advice is a scoped bean (e.g., request or session scoped). In other words, both the proxy bean and the target bean are wrapped in `ControllerAdviceBean` instances.  The reason this happens is that `ControllerAdviceBean.findAnnotatedBeans()` finds **all** beans in the `ApplicationContext` that are annotated with `@ControllerAdvice`.  ## Deliverables  - [x] Ensure that the list returned by `ControllerAdviceBean.findAnnotatedBeans()` does not contain target beans for scoped proxies.","closed","type: bug,","sbrannen","2019-11-18T14:24:28Z","2019-11-19T13:23:02Z"
"","24830","Revisit ""fast enough"" performance tests","## Overview  The Spring Framework test suite contains numerous tests that are assigned to the PERFORMANCE CI build, and many of these tests have names along the lines of ""ensure that XYZ is fast enough"".  When these tests were originally written, they were feasible when executed on an average developer's workstation; however, over time these tests have proven to be _flaky_ when executed on the CI server with various load levels for the various CI agents.  We are opening this issue in order to reassess whether such ""performance"" tests make sense in the current Spring Framework build.  ## Candidates  - [ ] `org.springframework.aop.framework.IntroductionBenchmarkTests`  ## Deliverables  - [x] Introduce a JMH benchmark infrastructure in the build - [ ] Search for test methods and test classes that are annotated with `@EnabledForTestGroups(PERFORMANCE)` (or `@EnabledForTestGroups(TestGroup.PERFORMANCE)`) or that contain ""FastEnough"" in their titles and determine if the tests should be deleted or modified to make them more robust. - [ ] Delete or modify each such test method or test class.","closed","type: task,","sbrannen","2020-03-31T17:37:39Z","2020-09-25T11:52:19Z"
"","24473","Revise generation of aggregated Javadoc in Gradle build","## Overview  The Gradle team has brought it to our attention that we should ideally generate aggregated Javadoc along the lines of the example provided by @jjohannes [here](https://github.com/jjohannes/gradle-demos/tree/master/aggregated-javadoc).  ## Rationale  Adopting the aforementioned best practice for aggregating Javadoc across projects will...  - make parallel execution and build configuration caching safer/possible - avoid potential breakage in future versions of Gradle - introduce greater separation of concerns - replace the current, hand-crafted approach with something more robust and maintainable","closed","status: superseded,","sbrannen","2020-02-03T14:21:45Z","2021-01-24T11:33:58Z"
"","23858","Remove unused type parameter declarations in MockMvc","## Overview  Several of the `ResultMatcher` methods used in `MockMvc` declare unused type parameters (e.g., ``). This is obviously the result of copying an existing method that actually needs the type parameter for proper casting.  For example, the following in `RequestResultMatchers`:  ```java /**  * Assert a request attribute value.  */ public  ResultMatcher attribute(String name, Object expectedValue) { 	return result -> 			assertEquals(""Request attribute '"" + name + ""'"", expectedValue, result.getRequest().getAttribute(name)); } ```  ... should actually be declared without `` since `T` is not used in the implementation or in the return type:  ```java /**  * Assert a request attribute value.  */ public ResultMatcher attribute(String name, Object expectedValue) { 	return result -> 			assertEquals(""Request attribute '"" + name + ""'"", expectedValue, result.getRequest().getAttribute(name)); } ```  ## Side Effects  Once we remove the unused type parameter declarations, users will see the following side effects if they had previously declared a type argument when invoking such methods.  - **Java**: an `Unused type arguments for the non generic method ...` warning will be generated by the compiler, but the code will continue to work unchanged. - **Kotlin**: a `Type inference failed: Not enough information to infer parameter T in fun ...` compiler error will be raised, causing the code to no longer compile (see [KT-5464](https://youtrack.jetbrains.com/issue/KT-5464)). Removal of the type argument declaration will allow the code to work correctly again.","closed","type: bug,","sbrannen","2019-10-24T08:18:45Z","2019-10-24T08:47:27Z"
"","24474","Configure Gradle build for use with newer JDKs","## Overview  In order to test the Spring Framework against newer versions of the JDK (e.g., early access builds for JDK 14, 15, etc.), we should introduce support in our Gradle build that allows us to select an alternative JDK (`JAVA_HOME`) to use when executing and/or compiling tests.  ## Proposal  Introduce system properties that can control whether an alternative Java installation is to be used for the current build.  Investigate options available on the CI server (e.g., existing environment variables that point to JDK installations).  ## Notes  The Bamboo CI server has JDK 14ea installed in `/opt/jdk-14`. Moreover, installed JDKs available include `/opt/jdk-[7-14]`.  ## Related Issues  - #24215  - #23678  - #24453","closed","type: task,","sbrannen","2020-02-03T15:49:57Z","2020-03-18T15:07:23Z"
"","24547","Upgrade to Gradle 6.2","## Overview  Gradle 6.2 has been released: https://docs.gradle.org/6.2/release-notes.html  Let's upgrade the Spring Framework build to Gradle 6.2.x during Spring Framework 5.3 development.  ## Related Issues  - gh-23479","closed","status: superseded,","sbrannen","2020-02-18T08:21:13Z","2020-02-24T13:34:49Z"
"","24077","Regression: @Inherited annotations declared in superclass are not recognized anymore","## Overview  After migration to spring boot 2.2 we noticed that behavior of the annotations scan has been changed. In our case we define `@SpringBootApplication` in the base abstract class   ```java @SpringBootApplication public abstract class BaseApplication {      protected abstract BaseApplication getApp();      public void start(String[] args) {         SpringApplication.run(getApp().getClass(), args);     } } ```  and then multiple concrete applications extend this class  ```java public class DemoApplication extends BaseApplication { 	public static void main(String[] args) { 		new DemoApplication().start(args); 	}  	@Override 	protected BaseApplication getApp() { 		return this; 	} } ```  It works fine in the v 2.1.x, but in 2.2 attempt to run the app causes the error:""  > java.lang.IllegalArgumentException: No auto-configuration attributes found. Is com.xxx.Application annotated with EnableAutoConfiguration  ``` 2019-11-13 09:52:58.571 ERROR 97155 --- [           main] o.s.boot.SpringApplication               : Application run failed  java.lang.IllegalArgumentException: No auto-configuration attributes found. Is com.example.demo.DemoApplication annotated with EnableAutoConfiguration? 	at org.springframework.util.Assert.notNull(Assert.java:215) ~[spring-core-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.getAttributes(AutoConfigurationImportSelector.java:148) ~[spring-boot-autoconfigure-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.getAutoConfigurationEntry(AutoConfigurationImportSelector.java:115) ~[spring-boot-autoconfigure-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.autoconfigure.AutoConfigurationImportSelector$AutoConfigurationGroup.process(AutoConfigurationImportSelector.java:396) ~[spring-boot-autoconfigure-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser$DeferredImportSelectorGrouping.getImports(ConfigurationClassParser.java:874) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser$DeferredImportSelectorGroupingHandler.processGroupImports(ConfigurationClassParser.java:801) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser$DeferredImportSelectorHandler.process(ConfigurationClassParser.java:771) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:188) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:325) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:242) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:706) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-5.2.1.RELEASE.jar:5.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) ~[spring-boot-2.2.1.RELEASE.jar:2.2.1.RELEASE] 	at com.example.demo.BaseApplication.start(BaseApplication.java:12) ~[classes/:na] 	at com.example.demo.DemoApplication.main(DemoApplication.java:8) ~[classes/:na] ```  ## Steps to reproduce  - use attached demo project to reproduce the issue [demo.zip](https://github.com/spring-projects/spring-boot/files/3842778/demo.zip) - change spring-boot version to 2.1.8.RELEASE and run app again - everything works as expected","closed","in: core,","amrynsky","2019-11-13T18:22:26Z","2019-12-03T10:37:50Z"
"","23940","Align implementations of StringToUUIDConverter and UUIDEditor","## Overview  `UUIDEditor` checks if the supplied value `hasText`; whereas, `StringToUUIDConverter` checks if the supplied value `hasLength`. Similarly, `StringToUUIDConverter` trims the supplied value, but `UUIDEditor` does not.  ## Deliverables  - [x] Switch to `StringUtils.hasText` in `StringToUUIDConverter` to align with the behavior of `UUIDEditor`. - [x] Use `String#trim()` in `UUIDEditor` to align with the behavior of `StringToUUIDConverter`.","closed","type: enhancement,","sbrannen","2019-11-06T13:02:34Z","2019-11-06T13:24:15Z"
"","23834","Support unidirectional @AliasFor attribute mapping within an annotation","## Original Title  Issue with AliasFor annotation upgrading from 5.1.7 to 5.2.0  ## Overview  I'm trying to update Spring Boot version from 2.1.5.REALEASE to 2.2.0.RELEASE and by that, my Spring Framework are getting updated.  After the update my application stop working and passing tests. The reason is because I use a library that specify a `@AliasFor` only on the `value` field and not on both attributes. Look at the code:  ```java @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface EndpointCacheable {   @AliasFor(""prefixKey"")   String value() default """";    String prefixKey() default """"; } ```  The `@AliasFor` documentation says since older versions that is needed to specify the annotation on both attributes that are alias of each other, but no error was thrown in older versions.  The stack trace:  ``` Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'prefixKey' in annotation [br.com.stilingue.utilities.cache.annotation.EndpointCacheable] must be declared as an @AliasFor 'value'. 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:183) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:134) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:126) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:103) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:109) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:68) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:61) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:217) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[?:?] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:213) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:181) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:168) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.TypeMappedAnnotation.of(TypeMappedAnnotation.java:632) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.annotation.MergedAnnotation.of(MergedAnnotation.java:593) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.type.classreading.MergedAnnotationReadingVisitor.visitEnd(MergedAnnotationReadingVisitor.java:96) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.asm.ClassReader.readElementValues(ClassReader.java:2775) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.asm.ClassReader.readMethod(ClassReader.java:1183) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.asm.ClassReader.accept(ClassReader.java:688) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.asm.ClassReader.accept(ClassReader.java:400) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:50) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:123) ~[spring-core-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:430) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:316) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:276) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ComponentScanAnnotationParser.parse(ComponentScanAnnotationParser.java:132) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:290) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:202) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:170) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:325) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:242) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:706) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) ~[spring-boot-2.2.0.RELEASE.jar:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.2.0.RELEASE.jar:2.2.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.2.0.RELEASE.jar:2.2.0.RELEASE] 	at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:125) ~[spring-boot-test-2.2.0.RELEASE.jar:2.2.0.RELEASE] 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) ~[spring-test-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) ~[spring-test-5.2.0.RELEASE.jar:5.2.0.RELEASE] 	... 47 more ```  There is an issue or is expected?   Maybe this will break other libs with alias only in one attribute (I know this a library bug, but no error was thrown before).  Thank you.","closed","type: enhancement,","lucasoares","2019-10-18T20:14:36Z","2019-10-31T11:06:57Z"
"","24268","Multiple Java Bean copy","## Description  As per the issue #24267 the `copyProperties` method in the BeanUtils class has been overloaded in order to make it able to copy any kind of Java Bean: Mutable, Immutable, Mixed.  Fixes #24267   ## How Has This Been Tested?  - [X] A Mutable Java Bean is successfully transformed - [X] An Immutable Java Beans is successfully transformed - [X] A Java Beans is successfully transformed with a given BeanTransformer - [X] The introduced changes have no impact on the existing code","closed","type: enhancement,","fborriello","2019-12-26T11:32:29Z","2020-01-06T13:43:09Z"
"","24049","UriComponentsBuilder should support repeated request parameters","## Background context  I have an endpoint for multi get requests:  ```java // GET /resources?id=1&id=2 @GetMapping Resources getMultipleResources(@RequestParam(""id"") Set ids)  ``` which returns a json:  ```javascript {     ""resources"": [         {             ""id"": ""1""              ...         },         {             ""id"": ""2""              ...         },         ...     ] } ```  When I do http requests with `RestTemplate` I build URI using `UriComponentsBuilder`.  But this builder has no convenient method to build URI with repeated query parameters. I have to modify the builder in `for` loop.  ```java final UriComponentsBuilder uriBuilder = UriComponentsBuilder                 .fromUriString(""http://localhost:8080"")                 .path(""resources""); for (String id: ids) {        uriBuilder.queryParam(""id"", id); } final URI uri = uriBuilder.build().toUri(); ```  ## Purpose  I would like to have a method dedicated for such case, e.g.   ```java public UriComponentsBuilder queryParam queryParamRepeated(String param, Collection values) ```  Then a usage of such method could look like this:  ```java final Uri uri = UriComponentsBuilder                 .fromUriString(""http://localhost:8080"")                 .path(""resources"")                 .queryParamRepeated(""id"", ids)                 .build()                 .toUri(); ```  If you think it would be valuable then I will prepare pull request.","closed","type: enhancement,","jewertow","2019-11-21T07:17:15Z","2019-12-09T11:08:21Z"
"","24787","webClient build url wrong when using UriBuilder [probably a bug]","## affects ``` path = ""http://a.b/c""; webClient = WebClient.builder().build(); webClient.get()         .uri(uriBuilder -> uriBuilder.path(path).queryParams(myMutliValuedMapParams).build()); ``` uri becomes: ""http:/a.b/c"", the double slash after schema becomes a single slash. And results in an  `java.net.UnknownHostException: http:` But `webClient.get().uri(path);` does not have the same problem. ## possible reason `UriComponentsBuilder.java`  buildInternal function causes the problem. the var `uric` is wrong. ```  private UriComponents buildInternal(EncodingHint hint) { 		UriComponents result; 		if (this.ssp != null) { 			result = new OpaqueUriComponents(this.scheme, this.ssp, this.fragment); 		} 		else { // The PROBLEM:  			HierarchicalUriComponents uric = new HierarchicalUriComponents(this.scheme, this.fragment, 					this.userInfo, this.host, this.port, this.pathBuilder.build(), this.queryParams, 					hint == EncodingHint.FULLY_ENCODED);   			result = hint == EncodingHint.ENCODE_TEMPLATE ? uric.encodeTemplate(this.charset) : uric; 		} 		if (!this.uriVariables.isEmpty()) { 			result = result.expand(name -> this.uriVariables.getOrDefault(name, UriTemplateVariables.SKIP_VALUE)); 		} 		return result; 	} ``` ## version spring-web-5.1.8.RELEASE","closed","status: invalid,","Jovons","2020-03-26T09:57:50Z","2022-01-27T15:13:15Z"
"","24370","Improve default experience of data binding from HTML date and time input fields","# tl;dr  The default Spring MVC date/time form binding is slightly at odds with the way modern date and time form input fields are submitted by browsers. This results in the need for (quite a bit of) explicit binding configuration to make default form submissions from browsers work.  # Details  The current Spring MVC way of binding of date value stems from the time when date and time values were handled through simple `` elements. When working with those, form values were usually rendered in the format that's matching the user's browser's locale. On form submissions Spring MVC would then consider the `Locale` provided (usually in an HTTP header sent by the browser or a value otherwise obtained from the request) when parsing the value provided.  The form elements of type [`date`](https://www.w3.org/TR/html52/sec-forms.html#date-state-typedate) and [`time`](https://www.w3.org/TR/html52/sec-forms.html#time-state-typetime) have been specified to contain values that roughly match the ISO formats for dates and times. That means that when using those explicit types, the browser now sends an ISO format but still a browser specific locale. Depending on the actual locale, this might cause the binding to fail, depending on whether the format backing the locale is compatible with the ISO format.  Assume a form backing object like this  ```java class Form {   LocalDate date;   LocalTime time; } ```  E.g. a browser submission with German locale with a date of `2019-01-15` and time of `20:15` would fail for the date binding, as the German flavor is `15.01.2019` but binding the time would  succeed as by accident the German format parses ISO times properly.  # Solutions / Workarounds  ## Annotating the form backing object  A very obvious way of fixing this is annotating all relevant form object fields with `@DateTimeFormat(iso = …)`. While this works, it's a bit tedious one you have many of these types. Also, it's a bit surprising that the default configuration is not able to bind the standard values produced by the browser in the first place. On the other hand, Spring MVC cannot actually know whether the value it's supposed to bind is coming from a text field or a date specific one, especially considering the large amounts of existing applications.  ## Define ISO formats to be used for all date types globally  Using Spring MVC's `WebMvcConfigurer` one can tweak the form binding to globally use ISO formats like this:  ```java @Bean WebMvcConfigurer isoDatesByDefault() {   return new WebMvcConfigurer() {     public void addFormatters(FormatterRegistry registry) {       DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();       registrar.setUseIsoFormat(true);       registrar.registerFormatters(registry);     }   } } ```  This has the advantage of avoiding the need for additional annotations on form backing objects. It of course breaks the date submission in any other formats (e.g. from plain text input fields using a format other than ISO).  # Questions / Remarks  The Spring [reference documentation](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#format-configuring-formatting-globaldatetimeformat) seems a bit dated as it discusses the form binding of dates from the legacy `Date` point of view. Also, declaring a custom `FormattingConversionService` is not really idiomatic in a Spring Boot context in which you'd rather declare a `WebMvcConfigurer` to tweak the service.  I was wondering whether it might makes sense to let Boot expose a property to enable the configuration tweaks shown above to simplify switching to the ISO format in general. There's precedence in ISO date specific configuration in the Jackson space.","closed","in: web,","odrotbohm","2020-01-15T19:31:24Z","2020-02-24T19:05:37Z"
"","23936","Use ""non-blocking"" thread for server-less tests in WebTestClient","# Problem [As was reported on Gitter](https://gitter.im/reactor/BlockHound?at=5db0e42010bd4128a14d7f25), `WebTestClient` uses the same thread to execute the controller's methods. In case of Webflux, it means that Reactor's built-in blocking call detection (e.g. calling `mono.block()`) or more advanced checks like [BlockHound](http://github.com/reactor/BlockHound) will not detect anything, since the thread is not non-blocking.  Since it creates a false positive feeling that the app does not have blocking calls, it would be better if `WebTestClient` with Webflux would mimic the non-blocking nature of the Webflux calls and move the subscription to e.g. `Schedulers.parallel()`  # Workaround It is possible to customize the `WebTestClient` and manually move the subscription to the parallel scheduler: ```java @Component public class WebTestClientConfig implements WebTestClientBuilderCustomizer {      @Override     public void customize(WebTestClient.Builder builder) {         builder.filter((clientRequest, next) ->             next.exchange(clientRequest).subscribeOn(Schedulers.parallel())         );     } } ```","closed","type: enhancement,","bsideup","2019-11-05T11:18:01Z","2021-01-20T17:07:41Z"
"","23849","webflux find a bug","![image](https://user-images.githubusercontent.com/13191643/67351504-4001f580-f580-11e9-80c8-1b97a9236b40.png)","closed","status: invalid,","liucyu","2019-10-23T02:30:07Z","2019-10-25T02:46:52Z"
"","24834","Fixes typo in annotation name","","closed","status: declined,","danieldietrich","2020-04-01T13:23:00Z","2020-04-01T13:55:30Z"
"","24790","Remove useless .gitignore files","","closed","type: task,","chenqimiao","2020-03-26T13:32:51Z","2020-03-27T02:17:02Z"
"","24789","Remove obsolete comment in BeanDefinitionParserDelegate","","closed","in: core,","chenqimiao","2020-03-26T12:11:52Z","2020-03-26T15:04:08Z"
"","24726","Upgrade to Reactor Californium SR17","","closed","type: task,","rstoyanchev","2020-03-18T17:10:38Z","2020-04-28T08:17:24Z"
"","24725","Upgrade to Reactor Dysprosium SR6","","closed","type: dependency-upgrade,","rstoyanchev","2020-03-18T17:09:44Z","2020-03-23T17:38:18Z"
"","24697","Fix typo in buildSrc/README.md","","closed","type: task,","chenqimiao","2020-03-14T03:46:31Z","2020-03-14T10:58:43Z"
"","24676","Fix typo in Enhancer","","closed","","chenqimiao","2020-03-11T01:50:39Z","2020-03-13T08:56:34Z"
"","24667","Add logger.isInfoEnabled check before logger.info","","closed","in: core,","chenqimiao","2020-03-10T06:09:49Z","2020-03-10T15:15:42Z"
"","24650","Update IntroductionInfo example in reference manual","","closed","type: task,","chenqimiao","2020-03-06T01:42:39Z","2020-03-06T14:46:40Z"
"","24623","Fix typos in AbstractClientHttpRequest","","closed","type: task,","codefromthecrypt","2020-03-02T03:24:17Z","2020-03-03T16:06:20Z"
"","24613","Fix typo in WebClient.Builder Javadoc","","closed","type: task,","chenqimiao","2020-02-28T16:29:46Z","2020-02-28T17:41:33Z"
"","24604","Update README.md","","closed","","cxyxd","2020-02-27T15:04:27Z","2020-02-27T15:06:40Z"
"","24597","Fix typo in reference manual","","closed","type: documentation,","wonwoo","2020-02-26T09:31:59Z","2020-02-26T13:34:36Z"
"","24578","Fix formatting in webflux-webclient.adoc","","closed","type: documentation,","chenqimiao","2020-02-24T07:41:42Z","2020-04-15T07:45:38Z"
"","24575","Document enhancement in core-beans.adoc","","closed","","chenqimiao","2020-02-23T14:37:58Z","2020-02-24T20:50:31Z"
"","24574","#23262 remove obsolete documentation of ""autowire"" property for @Bean","","closed","status: invalid,","mikesmithson","2020-02-23T14:33:29Z","2020-02-24T14:07:18Z"
"","24566","Fix typos in tests","","closed","type: task,","chenqimiao","2020-02-22T06:36:35Z","2020-02-22T17:32:12Z"
"","24543","Polishing","","closed","type: task,","zhangt2333","2020-02-17T15:43:26Z","2020-02-17T16:33:48Z"
"","24528","Placeholder for ReactorClientHttpRequest refactoring","","closed","status: invalid,","rstoyanchev","2020-02-14T21:32:59Z","2020-02-24T11:56:00Z"
"","24527","Upgrade to Reactor Californium SR16","","closed","type: dependency-upgrade,","rstoyanchev","2020-02-14T21:29:49Z","2020-02-24T14:58:28Z"
"","24495","Reuse CommonsLogWriter write() method to reduce duplication","","closed","in: core,","hyeonisism","2020-02-09T15:06:29Z","2020-02-17T16:54:14Z"
"","24483","分支1","","closed","status: invalid,","junxi568","2020-02-06T05:59:51Z","2020-02-06T08:04:31Z"
"","24476","Produce less String-related garbage when generating bean names","","closed","type: task,","stsypanov","2020-02-04T09:44:03Z","2020-02-25T14:02:04Z"
"","24447","Some trivial improvements to reduce allocation pressure","","closed","in: core,","stsypanov","2020-01-28T09:49:50Z","2020-01-28T10:31:04Z"
"","24390","1111","","closed","status: invalid,","liudebin","2020-01-17T15:49:24Z","2020-01-17T15:57:39Z"
"","24349","Upgrade to Reactor Dysprosium SR3","","closed","type: dependency-upgrade,","rstoyanchev","2020-01-13T16:48:32Z","2020-01-13T19:25:49Z"
"","24345","Upgrade to Californium SR15","","closed","type: task,","rstoyanchev","2020-01-13T15:38:23Z","2020-01-13T17:12:17Z"
"","24311","Add StringToPatternConverter","","open","status: feedback-provided,","valfirst","2020-01-07T14:11:25Z","2022-06-08T14:32:42Z"
"","24299","Upgrade to JUnit Jupiter 5.6","","closed","type: dependency-upgrade,","sbrannen","2020-01-06T11:10:33Z","2020-02-13T14:45:51Z"
"","24298","Upgrade to TestNG 7.1.0","","closed","type: dependency-upgrade,","sbrannen","2020-01-06T11:09:54Z","2020-04-28T10:13:50Z"
"","24245","Fix example in RSocket docs","","closed","type: documentation,","fjacobs","2019-12-21T21:19:56Z","2019-12-22T15:49:04Z"
"","24244","Fix example in RSocket docs","","closed","status: duplicate,","fjacobs","2019-12-21T21:01:26Z","2019-12-22T07:31:31Z"
"","24219","try fix #23791","","closed","status: declined,","zhou-hao","2019-12-17T01:57:11Z","2019-12-20T11:23:49Z"
"","24208","designator @annotation's @annotation(java.lang.Override) doesn't work","","open","in: core,","XSun771","2019-12-14T06:24:29Z","2021-11-11T10:12:43Z"
"","24158","read191207","","closed","status: invalid,","sunguagua","2019-12-07T07:49:10Z","2019-12-07T08:10:26Z"
"","24155","Add missing backtick in WebSocket documentation","","closed","type: task,","erichelgeson","2019-12-06T17:34:44Z","2019-12-06T19:02:38Z"
"","24121","merge","","closed","","august0228","2019-12-03T05:13:20Z","2022-02-18T19:07:21Z"
"","24090","commit initbean;","","closed","","abelzha","2019-11-27T08:08:54Z","2019-11-27T08:21:15Z"
"","24038","Upgrade to Reactor Californium-SR14","","closed","type: dependency-upgrade,","snicoll","2019-11-20T09:47:06Z","2019-11-27T10:52:17Z"
"","24037","Upgrade to Reactor Dysprosium-SR2","","closed","type: dependency-upgrade,","snicoll","2019-11-20T09:44:36Z","2019-11-27T10:53:22Z"
"","24008","Fix errors in documentation","","closed","type: documentation,","denisgalaybo","2019-11-15T16:37:33Z","2019-11-18T11:51:30Z"
"","23950","fix issue #23939","","closed","status: declined,","papurla","2019-11-07T16:49:44Z","2019-11-12T10:44:32Z"
"","23921","Update WebMvcConfigurer#addInterceptors javadoc for resource requests #23908","","closed","","samarthrastogi","2019-11-04T12:06:50Z","2022-02-18T19:07:16Z"
"","23916","Minor formatting","","closed","type: task,","wonwoo","2019-11-04T03:56:20Z","2019-11-19T15:21:34Z"
"","23906","Fix links in WebFlux.fn and WebMvc.fn docs","","closed","status: invalid,","aosagie","2019-11-01T04:39:50Z","2019-11-01T11:54:21Z"
"","23902","Update README.md","","closed","status: declined,","MORRIS1805","2019-10-31T15:49:07Z","2019-10-31T15:57:10Z"
"","23871","Upgrade to Reactor Dysprosium-SR1","","closed","type: dependency-upgrade,","snicoll","2019-10-25T06:31:28Z","2019-10-28T13:34:17Z"
"","23870","Upgrade to Reactor Californium-SR13","","closed","type: dependency-upgrade,","snicoll","2019-10-25T06:30:45Z","2019-10-28T13:30:57Z"
"","23864","TransactionalOperator::transactional does not close the transaction when cancelled","","closed","type: bug,","killaitis","2019-10-24T16:50:55Z","2019-10-25T12:48:47Z"
"","23862","update","","closed","","zhaoxc-git","2019-10-24T14:06:59Z","2022-02-18T19:07:17Z"