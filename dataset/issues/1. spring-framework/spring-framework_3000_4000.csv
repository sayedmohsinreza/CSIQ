"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","25719","Source code build error","构建环境: idea 2020 ,gradle 6.6 ,jdk 11 问题: unable to find valid certification path to requested target 过程: 试过很多种方法，问题一直没有解决（jdk从8升级到11，gradle从5.6.4升级到6.6，也向jdk中导入过ssl证书，一直无法解决） idea构建异常信息:  Could not resolve me.champeau.gradle:japicmp-gradle-plugin:0.2.8.      Required by:          project :buildSrc       > Could not resolve me.champeau.gradle:japicmp-gradle-plugin:0.2.8.          > Could not get resource 'https://plugins.gradle.org/m2/me/champeau/gradle/japicmp-gradle-plugin/0.2.8/japicmp-gradle-plugin-0.2.8.pom'.             > Could not GET 'https://plugins.gradle.org/m2/me/champeau/gradle/japicmp-gradle-plugin/0.2.8/japicmp-gradle-plugin-0.2.8.pom'.                > PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target       > Could not resolve me.champeau.gradle:japicmp-gradle-plugin:0.2.8.          > Could not get resource 'https://repo.maven.apache.org/maven2/me/champeau/gradle/japicmp-gradle-plugin/0.2.8/japicmp-gradle-plugin-0.2.8.pom'.             > Could not GET 'https://repo.maven.apache.org/maven2/me/champeau/gradle/japicmp-gradle-plugin/0.2.8/japicmp-gradle-plugin-0.2.8.pom'.                > PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target  cmd构建异常信息: Downloading https://services.gradle.org/distributions/gradle-5.6.4-bin.zip  Exception in thread ""main"" javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target","closed","status: invalid,","wangke6194","2020-09-07T09:23:36Z","2022-06-19T08:10:49Z"
"","24836","更新数据","更新数据","closed","status: invalid,","liweifan0616","2020-04-01T14:12:06Z","2020-04-01T14:27:47Z"
"","25598","2020_8_17_spring_framework_study","基于spring5.0，系统学习spring framework.","closed","status: invalid,","lengweijian","2020-08-17T02:56:26Z","2020-08-17T07:51:33Z"
"","25215","Merge pull request #1 from spring-projects/master","合并spring官方代码","closed","status: invalid,","chengwenyue","2020-06-09T14:26:50Z","2020-06-09T14:28:53Z"
"","25569","removed unused opiton from CompilerConvention","ㅇㅁㄻㄴㅇㄹㅇㅁㄴㄹ","closed","","hyeyoom","2020-08-09T06:52:28Z","2020-08-09T06:53:03Z"
"","25661","Fixed the wrong execution order of the methods annotated by @AfterRet…","…urning and @After in the AOP annotation implementation.","closed","in: core,","Dafengsu","2020-08-29T11:46:05Z","2020-08-31T05:14:13Z"
"","25556","Let the DataSize.toString method returns the closest unit to represen…","…t the data size  So I know I configured the max upload file size is `4MB`, not `4194304B` when I print the log message.","closed","in: core,","ijliym","2020-08-07T03:04:43Z","2021-12-10T23:04:40Z"
"","25114","Provide Go-style interface and implement independent type conversion …","…strategy, for bean injection in different type.","closed","status: declined,","cshijiel","2020-05-21T12:34:08Z","2020-06-23T08:05:24Z"
"","25662","XStreamMarshaller should avoid direct use of CompositeClassLoader which is not exported by XStream in OSGi","XStreamMarshaller uses the class `CompositeClassLoader` [here](https://github.com/spring-projects/spring-framework/blob/v5.2.8.RELEASE/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java#L189), but it is not part of the public API. xstream is an OSGi bundle and does not export the package `com.thoughtworks.xstream.core.util`. This results in a ClassNotFoundException when using Spring oxm + xstream in an OSGi environment since that package is not exported.  I've asked explicitly [here](https://github.com/x-stream/xstream/issues/219) about this. Could Spring oxm use the same classloader which loaded the xstream classes (`XStream.class.getClassLoader()`) to lookup the CompositeClassLoader and create a new instance to avoid this issue?","closed","type: enhancement,","aclemons","2020-08-30T03:53:05Z","2020-08-30T10:30:51Z"
"","24940","xml and javaConfig are used in the same interceptor, javaConfig didn't work on swagger /v2/api-doc","xml与javaConfig 配置同一个拦截器 ，javaConfig 对 swagger /v2/api-doc 不生效  javaConfig  ```java     @Bean     public SignValidInterceptor logInterceptor() {         SignValidInterceptor signValidInterceptor = new SignValidInterceptor();         signValidInterceptor.excludePathPattern(""GET"", ""/swagger/**"");         //        .excludePathPattern(""GET"", ""/"");         return signValidInterceptor;     }     @Override     public void addInterceptors(InterceptorRegistry registry) {         registry.addInterceptor(logInterceptor())                 //.excludePathPatterns(""/swagger/**"")                 .addPathPatterns(""/**"");     } ```      xml  ```xml                                                                    ```  https://github.com/spring-projects/spring-framework/blob/376434eb7545c39dcc7f8f87a28eeb9f26bbfd6e/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/InterceptorRegistration.java#L130  您好，我在使用 `javaConfig `配置拦截器时，发现其对`swagger`接口不生效。 debug代码时，发现`InterceptorRegistration `将`HandlerInterceptor` 包装 `MappedInterceptor `时 没有把 `MappedInterceptor `实例放入容器。  以至于在 `org.springframework.web.servlet.handler.AbstractHandlerMapping.detectMappedInterceptors` 中 找不到 `MappedInterceptor`的实例，  `org.springframework.web.servlet.handler.AbstractHandlerMapping#initApplicationContext`  故而不能为`PropertySourcedRequestMappingHandlerMapping` 添加 `adaptedInterceptors`， 使得拦截器不拦截`PropertySourcedRequestMappingHandlerMapping` 类型的接口，例如`Swagger`的 `/v2/api-docs` 接口。  ```	java 	mappedInterceptors.addAll( 				BeanFactoryUtils.beansOfTypeIncludingAncestors( 						obtainApplicationContext(), MappedInterceptor.class, true, false).values()); 	} ```","closed","status: invalid,","minggen","2020-04-20T08:46:59Z","2021-02-02T16:02:10Z"
"","25080","Avoid unnecessary boxing/unboxing of primitives","Wrapping primitives is pointless for the cases primitive can be used (e.g. in concatenation of arithmetics).","closed","type: task,","stsypanov","2020-05-14T14:14:41Z","2020-05-15T17:09:54Z"
"","25098","BeanDefinitionDsl: get environment property in a nice way","With this PR I'd like to open a discussion about a way to easily access Environment properties in `BeanDefinitionDsl`.","closed","status: declined,","krzykrucz","2020-05-18T18:34:36Z","2020-09-25T13:43:18Z"
"","25322","MappingJackson2HttpMessageConverter might be too specific in its Charset support","With this https://github.com/spring-projects/spring-framework/commit/eb0aae066c83ae0b7be280bd5c9e0679ed394a92#diff-ea14ba194c2adb7f8aa7f97a2ca5bcc7, spring web Jackson2 Converter introduced an enum set limiting UTF options. In a testing scenario we use ""US-ASCII"" which was working until now. Since 5.2.7, the controller will rejects requests, failing to decode. Is that the intended behavior or should `ENCODINGS` map include US-ASCII as well ?","closed","status: feedback-provided,","smaldini","2020-06-26T23:29:42Z","2020-07-06T16:51:18Z"
"","25305","Use JDBC 4 API for connection validation","With this commit use the JDBC 4.0 isValid method to validate the connection. This is favorable over a validation query.","closed","type: enhancement,","mdeinum","2020-06-23T12:27:51Z","2020-06-23T17:33:29Z"
"","25310","Determine why transferTo tests fail for Undertow","With the introduction of the `DefaultMultipartParser`, two tests started failing when running against Undertow:  1. `org.springframework.web.reactive.function.MultipartIntegrationTests#transferTo` and 2. `org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests#transferTo`.  As temporary workaround the tests were disabled for 5.3 M1, but this needs to be resolved by M2.","open","in: web,","poutsma","2020-06-24T08:15:54Z","2020-10-26T09:03:52Z"
"","25257","Make DispatcherServlet.properties loading lazy","With #25209, `DispatcherServlet.properties` loading and parsing will be useless for most of use cases, and it requires configuration on GraalVM native images.  The purpose of this issue to make such loading and parsing lazy, only invoked in `getDefaultStrategies()` if needed.","closed","type: enhancement,","sdeleuze","2020-06-16T13:54:42Z","2020-07-27T10:24:36Z"
"","25516","Support filename hint for client side use of ResourceDecoder","With #22267 the `ResourceDecoder` was extended to support a filename hint that allows setting the filename of the `Resource`. However, this does not work correctly with using the Spring WebClient.  e.g.  ``` ResponseEntity response = webClient.get(""/some-resource)     .flatMap(response -> response.toEntity(ByteArrayResource.class))     .block(); ```  The resource returned by this response will have `null` when invoking `getFileName()`.  The reason for that is the following:  When invoking `response.ToEntity(ByteArrayResource.class)`. We will reach:  https://github.com/spring-projects/spring-framework/blob/87c3bb579739aa4892f3b647f8eef7e2dc16a7f5/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java#L83-L89  Which calls `readToMono`:  https://github.com/spring-projects/spring-framework/blob/87c3bb579739aa4892f3b647f8eef7e2dc16a7f5/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java#L206-L211  There are now 2 possibilities for invoking the reader:  1. `reader.readMono(type, type, (ServerHttpRequest) message, response, context.hints())` - When the `BodyExtractor.Context#serverResponse` is not empty, which is the case when using `ServerRequest`. This case is correct. 2. `reader.readMono(type, message, context.hints())` - When the `BodyExtractor.Context#serverResponse` is empty which is the case for a `ClientResponse`  Since we are using `WebClient` we will skip the analysis for 1. And go to 2.  The `serverResponse` on the extractor is set to empty here:  https://github.com/spring-projects/spring-framework/blob/72895f081026df7e0b34807729d9cdea6c7ff4ec/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultClientResponse.java#L82-L97   When we look into the implementation of `reader.readMono(type, message, context.hints())`. More precisely the implementation of https://github.com/spring-projects/spring-framework/blob/72895f081026df7e0b34807729d9cdea6c7ff4ec/spring-web/src/main/java/org/springframework/http/codec/HttpMessageReader.java#L76  In `DecoderHttpMessageReader`: https://github.com/spring-projects/spring-framework/blob/dbec16d566ed7ac8a946e0d832d2a52d2d559f91/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java#L102-L106  We can see that the hints are passed as is without creating new hints based on the message.  The fix would be to also get new hints from `ReactiveHttpInputMessage` when reading a flux or mono without a `ServerHttpResponse`.  More precisely in this location:  https://github.com/spring-projects/spring-framework/blob/dbec16d566ed7ac8a946e0d832d2a52d2d559f91/spring-web/src/main/java/org/springframework/http/codec/DecoderHttpMessageReader.java#L96-L106  This can be done only for the `ResourceHttpMessageReader` and not for `DecoderHttpMessageReader`     Reproducable Test case    ``` /**  * Unit tests for {@link ResourceHttpMessageReader}.  *  * @author Filip Hrisafov  */ public class ResourceHttpMessageReaderTests extends AbstractLeakCheckingTests {  	private final ResourceHttpMessageReader reader = new ResourceHttpMessageReader();  	@Test 	void readResourceAsMono() throws IOException { 		String body = ""Test resource content""; 		MockServerHttpRequest request = request(body, ""test.txt""); 		Resource result = this.reader.readMono(ResolvableType.forClass(ByteArrayResource.class), request, null) 				.single() 				.block();  		assertThat(result).isNotNull(); 		assertThat(result.getFilename()).isEqualTo(""test.txt""); 		try (InputStream stream = result.getInputStream()) { 			assertThat(stream).hasContent(body); 		} 	}  	private MockServerHttpRequest request(String body, String filename) { 		return request(Mono.just(stringBuffer(body)), filename); 	}  	private MockServerHttpRequest request(Publisher","closed","type: enhancement,","filiphr","2020-08-03T15:40:53Z","2020-08-14T15:47:58Z"
"","24985","SpringFactoriesLoader should filter out duplicates","Whilst doing some testing that caused duplicate `META-INF/spring.factories` files on the classpath it became apparent that the Spring loading wasn't filtering out duplicates.  There are some pieces of code (for example in Spring Data) that were checking 'how many implementations are there' to determine whether to switch to a multi-provider handler or not. In those cases the code was discovering there were two implementations but in fact they were the same thing (exact same name).","closed","type: enhancement,","aclement","2020-04-27T17:23:09Z","2020-04-28T14:48:21Z"
"","24848","JdbcTemplate setFetchSize requires autocommit false on Postgres","While you can easily set the fetch size with `JdbcTemplate.setFetchSize(1000);`, on Postgres [one of the requirements](https://stackoverflow.com/questions/1468036/java-jdbc-ignores-setfetchsize) for it to actually take effect is for the connection to be in `autocommit=false` mode.  Even if you're aware of that fact, it can be convoluted to achieve that by the time you're using the template. Resorting to changing the default autocommit mode, wrapping the pool or [something else](https://stackoverflow.com/questions/25197774/how-to-set-autocommit-to-false-in-spring-jdbc-template).  I realize this is more complicated than for example MySQL's [streaming issue](https://github.com/spring-projects/spring-framework/issues/18600). Having `JdbcTemplate` itself change the autocommit mode automatically when fetchsize is issued for Postgres would be too database specific, and not really its job. Maybe a method for overriding autocommit mode when `JdbcTemplate` fetches a connection? I understand this is also a driver issue, and workarounds are available. However it can be confusing when the fetch size is ignored completely and it can force you to resort to the clumsier JDBC API.","open","in: data,","jussimarttila","2020-04-02T11:14:33Z","2021-11-10T11:38:08Z"
"","25303","MediaType Resolver in handlers to get at encodings/charsets from Accept Header","While this is an old issue(closed PR here https://github.com/spring-projects/spring-framework/pull/232#issuecomment-648104570 ), I think it is a genuine usecase and a viable alternative to the Variant mechanism (request.getVariant() call )  that can be found in Jersey implementations.  I am migrating an application from Jersey to Spring MVC and I stumbled upon this. For the language part in the Variant implementation, the LocaleResolver was a good alternative.   For the  other 2 dimensions of MediaType and encoding that is found in the Jersey implementation, this seems a good fit.   In my case I want to write to a StreamingResponseBody and the old implementation was using Variants to determine encoding. The encoding was specified in the the accept header in the request (MediaType/MimeType) and the parameter portion of the MediaType contained the charset. Using the resolver in the PR I can get the encoding here, where I need to know it beforehand so that I can specify the correct encoding that the client expects and specified in the request header, to write with in my OutputStream/Writer.  In my case I am using text/plain and the client can ask me various encoding in order of his preference and I can accomadate it in my Response.   Does that make sense for you guys.   I think this resolver belongs in Spring by default.  _Originally posted by @ahsanfz in https://github.com/spring-projects/spring-framework/pull/232#issuecomment-648104570_","open","in: web,","ahsanfz","2020-06-23T12:11:31Z","2021-11-10T12:31:07Z"
"","25439","Document that @Transactional does not propagate to new threads","When you make a new thread in the method enclosed by `@Transactional`, transaction does not propagate to the new thread.   For example, in the below case, write1 will rollback but write2 won't. ```java @Transactional public void methodA() {   write1();   CompletableFuture.runAsync(() -> write2(), Executors.newSingleThreadExecutor());   if (true) {     throw new RuntimeException();   } } ```  We need to make clear whether this is the specification or the bug.  Reference: [Spring Transaction Management Over Multiple Threads](https://dzone.com/articles/spring-transaction-management-over-multiple-thread-1)","closed","type: documentation,","kanjih","2020-07-21T05:52:54Z","2022-01-24T16:05:12Z"
"","25393","Add listOf(), setOf(), and mapOf() methods to TypeDescriptor","When we need to pass a type descriptor of a list into converter we should write ``` TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(MyDto.class)) ``` `List` class is used a lot so it will helpful to have a method ``` TypeDescriptor.listOf(ListingDetailedDto.class) ``` which will return same result","open","type: enhancement,","raderio","2020-07-15T14:56:57Z","2020-08-14T15:32:38Z"
"","25027","Skip null values for primitive target properties in BeanUtils.copyProperties","when we copy some property ,for example :   ```java private Integer status;//source   private int status;//target ```  if the source property is null, then throw new FatalBeanException( 									""Could not copy property '"" + targetPd.getName() + ""' from source to target"", ex);  to fix it , maybe need to skip the null value","closed","type: enhancement,","importsource","2020-05-07T10:24:32Z","2022-02-18T19:06:49Z"
"","25025","skip the null value copies","when we copy some property ,for example :   ```java private Integer status;//source   private int status;//target ```  if the source property is null, then throw new FatalBeanException( 									""Could not copy property '"" + targetPd.getName() + ""' from source to target"", ex);  to fix it , maybe need to skip the null value","closed","","importsource","2020-05-07T10:04:06Z","2022-02-18T19:06:49Z"
"","24935","Remove potentially confusing kotlin-reflect related log message","When using Spring Boot 2.2.6.RELEASE in Java, and I add a dependency that is written in Kotlin, Spring mentions   > org.springframework.core.KotlinDetector - Kotlin reflection implementation not found at runtime, related features won't be available.  That's fine, the dependency doesn't use Kotlin reflection. What makes me concerned is that, after quickly looking around in the code it seems that Spring would change its behavior to use Kotlin internally if I were to add kotlin-reflect to the classpath.   This means that, if a dependency written in Kotlin, that also has kotlin-reflect, Spring will alter its behavior?  I don't know if this poses a problem but it feels wrong and there doesn't seem to be a way to prevent Spring from using Kotlin even if it's on the classpath.  Also, the message cannot be hidden unless I overwrite the logger configuration outside of Spring. I want to make the warning go away and I don't want to alter my logger configuration outside of Spring. Alternatively I could add kotlin-reflect to make the warning go away, but then I'm wondering what is happening under the hood if all Kotlin requirements are met.  So I suggest some kind of mechanism to completely prevent using Kotlin as well as any warnings about it if not desired.  Please let me know if this is a non-issue!","closed","in: core,","brentco","2020-04-19T13:50:32Z","2020-04-20T09:02:36Z"
"","25116","spring-context-indexer does not produce spring.components with Kotlin","When using Kotlin /BOOT-INF/classes/META-INF/spring.components is not generated when annotationProcessor context-indexer is used.  Just create Kotlin/Gradle demo project using https://start.spring.io/ and then add annotationProcessor(""org.springframework:spring-context-indexer"") to dependencies { }  After `gradlew build` spring.components does not exist in JAR  But if I create _Java_ project and add annotationProcessor 'org.springframework:spring-context-indexer' then spring.components appears","closed","status: invalid,","jukkasi","2020-05-22T09:37:40Z","2020-05-25T08:35:43Z"
"","25804","Change in behavior of webflux blockOptional() in springboot 2.3.3?","When upgrading a Springboot application using org.springframework.boot:spring-boot-starter-webflux:2.1.10.RELEASE to org.springframework.boot:spring-boot-starter-webflux:2.3.3.RELEASE I have noticed a change in behavior of my code.  ```java Optional customerMappingOptional = webClientCustomerAdapter                 .get()                 .uri(""/api/v1/customers/mapping/{uuid}"", uuid)                 .retrieve()                 .onStatus(HttpStatus.NOT_FOUND::equals, response -> Mono.empty())                 .bodyToMono(CustomerMapping.class)                 .blockOptional(); ```  Using webflux 2.1.10 when the rest call returns a “not found”, the customerMappingOptional becomes an empty Optional. Using webflux 2.3.3 when the rest call returns a “not found”, the customerMappingOptional becomes an Optional with a value: a Customer object where all fields are null values.  I would like to hear the opinion of the Sprint developers on this matter.","closed","","RichardBoersma1970","2020-09-23T07:46:20Z","2020-09-24T11:58:46Z"
"","25010","Spring JDBC throwing Exception using the Snowflake JDBC driver","When trying to insert a record into the Snowflake database using Spring JDBC, I am getting an exception.  The only work around I have is to revert to using _jdbcTemplate.execute_ but I would prefer to use **SimpleJdbcInsert** so I can receive the generated key column for the row inserted.  I filed a ticket with Snowflake support and their engineers have provided analysis that leads them to believe the issue is with the Spring JDBC code.  The code for the insert is immediately below and the Snowflake engineer's analysis follows that.  ----------------------------------------------------------------------------------------------  ``` // the code below does not work private void insertRecord() {         SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(jdbcTemplate)                 .withTableName(""JOE_LOAD_AUDIT"")                 .usingGeneratedKeyColumns(""ROW_ID"");          // Populate the record's fields.         Map parameters = new HashMap();         parameters.put(""FILE_NAME"", ""myfile.csv"");         parameters.put(""FILE_SIZE"", 123);         parameters.put(""STATUS"", ""LOADED"");         parameters.put(""SOURCE_COMPONENT_NAME"", ""snowflake-test"");          // Insert the record and save the surrogate id for the record.         Number id = simpleJdbcInsert.executeAndReturnKey(parameters);          log.info(""Record inserted, id={}"", id.longValue()); } ```  The exception is as follows:  ----------------------------------------------------------------------------------------------  ``` 2020-03-30 12:29:35.831 JPARDIPC snowflake-test ERROR 16588 --- [           main] o.s.boot.SpringApplication              :826 : Application run failed java.lang.IllegalStateException: Failed to execute ApplicationRunner 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:778) 	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:765) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) 	at com.covetrus.test.SnowflakeTestApplication.main(SnowflakeTestApplication.java:42) Caused by: java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.Boolean (java.lang.Integer and java.lang.Boolean are in module java.base of loader 'bootstrap') 	at net.snowflake.client.jdbc.SnowflakeDatabaseMetaDataResultSet.getBoolean(SnowflakeDatabaseMetaDataResultSet.java:345) 	at net.snowflake.client.jdbc.SnowflakeBaseResultSet.getBoolean(SnowflakeBaseResultSet.java:167) 	at org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider.processTableColumns(GenericTableMetaDataProvider.java:414) 	at org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider.locateTableAndProcessMetaData(GenericTableMetaDataProvider.java:346) 	at org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider.initializeWithTableColumnMetaData(GenericTableMetaDataProvider.java:222) 	at org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory.lambda$createMetaDataProvider$0(TableMetaDataProviderFactory.java:80) 	at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:342) 	at org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory.createMetaDataProvider(TableMetaDataProviderFactory.java:52) 	at org.springframework.jdbc.core.metadata.TableMetaDataContext.processMetaData(TableMetaDataContext.java:171) 	at org.springframework.jdbc.core.simple.AbstractJdbcInsert.compileInternal(AbstractJdbcInsert.java:277) 	at org.springframework.jdbc.core.simple.AbstractJdbcInsert.compile(AbstractJdbcInsert.java:261) 	at org.springframework.jdbc.core.simple.AbstractJdbcInsert.checkCompiled(AbstractJdbcInsert.java:309) 	at org.springframework.jdbc.core.simple.AbstractJdbcInsert.doExecuteAndReturnKey(AbstractJdbcInsert.java:368) 	at org.springframework.jdbc.core.simple.SimpleJdbcInsert.executeAndReturnKey(SimpleJdbcInsert.java:127) 	at com.covetrus.test.SnowflakeTestApplication.insertRecord(SnowflakeTestApplication.java:107) 	at com.covetrus.test.SnowflakeTestApplication.run(SnowflakeTestApplication.java:48) 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:775) 	... 5 common frames omitted ``` ----------------------------------------------------------------------------------------------  The Engineering team has completed their investigation on this issue. Please find below details.   They have classified it as a bug within Spring, not the Snowflake JDBC driver.  The Spring application contains a file called **GenericTableMetaDataProvider.class**, which contains the function **processTableColumns**(DatabaseMetaData databaseMetaData, GenericTableMetaDataProvider.TableMetaData tmd). Within this function, there is the statement  `boolean nullable = tableColumns.getBoolean(""NULLABLE"");`  However, the NULLABLE column returns an integer, not a boolean. This can be seen in the documentation of JDBC getColumns() here:  [https://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html#getColumns(java.lang.String,%20java.lang.String,%20java.lang.String,%20java.lang.String)](https://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html#getColumns(java.lang.String,%20java.lang.String,%20java.lang.String,%20java.lang.String))  The Nullable column contains 1 of 3 integer values: ``` /**  * The constant indicating that a  * column does not allow NULL values.  */ int columnNoNulls = 0;  /**  * The constant indicating that a   * column allows NULL values.  */ int columnNullable = 1;  /**  * The constant indicating that the   * nullability of a column's values is unknown.   */ int columnNullableUnknown = 2; ``` So an easy fix on Spring's end to fix this issue would be to change the problem statement from this: `boolean nullable = tableColumns.getBoolean(""NULLABLE"");`  To this:  ``` int nullableInt = tableColumns.getInt(""NULLABLE""); boolean nullable = (nullableInt == 1);  // this works for values of 0 or 1 but they'll have to decide what to do if nullableInt is equal to 2 (unknown)  ``` It is possible for us to make a change to allow integer values to be returned as booleans (0 == false, >=1 == true), but this comes with the caveat that not all values would be returned correctly. For example, in this case, then a value of NullableUnknown would be returned as TRUE and some information would be lost. A better solution would be for Spring to make the change.   Kindly let me know in case of any further question or I can close this.","closed","","joepardi","2020-05-04T14:31:12Z","2022-02-18T19:06:48Z"
"","25250","Cache setup failure does not provide nested cause","When the our spring-framework project is started, we defined multi CacheManager, but not set which is primary, then running the class AbstractApplicationContext.finishBeanFactoryInitialization, there is an IllegalStateException:  ``` No CacheResolver specified, and no unique bean of type CacheManager found. Mark one as primary or declare a specific CacheManager to use. ```  But it not catched, it only catched BeansException, then it will do the finally code, it will lose some key message to help find the issue.  It's hard to find the issue because the exception is not logged. So can spring catch the exception of IllegalStateException or RuntimeException?  _It's solved by setting the primary CacheManager via `@Primary`._  Code:org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization  ```java         @Override 	public void refresh() throws BeansException, IllegalStateException { 		synchronized (this.startupShutdownMonitor) { 			// Prepare this context for refreshing. 			prepareRefresh();  			// Tell the subclass to refresh the internal bean factory. 			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  			// Prepare the bean factory for use in this context. 			prepareBeanFactory(beanFactory);  			try { 				// Allows post-processing of the bean factory in context subclasses. 				postProcessBeanFactory(beanFactory);  				// Invoke factory processors registered as beans in the context. 				invokeBeanFactoryPostProcessors(beanFactory);  				// Register bean processors that intercept bean creation. 				registerBeanPostProcessors(beanFactory);  				// Initialize message source for this context. 				initMessageSource();  				// Initialize event multicaster for this context. 				initApplicationEventMulticaster();  				// Initialize other special beans in specific context subclasses. 				onRefresh();  				// Check for listener beans and register them. 				registerListeners();  				// Instantiate all remaining (non-lazy-init) singletons. 				finishBeanFactoryInitialization(beanFactory);  				// Last step: publish corresponding event. 				finishRefresh(); 			}  			catch (BeansException ex) { 				if (logger.isWarnEnabled()) { 					logger.warn(""Exception encountered during context initialization - "" + 							""cancelling refresh attempt: "" + ex); 				}  				// Destroy already created singletons to avoid dangling resources. 				destroyBeans();  				// Reset 'active' flag. 				cancelRefresh(ex);  				// Propagate exception to caller. 				throw ex; 			}  			finally { 				// Reset common introspection caches in Spring's core, since we 				// might not ever need metadata for singleton beans anymore... 				resetCommonCaches(); 			} 		} 	} ```  There has exception code: org.springframework.cache.interceptor.CacheAspectSupport.afterSingletonsInstantiated:  ```java 	@Override 	public void afterSingletonsInstantiated() { 		if (getCacheResolver() == null) { 			// Lazily initialize cache resolver via default cache manager... 			Assert.state(this.beanFactory != null, ""CacheResolver or BeanFactory must be set on cache aspect""); 			try { 				setCacheManager(this.beanFactory.getBean(CacheManager.class)); 			} 			catch (NoUniqueBeanDefinitionException ex) { 				throw new IllegalStateException(""No CacheResolver specified, and no unique bean of type "" + 						""CacheManager found. Mark one as primary or declare a specific CacheManager to use.""); 			} 			catch (NoSuchBeanDefinitionException ex) { 				throw new IllegalStateException(""No CacheResolver specified, and no bean of type CacheManager found. "" + 						""Register a CacheManager bean or remove the @EnableCaching annotation from your configuration.""); 			} 		} 		this.initialized = true; 	} ```","closed","type: enhancement,","Bluselye","2020-06-15T02:36:24Z","2021-05-28T15:41:02Z"
"","25724","Add annotation judgment in method BeanFactoryUtils#beanNamesForAnnotationIncludingAncestors","When the local BeanFactory and the parent BeanFactory contain local bean of the same name and type, but only the parent BeanFactory contains specified annotations, should the parent Bean be used instead of the local Bean","closed","","xiaobei-ihmhny","2020-09-07T12:25:04Z","2022-02-18T19:06:26Z"
"","25509","Expose protected method to determine charset in AbstractJackson2HttpMessageConverter","When the issue of charset being ignored #25076 was resolved on 5.2.7/5.2.8 the problem now is the opposite. I have lot of clients that are sending ;charset=ISO-8859-1 on their request (for example by using RestTemplate is added by default), and know request and responses in Japanese language are garbled (should be UTF-8)  A simple way to ignore the charset by configuration or at least making some members protected would be nice.  Now the only alternative is to override complete methods    ```java  public class ForcedUTF8MappingJackson2HttpMessageConverter extends MappingJackson2HttpMessageConverter { 	 	public ForcedUTF8MappingJackson2HttpMessageConverter(ObjectMapper objectMapper) { 		super(objectMapper); 	}  	@Override 	public Object read(Type type, @Nullable Class contextClass, HttpInputMessage inputMessage) 			throws IOException, HttpMessageNotReadableException {  		JavaType javaType = getJavaType(type, contextClass); 		return readJavaType(javaType, inputMessage); 	}  	private Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) throws IOException { 		Charset charset = StandardCharsets.UTF_8;  		boolean isUnicode = true; 		try { 			if (inputMessage instanceof MappingJacksonInputMessage) { 				Class deserializationView = ((MappingJacksonInputMessage) inputMessage).getDeserializationView(); 				if (deserializationView != null) { 					ObjectReader objectReader = this.objectMapper.readerWithView(deserializationView).forType(javaType); 					if (isUnicode) { 						return objectReader.readValue(inputMessage.getBody()); 					} 					else { 						Reader reader = new InputStreamReader(inputMessage.getBody(), charset); 						return objectReader.readValue(reader); 					} 				} 			} 			if (isUnicode) { 				return this.objectMapper.readValue(inputMessage.getBody(), javaType); 			} 			else { 				Reader reader = new InputStreamReader(inputMessage.getBody(), charset); 				return this.objectMapper.readValue(reader, javaType); 			} 		} 		catch (InvalidDefinitionException ex) { 			throw new HttpMessageConversionException(""Type definition error: "" + ex.getType(), ex); 		} 		catch (JsonProcessingException ex) { 			throw new HttpMessageNotReadableException(""JSON parse error: "" + ex.getOriginalMessage(), ex, inputMessage); 		} 	}  	@Override 	protected JsonEncoding getJsonEncoding(@Nullable MediaType contentType) { 		return JsonEncoding.UTF8; 	}	  }  ```","closed","type: task,","nikomiranda","2020-08-03T08:04:26Z","2020-09-07T20:43:31Z"
"","25254","Support multi-value X-Forwarded-Prefix headers","When spring-cloud-gateway adds an X-Forward-Prefix header to a request on which an X-Forwarded-Prefix header is already present, the second value is added to the header separating both using comma.  This is currently not supported by the ForwardedHeaderFilter. The Filter prefixes the path with the full value of the Header, adding the commas to the Path. I haven't tested this with Webflux, but looking at ForwardedHeaderTransformer it doesn't seem to support this either.  I first opened this as an issue on the spring-cloud-gateway tracker (https://github.com/spring-cloud/spring-cloud-gateway/issues/1772) after some discussion with @spencergibb we decided to move this over here.","closed","type: enhancement,","hgarus","2020-06-15T20:16:49Z","2020-06-18T11:18:25Z"
"","25092","ModelAndView.status does not work with RedirectView","When setting a redirect view name and a status code to ModelAndView, the status code is ignored.  ``` @PostMapping(""/modelandviewredirect1"") public ModelAndView modelandviewredirect1(UserBean user) {     return new ModelAndView(""redirect:/result"", HttpStatus.TEMPORARY_REDIRECT); // set:, but was: } ```  The workarounds for this problem are as follows:  ``` // 1: use RedirectView#setStatusCode(..) @PostMapping(""/modelandviewredirectview1"") public ModelAndView modelandviewredirectview1(UserBean user) {     RedirectView view = new RedirectView(""/result"", true);     view.setStatusCode(HttpStatus.TEMPORARY_REDIRECT);     return new ModelAndView(view); }  // 2: use the RESPONSE_STATUS_ATTRIBUTE request attribute @PostMapping(""/modelandviewredirect2"") public ModelAndView modelandviewredirect2(UserBean user, HttpServletRequest request) {     request.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, HttpStatus.TEMPORARY_REDIRECT);     return new ModelAndView(""redirect:/result""); } ```  @ResponseStatus is supported with RedirectView as result of #10812 and #17800 resolution. I think ModelAndView.status should be supported with RedirectView as well as @ResponseStatus.  This PR fixes the problem by passing ModelAndView.status to the `RESPONSE_STATUS_ATTRIBUTE` request attribute.  ## Related issues [#10812 @ResponseStatus annotation is ignored in an @Controller redirect (RedirectView) [SPR-6144]](https://github.com/spring-projects/spring-framework/issues/10812) [#17800 Make RedirectViews use RESPONSE_STATUS_ATTRIBUTE as a response status if defined [SPR-13208]](https://github.com/spring-projects/spring-framework/issues/17800) [#18136 ability to set response status on ModelAndView [SPR-13560]](https://github.com/spring-projects/spring-framework/issues/18136) [#19362 ModelAndView's setStatus does not work for @ExceptionHandler methods [SPR-14796]](https://github.com/spring-projects/spring-framework/issues/19362)","closed","type: enhancement,","jkatada","2020-05-17T03:58:24Z","2021-12-07T12:59:36Z"
"","24964","Include response body in RestTemplate exception when there is no suitable HttpMessageConverter","When RestTemplate receive Response from target server, but there's no body readerble converter, throws RestClientException with only situation describing message.   In this situation, even though communication with the server is normally completed, the content of the received text is lost only because the object conversion of the specified type is impossible.  The results seem unfriendly to developers.  It is extremely natural that Exception is thrown because object conversion is impossible, but preserving the response value so that the developer can confirm that the object was not converted to the intended object because the value was returned in the response is helpful in the development or production stage. I think it need. (Especially production)  sually, if the values of the object conversion failure case are unexpectedly returned in the body, the status code may not 2xx, so an HttpServerErrorResponse or HttpClientErrorException will be thrown, but there is no 100% guarantee that the other server will follow the general status code rules. It may or may not be intentional.  Also, may have misplaced the conversion specification simply by the carelessness of the developer writing the communication code.  Anyway, the important thing is that it's a good idea to provide more effective information for trace exception by providing the full value of the response body returned to the developer.  I searched similar issue on github and stackoverflow, but could not find.  So I modified codes of `HttpMessageConverterExtractor.class` near line 120 as below, and I'd like to hear your opinion.  I would appreciate it if you would like to keep the body values or if there is a better way. thanks.  ## Current  ```java 		... 		catch (IOException | HttpMessageNotReadableException ex) { 			throw new RestClientException(""Error while extracting response for type ["" + 					this.responseType + ""] and content type ["" + contentType + ""]"", ex); 		}  		throw new RestClientException(""Could not extract response: no suitable HttpMessageConverter found "" + 				""for response type ["" + this.responseType + ""] and content type ["" + contentType + ""]""); 	} 	... ```  ## Suggest ```java 		... 		}  		catch (IOException | HttpMessageNotReadableException ex) { 			throw new RestClientException(""Error while extracting response for type ["" + 					this.responseType + ""] and content type ["" + contentType + ""]"", ex); 		}  		String extractErrorMessage = ""Could not extract response: no suitable HttpMessageConverter found "" + 				""for response type ["" + this.responseType + ""] and content type ["" + contentType + ""]"";  		try (InputStream is = responseWrapper.getBody()) { 			byte[] bytes = StreamUtils.copyToByteArray(is); 			throw new RestClientResponseException(extractErrorMessage, response.getStatusCode().value(), 					response.getStatusText(), response.getHeaders(), bytes, StandardCharsets.UTF_8); 		} catch (IOException ex) { 			throw new RestClientException(extractErrorMessage + "" And Error while keep response body to bytes"", ex); 		} 	} 	... ```","closed","type: enhancement,","devinabyss","2020-04-23T22:59:28Z","2021-01-05T11:47:32Z"
"","25653","Wrong bean factory method used when method names are the same in one @Configuration","When one `@Configuration` class have two bean factory methods with same name (but different arguments), then Spring creates both beans using only one of those factory methods.  Example:  ```java @Configuration public class Config {      @Bean     public String foo() {         return ""foo"";     }      @Qualifier(""printer1"")     @Bean(name = ""printer1"")     public Printer printer1() {         return new Printer1();     }      // This factory method overrides the method with the same name for both beans.     // The result is context with 2 beans, each has own name and qualifier, but both created with     // the same factory method (this method). Other factory method (printer1()) is ignored.     // So, basically there are 2 Printer2 instances in the context.     @Qualifier(""printer2"")     @Bean(name = ""printer2"")     public Printer printer1/* Here is the bug */(String foo) {         return new Printer2();     }       public interface Printer {         void print();     }      public static class Printer1 implements Printer {         @Override         public void print() {             System.out.println(""I'm Printer 1"");         }     }      public static class Printer2 implements Printer {         @Override         public void print() {             System.out.println(""I'm Printer 2"");         }     }  } ```  ```java @SpringBootApplication public class DemoApplication {      public static void main(String[] args) {         SpringApplication.run(DemoApplication.class, args);     }      @Bean     ApplicationRunner applicationRunner(List printers) {         return args -> printers.forEach(Config.Printer::print);     }  } ```  This prints:  ``` I'm Printer 2 I'm Printer 2 ```  If you try to inject qualified `printer1` bean it also will print `I'm Printer 2`. So, basically the context will have 2 beans, each with own qualifier etc, but both will be created using second factory method.  The solution is to rename first or second factory method to any other name to be different from name of the other method (e.g. `printer5`). Splitting `@Configuration` to 2 configurations also works.  As @mdeinum mentioned [here](https://stackoverflow.com/questions/59051895/bean-name-resolution-in-spring-using-bean-and-qualifier-annotations#comment104346268_59051895) the problem can be with `ConfigurationClassBeanDefinitionReader`.","closed","in: core,","xak2000","2020-08-27T15:01:42Z","2020-08-28T07:19:22Z"
"","24924","Avoid unnecessary String instantiation in StringUtils.deleteAny()","When I was reading https://github.com/spring-projects/spring-framework/pull/24870, I noticed that `String` instantiation in `StringUtils.deleteAny()` isn't necessary when nothing is deleted. So this PR changes to avoid it.  This is a straightforward change, but I just ran [the same benchmark](https://github.com/izeye/samples-jmh-gradle/blob/d193de7d08ce7d8de71dc6ba724cb89018501d20/src/jmh/java/com/izeye/samples/jmh/SpringStringUtilsDeleteAnyBenchmark.java) used in https://github.com/spring-projects/spring-framework/pull/24870. The result is as follows:  ``` Benchmark                                                                                                    Mode  Cnt     Score   Error   Units SpringStringUtilsDeleteAnyBenchmark.original                                                                 avgt         68.215           ns/op SpringStringUtilsDeleteAnyBenchmark.original:·gc.alloc.rate                                                  avgt       1384.675          MB/sec SpringStringUtilsDeleteAnyBenchmark.original:·gc.alloc.rate.norm                                             avgt        104.000            B/op SpringStringUtilsDeleteAnyBenchmark.original:·gc.churn.PS_Eden_Space                                         avgt       1359.258          MB/sec SpringStringUtilsDeleteAnyBenchmark.original:·gc.churn.PS_Eden_Space.norm                                    avgt        102.091            B/op SpringStringUtilsDeleteAnyBenchmark.original:·gc.churn.PS_Survivor_Space                                     avgt          0.048          MB/sec SpringStringUtilsDeleteAnyBenchmark.original:·gc.churn.PS_Survivor_Space.norm                                avgt          0.004            B/op SpringStringUtilsDeleteAnyBenchmark.original:·gc.count                                                       avgt         21.000          counts SpringStringUtilsDeleteAnyBenchmark.original:·gc.time                                                        avgt         12.000              ms SpringStringUtilsDeleteAnyBenchmark.patched                                                                  avgt         20.938           ns/op SpringStringUtilsDeleteAnyBenchmark.patched:·gc.alloc.rate                                                   avgt       4510.715          MB/sec SpringStringUtilsDeleteAnyBenchmark.patched:·gc.alloc.rate.norm                                              avgt        104.000            B/op SpringStringUtilsDeleteAnyBenchmark.patched:·gc.churn.PS_Eden_Space                                          avgt       4477.181          MB/sec SpringStringUtilsDeleteAnyBenchmark.patched:·gc.churn.PS_Eden_Space.norm                                     avgt        103.227            B/op SpringStringUtilsDeleteAnyBenchmark.patched:·gc.churn.PS_Survivor_Space                                      avgt          0.074          MB/sec SpringStringUtilsDeleteAnyBenchmark.patched:·gc.churn.PS_Survivor_Space.norm                                 avgt          0.002            B/op SpringStringUtilsDeleteAnyBenchmark.patched:·gc.count                                                        avgt         69.000          counts SpringStringUtilsDeleteAnyBenchmark.patched:·gc.time                                                         avgt         38.000              ms SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted                                   avgt         13.284           ns/op SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.alloc.rate                    avgt       2734.452          MB/sec SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.alloc.rate.norm               avgt         40.000            B/op SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.churn.PS_Eden_Space           avgt       2788.360          MB/sec SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.churn.PS_Eden_Space.norm      avgt         40.789            B/op SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.churn.PS_Survivor_Space       avgt          0.036          MB/sec SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.churn.PS_Survivor_Space.norm  avgt          0.001            B/op SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.count                         avgt         43.000          counts SpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:·gc.time                          avgt         22.000              ms ```","closed","in: core,","izeye","2020-04-17T13:57:15Z","2020-04-18T00:32:58Z"
"","25855","Update javax.mail reference to jakarta.mail","When I wanted to use `spring-boot-starter-mail` I noticed that `jakarta.mail` should be used instead of `javax.mail`. This has now been changed in the documentation.","closed","type: documentation,","thanus","2020-10-03T16:59:10Z","2020-11-17T10:49:02Z"
"","25122","About springCache","When I use @cacheable, cacheNames doesn't support SpEL. What should I do?","closed","for: stackoverflow,","solomonhe","2020-05-23T10:27:23Z","2020-05-23T10:35:54Z"
"","25518","@Value","When I set the parameters to 01, 02, 03, 04, 05, 06, 07, 09, the program will work normally, but when I set it to 08, an error will be reported. ```java @Value(""${test}"") private int testValue; @Test public void test2() {     System.out.println(testValue); } ``` ````yml test: 08 ````  #### Exception: ````java org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.hv.dbconnect.ConnectionTest': Unsatisfied dependency expressed through field 'testValue'; nested exception is org.springframework.beans.TypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: ""8.0""  	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1378) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireBeanProperties(AbstractAutowireCapableBeanFactory.java:396) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:119) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 	at org.springframework.boot.test.autoconfigure.SpringBootDependencyInjectionTestExecutionListener.prepareTestInstance(SpringBootDependencyInjectionTestExecutionListener.java:44) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:246) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53) Caused by: org.springframework.beans.TypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: ""8.0"" 	at org.springframework.beans.TypeConverterSupport.doConvert(TypeConverterSupport.java:80) 	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:60) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1191) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1164) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:593) 	... 28 more Caused by: java.lang.NumberFormatException: For input string: ""8.0"" 	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) 	at java.lang.Integer.parseInt(Integer.java:580) 	at java.lang.Integer.valueOf(Integer.java:766) 	at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:210) 	at org.springframework.beans.propertyeditors.CustomNumberEditor.setAsText(CustomNumberEditor.java:115) 	at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:466) 	at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:439) 	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:192) 	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:117) 	at org.springframework.beans.TypeConverterSupport.doConvert(TypeConverterSupport.java:70) 	... 32 more ````","closed","","leyan95","2020-08-04T03:16:05Z","2020-08-12T09:11:09Z"
"","25382","WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils","When I move from JDK 8 to JDK 11, I get an illegal access warning, here is the trace:  ``` WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (file:/home/bjorntj/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/5.2.7.RELEASE/56e14a3a5e2813534b5db2da1502cd58ab5bc61d/spring-core-5.2.7.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:533) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.reflect.FastClass$Generator.create(FastClass.java:65) 	at org.springframework.cglib.proxy.MethodProxy.helper(MethodProxy.java:135) 	at org.springframework.cglib.proxy.MethodProxy.init(MethodProxy.java:76) 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:242) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanFactoryAwareMethodInterceptor.intercept(ConfigurationClassEnhancer.java:249) 	at no.havleik.recipes.configuration.SecurityConfig$$EnhancerBySpringCGLIB$$fb4038f1.setBeanFactory() 	at org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor.postProcessProperties(ConfigurationClassPostProcessor.java:448) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:408) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ```  The SecurityConfig class looks like this:  ```java @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends GlobalMethodSecurityConfiguration {      @Override     @Bean     public AuthenticationManager authenticationManager() throws Exception {         return super.authenticationManager();     } } ```  Is this a known problem? Or perhaps I am using this wrong?  Btw, I am using Spring Boot 2.3.1.","closed","status: duplicate,","bjorntj","2020-07-12T12:37:35Z","2020-09-26T10:59:24Z"
"","25557","Optimize NumberToNumberConverterFactory and StringToEnumConverterFactory","When I look at `NumberToNumberConverterFactory`, I find no instance cache for `NumberToNumber`.  ```java public  Converter getConverter(Class targetType) { 	return new NumberToNumber(targetType); } ```  Therefore a new `NumberToNumber` object is instantiated for every conversion.  I added the following test case in `DefaultConversionServiceTests`, debugged it, and it really does create a new instance every time.  ```java 	@Test 	void frequencyConvert() { 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 		assertThat(conversionService.convert(""1.0"", Float.class)).isEqualTo(Float.valueOf(""1.0"")); 	} ```  Should `NumberToNumberConverterFactor` and `StringToEnumConverterFactory` introduce caches to avoid frequently creating new objects?","closed","in: core,","yilianhuaixiao","2020-08-07T07:47:45Z","2020-09-12T15:03:08Z"
"","25194","CaffeineCache with LoadingCache","When CaffeineCache is created with a LoadingCache, the LoadingCache is used with the method `public ValueWrapper get(Object key)` but not with method `public  T get(Object key, @Nullable Class type)`. Using LoadingCache is incompatible with @Cacheable pattern but consistently call the LoadingCache in both methods is better than now. Removing the usage is a backward-incompatible change.  Closes gh-25173","closed","status: declined,","stefano-salmaso","2020-06-05T21:23:33Z","2020-08-07T08:41:11Z"
"","25769","HttpHeaders.setContentDispositionFormData should ignore empty filename","When a Multipart Form request is used with an empty string as Filename, a ""No Filename"" exception is thrown. Can an empty String check be added to prevent the code from failing in empty string scenarios?  https://github.com/spring-projects/spring-framework/blob/3b0f14fd2e1964dfd9a23cbb19d6eb240e7e511e/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L864 ``` public void setContentDispositionFormData(String name, @Nullable String filename) { 		Assert.notNull(name, ""Name must not be null""); 		ContentDisposition.Builder disposition = ContentDisposition.builder(""form-data"").name(name); 		 if (filename != null) {  // Add Empty String check here, don't let through if empty String 			disposition.filename(filename);    // calls method below 		} 		setContentDisposition(disposition.build()); 	} ```   https://github.com/spring-projects/spring-framework/blob/29885e2b9f18646fd8b0971daa51ff7ce2401935/spring-web/src/main/java/org/springframework/http/ContentDisposition.java#L601 ``` @Override 		public Builder filename(String filename) { 			Assert.hasText(filename, ""No filename"");  // Assertion Fails since the the filename does not have text 			this.filename = filename; 			return this; 		}  ```","closed","type: enhancement,","npimentel","2020-09-14T19:24:11Z","2020-09-14T20:42:44Z"
"","25390","Change in the order between interceptors and mapped interceptors in Spring 5","When a handler mapping creates a `HandlerExecutionChain`, Spring 4.1.x added `adaptedInterceptors` first and then added `mappedInterceptors` as shown [here](https://github.com/spring-projects/spring-framework/blob/11fc10282d5fec21346bc541b564b1f45197f942/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L349-L356).  However, Spring 5.1.x merged adapted interceptors and mapped interceptors into `adaptedInterceptors` variable and `getHandlerExecutionChain` returns whatever in the order in `adaptedInterceptors` variable as shown [here](https://github.com/spring-projects/spring-framework/blob/14d539017cffbf534794dc9fbb8a9bc9b21ea07b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480-L490).  However, when the handler mapping populates `adaptedInterceptors`, it adds mapped interceptors into `adaptedInterceptors` first and then adds regular `interceptors` into `adaptedInterceptors` later as shown [here](https://github.com/spring-projects/spring-framework/blob/14d539017cffbf534794dc9fbb8a9bc9b21ea07b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L296-L297).  As a result, mapped interceptors are executed first and then regular interceptors are executed later in Spring 5 while regular interceptors were executed first and then mapped interceptors were executed later in Spring 4.  Is this an intended change?  I noticed this while I am upgrading Spring version from 4.1.x to 5.1.x in my application.  How can I override in Spring 5 so that regular interceptors are executed first and then mapped interceptors executed after?  Maybe [AbstractHandlerMapping.initApplicationContext](https://github.com/spring-projects/spring-framework/blob/14d539017cffbf534794dc9fbb8a9bc9b21ea07b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L293-L298) should be as following?  ``` 	@Override 	protected void initApplicationContext() throws BeansException { 		extendInterceptors(this.interceptors); 		initInterceptors(); // init and adapt this.interceptors first 		detectMappedInterceptors(this.adaptedInterceptors); // then adapt mapped interceptors 	} ```","closed","status: declined,","mykevinjung","2020-07-15T06:20:47Z","2020-08-12T10:53:48Z"
"","25602","MockMvc does not correctly initialize the request for non-file mock Part uploads","When `MockMultipartHttpServletRequestBuilder` is initialized with `Part` (rather than `MultipartFile`) instances, it correctly creates a `MockHttpServletRequest` as per its contract. However in order for this to work correctly the request must then be wrapped with `StandardMultipartHttpServletRequest` which works out which parts are files (and exposed also as `MultipartPartFile`) and which ones are not files (and must be exposed as request parameters).  Currently `MockMultipartHttpServletRequestBuilder` [does this](https://github.com/spring-projects/spring-framework/blob/50b20c2bb7b4c1a3542847a2aeb70f12aa10569d/spring-test/src/main/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilder.java#L147-L149) which ensures that file parts are recognized but it doesn't ensure the rest are exposed as request parameters which can also cause issues for `@RequestPart` arguments.   Existing tests appear to be using a filename which makes it work but masks the problem.","closed","type: bug,","rstoyanchev","2020-08-17T18:41:32Z","2020-08-19T20:17:25Z"
"","25354","Support for Jakarta EE 9 (annotations and interfaces in jakarta.* namespace)","What is the timing for the switch to the jakarta.* namespaced dependencies in JEE9? Is there a version I can use or build that's made that change?","closed","type: dependency-upgrade,","zenbones","2020-07-02T20:18:00Z","2022-03-04T12:33:18Z"
"","25431","Feature: more flexible callbacks in spring-test","What I miss in spring-test when I want to add a new feature is a way to communicate between extension components. If I'm using Spring Boot I want users to be able to just use `@SpringBootTest`, so the `ContextLoader` and the bootstrapper are fixed. I can add `TestExecutionListeners` and `ContextCustomizers` but they don't have a way to influence the way the `ContextLoader` works because they don't share any context.  See also https://github.com/spring-projects/spring-boot/issues/22405","open","type: enhancement,","dsyer","2020-07-20T10:38:25Z","2020-07-20T11:31:36Z"
"","25355","Support Flux in, Flux out for WebSocketSession in WebFlux","WebSocketClient as of Webflux 5.2.7 offers only 2 execute methods which confine programmer's logic to WebSocketHandler implementation he passes there. However, it would've been useful in some cases to expose the received Flux to the outside scope in order to enable its composition with other WS sessions (or reactive functions in general) If such usage pattern is a first-class API method in RSocket, then it's probably been requested often enough  example implementation: https://stackoverflow.com/questions/62249016/sending-output-of-one-websocket-client-as-input-to-another","open","type: enhancement,","bruto0","2020-07-03T10:56:10Z","2021-02-08T18:48:22Z"
"","25544","Provide access to AbstractRoutingDataSource's resolved target DataSources","We've had a few Spring Boot issues related to metrics and health where it would be useful to have access to an AbstractRoutingDataSource's resolved targets (https://github.com/spring-projects/spring-boot/issues/22719, https://github.com/spring-projects/spring-boot/pull/22222). Having access to the resolved targets would allow us to automatically provide metrics and health information for the target DataSources without them having to be exposed as beans or without the user having to write so much code to register them for metrics and health manually.","closed","type: enhancement,","wilkinsona","2020-08-06T09:26:07Z","2020-08-07T13:16:43Z"
"","25679","Revise database defaults for setNull handling (e.g. for NamedParameterJdbcTemplate batch updates)","We've been investigating an issue where we had a 100x performance drop when switching from JdbcTemplate to NamedParameterJdbcTemplate in batch update operations.  We found out that the root cause is the handling of null values by StatementCreatorUtils:setNull, which in turn calls getParameterMetadata from the connection. It seems this issue a database call for every row to be inserted (call stack from profiler attached) which basically kills the performance gains of the batch insert.  We're using Postgres as back-end database. Spring JDBC 5.2.5.  Thanks.","open","type: enhancement,","ricardoekm","2020-09-02T18:46:47Z","2020-10-24T14:09:38Z"
"","25391","RequestMapping produces not overriding at method level","We upgraded from Spring Boot 1.5.9.RELEASE to 2.1.8.RELEASE.  Previously we had this annotation on the controller: ```java @Controller @RequestMapping(value = ""/allocation"", produces = {APPLICATION_JSON_VALUE}) ```  And we had the same on our ""execute"" method. (This method downloads a csv file.) ```java     public List execute(             HttpServletRequest request,             HttpServletResponse response, ```  This was working fine before the Spring Boot upgrade. However after the upgrade it was returning a 406.  We added produces text/csv to the method level, but still getting the 406. Then we added produces text/csv to the controller, and now it works.  (this never used to be required, there is no Spring Framework Media Type for text/csv.)  According to the documentation, the produces at the method level is supposed to override the one at the controller level. This is not happening. (Also, why are we now enforcing the JSON type, where before we did not?)","closed","in: web,","vgrazi","2020-07-14T20:25:48Z","2020-08-03T08:30:05Z"
"","25655","Joda-Time presence check fails to detect Joda-Time 2.x specifically","We upgrade our project from 2.2.1 to 2.3.3 and now we are getting this exception. We found that you are no longer managing joda-time (in past it was 2.10.5) but query-dsl( managed 4.3.1) brings 1.6.  The `DefaultFormattingConversionService` detectes joda time on the classpath and calls the `JodaTimeFormatterRegistrar#registerFormatters` which contains the following lines. Which both references not existing classes in joda 1.6 (`YearMonth` and `MonthDay`) both were added in joda 2.0 according to the javadoc.  ``` registry.addFormatterForFieldType(YearMonth.class, new YearMonthFormatter()); registry.addFormatterForFieldType(MonthDay.class, new MonthDayFormatter()); ```  ``` java.lang.NoClassDefFoundError: org/joda/time/YearMonth  	at org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar.registerFormatters(JodaTimeFormatterRegistrar.java:203) 	at org.springframework.format.support.DefaultFormattingConversionService.addDefaultFormatters(DefaultFormattingConversionService.java:127) 	at org.springframework.boot.convert.ApplicationConversionService.configure(ApplicationConversionService.java:98) 	at org.springframework.boot.convert.ApplicationConversionService.(ApplicationConversionService.java:61) 	at org.springframework.boot.convert.ApplicationConversionService.(ApplicationConversionService.java:54) 	at org.springframework.boot.convert.ApplicationConversionService.getSharedInstance(ApplicationConversionService.java:80) 	at org.springframework.boot.context.properties.bind.Binder.(Binder.java:165) 	at org.springframework.boot.context.properties.bind.Binder.(Binder.java:140) 	at org.springframework.boot.context.properties.bind.Binder.(Binder.java:121) 	at org.springframework.boot.context.properties.bind.Binder.(Binder.java:76) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getWebApplicationType(SpringBootTestContextBootstrapper.java:172) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:156) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:395) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:312) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:265) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:108) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:101) 	at org.springframework.test.context.TestContextManager.(TestContextManager.java:137) 	at org.springframework.test.context.TestContextManager.(TestContextManager.java:122) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTestContextManager(SpringJUnit4ClassRunner.java:151) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.(SpringJUnit4ClassRunner.java:142) 	at org.springframework.test.context.junit4.SpringRunner.(SpringRunner.java:49) 	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) 	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) 	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:500) 	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:481) 	at org.junit.internal.builders.AnnotatedBuilder.buildRunner(AnnotatedBuilder.java:104) 	at org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder$DefensiveAnnotatedBuilder.buildRunner(DefensiveAllDefaultPossibilitiesBuilder.java:114) 	at org.junit.internal.builders.AnnotatedBuilder.runnerForClass(AnnotatedBuilder.java:86) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:70) 	at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:37) 	at org.junit.vintage.engine.discovery.DefensiveAllDefaultPossibilitiesBuilder.runnerForClass(DefensiveAllDefaultPossibilitiesBuilder.java:57) 	at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:70) 	at org.junit.vintage.engine.discovery.ClassSelectorResolver.resolveTestClass(ClassSelectorResolver.java:66) 	at org.junit.vintage.engine.discovery.ClassSelectorResolver.resolve(ClassSelectorResolver.java:47) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.lambda$resolve$2(EngineDiscoveryRequestResolution.java:134) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1631) 	at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) 	at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:543) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:185) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolve(EngineDiscoveryRequestResolution.java:125) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.resolveCompletely(EngineDiscoveryRequestResolution.java:91) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolution.run(EngineDiscoveryRequestResolution.java:82) 	at org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.resolve(EngineDiscoveryRequestResolver.java:113) 	at org.junit.vintage.engine.discovery.VintageDiscoverer.discover(VintageDiscoverer.java:44) 	at org.junit.vintage.engine.VintageTestEngine.discover(VintageTestEngine.java:63) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverEngineRoot(DefaultLauncher.java:181) 	at org.junit.platform.launcher.core.DefaultLauncher.discoverRoot(DefaultLauncher.java:168) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53)   ```","closed","in: core,","jproples","2020-08-28T08:15:25Z","2020-08-28T18:17:55Z"
"","25006","Add missing @PathVariable declarations in examples in webmvc.adoc","We say  For example, given URL ""/spring-web-3.0.5 .jar"", the following method extracts the name, version, and file extension:  So added PathVariable name to complete the code.","closed","in: web,","swapy","2020-05-03T06:05:35Z","2020-05-18T13:06:19Z"
"","25327","Support jackson @JsonProperty while convert String to Enum","We need convert external name to enum sometimes, jackson supports deserialize enum base on @JsonProperty ```java import com.fasterxml.jackson.annotation.JsonProperty; public enum PublicKeyCredentialType { 	@JsonProperty(""public-key"") 	public_key; } ``` It would be great if spring respect @JsonProperty, here is my raw improvement for  built-in`StringToEnumConverterFactory` ```java 		@Override 		public T convert(String source) { 			if (source.isEmpty()) { 				// It's an empty enum identifier: reset the enum value to null. 				return null; 			} 			try { 				return (T) Enum.valueOf(this.enumType, source.trim()); 			} catch (IllegalArgumentException e) { 				for (Field f : this.enumType.getFields()) { 					if (f.getType() == this.enumType) { 						JsonProperty jp = f.getAnnotation(JsonProperty.class); 						if (jp != null && source.equals(jp.value())) { 							try { 								return (T) f.get(null); 							} catch (IllegalArgumentException | IllegalAccessException e1) { 								// never happens 							} 						} 					} 				} 				throw e; 			} 		} ```","open","in: core,","quaff","2020-06-29T11:16:31Z","2021-11-12T12:54:07Z"
"","24941","Introduce ClientHttpConnector test suite","We need a test suite for ClientHttpConnector implementations, separate from  WebClientIntegrationTests, to verify basic assumptions. The test suite should test for:   * Errors in the request stream  * Canceling the response stream  * Basic operations for all the HTTP methods","closed","type: enhancement,","poutsma","2020-04-20T13:16:22Z","2020-04-29T13:22:30Z"
"","25802","Infer default status code based on HTTP method for @RequestMapping","We have to use `ResponseEntity` or use `@ResponseStatus` to give the correct status code. But this could be linked to the type of the HTTP METHOD (GET, POST ..) so that we would not need to put more code.","closed","status: declined,","GuilhermePetena","2020-09-22T20:36:26Z","2021-10-18T10:41:16Z"
"","25366","PersistenceAnnotationBeanPostProcessor keeps refreshing metadata cache","We have lots of threads stuck inside `PersistenceAnnotationBeanPostProcessor.findPersistenceMetadata()`, waiting to refresh metadata of our `@Configurable` entities. We don't use `@PersistenceUnit` or `@PersistenceContext` and thus our metadata are empty. Since version 5.2, emtpy metadata are represented by `InjectionMetadata.EMPTY`, which is always evaluated by `InjectionMetadata.needsRefresh()` as _'not fresh'_, because it doesn't containt the target class.   Compared to previous version of spring this was not happening. This error comes likely from version 5.2, the same version as `InjectionMetadata.forElements()` became used.  This is, how the stack fragment looks: ``` Thread 1538: (state = BLOCKED)  - org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor.findPersistenceMetadata(java.lang.String, java.lang.Class, org.springframework.beans.PropertyValues) @bci=49, line=403 (Compiled frame)  - org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor.postProcessProperties(org.springframework.beans.PropertyValues, java.lang.Object, java.lang.String) @bci=7, line=357 (Compiled frame)  - org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, org.springframework.beans.BeanWrapper) @bci=289, line=1422 (Compiled frame)  - org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireBeanProperties(java.lang.Object, int, boolean) @bci=66, line=393 (Compiled frame)  - org.springframework.beans.factory.wiring.BeanConfigurerSupport.configureBean(java.lang.Object) @bci=172, line=151 (Compiled frame)  - org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect.configureBean(java.lang.Object) @bci=5, line=63 (Compiled frame)  - org.springframework.beans.factory.aspectj.AbstractDependencyInjectionAspect.ajc$afterReturning$org_springframework_beans_factory_aspectj_AbstractDependencyInjectionAspect$2$1ea6722c(java.lang.Object) @bci=2, line=88 (Compiled frame) ```","closed","status: duplicate,","vinov","2020-07-07T14:36:24Z","2020-07-07T15:00:08Z"
"","25600","Introduce createContext() factory method in AbstractGenericContextLoader","We have customized `DefaultListableBeanFactory` and are using it already in `AnnotationConfigWebApplicationContext` for production.  Now we would like to customize the `DefaultListableBeanFactory` for integration tests as well, but in order to archive that we need a new factory method in `AbstractGenericContextLoader`.","closed","type: enhancement,","maciejmiklas","2020-08-17T12:14:44Z","2020-08-17T14:13:51Z"
"","24998","RedirectView with framework does not honor forwarded HTTPS","We have a Spring Boot project which serves up HTML pages using Thymeleaf. This is running behind a proxy. When we use `RedirectView` from an HTTPS page, the redirect is returning the correct page, but on HTTP.  Our code is along the lines of: ``` @PostMapping(value = ""/fillform"") public Object postForm(@Valid FormData formData) {     return new RedirectView(""formcompleted""); } ```  We do have the property set: ``` server.forward-headers-strategy=framework ```  Indeed that property does allow us to get the correct address (rather than the internal address the proxy uses). The issue is only with the schema. Also, the proxy we are using is Spring Cloud Gateway.","open","status: feedback-provided,","dlvenable","2020-04-30T15:34:13Z","2020-05-06T17:39:15Z"
"","25475","Spring Data JPA - Disable @Entity based on configuration","We have a requirement to disable @Entity based on configuration. is it possible?  We dont want to create a table so wanted to disable entity.   **Affects:** \  ---","closed","for: stackoverflow,","brindhats","2020-07-24T16:05:55Z","2020-07-25T10:41:57Z"
"","25050","Autowiring Optional of missing type throws ClassNotFoundException","We have a project running ```Gradle 6.3/6.4``` with ```OpenJdk 14-EA``` on ```Ubuntu 19.10```.  When starting with   ``` ./gradlew bootrun ```  this results in a RuntimeException:  ``` 2020-05-09 12:42:08.114 ERROR [  restartedMain] o.s.boot.SpringApplication               : Application run failed  org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:156) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:544) ~[spring-context-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at com.neoalto.xxx.XxxApplication.main(SpsApplication.java:44) ~[main/:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]     at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]     at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]     at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]     at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.2.7.RELEASE.jar:2.2.7.RELEASE] Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat     at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:125) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.(TomcatWebServer.java:87) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:437) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:191) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:180) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:153) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     ... 13 common frames omitted Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'securityConfig': Unsatisfied dependency expressed through method 'setContentNegotationStrategy' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration': Unsatisfied dependency expressed through method 'setConfigurers' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.data.web.config.SpringDataWebConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.NoClassDefFoundError: org/xmlbeam/config/XMLFactoriesConfig     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:723) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:409) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:211) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:202) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:96) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.ServletContextInitializerBeans.(ServletContextInitializerBeans.java:85) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:253) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.selfInitialize(ServletWebServerApplicationContext.java:227) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.springframework.boot.web.embedded.tomcat.TomcatStarter.onStartup(TomcatStarter.java:53) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5140) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]     at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) ~[na:na]     at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:841) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]     at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) ~[na:na]     at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.StandardService.startInternal(StandardService.java:421) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:930) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.apache.catalina.startup.Tomcat.start(Tomcat.java:468) ~[tomcat-embed-core-9.0.34.jar:9.0.34]     at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:106) ~[spring-boot-2.2.7.RELEASE.jar:2.2.7.RELEASE]     ... 18 common frames omitted Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration': Unsatisfied dependency expressed through method 'setConfigurers' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.data.web.config.SpringDataWebConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.NoClassDefFoundError: org/xmlbeam/config/XMLFactoriesConfig     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:723) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:409) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1306) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:715) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     ... 67 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.data.web.config.SpringDataWebConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.NoClassDefFoundError: org/xmlbeam/config/XMLFactoriesConfig     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:405) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1524) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1488) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1377) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1264) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1226) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:715) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     ... 89 common frames omitted Caused by: java.lang.NoClassDefFoundError: org/xmlbeam/config/XMLFactoriesConfig     at java.base/java.lang.Class.forName0(Native Method) ~[na:na]     at java.base/java.lang.Class.forName(Class.java:420) ~[na:na]     at java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114) ~[na:na]     at java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125) ~[na:na]     at java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49) ~[na:na]     at java.base/sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68) ~[na:na]     at java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138) ~[na:na]     at java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49) ~[na:na]     at java.base/sun.reflect.generics.repository.FieldRepository.computeGenericType(FieldRepository.java:90) ~[na:na]     at java.base/sun.reflect.generics.repository.FieldRepository.getGenericType(FieldRepository.java:82) ~[na:na]     at java.base/java.lang.reflect.Field.getGenericType(Field.java:266) ~[na:na]     at org.springframework.beans.factory.config.DependencyDescriptor.getDependencyType(DependencyDescriptor.java:388) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1243) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.createOptionalDependency(DefaultListableBeanFactory.java:1762) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1213) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.2.6.RELEASE.jar:5.2.6.RELEASE]     ... 103 common frames omitted Caused by: java.lang.ClassNotFoundException: org.xmlbeam.config.XMLFactoriesConfig     at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:602) ~[na:na]     at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) ~[na:na]     at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[na:na]     ... 121 common frames omitted ```  When I manually add the dependency ``` implementation 'org.xmlbeam:xmlprojector:1.4.16' ``` it works. But with JDK 13 this was stangely not needed.","open","in: core,","pbilstein","2020-05-09T10:49:42Z","2021-11-10T11:58:06Z"
"","25043","Memory leak in MediaType.parseMediaType()","We have 40 VMs (8 core,  27 GB RAM) running with Spring Webflux (version given below). Randomly facing performance issue at 2-5 VMs i.e. normal response time is 3-10 ms and in the problematic VMs response time is ~1000 ms.   I have analysed the API flow with Dynatrace and found that performance issue at MediaType.parseMediaType(), more than 75% of the response time contribution is from MediaType.parseMediaType.   Spring WebFlux Version --------------------------          io.projectreactor         reactor-bom         Dysprosium-SR4         pom         import         Embedded Server: ----------------------           org.springframework.boot         spring-boot-starter-jetty         ${spring-boot.version}","closed","status: duplicate,","radhakrishnanch","2020-05-10T18:11:41Z","2022-06-28T11:00:25Z"
"","25773","Document functional bean registration in the reference manual","We currently not have any documentation on functional bean registration in the reference manual, so let's add that in 5.3 (potentially backporting to 5.2) along with some Java/Kotlin examples.","open","in: core,","sbrannen","2020-09-15T11:50:20Z","2021-11-11T10:30:56Z"
"","24983","Support for webflux RSocket route using Coroutine instead of Reactor not working","We cannot make trivial spring webflux + RSocket routes works when using Kotlin coroutines instead of Reactor, despite a huge amount of research on blogs, documentation and even by reading the official spring coroutine extensions for RSocketRequester integration tests.  Here is the basic route: ```kotlin // with reactor: (it works fine)     @MessageMapping(""foo"")     fun foo(): Mono {         println(""test"")         return Mono.empty()     } // with suspend coroutine instead, throw an exception     @MessageMapping(""foo"")     suspend fun foo() {         println(""test"")       } ```  We get an exception both when calling the route from Junit5 (via RSocketRequester) and from an RSocketJS client. For such a trivial example one could guess that we have an issue with our config/ dependencies ? But we have followed the instructions for autoconfiguration.  We have the following gradle dependencies related to this: implementation(""org.springframework.boot:spring-boot-starter-rsocket"") implementation(""org.springframework.boot:spring-boot-starter-webflux"") implementation(""org.springframework.boot:spring-boot-starter-integration"") implementation(""org.springframework.integration:spring-integration-rsocket"") implementation(""org.springframework.integration:spring-integration-test"") testImplementation(""io.kotlintest:kotlintest-runner-junit5:3.3.0"") testImplementation(""io.kotlintest:kotlintest-extensions-spring:3.1.10"") annotationProcessor(""org.springframework.boot:spring-boot-configuration-processor"") annotationProcessor(""org.projectlombok:lombok"")  Most importantly, we have the following kotlin coroutine depenencies -> implementation(""org.jetbrains.kotlin:kotlin-reflect"") implementation(""org.jetbrains.kotlin:kotlin-stdlib-jdk8"") implementation(""org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.5"") implementation(""org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.3.5"") implementation(""org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.5"")  We have spring boot version 2.2.5 which have spring framework 5.2.4 and spring coroutine support has been added in spring framework 5.2 plugins { 	id(""org.springframework.boot"") version ""2.2.5.RELEASE"" 	id(""io.spring.dependency-management"") version ""1.0.9.RELEASE"" 	kotlin(""jvm"") version ""1.3.61"" 	kotlin(""plugin.spring"") version ""1.3.61"" 	id(""org.flywaydb.flyway"") version ""6.2.1"" }  We have *not* added any special annotation for coroutine support as we believe autoconf should work as espected.  What are we missing, and either fix this bug if it is one or improve the documentation/examples as we have read almost all of what is available online and could'nt figure out the issue.  The thrown exception is the following:  ``` java.lang.IllegalStateException: Invocation failure Endpoint [com.brainflow.brainflowserver.controllers.projects.realtime.ConnectionPocController] Method [public java.lang.Object com.brainflow.brainflowserver.controllers.projects.realtime.ConnectionPocController.damn2(kotlin.coroutines.Continuation","closed","","LifeIsStrange","2020-04-27T12:53:14Z","2020-09-15T08:26:32Z"
"","25493","No way to set timeout for the requests when using Jetty reactive httpclient","We are using Jetty reactive http client as the httpclient in webClient. To do this we create ClientConnector object using JettyClientHttpConnector.java (from spring-web).  Now the JettyClientHttpConnector.java doesn't have a way to set timeout for the jetty's HttpRequest. If timeout is not set then the request remains in the jettyclient queue until a response is received from server. This is causing problems during load/stress tests as jettyclient queue fills up to the maximum (when the server is too slow). Once queue is filled up ""Max requests queued per destination"" error is thrown after this no new request can be sent. Now to stop the queue fill up we need a way to set timeout to request, jetty has a way to set timeout for the requests, it's there in the HttpRequest.java class of jetty code. The only problem is JettyClientHttpConnector.java (from spring-web) doesn't have a way to set this timeout to the HttpRequest object created in connect() method.  Jetty HttpRequest.java timeout configuration ->  https://www.eclipse.org/jetty/javadoc/current/org/eclipse/jetty/client/HttpRequest.html#timeout(long,java.util.concurrent.TimeUnit)","closed","type: enhancement,","sathishkp85","2020-07-30T07:42:36Z","2020-08-24T07:05:30Z"
"","24909","Expose multipart data in ServerRequest","We are currently developing a Spring MVC environment using functional routing like this:  ```kotlin router {     POST(""/user-photo/"", userImageHandler::create) } ``` ```kotlin  @Component(""user.Image"") class UserImageHandler : PassHandler() {         fun create(serverRequest: ServerRequest) = success {         val multipartRequest = (serverRequest.servletRequest() as? MultipartHttpServletRequest) ?:              throw ResponseStatusException(                  HttpStatus.NOT_ACCEPTABLE,                  ""Request is not a multipart request""               )         val file: MultipartFile = multipartRequest.getFile(""file"") ?: throw ResponseStatusException(              HttpStatus.NOT_ACCEPTABLE,              ""Missing file with name: file""         )      ....     } } ``` The ServerRequest is the https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/function/ServerRequest.html interface. The only way to access files seem to be the casting method we do right now - `serverRequest.servletRequest().parts` is empty.  This is the integration test: ```kotlin         val file = MockMultipartFile(             ""blank.jpg"",             ""blank.jpg"",             ""image/jpg"",             getImageBytes()         )          mockMvc.perform(             MockMvcRequestBuilders.multipart(""/user-photo/"")                 .file(file)                 .accept(MediaType.APPLICATION_JSON)         ).andExpect(             MockMvcResultMatchers.status().isOk         ) ``` In the integration test the serverRequest.servletRequest part is of type `SecurityContextHolderAwareRequestWrapper[ org.springframework.security.web.header.HeaderWriterFilter$HeaderWriterRequest@71f08480]` and thus not a decendant of `MultipartHttpServletRequest`.   Is there a smarter way to access multipart files with the ServerRequest interface? Otherwise I would think that `HttpServletRequest` is missing a `getFiles()` method.  I found an way to access multipart files but it's a few levels deep and would require a lot of casting: ![image](https://user-images.githubusercontent.com/1151304/79347104-846cbd80-7f33-11ea-95fd-a2803b508eb1.png)","closed","type: enhancement,","jonasbark","2020-04-15T14:11:09Z","2020-04-28T13:44:56Z"
"","25064","ResolvableType forClass fails when a type in the generic signature isn't present","Via https://github.com/spring-projects/spring-boot/issues/21431 and somewhat similar to https://github.com/spring-projects/spring-framework/issues/25050, it appears that `ResolvableType` needs to handle a `TypeNotPresentException` being thrown when it queries generics. Here's the failure from the Boot issue:  ``` java.lang.TypeNotPresentException: Type org.springframework.jdbc.CannotGetJdbcConnectionException not present 	at java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:117) 	at java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125) 	at java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49) 	at java.base/sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68) 	at java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138) 	at java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49) 	at java.base/sun.reflect.generics.repository.ClassRepository.computeSuperclass(ClassRepository.java:104) 	at java.base/sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:86) 	at java.base/java.lang.Class.getGenericSuperclass(Class.java:955) 	at org.springframework.core.ResolvableType.getSuperType(ResolvableType.java:467) 	at org.springframework.core.ResolvableType.as(ResolvableType.java:456) 	at org.springframework.core.ResolvableType.forClass(ResolvableType.java:1041) 	at org.springframework.boot.diagnostics.AbstractFailureAnalyzer.getCauseType(AbstractFailureAnalyzer.java:56) 	at org.springframework.boot.diagnostics.AbstractFailureAnalyzer.analyze(AbstractFailureAnalyzer.java:33) 	at org.springframework.boot.diagnostics.FailureAnalyzers.analyze(FailureAnalyzers.java:111) 	at org.springframework.boot.diagnostics.FailureAnalyzers.reportException(FailureAnalyzers.java:104) 	at org.springframework.boot.SpringApplication.reportFailure(SpringApplication.java:816) 	at org.springframework.boot.SpringApplication.handleRunFailure(SpringApplication.java:801) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:325) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) 	at at.mikemitterer.catshostel.Application$Companion.main(Application.kt:46) 	at at.mikemitterer.catshostel.Application.main(Application.kt) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) 	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) Caused by: java.lang.ClassNotFoundException: org.springframework.jdbc.CannotGetJdbcConnectionException 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:602) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	at java.base/java.lang.Class.forName0(Native Method) 	at java.base/java.lang.Class.forName(Class.java:416) 	at java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114) 	... 27 common frames omitted ```","closed","type: enhancement,","wilkinsona","2020-05-13T07:34:06Z","2020-05-13T22:50:58Z"
"","26364","Missing ETag response header for CSS TransformedResources","Version: Spring Boot 2.3.4.RELEASE  When using a content resource chain to cache-bust `.css` and `.js` files, with server compression enabled, and Thymeleaf as the template engine (not sure if it's relevant or not), the css file is compressed but the js file is not. If the JS file is requested directly (without going through the resource chain), then it's compressed.  Here's a complete minimal repro: https://github.com/jnizet/compressiondemo  Here's a screenshot of the Chrome network panel when loading the page:    As you can see, the `bundle.js` files (which did not go through the resource chain) has a transfer size that is less than the file size. But the `bundle.c525abb....js` file, which is the same file, but obtained through the resource chain, is not compressed.  What's weird is that the css file did go through the resource chain, but was compressed as expected.","open","type: bug,","jnizet","2020-09-23T16:48:21Z","2021-01-08T16:51:22Z"
"","25055","UriComponentsBuilder.addPath() needs behavior documented in regards to slashes","Version: 5.2.5-RELEASE  We're using spring hateoas (webflux version) and noticed that our links have a missing slash between the context path and the controller `RequestMapping.path`.  Adding slashes to the `RequestMapping.path` is a workaround, but shouldn't be needed.  The method below seems to be the culprit.   If `psBuilder == null` and `fpBuilder != null`, no slash is added.  ```java public void addPath(String path) { 	if (StringUtils.hasText(path)) { 		PathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class); 		FullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class); 		if (psBuilder != null) { 			path = (path.startsWith(""/"") ? path : ""/"" + path); 		} 		if (fpBuilder == null) { 			fpBuilder = new FullPathComponentBuilder(); 			this.builders.add(fpBuilder); 		} 		fpBuilder.append(path); 	} } ```","closed","type: task,","ctytgat","2020-05-12T12:49:49Z","2020-05-24T20:26:59Z"
"","24885","PostProcessorRegistrationDelegate.sortPostProcessors optimization.","version: 5.2.4  ```java private static void sortPostProcessors(List postProcessors, ConfigurableListableBeanFactory beanFactory) { 		Comparator comparatorToUse = null; 		if (beanFactory instanceof DefaultListableBeanFactory) { 			comparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator(); 		} 		if (comparatorToUse == null) { 			comparatorToUse = OrderComparator.INSTANCE; 		} 		postProcessors.sort(comparatorToUse); 	} ```  `postProcessors` size < 1, Can return directly.","closed","in: core,","cherishsince","2020-04-09T06:16:55Z","2020-04-09T10:24:01Z"
"","25111","Spring Boot 2.3.0 won't start with hibernate.search.FieldBridge annotation in use","Using the annotation `org.hibernate.search.FieldBridge` in a spring boot 2.3.0 project resulting in a ""dead-lock"". The application won't start. Removing the annotation fixes it.   Example (Java 8):  https://github.com/knoobie/spring-2-3-fieldbridge  1) The application is still on 2.2.6 -> `mvn clean install` -> tests are working 2) Update to 2.3.0 -> `mvn clean install` ->   ```log 2020-05-20 10:13:39.710 DEBUG 18503 --- [         task-1] o.h.s.b.impl.lucene.WorkspaceFactory     : Starting workspace for index xxx.backend.entities.Question using an exclusive index strategy 2020-05-20 10:13:39.715 DEBUG 18503 --- [         task-1] o.h.s.b.impl.lucene.SyncWorkProcessor    : HSEARCH000230: Starting sync consumer thread for index 'de.dvzmv.service.help.service.backend.entities.Question' 2020-05-20 10:13:39.715 DEBUG 18503 --- [         task-1] o.h.s.b.impl.lucene.WorkspaceHolder      : HSEARCH000235: Backend for index 'xxx.backend.entities.Question' started: using a Synchronous batching backend. 2020-05-20 10:13:39.766 DEBUG 18503 --- [         task-1] o.h.s.i.i.LuceneEmbeddedIndexFamilyImpl  : Setting Lucene compatibility to Version 5.5.5 2020-05-20 10:13:39.777 DEBUG 18503 --- [         task-1] o.h.s.e.m.i.AnnotationMetadataProvider   : Found JPA id and using it as document id 2020-05-20 10:13:39.781 DEBUG 18503 --- [         task-1] o.h.s.e.m.i.AnnotationMetadataProvider   : Found JPA id and using it as document id -- no more logs -- ```  3) When `@FieldBridge` line is removed from `Answer` the application is running again, but the test fails (as expected).  Thread dump:  ```log 2020-05-20 10:46:25 Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):  ""Attach Listener"" spring-projects/spring-boot#361 daemon prio=9 os_prio=0 tid=0x00007ff484001000 nid=0x7f21 waiting on condition [0x0000000000000000]    java.lang.Thread.State: RUNNABLE  ""Hibernate Search sync consumer thread for index xxx.backend.entities.Question"" spring-projects/spring-boot#360 daemon prio=5 os_prio=0 tid=0x00007ff44452d800 nid=0x7ec6 waiting on condition [0x00007ff45e1f8000]    java.lang.Thread.State: TIMED_WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:338) 	at org.hibernate.search.backend.impl.lucene.SyncWorkProcessor.parkCurrentThread(SyncWorkProcessor.java:179) 	at org.hibernate.search.backend.impl.lucene.SyncWorkProcessor.access$300(SyncWorkProcessor.java:37) 	at org.hibernate.search.backend.impl.lucene.SyncWorkProcessor$Consumer.run(SyncWorkProcessor.java:149) 	at java.lang.Thread.run(Thread.java:748)  ""task-1"" spring-projects/spring-boot#359 prio=5 os_prio=0 tid=0x00007ff461434800 nid=0x7ec5 waiting for monitor entry [0x00007ff45eef7000]    java.lang.Thread.State: BLOCKED (on object monitor) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:183) 	- waiting to lock  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch(AbstractBeanFactory.java:517) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:533) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:505) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:482) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:475) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1158) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:422) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:352) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) 	at org.springframework.orm.hibernate5.SpringBeanContainer.createBean(SpringBeanContainer.java:151) 	at org.springframework.orm.hibernate5.SpringBeanContainer.getBean(SpringBeanContainer.java:110) 	at org.hibernate.search.cfg.impl.HibernateOrmBeanContainerBeanResolver.resolve(HibernateOrmBeanContainerBeanResolver.java:63) 	at org.hibernate.search.engine.service.beanresolver.impl.ReflectionFallbackBeanResolver.resolve(ReflectionFallbackBeanResolver.java:40) 	at org.hibernate.search.bridge.impl.BridgeFactory.createFieldBridgeFromAnnotation(BridgeFactory.java:371) 	at org.hibernate.search.bridge.impl.BridgeFactory.findExplicitFieldBridge(BridgeFactory.java:350) 	at org.hibernate.search.bridge.impl.BridgeFactory.buildFieldBridge(BridgeFactory.java:203) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.bindFieldAnnotation(AnnotationMetadataProvider.java:1335) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.checkForField(AnnotationMetadataProvider.java:1258) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.initializeMemberLevelAnnotations(AnnotationMetadataProvider.java:1065) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.initializeClass(AnnotationMetadataProvider.java:615) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.checkForIndexedEmbedded(AnnotationMetadataProvider.java:1924) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.initializeMemberLevelAnnotations(AnnotationMetadataProvider.java:1074) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.initializeClass(AnnotationMetadataProvider.java:615) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.doGetTypeMetadataFor(AnnotationMetadataProvider.java:192) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.getTypeMetadataFor(AnnotationMetadataProvider.java:181) 	at org.hibernate.search.engine.metadata.impl.AnnotationMetadataProvider.getTypeMetadataFor(AnnotationMetadataProvider.java:165) 	at org.hibernate.search.spi.SearchIntegratorBuilder.initDocumentBuilders(SearchIntegratorBuilder.java:445) 	at org.hibernate.search.spi.SearchIntegratorBuilder.createNewFactoryState(SearchIntegratorBuilder.java:244) 	at org.hibernate.search.spi.SearchIntegratorBuilder.buildNewSearchFactory(SearchIntegratorBuilder.java:200) 	at org.hibernate.search.spi.SearchIntegratorBuilder.buildSearchIntegrator(SearchIntegratorBuilder.java:128) 	at org.hibernate.search.hcore.impl.HibernateSearchSessionFactoryObserver.boot(HibernateSearchSessionFactoryObserver.java:127) 	- locked  (a org.hibernate.search.hcore.impl.HibernateSearchSessionFactoryObserver) 	at org.hibernate.search.hcore.impl.HibernateSearchSessionFactoryObserver.sessionFactoryCreated(HibernateSearchSessionFactoryObserver.java:94) 	at org.hibernate.internal.SessionFactoryObserverChain.sessionFactoryCreated(SessionFactoryObserverChain.java:35) 	at org.hibernate.internal.SessionFactoryImpl.(SessionFactoryImpl.java:380) 	at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:468) 	at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1249) 	at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) 	at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$$Lambda$806/120136606.call(Unknown Source) 	at java.util.concurrent.FutureTask.run(FutureTask.java:266) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at java.lang.Thread.run(Thread.java:748)  ""container-0"" spring-projects/spring-boot#358 prio=5 os_prio=0 tid=0x00007ff46011a000 nid=0x7ec4 waiting on condition [0x00007ff45effa000]    java.lang.Thread.State: TIMED_WAITING (sleeping) 	at java.lang.Thread.sleep(Native Method) 	at org.apache.catalina.core.StandardServer.await(StandardServer.java:570) 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer$1.run(TomcatWebServer.java:197)  ""Catalina-utility-2"" spring-projects/spring-boot#357 prio=1 os_prio=0 tid=0x00007ff458002800 nid=0x7ec3 waiting on condition [0x00007ff45f0fb000]    java.lang.Thread.State: TIMED_WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for   (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) 	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215) 	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078) 	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093) 	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809) 	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.lang.Thread.run(Thread.java:748)  ""Catalina-utility-1"" spring-projects/spring-boot#356 prio=1 os_prio=0 tid=0x00007ff46121a800 nid=0x7ec2 waiting on condition [0x00007ff45f9fe000]    java.lang.Thread.State: WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for   (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) 	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) 	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) 	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1088) 	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809) 	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.lang.Thread.run(Thread.java:748)  ""webpack"" spring-projects/spring-boot#355 daemon prio=5 os_prio=0 tid=0x00007ff4612ed000 nid=0x7eb6 runnable [0x00007ff45f3fc000]    java.lang.Thread.State: RUNNABLE 	at java.io.FileInputStream.readBytes(Native Method) 	at java.io.FileInputStream.read(FileInputStream.java:255) 	at java.io.BufferedInputStream.read1(BufferedInputStream.java:284) 	at java.io.BufferedInputStream.read(BufferedInputStream.java:345) 	- locked  (a java.lang.UNIXProcess$ProcessPipeInputStream) 	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) 	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) 	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) 	- locked  (a java.io.InputStreamReader) 	at java.io.InputStreamReader.read(InputStreamReader.java:184) 	at java.io.BufferedReader.fill(BufferedReader.java:161) 	at java.io.BufferedReader.readLine(BufferedReader.java:324) 	- locked  (a java.io.InputStreamReader) 	at java.io.BufferedReader.readLine(BufferedReader.java:389) 	at com.vaadin.flow.server.DevModeHandler.readLinesLoop(DevModeHandler.java:458) 	at com.vaadin.flow.server.DevModeHandler.lambda$logStream$1(DevModeHandler.java:436) 	at com.vaadin.flow.server.DevModeHandler$$Lambda$770/1410478418.run(Unknown Source) 	at java.lang.Thread.run(Thread.java:748)  ""process reaper"" spring-projects/spring-boot#353 daemon prio=10 os_prio=0 tid=0x00007ff4612e9800 nid=0x7ea1 runnable [0x00007ff49c0c3000]    java.lang.Thread.State: RUNNABLE 	at java.lang.UNIXProcess.waitForProcessExit(Native Method) 	at java.lang.UNIXProcess.lambda$initStreams$3(UNIXProcess.java:289) 	at java.lang.UNIXProcess$$Lambda$760/842129709.run(Unknown Source) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at java.lang.Thread.run(Thread.java:748)  ""Thread-340"" spring-projects/spring-boot#352 daemon prio=5 os_prio=0 tid=0x00007ff4612e2000 nid=0x7e9f runnable [0x00007ff45f4fd000]    java.lang.Thread.State: RUNNABLE 	at java.net.PlainSocketImpl.socketAccept(Native Method) 	at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) 	at java.net.ServerSocket.implAccept(ServerSocket.java:560) 	at java.net.ServerSocket.accept(ServerSocket.java:528) 	at com.vaadin.flow.server.DevServerWatchDog$WatchDogServer.run(DevServerWatchDog.java:58) 	at java.lang.Thread.run(Thread.java:748)  ""HikariPool-1 housekeeper"" spring-projects/spring-boot#350 daemon prio=5 os_prio=0 tid=0x00007ff460f65000 nid=0x7e9c waiting on condition [0x00007ff49dc21000]    java.lang.Thread.State: TIMED_WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for   (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) 	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215) 	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078) 	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093) 	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809) 	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at java.lang.Thread.run(Thread.java:748)  ""restartedMain"" spring-projects/spring-boot#11 prio=5 os_prio=0 tid=0x00007ff46c003000 nid=0x7d4b waiting on condition [0x00007ff49df1e000]    java.lang.Thread.State: WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for   (a java.util.concurrent.FutureTask) 	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) 	at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429) 	at java.util.concurrent.FutureTask.get(FutureTask.java:191) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.getNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:540) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:497) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:680) 	at com.sun.proxy.$Proxy111.getMetamodel(Unknown Source) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean$$Lambda$841/1869811997.apply(Unknown Source) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.getMetamodels(JpaMetamodelMappingContextFactoryBean.java:106) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:80) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:44) 	at org.springframework.beans.factory.config.AbstractFactoryBean.afterPropertiesSet(AbstractFactoryBean.java:142) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$180/1416025551.getObject(Unknown Source) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	- locked  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:330) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:113) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1699) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$180/1416025551.getObject(Unknown Source) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	- locked  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1114) 	at org.springframework.data.repository.support.Repositories.cacheRepositoryFactory(Repositories.java:99) 	- locked  (a org.springframework.data.repository.support.Repositories) 	at org.springframework.data.repository.support.Repositories.populateRepositoryFactoryInformation(Repositories.java:92) 	at org.springframework.data.repository.support.Repositories.(Repositories.java:85) 	at org.springframework.data.repository.support.DomainClassConverter.setApplicationContext(DomainClassConverter.java:109) 	at org.springframework.data.web.config.SpringDataWebConfiguration.addFormatters(SpringDataWebConfiguration.java:130) 	at org.springframework.web.servlet.config.annotation.WebMvcConfigurerComposite.addFormatters(WebMvcConfigurerComposite.java:81) 	at org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration.addFormatters(DelegatingWebMvcConfiguration.java:78) 	at org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration.mvcConversionService(WebMvcAutoConfiguration.java:435) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:651) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:636) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$180/1416025551.getObject(Unknown Source) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	- locked  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1306) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1226) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:539) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$180/1416025551.getObject(Unknown Source) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	- locked  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:895) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) 	- locked  (a java.lang.Object) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:143) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) 	at xxx.Application.main(Application.java:14) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49)  ""Thread-0"" spring-projects/spring-boot#9 prio=5 os_prio=0 tid=0x00007ff4c0a81800 nid=0x7d4a in Object.wait() [0x00007ff49e023000]    java.lang.Thread.State: WAITING (on object monitor) 	at java.lang.Object.wait(Native Method) 	- waiting on  (a org.springframework.boot.devtools.restart.RestartLauncher) 	at java.lang.Thread.join(Thread.java:1252) 	- locked  (a org.springframework.boot.devtools.restart.RestartLauncher) 	at java.lang.Thread.join(Thread.java:1326) 	at org.springframework.boot.devtools.restart.Restarter.relaunch(Restarter.java:296) 	at org.springframework.boot.devtools.restart.Restarter.doStart(Restarter.java:283) 	at org.springframework.boot.devtools.restart.Restarter.start(Restarter.java:264) 	at org.springframework.boot.devtools.restart.Restarter.lambda$immediateRestart$0(Restarter.java:172) 	at org.springframework.boot.devtools.restart.Restarter$$Lambda$16/1975546571.call(Unknown Source) 	at org.springframework.boot.devtools.restart.Restarter$LeakSafeThread.run(Restarter.java:629)  ""Service Thread"" spring-projects/spring-boot#8 daemon prio=9 os_prio=0 tid=0x00007ff4c00e2800 nid=0x7d48 runnable [0x0000000000000000]    java.lang.Thread.State: RUNNABLE  ""C1 CompilerThread2"" spring-projects/spring-boot#7 daemon prio=9 os_prio=0 tid=0x00007ff4c00c5800 nid=0x7d47 waiting on condition [0x0000000000000000]    java.lang.Thread.State: RUNNABLE  ""C2 CompilerThread1"" spring-projects/spring-boot#6 daemon prio=9 os_prio=0 tid=0x00007ff4c00c3800 nid=0x7d46 waiting on condition [0x0000000000000000]    java.lang.Thread.State: RUNNABLE  ""C2 CompilerThread0"" spring-projects/spring-boot#5 daemon prio=9 os_prio=0 tid=0x00007ff4c00c0800 nid=0x7d45 waiting on condition [0x0000000000000000]    java.lang.Thread.State: RUNNABLE  ""Signal Dispatcher"" spring-projects/spring-boot#4 daemon prio=9 os_prio=0 tid=0x00007ff4c00bc800 nid=0x7d44 runnable [0x0000000000000000]    java.lang.Thread.State: RUNNABLE  ""Finalizer"" spring-projects/spring-boot#3 daemon prio=8 os_prio=0 tid=0x00007ff4c008e800 nid=0x7d43 in Object.wait() [0x00007ff4ad5b5000]    java.lang.Thread.State: WAITING (on object monitor) 	at java.lang.Object.wait(Native Method) 	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144) 	- locked  (a java.lang.ref.ReferenceQueue$Lock) 	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165) 	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  ""Reference Handler"" spring-projects/spring-boot#2 daemon prio=10 os_prio=0 tid=0x00007ff4c008a000 nid=0x7d42 in Object.wait() [0x00007ff4ad6b6000]    java.lang.Thread.State: WAITING (on object monitor) 	at java.lang.Object.wait(Native Method) 	at java.lang.Object.wait(Object.java:502) 	at java.lang.ref.Reference.tryHandlePending(Reference.java:191) 	- locked  (a java.lang.ref.Reference$Lock) 	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  ""main"" spring-projects/spring-boot#1 prio=5 os_prio=0 tid=0x00007ff4c0012800 nid=0x7d3c in Object.wait() [0x00007ff4c7b77000]    java.lang.Thread.State: WAITING (on object monitor) 	at java.lang.Object.wait(Native Method) 	- waiting on  (a org.springframework.boot.devtools.restart.Restarter$LeakSafeThread) 	at java.lang.Thread.join(Thread.java:1252) 	- locked  (a org.springframework.boot.devtools.restart.Restarter$LeakSafeThread) 	at java.lang.Thread.join(Thread.java:1326) 	at org.springframework.boot.devtools.restart.Restarter$LeakSafeThread.callAndWait(Restarter.java:613) 	at org.springframework.boot.devtools.restart.Restarter.immediateRestart(Restarter.java:171) 	at org.springframework.boot.devtools.restart.Restarter.initialize(Restarter.java:164) 	at org.springframework.boot.devtools.restart.Restarter.initialize(Restarter.java:554) 	at org.springframework.boot.devtools.restart.RestartApplicationListener.onApplicationStartingEvent(RestartApplicationListener.java:74) 	at org.springframework.boot.devtools.restart.RestartApplicationListener.onApplicationEvent(RestartApplicationListener.java:50) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) 	at org.springframework.boot.context.event.EventPublishingRunListener.starting(EventPublishingRunListener.java:74) 	at org.springframework.boot.SpringApplicationRunListeners.starting(SpringApplicationRunListeners.java:47) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:305) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) 	at xxx.Application.main(Application.java:14)  ""VM Thread"" os_prio=0 tid=0x00007ff4c0080800 nid=0x7d41 runnable   ""GC task thread#0 (ParallelGC)"" os_prio=0 tid=0x00007ff4c0028000 nid=0x7d3d runnable   ""GC task thread#1 (ParallelGC)"" os_prio=0 tid=0x00007ff4c002a000 nid=0x7d3e runnable   ""GC task thread#2 (ParallelGC)"" os_prio=0 tid=0x00007ff4c002b800 nid=0x7d3f runnable   ""GC task thread#3 (ParallelGC)"" os_prio=0 tid=0x00007ff4c002d800 nid=0x7d40 runnable   ""VM Periodic Task Thread"" os_prio=0 tid=0x00007ff4c00e5000 nid=0x7d49 waiting on condition   JNI global references: 1764  ```","open","in: data,","knoobie","2020-05-20T10:01:59Z","2021-11-10T11:38:08Z"
"","25536","MockHttpServletResponse's setCharacterEncoding() does not update contentType property","Using Spring Boot 2.3.2, I have the following `MockMvc` setup:  ```java 		this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext) 			.addFilter(springSecurityFilterChain) 			.addFilter((request, response, chain) -> { 				chain.doFilter(request, response); 				response.setCharacterEncoding(""UTF-8""); 			}, ""/*"").build()  ```  In debugging, I can see this calls `MockHttpServletResponse::updateContentTypeHeader` and correctly falls through the code and replaces the content type header in `this.headers`, but it is not updating `this.contentType`, so any JUnit calls to `content().contentType()` will return the unaltered version which will lead to unexpected results.","closed","type: bug,","SledgeHammer01","2020-08-05T21:05:41Z","2020-08-10T14:07:27Z"
"","25492","Using RestTemplate to submit the data to the rest endpoint throwing StackOverflow Error","Using RestTemplate to submit the data to the rest endpoint throwing below error   Caused by: java.lang.StackOverflowError: null         at org.springframework.http.client.support.HttpRequestWrapper.getHeaders(HttpRequestWrapper.java:88)         at org.springframework.http.client.support.HttpRequestWrapper.getHeaders(HttpRequestWrapper.java:88)         at org.springframework.http.client.support.HttpRequestWrapper.getHeaders(HttpRequestWrapper.java:88)         at org.springframework.http.client.support.HttpRequestWrapper.getHeaders(HttpRequestWrapper.java:88)","closed","","SanjayGautam","2020-07-30T02:11:23Z","2020-08-13T07:11:45Z"
"","25125","Allow customization of JPA EntityManager before use","Using JPA with a Hibernate (5.4.16) implentation and `LocalContainerEntityManagerFactoryBean` with `JpaTransactionManager` (5.2.6) I'm  trying to use a Hibernate Filter, which implies access to the newly created `EntityManager`, to [enable](https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#pc-filter-entity-example) it.  I kept looking through the code but I can't seem to find a way to customize the `EntityManager`. I think something similar to `AbstractJpaVendorAdapter#postProcessEntityManagerFactory` perhaps would be nice, if possible.","closed","type: enhancement,","andrei-ivanov","2020-05-25T09:37:31Z","2020-10-16T12:30:10Z"
"","25311","Use @SafeVarargs in Jackson builder and factory","Using @SafeVarargs in Jackson mapper builder and factory bean classes allows the varargs methods to be used without a compiler warning. The implementations of these methods do not perform unsafe operations on their varargs parameter. It is therefore safe to add this annotation.  The following two methods are changed:  - add @SafeVarargs to Jackson2ObjectMapperBuilder#modulesToInstall   and make it final - add @SafeVarargs to   Jackson2ObjectMapperFactoryBean#setModulesToInstall and make it final  This is a backwards incompatible change as these methods now have to be declared final. Existing subclasses that override one of these methods will break.  Closes gh-25293","closed","type: enhancement,","marschall","2020-06-24T11:03:48Z","2020-06-24T15:16:51Z"
"","25848","UserCredentialsConnectionFactoryAdapter createContext changes.","UserCredentialsConnectionFactoryAdapter holds the username/password and uses them for the createConnection mehod.  This PR makes use of the same technic for  the `createContext` methods","open","in: messaging,","dotbg","2020-10-01T16:22:46Z","2022-05-10T19:11:49Z"
"","25506","Optimize DefaultLifecycleProcessor::startBeans","Use lambda for minor refactoring","closed","type: enhancement,","chenqimiao","2020-08-02T02:41:39Z","2020-08-10T15:40:52Z"
"","25457","Add JSON support to Protobuf codecs","Use case:  Developers want to create Protobuf service implementation, more efficient. However, also need to **expose as rest/json**, to support clients that consume json -- perhaps we are in technology-transition time?   This **does not work for netty/webflux**, but works for tomcat, so likely some platform config issue?   Please make it easy to expose PROTO  implementation as rest, without code duplication.  ![image](https://user-images.githubusercontent.com/56970398/88116050-b2dae400-cb85-11ea-98ba-d8db034f7f76.png)   https://stackoverflow.com/questions/60289736/spring-webflux-netty-no-tomcat-how-to-expose-proto-as-json-endopints-without/63022169#63022169","open","type: enhancement,","anborg","2020-07-21T23:13:19Z","2022-05-13T02:10:57Z"
"","25481","Upload a file, asynchronous processing will trigger Java.io.FileNotFoundException","upload a file, and and handle it like this, cause Java.io.FileNotFoundException. tmp file will be cleaned after the request thread been processed.  ![image](https://user-images.githubusercontent.com/48583080/88612351-9b3bb800-d0bd-11ea-96aa-dcb9db2016b8.png) ![image](https://user-images.githubusercontent.com/48583080/88612373-a7277a00-d0bd-11ea-9134-391119f0b194.png)  Exception is ` java.io.FileNotFoundException: /private/var/folders/3f/r0vdjy7x6_gf8r65qztk2s280000gn/T/tomcat.8862437345990196241.8080/work/Tomcat/localhost/ROOT/upload_72649361_9318_475e_ac23_968976e74536_00000000.tmp (No such file or directory) `","closed","for: stackoverflow,","lanicc","2020-07-28T02:33:03Z","2022-01-12T12:20:21Z"
"","25527","Upgrade to JUnit 5.7","Upgrade to JUnit 5.7 as soon as it is released.  [JUnit 5.7 M2](https://github.com/junit-team/junit5/milestone/49) should be released soon and may potentially be renamed to 5.7 RC1 leading to an earlier GA release.","closed","type: dependency-upgrade,","sbrannen","2020-08-04T14:02:52Z","2020-09-13T21:35:17Z"
"","25320","Merge pull request #1 from spring-projects/master","Update from spring-projects","closed","","fransonsr","2020-06-26T16:31:29Z","2020-06-26T16:31:57Z"
"","25664","Merge pull request #1 from spring-projects/master","update forks","closed","status: invalid,","slowDownWithMe","2020-08-31T08:23:08Z","2020-08-31T08:25:01Z"
"","25019","Merge pull request #1 from spring-projects/master","update forks","closed","","xieyuming","2020-05-06T07:18:40Z","2020-05-06T07:18:52Z"
"","25204","update","update file","closed","status: invalid,","qq1026290752","2020-06-08T06:13:12Z","2020-06-08T07:03:22Z"
"","25747","Merge pull request #1 from spring-projects/master","update","closed","status: invalid,","GoalSwallow","2020-09-09T14:04:11Z","2020-09-09T14:08:27Z"
"","25151","Provide a flag to disable XML support","Unlike other converters/codecs which can be enabled selectively based on classpath detection, XML ones are enabled by default in Spring MVC and WebFlux, but are also reachable in other places like properties loading facilities.  In order to improve effiency on both JVM and GraalVM native images for users not using XML (more common these days since JSON and Yaml are widely used), this issue plan to introduce a  `spring.xml.ignore` flag in order to disable XML support in a way that allows GraalVM native images to remove that code at build time.  Usage of XML support with the flag enabled should trigger a proper exception with a message explaining how to re-enable it.  For the record this allows to reduce native image size by 8.4M, RSS memory consumption by 4.2M and build time by 7s with Java 8.  The work done on [spring-graalvm-native substitutions](https://github.com/spring-projects-experimental/spring-graalvm-native/tree/master/spring-graalvm-native-substitutions) has allows to identify a first set of classes where XML support should be removed:  - `org.springframework.util.DefaultPropertiesPersister`  - `org.springframework.core.io.support.PropertiesLoaderUtils`  - `org.springframework.web.servlet.function.support.RouterFunctionMapping`  - `org.springframework.web.client.RestTemplate`  - `org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver`  - `org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport`  - `org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter`  - `org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter`  - `org.springframework.http.codec.support.BaseDefaultCodecs`  There are potential other places where we should seek where those XML related classes (used by GraalVM native to trigger XML support):  - `javax.xml.bind.Binder`  - `javax.xml.datatype.DatatypeFactory`  - `javax.xml.parsers.DocumentBuilderFactory`  - `javax.xml.parsers.SAXParserFactory`  - `javax.xml.stream.FactoryFinder`  - `javax.xml.transform.FactoryFinder`  - `org.w3c.dom.bootstrap.DOMImplementationRegistryClasses`  Such flag could also be used on Spring Boot side:  - In `org.springframework.boot.BeanDefinitionLoader` to remove usage of `XmlBeanDefinitionReader`  - In `org.springframework.boot.logging.logback.LogbackLoggingSystem` to remove XML support from Logback configuration.","closed","type: enhancement,","sdeleuze","2020-05-28T12:15:50Z","2020-11-19T15:13:39Z"
"","25652","Avoid LinkedList performance issues through use of ArrayDeque","Triggered by gh-25650 which replaces `LinkedList` all over the place in the 5.3 codebase, we've identified several spots where the use of `ArrayDeque` instead of `LinkedList` specifically avoids performance issues (e.g. for a larger number of elements). In particular, `StringUtils.cleanPath`, `FastByteArrayOutputStream` and `ParseState` benefit from such a change in the 5.2.x line as well.","closed","type: enhancement,","jhoeller","2020-08-27T11:25:42Z","2020-08-27T17:11:38Z"
"","25559","Introduce getBeanProvider variants with allowEagerInit flag","Triggered by gh-24644, the unique capabilities of `getBeanProvider` (which include stream-based access to generic type matches as well as ordered stream access) are useful for many purposes but miss a key ingredient from the simpler `ListableBeanFactory` retrieval methods: namely the ability to suppress eager initialization for type checks. Introducing dedicated `getBeanProvider` variants with an `allowEagerInit` flag at `ListableBeanFactory` level closes that gap without introducing the concept of eager/lazy type initialization at the basic `BeanFactory` level (where no other such methods with an `allowEagerInit` flag exist).  There is also an `includeNonSingletons` flag on those `ListableBeanFactory` retrieval methods which we are not mirroring here since it is less useful in general and potentially irritating in terms of semantics for the full set of `ObjectProvider` retrieval methods.","closed","type: enhancement,","jhoeller","2020-08-07T09:46:11Z","2020-08-07T10:08:56Z"
"","24890","Extend transaction attributes with labels","TransactionAttribute now exposes a labels attribute that associates a descriptive array of labels with a transaction.  Labels may be of pure descriptive nature or may get evaluated by transaction managers to associate technology-specific behavior with the actual transaction.","closed","type: enhancement,","mp911de","2020-04-09T13:51:43Z","2020-05-06T14:28:23Z"
"","25603","Clarify purpose of build(boolean) method in UriComponentsBuilder","To prevent confusion about the build(boolean) method fix for issue #25444 not #25323","closed","","eitan613","2020-08-17T20:34:13Z","2020-08-20T11:34:32Z"
"","25604","Prevent confusion about build(boolean) method in UriComponentsBuilder","To prevent confusion about the build(boolean) method","closed","type: task,","eitan613","2020-08-17T21:11:41Z","2020-09-07T20:43:31Z"
"","25357","Fix syntax errors in 'args()' AOP sample code","To me it looks like in your 'args()' argument binding sample pointcuts the syntax is wrong.","closed","status: invalid,","kriegaex","2020-07-06T05:37:43Z","2020-07-06T14:35:35Z"
"","25352","Polish mutateContextPathWithoutUpdatingPathShouldFail()","This PR updates the logic in `mutateContextPathWithoutUpdatingPathShouldFail()` to align with the name of the test method.","closed","type: task,","izeye","2020-07-01T10:03:49Z","2020-07-02T15:08:28Z"
"","25049","Replace HttpClient.websocket() deprecation","This PR replaces deprecated `HttpClient.websocket()` with recommended one.","closed","in: web,","izeye","2020-05-11T13:37:53Z","2020-05-30T00:15:35Z"
"","25361","Remove redundant Character.toLowerCase() in BeanPropertyRowMapper","This PR removes a redundant `Character.toLowerCase()` invocation in `BeanPropertyRowMapper.underscoreName()`.","closed","type: enhancement,","izeye","2020-07-06T12:59:57Z","2020-07-06T13:34:57Z"
"","25072","Use computeIfAbsent in ResourceBundleMessageSource","This PR is to optimize code by using computeIfAbsent instead of putIfAbsent, similar to #25054","closed","type: task,","chenqimiao","2020-05-14T03:25:11Z","2020-06-18T11:50:19Z"
"","25054","Use computeIfAbsent in ResourceBundleMessageSource","This PR is to optimize code by using `computeIfAbsent` instead of `putIfAbsent`, in addition, the content of some Javadoc has been adjusted.","closed","type: task,","chenqimiao","2020-05-12T10:37:11Z","2020-05-13T06:27:33Z"
"","25196","Refactor method name dispatching to switch statements","This PR is about issue #25163 :)","closed","","lee-garden","2020-06-06T15:26:45Z","2022-02-18T19:06:54Z"
"","25199","Refactor method name dispatching to switch statements in AutowireUtils","This PR is about #25163 :)","closed","type: enhancement,","lee-garden","2020-06-06T15:46:56Z","2020-06-09T21:48:18Z"
"","25464","Introduce CronExpression","This PR introduces `CronExpression`, a new abstraction for representing cron expressions, and a direct replacement for `CronSequenceGenerator`.","closed","type: enhancement,","poutsma","2020-07-23T13:29:28Z","2020-08-03T14:45:13Z"
"","25810","Optimize StringUtils trimLeading/Trailing methods","This PR includes some StringUtils methods optimization. The problem is that trimLeading/TrailingCharacter and trimLeading/TrailingWhitespace methods create a StringBuilder object as a local var instead of using String.substring method. Such approach is leading to unnecessary object creation on every method invocation. Also it runs slower because of internal StringBuilder operations and conversions String->StringBuilder->String. According to simple JMH benchmark, substring is x2/x3 faster on avg scenarios. The situation with long strings that are not changed at all(if the method returns an equal string) is especially dramatic for StringBuilder (but substring will return its param instead of new a string creation) Also found out that trimWhitespace(String str) method is already implemented in similar style.","closed","type: enhancement,","Shenker93","2020-09-23T20:56:39Z","2020-09-25T08:44:03Z"
"","24984","Modified the code to format the nested exception stack trace","This PR fixes https://github.com/spring-projects/spring-framework/issues/23227 .  As part of this fix , added a new function in `NestedExceptionUtils.java` which formats the nested exception stack trace based on **semi-colon** `;` and **colon** `:` .  P.S : As this is my first PR , please help with the eclipse code formatting file as my current commit has some changes to the lines that were not intended to change for this fix ( just formatting based on eclipse settings). It will help if I can get hold of a .preferences file that I can import locally in my eclipse , re-apply formatting and push the change.","open","in: core,","kamath-prasad","2020-04-27T14:53:07Z","2021-11-11T09:26:57Z"
"","25368","Use correct link to MaxInMemorySize","This PR fixes a broken link to the ""MaxInMemorySize"" section.","closed","status: invalid,","izeye","2020-07-08T01:05:36Z","2020-07-08T13:31:16Z"
"","25147","Deprecate HandlerInterceptorAdapter","This PR deprecates `HandlerInterceptorAdapter`, as `(Async)HandlerInterceptor` provide the same convenience by themselves with default methods. Additionally, existing `HandlerInterceptorAdapter` subclasses have been reworked to implement `(Async)HandlerInterceptor`.","closed","type: task,","vpavic","2020-05-28T07:48:22Z","2020-05-29T20:52:55Z"
"","25656","Copy httpHandlerDecorator in copy constructor for WebHttpHandlerBuilder","This PR changes to copy `httpHandlerDecorator` in copy constructor for `WebHttpHandlerBuilder` as it seems to be missed accidentally in 21d25b23d95d0b6ccb582cae0d53691b651d9a8e.  This PR also polishes its Javadoc and fixes its test along the way.","closed","type: bug,","izeye","2020-08-28T09:31:42Z","2020-09-01T10:23:04Z"
"","24958","Warn about unsupported ""/path/**/other"" patterns with WebFlux PathPatternParser","This issue is an early warning of behavior changes coming with #24952 in 5.3.0.  When applications use `PathPatternParser` to parse patterns with `""**""` in the middle, we should log a WARNING log message about this particular pattern saying that it will be processed as a `""*""` and rejected in the future.  We should also improve the Javadoc and reference documentation to better explain the cases supported here.","closed","type: enhancement,","bclozel","2020-04-22T16:12:52Z","2020-04-23T11:13:19Z"
"","25338","Leverage spring.ignore.xml flag to avoid XmlBeanDefinitionReader","This issue is a follow up of #25151, it avoids using `XmlBeanDefinitionReader` in `ConfigurationClassBeanDefinitionReader` when `spring.xml.ignore` is `true` in order to avoid triggering XML usage in GraalVM native images.","closed","type: enhancement,","sdeleuze","2020-06-30T05:33:47Z","2020-07-27T10:23:40Z"
"","25143","Optimize initialization of empty request mapping conditions","This isn't very optimal currently in terms of object creation. A new instance is created for every empty condition. Internally collections are created and wrapped automatically without checking for empty input. Combining class and method level mappings repeats the process further.","closed","type: task,","rstoyanchev","2020-05-27T17:39:19Z","2020-05-27T18:14:02Z"
"","25585","Eliminate unnecessary word in core-bean.adoc that causes repetition","This is the orginal ""A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container"". Here's an extra word of ""otherwise"".","closed","type: task,","york-lee","2020-08-14T01:57:49Z","2020-08-14T10:04:28Z"
"","24879","YamlPropertiesFactoryBean has empty string returned when empty array value is present in the YAML document","This is related to #21310.  I'm using the latest **spring boot version 2.2.6** and latest **spring cloud config  version 2.2.2**.  I use GitHub as source of truth for fetching my configurations from base YAML file.   Check the property `cards: [""""]` or just `cards: []` in line number 4.    The response I get from my service for fetching the configuration is as below snapshot for a default profile API to spring cloud config server.  Please find below snapshot with response : ""default.oihs.cards"": """"    Stack Overflow question: https://stackoverflow.com/questions/61096022/yamlpropertiesfactorybean-has-empty-string-returned-when-empty-array-value-is-pr","closed","in: core,","dhivyaarumugam","2020-04-08T08:05:30Z","2020-04-20T18:03:25Z"
"","25859","How to identify which dependencies will break after upgrading to latest spring from spring 3.0.5?","This is my pom file. I am working on very old version of spring and as time to time upgradation were not maintained so is it possible to jump to the latest version of spring from spring 3.0.5? Is there any way to predict what will break and what will not? ```      4.0.0     com.app     app-service     1     war               3.0.5.RELEASE         3.6.3.Final         1.4         dev         true                                 net.sf.ehcache             ehcache             2.10.6                               com.fasterxml.jackson.dataformat             jackson-dataformat-xml             2.9.8                                   junit                 junit                 4.12                                         org.springframework             spring-jms             ${spring.version} 	 		                                  org.springframework             spring-web             ${spring.version}                               org.springframework             spring-webmvc             ${spring.version}                               org.springframework             spring-context             ${spring.version}                                            org.springframework             spring-orm             ${spring.version}                                            org.springframework             spring-oxm             ${spring.version}          		 		  com.rabbitmq 		  amqp-client 		  3.2.1 		                      org.springframework             spring-core             ${spring.version}                                org.springframework             spring-aop             ${spring.version}                               org.springframework             spring-asm             ${spring.version}                                org.springframework             spring-test             ${spring.version}                               org.springframework.security             spring-security-core             ${spring.version}                               org.springframework.security             spring-security-web             ${spring.version}                               org.springframework.security             spring-security-config             ${spring.version}                  		 			org.apache.xbean 			xbean-spring 			3.14 		                        rome             rome             0.5                                antlr             antlr             2.7.6                           	mysql         	mysql-connector-java         	5.1.6                                aopalliance             aopalliance             1.0                               asm             asm             1.5.3                               cglib             cglib             2.1_3          		 		  org.apache.activemq 		  activemq-all 		  5.8.0 		                      org.hibernate.javax.persistence             hibernate-jpa-2.0-api             1.0.0.Final                                org.hibernate             hibernate-core             ${hibernate-version}                               org.hibernate             hibernate-envers             ${hibernate-version}                               net.sf.jasperreports             jasperreports             4.5.1                                commons-lang             commons-lang             2.3                                org.dbunit             dbunit             2.4.8             test                                log4j             log4j             1.2.16             jar                               javax.mail             mail             1.4.7                                        javax.servlet             servlet-api             2.5             jar             provided                                        commons-fileupload             commons-fileupload             1.2.2                                                       commons-dbcp                  commons-dbcp                  ${commons-dbcp-version}                                              commons-io             commons-io             1.3.2                                        jstl             jstl             1.2                                        org.codehaus.jackson             jackson-mapper-asl             1.7.5                                        org.hibernate             hibernate-validator             4.3.1.Final                               org.mockito             mockito-all             1.9.5             test             jar                               org.apache.httpcomponents             httpcore             4.0.1             jar                               org.apache.httpcomponents             httpclient             4.0.2             jar                               org.json             json             20180813             jar                               org.springframework.amqp             spring-rabbit             2.2.7.RELEASE                                                            maven-war-plugin                 2.2                                      WebContent/WEB-INF/web.xml                     app-service                                                             org.apache.maven.plugins                 maven-compiler-plugin                 2.3.2                                      1.8                     1.8                                                             maven-antrun-plugin                                                               prepare-package                                                      run                                                                                                                                                                        dev                              dev                              ```","closed","for: stackoverflow,","sayeduzzamancuet","2020-10-06T05:46:03Z","2020-10-06T05:49:32Z"
"","25292","Added unit test to IntegerToEnumConverterFactoryTest class.","This is my first commit into Spring Framework, so I would like to start small :)","closed","type: task,","devdilson","2020-06-20T12:58:29Z","2020-06-22T11:30:41Z"
"","24868","Add generic ETag comparator","This is an improvement request I wonder it has not been created before.  Consider the following code:  ```java @GetMapping(path = ""/{externalProjectId}"", produces = ""application/json"") public ResponseEntity getProject(     @PathVariable(""externalProjectId"") String externalProjectId,     @RequestHeader(name = ""If-None-Match"", required = false) RecordEtag ifNoneMatchEtag) {   Long modifiedId = service.getModifiedId(externalProjectId);    if (ifNoneMatchEtag != null && ifNoneMatchEtag.getValue() == modifiedId) {     return ResponseEntity.status(HttpStatus.NOT_MODIFIED)         .eTag(ifNoneMatchEtag.toString()).build();   }    BasicRecord project = service.getProject(externalProjectId);   return ResponseEntity.ok().eTag(new RecordEtag(modifiedId).toString()).body(project); } ``` (Yes, I know the ETag comparison is wrong)  where  ```java public class RecordEtag {    private long value;    public RecordEtag(String etag) {     Validate.notEmpty(etag, ""ETag cannot be null/empty"");      if (etag.startsWith(""W/""))       throw new IllegalArgumentException(""weak ETags are not supported"");      if (!(etag.startsWith(""\"""") && etag.endsWith(""\"""")))       throw new IllegalArgumentException(""ETag must be enclosed in double qoutes"");      String unwrapped = StringUtils.substringBetween(etag, ""\"""");      try {       this.value = Long.parseLong(unwrapped, 16);     } catch (NumberFormatException e) {       throw new IllegalArgumentException(""ETag is not a hex string"");     }   }    public RecordEtag(long value) {     this.value = value;   }    public long getValue() {     return value;   }    @Override   public String toString() {     return ""\"""" + Long.toHexString(value) + ""\"""";   }  } ```  What I am completely missing in Spring Web is to assist the developer to avoid boilerplate code around ETag comparison. I'd expect some comparator:  ```java @GetMapping(path = ""/{externalProjectId}"", produces = ""application/json"") public ResponseEntity getProject(     @PathVariable(""externalProjectId"") String externalProjectId,     @RequestHeader(name = ""If-None-Match"", required = false) ETagComparator ifNoneMatchEtag) {   Long modifiedId = service.getModifiedId(externalProjectId);    RecordEtag recordEtag = new RecordEtag(modifiedId);   if (ifNoneMatchEtag != null && ifNoneMatchEtag.matches(/* optional */ ETagComparator.WEAK_COMPARISION, recordEtag.toString()) {   //                                                                                                     ^^^^^^^^^^ can also be null if resource doesn't exist   return ResponseEntity.status(HttpStatus.NOT_MODIFIED)         .eTag(recordEtag.toString()).build();   }    BasicRecord project = service.getProject(externalProjectId);   return ResponseEntity.ok().eTag(recordEtag,toString()).body(project); } ```  Basic idea: * `ETagComparator` parses the value of the supplied header along with `*`, a possible list and weak/strong boolean * Ideally, when used from `@RequestHeader` and the header is wellknown (RFC 7232), the comparison function is already set * `@RequestHeader` will inject `null` when value is not provided * `ETagComparator` can handle `null` input from the client indicating that the target resource does not exist or by some other means fulfulling this * Match the the supplied value from controller method  The semantic behavior of `If-Match`/`If-None-Match` is welldefined. In a case of a custom header, like in my case `If-Parent-Match` which has `If-Match` semantic behavior I must be able to configure this semantic behavior also.","open","status: feedback-provided,","michael-o","2020-04-06T10:33:18Z","2021-11-10T12:16:38Z"
"","24837","Document precedence for @DynamicPropertySource","This is a follow-up to #24540.","closed","type: documentation,","sbrannen","2020-04-01T16:09:09Z","2020-04-01T16:10:27Z"
"","24978","ConflictingBeanDefinitionException on repeated index evaluation","This is a follow-up from the spring-boot gitter channel. When upgrading the spring-boot bom from 2.2.5.RELEASE to 2.2.6.RELEASE I get this exception: ``` Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'aBean' for bean class [com.example.demo.ABean] conflicts with existing, non-compatible bean definition of same name and class [com.example.demo.ABean] 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.checkCandidate(ClassPathBeanDefinitionScanner.java:349) ~[spring-context-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:287) ~[spring-context-5.2.5.RELEASE.jar:5.2.5.RELEASE] ``` The problem remains even when using 2.2.7.BUILD-SNAPSHOT. Here's what I've discovered while debugging it:   - so what happens is that the classpath scanner detects my test configuration (which has `@ComponentScan` annotation) and that adds the `aBean` bean, but it also picks up the `DemoApplication` (the class with the main method). So it does classpath scanning for the `DemoApplication` again so the `ComponentScanAnnotationParser` performs the scan, and finds the `aBean` again and then calls the `isCompatible` method here:  https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.java#L364  This method returns false so an exception is raised.   - It is important to have the `spring-context-indexer` dependency in your classpath. If you have it then the beans passed to `isCompatible` method will get `getSource()` return null.   - it is also important to name the bean `ABean`. If I name it `DemoBean` then the exception does not happen -  I think the component scan finds candidates sorted by beanName. So if `ABean` comes before `DemoApplication` then it will fail if I name it `DemoBean` then it will come after `DemoApplication` and it will not fail.  Here's a repository that reproduces the problem: https://github.com/ptahchiev/conflicting-bean","closed","in: core,","ptahchiev","2020-04-26T14:49:01Z","2020-04-27T11:45:02Z"
"","25461","Add new `listOf` method to `TypeDescriptor` class","This is a fix for issue https://github.com/spring-projects/spring-framework/issues/25393","closed","in: core,","raderio","2020-07-22T15:00:54Z","2021-12-10T23:06:10Z"
"","25436","Add convert method to ConversionService","This is a fix for issue #25394","open","in: core,","dPechman42","2020-07-20T21:04:12Z","2021-11-11T09:34:15Z"
"","25047","SPR-17614 Fix SpEL inline collections with negative keys or values are not cached","This is a fix for https://github.com/spring-projects/spring-framework/issues/22146","closed","type: enhancement,","SammyVimes","2020-05-11T12:08:19Z","2020-10-16T13:16:34Z"
"","25324","Hoist Class.getName() from String concatenation to dodge an issue related to profile pollution","This is a continuation of PR #24153.","closed","type: enhancement,","stsypanov","2020-06-27T11:53:06Z","2020-06-30T08:38:36Z"
"","25666","gh-25650 Replace remaining usage of LinkedList with ArrayList in tests","This is a continuation of https://github.com/spring-projects/spring-framework/commit/874574513c47287d86fb8a3e943a81910b587395","closed","in: core,","stsypanov","2020-08-31T11:12:11Z","2020-09-01T09:19:09Z"
"","25174","PathPattern doesn't extract pathWithinHandlerMapping correctly for non-pattern URLs","This is [defined as](https://github.com/spring-projects/spring-framework/blob/e955e52f2f108517535d4c0541cc5b8bd5e6c22b/spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerMapping.java#L75-L77):  > Name of the `{@link HttpServletRequest}` attribute that contains the path within the handler mapping, in case of a pattern match, or **the full relevant URI** (typically within the DispatcherServlet's mapping) else.  However, `PathPattern` defines that case as an empty string: https://github.com/spring-projects/spring-framework/blob/e955e52f2f108517535d4c0541cc5b8bd5e6c22b/spring-web/src/main/java/org/springframework/web/util/pattern/PathPattern.java#L278  I don't know if there was a reason for the discrepancy or if it accidental. @bclozel and @aclement do you recall anything more?  I think it would be okay to correct the behavior. The only place where this is used in WebFlux is for static resources where are typically mapped with a pattern. Now that we are adding support for `PathPattenr` in Spring MVC with #24945 we should correct it to make it consistent and easier to switch from `AntPathMatcher` to `PathPatternParser` in Spring MVC.","closed","status: invalid,","rstoyanchev","2020-06-02T10:57:59Z","2020-09-13T20:56:43Z"
"","25200","Fix web parameters resolution when injected via constructor","This fixes the problem described in #25182   Comma-separated multi value parameters are wrongly injected if constructor injection is used. Only spring-web is affected, webflux works correctly.  For example `...?listOfStrings=1,2` becomes `List listOfStrings = [""1,2""]`, instead of expected `List listOfStrings = [""1"", ""2""]`. The reason is that `WebRequest#getParameterValues` exposes single item params as an array which breaks conversion service later on.","closed","type: bug,","encircled","2020-06-06T22:35:11Z","2021-05-10T10:11:36Z"
"","24887","Avoid using regex matching for static patterns","This fixes the issue #24873  As of now, `AntPathStringMatcher` uses regex matching even when: - the pattern is a constant. In such cases, it should be enough to use strings comparison - the pattern is `.*`. In such cases it is always a positive match  Applying such optimizations increased `PatternsRequestCondition` evaluation (on my machine) from ~440 ops/ms to ~700 ops/ms  `AntPathStringMatcher` is used not only for URL matching, so it would be nice to double-check carefully","closed","type: enhancement,","encircled","2020-04-09T10:37:17Z","2020-05-15T15:25:24Z"
"","25065","Add support for R2DBC","This commit introduces support for R2DBC (""Reactive Relational Database Connectivity"") with custom ConnectionFactory implementations, a functional DatabaseClient for SQL execution, transaction management, a bind marker abstraction database initialization utilities and exception translation.   Open issues:  - [X] Discuss reuse of `ScriptUtils` and friends :: to be addressed in #25275. - [ ] Potential reuse of named parameters utilities - [x] Documentation (should it go side by side with the JDBC documentation)","closed","type: enhancement,","mp911de","2020-05-13T13:59:00Z","2020-06-18T12:39:38Z"
"","25256","Rollback reactive transaction on cancel","This commit introduces a change in reactive transaction semantics for cancel signals. Canceling a subscription now rolls back a reactive transaction to achieve a deterministic transaction outcome.  Previously, cancel signals committed a transaction which could cause partially committed transactions depending on when the cancel happened.  See also #25091.","closed","type: enhancement,","mp911de","2020-06-16T09:02:37Z","2020-06-17T13:04:56Z"
"","25463","Fully automate dev setup with Gitpod","This commit implements a fully-automated development setup using Gitpod.io, an online IDE for GitHub and GitLab that enables Dev-Environments-As-Code. This makes it easy for anyone to get a ready-to-code workspace for any branch, issue or pull request almost instantly with a single click.","closed","status: declined,","gumuxiansheng","2020-07-23T10:27:25Z","2022-07-27T15:14:23Z"
"","25313","Webflux model in @GetMapping is empty","This appears to be a regression (works with Spring Boot 2.3.0 and fails with 2.3.1). I think it's more likely to be a Webflux issue, but not really sure TBH. Consider this controller:  ```java @Controller public class SampleController {  	@GetMapping(""/"") 	public String home(Map model) { 		model.put(""time"", new Date()); 		model.put(""message"", ""Hello""); 		return ""index""; 	} } ```  The `home()` method is not called (I observe in a debugger) before the `AbstractView` is rendered, so the model is empty. Sample: https://github.com/scratches/SPR-25313.  UPDATE: it also works with Spring Boot 2.4.0-SNAPSHOT. So something is stuck in the middle there.","closed","status: duplicate,","dsyer","2020-06-24T16:33:33Z","2020-06-26T11:42:45Z"
"","25800","Ignore duplicate configuration metadata for cache key in the TestContext framework","This affects **4.3**   When I have a base class like:  ```java @ContextConfiguration(classes = A.class) class Base extends AbstractTestNGSpringContextTests {} ```  and a child class:  ```java @ContextConfiguration(classes = A.class) class Child extends Base {} ```  I noticed Spring creates separate `ApplicationContext` for both test classes.   This is not the expected behavior since according to [the docs](https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/integration-testing.html#testcontext-ctx-management-caching):  > An ApplicationContext can be uniquely identified by the combination of configuration parameters that are used to load it  So by the definition outlined in the docs, these two test classes should being using the same `ApplicationContext` .  When I enabled cache debugging I noticed this being logged:  ``` Storing ApplicationContext in cache under key [[MergedContextConfiguration@4f190018 testClass = Base, locations = '{}', classes = '{class A} ```   when trying to retrieve the `ApplicationContext` for the base class.   ``` Storing ApplicationContext in cache under key [[MergedContextConfiguration@4f190017 testClass = Child, locations = '{}', classes = '{class A, class A} ```  when trying to retrieve the `ApplicationContext` for the child class.   I expect the cache key to be the same here, why is it different?   ## Deliverables  Ignore duplicate test configuration annotation (for the following list of annotations) when a given test class declares the exact same annotation (or equivalent merged annotation) as the next level above the current test class in the inheritance class hierarchy or enclosing class hierarchy.  Effectively, we want to remove exact duplication resulting from copy-n-paste errors before building the `MergedContextConfiguration` for a given test class.  - [x] `@ContextConfiguration` - [x] `@ActiveProfiles`   - duplicates are already removed via the use of a `LinkedHashSet` in `ActiveProfilesUtils.resolveActiveProfiles()`   - See also #25973 - [x] `@TestPropertySource`","closed","type: enhancement,","dfit99","2020-09-22T21:25:44Z","2020-10-26T16:19:46Z"
"","25647","Avoid use of String's for ContentDisposition type","This adds constants for three common Content-Disposition types: `attachment`, `form-data`, and `inline`.  I have also updated the tests to use these new constants.","closed","type: enhancement,","kashike","2020-08-26T08:33:18Z","2020-10-23T17:28:30Z"
"","25648","Add URI variables to request context in AbstractUrlHandlerMapping (reactive)","There seems to be an asymmetry between MVC and Webflux with the `AbstractUrlHandlerMapping`. The MVC one parses out the URI variables and dumps them in a request attribute. The Webflux one does not. Here's what I did:  ```java class MyHandlerMapping extends AbstractUrlHandlerMapping { 	@Override 	protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception { 		Object result = super.lookupHandler(lookupPath, exchange); 		if (result == null) { 			return result; 		} 		PathPattern bestPattern = (PathPattern) exchange.getAttributes().get(BEST_MATCHING_PATTERN_ATTRIBUTE); 		Map uriVariables; 		Map matrixVariables; 		if (bestPattern == null) { 			bestPattern = getPathPatternParser().parse(lookupPath.value()); 			uriVariables = Collections.emptyMap(); 			matrixVariables = Collections.emptyMap(); 		} 		else { 			PathPattern.PathMatchInfo match = bestPattern.matchAndExtract(lookupPath); 			Assert.notNull(match, () -> 					""Expected pattern to match lookupPath "" + lookupPath); 			uriVariables = match.getUriVariables(); 			matrixVariables = match.getMatrixVariables(); 		} 		exchange.getAttributes().put(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriVariables); 		exchange.getAttributes().put(MATRIX_VARIABLES_ATTRIBUTE, matrixVariables); 		return result; 	} ... ```  (Code copied from `RequestMappingInfoHandlerMapping.handleMatch`.)  Would it be reasonable for that to be the default?","closed","type: enhancement,","dsyer","2020-08-26T09:34:37Z","2020-08-28T21:20:33Z"
"","25596","Document how to specify Jackson JSON view serialization hints with @RestController and Webflux","There is not documentation how to filter fields using JsonViews using specific security roles when using Webflux and non-functional endpoints, for example `@RestController`.  There  is a tutorial that explains how to achieve this using MCV. https://www.baeldung.com/spring-security-role-filter-json  There is another issue that has been closed that explains similar functionality with RouterFunctions and Webflux. https://github.com/spring-projects/spring-framework/issues/23150","closed","in: web,","monstrfolk","2020-08-16T18:36:31Z","2020-11-05T12:42:32Z"
"","25609","I create Bean Son which needs the Bean Father, and the bean father created on missingBean Enemy, the result is","there is no bean Father, but there is Bean Son, is this a bug?  ```java ConfigurableApplicationContext context = SpringApplication.run(SpringBeanApplication.class, args); Son son = context.getBean(Son.class); son.hello(); Father bean = context.getBean(Father.class); bean.hello();   @Service @ConditionalOnMissingBean(Enemy.class) public class Father {     public void hello() {         System.out.println(""father hello"");     } }  @Service public class Enemy {  }  @Service @ConditionalOnBean(Father.class) public class Son {     public void hello() {         System.out.println(""son hello"");     } } ```","closed","for: stackoverflow,","wy911149112","2020-08-18T08:00:19Z","2020-08-18T08:28:56Z"
"","25331","Upgrade to RSocket 1.1 M1","There is a significant internal refactoring planned that should not impact the current API. However there are also other new features and updates that we should aim to support, see #25332 and #25333.","closed","type: dependency-upgrade,","rstoyanchev","2020-06-29T13:52:40Z","2020-08-10T19:41:25Z"
"","24990","Simplify redundant code","There is a redundant `if condition` in `ResolvableType.java`. I propose to simplify redundant code. Thank you for reading my PR :)","closed","status: invalid,","YooInKeun","2020-04-29T04:34:21Z","2020-04-29T13:40:15Z"
"","25270","WebFlux application server add server.forward- Headers - Strategy = Framework RouterFunction endpoint 404","There are two services:  ` account-service `, ` gateway-server `  After the `account-service` has set the 'server.forward- Headers - Strategy = Framework' property.routerFunction endpoint start 404   The following interfaces are accessed through the Spring Cloud Gateway  ` http://localhost:8080/account/hi ` is 404. The generated by RouterFunction endpoint  ` http://localhost:8080/account/hello ` return 200 normal, through RequestMapping annotations   Reproducible Example：  [forward-proxy-demo.zip](https://github.com/spring-projects/spring-framework/files/4793657/forward-proxy-demo.zip)","closed","type: bug,","oursy","2020-06-17T15:44:42Z","2020-09-03T13:19:16Z"
"","25179","Disable and remove unsupported features from native images","The work done on [spring-graalvm-native substitutions](https://github.com/spring-projects-experimental/spring-graalvm-native/tree/master/spring-graalvm-native-substitutions) has allows to identify a first set of classes where we need to add a specific code path for GraalVM native images:  - Remove load time weaving capabilities from `org.springframework.context.support.AbstractApplicationContext` - Remove `ConfigurationClassEnhancer` usage from `org.springframework.context.annotation.ConfigurationClassPostProcessor` - Remove usage of `ObjenesisCglibAopProxy` from   `org.springframework.aop.framework.DefaultAopProxyFactory` - Remove `CglibSubclassCreator` usage from `org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy`  There are likely other ones to be identified.","closed","type: enhancement,","sdeleuze","2020-06-03T11:13:29Z","2020-07-27T10:25:39Z"
"","25333","Support RSocket Load Balancing","The way to use to the load balancing feature through `RSocketRequester` is not straight forward and we need to change that but the 1.1 M1 upgrade (see #25331) should bring an updated API that we should aim to work well against.","closed","type: enhancement,","rstoyanchev","2020-06-29T14:03:57Z","2020-09-09T05:27:20Z"
"","25738","Optimize ConfigurationClassPostProcessor#enhanceConfigurationClasses method to shorten startup time","The Version of the Spring Framework I used: 5.2.8  ConfigurationClassPostProcessor#enhanceConfigurationClasses method determines the @Configuration class in full mode: ![image](https://user-images.githubusercontent.com/18030368/92459323-1f26ab00-f1f9-11ea-8e29-1e88c18d41a9.png)  if `beanFactory.containsSingleton(beanName)` is true.The output info log tells me that the Bean cannot be enhanced，But it still puts it inside 'configBeanDefs'.And then execute `enhancer.enhance(configClass, this.beanClassLoader);` to enhance it.  Although,enhanced instances do not end up in the IoC container（Because it already exists in the container）.But it's semantically inconsistent.It also creates unnecessary overhead in terms of performance.Slow application startup.  For example：  1、Define a @Configuration class `AppConfig`: ```java @Configuration public class AppConfig {          @Bean     public BeanDefinitionRegistryPostProcessor postProcessor() {         return new BeanDefinitionRegistryPostProcessor() {             @Override             public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {             }              @Override             public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {             }         };     }  } ``` 2、debug run Spring container.Screenshot as follows: ![image](https://user-images.githubusercontent.com/18030368/92462839-978f6b00-f1fd-11ea-9b96-3ea7514f2ec6.png)   ![image](https://user-images.githubusercontent.com/18030368/92460295-62354e00-f1fa-11ea-983d-7240ab0b816c.png)  Console log： ![image](https://user-images.githubusercontent.com/18030368/92460385-809b4980-f1fa-11ea-95d8-58890b6c0bc2.png)  The log says that `AppConfig` will not be enhanced.But the enhanced logic is actually executed,and there are contradictions.  Solution：I think the following changes can be made to the code to avoid unnecessary performance losses and speed up startup ```java public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {     ... 			if (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) { 				if (!(beanDef instanceof AbstractBeanDefinition)) { 					throw new BeanDefinitionStoreException(""Cannot enhance @Configuration bean definition '"" + 							beanName + ""' since it is not stored in an AbstractBeanDefinition subclass""); 				} 				else if (logger.isInfoEnabled() && beanFactory.containsSingleton(beanName)) { 					logger.info(""Cannot enhance @Configuration bean definition '"" + beanName + 							""' since its singleton instance has been created too early. The typical cause "" + 							""is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor "" + 							""return type: Consider declaring such methods as 'static'.""); 				}                                  else {                                         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);                                 } 				 			}     ... } ``` Just make `configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);` at the independent `else` branch.","open","in: core,","yourbatman","2020-09-08T10:01:17Z","2021-11-12T12:08:08Z"
"","25608","Remove session on 4xx response from WebSocket handshake","The sockjs session will be removed after websocket handshake request failed, therefore the next downgrade session could be created.","closed","type: bug,","yfei-z","2020-08-18T04:51:57Z","2020-09-07T20:43:32Z"
"","25318","Remove unnecessary assignments","The setting methods of the two fields declare that the default value is `false`. So, maybe the assignments should be removed.","closed","","diguage","2020-06-26T02:51:25Z","2022-02-18T19:06:54Z"
"","25056","Avoid StringBuilder.append(Object) in ContentDisposition","The return type of expression `(c == '""' && !escaped) ? ""\\\"""" : c` is `Object`, which implies a call to `StringBuilder.append(Object)`.  The implementation of the following means that lots of garbage objects are allocated as a result of `String.valueOf()`.   ```java @Override public StringBuilder append(Object obj) {     return append(String.valueOf(obj)); } ```  Instead of covariant append we can use exact signatures, i.e. one taking `char` and one taking `String` which allows us to avoid unnecessary allocations.  This [benchmark](https://raw.githubusercontent.com/stsypanov/strings/master/src/jmh/java/tsypanov/strings/string/StringBuilderCovariantAppendBenchmark.java) demonstrates significant improvement even for filename of length = 10:  ``` JDK 8  Benchmark                              (latin)  (length)  Mode  Cnt     Score     Error   Units appendCovariant                           true        10  avgt   50   180.230 ±  10.346   ns/op appendExact                               true        10  avgt   50    68.517 ±   1.479   ns/op  appendCovariant                          false        10  avgt   50   177.713 ±   4.438   ns/op appendExact                              false        10  avgt   50    67.798 ±   1.364   ns/op  appendCovariant:·gc.alloc.rate.norm       true        10  avgt   50   688.000 ±   0.001    B/op appendExact:·gc.alloc.rate.norm           true        10  avgt   50   112.000 ±   0.001    B/op  appendCovariant:·gc.alloc.rate.norm      false        10  avgt   50   816.000 ±   0.001    B/op appendExact:·gc.alloc.rate.norm          false        10  avgt   50   112.000 ±   0.001    B/op  JDK 14  Benchmark                              (latin)  (length)  Mode  Cnt     Score     Error   Units appendCovariant                           true        10  avgt   50   228.858 ±  18.627   ns/op appendExact                               true        10  avgt   50    57.950 ±   2.660   ns/op  appendCovariant                          false        10  avgt   50   292.879 ±  12.408   ns/op appendExact                              false        10  avgt   50    90.228 ±   2.277   ns/op  appendCovariant:·gc.alloc.rate.norm       true        10  avgt   50   688.026 ±   0.002    B/op appendExact:·gc.alloc.rate.norm           true        10  avgt   50   112.004 ±   0.001    B/op  appendCovariant:·gc.alloc.rate.norm      false        10  avgt   50  1096.040 ±   0.002    B/op appendExact:·gc.alloc.rate.norm          false        10  avgt   50   200.008 ±   0.001    B/op ```","closed","type: task,","stsypanov","2020-05-12T13:00:50Z","2020-05-22T14:50:12Z"
"","24934","Upgrade to RSocket 1.0 RC7","The release is expected tomorrow and includes a new `RSocketConnector` and `RSocketServer` API replacements for `RSocketFactory` which is deprecated.","closed","type: dependency-upgrade,","rstoyanchev","2020-04-19T16:54:08Z","2020-04-28T05:29:01Z"
"","25686","Deprecate JdbcUtils.extractDatabaseMetaData(DataSource, String)","The reflective variant of `extractDatabaseMetaData` should be deprecated in favor of the callback-driven one which can be conveniently used with a Java 8 lambda expression or method reference.  Additionally, the `DatabaseMetaDataCallback` interface and the corresponding `JdbcUtils.extractDatabaseMetaData(DataSource, DatabaseMetaDataCallback)` utility method do not declare a generic return type yet... in contrast to the reflective variant.","closed","type: task,","jhoeller","2020-09-03T11:12:10Z","2020-09-03T17:22:53Z"
"","25090","@Controller which extends base generic abstract controller and implements interface with @RequestMapping has mapped only pure generic types","The problem is when controller extends base generic abstract class and implements interface with `@RequestMapping` it has mapped only those methods which signature have pure generic type. Other methods mapped only if controller's subclass overrides those methods.  To represent an issue, lets imagine the following project structure ([or visit this example repo](https://github.com/averude/spring-generic-controller-issue)): Generic repository interface:  ```java public interface IRepository {     Optional get(Long id);     List getALl();     T save(T t); } ``` …its implementation:  ```java @Component public class IntegerRepository implements IRepository {     @Override     public Optional get(Long id) {         return Optional.of(10);     }      @Override     public List getALl() {         return Arrays.asList(10,20,30);     }      @Override     public Integer save(Integer integer) {         return integer;     } } ``` Generic abstract controller class: ```java public abstract class AController {      private IRepository repository;      public AController(IRepository repository) {         this.repository = repository;     }      public Optional get(Long id) {         return repository.get(id);     }      public List getAll() {         return repository.getALl();     }      public T post(T t) {         return repository.save(t);     } } ``` Controller interface: ```java @RequestMapping(""/integers"") public interface IntegerController {     @RequestMapping(method = RequestMethod.GET, value = ""/{id}"")     Optional get(@PathVariable Long id);      @RequestMapping(method = RequestMethod.GET)     List getAll();      @RequestMapping(method = RequestMethod.POST)     Integer post(@RequestBody Integer t); } ``` …and its implementation: ```java @RestController public class IntegerControllerImpl extends AController implements IntegerController {     @Autowired     public IntegerControllerImpl(IntegerRepository repository) {         super(repository);     } } ``` In this case Spring doesn’t map controller’s get() and getAll() methods but post() do. > 2020-05-16 09:44:51.347 TRACE 5437 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping :     c.a.s.c.IntegerControllerImpl:  {POST /integers}: post(Integer)  The only way to make it work is to override base controller's GET methods.  ```java @RestController public class IntegerControllerImpl extends AController implements IntegerController {     @Autowired     public IntegerControllerImpl(IntegerRepository repository) {         super(repository);     }      @Override     public Optional get(Long id) {         return super.get(id);     }      @Override     public List getAll() {         return super.getAll();     } } ```  > 2020-05-16 13:54:12.843 TRACE 5914 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping :  > c.a.s.c.IntegerControllerImpl: > {GET /integers/{id}}: get(Long) > {GET /integers}: getAll() > {POST /integers}: post(Integer)","open","in: web,","averude","2020-05-16T18:17:58Z","2022-07-25T08:52:19Z"
"","25767","Fix typo in Regular Expression Pointcuts docs","The paragraph describes the behavior of one pointcut, so it's obviously a typo here.","closed","in: core,","xak2000","2020-09-14T12:11:39Z","2020-09-14T19:01:39Z"
"","25123","MonoToListenableFutureAdapter should not be in the package:org.springframework.util.","The package {@code org.springframework.util} is the lowest-level abstraction for jdk。  I think the package  should not be dependent on any third-party libraries.","closed","","zinu-x","2020-05-25T08:20:22Z","2020-05-25T08:54:42Z"
"","25379","Deprecate remoting technologies support","The original issue here was closed https://github.com/spring-projects/spring-framework/issues/24434 and I think this needs to be brought back up again.  @bclozel made a few valid points: ``` Doing this would be a breaking change and we would need to create a new artifact for that. This is typically the type of change we apply for major releases.  These classes have been part of spring-web since Spring Framework 1.1.  I guess it's hard to balance the severity of the issue and the amount of unsafe setup required to trigger it. Tools warning about such vulnerabilities don't usually have that context and they can only convey more information to users about the context of this vulnerability.  In this case, and especially since this new warning seems to be a misunderstanding, I don't think we should move this code now. ```  The issue was closed but I think this issue should be opened and accounted for at least for the next major release of the spring framework which @bclozel had mentioned as a viable option. Before closing this ticket out it would be nice if there was a set plan on how to handle this in future major releases of spring-framework.  I did fork the spring-framework repo and split the rmi code into a new module `spring-rmi' and this isn't a difficult thing to do and making this part of a major release would be nice as when people upgrade to 6.x they can accommodate for this code no longer being in spring-web. https://github.com/mbazos/spring-framework/tree/feature/split-remoting-to-new-module","closed","type: task,","mbazos","2020-07-09T16:10:44Z","2022-07-08T02:23:23Z"
"","25429","Fix infinite loop bug in AnnotationScanner","The original code `isFiltered(source, context, classFilter)` when true,  would cause  dead circle. Maybe new code is right.","closed","status: feedback-provided,","yilianhuaixiao","2020-07-20T09:40:31Z","2020-07-28T07:43:27Z"
"","25628","Update signature of MessageSource.getMessage() methods","The methods `getMessage()` in MessageSource.java accept their arguments as an array of `Object`s:  https://github.com/spring-projects/spring-framework/blob/8047a0bb784087ae9699680017ebb5a43d77a5b7/spring-context/src/main/java/org/springframework/context/MessageSource.java#L74  By changing the type of `args` to be a vararg variable instead of being an explicit array, users can call the method without having to create an array and pass it around. Also messages often do not require any arguments so this change makes it easy to call the methods without arguments (instead of passing null or an empty array).  What I'm suggesting is something like this:  ```java String getMessage(String code, Locale locale, Object... args) throws NoSuchMessageException; ```  **Affects:** \","open","in: core,","mahozad","2020-08-22T07:26:11Z","2022-05-23T08:39:20Z"
"","25082","Cannot update log level of SimpleBrokerMessageHandler using actuator","The log level used by `SimpleBrokerMessageHandler` cannot be updated via actuator. When debugging, it seems that it uses a `org.springframework.core.log.CompositeLog` that determines the log levels when creating the instance. This means that the only way to increase the logging level is to stop the server and update the configuration.  As a workaround, we can start the server with a higher logging level and then reduce it using actuator once server has started.  **Affects:** spring-messaging 5.2.5.RELEASE","open","in: messaging,","nickcaballero-mm","2020-05-14T17:05:58Z","2021-11-12T12:11:44Z"
"","25401","Improve UriComponents.sanitizeSource()","The length of sanitized URI is either the same, or less than original one, so we can use `char[]` to reduce overhead brought by `StringBuilder`.","closed","type: enhancement,","stsypanov","2020-07-17T09:25:32Z","2020-08-10T20:11:01Z"
"","24932","Deprecate AnnotationFilter.NONE (since MergedAnnotations always filters java.lang.* annotations)","The following test case ```java @Test void deprecatedAnnotationShouldBeFoundIfFilterIsNone() {     List deprecatedAnnotations = MergedAnnotations.from(             TestClass.class,             MergedAnnotations.SearchStrategy.DIRECT,             RepeatableContainers.standardRepeatables(),             AnnotationFilter.NONE // That should include java.lang.* annotations?!     ).stream(Deprecated.class).collect(Collectors.toList());     assertThat(deprecatedAnnotations).hasSize(1); // fails! } @java.lang.Deprecated private static class TestClass {     // just for testing } ``` fails although I've specified `AnnotationFilter.NONE` instead of the default `AnnotationFilter.PLAIN` filter option. I'd expect the annotation to be found (and thus the I expect the list to contain one element instead of being empty).  I suspect this is a bug since as a user of the MergedAnnotations API I expect that the `AnnotationFilter.NONE` returns all possible annotations, even if they're part of `java.lang` package.   I think I tracked the problem down to the following method `org.springframework.core.annotation.AnnotationsScanner#isIgnorable`: ```java private static boolean isIgnorable(Class annotationType) {     return AnnotationFilter.PLAIN.matches(annotationType); } ``` which is used when getting the list of annotations from the annotated element in `org.springframework.core.annotation.AnnotationsScanner#getDeclaredAnnotations(java.lang.reflect.AnnotatedElement, boolean)`. However, I'm no expert for this part of the framework and I might be that I'm mistaken if that's the origin of the bug.  I don't know how to propose a fix for this and why this `isIgnorable` method is used, but I hope you agreed that this is a bug or at least unexpected behavior for using the filter option `NONE`.  Also note that this bug is usually hidden by a shortcut in for example `org.springframework.core.annotation.AnnotationUtils#findAnnotation`: ```java // Shortcut: directly present on the element, with no merging needed? if (AnnotationFilter.PLAIN.matches(annotationType) || 		AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) { 	return annotatedElement.getDeclaredAnnotation(annotationType); } ``` So either the comment is not correct that this is just a shortcut but actually also finding annotations matching `PLAIN`, or the MergedAnnotations API has a bug, as explained above.   Background: I'm working on a Spring-based library and would like to find a bunch of annotations, some of them mergable, but some not. I wouldn't like to use different search utilities and always use the MergedAnnotations API, no matter what kind of annotation I'm looking for within my library.  Thanks a lot for investigating!","closed","in: core,","neiser","2020-04-19T09:18:15Z","2020-05-03T08:48:08Z"
"","24847","Consider Hidden classes use cases","The feature called Hidden classes has been officially marked as a candidate for Java 15 which will reach general availability by the 15 september of this year.  Hidden classes are a feature that I think is specifically made for frameworks like spring.   You have far more expertise than me for considering what could be the use cases/benefits/optimizations that this feature could provide on spring, when detecting at runtime that the user supports Java 15.  https://openjdk.java.net/jeps/371  It might be used for beans or any other kind of dynamically generated classes.  Edit: BTW you could propose, influence the design of the feature while it can still change.","open","in: core,","LifeIsStrange","2020-04-02T10:26:28Z","2021-11-12T13:35:07Z"
"","24888","@value doesn't support Map type where read properties from yml","the error message is No converter found capable of converting from type [java.util.Collections$UnmodifiableMap] to type [java.lang.String]","closed","","zqxin45","2020-04-09T11:08:00Z","2020-04-14T10:57:12Z"
"","25044","javadoc: remove a comment documented a limitation on @Lookup annotation","The documentation on @Lookup annotation reads:  > When used with component scanning or any other mechanism that filters out abstract > beans, provide stub implementations of your lookup methods to be able to declare > them as concrete classes.  However it looks like it's possible to define an abstract class, annotated with @Component, with an abstract @Lookup-annotated method, and have Spring replace it with a concrete implementation. So this limitation doesn't seem to hold any longer.","closed","in: core,","urisimchoni","2020-05-10T18:29:23Z","2020-05-18T17:11:46Z"
"","25384","Add unsatisfied parameter name and parameter value to UnsatisfiedServletRequestParameterException","The current structure of `UnsatisfiedServletRequestParameterException` does not provide custom exception handlers with enough flexibility in producing response bodies.  For example, assuming that we have the following two controllers:  ```java @RestController public class Controller1 {      @PostMapping(         params = ""action=foo""     )     public ResponseEntity handle(...) {      }  }  @RestController public class Controller2 {      @PostMapping(         params = ""action=bar""     )     public ResponseEntity handle(...) {      }  } ```  In response to an invalid action parameter such as `xxx`, a developer may want to handle the resulting  `UnsatisfiedServletRequestParameterException` and respond with a message like this:  ```json {     ""message"" : ""Invalid parameter"",     ""parameterName"" : ""action"",     ""parameterValue"" : ""xxx"" } ```  However at the moment there's not a straightforward, clean, and elegant option to produce such a custom message.  Another current option, which is also not clean, is to extend `RequestMappingInfoHandlerMapping`' and override its `handleNoMatch` method, but this method combines handling of different types of mismatches and overriding it would require copy/pasting the entire method body and changing the `if (helper.hasParamsMismatch()) {` clause:  ```java 	/** 	 * Iterate all RequestMappingInfo's once again, look if any match by URL at 	 * least and raise exceptions according to what doesn't match. 	 * @throws HttpRequestMethodNotSupportedException if there are matches by URL 	 * but not by HTTP method 	 * @throws HttpMediaTypeNotAcceptableException if there are matches by URL 	 * but not by consumable/producible media types 	 */ 	@Override 	protected HandlerMethod handleNoMatch( 			Set infos, String lookupPath, HttpServletRequest request) throws ServletException {  		PartialMatchHelper helper = new PartialMatchHelper(infos, request); 		if (helper.isEmpty()) { 			return null; 		}  		if (helper.hasMethodsMismatch()) { 			Set methods = helper.getAllowedMethods(); 			if (HttpMethod.OPTIONS.matches(request.getMethod())) { 				HttpOptionsHandler handler = new HttpOptionsHandler(methods); 				return new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD); 			} 			throw new HttpRequestMethodNotSupportedException(request.getMethod(), methods); 		}  		if (helper.hasConsumesMismatch()) { 			Set mediaTypes = helper.getConsumableMediaTypes(); 			MediaType contentType = null; 			if (StringUtils.hasLength(request.getContentType())) { 				try { 					contentType = MediaType.parseMediaType(request.getContentType()); 				} 				catch (InvalidMediaTypeException ex) { 					throw new HttpMediaTypeNotSupportedException(ex.getMessage()); 				} 			} 			throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList(mediaTypes)); 		}  		if (helper.hasProducesMismatch()) { 			Set mediaTypes = helper.getProducibleMediaTypes(); 			throw new HttpMediaTypeNotAcceptableException(new ArrayList(mediaTypes)); 		}  		if (helper.hasParamsMismatch()) { 			// CHANGE HERE 			List conditions = helper.getParamConditions(); 			throw new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap()); 		}  		return null; 	} ```  It would be nice if `RequestMappingInfoHandlerMapping` was implementing the strategy pattern so we could inject custom strategies for handling ""method mismatch"", ""consumes mismatch"", ""produces mismatch"", and ""params mismatch"" and throwing custom exceptions from our custom strategies.","open","type: enhancement,","behrangsa","2020-07-13T00:00:25Z","2020-07-27T15:54:52Z"
"","25521","Allow to access the underlying ConnectionFactory from DatabaseClient","The current API does not allow one to get access to the `ConnectionFactory` a `DatabaseClient` uses. This would avoid some potential inconsistencies when we need to access the `ConnectionFactory` (typically to detect the dialect to use).  See also https://github.com/spring-projects/spring-boot/issues/22708#issuecomment-668125351","closed","type: enhancement,","snicoll","2020-08-04T09:04:33Z","2020-08-04T09:48:27Z"
"","25849","JettyClientHttpConnector triggers early cancellation","The connector uses `Mono.from(Publisher)` to obtain Jetty's `ReactiveResponse`. However it also cancels after the first item and is meant for use with a `Publisher` that can produce a sequence. We need to use `Mono.fromDirect` instead which does not cancel the upstream since in this case we only expect one item.  This will help with https://github.com/jetty-project/jetty-reactive-httpclient/issues/22 so that the Jetty reactive client can abort the request in case of a cancel signal.","closed","type: bug,","rstoyanchev","2020-10-01T17:38:30Z","2020-10-02T13:40:11Z"
"","24914","Unnecessary iteration in PostProcessorRegistrationDelegate's invokeBeanFactoryPostProcessors()","the code in /org/springframework/context/support/PostProcessorRegistrationDelegate.java:82  ```java List currentRegistryProcessors = new ArrayList();  // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames =         beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) {     if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {         currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));         processedBeans.add(ppName);     } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear();  // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) {     if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {         currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));         processedBeans.add(ppName);     } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); ```  I think can use one For instead of two For. ```java List priorityOrderedRegistryProcessors = new ArrayList(); List orderedRegistryProcessors = new ArrayList();  String[] postProcessorNames =         beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) {     if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {         priorityOrderedRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));         processedBeans.add(ppName);     } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {         orderedRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));         processedBeans.add(ppName);     } }  // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedRegistryProcessors, beanFactory); registryProcessors.addAll(priorityOrderedRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(priorityOrderedRegistryProcessors, registry);  // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. sortPostProcessors(orderedRegistryProcessors, beanFactory); registryProcessors.addAll(orderedRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(orderedRegistryProcessors, registry); priorityOrderedRegistryProcessors = null; orderedRegistryProcessors = null;  ```","closed","in: core,","frf12","2020-04-16T05:55:56Z","2020-12-30T14:53:58Z"
"","24989","Fix race condition in WriteResultPublisher between subscription and completion in publishComplete","The bug I was experiencing was that sometimes with a WebFlux on Tomcat setup, responses were not being emitted (despite the Publisher being returned from my Controller methods completing successfully). Similar to https://github.com/spring-projects/spring-framework/issues/23096","closed","type: bug,","danielra","2020-04-28T17:38:41Z","2020-05-04T09:59:13Z"
"","24927","""http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"" is not accessible and cause application fails to start-up","The below is the stack trace  > ([DEBUG]) o.s.b.f.x.ResourceEntityResolver: Could not resolve XML entity [http://www.springframework.org/schema/beans/spring-beans-4.3.xsd] through URL [[https:](url) //www.springframework.org/schema/beans/spring-beans-4.3.xsd] javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative DNS name matching www.springframework.org found.         at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)         at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1964)         at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:328)         at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:322)         at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1614)         at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)         at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1052)         at sun.security.ssl.Handshaker.process_record(Handshaker.java:987)         at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1072)         at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1385)         at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1413)         at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1397)         at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:559)         at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:185)         at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1564)         at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1492)         at sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:263)         at java.net.URL.openStream(URL.java:1045)         at org.springframework.beans.factory.xml.ResourceEntityResolver.resolveEntity(ResourceEntityResolver.java:118)         at org.apache.xerces.util.EntityResolverWrapper.resolveEntity(Unknown Source)         at org.apache.xerces.impl.XMLEntityManager.resolveEntity(Unknown Source)         at org.apache.xerces.impl.xs.XMLSchemaLoader.resolveDocument(Unknown Source)         at org.apache.xerces.impl.xs.XMLSchemaValidator.findSchemaGrammar(Unknown Source)         at org.apache.xerces.impl.xs.XMLSchemaValidator.handleStartElement(Unknown Source)         at org.apache.xerces.impl.xs.XMLSchemaValidator.startElement(Unknown Source)         at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source)         at org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher.scanRootElementHook(Unknown Source)         at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)         at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)         at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)         at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)         at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)         at org.apache.xerces.parsers.DOMParser.parse(Unknown Source)         at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source)         at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:77)         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadDocument(XmlBeanDefinitionReader.java:430)         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:388)         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336)         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:305)         at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188)         at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224)         at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195)         at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257)         at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128)         at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94)         at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:133)         at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:637)         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:522)         at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:144)         at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:85)         at com.egl.payment.Main.setupSpring(Main.java:55)         at com.egl.payment.Main.(Main.java:41) Caused by: java.security.cert.CertificateException: No subject alternative DNS name matching www.springframework.org found.         at sun.security.util.HostnameChecker.matchDNS(HostnameChecker.java:214)         at sun.security.util.HostnameChecker.match(HostnameChecker.java:96)         at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:455)         at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:436)         at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:200)         at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)         at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1596)","closed","","asdf913","2020-04-18T07:30:58Z","2020-04-18T13:38:50Z"
"","24931","WebClientHateoasConfiguration has runtime dependency upon spring-test","The `WebClientHateoasConfiguration` has a runtime dependency upon `spring-test`. I'm not sure if this is working as designed, but It is unusual for Spring applications to have to include spring-test as a runtime dependency. Usually spring-test is included as a test scope dependency only, which makes it unavailable at runtime.  **Steps to reproduce:** 1. [Create a Spring Boot 2.3.0.M4 project with webflux and hateoas dependencies](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.3.0.M4&packaging=jar&jvmVersion=1.8&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=webflux,hateoas) 2. Run with `mvn spring-boot:run` 3. Observe the following exception in the log: ``` java.lang.IllegalStateException: Failed to introspect Class [org.springframework.hateoas.config.WebClientHateoasConfiguration] from ClassLoader [jdk.internal.loader.ClassLoaders$AppClassLoader@277050dc] 	at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:481) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:358) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.util.ReflectionUtils.getUniqueDeclaredMethods(ReflectionUtils.java:414) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.lambda$getTypeForFactoryMethod$2(AbstractAutowireCapableBeanFactory.java:743) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1737) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryMethod(AbstractAutowireCapableBeanFactory.java:742) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:681) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:649) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1605) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:523) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:494) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:616) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:608) ~[spring-beans-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1242) ~[spring-context-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	at org.springframework.boot.SpringApplication.getExitCodeFromMappedException(SpringApplication.java:880) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at org.springframework.boot.SpringApplication.getExitCodeFromException(SpringApplication.java:868) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at org.springframework.boot.SpringApplication.handleExitCode(SpringApplication.java:855) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at org.springframework.boot.SpringApplication.handleRunFailure(SpringApplication.java:806) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:325) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.3.0.M4.jar:2.3.0.M4] 	at com.example.demo.DemoApplication.main(DemoApplication.java:10) ~[classes/:na] Caused by: java.lang.NoClassDefFoundError: org/springframework/test/web/reactive/server/WebTestClientConfigurer 	at java.base/java.lang.ClassLoader.defineClass1(Native Method) ~[na:na] 	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016) ~[na:na] 	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174) ~[na:na] 	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:800) ~[na:na] 	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:698) ~[na:na] 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:621) ~[na:na] 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:579) ~[na:na] 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) ~[na:na] 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[na:na] 	at java.base/java.lang.Class.getDeclaredMethods0(Native Method) ~[na:na] 	at java.base/java.lang.Class.privateGetDeclaredMethods(Class.java:3166) ~[na:na] 	at java.base/java.lang.Class.getDeclaredMethods(Class.java:2309) ~[na:na] 	at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:463) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE] 	... 21 common frames omitted Caused by: java.lang.ClassNotFoundException: org.springframework.test.web.reactive.server.WebTestClientConfigurer 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) ~[na:na] 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) ~[na:na] 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[na:na] 	... 34 common frames omitted ```","closed","for: external-project,","thorntonrp","2020-04-18T22:51:59Z","2020-04-19T07:31:03Z"
"","25681","SQLErrorCodesFactory.getErrorCodes(DataSource) returns empty error codes if access to transactional connection fails","The `SQLErrorCodes getErrorCodes(DataSource dataSource)` method of the `org.springframework.jdbc.support.SQLErrorCodesFactory` class is responsible for producing a `SQLErrorCodes` instance with a repository of vendor-specific `SQLException` error codes that are neatly categorized for Spring JDBC exception mapping.   For example, `duplicateKeyCodes` contains codes that will be mapped to `DuplicateKeyException`.  This is a great convenience for applications since they can work with a comprehensive and intuitive hierarchy of exceptions rather than vendor-specific error codes.  Unfortunately, `getErrorCodes` has fallback logic that can have dramatic and damaging side effects.   If a `SQLErrorCodes` instance is not yet cached for a particular `DataSource` then `getErrorCodes` creates one. It does so by first obtaining the ""database product name"" for the `DataSource`. Next it looks in a repository of error codes, keyed by database product name, for the target `SQLErrorCodes` instance. Lastly, that result is added to the cache by `DataSource`.  Unfortunately, obtaining the database product name is an operation on a JDBC connection and has many failure modes. For example, the thread-bound JDBC connection might have been closed for some reason.  Bizarrely,  `getErrorCodes` responds to such exceptions by simply producing an _empty_ `SQLErrorCodes` with no mapping at all. That's the best it can do if it _must_ return an `SQLErrorCodes` instance since it doesn't know the database engine. Unfortunately, this changes the expected behavior of upstream components like `JdbcTemplate`, which _caches_ the `SQLErrorCodes` in an `SQLErrorCodeSQLExceptionTranslator`. In other words, the exception corrupts the `JdbcTemplate` exception translator and the conveniences mentioned above go out the window!  Consider the following code snippet in a long-running application: ```java try {     jdbcTemplate.update(...); } catch (DuplicateKeyException e) {     // handle unique constraint violation } ```  Suppose a `SQLException` occurs due to a unique constraint violation with MySQL vendor code `1062`. The execution path above executes, resulting in a `SQLErrorCodes` instance that has code `1062` in the `duplicateKeyCodes` bucket. Spring JDBC translates that to a `DuplicateKeyException` and all is well!  However, suppose instead that the error path above occurs resulting in an empty `SQLErrorCodes`. Now code `1062` isn't represented at all and the exception translator has to employ fallback logic that results in a `DataIntegrityViolationException`. The exception is _not_ handled by the catch block and mayhem ensues.  This unpredictable behavior strikes me as extremely dangerous behavior.  In my case, it surfed in the production environment and had quite a noticeable impact.  Fortunately, a quick workaround is available by simply setting the exception translator and database product name up front. However, I didn't realize that until it was too late.  The issue can be trivially reproduced using a debug session in which the connection is closed. See attached screenshots.  ![Screen Shot 2020-09-02 at 8 43 38 PM](https://user-images.githubusercontent.com/221014/92069705-e56c2500-ed5e-11ea-9431-8cdf5652ac09.png) ![Screen Shot 2020-09-02 at 8 43 54 PM](https://user-images.githubusercontent.com/221014/92069708-ea30d900-ed5e-11ea-9d24-19495d00351b.png) ![Screen Shot 2020-09-02 at 8 44 11 PM](https://user-images.githubusercontent.com/221014/92069727-f321aa80-ed5e-11ea-9800-d13ee249fbb0.png) ![Screen Shot 2020-09-02 at 8 44 17 PM](https://user-images.githubusercontent.com/221014/92069738-f87ef500-ed5e-11ea-9519-7464256f7af3.png) ![Screen Shot 2020-09-02 at 8 44 50 PM](https://user-images.githubusercontent.com/221014/92069743-fddc3f80-ed5e-11ea-996a-cad29a41b18a.png) ![Screen Shot 2020-09-02 at 8 47 48 PM](https://user-images.githubusercontent.com/221014/92069753-05034d80-ed5f-11ea-9023-5db220009b37.png) ![Screen Shot 2020-09-02 at 8 46 42 PM](https://user-images.githubusercontent.com/221014/92069758-06cd1100-ed5f-11ea-966f-297300947436.png)","closed","type: bug,","ebarlas","2020-09-03T03:59:10Z","2022-06-07T10:21:16Z"
"","24908","Improve Javadoc","The `getBeanNamesOfType` method does not seem to exist, this looks like it should refer to the method called `getBeanNamesForType`.","closed","type: documentation,","chenqimiao","2020-04-15T04:04:36Z","2020-04-15T06:55:54Z"
"","25332","Support use of RSocketClient","The 1.1 M1 upgrade #25331 contains a new `RSocketClient` that is similar to the `RSocket` contract but does not represent a live connection. Rather it obtains a shared connection as needed when requests are made. So it is more comparable to `WebClient` as opposed to an HTTP connection.   We can investigate the possibility of `RSocketRequester.Builder` producing an `RSocketRequester` instance that wraps an `RSocketClient` vs the `Mono` returned from the `connect` method today.","closed","type: enhancement,","rstoyanchev","2020-06-29T13:59:52Z","2020-07-14T09:09:34Z"
"","25593","Kotlin extension function on Generics type + @Validated proxy class causes an ArrayIndexOutOfBoundsException","Thanks in advance for reading this issue. After thorough search in StackOverflow.com, I found nothing about this in there(for every combinations of keywords: `Spring`, `Kotlin extension`, `@Validated` `ArrayIndexOutOfBoundsException`). There is a workaround hopefully, but it would be great if this issue is solved as well!  While I was writing a Kotlin *Mixin*, I bumped into an `ArrayIndexOutOfBoundsException` caused by CGLIB proxied class. Spent around 30 minutes and found that this is because of a peculiar combination such as:  1. declare an Kotlin extension function that receiver type is using Java/Kotlin generics(MultiValueMap is in this case) ``` interface FetchCriteriaRequestMixin {      fun  MultiValueMap.toFetchCriteria(          sortByProvider: (sortBy: String?) -> SORT,          defaultSortDirection: SortDirection,          defaultPage: Int,          defaultFetchSizeRange: IntRange      ): ContentsFetchCriteria } ``` 2. let this method is exposed to `org.springframework.validation.annotation.Validated` annotated class which is to be a proxy target ``` @Validated interface GetRepliesController  @RestController internal class GetRepliesControllerImpl : GetRepliesController, FetchCriteriaRequestMixin  ``` 3. declare a spring-data-jpa dependency with Hibernate  Yet I couldn't found any solution for this, but there is a workaround which are 1. eliminate an extension function and make it as like plain Java utility method, 2. eliminate generics in receiver type of extension function.  I'm leaving my Github source code link for better bug reproduction.  [Mixin type - an original cause of this issue](https://github.com/FrancescoJo/spring-board-demo/blob/master/app-main/src/main/kotlin/com/github/fj/board/endpoint/common/FetchCriteriaRequestMixin.kt#L21) [`@Validated @RestController` that utilises this mixin](https://github.com/FrancescoJo/spring-board-demo/blob/master/app-main/src/main/kotlin/com/github/fj/board/endpoint/v1/reply/GetRepliesController.kt#L41)  Tested under:   * org.springframework.boot:spring-boot-starter:2.3.1.RELEASE (depends on Spring 5.2.7.RELEASE)   * javax.validation:validation-api:2.0.1.Final   * jakarta.servlet:jakarta.servlet-api:4.0.3   * org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.72   * org.jetbrains.kotlin:kotlin-allopen:1.3.72","open","in: kotlin,","FrancescoJo","2020-08-15T17:20:55Z","2022-01-19T10:52:44Z"
"","24937","'StandardEnvironment' Optimize.","Th's 'StandardEnvironment' constructor should show call parent constructor. (Improve reading)","closed","status: declined,","cherishsince","2020-04-20T08:03:31Z","2020-04-23T16:05:53Z"
"","24884","Provide a Mutable Clock in Spring Test Context Framework","Testing date based business logic is hard, since Spring is now based on Java 8 its possible to use java.time.Clock and mutable clock from [Three Ten Extra](https://www.threeten.org/threeten-extra/). It would be useful to include such a mutable clock in spring test context framework along with an injectable Clock that returns the default system clock. Below is code that implement this.   ```java /**  * A factory for obtaining an instance fo the java.util.clock that will be injected into by spring  * into any components that require a clock to know the current time.  */ public interface ClockProvider {   Clock clock(); } ```  ```java /** Default Clock provider for the application. It returns the same clock used by Instant.now() */ @Component class DefaultClockProvider implements ClockProvider {    @Override   public Clock clock() {     return Clock.systemUTC();   } } ``` notice  that I have to use `@Primary` and `@TestFixtureComponent` on my test fixture implementation that provides a jsr 310 extras mutable clock.  ```java @Primary @TestFixtureComponent class TestClockProvider implements ClockProvider {   private final Logger logger = LoggerFactory.getLogger(TestClockProvider.class);    @PostConstruct   void init() {     logger.warn(""** ++ TestClockProvider with a Mutable Clock In Use ++ **"");   }    @Override   public Clock clock() {     return MutableClock.of(Instant.now(), ZoneOffset.UTC);   } } ```  There is also a `@Configuration` class to create a Clock Bean so that my code can just inject a java.util.Clock where it needs to know the current time. This class is in `src/main/java`  ```java @Configuration class ClockConfig {   @Bean   Clock clock(ClockProvider clockProvider) {     return clockProvider.clock();   } } ```  TimeMachine class below can be autowired into test classes and used to move the clock forwards, backwards ... etc.   ``` java  @TestFixtureComponent @ConditionalOnBean(TestClockProvider.class) public class TimeMachine {   private final MutableClock clock;    public TimeMachine(Clock clock) {     this.clock = (MutableClock) clock;   }    /**    * Advanced the clock used by the application by a certain number of seconds.    *    * @param seconds the number of seconds to advance the clock by    */   public void advanceSeconds(long seconds) {     this.clock.add(Duration.ofSeconds(seconds));   } } ```  A lot of business logic does date and time comparisons injection of a clock is the recommended way to do this in Java 8 and above.  Adding Spring support for virtual clock is quite useful.","closed","status: feedback-provided,","asaikali","2020-04-09T04:30:02Z","2020-04-13T12:59:56Z"
"","25829","Cannot test @RequestPart multipart controllers with Servlet MockPart","Tested with spring boot 2.3.4. [Example project](https://github.com/dimone-kun/multipart-test-demo)  We have controller that receives some arguments that are parts of multipart request.  ```java @RestController class HelloWorldController {     @RequestMapping(path = ""helloworld"", method = RequestMethod.POST)     @ResponseStatus(code = HttpStatus.OK)     public String helloWorld(@RequestPart(name = ""part0"") String str0,                              @RequestPart(name = ""part1"") String str1) {         return str0+str1;     } } ``` For running application request works as intended: ```http POST http://localhost:8080/helloworld Content-Type: multipart/form-data; boundary=6512c604-1edc-4c15-8916-dc2e91413c82  --6512c604-1edc-4c15-8916-dc2e91413c82 Content-Disposition: form-data;name=""part0"" Content-Type: text/plain  Hello --6512c604-1edc-4c15-8916-dc2e91413c82 Content-Disposition: form-data;name=""part1"" Content-Type: text/plain  World --6512c604-1edc-4c15-8916-dc2e91413c82--  ## response HelloWorld ```  Now we want to test it: ```java @Test void helloWorldTest() throws Exception {         MockPart part0 = new MockPart(""part0"", ""Hello"".getBytes());         part0.getHeaders().setContentType(MediaType.TEXT_PLAIN);         MockPart part1 = new MockPart(""part1"", ""World"".getBytes());         part1.getHeaders().setContentType(MediaType.TEXT_PLAIN);          web.perform(multipart(""/helloworld"")                 .part(part0, part1))                 .andExpect(status().isOk())                 .andExpect(content().string(""HelloWorld"")); } ``` But test is failing with NPE exception: ``` Request processing failed; nested exception is java.lang.NullPointerException org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652) Caused by: java.lang.NullPointerException 	at org.springframework.web.multipart.support.RequestPartServletServerHttpRequest.getBody(RequestPartServletServerHttpRequest.java:99) ```  The reason behind that is `org.springframework.web.multipart.support.RequestPartServletServerHttpRequest:84`; it's expecting `StandardMultipartHttpServletRequest` in `multipartRequest` field but got `MockMultipartHttpServletRequest`: ```java public InputStream getBody() throws IOException {     if (this.multipartRequest instanceof StandardMultipartHttpServletRequest) {         try {             return this.multipartRequest.getPart(this.partName).getInputStream();         }         catch (Exception ex) {             throw new MultipartException(""Could not parse multipart servlet request"", ex);         }     }      } ```","closed","type: enhancement,","dimone-kun","2020-09-28T14:09:30Z","2020-10-12T16:42:36Z"
"","25340","Profiles should be comparable when created via Profiles.of()","Suppose we have this code in production:  ```java private boolean isExternalProfileEnabled() {   return environment.acceptsProfiles(Profiles.of(""external"")); } ```  Then I want to mock this in tests and I write something like:  ```java when(environment.acceptsProfiles(Profiles.of(""external""))).thenReturn(true); ```  And at runtime the mock fails to return `true`, because comparison of arguments fails due to missing `equals()` and `hashCode()` implementations in `ParsedProfiles`.  This makes us use the deprecated API and rewrite the example code like:  ```java private boolean isExternalProfileEnabled() {   return environment.acceptsProfiles(""external""); } ```  and use of the deprecated API in turn makes Sonar unhappy.","closed","type: enhancement,","stsypanov","2020-06-30T08:56:22Z","2020-07-07T12:19:43Z"
"","25489","specify null and zero length data","String: length of zero and null value are not same. but, this code return null when string has length of zero.  So, I think it need to be more specific. if the parameter String(source) value is null -> then NullPointException is occured (automatically). and if String length is not valid (that is length is not 1) -> then IllegalArgumentException ocurred by the code.  Please check and leave a comment. thank you.","closed","","minuk8932","2020-07-29T10:08:32Z","2022-02-18T19:06:22Z"
"","25562","Lazy dependency proxy does not populate bean dependencies","Start off with the latest **spring-petclinic** project based on Boot 2.3.x Launch the app and see the JSON response for `/actuator/beans` Search for `OwnerController` bean. This bean should depend on `OwnerRepository` and `PetRepository`. The JSON for the bean however is this: ```         ""ownerController"": {           ""aliases"": [],           ""scope"": ""singleton"",           ""type"": ""org.springframework.samples.petclinic.owner.OwnerController"",           ""resource"": ""file [/Users/aboyko/Documents/runtime-sts4/spring-petclinic/target/classes/org/springframework/samples/petclinic/owner/OwnerController.class]"",           ""dependencies"": []         }, ```  If **spring-petclinic** is switched to Boot 2.2.x then the dependencies are detected correctly: ```         ""ownerController"": {           ""aliases"": [],           ""scope"": ""singleton"",           ""type"": ""org.springframework.samples.petclinic.owner.OwnerController"",           ""resource"": ""file [/Users/aboyko/Documents/runtime-sts4/spring-petclinic/target/classes/org/springframework/samples/petclinic/owner/OwnerController.class]"",           ""dependencies"": [             ""ownerRepository"",             ""visitRepository""           ]         }, ```  Something is off in the framework as **actuator** simply calls `org.springframework.beans.factory.config.ConfigurableBeanFactory.getDependenciesForBean(String)`  Try this in the `org.springframework.samples.petclinic.PetClinicApplication` for the **main** method:  ``` 	public static void main(String[] args) { 		ConfigurableApplicationContext context = SpringApplication.run(PetClinicApplication.class, args);  		final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);  		final Runnable printDependnecies = new Runnable() { 			public void run() { 				String[] dependenciesForBean = context.getBeanFactory().getDependenciesForBean(""ownerController""); 				 				if (dependenciesForBean.length == 0) { 					System.out.println(""no dependencies!!!""); 				} else { 					System.out.println(""Dependencies:""); 					for (String dep : dependenciesForBean) { 						System.out.println(dep); 					} 					System.out.println(); 				} 			} 		};  		scheduler.scheduleAtFixedRate(printDependnecies, 10, 10, TimeUnit.SECONDS);  	} ```  You'd see that there are no dependencies returned in the Boot 2.3.x case.","closed","in: core,","BoykoAlex","2020-08-07T15:32:12Z","2020-11-10T22:53:46Z"
"","25821","SimpMessagingTemplate.convertAndSend results in UnsupportedOperationException when Spring Cloud Sleuth is present","springboot version: 2.1.3 spring-websocket version: 5.1.1 spring-cloud-sleuth version: 2.1.1  When I try to use SimpMessagingTemplate.convertAndSend to send a String message to the websocket client after adding spring cloud sleuth to the application, an exception occurs:  ``` Caused by: java.lang.UnsupportedOperationException: null 	at java.util.Collections$UnmodifiableMap.remove(Collections.java:1460) 	at org.springframework.messaging.support.NativeMessageHeaderAccessor.removeNativeHeader(NativeMessageHeaderAccessor.java:209) 	at org.springframework.cloud.sleuth.instrument.messaging.MessageHeaderPropagation.removeAnyTraceHeaders(MessageHeaderPropagation.java:86) 	at org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.preSend(TracingChannelInterceptor.java:173) 	at org.springframework.messaging.support.AbstractMessageChannel$ChannelInterceptorChain.applyPreSend(AbstractMessageChannel.java:178) 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:132) 	... 123 common frames omitted ```  some primary code belows: ``` @RequestMapping(value = ""/ws/reply"", method = RequestMethod.GET) public String msgReply(@RequestParam String msg) { 	System.out.println(msg); 	template.convertAndSend(""/riten_ws_topic"", msg); 	return msg; } ```  ``` @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { 	@Override 	public void configureMessageBroker(MessageBrokerRegistry config) { 		config.enableSimpleBroker(""/riten_ws_topic""); 		config.setApplicationDestinationPrefixes(""/riten_ws_client""); 	} 	@Override 	public void registerStompEndpoints(StompEndpointRegistry registry) { 		registry.addEndpoint(""/riten_ws_server"").setAllowedOrigins(""*"").withSockJS(); 	} } ```","closed","type: bug,","rogue2yjg","2020-09-26T12:41:26Z","2020-09-30T21:11:22Z"
"","25502","Redis Reactive:Update Cache Fails","Spring_boot_version = '2.3.1.RELEASE'  **what works**    **Update Redis using Jedis**  ```         val jedis = Jedis(""localhost"")         println(""Connection successful"")         println(""Connection successful""+jedis.ping())         jedis.set(""cacheKey"", cacheValue);         println(""Cache Value-""+jedis.get(""cacheKey"")) ```  **Get Using reactive redis Template--Successful**  `redisTemplate.opsForValue().get(""cacheKey"")`   **What Fails**  **Update cache using reactive redisTemplate**  `redisTemplate.opsForValue().set(cacheKey , cacheValue , Duration.ofSeconds(10s))`  **Get Using reactive redis Template--Failed** ` redisTemplate.opsForValue().get(""cacheKey"")`     **Redis Configuration**     ``` @Configuration @ConditionalOnClass(     ReactiveRedisTemplate::class,     RedisConnectionFactory::class,     LettuceConnectionFactory::class,     ReactiveRedisConnectionFactory::class ) open class RedisConfiguration `{`      @Bean     open fun reactiveRedisConnectionFactory(): ReactiveRedisConnectionFactory {         return LettuceConnectionFactory()     }      @Bean     open fun reactiveRedisConnection(redisConnectionFactory: ReactiveRedisConnectionFactory): ReactiveRedisConnection     {         return redisConnectionFactory.reactiveConnection     }      @Bean     open fun reactiveRedisTemplateString(@Qualifier(""redisCache"") connectionFactory: ReactiveRedisConnectionFactory?): ReactiveRedisTemplate {         return ReactiveRedisTemplate(             connectionFactory,             RedisSerializationContext.string()         )     }   } ```    Do i have to add any additional steps in order to update redis cache using redis reactive?  Link to stack overflow: https://stackoverflow.com/questions/63195783/redis-reativecache-update-fails","closed","for: stackoverflow,","upen4a3","2020-07-31T16:31:24Z","2020-07-31T17:01:02Z"
"","25299","spel ,i can't get value when the expression is like '01'","spring-expression-5.1.3.RELEASE  ---  ```java ExpressionParser parser = new SpelExpressionParser() StandardEvaluationContext context = new StandardEvaluationContext(); Record record = new Record(); record.put(""name"",""scl"");  record.put(""2"",""22"");  record.put(""03"",""33"");  context.setRootObject(record); parser.parseExpression(""[a]"").getValue(context);//11 parser.parseExpression(""[2]"").getValue(context);//22 parser.parseExpression(""[03]"").getValue(context);//null ```","closed","for: stackoverflow,","sucls","2020-06-22T10:43:12Z","2020-06-22T10:57:05Z"
"","25188","Spring not showing reason in RuntimeException class","Spring version: 2.3.0.RELEASE Java Version: 8  I'm trying to handle de reason of a excetopn class: ```java @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = ""Cartão inválido"")     public class CartaoDebitoInvalidException extends RuntimeException { } ```  In my service class I call the exception this way:  ```java throw new CartaoDebitoInvalidException(); ```  But the reason is noa appearing in the response:   ```json {     ""timestamp"": ""2020-06-05T00:12:37.391+0000"",     ""status"": 404,     ""error"": ""Not Found"",     ""message"": """",     ""path"": ""/pagar_debito"" } ```  Note: It works in version 2.2.7.RELEASE","closed","status: invalid,","RochaKaique","2020-06-05T00:21:37Z","2020-06-05T08:11:14Z"
"","25392","JndiObjectFactoryBean lacks lazyInit field defined in spring-jee.xsd for jndi-lookup","Spring version 5.2.5.RELEASE. http://www.springframework.org/schema/jee/spring-jee.xsd defines ""**lazy-init**"" property for ""**jndiLocatingType**"" complex type. ""**jndi-lookup**"" defined as ""**jndiLocatingType**"", but JndiObjectFactoryBean doesn't have such field nor setter. That result in NotWritablePropertyException during bean instantiation: _Invalid property 'lazyInit' of bean class [org.springframework.jndi.JndiObjectFactoryBean]: Bean property 'lazyInit' is not writable or has an invalid setter method._","closed","status: invalid,","tolyan","2020-07-15T13:56:58Z","2020-10-14T06:18:23Z"
"","24945","Support for PathPatternParser in Spring MVC","Spring MVC has always used `AntPathMatcher` but the use of patterns has grown over time with annotated controllers and URI variables present in most patterns. This is why for WebFlux we introduced `PathPatternParser` and the parsed `PathPattern` representation which enables more efficient path matching.  This issue is to add support for using `PathPattern` in Spring MVC as an alternative to the `AntPathMatcher` which will also require using a `RequestPath`, a parsed representation of the request path.","closed","type: enhancement,","rstoyanchev","2020-04-20T16:30:57Z","2020-06-18T20:17:31Z"
"","25287","Deprecate JCA CCI support","Spring comes with traditional support for the CCI (Common Client Interface) included in the JCA specification, along the lines of Spring's JDBC support. However, CCI was never particularly popular and has been superseded by specific data access and integration APIs for modern practical purposes. Let's therefore deprecate it as of Spring Framework 5.3, dropping our support completely in 6.0.  Even as of 6.0, CCI will still be usable with Spring: using its native API, or even with a custom fork of the old CCI support classes in Spring. We are just not going to ship official support in core Spring anymore.","closed","type: task,","jhoeller","2020-06-19T15:48:29Z","2020-06-19T17:19:47Z"
"","25280","Caching emitted values of monos","Spring caching does not currently work as I would expect for methods that return a Mono type. I suggest an enhancement to support the caching of the value emitted from the mono as opposed to the mono itself.  E.g.  @Cacheable(...) public Mono expensiveOperation(...)  It should work in the same way as for any other cacheable except targeting the emitted value rather than the actual mono. In particular it should support custom keys, cache managers, etc.  We have a rough implementation that we are using at Booking.com. I’d be happy to contribute to this if it is accepted.","closed","status: duplicate,","pstitt","2020-06-18T17:55:25Z","2020-06-18T18:21:12Z"
"","25326","Socket leak when using Webclient","Spring Boot Version: 2.3.1, when 2.3.0 has no problem When using a sample `Webclient` to retrive a remote restful API, this happens.  The test code: ```java @RestController @Slf4j public class WebClientController {      @Autowired     private WebClient.Builder webClientBuilder;      @PostMapping(value = ""/wb"")     public Mono wbTest(@PathVariable(required = false) String action) {         return webClientBuilder.build().get().uri(""http://remoteIP:remotePort/privaters/jwks/pub"")                 .retrieve()                 .bodyToMono(String.class);     }  } ``` After a few requsts, using `lsof -p XXX` to check, then shows scokets leaked! ``` java    10823 ircp   32u     sock                0,7       0t0 154700740 protocol: TCP java    10823 ircp   33u     sock                0,7       0t0 154701211 protocol: TCP java    10823 ircp   34u     sock                0,7       0t0 154700776 protocol: TCP java    10823 ircp   35u     sock                0,7       0t0 154700777 protocol: TCP java    10823 ircp   36u     sock                0,7       0t0 154700778 protocol: TCP java    10823 ircp   37u     sock                0,7       0t0 154701301 protocol: TCP java    10823 ircp   38u     sock                0,7       0t0 154701304 protocol: TCP java    10823 ircp   39u     sock                0,7       0t0 154701307 protocol: TCP java    10823 ircp   40u     sock                0,7       0t0 154701837 protocol: TCP ```","closed","status: duplicate,","fanticat","2020-06-29T05:48:56Z","2020-06-29T07:27:40Z"
"","25817","Provide public getter or part converter registration in FormHttpMessageConverter for partConverters","Spring Boot has a reflection hack so that it can register additional part converters (see https://github.com/spring-projects/spring-boot/issues/23485). It would be good to at least provide a public API for doing that. Maybe go a bit further in 6.0?","closed","type: task,","dsyer","2020-09-25T08:51:12Z","2020-09-25T20:55:03Z"
"","24999","Illegal reflective access by org.springframework.util.ReflectionUtils  - JDK11","Spring Boot ::        (v2.2.4.RELEASE)  ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to constructor java.nio.ByteBuffer(int,int,int,int,byte[],int) WARNING: Please consider reporting this to the maintainers of org.springframework.util.ReflectionUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release ```  Full log:  ``` WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to constructor java.nio.ByteBuffer(int,int,int,int) 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:202) 	at org.springframework.data.mapping.PreferredConstructor.(PreferredConstructor.java:69) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer$Discoverers.buildPreferredConstructor(PreferredConstructorDiscoverer.java:228) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer$Discoverers.access$200(PreferredConstructorDiscoverer.java:89) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer$Discoverers$1.discover(PreferredConstructorDiscoverer.java:112) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer.discover(PreferredConstructorDiscoverer.java:77) 	at org.springframework.data.mapping.model.BasicPersistentEntity.(BasicPersistentEntity.java:105) 	at org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntity.(BasicMongoPersistentEntity.java:74) 	at org.springframework.data.mongodb.core.mapping.MongoMappingContext.createPersistentEntity(MongoMappingContext.java:91) 	at org.springframework.data.mongodb.core.mapping.MongoMappingContext.createPersistentEntity(MongoMappingContext.java:39) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:357) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to constructor java.nio.ByteBuffer(int,int,int,int,byte[],int) 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:202) 	at org.springframework.data.mapping.PreferredConstructor.(PreferredConstructor.java:69) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer$Discoverers.buildPreferredConstructor(PreferredConstructorDiscoverer.java:228) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer$Discoverers.access$200(PreferredConstructorDiscoverer.java:89) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer$Discoverers$1.discover(PreferredConstructorDiscoverer.java:112) 	at org.springframework.data.mapping.model.PreferredConstructorDiscoverer.discover(PreferredConstructorDiscoverer.java:77) 	at org.springframework.data.mapping.model.BasicPersistentEntity.(BasicPersistentEntity.java:105) 	at org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntity.(BasicMongoPersistentEntity.java:74) 	at org.springframework.data.mongodb.core.mapping.MongoMappingContext.createPersistentEntity(MongoMappingContext.java:91) 	at org.springframework.data.mongodb.core.mapping.MongoMappingContext.createPersistentEntity(MongoMappingContext.java:39) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:357) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.ByteBuffer.hb 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.ByteBuffer.offset 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.ByteBuffer.isReadOnly 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.ByteBuffer.bigEndian 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.ByteBuffer.nativeByteOrder 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.Buffer.mark 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.Buffer.position 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.Buffer.limit 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.Buffer.capacity 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/C:/Users/Renato/.m2/repository/org/springframework/spring-core/5.2.3.RELEASE/spring-core-5.2.3.RELEASE.jar) to field java.nio.Buffer.address 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:782) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:500) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4797) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:548) 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:506) 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:705) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:374) 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:323) 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:452) 	at org.springframework.data.mapping.context.AbstractMappingContext.afterPropertiesSet(AbstractMappingContext.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ```","open","in: core,","renatosebben","2020-04-30T20:08:00Z","2021-11-10T12:35:33Z"
"","25007","TransactionalOperator.executeAndAwait returns value too early","Spring Boot 2.3.0.M4 Kotlin 1.3.72 postgres 9.5.21  / jdbc driver 42.2.9 / r2dbc 0.8.2   When I use several transactions sequently, I ran into visibility problems. Data inserted in previous transactions may be absent in the table.  ```kotlin     @Test     fun invisibleData() = runBlocking {         databaseClient.execute(""""""create table test (id int);"""""".trimIndent()).await()         val id = transactionalOperator.executeAndAwait {             databaseClient.insert()                 .into(""test"")                 .value(""id"", 1)                 .map { row -> row[""id""]}                 .awaitOne() as Int         }         logger.info(""Inserted! executeAndAwait $id"")          databaseClient.insert()             .into(""test"")             .value(""id"", 2)             .then()             .`as`(transactionalOperator::transactional)             .awaitFirstOrNull()         logger.info(""Inserted! transactional"")          transactionalOperator.execute {             databaseClient.insert()                 .into(""test"")                 .value(""id"", 3)                 .then()         }.awaitFirstOrNull()         logger.info(""Inserted! execute"")     } ```  ``` 2020-05-03 08:57:45.078 DEBUG 12802 --- [tor-tcp-epoll-1] i.r.p.client.ReactorNettyClient          : Response: CommandComplete{command=INSERT, rowId=0, rows=1} 2020-05-03 08:57:45.078 DEBUG 12802 --- [tor-tcp-epoll-1] i.r.postgresql.util.FluxDiscardOnCancel  : received cancel signal 2020-05-03 08:57:45.078 TRACE 12802 --- [tor-tcp-epoll-1] .s.t.r.TransactionSynchronizationManager : Retrieved value [org.springframework.data.r2dbc.connectionfactory.ConnectionHolder@3bae4c6d] for key [ConnectionPool[PostgreSQL]] bound to context [ad41659f-9635-4b70-8000-7b8658683f33: generic-transaction] 2020-05-03 08:57:45.080 TRACE 12802 --- [-1 @coroutine#2] o.s.d.r.c.R2dbcTransactionManager        : Triggering beforeCommit synchronization 2020-05-03 08:57:45.080 TRACE 12802 --- [-1 @coroutine#2] o.s.d.r.c.R2dbcTransactionManager        : Triggering beforeCompletion synchronization 2020-05-03 08:57:45.082 DEBUG 12802 --- [-1 @coroutine#2] o.s.d.r.c.R2dbcTransactionManager        : Initiating transaction commit 2020-05-03 08:57:45.082 DEBUG 12802 --- [-1 @coroutine#2] o.s.d.r.c.R2dbcTransactionManager        : Committing R2DBC transaction on Connection [PooledConnection[PostgresqlConnection{client=io.r2dbc.postgresql.client.ReactorNettyClient@2e3b4394, codecs=io.r2dbc.postgresql.codec.DefaultCodecs@70ccb3bf}]] 2020-05-03 08:57:45.083 DEBUG 12802 --- [-1 @coroutine#2] io.r2dbc.postgresql.QUERY                : Executing query: COMMIT 2020-05-03 08:57:45.083 DEBUG 12802 --- [-1 @coroutine#2] i.r.p.client.ReactorNettyClient          : Request:  Query{query='COMMIT'} 2020-05-03 08:57:45.083 TRACE 12802 --- [-1 @coroutine#2] i.r.p.client.ReactorNettyClient          : [id: 0x36ce44a1, L:/127.0.0.1:38216 - R:localhost/127.0.0.1:32258] WRITE: 12B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 51 00 00 00 0b 43 4f 4d 4d 49 54 00             |Q....COMMIT.    | +--------+-------------------------------------------------+----------------+ 2020-05-03 08:57:45.083 TRACE 12802 --- [-1 @coroutine#2] i.r.p.client.ReactorNettyClient          : [id: 0x36ce44a1, L:/127.0.0.1:38216 - R:localhost/127.0.0.1:32258] FLUSH !!! 2020-05-03 08:57:45.084  INFO 12802 --- [in @coroutine#1] r.i.d.j.JvmBackendApplicationTests       : Inserted! executeAndAwait 1 2020-05-03 08:57:45.085 DEBUG 12802 --- [tor-tcp-epoll-1] i.r.p.client.ReactorNettyClient          : Response: CloseComplete{} 2020-05-03 08:57:45.086 DEBUG 12802 --- [tor-tcp-epoll-1] i.r.p.client.ReactorNettyClient          : Response: ReadyForQuery{transactionStatus=TRANSACTION} 2020-05-03 08:57:45.086 TRACE 12802 --- [tor-tcp-epoll-1] i.r.p.client.ReactorNettyClient          : [id: 0x36ce44a1, L:/127.0.0.1:38216 - R:localhost/127.0.0.1:32258] READ COMPLETE 2020-05-03 08:57:45.086 TRACE 12802 --- [tor-tcp-epoll-1] i.r.p.client.ReactorNettyClient          : [id: 0x36ce44a1, L:/127.0.0.1:38216 - R:localhost/127.0.0.1:32258] READ: 18B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 43 00 00 00 0b 43 4f 4d 4d 49 54 00 5a 00 00 00 |C....COMMIT.Z...| |00000010| 05 49                                           |.I              | +--------+-------------------------------------------------+----------------+ 2020-05-03 08:57:45.086 DEBUG 12802 --- [tor-tcp-epoll-1] i.r.p.client.ReactorNettyClient          : Response: CommandComplete{command=COMMIT, rowId=null, rows=null} ``` You can see the logger message before commit actually happens, right after Netty FLUSH.  In cases with `transactional` and `execute` it works fine and awaits for database answer. Is it intentional behaviour, or bug?","closed","type: bug,","istarion","2020-05-03T06:12:24Z","2020-10-13T13:27:13Z"
"","25182","Different behaviour with controller query parameters mapping in object in Kotlin and Java","Spring boot 2.3.0, java 11.  Hello everyone, i trying to map query params into object with kotlin data class. When i query my controller with params /?values=1,2,3, then list parameter maps into one string instead of list of strings. After that i decided to reproduce this error with java service, on pojo without constructor values maps correctly, on pojo with constructor values maps into single string.  Expected behaviour: query parameter maps in both cases into list divided by coma separator  Is it correct behaviour or bug? I dont think it is spring boot issue, so i created it in the spring-framework repository  Sorry for my english.  Repo to reproduce: https://github.com/Ivanbmstu/spring_query_mapping  Run build in both modules (Kotlin and Java)","closed","status: superseded,","Ivanbmstu","2020-06-03T21:53:18Z","2021-05-08T16:17:11Z"
"","25031","Attempted duplicate class definition encountered using repackaged CGLIB's BeanMap","spring boot 2.2.6.RELEASE JDK 8  ```java public static  T mapToBean(Map map, T bean) {                BeanMap beanMap = BeanMap.create(bean);         beanMap.putAll(map);          return bean; } ```    **While calling mapToBean(), I have got such issue by accident**  **I don't konw why and how it happen.**      **Once this error occurs, all subsequent requests will generate this error**  **I cannot reproduce this error manually, but it must happen**   **When I restart the springboot using**: ```shell mvn clean package -Dmaven.test.skip=true ```  **the error disappears but still will occur while using.**  ```text java.lang.LinkageError: loader (instance of  org/springframework/boot/loader/LaunchedURLClassLoader): attempted  duplicate class definition for name: ""cn/com/jec/mclyx/model/Ecosystem$$BeanMapByCGLIB$$a06bc9d5"" 	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_221] 	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_221] 	at sun.reflect.GeneratedMethodAccessor26.invoke(Unknown Source) ~[na:na] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_221] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_221] 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:535) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_221] 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.beans.BeanMap$Generator.create(BeanMap.java:127) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.cglib.beans.BeanMap.create(BeanMap.java:59) ~[spring-core-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at cn.com.jec.mclyx.utils.BeanCopierHelper.mapToBean(BeanCopierHelper.java:70) ~[classes!/:0.0.1-SNAPSHOT] 	at cn.com.jec.mclyx.service.impl.EcosystemServiceImpl.updateEcosystem(EcosystemServiceImpl.java:135) ~[classes!/:0.0.1-SNAPSHOT] 	at cn.com.jec.mclyx.controller.EcosystemController.updateEcosystem(EcosystemController.java:135) ~[classes!/:0.0.1-SNAPSHOT] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_221] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_221] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_221] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_221] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at cn.com.jec.mclyx.filter.JwtAuthenticationFilter.doFilterInternal(JwtAuthenticationFilter.java:26) ~[classes!/:0.0.1-SNAPSHOT] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) ~[spring-security-web-5.2.2.RELEASE.jar!/:5.2.2.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.4.RELEASE.jar!/:5.2.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_221] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_221] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.31.jar!/:9.0.31] 	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_221] ```","open","status: feedback-provided,","jx00109","2020-05-07T13:06:48Z","2020-05-11T08:39:47Z"
"","25529","Reactor's withVirtualTime breaks cached contexts in tests","Spring Boot 2.2.5 JUnit 5.6.2  In my codebase I have:  1. Tests using `@SpringBootTest`, leveraging it's context caching for test execution speed.  1. Tests using Reactor's `withVirtualTime`  The tests using `@SpringBootTest` setup some components that use a `Flux` to communicate, and also using the `Schedulers` that Reactor provides.  `withVirtualTime` operates by _replacing_ the `Schedulers` with ones that can have time manipulated. As part of this, it disposes the existing schedulers, does the replacement, and then restores the default schedulers.  However, this will cause subsequent tests from the first category to then fail with  `reactor.core.Exceptions$ReactorRejectedExecutionException: Scheduler unavailable` as the scheduler the Flux's were using has been disposed.  In terms of remediation, controlling the test execution order isn't available right now (and has it's own problems, as mentioned in https://github.com/junit-team/junit5/issues/1948).  I've ""worked around"" the issue by having tests in the second category ""use"" the same set of annotations as the first category, so that I can add `@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)` and force the context to be disposed. This is a tractable solution for me as I only have one type of cached context.   Other ways of solving this could be: - A method to not have `withVirtualTime` replace the default `Schedulers` (with the knowledge that the code under test will always need to specify which scheduler to use for the operators that use a default) - A method to forcibly close all cached contexts. I thought about sub-classing `DefaultCacheAwareContextLoaderDelegate` to get at the static `defaultContextCache`, but there is no way to _close_ all contexts. The cache may be cleared, but that will cause the contexts to be orphaned in memory.","closed","for: external-project,","osi","2020-08-04T18:22:44Z","2020-08-13T14:48:17Z"
"","24915","BeanNameAutoProxyCreator proxies the wrong beans when custom TargetSourceCreator specified","Spring 5.1.8 (but also probably earlier versions)  Short version: if you use `BeanNameAutoProxyCreator` with a custom `TargetSourceCreator`, you'll get proxies created for **all** of your beans, not just the ones listed in the `beanNames` property.   Longer version: `BeanNameAutoProxyCreator` allows you to specify the `beanNames` for which you want proxies to be created. It also allows you to specify one of more `TargetSourceCreators`. However, the `TargetSourceCreator` will be asked to create  `TargetSource` for every bean in the context, not just the beans listed in `beanNames`.  To reproduce the problem, I created a simple context with 2 beans and a unit test (see below). The context contains a `BeanNameAutoProxyCreator` and specifies that only `beanA` should be proxied. Both `beanA` and `beanB` are declared as `lazy-init`, and I've specified a `LazyInitTargetSourceCreator` to be used (the lazy-init-ness isn't particularly important, it's just an off-the-shelf implementation of `TargetSourceCreator` that demonstrates the problem).  The unit test asserts that `BeanA` is a proxy and `beanB` is not, but then fails because both beans have been proxied.  This is at the very least unexpected and confusing (and should be documented), and is probably a bug. The `TargetSourceCreator` is being asked for a `TargetSource` for every bean in the context, without checking for which beans should be candidates for being proxied.  ```xml                                                                  ```  ```java package test;  import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.aop.SpringProxy; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestExecutionListeners; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;  import javax.inject.Inject;  import static org.hamcrest.Matchers.instanceOf; import static org.hamcrest.Matchers.not; import static org.junit.Assert.assertThat;  @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = ""/context.xml"") @TestExecutionListeners(DependencyInjectionTestExecutionListener.class) public class BeanNameAutoProxyBugTest {      @Inject     ClassA beanA;      @Inject     ClassB beanB;      @Test     public void test() {         assertThat(""beanA should be proxied"", beanA, instanceOf(SpringProxy.class));         assertThat(""beanB should not be proxied"", beanB, not(instanceOf(SpringProxy.class)));     }      static class ClassA {     }      static class ClassB {     } } ```","closed","type: enhancement,","kennymacleod","2020-04-16T08:36:00Z","2021-12-24T15:34:46Z"
"","24902","Put a limit on the size of DefaultSingletonBeanRegistry#suppressedExceptions","Spring 5.1.8  Whilst converting a particularly complex ball-of-mud legacy application from XML config to `@Configuration`-style config, I am finding that diagnosing circular references that trigger `BeanCurrentlyInCreationException`s causes an `OutOfMemoryError` before any actual exception is thrown during context initialisation. This doesn't happn with the pure XML-based config, only when I mix Java and XML styles.  When I look at the `hprof` file, 96% of the 2.5GB heap is retained by the `DefaultSingletonBeanRegistry#suppressedExceptions` field, which is full of massively-nested `BeanCreationException`s  - 12592 of them, in this case.  It woul make sense to me if the `suppressedExceptions` field were to have a size limiter added, to prevent it growing so large. It's only there for diagnostics, and 12000+ exceptons isn't going to help anyone. I on't know what a sensible size imit would be, but more than a few dozen would seem to be unecessary and unhelpful.  In my case, the limiter would at least allow the context init to fail ""gracefully"". I don't know what it is about my set up, but its much too complex for me to post as a test case, sorry.","closed","type: enhancement,","kennymacleod","2020-04-13T20:14:22Z","2020-04-25T15:09:00Z"
"","25654","load balance not supportted","sorry, sharding-sphere bug was wrongly reported to here. please close it.","closed","status: invalid,","johnny2002","2020-08-28T08:02:56Z","2020-08-28T08:49:26Z"
"","25094","WebClient losing intermittent responses","Sorry for crossposting. I asked this question on StackOverflow but for some reason, no one seems to have seen it except for me. This issue is getting very pressing now so I'm hoping that someone here will be able to see where I'm going wrong.  This is the SO post: https://stackoverflow.com/questions/60187111/java-webclient-losing-intermittent-responses-when-load-increases  I'm developing a credit card charging server for a hotel booking system that can either be used manually through a web UI or automatically for non-refundable bookings. Each transaction goes through a proxy service (third party cc store, PCI Booking) and from there to the actual payment provider. I then save the responses (Success, card declined, etc), the provider name and the time it took to charge. When I charge manually, everything works fine but when there are several automatic requests firing at the same time, I'm not getting all the responses. Sometimes I get nothing and sometimes the elapsed() handler fires and then nothing.  Here is the code in question: ```java public Mono doRequest( PaymentTransaction pt ) {     Long bookId = pt.getCardToken().getBookId();     ThreadMXBean bean = ManagementFactory.getThreadMXBean();     logToBoth( ""Book ID: "" + bookId + "", Total number of threads: "" + bean.getThreadCount() );     logToBoth( ""Book ID: "" + bookId + "", Total number of daemon threads: ""          + bean.getDaemonThreadCount() );     logToBoth( ""Book ID: "" + bookId + "", Peak thread count: "" + bean.getPeakThreadCount() );     if( pt == null ) {         logService.logError( this, ""Book ID: "" + pt.getCardToken().getBookId()              + "", doRequest: pt is null!"" );     }     else {         logService.logInfo( this, ""Book ID: "" + pt.getCardToken().getBookId()              + "", PaymentTransaction health: "" + pt.getHealth() );     }     return client.post()         .uri( builder -> builder.path( ""/api/paymentGateway"" ).build() )         .contentType( MediaType.APPLICATION_JSON )         .body( Mono.just( pt ), PaymentTransaction.class )         .header( ""authorization"", ""APIKEY "" + getApiKey() )         .exchange()         .defaultIfEmpty( ClientResponse.create( HttpStatus.I_AM_A_TEAPOT ).build() )         .timeout( Duration.ofMillis( 90000 ) )         .onErrorResume( e -> {             String errorMsg = ""Error in payment processing (""                 + pt.getPaymentGateway().getName() + "", BookID: ""                + pt.getCardToken().getBookId() + "", ""                + pt.getCardToken().getCardNumber() + "", ""                + pt.getAmount() + ""): "" + parseError( e );             logToBoth( errorMsg );             return Mono.error( new Exception( errorMsg )  );         } )         .elapsed()         .flatMap( tuple -> logTime( pt, tuple ) )         .flatMap( response -> {             logToBoth( ""Book ID "" + pt.getCardToken().getBookId()                + "". doRequest status: "" + response.statusCode().toString() );             if (response.statusCode().is4xxClientError()                 || response.statusCode().is5xxServerError() ) {                 logService.logError( this, ""Book ID: "" + pt.getCardToken().getBookId()                     + "", Error response from provider: ""                      + response.statusCode().toString() );                 return response.bodyToMono( String.class )                     .map( s -> {                         String errorMsg = ""Book ID "" + pt.getCardToken().getBookId()                              + "": "" + ""Error from PCI Booking: "" + s;                             logToBoth( errorMsg );                             PaymentResponse pr = new PaymentResponse();                             String error = encodingService.urlEncode( s );                             pr.setPciBookingError( error );                             pr.setOperationResultCode( ""Failure"" );                             pr.setOperationResultDescription( ""Error"" );                             pr.setGatewayResultCode( response.statusCode().toString() );                             pr.setGatewayResultDescription( error );                             pr.setGatewayName( pt.getPaymentGateway().getName() );                             pr.setAmount( pt.getAmount() );                             pr.setCurrency( pt.getCurrency() );                             pr.setGatewayReference( pt.getGatewayReference() );                             pr.setCreated( new Date() );                             pr.setOperationType( pt.getOperationType() );                             return pr;                         });             }             else {                 logService.logInfo( this, ""Book ID: ""                    + pt.getCardToken().getBookId() +                    "", returning payment response"" );                 return response.bodyToMono( PaymentResponse.class );             }         })         .doOnSuccess( pr -> logToBoth( ""Book ID: ""              + pt.getCardToken().getBookId() + "", doRequest successful"" ) )         .doOnError( e -> logToBoth( ""Book ID: ""              + pt.getCardToken().getBookId()              + "", doRequest error: "" + e.getMessage() ) ); }  private Mono logTime( PaymentTransaction pt, Tuple2 t ) {     ClientResponse cr = t.getT2();     logToBoth( ""=> "" + pt.getOperationType() + "", Booking: ""          + pt.getCardToken().getBookId() + "", ""         + ""Provider: "" + pt.getPaymentGateway().getName() + "", ""         + ""Amount: "" + pt.getAmount() + "" "" + pt.getCurrency() + "", ""         + ""Card: "" + pt.getCardToken().getCardNumber() + "", ""         + ""Duration: "" + t.getT1() + ""ms"" + "", Status: "" + cr.statusCode().toString() );      return Mono.just( cr ); } ``` This is running in a spring service bean and this is how the WebClient is constructed:  ```java  WebClient client = WebClient.builder()             .baseUrl( ""https://service.pcibooking.net"" )             .build(); ``` i  have experienced the issue with as few as 9 requests coming in at the same time. They all reach the payment provider but I appear to get the response for every second request. In those cases, neither of the flatMaps are called but sometimes the elapsed() handler gets called.  I'm logging both to console nad to a database. When this issue happens, the last log I'll see is either the one with ""PaymentTransaction health"" or the one from logTime().  I added the defaultIfEmpty() just to make sure that I was not getting an empty body. According to PCI Booking, the responses from the payment providers are normal but it seems like I am not receiving them all.  I'm using spring boot and this is my pom: ```xml       4.0.0              org.springframework.boot         spring-boot-starter-parent         2.2.4.RELEASE                    is.godo     pci-server     1.1.0.RELEASE     war      pci-server     PCI server               1.8         yyyy.MM.dd         ${project.version}-${maven.build.timestamp}         UTF-8         UTF-8          docker.godo.is                                           godo-snapshot             https://repo.godo.is/repository/maven-snapshots/                               godo-release             https://repo.godo.is/repository/maven-releases/                                          org.springframework.boot             spring-boot-starter-data-jpa                                org.springframework.boot             spring-boot-starter                                org.springframework.boot             spring-boot-starter-test             test                                org.springframework.boot             spring-boot-starter-web                                org.springframework.boot             spring-boot-starter-webflux                                org.springframework.boot             spring-boot-starter-websocket                                com.fasterxml.jackson.dataformat             jackson-dataformat-xml             2.9.7                                org.springframework.boot             spring-boot-starter-tomcat                               javax.servlet             jstl                               org.apache.tomcat.embed             tomcat-embed-jasper                               org.eclipse.jdt.core.compiler             ecj             4.6.1             provided                                org.webjars             webjars-locator-core                               org.webjars             webjars-locator             0.36                               org.webjars             sockjs-client             1.0.2                               org.webjars             stomp-websocket             2.3.3                               org.webjars             bootstrap             3.3.7                               org.webjars             jquery             3.1.0                                mysql             mysql-connector-java             8.0.11             runtime                                is.godo             godo-api-extended             1.4.8                               is.godo.core             godo-core             2.2.9                                         org.apache.commons             commons-lang3             3.9                               is.godo.server.property.dto             godo-property-server-dto             1.1.9                                org.springframework.boot             spring-boot-starter-security                               io.jsonwebtoken             jjwt             0.9.1                                                            org.springframework.boot                 spring-boot-maven-plugin                                      true                                                             org.apache.maven.plugins                 maven-jar-plugin                 3.0.2                                                                                            true                             true                                                  ${project.build.outputDirectory}/META-INF/MANIFEST.MF                                                                                 org.apache.maven.plugins                 maven-surefire-plugin                 2.20.1                                      false                                                             com.spotify                 dockerfile-maven-plugin                 1.3.6                                                               javax.activation                         activation                         1.1.1                                                                            ${docker.image.prefix}/${project.artifactId}                                              target/${project.build.finalName}.war                                          ${docker.tag.prefix                                              ``` It might be relevant that the doRequest function returns a Mono which is then flatMapped and another service called that stores information about the payment in the hotel booking system. This function can take several seconds to complete.  I thought this might be a threading issue so I tried changing some parameters but they don't seem to have an effect. At the moment, I have these tomcat parameters set:  `server.tomcat.max-threads: 200 server.tomcat.min-spare-threads: 50`  Any help would be greatly appreciated. I'm totally at a loss here.  Thanks, Gísli","closed","status: invalid,","gislileifs","2020-05-18T14:55:48Z","2020-07-03T05:36:50Z"
"","25793","sorry","sorry","closed","","ghost","2020-09-20T09:16:00Z","2022-02-18T19:06:28Z"
"","25627","Circular dependencies reporting is unclear","Sometimes circular dependencies reporting functionality is not very clear and doesn't help to understand **where exactly** cycle happened.  Simplest example:  ```java @Configuration public class TestConfig {      private final MyBean1 myBean1;      public TestConfig(MyBean1 myBean1) {         this.myBean1 = myBean1;     }      @Bean     MyBean1 myBean1() {         return new MyBean1();     }      public static class MyBean1 {}  } ```  The report looks like this:  ``` The dependencies of some of the beans in the application context form a cycle:  ┌─────┐ |  testConfig defined in file [...demo-circular-report\target\classes\com\example\demo\TestConfig.class] └─────┘ ```  There is nothing here that indicates that it's `MyBean1` that causes that circular reference.  Can the report look like this instead?  ``` ┌─────┐ |  testConfig defined in file [...demo-circular-report\target\classes\com\example\demo\TestConfig.class] |     ↓ |  myBean1 defined in .... └─────┘ ```  Or maybe `myBean1` shoud be first. It's circular anyway...   This image explain more clear what's actually happened, isn't it? `testConfig` bean can't be created, because `myBean1` bean can't be created, because it needs `testConfig` bean to be created first.  I suppose the root of the problem comes from the fact that exception also doesn't contain full graph of dependencies.  ``` 2020-08-21 19:43:31.698  WARN 10120 --- [           main] s.c.a.AnnotationConfigApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'testConfig' defined in file [...demo-circular-report\target\classes\com\example\demo\TestConfig.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'testConfig': Requested bean is currently in creation: Is there an unresolvable circular reference? ```  Names of some dependencies are just missing in this message. In this case it's `myBean1` (the only reference to it is ""through constructor parameter 0""). But in my real app it was even stranger. My `bean1` depends on `bean2` that is created in `config1` but in the report it looks like my `bean1` directly depends on `config1`.  Maybe  it's just how it works and nothing can be done here?","open","in: core,","xak2000","2020-08-21T17:05:16Z","2021-11-12T12:08:06Z"
"","25283","Convert JSR310 to SQL type if possible","Some driver can not infer the SQL type from JSR310 type in `setObject` method, we should convert JSR310 type to SQL type via  corresponding `valueOf` method.  postgresql-42.2.9.jar: ``` Caused by: org.postgresql.util.PSQLException: Can't infer the SQL type to use for an instance of java.time.LocalDateTime. Use setObject() with an explicit Types value to specify the type to use. 	at org.postgresql.jdbc.PgPreparedStatement.setObject(PgPreparedStatement.java:971) ~[postgresql-42.2.9.jar:42.2.9.jre7] 	at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.setObject(HikariProxyPreparedStatement.java) ~[HikariCP-3.4.1.jar:?] 	at org.springframework.jdbc.core.StatementCreatorUtils.setValue(StatementCreatorUtils.java:415) ~[classes/:5.2.2.RELEASE] 	at org.springframework.jdbc.core.StatementCreatorUtils.setParameterValueInternal(StatementCreatorUtils.java:233) ~[classes/:5.2.2.RELEASE] 	at org.springframework.jdbc.core.StatementCreatorUtils.setParameterValue(StatementCreatorUtils.java:147) ~[classes/:5.2.2.RELEASE] 	at org.springframework.jdbc.core.PreparedStatementCreatorFactory$PreparedStatementCreatorImpl.setValues(PreparedStatementCreatorFactory.java:285) ~[spring-jdbc-5.2.2.jar:5.2.2.RELEASE] 	at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate$2.setValues(NamedParameterJdbcTemplate.java:372) ~[spring-jdbc-5.2.2.jar:5.2.2.RELEASE] 	at org.springframework.jdbc.core.JdbcTemplate.lambda$batchUpdate$2(JdbcTemplate.java:944) ~[spring-jdbc-5.2.2.jar:5.2.2.RELEASE] 	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:617) ~[spring-jdbc-5.2.2.jar:5.2.2.RELEASE] ```","closed","in: data,","quaff","2020-06-19T08:04:32Z","2020-06-24T10:59:49Z"
"","25621","SocketUtils ServerSocket、DatagramSocket use try-with-resource.","SocketUtils ServerSocket、DatagramSocket use try-with-resource.","closed","in: core,","ChunMengLu","2020-08-21T08:35:40Z","2020-08-25T11:50:38Z"
"","25561","Fix Reactor deprecations in MonoToListenableFutureAdapter","Since reactor/reactor-core#1053, the `MonoToListenableFutureAdapter` is using deprecated APIs.  This might be an opportunity to rewrite this adapter with an improved implementation.","closed","type: task,","bclozel","2020-08-07T17:00:17Z","2020-08-14T14:19:29Z"
"","25163","Refactor method name dispatching to switch statements","Since Java 7, the `switch` statement can be used with a `String` value but we haven't really embraced that yet, in particular not for our proxy/interceptor implementations which still use `if`/`else` statements and `method.getName().equals` calls. From a readability perspective, it would be nice to refactor towards `switch` statements as far as possible.","closed","type: enhancement,","jhoeller","2020-05-29T15:15:53Z","2020-05-29T21:08:47Z"
"","25736","Deprecate Joda-Time support","Since 5.0, Spring Framework requires JDK 8+ and the current 5.3 generation is meant to be the long-term support branch for the 5.x version. This issue is about deprecating our Joda-Time support entirely, expecting removal in the next major release.  For reference, Spring Boot removed the dependency management for Joda-Time since 2.3, see spring-projects/spring-boot#19699","closed","type: task,","bclozel","2020-09-08T08:15:09Z","2020-09-15T11:18:02Z"
"","25483","AnnotationTypeMappings does not filter repeatable annotations","since `					if (!isMappable(source, metaAnnotation)) { 						continue; 					}` is called before and 'source' ,'metaAnnotation' did not changed.  The code should be deleted.","closed","in: core,","yilianhuaixiao","2020-07-28T07:40:33Z","2020-07-30T12:07:14Z"
"","25308","simplify the code, replace if with switch","simplify the code, replace if with switch","closed","type: task,","walesu","2020-06-24T01:59:25Z","2020-06-24T11:54:47Z"
"","25856","Simplify code for SimpleClientHttpRequestFactory.prepareConnection","Simplify code for SimpleClientHttpRequestFactory.prepareConnection","closed","type: task,","rsvoboda","2020-10-03T21:09:03Z","2020-10-22T07:50:00Z"
"","25474","Simplified ""String"" return value","Simplified code: Simplified ""String"" return value","closed","","walesu","2020-07-24T15:50:52Z","2022-02-18T19:06:25Z"
"","25155","Resolves gh-25140","Simple fix for GH-25140  Just to be sure, the call   ``` multiValueMap.addAll(""some-key"", null); ```  will fail with NullPointer.   ``` multiValueMap.addAll(""some-other-key"", Collections.emptyList()); ```  produces  ``` multiValueMap.getFirst(""some-other-key"") == null ```","closed","","midumitrescu","2020-05-28T13:42:11Z","2022-02-18T19:06:51Z"
"","25206","Should ServletServerHttpResponse copy servletResponse when constructed?","Should `ServletServerHttpResponse` copy `servletResponse` when constructed; otherwise we can't get `contentType` when write.   https://github.com/spring-projects/spring-framework/blob/a34f1e375907350cc2dd211f0c8dc59f0e4e1890/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java#L215-L223  https://github.com/spring-projects/spring-framework/blob/a34f1e375907350cc2dd211f0c8dc59f0e4e1890/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessor.java#L171-L181  https://github.com/spring-projects/spring-framework/blob/a34f1e375907350cc2dd211f0c8dc59f0e4e1890/spring-web/src/main/java/org/springframework/http/server/ServletServerHttpResponse.java#L58-L62","closed","status: invalid,","czjxy881","2020-06-08T09:52:13Z","2020-07-20T09:40:05Z"
"","25175","Configure Gradle wrapper validation action","See: https://github.com/gradle/wrapper-validation-action","closed","type: task,","sbrannen","2020-06-02T12:35:12Z","2020-06-02T12:46:27Z"
"","25018","Grammatical mistake in PathMatchConfigurer#setUseSuffixPatternMatch's comment","See the image below, where the arrow points maybe lost a `no`.  ![image](https://user-images.githubusercontent.com/43025881/81139425-53aeff80-8f98-11ea-899e-787334fa184d.png)  Commit title: `Turn off use of path extensions by default`; Commit revision number: `147b8fb75550ebe25ebdae6a42af74c61b24439f`.","closed","","ijliym","2020-05-06T04:56:32Z","2020-05-06T05:36:23Z"
"","25845","Add option to disable Last-Modified handling when serving static resources","See spring-io/start.spring.io#519 for the original issue.  When packaging static files, applications may choose to override the file metadata for build reproducibility or caching reasons. In this case, the build is overriding the file modification date to ensure that the hash of the container image layer doesn't change if the content didn't change.  Spring Framework serves static resources and uses that information for the `Last-Modified` HTTP response header. In the case of the start.spring.io service, the file changed but browsers are reusing the cached version because the modified date didn't change.  We should at least provide a configuration option to disable this behavior if the developers want to.","closed","type: enhancement,","bclozel","2020-09-30T15:35:17Z","2020-10-06T14:31:08Z"
"","25574","Consider adding @SpringJsonType or similar","See https://github.com/spring-projects/spring-kafka/issues/1549  Several Spring projects (spring-jms, spring-amqp, spring-kafka, ...) have mechanisms for mapping a `typeId` token to/from a class name, allowing decoupling of concrete types between sender and receiver.  The issue (in spring-kafka) is asking for a scan that looks for classes with a typeId annotation and automatically populate the type mapper with the mappings.  Rather than a specific solution for spring-kafka, I think it would be better to provide a generic spring-messaging annotation e.g `SpringJsonType` and, perhaps, a utility method `Map","closed","status: declined,","garyrussell","2020-08-10T18:06:49Z","2020-08-28T09:59:26Z"
"","25624","fix issue 25623","see https://github.com/spring-projects/spring-framework/issues/25623","open","in: core,","justmehyp","2020-08-21T16:10:10Z","2021-11-12T13:32:13Z"
"","25142","Document that the Map backing a MapPropertySource should not contain null values","See https://github.com/spring-projects/spring-boot/issues/21542 for background.  Currently a `PropertySource` can legitimately contain `null` values. For example, a `MapPropertySource` can return `true` from `containsProperty` and `null` from `getProperty` if the backing `Map` has an entry with a null value.  The `PropertySourcesPropertyResolver` class currently [treats null results as missing properties](https://github.com/spring-projects/spring-framework/blob/cc061ca7162d443c8f6ab0d6a8b70f507d6745b5/spring-core/src/main/java/org/springframework/core/env/PropertySourcesPropertyResolver.java#L86). This makes if impossible for a higher `PropertySource` to override a lower one with a `null` value.  The resolver could call `containsProperty` to check for a value and allow `null` results, however, this has some downsides:  * It's less efficient since two calls need to be made for each matching value * It potentially breaks back-compatibility  I've raised this issue to discuss if the design is intentional or not.","closed","in: core,","philwebb","2020-05-27T16:37:43Z","2020-05-29T14:06:47Z"
"","25573","Upgrade to Dokka 1.4.20","See https://blog.jetbrains.com/kotlin/2020/08/dokka-preview-based-on-kotlin-1-4-0-rc/, depends on https://github.com/Kotlin/dokka/issues/1293.","closed","type: dependency-upgrade,","sdeleuze","2020-08-10T13:27:47Z","2021-11-11T10:23:52Z"
"","25036","Document ReactiveTransactionManager support in reference manual","See gh-25030.","closed","type: documentation,","mp911de","2020-05-08T10:20:47Z","2020-05-08T16:27:26Z"
"","25626","fix from #25625.","see #25625","closed","status: declined,","kingbbode","2020-08-21T17:57:52Z","2020-10-15T10:16:55Z"
"","25733","Deprecate AppCacheManifestTransformer","Schedule for removal the AppCacheManifestTransformer (both Servlet and reactive variants) since support is being removed from browsers: https://web.dev/appcache-removal/","closed","type: task,","bclozel","2020-09-08T05:48:09Z","2020-09-08T12:47:20Z"
"","25499","Spring 4.3 Framework: Deadlock on ConcurrentHashMap AbstractBeanFactory.doGetBean","Scenario - Looks like this is timing issue. We have application lock (Lock#1) before calling getBean(), then there comes Spring framework ConcurrentHashMap (Lock#2). Threads are getting blocked on Lock#1 and Lock#2. Please find below snippets of thread dumps to prove the use case.  **T1 - (Acquired Lock#1 and waiting for Lock#2)**  ""Catalina-utility-1"" #85 prio=1 os_prio=0 tid=0x00007f9918034000 nid=0x33f0 waiting for monitor entry [0x00007f97f1ccd000]  java.lang.Thread.State: BLOCKED (on object monitor)            at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:213)            - waiting to lock  (a java.util.concurrent.ConcurrentHashMap)   (**-> At this place, waiting for Spring lock, Lock#2. Here it has already acquired Lock#1, and waiting for Lock#2** )            at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)            at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)            at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1082)            at com.bmc.unifiedadmin.service.ABCServiceBeanContext.getService(ABCServiceBeanContext.java:53)            at com.bmc.unifiedadmin.service.ABCServicesFactory.getService(ABCServicesFactory.java:52)     (**-> At this place, application semaphore have been acquired, Lock#1**)  **T2 - (Acquired Lock#2 and waiting for Lock#1)**            at java.util.concurrent.Semaphore.acquire(Semaphore.java:312) -> (**At this place, waiting for TSPS lock, Lock#1. Here it has already acquired Lock#2, and waiting for Lock#2**)      —      –            at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)            at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)            at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)            at java.lang.reflect.Constructor.newInstance(Constructor.java:423)            at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:142)            at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:89)            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1151)            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1103)            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:511)            at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)            at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)            at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)            - locked  (a java.util.concurrent.ConcurrentHashMap)   ((**-> At this place, Lock#2 has been acquired**)","closed","in: core,","rakeshvende","2020-07-31T12:12:19Z","2020-09-26T14:29:20Z"
"","24874","Scanned custom annotations ClassPathBeanDefinitionScanner encountered a problem","Scanned custom annotations `ClassPathBeanDefinitionScanner` encountered a problem. When classes that need to be scanned have both the custom annotations and the system annotations, they are thought to be scanned by the system annotations, not by the custom annotations. So `doScan()` returns an empty array. What should I do in this case? Are there any available tools?","closed","","lxchinesszz","2020-04-07T07:29:52Z","2020-04-21T08:18:14Z"
"","25649","Duplicated Invoke when onApplicationEvent called from ApplicationListener","Running with springboot 2.2.5 ,which contains spring version: spring-core-5.2.4  and spring-aop-5.2.4.  Scenario: My Listener as below:  ```java @Service public class UserJoinRoomListener implements ApplicationListener {   @Override   @TraceSource(sampler = RoomEntrySampler.class) //AOP here to trigger #{RoomEntrySampler#process} after current funtion invoked   public void onApplicationEvent(UserJoinRoomEvent event) {     System.out.println(""Hello "");   } } ```  RoomEntrySampler code as below:  ```java public class RoomEntrySampler{   @Override   public void process(UserJoinRoomEvent event) { 	System.out.println(""World"");   } } ```  when i call `ApplicationContext.publishEvent(new UserJoinRoomEvent(xxx,xxx))`   Expectation:  it should print ""Hello World"".  Actually: it print ""Hello Hello World""  Question: to my understanding,  Function ""onApplicationEvent""(the proxy object ) should only be invoked at just one time and run at one go.  but it's not eventually ,, can i consider this situation as a  ""Bug""?","open","in: core,","freezingWu","2020-08-24T15:35:40Z","2021-11-10T10:03:02Z"
"","25638","Duplicated Invoke when onApplicationEvent called from ApplicationListener","Running with springboot 2.2.5 ,which contains spring version: spring-core-5.2.4  and spring-aop-5.2.4.  Scenario: My Listener as bellow: @Service public class UserJoinRoomListener implements ApplicationListener<UserJoinRoomEvent> {   @Override   @TraceSource(sampler = RoomEntrySampler.class) //AOP here to trigger #{RoomEntrySampler#process} after current funtion invoked   public void onApplicationEvent(UserJoinRoomEvent event) {     System.out.println(""Hello "");   } }  RoomEntrySampler code as bellow: public class RoomEntrySampler{   @Override   public void process(UserJoinRoomEvent event) { 	System.out.println(""World"");   } }  when i call `ApplicationContext.publishEvent(new UserJoinRoomEvent(xxx,xxx))`   Expectation:  it should print ""Hello World"".  Actually: it print ""Hello Hello World""  Question: to my understanding,  Function ""onApplicationEvent""(the proxy object ) should only be invoked at just one time and run at one go.  but it's not eventually ,, can i consider this situation as a  ""Bug""?","closed","","freezingWu","2020-08-24T10:42:05Z","2022-02-18T19:06:25Z"
"","25548","Require RSocket 1.0 as minimum version","RSocket removed in 1.1 some classes deprecated in 1.0 (see https://github.com/rsocket/rsocket-java/commit/6daa2ebb07c00d6394fef7bb039bf73a935f884e).  Spring Framework deprecated related classes in the 5.2.x line. Because RSocket is still quite new and given the LTS requirements for the 5.3.x line, we'll remove our deprecated classes as well.","closed","type: task,","bclozel","2020-08-06T12:41:28Z","2020-08-06T12:45:58Z"
"","25374","Spring JMS and ActiveMQ: Automatic JMS message to POJO conversion support.","Right now there is no way to automatically convert JMS message to POJO. I have to set a type id from consumer side (listener) and a FQDN java name from a producer side for listener to infer(get) the type for message conversion.  The question really is, are there plans to add logic to Spring JMS that will do the automatic conversion? Is it feasible at all?  ``` MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter(); converter.setTypeIdPropertyName(""java_type"");  other converter settings ```","closed","status: declined,","ifliunt","2020-07-08T21:03:49Z","2020-07-09T08:40:16Z"
"","25330","Avoid re-creating RSocketRequester instance per subscriber","Right now `RSocketRequester.Builder` uses the `connect` method as a terminal operation which builds a `Mono doCancel()` the underlying mono is not directly propagated to the user, hence all subsequent subscriptions create new connections instead of the usage of the cached (assumed the `reconnect` feature is enabled)    # Expected    ``` rsocketRequesterBuilder 				.rsocketConnector(rsocketConnector -> 					rsocketConnector 							.lease(() -> Leases.create().receiver(leaseReceiver)) 							.reconnect( 								Retry.backoff(Long.MAX_VALUE, Duration.ofMillis(100)) 								     .maxBackoff(Duration.ofSeconds(5)) 							) 				) 				.connectWebSocket(URI.create(adjustmentProperties.getBaseUrl())); ```  to behave approximately identical to     ``` RSocketConnector 				.create() 				.lease(() -> Leases.create().receiver(leaseReceiver)) 				.dataMimeType(dataMimeType.toString()) 				.metadataMimeType(metadataMimeType.toString()) 				.reconnect( 						Retry.backoff(Long.MAX_VALUE, Duration.ofMillis(100)) 						     .maxBackoff(Duration.ofSeconds(5)) 				) 				.connect(WebsocketClientTransport.create(URI.create(adjustmentProperties.getBaseUrl() + ""rsocket""))) 				.map(rsocket -> RSocketRequester.wrap( 					rsocket, 					dataMimeType, 					metadataMimeType, 					rSocketStrategies 				));  ```  # Actual   connect method wraps   ``` RSocketConnector 				.create() 				.lease(() -> Leases.create().receiver(leaseReceiver)) 				.dataMimeType(dataMimeType.toString()) 				.metadataMimeType(metadataMimeType.toString()) 				.reconnect( 						Retry.backoff(Long.MAX_VALUE, Duration.ofMillis(100)) 						     .maxBackoff(Duration.ofSeconds(5)) 				) 				.connect(WebsocketClientTransport.create(URI.create(adjustmentProperties.getBaseUrl() + ""rsocket""))) ```  into   ``` Mono.defer(() -> RSocketConnector 				.create() 				.lease(() -> Leases.create().receiver(leaseReceiver)) 				.dataMimeType(dataMimeType.toString()) 				.metadataMimeType(metadataMimeType.toString()) 				.reconnect( 						Retry.backoff(Long.MAX_VALUE, Duration.ofMillis(100)) 						     .maxBackoff(Duration.ofSeconds(5)) 				) 				.connect(WebsocketClientTransport.create(URI.create(adjustmentProperties.getBaseUrl() + ""rsocket"")))) ```  so `reconnect` does not work as expected","closed","type: enhancement,","OlegDokuka","2020-06-29T13:41:08Z","2020-07-01T07:08:32Z"
"","25639","Public method in RSocketMessageHandler to register any handler method","Right now `RSocketMessageHandler` can process only `@MessageMapping` methods when the handler class is marked with the `@Controller`.   Provide a hook which will allow us to register any handler with its own conditions. It is possible right now when we override `RSocketMessageHandler` and call its `protected final registerHandlerMethod()`, but it would be great to be able to register conditional handlers into a single `RSocketMessageHandler`, which in most cases is auto-configured by Spring Boot.  Thanks  P.S. For my use-case having a `registerHandlerMethod()` as `public` would be enough though. Even if it is going to have a restriction to be called only on startup during bean initialization phase.","closed","type: enhancement,","artembilan","2020-08-24T15:12:47Z","2020-08-27T12:14:12Z"
"","25415","Simplified return statement","return value if statements which can be simplified to a single assignment, return or assert statement.","closed","type: enhancement,","walesu","2020-07-19T04:37:35Z","2020-07-20T09:12:58Z"
"","25149","ExchangeStrategies custom codec's reader & writer are not registered","Resolves #25146","closed","type: bug,","dlsrb6342","2020-05-28T10:16:16Z","2020-05-28T13:38:28Z"
"","25263","Overloaded @Bean method with name mismatch causes bean to be created twice (in case of ASM processing)","Reproduced in Spring 5.2.7.RELEASE (Spring Boot 2.3.1.RELEASE):  ```java @Configuration public class SomeConfig {     @Bean(name = ""other"")     SomeOtherBean foo() {         System.out.println(""constructing SomeOtherBean"");         return new SomeOtherBean();     }      @Bean(name = ""foo"")     SomeBean foo(@Qualifier(""other"") SomeOtherBean other) {         System.out.println(""constructing SomeBean"");         return new SomeBean(other);     } } ```  With the above configuration class, `SomeOtherBean` is constructed twice, and `SomeBean` is never constructed. Why? Because the two methods have the same name. If you rename the second method to `bar`, everything is constructed once, as expected.  Admittedly, using the same method name is not a good idea. I just happened to have done it by accident.","closed","in: core,","jnizet","2020-06-17T09:15:11Z","2020-08-27T12:50:33Z"
"","25381","Use Math.min() in ExponentialBackOff","Reports cases where the minimum or the maximum of two numbers can be calculated by means of Math.max() or Math.min() instead of doing it manually.","closed","type: enhancement,","walesu","2020-07-12T09:11:41Z","2020-07-13T10:02:43Z"
"","24903","provide way to configure websoscket parameters outside","replaced deprecated invocation with recommended method This is required to enable websocket server compression. By default builder has compression=false parameter and it is not possible to override it (factory could not be setup from anywhere)","closed","status: superseded,","golosegor","2020-04-13T20:16:34Z","2020-04-23T07:29:41Z"
"","25314","Wording changes","Replace potentially insensitive language with more neutral language.  Note that there are lots of code items (method names, for example) that also need to change.","closed","type: documentation,","Buzzardo","2020-06-24T17:44:58Z","2020-07-20T16:40:11Z"
"","24933","Simplify substring() usage in MimeTypeUtils","Removed redundant if-constructions and unnecessary variable declaration.","closed","status: feedback-provided,","mikaelparsekyan","2020-04-19T14:17:32Z","2020-04-19T15:40:54Z"
"","24936","Simplify if-else constructions in spring-web","Removed redundant else-s in `ReadOnlyHttpHeaders.java` and in `ResponseEntity.java`","closed","status: declined,","mikaelparsekyan","2020-04-20T07:57:32Z","2020-04-20T12:27:52Z"
"","25459","Removed unused imports","Removed Java.util.List and Java.util.stream.Collectors from TestCompiler.java","closed","status: declined,","MattMFX","2020-07-22T08:13:56Z","2020-07-22T08:16:22Z"
"","24913","Built-in support for standard bean validation on controller method arguments","Related to #11041.  I'm trying to validate `@PathVariable` and `@RequestBody` in one method. `MethodValidationPostProcessor` is registered. Simplified Controller looks like this:  ```java @RestController @Validated public class MyController {     @RequestMapping(value = ""/{id}"", method = RequestMethod.PUT)     public ResponseEntity method_name(@PathVariable @NotNull String id, @Valid @RequestBody Body body) {         /// Some code     } } ```  I noticed that request body validation is triggered twice - it wouldn't be an issue if it weren't custom `ConstraintValidator` with injected bean:  ```java public class CustomValidator implements ConstraintValidator {  	@Autowired 	private BodyVerificator bodyVerificator; ... ```  For first validation run the bean is injected properly, and for second run it's null so it results in NPE. Workaround is to either not use method parameter validation at all, or to annotate `@RequestBody` with `@Validated` so not mix `@Validated` and `@Valid`. I would actually prefer to have `@PathVariable` bean validation support in Spring like in #11041.","open","type: enhancement,","hedgerocker","2020-04-16T05:51:38Z","2022-07-05T09:32:00Z"
"","24862","Introduce owningClass attribute in @RequestAttribute","Regularly I find myself in a situation in which I'd like to use a class name in an annotation. Most recently I ran into that situation in connection with the `@RequestAttribute` annotation.  Often when I need to write a request filter I end up with a code similar to the following: ```java package org.exmaple;  import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException;  public class ExampleFilter implements Filter {      public static final String ATTRIBUTE_NAME =         ExampleFilter.class.getName() + '.' + ""EXAMPLE_ATTRIBUTE"";      @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {         String someValue;          ...          request.setAttribute(ATTRIBUTE_NAME, someValue);          chain.doFilter(request, response);     }  } ``` Note that the value of `ATTRIBUTE_NAME` is a constant string with the class name prepended to it to avoid attribute name conflicts. This practice is not uncommon for request attribute names.  Now, when I want to use the attribute set by the filter in a handler, I'd like to be able to do so as follows: ```java package org.exmaple;  import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestAttribute; import org.springframework.web.bind.annotation.RequestMapping;  @Controller @RequestMapping(""/example"") public class ExportController {      @GetMapping(""/test"")     public ResponseEntity test(@RequestAttribute(ExampleFilter.ATTRIBUTE_NAME) String attributeValue, ...) {         Object responseData;          ...          return new ResponseEntity(responseData, HttpStatus.OK);     }  } ``` But java doesn't let me do that, complaining that: _Attribute value must be constant_.  This is unfortunate as it forces me to hardcode the class name in the attribute name: ```java public static final String ATTRIBUTE_NAME = ""org.exmaple.ExampleFilter.EXAMPLE_ATTRIBUTE""; ```  While it is not possible to use class names in annotations it _is_ possible to use class constants. Therefore, to improve the current situation, I propose adding a new field to the `@RequestAttribute` for specifying the class ""owning"" the attribute. If specified, the name of the class would be prepended to the value used currenlty (either specified or inferred). If left unspecified, nothing would be prepended, so the proposed change is backwards compatible. Here is a tentative implementation: ```java @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RequestAttribute {      /**      * Alias for {@link #name}.      */     @AliasFor(""name"")     String value() default """";      /**      * The name of the request attribute to bind to.      * The default name is inferred from the method parameter name.      * If {@link #owningClass} is specified, its name is prepended to the value of this field.      */     @AliasFor(""value"")     String name() default """";      /**      * The class owning the attribute. If specified, its name is prepended to {@link #name}      * (both explicitly specified or inferred).      */     Class owningClass() default None.class;      /**      * Whether the request attribute is required.      * Defaults to {@code true}, leading to an exception being thrown if      * the attribute is missing. Switch this to {@code false} if you prefer      * a {@code null} or Java 8 {@code java.util.Optional} if the attribute      * doesn't exist.      */     boolean required() default true;      class None {     }  } ```","closed","type: enhancement,","mruzicka","2020-04-03T18:21:51Z","2020-04-07T09:15:02Z"
"","25623","PathMatchingResourcePatternResolver  gives me a FileSystemResource instead of ClassPathResource while I specify the prefix ""classpath:""","Recently, I had some trouble loading classpath resources. During local development, I can obtain the resources under classpath through classloader. And If this resource is a folder, I can get sub-files/ sub-directories through the `File#listfiles` method. But this doesn't work when the program is packaged in a jar package, the file in a jar is not a file, and the folder is not a folder. In this case, they are all `JarEntry`.  So I found out the PathMatchingResourcePatternResolver, which I hoped would solve my problem, but it couldn't.  The problem is described as follows:  First, we create a new PathMatchingResourcePatternResolver instance: ``` package com.xxx;  public class Main {   public static void main(String[] args) {     ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();   } } ```  I want to get the resources under classpath, such as all sub-resources under 'org/springframework/core/io/support/', ``` resolver.getResources(""classpath:org/springframework/core/io/support/*"") ```  I specified the prefix ""classpath:"" just as I wanted to get resources under classpath. The statement returns an Array with component type `ClassPathResource`. That is exactly what I want. And the class name `ClassPathResource` is just so NICE.  OK, We just tried to get the resources inside a jar. Next, We are going to get something in expanded directory(file system). My program has a package called` com.xxx `. Next, let's try to obtain the resources under ""com/xxx"": ``` resolver.getResources(""classpath:com/xxx""); ```  This time, take a closer look. It returns an Array with concrete component type `FileSystemResource`. I am confused now. I specified the prefix ""classpath:"", instead of ""file:///"", so why give me a FileSystemResource?  I am expecting the perfect `ClassPathResource` because I need its `getPath` method to do other things.  Finally, I am thinking about that this may be a defect in implementation, and should be resolve. What do you guys think?","closed","status: superseded,","justmehyp","2020-08-21T15:20:12Z","2021-11-15T20:54:31Z"
"","24966","Provide a method to get the list of scheduled tasks and cancel instead of destroying all tasks in ScheduledTaskRegistrar","Recently I used SchedulingConfigurer to schedule same task for multiple cron expressions. And one more requirement is the cron expression may change on the fly that means I am having the cron trigger in data base. If have a provision to get the scheduled task which are scheduled using ScheduledTaskRegistrar then I will cancel the task and schedule the same task with new cron expression. I see there is a destroy method to cancel the scheduled task but that also shutdowns the executor also.  My request is to provide getter method to get the scheduled task and cancel them. Also make the scheduleTasks as public method so that I can call the same method when the cron is changed dynamically , for now in my application I am using the afterProperties method.","open","in: core,","rsilamala","2020-04-24T15:57:31Z","2022-06-05T18:26:18Z"
"","25471","Support macros in crontab expressions","Recent version of `crontab` support the following macros:  *  `@yearly` or `@annually`: run once a year, ""0 0 1 1 *"". * `@monthly`: run once a month, ""0 0 1 * *"". * `@weekly`: run once a week, ""0 0 * * 0"". * `@daily` or `@midnight`: run once a day, ""0 0 * * *"". * `@hourly`: run once an hour, ""0 * * * *"".  We should support these macros in Spring Framework as well, as they greatly improve the readability of typical crontab expressions.","closed","type: enhancement,","poutsma","2020-07-24T09:23:37Z","2020-08-04T05:59:33Z"
"","25843","non-root xmlelements JAXBElement serialisation","Question:  https://stackoverflow.com/questions/64095580/spring-boot-with-an-jaxbelement-result  Bug? In a fairly old release note of Spring-OMX I notice that non-root elements should be supported. Then again they are not;  ``` 2020-09-30 11:21:01.200  WARN 67871 --- [0.0-8083-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotWritableException: Could not marshal [[bestaetigung=[ergebnis=NOTOK,fehlernummer=1,fehlertext=I'm sorry, your senderId 'test' is not configured.,zst=2020-09-30T11:21:00.476367]]]: JAXB marshalling exception; nested exception is javax.xml.bind.MarshalException  - with linked exception: [com.sun.istack.SAXException2: unable to marshal type ""de.vdv453.AboAntwortType"" as an element because it is missing an @XmlRootElement annotation]; nested exception is org.springframework.oxm.MarshallingFailureException: JAXB marshalling exception; nested exception is javax.xml.bind.MarshalException  - with linked exception: [com.sun.istack.SAXException2: unable to marshal type ""de.vdv453.AboAntwortType"" as an element because it is missing an @XmlRootElement annotation]] ```  ```java 		Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller(); 		jaxb2Marshaller.setContextPath(ObjectFactory.class.getPackage().getName()); 		Map prop = new HashMap(); 		prop.put(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE); 		jaxb2Marshaller.setMarshallerProperties(prop); 		jaxb2Marshaller.setCheckForXmlRootElement(false); 		return new MarshallingHttpMessageConverter(jaxb2Marshaller); ```","closed","for: stackoverflow,","skinkie","2020-09-30T09:26:56Z","2020-09-30T11:54:45Z"
"","25420","Merge pull request #1 from spring-projects/master","pull","closed","","zerotoone01","2020-07-19T16:01:50Z","2020-07-19T16:53:01Z"
"","25301","Reduce String creation in BeanPropertyRowMapper","Prior to this commit the BeanPropertyRowMapper used String.substring and String.toLowerCase to parse the field names. This would generate more String than needed.  Instead one could iterate over the internal char[] of the String and use the Character methods instead. This reduces the String creation.","closed","type: enhancement,","mdeinum","2020-06-23T06:16:36Z","2022-01-17T13:29:15Z"
"","25260","Align DispatcherServlet defaults for Java and XML","Prior to this commit some of the default strategies defined for the DispatcherServlet weren't included in the default configuration for both Java and XML configuration.  The following default beans have been added to the configuration with the name as expected by the DispatcherServlet:  - org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver - org.springframework.web.servlet.theme.FixedThemeResolver - org.springframework.web.servlet.support.SessionFlashMapManager - org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator  Fixes: gh-25209","closed","type: enhancement,","mdeinum","2020-06-17T07:12:41Z","2020-07-27T10:25:23Z"
"","25572","Call StartupStep.end in finally block","Prior to this commit it was possible that a StartupStep was started but never ended. This was the case when an exception occured during bean initializing. To always call the method regardless of the outcome, the call to StartupStep.end has been moved to a finally block.  When an exception occurs the StartupStep is also enriched with the exception class and message for diagnostic purposes.  Related: spring-projects/spring-boot#22776","closed","type: enhancement,","mdeinum","2020-08-10T10:28:27Z","2020-08-24T08:49:08Z"
"","24970","Reintroduce synthesized annotation attribute value caching","Prior to the introduction of the `MergedAnnotation` in Spring Framework 5.2, our `SynthesizedAnnotationInvocationHandler` utilized a cache for annotation attribute values; whereas, the new `SynthesizedMergedAnnotationInvocationHandler` has no such caching in place.  Issues such as #24961 indicate a regression in performance caused by the lack of such an attribute value cache. For example, the `required` attribute in `@RequestParam` is looked up using the internal meta-model in the `MergedAnnotation` API twice per request for each `@RequestParam` in a given controller handler method.  Reintroducing the attribute value cache would avoid the unnecessary performance overhead associated with multiple lookups of the same attribute not only for use cases like `RequestParam.required` but also for `equals()` and `toString()` invocations on a synthesized annotation. Note that invocations of `hashCode()` also incur additional overhead for attribute value lookups but only once, since the resulting hash code is cached after the first computation.","closed","in: core,","sbrannen","2020-04-25T12:29:09Z","2020-04-26T12:14:43Z"
"","25592","Support multiple aliases via @AliasFor","Previously, one annotation attribute only supported one alias. You can only do like this:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test1 {         String test1() default ""test1"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test2 {         String test2() default ""test2"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test1     @Test2     public @interface Test3 {          @AliasFor(annotation = Test1.class, attribute = ""test1"")         String test3() default ""test3"";          @AliasFor(annotation = Test2.class, attribute = ""test2"")         String test4() default ""test4"";     } ```  But now, you can do this more easily:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test1     @Test2     public @interface Test3 {          @AliasFor(annotation = Test1.class, attribute = ""test1"")         @AliasFor(annotation = Test2.class, attribute = ""test2"")         String test3() default ""test3"";     } ```  Moreover, the mutual aliasing of different attributes in the same annotation can break the original limitation (although this kind of use scenario is less):  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test4 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test"";          @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test"";     } ```  Combine examples above, you can use `@AliasFor` like this:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test5 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test1"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test1"";          @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test1"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test5     public @interface Test6 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test2"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test2"";          @AliasFor(annotation = Test5.class)         @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test2"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test6     public @interface Test7 {          @AliasFor(annotation = Test6.class)         String test3() default ""test3"";     }      @Test7(test3 = ""override the method"")     public static class Element4 {     }      @Test     public void test3() {         Test5 test5 = AnnotatedElementUtils.getMergedAnnotation(Element4.class, Test5.class);         Test6 test6 = AnnotatedElementUtils.getMergedAnnotation(Element4.class, Test6.class);         System.out.println(test5.toString());         System.out.println(test6.toString());         assertEquals(""override the method"", test6.test1());         assertEquals(""override the method"", test6.test2());         assertEquals(""override the method"", test6.test3());         assertEquals(""override the method"", test5.test1());         assertEquals(""override the method"", test5.test2());         assertEquals(""override the method"", test5.test3());     } ```  For more details, please read `org.springframework.core.annotation.alisfors.AlisforsTests`.","closed","type: enhancement,","dragon-zhang","2020-08-15T06:58:42Z","2020-11-02T10:37:55Z"
"","24867","Fix json type info when using Optional","Preserve json type info during serialization when value is wrapped with java.util.Optional #24498","closed","status: declined,","encircled","2020-04-06T09:50:51Z","2020-04-24T09:47:32Z"
"","25477","Remove unused class filtering support in AnnotationScanner","PR gh-25429 brought it to our attention that there was a bug in AnnotationScanner when using a non-null class filter that filtered out classes; however, it turns out that there is no production code that utilizes the package-private class filtering support.  This commit therefore removes all class filtering support from AnnotationScanner since that functionality was effectively unused.","closed","in: core,","sbrannen","2020-07-25T14:24:55Z","2020-07-28T08:02:01Z"
"","25833","Mybranch","pr","closed","","codegitz","2020-09-29T03:17:14Z","2020-09-29T06:34:17Z"
"","25595","1 update query takes 3-4 minutes at DB2","pom file looks like this; (spring boot version 2.1.8)  ```  	com.ibm.db2.jcc 	db2jcc4         10.1          org.springframework.boot       spring-boot-starter-jdbc  ```  and query is this, just one row  `jdbcTemplate.update(""UPDATE myTable SET hashValue= ? WHERE TRIM(id) = ?"", hashValue, id);`  So far, I tried to set `auto-commit=false` but nothing changed.","closed","for: stackoverflow,","muhammedOzbilici","2020-08-15T21:13:44Z","2020-08-16T13:52:12Z"
"","25302","Fix typo in Java example for handler class","Polishing","closed","type: documentation,","origoni","2020-06-23T08:29:26Z","2020-06-23T16:01:25Z"
"","24880","Spring Data MongoDb - Unable to use @EnableMongoAuditing with multiple DB connections","Please see [this issue in StackOverflow ](https://stackoverflow.com/questions/60557848/couldnt-find-persistententity-fpr-type-class-when-using-enablemongoauditing-wi) for all of the details.  While thinking about it, I'm sure this is a defect or something to be completed. This is in the version of Spring Data which is with Spring Boot 2.1.12.","closed","for: external-project,","hirowla","2020-04-08T11:41:44Z","2020-04-08T13:05:52Z"
"","25715","Fix Issue #25557","Please see #25557","closed","in: core,","kostya05983","2020-09-06T17:51:08Z","2020-09-12T15:03:36Z"
"","25229","DELETE ME","Please delete this issue","closed","","ML-Marco","2020-06-10T10:57:27Z","2022-02-18T19:06:53Z"
"","25753","A beforeCommit chain failure invariably results in a 500 response","Please consider the following test (the entire test code is provided below): it is comprised of the WebSessionTest which sends a request to the WebSessionController, the latter responds with a 200 response, afterwards the web session is being saved (see the WebSessionTestWebSessionManager) which results in the response before commit chain failure owing to the InMemoryWebSessionStore’s size  is 0 (is employed by the WebSessionTestWebSessionManager). WebExceptionHandlers are invoked (no matter how an exception handler is implemented it may be either an annotated method or a WebExceptionHandler implementation) notwithstanding the client receives a 500 response.  I would like to return a 503 response with an application specific representation. I came up with a workaround in the DefaultWebSessionManager's overloaded method: ```java exchange.getResponse()         .beforeCommit(() -> Mono.defer(session::save)                 .onErrorResume(this::isMaxSessionsLimitReachedException, e -> { exchange.getResponse().setStatusCode(HttpStatus.SERVICE_UNAVAILABLE);                     exchange.getResponse().getHeaders().clear();                     exchange.getResponse().getCookies().clear();                      return Mono.empty();                 })); ``` however it doesn't give me a chance to provide a body otherwise the client hangs.  Environment: * Java 11, * Spring 5.2.8.RELEASE, * Spring Boot 2.3.3.RELEASE.  The code of the test:  **WebSessionTest:** ```java package com.example.session;  import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpResponse.BodyHandlers; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit;  import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.web.server.LocalServerPort; import org.springframework.test.context.junit.jupiter.SpringExtension;  import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertNotNull;  @ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,         classes = {                 WebSessionController.class,                 WebSessionTestWebSessionManager.class,                 WebSessionTestWebExceptionHandler.class }) @EnableAutoConfiguration public class WebSessionTest {     @LocalServerPort     private int serverPort;      @Test     public void testJustReponse() throws ExecutionException, InterruptedException     {         long timestamp = System.currentTimeMillis();          HttpClient client = HttpClient.newHttpClient();         HttpRequest request = HttpRequest.newBuilder()                 .uri(URI.create(""http://localhost:"" + serverPort + ""/just/"" + timestamp))                 .build();         CompletableFuture future =                 client.sendAsync(request, BodyHandlers.ofString()).completeOnTimeout(null, 5, TimeUnit.SECONDS);         HttpResponse response = future.get();          assertNotNull(response, ""No response in 5 seconds."");         assertEquals(503, response.statusCode());     } } ```  **WebSessionController:** ```java package com.example.session;  import java.util.concurrent.Executors;  import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.ResponseStatus; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.server.WebSession;  import reactor.core.publisher.Mono; import reactor.core.scheduler.Scheduler; import reactor.core.scheduler.Schedulers;  import static org.springframework.http.HttpStatus.SERVICE_UNAVAILABLE;  @RestController public class WebSessionController implements InitializingBean, DisposableBean {     private Scheduler scheduler;      @Override     public void afterPropertiesSet()     {         scheduler = Schedulers.fromExecutorService(Executors.newCachedThreadPool());     }      @Override     public void destroy()     {         scheduler.dispose();     }      @GetMapping(""/just/{timestamp}"")     public Mono just(@PathVariable String timestamp, WebSession session)     {         return Mono.fromCallable(() -> {             session.getAttributes().putIfAbsent(""test"", timestamp);              return ResponseEntity.status(HttpStatus.OK)                     .header(HttpHeaders.CACHE_CONTROL, ""no-store"")                     .body(timestamp);         }).subscribeOn(scheduler);     }      /*     No matter how the exception handler is implemented it may be either an annotated method or a WebExceptionHandler      implementation – the client invariably receives a 500 response.             @ResponseStatus(value= SERVICE_UNAVAILABLE, reason=""Too many sessions"")     @ExceptionHandler     public void tooManySessions(Exception e)     {     }      @ExceptionHandler     public Mono tooManySessions(Exception e)     {         return Mono.fromCallable(() -> ResponseEntity.status(500).body(e.getMessage())).subscribeOn(scheduler);     }      @ExceptionHandler     public ResponseEntity tooManySessions(Exception e)     {         return ResponseEntity.status(503).body(""To many sessions: "" + e.getMessage());     }     */ } ```  **WebSessionTestWebSessionManager:** ```java package com.example.session;  import org.springframework.beans.factory.InitializingBean; import org.springframework.stereotype.Component; import org.springframework.web.server.session.DefaultWebSessionManager; import org.springframework.web.server.session.InMemoryWebSessionStore; import org.springframework.web.server.session.WebSessionManager;  @Component(""webSessionManager"") public class WebSessionTestWebSessionManager extends DefaultWebSessionManager implements WebSessionManager,         InitializingBean {     private final InMemoryWebSessionStore sessionStore = new InMemoryWebSessionStore();      @Override     public void afterPropertiesSet()     {         sessionStore.setMaxSessions(0);         super.setSessionStore(sessionStore);     } } ```  **WebSessionTestWebExceptionHandler:** ```java package com.example.session;  import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import org.springframework.web.server.WebExceptionHandler;  import reactor.core.publisher.Mono;  @Component public class WebSessionTestWebExceptionHandler implements WebExceptionHandler {     @Override     public Mono handle(ServerWebExchange exchange, Throwable throwable)     {         exchange.getResponse().setStatusCode(HttpStatus.SERVICE_UNAVAILABLE);         exchange.getResponse().getHeaders().clear();         exchange.getResponse().getCookies().clear();         return exchange.getResponse()                 .writeWith(Flux.just(exchange.getResponse()                         .bufferFactory()                         .wrap(""Service unavailable"".getBytes(StandardCharsets.UTF_8))));     } } ```","closed","type: enhancement,","evgenyvsmirnov","2020-09-11T04:37:52Z","2020-09-13T20:30:52Z"
"","25093","DataBufferUtils ""doesn't respect backpressure""","Please consider the following REST controller method which employs DataBufferUtils to transmit a file: ```java     @RequestMapping(path = ""/file/{id}"", method = GET, produces = APPLICATION_OCTET_STREAM_VALUE)     @ResponseBody     public Mono downloadFile(ServerWebExchange exchange, @PathVariable(""id"") String id) {         return Mono                 .fromRunnable(() -> {                     HttpHeaders headers = exchange.getResponse().getHeaders();                     headers.add(HttpHeaders.CONTENT_LENGTH, Long.toString(getFileLength(id)));                     headers.add(HttpHeaders.CONTENT_TYPE, APPLICATION_OCTET_STREAM_VALUE);                 })                 .subscribeOn(scheduler)                 .then(exchange.getResponse().writeWith(                         DataBufferUtils.readInputStream(                                 () -> getFileInputStream(id),                                 exchange.getResponse().bufferFactory(),                                 8192                         ).subscribeOn(scheduler)));     } ```  **Expected behaviour:** a 200, 4xx or 5xx is transmitted to the client or the connection is closed amid the transmission. **Actual behaviour:** client hangs  So once in a while I stumble across the following stacktraces in the production logs (the bad thing is that I can't reproduce them with a test – it seems reactor-netty disregards the clients TCP window size which the test could capitalize on):  ``` 2020/05/15-04:50:59.581-0,JAVA,0,level=WARN,pid=6500,threadId=182,thread=webflux-selector-http-3,logger=GlobalExceptionHandler,message='[d8818abc-1105] Request processing failed: HTTP GET ""/file/file5412465168127""',exception=reactor.core.Exceptions$OverflowException: Queue is full: Reactive Streams source doesn't respect backpressure 	at reactor.core@3.3.2.RELEASE/reactor.core.Exceptions.failWithOverflow(Exceptions.java:231) 	at reactor.netty@0.9.4.RELEASE/reactor.netty.channel.MonoSendMany$SendManyInner.onNext(MonoSendMany.java:190) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 	at spring.web@5.2.4.RELEASE/org.springframework.http.server.reactive.ChannelSendOperator$WriteBarrier.onNext(ChannelSendOperator.java:173) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxSubscribeOn$SubscribeOnSubscriber.onNext(FluxSubscribeOn.java:151) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxUsing$UsingFuseableSubscriber.onNext(FluxUsing.java:350) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxGenerate$GenerateSubscription.next(FluxGenerate.java:169) 	at spring.core@5.2.4.RELEASE/org.springframework.core.io.buffer.DataBufferUtils$ReadableByteChannelGenerator.accept(DataBufferUtils.java:644) 	at spring.core@5.2.4.RELEASE/org.springframework.core.io.buffer.DataBufferUtils$ReadableByteChannelGenerator.accept(DataBufferUtils.java:618) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxGenerate.lambda$new$1(FluxGenerate.java:56) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxGenerate$GenerateSubscription.slowPath(FluxGenerate.java:262) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:204) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxUsing$UsingFuseableSubscriber.request(FluxUsing.java:317) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxSubscribeOn$SubscribeOnSubscriber.lambda$requestUpstream$0(FluxSubscribeOn.java:135) 	at reactor.core@3.3.2.RELEASE/reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84) 	at reactor.core@3.3.2.RELEASE/reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.lang.Thread.run(Thread.java:834)  2020/05/15-04:50:59.586-0,JAVA,0,level=ERROR,pid=6500,threadId=182,thread=webflux-selector-http-3,logger=org.springframework.web.server.adapter.HttpWebHandlerAdapter,message='[d8818abc-1105] Error [java.lang.UnsupportedOperationException] for HTTP GET ""/file/file5412465168127"", but ServerHttpResponse already committed (200 OK)' 2020/05/15-04:50:59.586-0,JAVA,0,level=ERROR,pid=6500,threadId=182,thread=webflux-selector-http-3,logger=reactor.netty.http.server.HttpServerOperations,message='[id: 0xd8818abc, L:/192.168.44.20:9090 - R:/192.168.44.23:37330] Error finishing response. Closing connection',exception=java.lang.UnsupportedOperationException 	at spring.web@5.2.4.RELEASE/org.springframework.http.ReadOnlyHttpHeaders.set(ReadOnlyHttpHeaders.java:106) 	at spring.web@5.2.4.RELEASE/org.springframework.http.HttpHeaders.setContentType(HttpHeaders.java:951) 	at webflux@2020.3.0-20200416.024359-2381/ErrorWebExceptionHandler.handle(ErrorWebExceptionHandler.java:82) 	at spring.web@5.2.4.RELEASE/org.springframework.web.server.handler.ExceptionHandlingWebHandler.lambda$handle$0(ExceptionHandlingWebHandler.java:77) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:88) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:100) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:390) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators.error(Operators.java:182) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoError.subscribe(MonoError.java:52) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Mono.subscribe(Mono.java:4105) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:97) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:390) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:185) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:251) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:100) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators.error(Operators.java:182) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:134) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Mono.subscribe(Mono.java:4090) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:97) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:390) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators.error(Operators.java:182) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:181) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:48) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1637) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1637) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1637) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:173) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2199) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.request(MonoPeekTerminal.java:132) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:318) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onSubscribe(MonoPeekTerminal.java:145) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Mono.subscribe(Mono.java:4105) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Mono.subscribe(Mono.java:4105) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:97) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onError(FluxPeekFuseable.java:227) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onError(FluxPeekFuseable.java:227) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MonoSubscriber.onError(Operators.java:1684) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onError(MonoIgnoreThen.java:306) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:185) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:251) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:100) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators.error(Operators.java:182) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoError.subscribe(MonoError.java:52) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Mono.subscribe(Mono.java:4105) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:97) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MonoSubscriber.onError(Operators.java:1684) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onError(MonoIgnoreThen.java:306) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:251) 	at spring.web@5.2.4.RELEASE/org.springframework.http.server.reactive.ChannelSendOperator$WriteCompletionBarrier.onError(ChannelSendOperator.java:414) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onError(MonoIgnoreElements.java:76) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:1876) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.Operators$MonoSubscriber.onError(Operators.java:1684) 	at reactor.core@3.3.2.RELEASE/reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onError(MonoIgnoreThen.java:306) 	at reactor.netty@0.9.4.RELEASE/reactor.netty.channel.MonoSendMany$SendManyInner.run(MonoSendMany.java:323) 	at reactor.netty@0.9.4.RELEASE/reactor.netty.channel.MonoSendMany$SendManyInner.trySchedule(MonoSendMany.java:383) 	at reactor.netty@0.9.4.RELEASE/reactor.netty.channel.MonoSendMany$SendManyInner.trySuccess(MonoSendMany.java:527) 	at reactor.netty@0.9.4.RELEASE/reactor.netty.channel.MonoSendMany$SendManyInner.trySuccess(MonoSendMany.java:94) 	at io.netty.common@4.1.45.Final/io.netty.util.internal.PromiseNotificationUtil.trySuccess(PromiseNotificationUtil.java:48) 	at io.netty.transport@4.1.45.Final/io.netty.channel.ChannelOutboundBuffer.safeSuccess(ChannelOutboundBuffer.java:717) 	at io.netty.transport@4.1.45.Final/io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:272) 	at io.netty.transport@4.1.45.Final/io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:352) 	at io.netty.transport@4.1.45.Final/io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:431) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:930) 	at io.netty.transport@4.1.45.Final/io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.forceFlush(AbstractNioChannel.java:361) 	at io.netty.transport@4.1.45.Final/io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:708) 	at io.netty.transport@4.1.45.Final/io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) 	at io.netty.transport@4.1.45.Final/io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) 	at io.netty.transport@4.1.45.Final/io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 	at io.netty.common@4.1.45.Final/io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.common@4.1.45.Final/io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at java.base/java.lang.Thread.run(Thread.java:834) ```  My first concern is ""Queue is full: Reactive Streams source doesn't respect backpressure"" – have no idea how could I ""respect backpressure"" – your expertise would be valued.  The second and the foremost one is ""Error [java.lang.UnsupportedOperationException] for HTTP GET ""/file/file5412465168127"", but ServerHttpResponse already committed (200 OK)'"". Evidence suggests that reactor-netty can't keep up with the transmission, fails, the error is propagated to the application exception handler which composes a 5xx response, but HttpWebHandlerAdapter afterwards detects that at least the status line is in the wire and rightly rejects 5xx response (the only thing it can do in such a situation). I came up with the idea of the conditional exception suppression: ```java .then(...) .onErrorResume(e -> serverWebExchange.getResponse().isCommitted(), e -> Mono.empty()); ``` hoping to prevent my exception handler from the error processing. In my eyes its an odd solution because such situations are inherent in HTTP servers.  Are there any flaws in my implementation or the problem is caused by an issue in DataBufferUtils or elsewhere?  **Environment:** * Java 11, * spring.web 5.2.4.RELEASE, * reactor.core 3.3.2.RELEASE, * reactor.netty 0.9.4.RELEASE","open","in: web,","evgenyvsmirnov","2020-05-18T04:42:20Z","2021-11-08T11:46:08Z"
"","25079","Introduce NON_EXTENSIBLE JSON assertion support in spring-test","Please add a method for `JSONCompareMode.NON_EXTENSIBLE` to `JsonExpectationsHelper` in `spring-test`.  Because: mostly you want to assert that both requests contain exactly the same content and the same fields. But order of elements usually does not matter, as json is nothing other than a HashMap.  That's simply not possible to assert as of now.  `NON_EXTENSIBLE` is the correct mode in that case.","closed","status: feedback-provided,","membersound","2020-05-14T12:52:09Z","2020-05-15T18:26:26Z"
"","24844","Add support for relative ordering","Our current support for `@Order` is using an absolute number with a default value of ""lowest precedence"" (i.e. `Integer.MAX_VALUE`). We also have `@PriorityOrdered` to override such ordering in certain scenarios.  One problem with the current default value is that it is not natural for customizers where you'd want the ""default"" ones to be at a given order with the ability of custom instance to run before, or after. Such default must provide a value as there is no way to run ""after"" with the current default value. A natural value for that is zero with negative values being processed before and positive values being processed after.  A better way to express ordering is to express it relative to another concept. You may need to run/customize/execute after or before another ""instance"".  In Spring Boot, we've essentially implemented that with `@AutoConfigureBefore`, `@AutoConfigureAfter` to order auto-configurations.   This issue is to discuss if there is an appetite to provide such constructs in the core framework, with an SPI that would let us order things (potentially being honored on `ObjectProvider#orderedStream()`.","open","type: enhancement,","snicoll","2020-04-02T07:49:09Z","2022-08-02T08:24:00Z"
"","25789","Construct StringWriter instances with appropriate initial size","Our `StringWriter` usage in several message converters and in `FileCopyUtils` effectively initializes a `StringBuffer` with a default initial capacity of 16. Since we use an initial size of 1024 for messages and 4096 for files in case of a byte array, we should align there for our equivalent `StringWriter` code paths.","closed","in: core,","jhoeller","2020-09-18T16:08:35Z","2020-10-07T12:26:06Z"
"","25117","Introduce serializeToByteArray/deserializeFromByteArray convenience methods","Our `SerializationDelegate` and the underlying `Serializer`/`Deserializer` interfaces are usually used with byte arrays. Introducing convenience methods for the byte array case simplies our own usage (e.g. in `ConcurrentMapCache` and `SerializingConverter`).","closed","type: enhancement,","jhoeller","2020-05-22T14:20:00Z","2020-05-22T15:17:28Z"
"","25488","Cache-busting does not work when lazy-initialization is enabled","Original issue here: https://github.com/thymeleaf/thymeleaf-spring/issues/227  It seems like cache-busting does not work when lazy initialization is active. Once I set it to false cache-busting works again.   This seems like a bug for the docs say:  >  In a web application, enabling lazy initialization will result in many web-related beans not being initialized until an HTTP request is received.  But this does not seem to be true for whatever component is responsible for `spring.resources.chain.strategy.content`.  Spring boot versions tested: 2.2.2 and 2.2.6   Tested with Thymeleaf  Miminal setup:  Check out https://github.com/ultraq/gs-serving-web-content/tree/cache-busting-issue/complete (branch cache-busting-issue).  In `application.properties`:  ```properties spring.resources.cache.cachecontrol.max-age=604800 spring.resources.chain.enabled=true spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** spring.resources.chain.html-application-cache=true  # toggle this on/off #spring.main.lazy-initialization=true ```  Maybe this behaviour is intended / to be expected - if so please add a paragraph to the docs.","open","in: web,","black-snow","2020-05-06T12:16:13Z","2021-11-10T12:28:01Z"
"","25000","AbstractReactiveTransactionManager bug","org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doGetTransaction method's return type should be Mono ,because maybe will go to get Connecion.","open","in: data,","qinarmy-zoro","2020-04-30T23:38:19Z","2021-11-10T12:13:42Z"
"","25045","Fix SpelEvaluationException with example code","org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'name' cannot be found on null","closed","in: core,","quaff","2020-05-11T01:20:48Z","2020-05-18T12:16:17Z"
"","25688","remove-repeat-get-handlerMappings","org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#getHandlerMappings code line 157:     I think maybe don't need assign this.handlerMappings to handlerMappings,because visibility can be guaranteed with volatile and synchronized。","closed","status: invalid,","xichaodong","2020-09-03T14:50:25Z","2020-09-09T13:43:42Z"
"","25846","Drop explicit zeroing at instantiation of Atomic* objects","Often fields of atomic types e.g. AtomicInteger are explicitly zeroed at initialization, which is redundant and slower than relying on default values: ```java @State(Scope.Thread) @OutputTimeUnit(TimeUnit.NANOSECONDS) @BenchmarkMode(value = Mode.AverageTime) public class AtomicBenchmark {   @Benchmark   public Object defaultValue() {     return new AtomicInteger();   }   @Benchmark   public Object explicitValue() {     return new AtomicInteger(0);   } } ``` Semantically both new AtomicInteger() and new AtomicInteger(0) are the same, but explicitValue() is much slower: ```java Benchmark                      Mode  Cnt   Score   Error  Units AtomicBenchmark.defaultValue   avgt   30   4.778 ± 0.403  ns/op AtomicBenchmark.explicitValue  avgt   30  11.846 ± 0.273  ns/op ``` This is related to https://github.com/spring-projects/spring-framework/pull/25261","closed","in: core,","stsypanov","2020-09-30T20:15:43Z","2020-10-06T15:19:33Z"
"","25253","NoRollbackFor rule causes TransactionAspectSupport to log unwarranted ""exception overridden"" error on WebSphere","Observed using Spring 4.3.26, expecting same behavior from Spring 5.x after code comparison.  The application code throws custom `NoDataFoundException` checked exception in normal conditions to report absence of data, which is then handled outside the transaction. Certainly not the best pattern, but unsolvable for now due to a myriad of possible side effects.  To alleviate the issue, we're using `NoRollbackRule` attribute in the form of `+NoDataFoundException` on `TransactionProxyFactoryBean` like so: ```                            PROPAGATION_REQUIRED,+NoDataFoundException ```  This results in `NoDataFoundException` being correctly rethrown outside tx, but still emitting an error log statement like so:   ``` org.springframework.transaction.interceptor.TransactionAspectSupport invokeWithinTransaction Application exception overridden by commit exception                                   ```  Stepping into `invokeWithinTransaction` code, it appears that the checked exception being rethrown is mistaken as a ""new"" transaction commit exception, overriding... itself.  Initial capture of the checked exception: ``` if (txAttr.rollbackOn(ex)) {  [...] } else { 	// A normal return value: will lead to a commit. 	throwableHolder.throwable = ex; 	return null; } ```  Rethrowing outside of tx: ``` // Check result state: It might indicate a Throwable to rethrow. if (throwableHolder.throwable != null) { 	throw throwableHolder.throwable; } ```  Exception re-handled on exit, triggering extraneous logging: ``` catch (Throwable ex2) { 	if (throwableHolder.throwable != null) { 		logger.error(""Application exception overridden by commit exception"", throwableHolder.throwable); 	} 	throw ex2; } ```  Fixing this situation should be as simple as comparing `ex2` and `throwableHolder.throwable`  for equality (in addition to the null check already in place), or resetting  `throwableHolder.throwable` to `null` upon rethrowing the checked exception. A PR can be submitted to this effect if requested.  A quick workaround would be to disable logging for the `TransactionProxyFactoryBean`, which is unpalatable because of the many other serious error conditions that could go unreported. A more sophisticated patch would apply a targeted logging filter to ignore error entries mentioning the checked exception class.","closed","type: bug,","fralalonde","2020-06-15T20:10:59Z","2020-06-17T13:47:49Z"
"","25350","Mime type ""application/*"" is not compatible with ""application/vnd+json""","Now mime types with suffix (and wildcard subtypes with suffix) are not compatible with wildcard subtypes.  For example, mime type `application/*` is not compatible with `application/vnd+json`.  This may lead to some surprising results -- for example:  ```java package com.example.demo;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  @SpringBootApplication public class DemoApplication {      public static void main(String[] args) {         SpringApplication.run(DemoApplication.class, args);     }  }  @RestController class DemoController {      @GetMapping(path = ""/demo"", produces = ""application/vnd+json"")     public void demo() {     } } ```  returns 406 error when client requests for a ""application/*"" mime type  ``` $ curl --header ""Accept: application/*"" http://localhost:8080/demo {""timestamp"":""2020-07-01T06:40:44.644+0000"",""status"":406,""error"":""Not Acceptable"",""message"":""Could not find acceptable representation"",""path"":""/demo""} ```  I am not sure is this bug or feature according to some standards, but the Javadoc for `MimeType.isCompatibleWith` says:  > In effect, this method is similar to `includes`, except that it is symmetric.""  But at the same time `MimeType.includes` method assumes that `application/*` includes `application/vnd+json`:  ```java new MimeType(""application"", ""*"").isCompatibleWith(new MimeType(""application"", ""vnd+json"")); // false new MimeType(""application"", ""*"").includes(new MimeType(""application"", ""vnd+json"")); // true ```","closed","type: enhancement,","anton-filatov","2020-07-01T06:50:11Z","2020-09-08T12:47:21Z"
"","24845","Injection of List is inconsistent with Resource[]","Normally it's safe to change type from array to list, but it's not for `Resource`. ```java @Value(""${resources:file:/tmp/*.text}"") Resource[] resourceArray;  // multiple FileSystemResource  @Value(""${resources:file:/tmp/*.text}"") List resourceList; // only one FileUrlResource ``` here is the full test  ```java import static org.junit.Assert.assertEquals;  import java.io.File; import java.io.IOException; import java.util.List;  import org.junit.AfterClass; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.Resource; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestPropertySource; import org.springframework.test.context.junit4.SpringRunner;  import test.ResourceInjectionTest.TestConfiguration;  @RunWith(SpringRunner.class) @TestPropertySource(properties = { ""resources=file:/tmp/*.text"" }) @ContextConfiguration(classes = TestConfiguration.class) public class ResourceInjectionTest {  	private static File[] files;  	@Autowired 	private TestConfiguration testConfiguration;  	@BeforeClass 	public static void setup() throws IOException { 		files = new File[2]; 		files[0] = new File(""/tmp"", ""a.text""); 		files[1] = new File(""/tmp"", ""b.text""); 		for (File f : files) 			f.createNewFile(); 	}  	@AfterClass 	public static void cleanup() { 		for (File f : files) 			f.delete(); 	}  	@Test 	public void testInjection() { 		assertEquals(2, testConfiguration.resourceArray.length); // two FileSystemResource 		assertEquals(2, testConfiguration.resourceList.size()); // one FileUrlResource 	}  	static class TestConfiguration { 		 		@Value(""${resources}"") 		Resource[] resourceArray;  		@Value(""${resources}"") 		List resourceList; 		 	} }  ```","open","type: enhancement,","quaff","2020-04-02T08:19:55Z","2020-05-11T15:03:30Z"
"","25145","Dynamically change the application properties defined in the YAML file while running Springboot tests","My Use case is,  organisation wide all our microservies are using `YAML`, so we cannot move from `YAML `to `.properties`. In one of my recent app, I am using testcontainers for Unit tests, where testcontainers randomly selects any available port to start the container. So before running the tests I have to dynamically change the PORT property which is defined in the YAML file. For .properties file, it was straightforward with `ApplicationContextInitializer `& `TestPropertyValues `- like `TestPropertyValues.of(""spring.rabbitmq.port"" + container.getMappedPort(5672)).applyTo(applicationContext);`  Not able to achieve this, being the port property is defined in the YAML file.  Any workaround / suggestions ?","closed","status: duplicate,","raahool","2020-05-27T20:57:45Z","2020-05-29T18:31:48Z"
"","25619","DefaultListableBeanFactory memory leak spring version 4.3.11.RELEASE","My project using spring version 4.3.11.Release and i can see huge memory leakage in DefaultListableBeanFactory. We are not using any LinkedList, But it looks like spring defaultListableBeanFactory using internally and is not getting garbage collected  Please let me know, how to fix this issue and it would be really helpful  One instance of ""org.springframework.beans.factory.support.DefaultListableBeanFactory"" loaded by ""org.apache.catalina.loader.ParallelWebappClassLoader @ 0x4c00ef4f0"" occupies 220,844,344 (15.97%) bytes. The memory is accumulated in one instance of ""java.util.LinkedList"" loaded by """".","open","status: feedback-provided,","johnpalantir","2020-08-20T22:59:16Z","2021-11-12T12:51:20Z"
"","25208","In the yaml file, use @Value annotation to parse the attribute to get an error value","My configuration file is application.yml, and the content is as follows: ``` bizlimit:   common:     startTime: 05:00     endTime: 23:00 ```  Java code: ``` @Component public class BizTimeLimitProperties {     @Value(""${bizlimit.common.startTime}"")     private String startTime;     @Value(""${bizlimit.common.endTime}"")     private String endTime; } ```  In debug mode, I found that startTime is correct, but endTime is '1380'","closed","for: stackoverflow,","SmilingBug","2020-06-08T10:36:14Z","2020-06-08T10:45:15Z"
"","25236","Can Spring JDBC insert rows into a Snowflake table when autoincrement is used?","My code to insert a row into my Snowflake table is throwing an exception since the **null** value that _SimpleJdbcInsert_ puts into the INSERT sql violates the NOT NULL constraint on the table.  I'm using Spring Boot 2.2.5, Spring 5.2.4, and Snowflake JDBC driver 3.12.6.  Knowing that the ROW_ID column is an autoincrement column, shouldn't the generated INSERT sql statement omit this field?  Here's the info:  **DDL:** ``` create or replace TABLE TEST ( 	ROW_ID NUMBER(38,0) NOT NULL autoincrement, 	COL1 VARCHAR(50), 	constraint PK_ROW_ID primary key (ROW_ID) ); ``` **Code:** ```     private void insertRecord() {         SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(jdbcTemplate)                 .withTableName(""TEST"");          Map parameters = new HashMap();         parameters.put(""COL1"", ""foobar"");          int i = simpleJdbcInsert.execute(parameters);     } ``` **Exception/Log:** ``` c.c.test.SnowflakeTestApplication       :141 : Creating data source snowflake ... c.c.test.SnowflakeTestApplication       :157 : Data source created successfully c.c.test.SnowflakeTestApplication       :61 : Started SnowflakeTestApplication in 2.327 seconds (JVM running for 4.622) o.s.jdbc.core.simple.SimpleJdbcInsert   :308 : JdbcInsert not compiled before execution - invoking compile o.s.jdbc.datasource.DataSourceUtils     :115 : Fetching JDBC Connection from DataSource o.s.j.datasource.SimpleDriverDataSource :142 : Creating new JDBC Driver Connection to [jdbc:snowflake://xxxxxx.us-east-1.snowflakecomputing.com/?db=DEMO_DB&schema=PUBLIC&role=U_ENG_DW_DDL&warehouse=DEV_ADHOC_WH] o.s.j.c.m.TableMetaDataProviderFactory  :76 : Using GenericTableMetaDataProvider o.s.j.c.metadata.TableMetaDataProvider  :154 : GetGeneratedKeys is not supported o.s.j.c.metadata.TableMetaDataProvider  :392 : Retrieving meta-data for DEMO_DB/PUBLIC/TEST o.s.j.c.metadata.TableMetaDataProvider  :418 : Retrieved meta-data: ROW_ID -5 false o.s.j.c.metadata.TableMetaDataProvider  :418 : Retrieved meta-data: COL1 12 true o.s.jdbc.core.simple.SimpleJdbcInsert   :281 : Compiled insert object: insert string is [INSERT INTO TEST (ROW_ID, COL1) VALUES(?, ?)] o.s.jdbc.core.simple.SimpleJdbcInsert   :264 : JdbcInsert for table [TEST] compiled o.s.jdbc.core.simple.SimpleJdbcInsert   :356 : The following parameters are used for insert INSERT INTO TEST (ROW_ID, COL1) VALUES(?, ?) with: [null, foobar] o.s.jdbc.core.JdbcTemplate              :860 : Executing prepared SQL update o.s.jdbc.core.JdbcTemplate              :609 : Executing prepared SQL statement [INSERT INTO TEST (ROW_ID, COL1) VALUES(?, ?)] o.s.jdbc.datasource.DataSourceUtils     :115 : Fetching JDBC Connection from DataSource o.s.j.datasource.SimpleDriverDataSource :142 : Creating new JDBC Driver Connection to [jdbc:snowflake://xxxxxx.us-east-1.snowflakecomputing.com/?db=DEMO_DB&schema=PUBLIC&role=U_ENG_DW_DDL&warehouse=DEV_ADHOC_WH] o.s.jdbc.support.SQLErrorCodesFactory   :203 : Looking up default SQLErrorCodes for DataSource [org.springframework.jdbc.datasource.SimpleDriverDataSource@7b5b5bfe] o.s.jdbc.datasource.DataSourceUtils     :115 : Fetching JDBC Connection from DataSource o.s.j.datasource.SimpleDriverDataSource :142 : Creating new JDBC Driver Connection to [jdbc:snowflake://xxxxxx.us-east-1.snowflakecomputing.com/?db=DEMO_DB&schema=PUBLIC&role=U_ENG_DW_DDL&warehouse=DEV_ADHOC_WH] o.s.jdbc.support.SQLErrorCodesFactory   :186 : SQL error codes for 'Snowflake' not found o.s.jdbc.support.SQLErrorCodesFactory   :247 : Caching SQL error codes for DataSource [org.springframework.jdbc.datasource.SimpleDriverDataSource@7b5b5bfe]: database product name is 'Snowflake' s.j.s.SQLErrorCodeSQLExceptionTranslator:285 : Unable to translate SQLException with Error code '100072', will now try the fallback translator o.s.j.s.SQLStateSQLExceptionTranslator  :98 : Extracted SQL state class '22' from value '22000' ... java.lang.IllegalStateException: Failed to execute ApplicationRunner 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:778) 	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:765) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) 	at com.covetrus.test.SnowflakeTestApplication.main(SnowflakeTestApplication.java:45) Caused by: org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback; SQL [INSERT INTO TEST (ROW_ID, COL1) VALUES(?, ?)]; NULL result in a non-nullable column; nested exception is net.snowflake.client.jdbc.SnowflakeSQLException: NULL result in a non-nullable column 	at org.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104) 	at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72) 	at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) 	at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) 	at org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1443) 	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:633) 	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:862) 	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:917) 	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:922) 	at org.springframework.jdbc.core.simple.AbstractJdbcInsert.executeInsertInternal(AbstractJdbcInsert.java:358) 	at org.springframework.jdbc.core.simple.AbstractJdbcInsert.doExecute(AbstractJdbcInsert.java:337) 	at org.springframework.jdbc.core.simple.SimpleJdbcInsert.execute(SimpleJdbcInsert.java:117) 	at com.covetrus.test.SnowflakeTestApplication.insertRecord(SnowflakeTestApplication.java:99) 	at com.covetrus.test.SnowflakeTestApplication.run(SnowflakeTestApplication.java:51)  ```","closed","","joepardi","2020-06-10T20:04:04Z","2022-02-18T19:06:53Z"
"","24947","Allow override of data binding in ModelAttributeMethodArgumentResolver","Motivation ---------- The Spring MVC `ModelAttributeMethodProcessor` includes many helpful extension methods that allow developers to extend and enhance the data binding capabilities of the class. Unfortunately, Spring WebFlux's equivalent class, the `ModelAttributeMethodArgumentResolver`, does not include these same extension methods. I am leveraging these extension methods, specifically the `bindRequestParameters` method, to provide valuable enhancements to my application. I would like to provide these same enhancements to the WebFlux portion of my application and am unable to do so at this time. I would like to update the WebFlux `ModelAttributeMethodArgumentResolver` to add the `bindRequestParameters` method.  Modifications ------------- I created a new method called `bindRequestParameters` and encapsulated the `WebExchangeDataBinder` bind call inside of it. This method is marked as protected as it should only be used by children of this class. This change mirrors the behavior in the equivalent Spring MVC class (`ModelAttributeMethodProcessor`).  Result ------ The WebFlux `ModelAttributeMethodArgumentResolver` can now accept alternative data binding implementations mirroring the Web MVC behavior.","closed","type: enhancement,","mattbertolini","2020-04-20T23:44:15Z","2020-04-25T14:27:37Z"
"","25071","Publish documentation under reference/html folder","Most Spring projects publish their documentation under a `/html` or `/htmlsingle` subfolder. Spring Framework used to do this as well [in 4.x](https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/) but in 5.x [it changed](https://docs.spring.io/spring-framework/docs/5.0.x/spring-framework-reference/).  For consistency with other projects, it would be nice to have the `/html` folder back.  See https://github.com/spring-projects/spring-security/issues/8420 for a similar request in Spring Security.","closed","type: documentation,","philwebb","2020-05-13T22:48:03Z","2020-09-12T16:15:40Z"
"","25300","Support fragments in UriComponentsBuilder.fromHttpUrl()","Method `fromHttpUrl` ends with `IllegalArgumentException` if parameter contain fragment  ``` java.lang.IllegalArgumentException: [https://tools.ietf.org/html/rfc6749#section-4.1] is not a valid HTTP URL ``` Test case:  ```java         String redirectUri = ""https://tools.ietf.org/html/rfc6749#section-4.1"";         java.net.URL url1 = new URL(redirectUri);         UriComponentsBuilder urlBuilder = UriComponentsBuilder.fromUriString(redirectUri);         //UriComponentsBuilder urlBuilder = UriComponentsBuilder.fromHttpUrl(redirectUri); ```  From code (for URL '#' missing):  ```java 	// Regex patterns that matches URIs. See RFC 3986, appendix B 	private static final Pattern URI_PATTERN = Pattern.compile( 			""^("" + SCHEME_PATTERN + "")?"" + ""(//("" + USERINFO_PATTERN + ""@)?"" + HOST_PATTERN + ""(:"" + PORT_PATTERN + 					"")?"" + "")?"" + PATH_PATTERN + ""(\\?"" + QUERY_PATTERN + "")?"" + ""(#"" + LAST_PATTERN + "")?"");  	private static final Pattern HTTP_URL_PATTERN = Pattern.compile( 			""^"" + HTTP_PATTERN + ""(//("" + USERINFO_PATTERN + ""@)?"" + HOST_PATTERN + ""(:"" + PORT_PATTERN + "")?"" + "")?"" + 					PATH_PATTERN + ""(\\?"" + LAST_PATTERN + "")?""); ```","closed","type: enhancement,","ljosefik","2020-06-22T14:39:31Z","2020-06-26T16:33:18Z"
"","25612","Merge pull request #1 from spring-projects/master","merge","closed","status: invalid,","DahuaChan","2020-08-19T12:59:51Z","2020-08-19T13:04:29Z"
"","24969","Merge pull request #1 from spring-projects/master","master","closed","","MrJian8","2020-04-25T12:14:18Z","2020-04-25T12:14:34Z"
"","25002","Supplement Test Cases In XmlBeanFactoryTests : Resolve Circle Reference When Use Aop","Many people implementate `BeanPostProcessor` to realize Aop, but it has a problem with cicle reference. Implementation `SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference` is a good practice, for example `AbstractAutoProxyCreator`. I think the case could make learners understand better.","open","in: core,","lixiaolong11000","2020-05-01T09:40:43Z","2021-11-10T10:03:01Z"
"","25824","Method chaining - AbstractDriverBasedDataSource","Make it more convenient for callers when using multiple set methods in a row by allowing method chaining.  My pull request would make the following sample code possible: var datasource = new SimpleDriverDataSource()   .setDriver(new org.postgresql.Driver())   .setUrl(""jdbc:postgresql:my_database"")   .setUsername(""postgres"")   .setPassword(""whatever"");  My motivation for this pull request was that I was writing some sample code, and I was tired of constantly having to add ""object.method"" for each set call like this: var datasource = new SimpleDriverDataSource(); datasource.setDriver(new org.postgresql.Driver()) datasource.setUrl(""jdbc:postgresql:my_database"") datasource.setUsername(""postgres"") datasource.setPassword(""whatever"");  Trying to reduce code writing while having the same functionality, and to make it look more elegant and readable.   If my request was approved and merged, the ""object.method"" way of doing it would still work (backwards-compatible) AND also allow method chaining.","closed","","danuvian","2020-09-27T20:33:46Z","2022-02-18T19:06:29Z"
"","25823","Method chaining AbstractDriverBasedDataSource","Make it more convenient for callers when using multiple set methods in a row by allowing method chaining.  I was motivated to change this when I was trying some sample code that looked similar to this: var ds = new SimpleDriverDataSource(); ds.setDriver(new org.postgresql.Driver()); ds.setUrl(""jdbc:postgresql:my_database""); ds.setUsername(""postgres""); ds.setPassword(""whatever"");  My change would make it easier to the above with less code: var ds = new SimpleDriverDataSource()   .setDriver(new org.postgresql.Driver())   .setUrl(""jdbc:postgresql:my_database"")   .setUsername(""postgres"")   .setPassword(""whatever"");","closed","","danuvian","2020-09-27T20:10:27Z","2022-02-18T19:06:28Z"
"","24991","Upgrade to Asciidoctor Gradle plugin 3.x","Looking at [the reference documentation of the plugin](https://asciidoctor.github.io/asciidoctor-gradle-plugin/development-3.x/user-guide/), we might improve our configuration and better include the documentation theme from spring-doc-resources.","closed","type: dependency-upgrade,","bclozel","2020-04-29T10:33:48Z","2020-09-23T08:07:30Z"
"","25139","run CglibProxyControllerTests have NullPointerException","logger is null   when run   if (logger.isTraceEnabled()) { 			logger.trace(""Mapped to "" + handler); 		} 		else if (logger.isDebugEnabled() && !request.getDispatcherType().equals(DispatcherType.ASYNC)) { 			logger.debug(""Mapped to "" + executionChain.getHandler()); 		}  this have NullPointerException","closed","status: invalid,","liangkunJoin","2020-05-27T15:40:54Z","2020-05-28T16:10:59Z"
"","25349","Avoid resizing of fixed-size HashMap","loadFactor should be 1.0 instead of default 0.75","closed","type: enhancement,","quaff","2020-07-01T01:28:14Z","2020-08-26T14:11:06Z"
"","24889","HttpStatusCodeException does not protect against NullPointerException","Lines 104 and 110- the _statusCode_ variable can be null. When the NullPointerException is thrown from line 110, it has no stack trace and is very difficult to debug.","closed","status: declined,","jimgood","2020-04-09T13:14:02Z","2020-04-22T09:38:14Z"
"","25362","Add support for LHS Brackets from query parameters","LHS Brackets style of query parameters is commonly used, it used by Stripe, GoCardless, and others. Sample: `htps://domain.com?price[gte]=200&price[lte]=500`  https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/#lhs-brackets  Will be great to be possible to map this to the class ``` class Price {     private Long gte;     private Long lte;     // ... }  class Request {     private Price price;     // ... } ```  It works if the `price` is a `Map` ``` class Request {     private Map price;     // ... } ``` But it doesn't work for a `class`.","closed","in: web,","raderio","2020-07-06T13:14:26Z","2021-07-07T12:53:29Z"
"","25547","Update WebFlux documentation with regards to logging appenders","Let's say we have a WebFlux Annotated Controller like the following:  ```java @PostMapping(value = ""api/create/user"", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE) @ResponseStatus(value = HttpStatus.OK) public Mono createUser(@Valid @RequestBody UserInfo userInfo) {     log.info(""userInfo request body : {}"", userInfo);     return userInfoService.createUserInfo(userInfo); } ``` We assume we use an SLF4J logger implementation and we have file appenders defined.  This is a blocking operation. How should it be handled? Not only on Controller level but on Service level as well since we may have needs to debug or trace various steps of a flow. Should AsyncAppender be used e.g. https://logging.apache.org/log4j/2.x/manual/async.html ?   I believe that there is not enough documentation on this topic to explain the details, the options and various use-cases.","closed","type: documentation,","kmandalas","2020-08-06T11:37:32Z","2020-09-25T20:57:07Z"
"","25262","Use neutral terminology instead of oppressive language","Let's please do this:  - blacklist / whitelist -> blocklist / allowlist - change `master` branch to `main` - white/black box testing -> clear/opaque  It's time!","closed","type: task,","nealeu","2020-06-17T08:32:05Z","2021-03-14T13:29:47Z"
"","24960","5.0.x","learn","closed","status: invalid,","ludishenxian","2020-04-23T07:09:33Z","2020-04-23T07:12:36Z"
"","25017","Fix concurrency issues in XStreamMarshaller","Just stumbled on a nasty concurrency issue in `org.springframework.oxm.xstream.XStreamMarshaller`.  When you forget to call `afterPropertiesSet` on this marshaller, the internally held XStream instance will not be initialized. Instead, it will be done in the method `getXStream`, which is called from both marshal and unmarshal methods.  This initialization is not guarded, and might happen concurrently. In this case, the `ConverterLookup` used to store converters will be shared by the XStream instances that are constructed, which can lead to strange application behaviour, since the underlying data structure is not thread safe.  In our application, it lead to very strange errors during XML marshalling/unmarshalling, since a couple of converters were missing. This happened whenever our app process scaled up during high load.   I see 2 possible solutions: * throw an exception in case afterPropertiesSet is not called on an instance  * make XStream initialization thread safe  Spring version affected is 5.2.5.RELEASE","closed","type: enhancement,","JakobFels","2020-05-05T14:35:20Z","2020-05-07T10:40:59Z"
"","25599","Error import for test class","Jaxb2MarshallerTests and Jaxb2UnmarshallerTests can not import org.springframework.oxm.jaxb.test.FlightType and org.springframework.oxm.jaxb.test.Flights, can not find  org.springframework.oxm.jaxb.test package  spring version :5.1.18.BUILD-SNAPSHOT","closed","status: invalid,","wolfewf","2020-08-17T05:57:31Z","2020-08-17T12:43:11Z"
"","25470","webClient get error timeout while I've set timeout for it","java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 20000ms in 'source(MonoDefer)' (and no fallback has been configured) 	at reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.handleTimeout(FluxTimeout.java:289) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.doTimeout(FluxTimeout.java:274) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.publisher.FluxTimeout$TimeoutTimeoutSubscriber.onNext(FluxTimeout.java:396) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.publisher.StrictSubscriber.onNext(StrictSubscriber.java:89) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.publisher.MonoDelay$MonoDelayRunnable.run(MonoDelay.java:117) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:68) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:28) [reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE] 	at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) [?:?] 	at java.util.concurrent.FutureTask.run(FutureTask.java) [?:?] 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) [?:?] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?] 	at java.lang.Thread.run(Thread.java:834) [?:?]  Used:  >               org.springframework             spring-webflux             5.2.4.RELEASE","closed","for: stackoverflow,","hoihmy","2020-07-24T08:40:41Z","2020-07-24T09:46:14Z"
"","25427","Defer creating logger in StandardWebSocketHandlerAdapter","It's similar to https://github.com/spring-projects/spring-framework/issues/23655 Open Liberty will load class `org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter` before starting of application, it trigger log4j2 initialization before web application initialization, system property lookup will not using value set at `WebApplicationInitializer::onStartup`.  here is stack trace: ``` [err]   at org.apache.logging.log4j.core.lookup.SystemPropertiesLookup.lookup(SystemPropertiesLookup.java:45) [err]   at org.apache.logging.log4j.core.lookup.AbstractLookup.lookup(AbstractLookup.java:33) [err]   at org.apache.logging.log4j.core.lookup.Interpolator.lookup(Interpolator.java:198) [err]   at org.apache.logging.log4j.core.lookup.StrSubstitutor.resolveVariable(StrSubstitutor.java:1060) [err]   at org.apache.logging.log4j.core.lookup.StrSubstitutor.substitute(StrSubstitutor.java:982) [err]   at org.apache.logging.log4j.core.lookup.StrSubstitutor.substitute(StrSubstitutor.java:878) [err]   at org.apache.logging.log4j.core.lookup.StrSubstitutor.replace(StrSubstitutor.java:433) [err]   at org.apache.logging.log4j.core.config.plugins.visitors.PluginBuilderAttributeVisitor.visit(PluginBuilderAttributeVisitor.java:49) [err]   at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.injectFields(PluginBuilder.java:185) [err]   at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:121) [err]   at org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:1002) [err]   at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:942) [err]   at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:934) [err]   at org.apache.logging.log4j.core.config.AbstractConfiguration.doConfigure(AbstractConfiguration.java:552) [err]   at org.apache.logging.log4j.core.config.AbstractConfiguration.initialize(AbstractConfiguration.java:241) [err]   at org.apache.logging.log4j.core.config.AbstractConfiguration.start(AbstractConfiguration.java:288) [err]   at org.apache.logging.log4j.core.LoggerContext.setConfiguration(LoggerContext.java:579) [err]   at org.apache.logging.log4j.core.LoggerContext.reconfigure(LoggerContext.java:651) [err]   at org.apache.logging.log4j.core.LoggerContext.reconfigure(LoggerContext.java:668) [err]   at org.apache.logging.log4j.core.LoggerContext.start(LoggerContext.java:253) [err]   at org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:153) [err]   at org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:45) [err]   at org.apache.logging.log4j.LogManager.getContext(LogManager.java:194) [err]   at org.apache.logging.log4j.spi.AbstractLoggerAdapter.getContext(AbstractLoggerAdapter.java:138) [err]   at org.apache.logging.log4j.jcl.LogAdapter.getContext(LogAdapter.java:39) [err]   at org.apache.logging.log4j.spi.AbstractLoggerAdapter.getLogger(AbstractLoggerAdapter.java:48) [err]   at org.apache.logging.log4j.jcl.LogFactoryImpl.getInstance(LogFactoryImpl.java:40) [err]   at org.apache.logging.log4j.jcl.LogFactoryImpl.getInstance(LogFactoryImpl.java:55) [err]   at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:655) [err]   at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.(StandardWebSocketHandlerAdapter.java:45) [err]   at java.lang.Class.forName0(Native Method) [err]   at java.lang.Class.forName(Class.java:348) [err]   at com.ibm.ws.webcontainer.osgi.webapp.WebApp.addClassToHandlesTypesStartupSet(WebApp.java:1093) [err]   at [internal classes] [err]   at com.ibm.ws.webcontainer.osgi.WebContainer.access$000(WebContainer.java:110) [err]   at com.ibm.ws.webcontainer.osgi.WebContainer$2.run(WebContainer.java:951) ```","closed","type: enhancement,","quaff","2020-07-20T07:49:39Z","2020-07-20T15:08:25Z"
"","25038","Use Map::computeIfAbsent to simplify scope implementations","It's a tiny improvement.","closed","in: core,","quaff","2020-05-09T07:50:53Z","2020-08-22T22:00:23Z"
"","24995","Introduce mechanism to discover whether a reactive type registered in ReactiveAdapterRegistry uses deferred computation","It would make sense to describe whether a type registered in `ReactiveAdapterRegistry` uses deferred computation. Deferred types are `Publisher` types, RxJava types and Kotlin's flow. Non-deferred types (eager computation) are which act as `Future` or Promise.  Background is that Spring Data uses `ReactiveAdapterRegistry` to determine a stack that is used to implement a repository interface. An issue comes into play when a repository uses `@Async` in combination with `CompletableFuture`. These methods are typically implemented using the imperative stack and calls are offloaded to a thread pool. Since the registry lists `CompletionStage`/`CompletableFuture` types, future types are considered to be reactive ones.  Related issue: https://jira.spring.io/browse/DATAJPA-1710","closed","type: enhancement,","mp911de","2020-04-30T08:41:31Z","2020-05-04T09:56:35Z"
"","25766","Support interception of calls to the underlying cache","It would be nice if there was a pluggable mechanism (i.e. strategy interface) in order to intercept put/get to the underlying caches that the CacheManager interacts with.  This would allow for transforming read/writes in order to decrypt/encrypt the values.  There seems to be another user requesting the same at SO: https://stackoverflow.com/questions/46478798/how-to-write-custom-interceptor-for-spring-cachecachable","closed","status: declined,","davidkarlsen","2020-09-14T11:23:26Z","2020-09-23T07:29:11Z"
"","24898","VersionResourceResolver should use weak ETags to allow for HTTP compression","It is currently not possible to compress static resources that are passed through the `VersionResourceResolver`.  `VersionResourceResolver` (or `FileNameVersionedResource` , to be more precise) unconditionally sets the ETag-header to a resource's MD5 hash whenever `getResponseHeaders()` is called (cf. [here](https://github.com/spring-projects/spring-framework/blob/4523d9586fcd0e18bc2e791201ad6261931e58b3/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/VersionResourceResolver.java#L316)). On the other hand, Tomcat's `CompressionConfig#useCompression()` (and probably other web servers) considers resources with a strong ETag-header not eligible for compression (cf. code line [here](https://github.com/apache/tomcat/blob/765f94482637d31cf1e5b561504107288ad498ea/java/org/apache/coyote/CompressionConfig.java#L243)). This seems to be reasonable to not break the semantics of strong ETags.  A minimal reproducable setup is provided [in this Github project](https://github.com/luddwichr/etag-and-gzip). I also posted a [question on Stack Overflow](https://stackoverflow.com/q/60377766/7480395) without any considerable input to resolve the problem (yet).  Is the desired use case (hash-based cache busting and compression) completely off what you normally do? Did I miss something? Or do you agree that making it possible to disable setting the ETag-header is a viable way to allow for this use case? At least [issue 17963](https://github.com/spring-projects/spring-framework/issues/17963) mentioned the ETag-header feature, but ""provide optional configuration setting to disable that behavior"" seems not to have been considered.  Removing the ETag header before the web server checks if compression can be used seems like a hack to me (e.g. using [this]( https://stackoverflow.com/a/7895292/7480395) mechanism). Also, this might break other use cases within an application where ETag headers are desirable...","closed","type: enhancement,","luddwichr","2020-04-11T12:53:17Z","2020-05-11T19:42:28Z"
"","25850","Document @DynamicPropertySource use cases that require @DirtiesContext","It appears that `@DynamicPropertySource` cannot be used on a test superclass. See https://twitter.com/aheritier/status/1311721275811917824","closed","type: documentation,","philwebb","2020-10-01T18:12:45Z","2020-10-27T13:26:59Z"
"","25826","@ConditionalOnProperty with @PropertySource behaviour (former not loading from latter)","Issue with Spring Boot 2.3.3.RELEASE  I have provided an example project of what I'm trying to accomplish [here](https://github.com/napapu/dependency-property-experiment/blob/master/src/main/java/org/example/config/ConditionalBeansConfig.java).  The problem relates to @ConditionalOnProperty annotation when used at the config class level to enumerate based on a properties file (purposely not application-*.properties) that has been loaded via a @PropertySource (could be the same or different configuration class, doesn't matter).  Based on the documentation of @Conditional, when used at the config class level, all the beans used in that class should be subjected to that condition. However, this is not working as intended because the bean in my example will only load when @ConditionalOnProperty is used at the _bean_ level.  Is this a gotcha to be aware of when using these in tandem? I would assume that @ConditionalOnProperty would work at the config class level and apply that same conditional to all the beans declared in the config.  Thanks!","closed","status: invalid,","napapu","2020-09-28T06:58:58Z","2020-09-28T07:06:49Z"
"","24976","Don't get ContentCachingResponseWrapper in ShallowEtagHeaderFilter so that users can extend this wrapper","Issue Description: Code in `ShallowEtagHeaderFilter`: [`WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);`](https://github.com/spring-projects/spring-framework/blob/c237338d8f4b0100c8432c48acc2cabc8305a651/spring-web/src/main/java/org/springframework/web/filter/ShallowEtagHeaderFilter.java#L116) should be replaced into  `WebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);` so that users can implement their own business logic based on `ContentCachingResponseWrapper`.  Change `ContentCachingResponseWrapper` to `ConditionalContentCachingResponseWrapper` so that it gets the right one. ``` private void updateResponse(HttpServletRequest request, HttpServletResponse response) throws IOException {  	ContentCachingResponseWrapper wrapper =  // WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);    WebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);  		Assert.notNull(wrapper, ""ContentCachingResponseWrapper not found""); 		HttpServletResponse rawResponse = (HttpServletResponse) wrapper.getResponse();  		if (isEligibleForEtag(request, wrapper, wrapper.getStatus(), wrapper.getContentInputStream())) { 			String eTag = wrapper.getHeader(HttpHeaders.ETAG); 			if (!StringUtils.hasText(eTag)) { 				eTag = generateETagHeaderValue(wrapper.getContentInputStream(), this.writeWeakETag); 				rawResponse.setHeader(HttpHeaders.ETAG, eTag); 			} 			if (new ServletWebRequest(request, rawResponse).checkNotModified(eTag)) { 				return; 			} 		}  		wrapper.copyBodyToResponse(); 	} ```  I have implemented my own Filter, and in my own Filter, i have implemented my own ResponseWrapper which extends `ContentCachingResponseWrapper`, everything works fine if `ShallowEtagHeaderFilter` is not loaded, but when it works with `ShallowEtagHeaderFilter`, when `ShallowEtagHeaderFilter.updateResponse` is invoked, the real HttpServletResponse get through `WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);` become my own ResponseWrapper, so my own logic will be invoked inside `ShallowEtagHeaderFilter`, which is a mistake.  By changing the code to `WebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);`, everything will be fine.   **Affects:** \","closed","type: enhancement,","medusar","2020-04-26T11:11:44Z","2020-07-19T18:02:31Z"
"","25503","Modify DefaultMessageListenerContainer javadoc","Issue #15210 reports a problem with `maxMessagePerTask` and `CachingConnectionFactory`. The result of the issue is javadoc section which discourages `CachingConnectionFactory` with dynamic scaling. But dynamic scaling described in the javadoc is achieved by method `setMaxConcurrentConsumers`, not `setMaxMessagePerTask`.   I can't find issue 15210 details, but `CachingConnectionFactory` is typical setup in Spring world. For example, the guide https://github.com/spring-guides/gs-messaging-jms creates a context with `DefaultMessageListenerContainer` + `CachingConnectionFactory`.  For that reason I assume that `DefaultMessageListenerContainer` + `CachingConnectionFactory` + dynamic scaling with `setMaxConcurrentConsumers` is correct. I deleted misleading Javadoc section and added relevant discouraging section to Javadoc of method `setMaxMessagePerTask`.  If I am wrong please reject my PR.","open","type: documentation,","michaldo","2020-08-01T01:19:16Z","2021-04-27T05:06:14Z"
"","25723","Replace .equals("""") with .isEmpty()","isEmpty is faster, has less byte code and is easier to read.","closed","","Laffini","2020-09-07T09:42:58Z","2022-02-18T19:06:26Z"
"","25553","Optimize single character equality checks","Investigate claims made in [Micro optimizations in Java. String.equals()](https://medium.com/javarevisited/micro-optimizations-in-java-string-equals-22be19fd8416) article.","closed","in: core,","sbrannen","2020-08-06T15:34:13Z","2020-08-25T14:42:04Z"
"","25552","Optimize usage of """".equals()","Investigate claims made in [Micro optimizations in Java. String.equals()](https://medium.com/javarevisited/micro-optimizations-in-java-string-equals-22be19fd8416) article.","closed","in: core,","sbrannen","2020-08-06T15:32:35Z","2020-08-25T14:42:04Z"
"","25272","Clean up JdbcOperations/JdbcTemplate signatures containing both Object[] methods and varargs","Interfaces (and implementations) like `JdbcOperations` contain several methods, historically, that operate on an `Object[]`. With the introduction of varargs most of those methods now have a varargs counterpart. As Java 8 is the baseline it might be considered to deprecate the methods using an `Object[]` in favor of the varargs one.   This would allow for some API cleanup in for instance Spring 6.   This might apply to other templates as well (messaging, jms, ...).","closed","type: task,","mdeinum","2020-06-18T07:28:45Z","2021-06-01T07:54:52Z"
"","25201","Beans of generic interfaces with nested Kotlin type parameters are not found","Interface implementations that use nested type parameters with Kotlin types are not found as implementations. The following example fails:  ```kotlin package com.example.demo  import org.springframework.stereotype.Component  interface MyInterface {     fun doit(): T }  @Component class MyImplementation1 : MyInterface {     override fun doit(): Sequence {         TODO(""not implemented"")     } }  @Component class MyConsumer(private val my: MyInterface) ``` The error message is:  > Parameter 0 of constructor in com.example.demo.MyConsumer required a bean of type 'com.example.demo.MyInterface' that could not be found.  But if I use the (similar) Java interface `Stream` everything is fine:  ```kotlin package com.example.demo  import org.springframework.stereotype.Component import java.util.stream.Stream  interface MyInterface {     fun doit(): T }  @Component class MyImplementation1 : MyInterface {     override fun doit(): Stream {         TODO(""not implemented"")     } }  @Component class MyConsumer(private val my: MyInterface) ```  The application file is identical in both cases:  ```kotlin package com.example.demo  import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication  @SpringBootApplication class DemoApplication  fun main(args: Array) {     runApplication(*args) } ```  Possibly related to #22313","open","in: kotlin,","helmbold","2020-06-07T13:12:29Z","2022-01-19T10:53:03Z"
"","25792","Potential bug in getBean(Class) for ProxyFactoryBean and target bean regarding @Priority","In this case(**spring 5.0.x version**):  ```java public class AppConfig {  @Bean  public ProxyFactoryBean proxyFactoryBean(TargetService targetService) {      ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();      proxyFactoryBean.setProxyTargetClass(true);      proxyFactoryBean.setTarget(targetService);      proxyFactoryBean.setInterceptorNames(""myBeforeAdvice"");      return proxyFactoryBean;  } }  ```  ```java public class MyBeforeAdvice implements MethodBeforeAdvice {   @Override  public void before(Method method, Object[] args, Object target) throws Throwable {      System.out.println(""before invoke method [ "" + method.getName() + "" ], aop before logic invoked"");  } } ```  ```java @Priority(12) public class TargetService {   public void testAopApi() {      System.out.println(""testAopApi has invoked"");  } } ```  ```java public class Entry {   public static void main(String[] args) {      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(              TargetService.class,              MyBeforeAdvice.class,              AppConfig.class);       context.getBean(TargetService.class).testAopApi();  } } ```  I need to get the proxy bean of TargetService type by ""getBean(Class requiredType)"" api, but it throws following exception:  ``` Exception in thread ""main"" org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.eugene.sumarry.resourcecodestudy.newissue.TargetService' available: Multiple beans found with the same priority ('12') among candidates: [targetService, proxyFactoryBean] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.determineHighestPriorityCandidate(DefaultListableBeanFactory.java:1421) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1027) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:338) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:333) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1107) 	at com.eugene.sumarry.resourcecodestudy.newissue.Entry.main(Entry.java:13) ```  As we know spring has two solution to deal with above situation that is by @Primary and @Priority annotation。  ```java // org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveNamedBean(java.lang.Class, java.lang.Object...) String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) {  candidateName = determineHighestPriorityCandidate(candidates, requiredType); } ```  When I replace the `@Priority(12)` with the `@Primary` annotation, this problem can be solved perfectly.   **But, when I try to use the `@Priority` annotation to deal with the problem, I don't know how to solve it, because I cannot add `@Priority` annotation to proxy object**.  After a lot of testing, I found that this is indeed a problem. When the `ProxyFactoryBean` proxies the bean in the Spring container, we will get an above exception if we use the `getBean(Class requiredType)` API to get the bean.","closed","in: core,","AvengerEug","2020-09-19T16:25:29Z","2020-09-23T13:47:09Z"
"","24886","Memory leak in MimeTypeUtils LRUCache","In then current LRUCache implementation, the queue tracking recently used cached values is thread safe, at least each call to offer/add values to it is.  But in the case of highly concurrent calls for the same cached value, the current implementation can add multiple instances of the same value to the queue. Since the queue is unbounded, this can lead to memory leak issues or large queues which increases the time spent when going over the queue to find values to remove.  We'll also use this issue to improve queue lookup for recently used values by starting from the end and using a different queue implementation.","closed","type: bug,","bclozel","2020-04-09T09:22:33Z","2020-04-09T13:42:52Z"
"","25482","Improve Javadoc for @RequestMapping#params","In the Javadoc comments for `org.springframework.web.bind.annotation.RequestMapping#params`, it is noted that:  > The primary path mapping (i.e. the specified URI value) still has to uniquely identify the target handler, with parameter mappings simply expressing preconditions for invoking the handler.  Does that mean as far as Spring is concerned, these handler methods are _""invalid""_ then, as the URI does not _""uniquely identify the target handler""_?  ```java @RestController @RequestMapping(path = ""/demo1"") public class DemoController1 {      @GetMapping(params = ""p=1"")     public String endpoint1(@RequestParam(""p"") final String p) {         return p;     }      @GetMapping(params = ""p=2"")     public String endpoint2(@RequestParam(""p"") final String p) {         return p;     }  } ```  If that's the case, Spring should throw an error during startup or print a warning, but it doesn't.  And FWIW, requests can be routed to `endpoint1`/`endpoint2` based on value of `p` so maybe the Javadoc comment is out of date?  For context, see: https://gitter.im/spring-projects/spring-boot?at=5f1ef4e6e9066820051edccd","closed","in: web,","behrangsa","2020-07-28T02:37:59Z","2020-08-10T12:46:22Z"
"","24851","Zipkin: Deprecatead APIs in documentation for customization of client parsing of the HTTP related spans","In the documentation, https://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.1.0.M2/multi/multi__customizations.html is mentioned ""If a customization of client / server parsing of the HTTP related spans is required, just register a bean of type brave.http.HttpClientParser or brave.http.HttpServerParser.""  It works this way. However, HttpCLientParser and HttpServerParser are **deprecated** right now and customization doesn't work with suggested HttpRequestParser or without registration bean. Please update the documentation on how to work with non-deprecated things.","closed","for: external-project,","Vynnytska","2020-04-02T16:58:17Z","2020-04-02T19:42:18Z"
"","25028","Possibility to add default reference type in inner use of ConcurrentReferenceHashMap (ResolvableType)","In the context of our framework, we come across a metaspace issue due to the use of soft references in ConcurrentReferenceHashMap by default. That default can be set in the constructor but there are are some inner uses of that class relies on the default soft reference type. For example: ResolvableType  Can a change be performed to provide a way to set the reference types in this cases this without using reflection? Passing the reference type to ResolvableType for example.  Thanks!","open","in: core,","fsgonz","2020-05-07T14:43:29Z","2021-11-10T12:35:33Z"
"","24854","Unable to find the license for Java HTTP Server component in spring-web-5.2.4.RELEASE.jar","In spring-web-5.2.4.RELEASE.jar for the below classes  spring-web-5.2.4.RELEASE.jar/org/springframework/remoting/caucho/SimpleHessianServiceExporter.class spring-web-5.2.4.RELEASE.jar/org/springframework/remoting/httpinvoker/SimpleHttpInvokerServiceExporter.class spring-web-5.2.4.RELEASE.jar/org/springframework/remoting/jaxws/SimpleHttpServerJaxWsServiceExporter.class  If we are checking the Source code of these class files from GitHub, below import statements are used for these files .  import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler;  For these import statements Black duck tool  is identifying the import statements are from the Java HTTP Server component (http (repo1.maven.org/maven2/com/sun/net/httpserver)) And the tool is not able to identify the license of this HTTP server component .  Please reply us with the license of this Java HTTP Server component","closed","status: invalid,","chinmaypanda53","2020-04-03T11:14:48Z","2020-04-03T14:02:40Z"
"","25032","Update Server Requesters IAW observed behavior","In spring-messaging-5.2.5-RELEASE, I observed in the debugger that to successfully complete the connection setup after intercepting and caching a Server Requester, the Kotlin @ConnectMapping method must declare a return type of Mono? and then return null. Any other declared return type or a non-null return value, including Mono.empty(), caused AbstractEncoderMethodReturnValueHandler.handleReturnValue(...) to fall through to the code after this `if` block:  ``` 		if (returnValue == null) { 			return handleNoContent(returnType, message); 		} ``` and that resulted in a failure to establish the connection with a RejectedSetupException.","closed","status: invalid,","richmeyer7","2020-05-07T19:08:58Z","2020-05-28T08:08:26Z"
"","25607","Why PropertyValue needs to extends AttributeAccessor","In spring-bean, PropertyValue now extends  AttributeAccessor, so it holds ""attributes"" in bean object.  But since PropertyValue represents an individual bean property, is it really  necessary to be like this? PropertyValue extends AttributeAccessor  makes me confused. Why not extends nothing only add a ""source"" field in PropertyValue?","closed","for: stackoverflow,","yilianhuaixiao","2020-08-18T02:58:35Z","2020-08-18T09:16:28Z"
"","25217","Possibly wrong annotations","In Spring Data Jpa (at least since 2.2.x, still present in 2.3.x) there seem to be some wrong annotations. Unless this is by design, the following `@Nullable`-annotated methods should be changed.  **`org.springframework.data.jpa.domain.SpecificationComposition.composed(Specification, Specification, Combiner)`**   The method is annotated with `@Nullable` even though it always returns a specification. Thus the method should be annotated with `@NonNull` instead.   As a consequence of this change the methods `org.springframework.data.jpa.domain.Specification.and(Specification)` and `org.springframework.data.jpa.domain.Specification.or(Specification)` should also be annotated with `@NonNull` since they return the output from `composed`  **`org.springframework.data.jpa.domain.Specification.where(Specification)`** The method is annotated with `@Nullable` even though it's only purpose is converting `null` values passed as parameter into a specification that returns null als predicate.   This means the return value actually always is an actual specification. Thus the method should be annotated with `@NonNull` instead.    **`org.springframework.data.jpa.domain.Specification.not(Specification)`**   The method is not annotated. However it makes sure to always return a specification.   Thus it could be annotated with `@NonNull`","closed","for: external-project,","NielsNet","2020-06-10T06:52:14Z","2020-06-10T08:53:54Z"
"","25799","Sending an event as part of the EMF lock triggers a deadlock","In Spring Boot we have some custom `DataSource` initialisation that needs to know about the state of the EMF. When JPA is bootstrapped in deferred mode, we need to make sure that our core runs as part of that lock.  For this we use `JpaVendorAdapter#postProcessEntityManagerFactory`. Our implementation sends a event and another component uses that as a trigger to do more things.  Unfortunately this setup leads to a deadlock in the main thread:  ``` ""main"" #1 prio=5 os_prio=31 tid=0x00007f80d500c000 nid=0x2903 waiting on condition [0x000070000fd6a000]    java.lang.Thread.State: WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for   (a java.util.concurrent.FutureTask) 	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) 	at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429) 	at java.util.concurrent.FutureTask.get(FutureTask.java:191) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.getNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:540) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:497) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:680) 	at com.sun.proxy.$Proxy57.getMetamodel(Unknown Source) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean$$Lambda$576/2014729464.apply(Unknown Source) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.Iterator.forEachRemaining(Iterator.java:116) 	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) 	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.getMetamodels(JpaMetamodelMappingContextFactoryBean.java:106) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:80) 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:44) 	at org.springframework.beans.factory.config.AbstractFactoryBean.afterPropertiesSet(AbstractFactoryBean.java:142) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1853) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1790) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) 	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$337/1777443462.getObject(Unknown Source) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	- locked  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:330) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:113) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1697) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1442) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) 	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$337/1777443462.getObject(Unknown Source) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	- locked  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ```  With the following state for `task1` (the thread that was created to initialise the DB):   ``` ""task-1"" #23 prio=5 os_prio=31 tid=0x00007f80944ca000 nid=0x480b waiting for monitor entry [0x00007000121de000]    java.lang.Thread.State: BLOCKED (on object monitor) 	at org.springframework.context.event.AbstractApplicationEventMulticaster.getApplicationListeners(AbstractApplicationEventMulticaster.java:191) 	- waiting to lock  (a java.util.concurrent.ConcurrentHashMap) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:134) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361) 	at org.springframework.boot.autoconfigure.orm.jpa.DataSourceInitializedPublisher.publishEventIfRequired(DataSourceInitializedPublisher.java:99) 	at org.springframework.boot.autoconfigure.orm.jpa.DataSourceInitializedPublisher.access$100(DataSourceInitializedPublisher.java:50) 	at org.springframework.boot.autoconfigure.orm.jpa.DataSourceInitializedPublisher$DataSourceSchemaCreatedPublisher.postProcessEntityManagerFactory(DataSourceInitializedPublisher.java:197) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:412) 	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$$Lambda$803/1946962024.call(Unknown Source) 	at java.util.concurrent.FutureTask.run(FutureTask.java:266) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at java.lang.Thread.run(Thread.java:748) ```","closed","in: core,","snicoll","2020-09-22T13:29:46Z","2020-09-25T09:44:53Z"
"","25189","Why remove org.springframework.cache.guava.GuavaCacheManager in Spring 5.0?","In Spring 5.0, I found GuvaCache and GuavaCacheManager has been removed,  and use CaffeineCacheManager instead, remove a class is Incompatible behavior，GuvaCache and GuavaCacheManager can been recovery?","closed","","steveguoshao","2020-06-05T06:41:12Z","2020-06-05T08:15:35Z"
"","25109","Custom HTTP Method on MockServerHttpRequest","In some cases we'd like to use `MockServerHttpRequest` with methods not in Spring's `HttpMethod` enum (for testing corner cases for example). My scenario was wanting to use `MockServerHttpRequest` with the CONNECT method, which isn't in HttpMethod. When `ServerHttpRequest` receives a request from Reactor Netty it can accept CONNECT as a string method even though it's not in the enum. I believe we should also add a string-based method initialization to `MockServerHttpRequest`.  This was originally described in #24820 but I was asked to create a separate issue for this. @rstoyanchev FYI","closed","type: enhancement,","GuyLewin","2020-05-20T02:10:38Z","2020-05-28T08:38:33Z"
"","25319","Replace anonymous inner classes with lambda expressions","In SimpleBufferingAsyncClientHttpRequest And SimpleStreamingAsyncClientHttpRequest class，Anonymous type can be replaced with lambda","closed","type: task,","walesu","2020-06-26T12:10:09Z","2020-06-26T16:55:27Z"
"","25710","Mechanism to access request bound objects in WebClient filter in servlet env","In servlet environment, when migrating `RestTemplate` to `WebClient`, one of the challenges people face is to access http request bound objects within `WebClient` filters(`ExchangeFilterFunction`). I think this is an area currently lacking a support.   For example, `SecurityContext`, `Locale/LocaleContext`(`LocaleContextHolder`), `HttpServletRequest`(`RequestContextHolder`) and any values associated to the request(`ThreadLocal`) cannot easily be retrieved in `ExchangeFilterFunction`.  I think common solution for this is to use `Hooks` to populate the values to subscriber's context.  For example, in Spring Security, [here](https://github.com/spring-projects/spring-security/blob/2abf59b695b3ad14719299ed17ff47b181eed802/config/src/main/java/org/springframework/security/config/annotation/web/configuration/SecurityReactorContextConfiguration.java#L72-L80) defines and registers a hook that populates `SecurityContext`. Since this mechanism also populates `HttpServletRequest` and `HttpServletResponse`, I leverage it in my exchange filter functions to retrieve request bound values. I also have similar logic for MDC and `LocaleContext`.  I think this mechanism should be supported in Spring Framework itself; so that, all downstream libraries and application can leverage it.  For implementation perspective, for example, define a class `ReactorContextAttribute` which is a map kept in thread local. Then, framework guarantees to populate this map in subscriber's context. So that, users or downstream libraries can simply populate this map in request thread, then retrieves values from the map in subscriber context. In addition, `FrameworkServlet`/`DispatcherServlet` resolved value/context, such as `LocaleContext`, can be placed in this map to make them accessible in exchange filter functions.  If such mechanism exists, for example, Spring Security can simply add a logic to populate `SecurityContext`.   I think this is a big missing piece to use `WebClient` in servlet environment along with [supporting MDC](https://github.com/spring-projects/spring-framework/issues/24416).","closed","type: task,","ttddyy","2020-09-05T00:14:48Z","2022-03-31T21:21:55Z"
"","25668","change assert in replaceOverride constructor from methodName to metho…","In org.springframework.beans.factory.support.ReplaceOverride#ReplaceOverride:     Code line 52 repeat verify replaceOverride constructor method，may be you want to check methodReplacerBeanName instead of methodName.","closed","in: core,","xichaodong","2020-08-31T17:34:55Z","2020-09-01T08:10:09Z"
"","25375","Endless loops in RequestMappingHandlerMapping#registerHandlerMethod after the override","In order to realize some special business, I rewrote the `RequestMappingHandlerMapping#registerHandlerMethod`， like  ```java @Override protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {     //dosomething...     if (xx) {         //dosomething...     } else {         super.registerHandlerMethod(handler, method, mapping);     } } ```   This code is no problem under spring-boot 2.2.0 (not included)   However, when I upgrade the spring-boot version of the newly version (above 2.2.0), this method will directly call the object itself when calling super.  ------------------- super → this   ↑  ←― ↓ --------------------  Current spring-boot version：  spring 5.0.6.RELEASE  spring-boot 2.0.2.RELEASE","closed","","zhangmingshuang","2020-07-09T07:09:11Z","2020-07-30T06:10:05Z"
"","25209","Align DispatcherServlet defaults for Java and XML","In order to improve GraalVM compatibility (by requiring less reflection configuration) and for the sake of consistency, we should probably register these 4 missing beans in `WebMvcConfigurationSupport`:  - `org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver`  - `org.springframework.web.servlet.theme.FixedThemeResolver`  - `org.springframework.web.servlet.support.SessionFlashMapManager`  - `org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator`  We should also make sure the same is done on XML side and should then make `DispatcherServlet.properties` parsing lazy as most use case will not use it.  Finally, we should check that no Spring Boot configuration update is needed.","closed","status: superseded,","sdeleuze","2020-06-08T13:12:56Z","2020-06-22T08:31:36Z"
"","25586","the member delegates in ChainedPersistenceExceptionTranslator not support custom process order","in my project,i want to tailor my custom sql exception translator ,but I find spring not support to assign the order that I want, I'm not sure it is my error?","open","in: data,","javartisan","2020-08-14T03:28:33Z","2021-11-10T12:23:05Z"
"","25777","Unify WebRequest parameter names","In all other methods, `WebRequest` uses the name `request`. Using `webRequest` only for `handleAsyncRequestTimeoutException()`. Unify names for clean code.  Thanks!","closed","status: declined,","jaeyeonling","2020-09-15T17:24:20Z","2020-09-16T17:24:16Z"
"","25130","ConstructorResolver.resolveConstructorArguments() return value issue","In `ConstructorResolver`:  ```java private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw, 			ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) { 		TypeConverter customConverter = this.beanFactory.getCustomTypeConverter(); 		// ...  		for (Map.Entry entry : cargs.getIndexedArgumentValues().entrySet()) { 			int index = entry.getKey(); 			if (index < 0) { 				throw new BeanCreationException(mbd.getResourceDescription(), beanName, 						""Invalid constructor argument index: "" + index); 			} 			if (index > minNrOfArgs) { 				minNrOfArgs = index + 1; 			} 			// .... 		} // ....     return minNrOfArgs; } ```  I assume that method  `resolveConstructorArguments` is to resolve contructor arguments in the XML file and return the minimum number of parameters required by contructor 。but if the first parameter is autowired , the second parameter  is config by XML file，the method will not work well。  **example**:  ```java public class FactoryObject { 	     public DmzService getDmz(String name, int age, Date birthDay, OrderService orderService) {  	public DmzService getDmz(OrderService orderService,String name) { 		 		return new DmzService(orderService,name); 	}  } ```  ```xml   	  	  	 		 	   ```  the `resolveConstructorArguments` method will return 1,but correct answer is 2。  I think the problem arises because of this judgment:  ```java if (index > minNrOfArgs) {     minNrOfArgs = index + 1; } ```  It might be better to change it to look like this  ``` if (index + 1 > minNrOfArgs) {     minNrOfArgs = index + 1; } ```","closed","type: enhancement,","daimingzhi","2020-05-26T14:13:38Z","2020-05-27T02:44:18Z"
"","25105","ConfigurationClassPostProcessor makes assumptions about the presence of an ImportRegistry","In `ConfigurationClassPostProcessor`:  ```java 	@Override 	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {         ... 		if (!this.registriesPostProcessed.contains(factoryId)) { 			// BeanDefinitionRegistryPostProcessor hook apparently not supported... 			// Simply call processConfigurationClasses lazily at this point then. 			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); 		} 		enhanceConfigurationClasses(beanFactory); 		beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); 	} ```  where `processConfigBeanDefinition()` is responsible for setting up the `IMPORT_REGISTRY_BEAN_NAME` but it might not. It is normally called from `postProcessBeanDefinitionRegistry()` but even then it might not add  the `ImportRegistry`. And then `ImportAwareBeanPostProcessor` is registered unconditionally, and it expects there to be a `IMPORT_REGISTRY_BEAN_NAME`. It barfs if it's not there.  Possibly this never arises in a ""normal"" Spring application, but many things can happen to prevent `processConfigBeanDefinitions()` from adding that `ImportRegistry` (currently we are looking at an example in a native image), so probably the `ImportAwareBeanPostProcessor` should either only be added if the `IMPORT_REGISTRY_BEAN_NAME` is present, or should check before using it that it is there.","closed","type: enhancement,","dsyer","2020-05-19T14:40:03Z","2020-07-27T15:58:04Z"
"","25244","AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata issue","in `AutowiredAnnotationBeanPostProcessor`，we `buildAutowiringMetadata`  against method annotated `@Autowired`。  ```java private InjectionMetadata buildAutowiringMetadata(final Class clazz) {     // .... ReflectionUtils.doWithLocalMethods(targetClass, method -> { 				Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); 				if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { 					return; 				} 				AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); 				if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { 					if (Modifier.isStatic(method.getModifiers())) { 						if (logger.isInfoEnabled()) { 							logger.info(""Autowired annotation is not supported on static methods: "" + method); 						} 						return; 					} 					if (method.getParameterCount() == 0) { 						if (logger.isInfoEnabled()) { 							logger.info(""Autowired annotation should only be used on methods with parameters: "" + 									method); 						} 					} 					boolean required = determineRequiredStatus(ann); 					PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); 					currElements.add(new AutowiredMethodElement(method, required, pd)); 				} 			});     // ... } ```  From the above code, I can see that any method with an `@Autowired` annotation will be treated as an injection point, which means that parameters of method will be injected, if parameters cannot be injected, an error will be reported, and the method will be invoked when method `InjectionMetadata.inject` executes。  We think there are several problems with the above code：  - Methods with no arguments should be filtered out，no arguments means do not need `autowire`  - `BeanUtils.findPropertyForMethod(bridgedMethod, clazz)` will return null when `bridgedMethod` is neither `readMethod ` nor `writeMethod`。In this case, do we still need to inject? - if `bridgedMethod` is `readMethod `  that means the method look like `void getXxx()`，do we still need new a `AutowiredMethodElement` ?  Because I don't know if this code is designed that way，so I make this issue。  Looking forward to your reply. Thank you very much！！！！","closed","in: core,","daimingzhi","2020-06-12T00:05:46Z","2020-09-27T12:43:03Z"
"","25034","HttpHeaders equals may return false without comparing actual content","In 5.1 `HttpHeaders` became a `MultiValueMap` and it became possible to wrap existing `HttpHeaders` instances rather than copy their contents. As a result it's possible to have multiple `HttpHeaders` wrappers around the actual `MultiValueMap` content.  The `equals` method tries to compare the `MultiValueMap` content by nesting on the `headers` field but if the levels of nesting are uneven, it may return false. For example:  ```java HttpHeaders headers1 = new HttpHeaders(); HttpHeaders headers2 = new HttpHeaders(new HttpHeaders(headers1));  assertThat(headers1.equals(headers2)).isTrue(); // Pass assertThat(headers2.equals(headers1)).isTrue(); // Fail ```","closed","type: bug,","rstoyanchev","2020-05-08T06:49:44Z","2020-06-06T14:12:06Z"
"","25160","Introduce tests for MultiValueMap","imho improved tests for gh-25140, as solicited by @jhoeller   As promised in gh-25159, I am submitting a second suggestion for Testing the exiting code of   ``` CollectionUtils.toMultiValueMap ```  The suggestion was to create for this MultiValueMap same tests as for    ``` LinkedMultiValueMap ```  present in ``` LinkedMultiValueMapTests ```  This, however, produced a very high code duplication, which I did not find very elegant.   I think the better way is to use Jupiter properly, to instantiate various types of MultiValueMap and test the contract for each of them.   Like this test code is not duplicated and the contracts are consistent with each other.   This is just a suggestion.   I am open for suggestions  in case this does not fit your expectations.  Kind regards","open","status: feedback-provided,","midumitrescu","2020-05-28T22:56:54Z","2021-04-27T05:06:13Z"
"","24996","A NullPointerException for HandlerMapping","if you don't register any viewcontrollers, you might get a null here:  org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#viewControllerHandlerMapping  ``` 	@Bean 	@Nullable 	public HandlerMapping viewControllerHandlerMapping() { 		ViewControllerRegistry registry = new ViewControllerRegistry(this.applicationContext); 		addViewControllers(registry);  		AbstractHandlerMapping handlerMapping = registry.buildHandlerMapping(); 		if (handlerMapping == null) { 			return null; 		} 		handlerMapping.setPathMatcher(mvcPathMatcher()); 		handlerMapping.setUrlPathHelper(mvcUrlPathHelper()); 		handlerMapping.setInterceptors(getInterceptors()); 		handlerMapping.setCorsConfigurations(getCorsConfigurations()); 		return handlerMapping; 	} ```  but when we iterate over a handlerMappings , 'mapping ' might be null: org.springframework.web.servlet.DispatcherServlet#getHandler ``` 	@Nullable 	protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { 		if (this.handlerMappings != null) { 			for (HandlerMapping mapping : this.handlerMappings) { 				HandlerExecutionChain handler = mapping.getHandler(request); 				if (handler != null) { 					return handler; 				} 			} 		} 		return null; 	} ``` so I'm going to get an exception.","closed","status: invalid,","sucls","2020-04-30T10:01:45Z","2020-04-30T11:48:25Z"
"","25140","MultiValueMapAdapter.getFirst fails with IndexOutOfBoundsException in case of empty List","If You create `MultiValueMap` via `MultiValueMapAdapter`, and value list is empty, call of method `getFirst` fail on `IndexOutOfBounds` exception:  ```java private static class MultiValueMapAdapter implements MultiValueMap, Serializable {  		private final Map map;  		public MultiValueMapAdapter(Map map) { 			Assert.notNull(map, ""'map' must not be null""); 			this.map = map; 		}  		@Override 		@Nullable 		public V getFirst(K key) { 			List values = this.map.get(key); 			return (values != null ? values.get(0) : null); 		} ```  Good solution is:  ```java return (values != null && !values.isEmpty() ? values.get(0) : null); ```","closed","in: core,","vlavasa","2020-05-27T15:50:57Z","2020-10-23T10:42:50Z"
"","25583","Switch data sources smoothly","If we have thousands of DataSources, when resolvedDefaultDataSource is putting DataSource to map, other threads cannot get the DataSources from previous map","closed","status: declined,","TurboTurn","2020-08-13T07:43:53Z","2021-12-10T23:03:39Z"
"","25121","Default value for @Value for all properties","If we don't have a value for a property we get below error. This error can be avoided by setting a colon `:` with or without a default value. Is there a way we can set default value for all the properties that way my application need not rely on the developer to specify `:`?  `Could not resolve placeholder`  If there is a better approach to solve this, please let me know.","closed","for: stackoverflow,","gituserjava","2020-05-23T09:56:55Z","2020-05-23T10:59:52Z"
"","24840","Change MultiValueMap to extend Map","If we change [MultiValueMap ](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/MultiValueMap.java) to wildcard the List type it extends then this code will compile  ```java final MultiValueMap formParams = new LinkedMultiValueMap(); final  List enumFormStringArray = Collections.singletonList(""foo""); formParams.put(""enum_form_string_array"", enumFormStringArray); ```  This will allow us to clear up some warnings in the openapi-generator (https://github.com/OpenAPITools/openapi-generator/issues/5782)","open","in: core,","jonfreedman","2020-04-01T17:24:40Z","2021-11-12T12:08:05Z"
"","24900","Prevent setting parent bean factory to self","If set parent bean factory to self, once try to get an undefined bean,  bellow condition if (parentBeanFactory != null && !containsBeanDefinition(beanName)) { ... } will always be true and  StackOverflowError will be thrown. Sometimes, this issue is hard to detect during runtime,  if self-reference is not allowed here,  error will be found at the early time of startup. Also, a self-reference parent bean factory is valueless.","closed","type: enhancement,","liuhy365","2020-04-13T15:35:36Z","2020-04-25T14:28:10Z"
"","25795","Introduce a NativeDetector utility class","If https://github.com/oracle/graal/issues/2594 get fixed in time we should probably reintroduce `GraalDetector` renamed to `NativeDetector` for a wider scope (could be useful for Project Leyden). It was removed via https://github.com/spring-projects/spring-framework/commit/806eb5c93391e2757b2210297ff58b3254ef9876.","closed","type: enhancement,","sdeleuze","2020-09-21T14:43:43Z","2021-02-15T15:36:54Z"
"","25584","FileUrlResource isWritable method returns true if URL protocol is not indicating a file","if add testcase `	@Test 	void test() throws IOException { 		Resource resource = new FileUrlResource(new URL(""https://spring.io/"")); 		assertThat(resource.isReadable()).isFalse(); 	} ` the former code cannot pass. Then I restricted   FileUrlResource must be contructed with a URL about file.","closed","in: core,","yilianhuaixiao","2020-08-14T01:28:03Z","2020-09-08T10:28:09Z"
"","25497","Provide equivalent of @EnableWebFlux and @EnableWebMvc for the RouterFunction  approach","If a user only provides `RouterFunction` endpoints it's a shame to load up the application context with loads of annotation-processing (`RequestMappingHandlerMapping` etc.). But everything happens in the same place right now.  See https://github.com/spring-projects/spring-boot/issues/22314.","open","in: web,","dsyer","2020-07-31T08:34:37Z","2021-11-10T11:46:07Z"
"","24853","Connection created by SingleConnectionDataSource with suppressClose=true always returns isClosed=false even if the target connection is closed","If `SingleConnectionDataSource`  is configured with `suppressClose=true` it will produce a Connection wrapped in `CloseSuppressingInvocationHandler`. `CloseSuppressingInvocationHandler` will always return false if the `isClosed()` is being triggered on the wrapped connection. This is ok until `SingleConnectionDataSource#destroy()` is triggered which closed the connection on the wrapped Connection.   I'd therefore suggest to change    	/** 	 * Invocation handler that suppresses close calls on JDBC Connections. 	 */ 	private static class CloseSuppressingInvocationHandler implements InvocationHandler {  		private final Connection target;  		public CloseSuppressingInvocationHandler(Connection target) { 			this.target = target; 		}  		@Override 		@Nullable 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 			// Invocation on ConnectionProxy interface coming in...  			if (method.getName().equals(""equals"")) { 				// Only consider equal when proxies are identical. 				return (proxy == args[0]); 			} 			else if (method.getName().equals(""hashCode"")) { 				// Use hashCode of Connection proxy. 				return System.identityHashCode(proxy); 			} 			else if (method.getName().equals(""unwrap"")) { 				if (((Class) args[0]).isInstance(proxy)) { 					return proxy; 				} 			} 			else if (method.getName().equals(""isWrapperFor"")) { 				if (((Class) args[0]).isInstance(proxy)) { 					return true; 				} 			} 			else if (method.getName().equals(""close"")) { 				// Handle close method: don't pass the call on. 				return null; 			} 			else if (method.getName().equals(""isClosed"")) { 				return false; 			} 			else if (method.getName().equals(""getTargetConnection"")) { 				// Handle getTargetConnection method: return underlying Connection. 				return this.target; 			}  			// Invoke method on target Connection. 			try { 				return method.invoke(this.target, args); 			} 			catch (InvocationTargetException ex) { 				throw ex.getTargetException(); 			} 		} 	}  to  	/** 	 * Invocation handler that suppresses close calls on JDBC Connections. 	 */ 	private static class CloseSuppressingInvocationHandler implements InvocationHandler {  		private final Connection target;  		public CloseSuppressingInvocationHandler(Connection target) { 			this.target = target; 		}  		@Override 		@Nullable 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 			// Invocation on ConnectionProxy interface coming in...  			if (method.getName().equals(""equals"")) { 				// Only consider equal when proxies are identical. 				return (proxy == args[0]); 			} 			else if (method.getName().equals(""hashCode"")) { 				// Use hashCode of Connection proxy. 				return System.identityHashCode(proxy); 			} 			else if (method.getName().equals(""unwrap"")) { 				if (((Class) args[0]).isInstance(proxy)) { 					return proxy; 				} 			} 			else if (method.getName().equals(""isWrapperFor"")) { 				if (((Class) args[0]).isInstance(proxy)) { 					return true; 				} 			} 			else if (method.getName().equals(""close"")) { 				// Handle close method: don't pass the call on. 				return null; 			} 			// else if (method.getName().equals(""isClosed"")) { 			//	return false; 			// } 			else if (method.getName().equals(""getTargetConnection"")) { 				// Handle getTargetConnection method: return underlying Connection. 				return this.target; 			}  			// Invoke method on target Connection. 			try { 				return method.invoke(this.target, args); 			} 			catch (InvocationTargetException ex) { 				throw ex.getTargetException(); 			} 		} 	}  Let me know if this change would be ok then I can create a pull request","closed","type: bug,","barfoo4711","2020-04-03T10:30:21Z","2020-04-05T08:56:14Z"
"","25568","Assert preconditions for MergedAnnotations.from() factory methods","If `null` values are supplied for the `RepeatableContainers` or `AnnotationFilter` arguments to `from()` factory methods in `MergedAnnotations`, certain operations will eventually result in a `NullPointerException`.  This is to be expected; however, the `NullPointerException` is often swallowed and only logged at `INFO` level with an exception message similar to the following.  > Failed to introspect annotations on org.example.MyClass: NullPointerException  In such cases, the `INFO` log message is not helpful in diagnosing the problem. Furthermore, since the exception is swallowed, the desired operation (e.g., `MergedAnnotations.stream(...)`) simply returns no results, and the user is left wondering what happened.","closed","type: enhancement,","sbrannen","2020-08-08T10:20:58Z","2020-08-08T10:32:19Z"
"","24863","Documentation for CORS WebFlux","I've found no paragraph about CORS in the WebFlux part of the Spring Boot Documentation, is CORS only supported in Spring MVC? (It is shown [there](https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-cors))  Because [here](https://github.com/spring-projects/spring-framework/blob/master/src/docs/asciidoc/web/webflux-cors.adoc) is a document named 'webflux-cors.adoc' with paragraphs about Spring MVC.","closed","status: invalid,","tamaro-skaljic","2020-04-03T18:40:17Z","2020-04-05T13:39:11Z"
"","25528","PingPongWebSocketHandlerDecorator schedules pings and replies to pongs","I've found it to be common for WebSockets clients to be required to issue pings and reply to pongs, or if not required to do so, want to do so in order to detect disconnects. In the interest of making this common chore easier for everyone to do, it would be nice for Spring to include `PingPongWebSocketHandlerDecorator` making it easy to implement that functionality.","closed","type: enhancement,","candrews","2020-08-04T17:17:31Z","2021-02-16T14:58:02Z"
"","25781","Websockets ExecutorSubscribableChannel class keeps on sending heartbeat every 15 sec.","I'm using spring boot 2.3.3.RELEASE with websocket support and RabbitMQ as external broker with stomp support.  The issue is that the client keeps on getting a heartbeat message **""\n""** every  +-15 secs even though the client negotiated the heatbeat as **""0, 30000""** during the CONNECT request as suggested in this [documentation]( https://www.rabbitmq.com/heartbeats.html#stomp) on heart-beat header support with stomp in RabbitMQ. By turning on trace log I was able to find that **ExecutorSubscribableChannel** has a ```run()``` method that gets executed by a **ThreadPoolExecutor** every +-15 secs, which in turn sends that heartbeat message. I'm not sure if its a bug or I'm missing some configuration on my side. Any help would be appreciated.","closed","status: invalid,","prinal10","2020-09-16T16:23:05Z","2021-10-23T21:13:25Z"
"","25496","Request: WebClient URI spec to support publishers","I'm using a WebClient in a Spring Reactive application and need to make several calls as part of the steps the publisher goes through.   I wanted to do the following: ```java public Mono getHistoricProcessInstances(Mono uriParameter) {     return webClient                 .get()                 .uri(""foo?bar={uriParameter}"",                         Map.of(""uriParameter"", uriParameter))                 .retrieve()                 .bodyToMono(ResponsePojo.class); } ``` I had to do the following instead as a workaround: ```java public Mono getHistoricProcessInstances(Mono request) {     return webClient                 .post()                 .uri(""foo"")                 .body(RequestPojo, RequestPojo.class)                 .retrieve()                 .bodyToMono(ResponsePojo.class); } ```  I was lucky that the API I was calling supported the same parameters in the body as a post, but that's not always the case.   Are there plans to support this or is a reactive pattern for a workaround?","closed","","sshevlyagin","2020-07-30T18:52:00Z","2020-08-13T18:09:39Z"
"","25388","SimpleJdbcInsert needs backticks in table name for in MariaDB","I'm using `spring-jdbc` 5.1.14.RELEASE and MariaDB 10.3.13.  When I use `SimpleJdbcInsert` I'm getting the error:  ``` ""Thrown org.springframework.dao.DataAccessResourceFailureException"",         ""Unable to locate table meta-data for 'table' in the 'schema' schema"" ``` I can workaround it by adding backticks (`) in the table names, but I don't think I should have to do that.  Thank you for your time.","open","in: data,","dsgoers","2020-07-14T16:13:44Z","2021-11-10T11:38:09Z"
"","25077","After HttpAsyncRequeste requested twice, the client received the HTTP response code 400， server has no exception","I'm trying below code on Spring MVC (5.0.8 version of dependencies) deployed on undertow   【client code 】   InputStreamEntity entity = new InputStreamEntity(inputStream);         entity.setChunked(true);   HttpUriRequest post = RequestBuilder                 .post(String.format(""http://%s/accessPoint/mirror"", serverAddress))                 .addHeader(""X-Mirror-Caller"", param.getCallFromNumber())                 .addHeader(""X-Mirror-Called"", param.getCallToNumber())                 .addHeader(""X-Mirror-AgentID"", param.getAgentId())                 .addHeader(""X-Mirror-Direction"", param.getCallDirection())                 .addHeader(""X-Mirror-CallID"", param.getCallId())                 .addHeader(""X-Mirror-Source"", param.getSource())                 .addHeader(""X-Mirror-Extension"", param.getExtension())                 .addHeader(""X-Mirror-ExtraInfo"", param.getExtraInfo())                 .addHeader(""X-Mirror-RingTime"", StringUtils.formatDateTime(new Date()))                 .addHeader(""X-Mirror-ConnectedTime"", StringUtils.formatDateTime(new Date()))                 .setEntity(entity)                 .build();          InetSocketAddress addr = NetUtils.parseSocketAddress(serverAddress);         HttpHost host = new HttpHost(addr.getAddress(), addr.getPort());          requester.execute(                 new BasicAsyncRequestProducer(host, post),                 new BasicAsyncResponseConsumer(),                 pool,                 HttpCoreContext.create(),                 new FutureCallback() {                     @Override                     public void completed(HttpResponse result) {                         IOUtils.closeQuietly(inputStream);                          try {                             RESTfulResponse response = StringUtils.jsonToObject(                                     new InputStreamReader(                                             result.getEntity().getContent(), ""UTF-8""),                                     RESTfulResponse.class);                             if (response == null) {                                 LOG.error(""cannot parse response as json"" + ""agentId = "" + agentId                                         + "" file name [ "" + speechFile.getName()                                         + ""]"" + ""call ["" + param.getCallId() + ""]"" + ""status code"" +                                         result.getStatusLine().getStatusCode());                             } else {                                 LOG.info(String.format(                                         ""result of this request is [%s], agentId = %s, source = %s, callId = %s"",                                         response.getFunctionResult(), agentId, source, param.getCallId()));                             }                         } catch (Exception e) {                             LOG.error(e.getMessage(), e);                         }                          responseHandler.onResponse(agentId, source);                     }                      @Override                     public void failed(Exception ex) {                         LOG.error(""request failed! agentId = "" + agentId                                 + "" file name [ "" + speechFile.getName()                                 + ""]"" + ""call ["" + param.getCallId() + ""]"", ex);                         IOUtils.closeQuietly(inputStream);                         responseHandler.onResponse(agentId, source);                     }                      @Override                     public void cancelled() {                         LOG.error(""request cancelled! agentId = "" + agentId);                         IOUtils.closeQuietly(inputStream);                         responseHandler.onResponse(agentId, source);                     }                 });     i can receive first request callback results and results are current but  http status code for the second request is 400,when i debug at server, i cannot receive request，The server code is below。              @ResponseBody     @RequestMapping(value = ""/accessPoint/mirror"", method = RequestMethod.POST)     public DeferredResult accessNewStream(             @RequestHeader(name = ""X-Mirror-Caller"", defaultValue = """") String caller,             @RequestHeader(name = ""X-Mirror-Called"", defaultValue = """") String called,             @RequestHeader(name = ""X-Mirror-AgentID"", defaultValue = """") String agentId,             @RequestHeader(name = ""X-Mirror-Direction"", defaultValue = """") String direction,             @RequestHeader(name = ""X-Mirror-CallID"") String callId,             @RequestHeader(name = ""X-Mirror-Source"") String streamSource,             @RequestHeader(name = ""X-Mirror-Extension"", defaultValue = """") String extension,             @RequestHeader(name = ""X-Mirror-SpeechFormat"",                     defaultValue = ""audio/16LE;rate=8000"") String format,             @RequestHeader(name = ""X-Mirror-ExtraInfo"", defaultValue = """") String extraInfo,             @RequestHeader(name = ""X-Mirror-RingTime"") String ringTime,             @RequestHeader(name = ""X-Mirror-ConnectedTime"") String connectTime,             HttpServletRequest request) {         DeferredResult result = new DeferredResult();         RESTfulResponse response = new RESTfulResponse();           LOG.info(""Mirror Access stream, agentId="" + agentId + "", callId"" + callId);          if (!StringUtils.isAbsEmpty(agentId)) {             response.setFunctionResult(CommonErrorString.INVALID_PARAM);             response.setMessage(""agent id is empty"");             // result.setErrorResult(new MirrorAcessException());             if (!result.isSetOrExpired()) {                 result.setResult(response);             }             return result;         }         return result;     }","open","in: web,","zhangzhen9528","2020-05-14T09:59:16Z","2021-11-08T11:46:07Z"
"","25387","404 on endpoint at root context path","I'm switching my apps from spring mvc to use with spring boot.  To do that, i've build small projects [spring mvc](https://github.com/Fyro-Ing/mvc-multi-context/tree/not-springboot) and [spring-boot](https://github.com/Fyro-Ing/mvc-multi-context/tree/master)  like examples.  I found what seems to be a bug with endpoint path at root context path of dispatcher. Defining a simple [RestController](https://github.com/Fyro-Ing/mvc-multi-context/blob/d6b124ee0f25a8f8af7a636a0071871ae32adefb/src/main/java/com/myapp/api/app/service/AppController.java#L10) without RequestMapping. When i call request on that, there is a 404 response  > POST http://localhost:8080/api > HTTP/1.1 404   But, when i add ""/"" at the end of  request, all is good  > POST http://localhost:8080/api/ > HTTP/1.1 204   The good request is ""POST http://localhost:8080/api"", isn't it ?  All others requests are ok (like /api/sub or /api/two/other)  when debugging this problem, i realized that the problem could be  https://github.com/spring-projects/spring-framework/blob/7c982511426eebea3d34730ab128bb39a55a9de6/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java#L236  if replace this line with `    if (null != rest) {` all request are now good   Or here :  defaut path must be ""/"" not """" ? https://github.com/spring-projects/spring-framework/blob/7c982511426eebea3d34730ab128bb39a55a9de6/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java#L358   To reproduce :  - [spring mvc](https://github.com/Fyro-Ing/mvc-multi-context/tree/not-springboot) - [spring-boot](https://github.com/Fyro-Ing/mvc-multi-context/tree/master)  Examples are with multiple dispatcher, but problem occurred with one dispatcher  spring 5.2.10.RELEASE spring boot 2.3.5.RELEASE","open","in: web,","Fyro-Ing","2020-07-14T15:06:39Z","2021-11-08T11:46:08Z"
"","25546","Bean creation fails with StackOverflowError after upgrading from 5.1.13 to 5.2.7","I'm seeing below error after upgrading the Spring framework from 5.1.13 to 5.2.7. ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'restResourceFactory' defined in URL [jar:file:/usr/path/to/webapps/appservices/WEB-INF/lib/appmanager-client-1.50.0.jar!/com/app/test/appmanager/common/AppManagerBeanPostProcessor.class]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.transaction.config.internalTransactionAdvisor': Cannot resolve reference to bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0' while setting bean property 'transactionAttributeSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0': BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.retry.annotation.RetryConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.StackOverflowError                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:511)                 at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)                 at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)                 at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207)                 at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:241)                 at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:723)                 at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:536)                 at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)                 at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)                 at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103)                 at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4602)                 at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5066)                 at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)                 at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:742)                 at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:718)                 at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:703)                 at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:986)                 at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1857)                 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)                 at java.util.concurrent.FutureTask.run(FutureTask.java:266)                 at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)                 at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)                 at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:772)                 at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:426)                 at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1585)                 at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:308)                 at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:123)                 at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:424)                 at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:367)                 at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:966)                 at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:839)                 at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)                 at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1427)                 at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1417)                 at java.util.concurrent.FutureTask.run(FutureTask.java:266)                 at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)                 at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)                 at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:943)                 at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:258)                 at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)                 at org.apache.catalina.core.StandardService.startInternal(StandardService.java:422)                 at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)                 at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:770)                 at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)                 at org.apache.catalina.startup.Catalina.start(Catalina.java:682)                 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)                 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)                 at java.lang.reflect.Method.invoke(Method.java:498)                 at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:350)                 at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:492) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.transaction.config.internalTransactionAdvisor': Cannot resolve reference to bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0' while setting bean property 'transactionAttributeSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0': BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.retry.annotation.RetryConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.StackOverflowError                 at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:342)                 at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:113)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1697)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1442)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516)                 at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)                 at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)                 at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207)                 at org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:91)                 at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findCandidateAdvisors(AbstractAdvisorAutoProxyCreator.java:111)                 at org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors(AnnotationAwareAspectJAutoProxyCreator.java:92)                 at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:101)                 at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:251)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1140)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1113)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:505)                 ... 51 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0': BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.retry.annotation.RetryConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.StackOverflowError                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:511)                 at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)                 at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)                 at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)                 at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:330)                 ... 68 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.retry.annotation.RetryConfiguration': Injection of autowired dependencies failed; nested exception is java.lang.StackOverflowError                 at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:405)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1420)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516)                 at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324)                 at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226)                 at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207)                 at org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:91)                 at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findCandidateAdvisors(AbstractAdvisorAutoProxyCreator.java:111)                 at org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors(AnnotationAwareAspectJAutoProxyCreator.java:92)                 at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:101)                 at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:251)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1140)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1113)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:505)                 ... 73 common frames omitted Caused by: java.lang.StackOverflowError: null                 at java.io.UnixFileSystem.canonicalize0(Native Method)                 at java.io.UnixFileSystem.canonicalize(UnixFileSystem.java:172)                 at java.io.File.getCanonicalPath(File.java:618)                 at org.apache.catalina.webresources.AbstractFileResourceSet.file(AbstractFileResourceSet.java:90)                 at org.apache.catalina.webresources.DirResourceSet.getResource(DirResourceSet.java:101)                 at org.apache.catalina.webresources.StandardRoot.getResourceInternal(StandardRoot.java:281)                 at org.apache.catalina.webresources.Cache.getResource(Cache.java:62)                 at org.apache.catalina.webresources.StandardRoot.getResource(StandardRoot.java:216)                 at org.apache.catalina.webresources.StandardRoot.getClassLoaderResource(StandardRoot.java:225)                 at org.apache.catalina.loader.WebappClassLoaderBase.findClassInternal(WebappClassLoaderBase.java:2209)                 at org.apache.catalina.loader.WebappClassLoaderBase.findClass(WebappClassLoaderBase.java:816)                 at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1261)                 at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1121)                 at java.lang.Class.forName0(Native Method)                 at java.lang.Class.forName(Class.java:348)                 at org.springframework.util.ClassUtils.forName(ClassUtils.java:284)                 at org.springframework.util.ClassUtils.resolveClassName(ClassUtils.java:324)                 at org.springframework.beans.propertyeditors.ClassEditor.setAsText(ClassEditor.java:65)                 at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:429)                 at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:402)                 at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:155)                 at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)                 at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53)                 at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:758)                 at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:227)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1356)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1203)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getSingletonFactoryBeanForTypeCheck(AbstractAutowireCapableBeanFactory.java:1007)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBean(AbstractAutowireCapableBeanFactory.java:884)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:710)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:665)                 at org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors(BeanFactoryAspectJAdvisorsBuilder.java:100)                 at org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors(AnnotationAwareAspectJAutoProxyCreator.java:95)                 at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:101)                 at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:251)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1140)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1113)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getSingletonFactoryBeanForTypeCheck(AbstractAutowireCapableBeanFactory.java:1005)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBean(AbstractAutowireCapableBeanFactory.java:884)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:710)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:665)                 at org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors(BeanFactoryAspectJAdvisorsBuilder.java:100)                 at org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors(AnnotationAwareAspectJAutoProxyCreator.java:95)                 at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:101)                 at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:251)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1140)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1113)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getSingletonFactoryBeanForTypeCheck(AbstractAutowireCapableBeanFactory.java:1005)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBean(AbstractAutowireCapableBeanFactory.java:884)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:710)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:665)                 at org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors(BeanFactoryAspectJAdvisorsBuilder.java:100)                 at org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors(AnnotationAwareAspectJAutoProxyCreator.java:95)                 at org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.shouldSkip(AspectJAwareAdvisorAutoProxyCreator.java:101)                 at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(AbstractAutoProxyCreator.java:251)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1140)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1113)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getSingletonFactoryBeanForTypeCheck(AbstractAutowireCapableBeanFactory.java:1005)                 at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBean(AbstractAutowireCapableBeanFactory.java:884)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:710)                 at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:665) -- omitted the repeating part ```","closed","status: feedback-provided,","Dmdl","2020-08-06T10:46:31Z","2021-02-17T09:13:03Z"
"","25814","Provide `RequestPredicate` with no side effects","I'm developing a Spring WebFlux application that serve Single Page Application front-end resources. I have registered front-end resources in the `ResourceHandlerRegistry` for distribution, but some of them have had to change the `Cache-Control` header.  The `ResourceHandlerRegistry` cannot dynamically set the response headers according to the request URL or file extension. I figured this goal could be accomplished with the `WebFilter` as well as the Servet API.  I used `WebFilter` in WebFlux to check the HTTP request and tried to change the HTTP header of the response, but the I've noticed that WebFlux has different caveats than the Servlet API. e.g, when I was getting a path from `ServerHttpRequest`, I had to call `request.getPath().pathWithinApplication()` or else the context path would be included.  Spring MVC provided an `AntMatcher`, so I looked for Spring WebFlux to provide a useful matcher as well, so I found the `RequestPredicate`, but this is a class for the `RouterFunction` and seems to have some side effects. e.g, `RequestPredicates#path(String)` rewrites the path variable in the request.  I then discovered that Spring Security had a [ServerWebExchangeMatchers](https://github.com/spring-projects/spring-security/blob/5.4.0/web/src/main/java/org/springframework/security/web/server/util/matcher/ServerWebExchangeMatchers.java) with no side effects, and I implemented my own matcher based on its implementation.  But this is reinventing the wheel.  I was referring to the Spring Security implementation in this case, but I think it would be a time saver for someone like me who wants to do conditional processing with `WebFilter`, if a similar feature was provided as part of Spring WebFlux.  The following code is a sample of my `WebFilter` implementation. `my.application.matcher.ServerWebExchangeMatcher` is a matcher based on Spring Security [ServerWebExchangeMatchers](https://github.com/spring-projects/spring-security/blob/5.4.0/web/src/main/java/org/springframework/security/web/server/util/matcher/ServerWebExchangeMatchers.java).    ```java package my.application;  import java.util.List;  import my.application.matcher.ServerWebExchangeMatcher;  import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.web.server.ServerWebExchange; import org.springframework.web.server.WebFilter; import org.springframework.web.server.WebFilterChain; import reactor.core.publisher.Mono;  public class NoCacheWebFilter implements WebFilter {      public static final String CACHE_CONTROL_VALUE = ""no-cache, no-store, max-age=0, must-revalidate"";      public static final String PRAGMA_VALUE = ""no-cache"";      public static final String EXPIRES_VALUE = ""0"";      private final ServerWebExchangeMatcher serverWebExchangeMatcher;      public NoCacheWebFilter(         ServerWebExchangeMatcher serverWebExchangeMatcher) {          this.serverWebExchangeMatcher = serverWebExchangeMatcher;     }      @Override     public Mono filter(ServerWebExchange exchange, WebFilterChain chain) {         if (this.serverWebExchangeMatcher.matches(exchange)) {             exchange.getResponse().beforeCommit(() ->                 Mono.fromRunnable(() -> writeNoCacheHeader(exchange)));         }          return chain.filter(exchange);     }      private void writeNoCacheHeader(ServerWebExchange exchange) {         ServerHttpResponse response = exchange.getResponse();          if (response.getStatusCode() == HttpStatus.NOT_MODIFIED) {             return;         }          HttpHeaders responseHeaders = response.getHeaders();         responseHeaders.put(HttpHeaders.CACHE_CONTROL, List.of(CACHE_CONTROL_VALUE));         responseHeaders.put(HttpHeaders.PRAGMA, List.of(PRAGMA_VALUE));         responseHeaders.put(HttpHeaders.EXPIRES, List.of(EXPIRES_VALUE));     }  } ```","open","status: pending-design-work,","tt4g","2020-09-25T02:35:50Z","2021-11-08T11:37:30Z"
"","25115","WebClient HTTP Request Timeout","I'd like for `WebClient` and/or `ClientRequest` to have first-class support for an HTTP request timeout.  (i.e. the time it takes to receive a response after sending a request).  Something similar to the [java http client's request timeout](https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.Builder.html#timeout(java.time.Duration)).  The [currently documented](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder-reactor-timeout) use of netty's `ReadTimeoutHandler` / `WriteTimeoutHandler` is insufficient to use as an HTTP request timeout.  Specifically they apply at the TCP level, which leads to problems like this: 1. They apply during the SSL handshake, which might take longer than a typical HTTP response, due to the cryptography involved.  Therefore, they would need to be set higher than desired for HTTP responses. 2. They apply even when an HTTP request is not being processed.  For example, they could cause a connection sitting in the connection pool to be closed, even though it might be able to be used a split-second later by another request.  The `.timeout` operator on the reactive stream is insufficient to use as an HTTP request timeout as well.  Specifically, it operates on the reactive stream, which includes things like obtaining a connection from the connection pool and potentially creating a new connection, in addition to the time it takes the client to receive a response.  This leads to having to use a `.timeout` value this is greater than the connection timeout plus the time to obtain the connection from the connection pool.   So, the `.timeout` operator cannot be used as an HTTP request timeout.  I'm willing to ""pay the price"" of establishing connections occasionally (leading to waiting longer occasionally for the stream to emit), but I'd still like to set a lower HTTP request timeout, to ensure the stream emits values fast when a new connection is not established.","closed","type: enhancement,","philsttr","2020-05-21T18:31:16Z","2020-08-28T21:20:33Z"
"","25610","Spring Test: Methods should allow supertypes of Matcher using lower bounded wildcards","I was working with a test helper method a colleague wrote that took in an arbitrary status code `Matcher` to test whether a status code matched a particular value, which was implemented under the hood using [`StatusResultMathers.is(Matcher matcher)`](https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/test/web/servlet/result/StatusResultMatchers.html).  I had one use case where I didn't actually care to assert anything, so I wanted to pass in Hamcrest's [`Matchers.anything()`](http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html#anything()) to the method.  However, `Matchers.anything()` returns a `Matcher`, not a `Matcher`, so it cannot be used with `StatusResultMathers.is`.  I ended up rewriting my test to not require the use of this matcher, but regardless of this fact, pretty much any method that takes in a specific type of `Matcher` to match against an object (e.g. `Matcher`) should be allowed to take in a `Matcher` that matches a superclass as well, since that's still applicable to the object being matched.  Therefore, I propose that this method (and any other such test method in Spring Test) have its input type relaxed to allow the given type or any supertype.  For this specific case, `StatusResultMathers.is(Matcher matcher)` should be changed to `StatusResultMathers.is(Matcher","closed","type: enhancement,","mjustin","2020-08-18T16:40:18Z","2020-08-27T12:14:13Z"
"","25500","Refactoring opportunity in HandlerExecutionChain","I was reading Spring's code base and stumbled upon this:  ```java public class HandlerExecutionChain {      private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);      private final Object handler;      @Nullable     private HandlerInterceptor[] interceptors;      @Nullable     private List interceptorList; ... ```  I haven't looked into this thoroughly, but looks like one of `interceptors` and `interceptorList` is redundant. Interestingly it has been like this from the first commit that I could find in the history: af47a8b79b0fa07ff2c038197a07c09b745802ac ([HandlerExecutionChain.java](https://github.com/spring-projects/spring-framework/blob/af47a8b79b0fa07ff2c038197a07c09b745802ac/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/HandlerExecutionChain.java)).","closed","type: enhancement,","behrangsa","2020-07-31T12:57:59Z","2020-08-06T22:35:22Z"
"","25507","CloseStatus implements Serializable","I wanted to use `CloseStatus` in another serializable class and noticed that it wasn't serializable.  There's no harm in making it serializable... so why not :)","closed","in: web,","candrews","2020-08-03T00:56:13Z","2020-08-28T21:20:32Z"
"","25762","StringDecoder does not provide a way to configure the default charset","i want to write a chatclient for a very old chat system. that chat system uses iso-8859-1 encoding. when i use the webclient, german umlaute (äü etc.) are messed up and there is no way to somehow configure that in StringDecoder. when i tell the webclient to use accept headers with utf8, thats simply ignored as the server can not respond in utf8.  there are 2 or 3 static constructors to allow me to create a StringDecoder but all use utf8!  	public static StringDecoder textPlainOnly(List delimiters, boolean stripDelimiter) { 		return new StringDecoder(delimiters, stripDelimiter, new MimeType(""text"", ""plain"", DEFAULT_CHARSET)); 	} and DEFAULT_CHARSET is UTF-8.  Provide a way to configure that, thanks!","closed","type: enhancement,","damnms","2020-09-13T08:49:11Z","2020-09-14T14:44:42Z"
"","25683","3.2.x","I want to View older version code base for my research purpose. Will you please provide me ?","closed","status: invalid,","mihiramreli","2020-09-03T07:10:58Z","2020-09-03T07:44:45Z"
"","25460","When spring.jackson.date-format and WebMvcConfigurationSupport are used at the same time,  it will not take effect","I want to use ``spring.jackson.date-format=yyyy-MM-dd HH:mm:ss`` to set the time format, but at the same time, my project has customized ``org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport``, and the``yyyy-MM-dd HH:mm:ss``  is no longer effective  please see demo: https://github.com/brucelwl/demo/tree/bug  Digression: there are more and more redundant automatic assembly of ``Springboot``. I hope springboot can simplify these configuration classes, such as ``org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration`` and ``org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration``. ``Spring`` has helped us to implement it","closed","status: invalid,","brucelwl","2020-07-22T09:40:34Z","2020-07-22T14:06:00Z"
"","25484","Execution failed for task ':distZip'.","I want to Install spring-framework-5.2.1.RELEASE in local Maven repository, command is gradlew publishToMavenLocal -x javadoc -x dokka -x asciidoctor ,but failed > Task :distZip FAILED  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':distZip'. > Failed to create MD5 hash for file 'D:\study\spring-framework-5.2.1.RELEASE\build\distributions\spring-framework-5.2.1.RELEASE-schema.zip' as it does not exist.","closed","status: duplicate,","WangHanHong","2020-07-28T08:11:00Z","2020-07-28T08:29:56Z"
"","25750","DispatcherServlet.doDispatch.cleanupMultipart","I use【MultipartFile.transferTo(File dest)】method deal with my file uploaded by HTTP When I return the HTTP request correctly , The file was deleted. I found out that DispatcherServlet.doDispatch.cleanupMultipart did this. Should I give up the multipartfile.transferto (File dest) method for this reason?","closed","for: stackoverflow,","WwwJy","2020-09-10T15:58:21Z","2020-09-11T10:35:45Z"
"","25834","@RequestBody can not parse body data correctly sometimes","I used `@RequestBody` to parse `HttpServletRequest` body data in my POST method.  I repeatedly submit POST request, and possibly the jsonArray is null, but contentLength is not 0.  ```java @PostMapping(""xxx"") public void verify(@RequestBody(required = false)String jsonArray, HttpServletRequest request, HttpServletResponse response)  {     if (jsonArray == null || jsonArray.length() == 0) {         int contentLength = request.getContentLength();         logger.error(""contentLength= "" + contentLength);         response.setStatus(HttpServletResponse.SC_BAD_REQUEST);         return;     } } ```","open","status: feedback-provided,","s-c-c","2020-09-29T08:27:07Z","2020-10-09T06:11:10Z"
"","25073","curl post application/x-www-form-urlencoded throw MissingServletRequestParameterException","I use spring-boot 2.2.x  My code is:  ```java    @PostMapping(path = ""/testFormData"", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)   public BaseResult testFormData(@RequestParam(name = ""name"") String name,       @RequestParam(name = ""age"") Integer age) {     log.info(""api testFormData name is {}, age is {}"", name, age);     return BaseResult.success(name + ""---"" + age);   } ```  and I use curl:  ```  curl -XPOST ""http://127.0.0.1:8082/api/testFormData""  -d ""name=jackson&age=24"" ```  and it throws a `MissingServletRequestParameterException`.  If I use spring-boot 2.1.x, the request is OK.  How can I resolve `application/x-www-form-urlencoded` post request?","closed","in: web,","dragontree101","2020-05-14T06:08:07Z","2022-06-23T10:52:53Z"
"","25803","Support custom TimeUnits in StopWatch","I use `spring-core:5.2.9.RELEASE`.  When I invoke `StopWatch#prettyPrint`,  ```text StopWatch '': running time = 9624841500 ns --------------------------------------------- ns         %     Task name --------------------------------------------- 1202450400  012%  createRandoms 8422391100  088%  write ```  I want `StopWatch` to provide `setTimeUnit(java.util.concurrent.TimeUnit)`, `getLastTime(TimeUnit)` and `getTotalTime(TimeUnit)`; the return type of these methods is `double`.  For example,  ```java StopWatch stopWatch = new StopWatch(); stopWatch.setTimeUnit(TimeUnit.MINUTES); // If not set, StopWatch is applied default TimeUnit. stopWatch.start();  /* working... */  stopWatch.stop(); getTotalTime(TimeUnit.SECONDS); // 9.6248415 getTotalTime(); // 0.160414025 / Without param, it depends on StopWatch#timeUnit System.out.println(stopWatch.prettyPrint()); ``` is like ...  ```text StopWatch '': running time = 0.160414025 min --------------------------------------------- min         %     Task name --------------------------------------------- 0.02004084   012%  createRandoms 0.140373185  088%  write ```  Thanks!","closed","status: superseded,","ImSejin","2020-09-23T07:43:22Z","2020-09-25T12:44:51Z"
"","25498","Please make SimpleJdbcCall.compile() throw exception when the procedure is not exists in Oracle","I use [SimpleJdbcCall](https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcCall.java) to call stored procedure in Oracle.  But I found that when `compile()` non exists procedure, it simply success return. After some digging, I found the following codes that cause this issue.  https://github.com/spring-projects/spring-framework/blob/198d64d5396346d1ce33ca9a80df34fafb2c851f/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericCallMetaDataProvider.java#L370-L375  The `GenericCallMetaDataProvider` believes that Oracle will not return information about stored procedures, so it just ignores the problem.  I tested this and found that the Oracle JDBC driver did return the information about the stored procedures.  * Oracle Server: Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 (Sorry, I only have this version) * Oracle JDBC Driver: com.oracle.database.jdbc:ojdbc8:[12.2.0.1,18.3.0.0,19.3.0.0,19.6.0.0,19.7.0.0] from maven central  Please make SimpleJdbcCall.compile() throw exception in this situation. Or provide some way to enforce this behavior.","open","in: data,","moonfruit","2020-07-31T09:04:13Z","2022-01-28T09:16:49Z"
"","25342","fixed #25263 and #25350","I tried to fiexed [#25263](https://github.com/spring-projects/spring-framework/issues/25263),The test case is in **ImportedConfigurationClassEnhancementTests#checkOverloadedBean**,The test passed,It's in  the Spring-Context module,You can verify it,thanks.","closed","status: superseded,","lifejwang11","2020-06-30T09:07:36Z","2021-11-12T13:36:42Z"
"","25763","Fix typo in AOP XML documentation","I think there is a missing word from this sentence:      The XML style may most familiar to existing Spring users  Should be:      The XML style may *be* most familiar to existing Spring users","closed","type: task,","sokrato","2020-09-13T13:38:23Z","2020-09-14T11:22:03Z"
"","24905","Remove unnecessary sorting in PostProcessorRegistrationDelegate","I think the sorting is unnecessary, because `internalPostProcessors ` has been sorted in every previous stage of traversing `ppNames`. Secondly, this sorting will break some rules, For example, it will cause nonOrderedPostProcessors to sort by `@Order`. But in JavaDoc of BeanPostProcessor ,this is not allowed.  The Ordering section of the class-level Javadoc for BeanPostProcessor states the following. > > `BeanPostProcessor` beans that are autodetected in an `ApplicationContext` will be ordered according to `PriorityOrdered` and `Ordered` semantics. In contrast, `BeanPostProcessor` beans that are registered programmatically with a `BeanFactory` will be applied in the order of registration; any ordering semantics expressed through implementing the `PriorityOrdered` or `Ordered` interface will be ignored for programmatically registered post-processors. Furthermore, the `@Order` annotation is not taken into account for `BeanPostProcessor` beans.","open","in: core,","chenqimiao","2020-04-14T08:47:31Z","2021-11-11T09:51:11Z"
"","24957","DefaultResourceLoader's default constructor makes it easy to introduce a ClassLoader leak","I recently diagnosed a [Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/20900) that has led me to the conclusion that the default constructor of `DefaultResourceLoader` is dangerous and needs to be used with more caution than its javadoc currently suggests. The problem is due to the default constructor capturing the thread context class loader (A) and holding a reference to it in a field. This can lead to problems if the `DefaultResourceLoader` instance is then referenced, directly or indirectly, from a static field of a type that was loaded by a different class loader (B). When this happens, class loader A will now be held in memory for as long as class loader B is reachable. Furthermore, calls to the `DefaultResourceLoader` may result in class loader A being called when that is no longer expected to happen.  Given the danger described above, ideally `new DefaultResourceLoader()` would not capture the TCCL. I think it would be preferable if it used `DefaultResourceLoader.class.getClassLoader()` but I suspect that ship has sailed long ago. Perhaps the default constructor could be deprecated with a view to removing it in the future? That would force code creating a `DefaultResourceLoader` to think about the `ClassLoader` that will be used.","closed","type: enhancement,","wilkinsona","2020-04-22T14:13:33Z","2020-04-28T11:03:16Z"
"","25170","Refactor method name dispatching to switch statements","I propose to refactor method name dispatching to switch statements to follow #25163. Thank you :)","closed","type: enhancement,","YooInKeun","2020-05-31T15:57:25Z","2020-06-02T16:03:08Z"
"","25825","Websockets ExecutorSubscribableChannel class keeps on sending heartbeat every 15 sec.","I opened this issue and tried to follow the suggestion given by @rstoyanchev [here](https://github.com/spring-projects/spring-framework/issues/25781), and as you can see below in screen shot from the logs the heart-beat is getting set but is not honored by the ```StompBrokerRelayMessageHandler``` which keeps on sending the heart-beat message every 15 secs shown in the second screen shot.  ![image](https://user-images.githubusercontent.com/23653871/94387626-ef880600-0107-11eb-8600-56d6c969f90b.png)   ![image](https://user-images.githubusercontent.com/23653871/94388157-68d42880-0109-11eb-8da6-86bc31013467.png)   I'm sure this is a bug since i created a separate project [here ](https://github.com/prinal10/websocketbugdemo) and was able to reproduce over and over.","closed","status: duplicate,","prinal10","2020-09-28T03:05:37Z","2020-09-30T12:33:14Z"
"","24986","Avoid logging exception for closed session in AbstractSockJsSession","I have the following WebSocket configuration :  ```java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {     @Override     public void registerStompEndpoints(StompEndpointRegistry registry) {         registry.addEndpoint(""/game"");         registry.addEndpoint(""/game"").withSockJS();     }      @Override     public void configureClientInboundChannel(ChannelRegistration registration) {         registration.interceptors(subscriptionInterceptor());     }      @Override     public void configureClientOutboundChannel(ChannelRegistration registration) {     }      @Override     public void configureMessageBroker(MessageBrokerRegistry config) {         config.enableSimpleBroker(""/all"",""/user"", ""/table"");         config.setApplicationDestinationPrefixes(""/app"");         config.setPreservePublishOrder(true);     }      @Override     public void configureWebSocketTransport(WebSocketTransportRegistration registry) {         registry.setMessageSizeLimit(5 * 1024 * 1024);         registry.setSendBufferSizeLimit(5 * 1024 * 1024);         registry.setSendTimeLimit(60 * 1000);     }      @Bean     public SubscriptionInterceptor subscriptionInterceptor() {         return new SubscriptionInterceptor();     } } ```  I have around 30 JS clients connected to my server using SockJS to send messages. From time to time I get the following error :  ``` ERROR 14607 --- [io-8080-exec-17] .w.s.a.s.StandardWebSocketHandlerAdapter : Closing session due to exception for StandardWebSocketSession[id=11d93b6a-7de1-354b-4f33-5834a89da351, uri=ws://41.250.241.235:8080/game/352/qbd0x4z4/websocket]  org.springframework.web.socket.sockjs.SockJsMessageDeliveryException: Failed to deliver message(s) [SEND destination:/app/table/7/request/newFrame content-length:2  {}] for session qbd0x4z4; nested exception is org.springframework.web.socket.sockjs.SockJsMessageDeliveryException: Failed to deliver message(s) [SEND destination:/app/table/7/request/newFrame content-length:2  {}] for session qbd0x4z4: Session closed     at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.delegateMessages(AbstractSockJsSession.java:391) ~[spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.handleMessage(WebSocketServerSockJsSession.java:195) ~[spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler.handleTextMessage(SockJsWebSocketHandler.java:93) ~[spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.handler.AbstractWebSocketHandler.handleMessage(AbstractWebSocketHandler.java:43) ~[spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.handleTextMessage(StandardWebSocketHandlerAdapter.java:114) [spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.access$000(StandardWebSocketHandlerAdapter.java:43) [spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:85) [spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:82) [spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     at org.apache.tomcat.websocket.WsFrameBase.sendMessageText(WsFrameBase.java:395) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.server.WsFrameServer.sendMessageText(WsFrameServer.java:119) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.WsFrameBase.processDataText(WsFrameBase.java:495) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.WsFrameBase.processData(WsFrameBase.java:294) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.WsFrameBase.processInputBuffer(WsFrameBase.java:133) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.server.WsFrameServer.onDataAvailable(WsFrameServer.java:82) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.server.WsFrameServer.doOnDataAvailable(WsFrameServer.java:171) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.server.WsFrameServer.notifyDataAvailable(WsFrameServer.java:151) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.upgradeDispatch(WsHttpUpgradeHandler.java:148) [tomcat-embed-websocket-9.0.31.jar:9.0.31]     at org.apache.coyote.http11.upgrade.UpgradeProcessorInternal.dispatch(UpgradeProcessorInternal.java:54) [tomcat-embed-core-9.0.31.jar:9.0.31]     at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) [tomcat-embed-core-9.0.31.jar:9.0.31]     at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.31.jar:9.0.31]     at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1639) [tomcat-embed-core-9.0.31.jar:9.0.31]     at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.31.jar:9.0.31]     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_121]     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_121]     at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.31.jar:9.0.31]     at java.lang.Thread.run(Thread.java:745) [na:1.8.0_121] Caused by: org.springframework.web.socket.sockjs.SockJsMessageDeliveryException: Failed to deliver message(s) [SEND destination:/app/table/7/request/newFrame content-length:2  {}] for session qbd0x4z4: Session closed     at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.delegateMessages(AbstractSockJsSession.java:383) ~[spring-websocket-5.1.14.RELEASE.jar:5.1.14.RELEASE]     ... 25 common frames omitted ``` I have no idea why I do get such an error as the logs are not self-explanatory. I have been looking eveywhere in the internet, but I didn't find any solution to this issue, or at least someone who can explain what is happening.  Grateful if an experienced programmer with Spring and Websocket could help.","closed","type: enhancement,","mbenmass","2020-04-28T03:07:37Z","2020-05-04T09:56:36Z"
"","25601","webflux giving 502 gateway using wrk benchmark tests","I have setup a simple spring boot webflux app with version 2.3.3 with following controller   ``` @RestController public class Controller {      @Autowired     Bean bean;     @RequestMapping(""/{id}"")     public Object test(){         return bean;     } }  ```  and i had setup a nginx in front of it with default configurations and the following proxy pass configuration  ``` server {      server_name com.test;      listen 9080;     location / {             proxy_pass http://172.31.32.52:3000$uri;             proxy_set_header Host $host;     } }  ```  Now while performing wrk benchmarking I ran the following command   ` wrk -t2 -c100 -d30s --latency -s post.lua http://171.31.12.124:9080/reqToRespApi`  This works fine 1 -2 rounds with following results  ``` Running 30s test @ http://171.31.13.124:9080/reqToRespApi   2 threads and 100 connections   Thread Stats   Avg      Stdev     Max   +/- Stdev     Latency    17.86ms    3.06ms  65.83ms   77.39%     Req/Sec     2.81k   270.18     3.33k    62.00%   Latency Distribution      50%   17.34ms      75%   19.47ms      90%   21.48ms      99%   26.47ms   168028 requests in 30.02s, 28.52MB read Requests/sec:   5596.97 Transfer/sec:      0.95MB ```  but later it started giving 502's for few requests with following results  ``` Running 30s test @ http://171.31.12.124:9080/reqToRespApi   2 threads and 100 connections   Thread Stats   Avg      Stdev     Max   +/- Stdev     Latency    89.25ms  253.15ms   2.00s    93.53%     Req/Sec     1.76k     1.06k    3.28k    54.17%   Latency Distribution      50%   19.52ms      75%   34.47ms      90%   95.15ms      99%    1.53s    104958 requests in 30.03s, 18.22MB read   Socket errors: connect 0, read 0, write 0, timeout 81   Non-2xx or 3xx responses: 2509 Requests/sec:   3495.35 Transfer/sec:    621.30KB  ```  After this even normal requests started giving   ```  curl http://localhost:3000/test curl: (56) Recv failure: Connection reset by peer ```  Can I know what configuration needs to be changed ? with normal springboot web app it works fine without any errors.   Tested this on 3 AWS servers with following setup  1. AWS t2 medium - wrk was running here  2. AWS t3axlarge - nginx was hosted here  3. AWS t2 medium -  spring boot app was hosted here     P.S Have modified the IP addresses for security reasons.","closed","","revoorunischal","2020-08-15T09:02:21Z","2020-09-25T09:04:39Z"
"","25745","Spring boot Bean Validation on @NotNull Boolean field fails","I have created some DTO classes through Swaggerhub, generating from a REST API. There are Validation annotations as necessary in the generated DTO classes, and these do work for other data types than Boolean. (So the rest of the required annotations, and configs are in place)  The problem is, that the generated class has a property accessor properly named like `isBlack()`, and this method is annotated as `@NotNull`.  ```java @NotNull public Boolean isBlack() {  return black; } ```  The class having `null` in the property passes through the REST controller method's `@Valid` endpoint without error message.  After experimenting how to find a workaround to the problem I added another accessor method to this field like   ```java @NotNull public Boolean getBlack() {  return black; } ```  With this addition, the null value was properly captured, and returned with validation error message. I am pretty sure, this is a bug in Spring code, which does not look for methods starting with 'is' instead of the regular 'get' for property accessors.","closed","status: invalid,","padisah","2020-09-09T10:36:56Z","2020-09-09T16:53:24Z"
"","24850","Spel on mongodb @ Document not working since 2.2.0.RELEASE","I have been working on a mongodb repository with Spring-framework using spring-data-mongodb. I recently updated the version to 2.2.6.RELEASE and it stopped working. The issue occurred as SPEL is not able to evaluate anything on the @ Document annotation: @ Document(collection = ""#{ getEnvironment().getProperty('XXX') }"") By digging the code I realised that when calling BasicMongoPersistentEntity.getCollection()  will always generate a StandardEvaluationContext with TypedValue rootObject with null values.  Before version 2.2.0 this has been working properly.   I hope this helps.","closed","for: external-project,","riccardorefine","2020-04-02T16:53:45Z","2020-04-07T10:57:06Z"
"","25622","Spring boot java.lang.IllegalStateException: Required to bind 2 arguments, but only bound 1 (JoinPointMatch was NOT bound in invocation)","I have an application which has an aspect built using Spring AOP. In the aspect class XYZ.java I have a method xyz on which the @Around advice is applied. The method xyz calls another method abc in a different class ABC.java which has a @test annotation with an argument. I also have a Controller class which has methods on which there are Spring custom annotations with arguments applied. Since these controller methods are covered by the pointcut in the aspect class, it is throwing the following exception:  Spring boot java.lang.IllegalStateException: Required to bind 2 arguments, but only bound 1 (JoinPointMatch was NOT bound in invocation).   Below is a snippet of how the code looks:  XYZ.java - AspectClass --------------------------- @Around(pointcut()) public Object xyz(ProceedingJoinPoint pj){  ABC.abc(pj); }  ABC.java -- class with annotation ------------------------------------- @test(name=""abc"") public Object abc(ProceedingJoinPoint pj){ pj.proceed(); }  Controller class ------------------- @customAnnotation(name=""custom"") public String apiMethod(){  }  Please help understand how in such a scenario the binding of arguments can be done.","open","status: feedback-provided,","Tritpi","2020-08-21T12:13:41Z","2021-11-10T09:51:28Z"
"","25467","Throw RestClientResponseException instead of RestClientException in HttpMessageConverterExtractor when an error occurs during unmarshalling","I have a use case running tests where the server I hit responds with an XML body instead of the expected type I'm unmarshalling to when there is an error. It would be convenient if I could see what the response body was to determine what the true cause of failure was, instead of just seeing a generic ""Error while extracting response"".  This change could be easily done by instead of throwing a RestClientException, throw something that contains the response in the exception. (Anything extending RestClientResponseException) That way in my test framework code, I can try catch and rethrow the exception exposing the response body.  I see that a similar change was done for the case where the converter is not found - could we do the same for my use case too? https://github.com/spring-projects/spring-framework/commit/aa97563853535d5fea773e18980a8ac964d3e618  Example failed test cause in my framework: (redacted some class names) ``` Caused by: org.springframework.web.client.RestClientException: Error while extracting response for type [class] and content type [application/xml;charset=UTF-8]; nested exception is org.springframework.http.converter.HttpMessageNotReadableException: Could not unmarshal to [class]: null; nested exception is javax.xml.bind.UnmarshalException  - with linked exception: [Exception [EclipseLink-25008] (Eclipse Persistence Services - 2.7.3.v20180807-4be1041): org.eclipse.persistence.exceptions.XMLMarshalException Exception Description: A descriptor with default root element Application_Error was not found in the project] ``` when the real response was  ``` Content: 	Request timed out. ```  Thanks!","closed","in: web,","epiwd","2020-07-23T19:45:46Z","2020-11-24T12:20:21Z"
"","25687","Upgrading from Boot 2.3.3 or 2.4-M1 to Boot 2.4-M2 uses 125mb heap in BitsCronField","I have a small-ish Spring MVC app using Boot 2.3.3. Immediately after startup, this uses 20MB of heap (after triggering a GC).  Changing to Boot 2.4-M2, it uses 140MB. I've also tested with M1 which doesn't display the issue.  Heap dump analysis shows that 125MB of heap is being used by org.springframework.scheduling.support.BitsCronField, because there are 15 million objects in a long[].  My application doesn't use scheduling i.e. there is no @EnableScheduling annotation.  ![image](https://user-images.githubusercontent.com/24962424/92111785-bdbfa000-ede4-11ea-9ec9-b2c63aa4b183.png)","closed","in: core,","leccelecce","2020-09-03T11:58:01Z","2020-09-29T08:19:07Z"
"","25485","SimpleIdGenerator is not thread safe, neither it is documented to be","I have a small miss-understanding about `SimpleIdGenerator`, that is a fairly trivial class:  ``` public class SimpleIdGenerator implements IdGenerator {  	private final AtomicLong mostSigBits = new AtomicLong(0);  	private final AtomicLong leastSigBits = new AtomicLong(0);   	@Override 	public UUID generateId() { 		long leastSigBits = this.leastSigBits.incrementAndGet(); 		if (leastSigBits == 0) { 			this.mostSigBits.incrementAndGet(); 		} 		return new UUID(this.mostSigBits.get(), leastSigBits); 	}  } ```  The presence of `AtomicLong` hints into the fact that this is a thread-safe continuous incremented UUID, but it's not the case:  ``` long leastSigBits = this.leastSigBits.incrementAndGet(); if (leastSigBits == 0) { ```  For the sake of the discussion let's suppose that currently `leastSigBits` holds a `-1` (it has been incremented quite a lot, yes).    `ThreadA` does `long leastSigBits = this.leastSigBits.incrementAndGet();`, so it puts the value into `0` (`-1 + 1 = 0`); but _before_ it does the check `if (leastSigBits == 0)`, `ThreadB` did `long leastSigBits = this.leastSigBits.incrementAndGet();` too, now on a value that is `0`, so it put the value in `1`. `ThreadA` does the check and sees a value of `1`, that `if` statement is not entered and a such a duplicate `UUID`.  This is very far stretched and I have doubts it has ever impacted any users as for this to happen they would need to generate all the `long` range of IDs, which is highly highly improbable. Still, this code is wrong.  If this is suppose to provide _thread-safe_ variant :      - document it as such   - fix the code  if this isn't supposed to be thread safe, simply dropping the un-necessary `AtomicLong` (with it's `volatile` overhead) is going to be a big performance gain.  Either way, I would be more than glad to fix this, if someone tells me the path I should be taking. Thank you.","closed","type: task,","wind57","2020-07-28T15:50:53Z","2020-09-13T20:30:51Z"
"","25321","Improve Random seed in SocketUtils","I had an issue where `System.currentTimeMillis()` was a bad seed when a few tests were running in parallel. I want to be able to override the random to use `nanoTime()`.","closed","status: feedback-provided,","jryan128","2020-06-26T18:19:58Z","2020-07-06T12:35:55Z"
"","25169","The resolvedConstructorArguments field in BeanDefiniton is always null or EMPTY_ARGS","I found that during Bean instantiation, the `resolvedConstructorArguments` are always empty or null.  The purpose of using the cache parameter is to quickly find the corresponding method when the Bean is instantiated the second time. However, in order to avoid creating multiple prototype beans whose properties reference the same object, we cannot directly cache the parameters to be used by the method, so the `preparedConstructorArguments` parameter appears.  As far as I can tell, `resolvedConstructorArguments` is either null or an empty array, and it's only going to be an empty array if the following if-condition is satisfied. The rest of the time it is null.  In `ConstructorResolver`, its `instantiateUsingFactoryMethod` and `autowireConstructor` methods contain the following code:  ```java if (candidates.length == 1 && explicitArgs == null && !mbd.hasConstructorArgumentValues()) {     Constructor uniqueCandidate = candidates[0];     if (uniqueCandidate.getParameterCount() == 0) {         synchronized (mbd.constructorArgumentLock) {             mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;             mbd.constructorArgumentsResolved = true;             mbd.resolvedConstructorArguments = EMPTY_ARGS;         }         bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));         return bw;     } } ```  When `resolvedConstructorArguments` is an empty array, it looks like `resolvedConstructorArguments`'s  job is to make sure that no arguments are needed when the method is called.  I don't understand why it's designed this way.  The `resolvedConstructorArguments` field doesn't seem necessary.","open","in: core,","daimingzhi","2020-05-31T02:15:48Z","2021-05-19T13:00:56Z"
"","25631","Simplify code in AbstractFallbackJCacheOperationSource","I found that `operation` has been judged not to be null before, so it can be returned directly","closed","in: core,","EruDev","2020-08-23T06:03:07Z","2020-09-18T13:11:57Z"
"","24907","Simplify some control flow code","I found some control flow code can be simplify","closed","type: task,","Deycoesr","2020-04-14T11:20:22Z","2020-04-17T16:31:42Z"
"","25202","Update documentation - @Cacheable cannot be used on @PostConstruct","I found out that @Cacheable cannot be used on a @PostConstruct because CacheAspectSupport may be initialized after the components on which I'm calling the cache. I saw this has already been mentioned in this closed issue #17297 but the documentation hasn't been updated.","closed","status: invalid,","robertobatts","2020-06-07T14:26:21Z","2020-06-08T06:46:15Z"
"","25760","Simplify TypeUtils#isAssignable","I found and replace code duplicates in **TypeUtils#isAssignable**, and test **TypeUtilsTests** passed","closed","","GungnirLaevatain","2020-09-12T09:41:38Z","2021-06-17T06:08:40Z"
"","24951","Streaming parsing of JSON array in Spring WebClient","I found #21862 which is pretty close to my request but closed.  I am currently using Spring WebClient with Spring Boot 2.2.6 and Spring Framework 5.2.5 writing a service that sits in front of a number of other upstream services and transforms their response for public consumption.  Some of these services respond with very large JSON payloads that are little more than an array of entities wrapped in a JSON document, usually with no other properties:  ```json {     ""responseRoot"": {         ""entities"": [             { ""id"": ""1"" },             { ""id"": ""2"" },             { ""id"": ""n"" },         ]     } } ```  There could be many thousands of entities in this nested array and the entire payload can be tens of MBs.  I want to be able to read in these entities through a `Flux` so that I can transform them individually and write them out to the client without having to deserialize all of them into memory.  This doesn't appear to be something that Spring WebFlux supports out of the box.  I'm currently exploring writing my own BodyExtractor which reuses some of the code in `Jackson2Tokenizer` to try to support this.  My plan is to accept a `JsonPointer` to the location of the array and then parse asynchronously until I find that array, then to buffer the tokens for each array element to deserialize them.  ```java var flux = client.get()     .uri(uri)     .exchange()     .flatMapMany(r ->         r.body(new StreamingBodyExtractor(JsonPointer.compile(""/responseRoot/entities"")))     ); ```  Before I go too far down this path I was curious if this was functionality that Spring would be interested in supporting out of the box.  Similarly, I was curious about the functionality of being able to stream out a response from a WebFlux controller via a `Flux` where the streamed response would be wrapped in a JSON array and possibly in a root JSON document as well?","open","in: web,","HaloFour","2020-04-21T14:00:02Z","2022-07-12T20:08:23Z"
"","25625","UriBuilder replaceQueryParam suggests a way to handle nulls.","I expect replaceQueryParam to skip null values.  ``` UriComponentsBuilder.newInstance()                 .queryParam(""baz"", ""qux"", 42)                 .replaceQueryParam(""baz"", (Object) null)                .build() ```  expected query is null.  ``` UriComponentsBuilder.newInstance()                 .queryParam(""baz"", ""qux"", 42)                 .replaceQueryParam(""baz"", null, 24)                .build() ```  expected query is ""baz=24""  Tell me what you think. Thanks.","closed","","kingbbode","2020-08-21T17:47:56Z","2020-10-29T12:28:48Z"
"","25212","Performance test may result in ConcurrentModificationException, less than 1% of requests will fail","I don't know why happened this exception,if too many request access,  less than one percent of request will fail.  What should I do to solve the problem?  This is stack of exception:  ``` Caused by: java.util.ConcurrentModificationException 	at java.util.LinkedHashMap$LinkedHashIterator.nextNode(LinkedHashMap.java:719) ~[?:1.8.0_232] 	at java.util.LinkedHashMap$LinkedEntryIterator.next(LinkedHashMap.java:752) ~[?:1.8.0_232] 	at java.util.LinkedHashMap$LinkedEntryIterator.next(LinkedHashMap.java:750) ~[?:1.8.0_232] 	at java.util.HashMap.putMapEntries(HashMap.java:512) ~[?:1.8.0_232] 	at java.util.HashMap.putAll(HashMap.java:785) ~[?:1.8.0_232] 	at org.springframework.web.servlet.view.AbstractView.createMergedOutputModel(AbstractView.java:341) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:314) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.4.RELEASE.jar:5.2.4.RELEASE] 	... 38 more ```","closed","in: web,","Bluselye","2020-06-09T03:44:21Z","2020-06-23T13:17:25Z"
"","25759","Fix typo regarding Ordered interface in core-aop.adoc","I believe there is a typo in *core-aop.adoc*,  `org.springframework.core.Ordered` defines `getOrder`, not `getValue`.","closed","type: documentation,","sokrato","2020-09-12T06:29:24Z","2020-09-14T15:19:35Z"
"","25039","UriBuilder replaceQueryParam not working","I am using spring web-flux webclient and i am passing b as null, but replaceQueryParam is still adding b param in uri. Not sure if i am doing something wrong or is there any bug.  ``` public List getPermissions(String a, String b, String c) { 		return webClient.get() 				.uri(uriBuilder -> uriBuilder 						.path(tenantInformationProvider.getRawTenant() + ""/a/b"") 						.queryParam(""a"",a).replaceQueryParam(""b"", b) 						.replaceQueryParam(""c"", c).build()) 				.header(""Authorization"", ""Bearer "" + userInformationProvider.getToken()).retrieve() 				.onStatus(HttpStatus::is4xxClientError, res -> Mono.error(new Exception(""4XX received from API""))) 				.onStatus(HttpStatus::is5xxServerError, res -> Mono.error(new Exception(""Internal server occured""))) 				.bodyToMono(new ParameterizedTypeReference() { 				}).log().block(); 	} ```  `replaceQueryParam(String name, Object... values)`  passing null to varargs argument still treating as not null and ultimately adding that param in URI. How can i ignore the param if its value is null?","closed","for: stackoverflow,","harish0000","2020-05-09T08:04:40Z","2020-05-10T12:24:28Z"
"","25786","ClientHttpRequestInterceptor does not work for Resttemplate when http 422","I am using spring boot with following dependency on Jdk 11  ```xml  	org.springframework.boot 	spring-boot-starter-parent         2.3.3.RELEASE  ```  this is my resttemplate config.  ```java @Bean(name = ""customRestTemplate"") 	public RestTemplate getResttemplate() { 		RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory())); 		List","closed","status: duplicate,","foxivolunteer","2020-09-18T13:09:32Z","2020-09-25T09:43:13Z"
"","24894","Support for annotating multiple arguments with @RequestBody","I am using `spring-webmvc` 5.2.3.  I want to use Spring's Default MethodArgumentResolver to resolve the json payload into multiple beans. But I am not able to do that right now because `AbstractMessageConverterMethodArgumentResolver.EmptyBodyCheckingHttpInputMessage(httpRequest)`is passed the HttpRequest object and is used directly. While attempting to resolve the second argument the HttpRequest's inputStream is closed, so I get an exception saying that the input stream is closed. Ergo I am able to annotate only one argument with `@RequestBody`.  ```java     @PostMapping(""/endpoint"")     public void  method(@Valid @RequestBody CustomBean bean1,                                  @Valid @RequestBody CustomBean2 bean2)      {         // using both beans.     } ```  Why not use a `ContentCachingRequestWrapper` instead of the actual HttpRequest for argument resolution ?","closed","status: declined,","adiSuper94","2020-04-10T12:39:53Z","2020-04-14T10:54:53Z"
"","25258","Path variable is cut off after semicolon","I am trying to upgrade from `5.0.2.RELEASE` to `5.2.7.RELEASE`.   We have some controllers laying around that accepts path variables with semicolon. For the compatibility we need these variables as full string ( `aa=123;bb=456` ). Previously we had this configuration:  ```java // OLD @Configuration public class CustomRequestHandlerMapping extends WebMvcConfigurationSupport {      @Override     @Bean     public RequestMappingHandlerMapping requestMappingHandlerMapping() {         RequestMappingHandlerMapping handlerMapping = super.requestMappingHandlerMapping();         handlerMapping.setRemoveSemicolonContent(false);         return handlerMapping;     } } ``` Now that the method signature of `WebMvcConfigurationSupport.requestMappingHandlerMapping()` has changed, we have been looking for alternate solutions. We have tried to extend `WebMvcConfigurer`:  ```java // NEW @Configuration public class CustomRequestHandlerMapping implements WebMvcConfigurer {      @Override     public void configurePathMatch(PathMatchConfigurer configurer) {         UrlPathHelper urlPathHelper = new UrlPathHelper();         urlPathHelper.setRemoveSemicolonContent(false);         configurer.setUrlPathHelper(urlPathHelper);     } } ``` I have checked and saw that `shouldRemoveSemicolonContent()` is in fact `true`. But the variable is still cut off. See the controller:  ```java @Controller @RequestMapping(""/accounts/{accountId}/items"") public class ItemController {      @Autowired     private RequestMappingHandlerMapping requestMappingHandlerMapping;      @RequestMapping(value = ""/{itemId}"", method = RequestMethod.GET)     @ResponseBody     @PreAuthorize(""hasAnyRole('Admin', 'User')"")     public ItemDTO getItem(         @PathVariable String accountId,         @PathVariable String itemId) {         System.out.println(""pathVariable: "" + itemId);         System.out.println(""shouldRemoveSemicolonContent: "" + requestMappingHandlerMapping.getUrlPathHelper().shouldRemoveSemicolonContent());         // ....     } } ``` Logs show that: ``` Request url: ""/accounts/123/items/itemid=234;type=bigitem"" pathVariable: itemid=234 shouldRemoveSemicolonContent: false ``` But I want `pathVariable` to be `itemid=234;type=bigitem`. What am I missing and what do I need to do to achieve this?   Is there a possible bug?  --- **Edit:** If we extend `UrlPathHelper` with following values and use it in `configurer.setUrlPathHelper(new CustomUrlPathHelper())`, we get the desired result. But it really feels like a hack. ```java public class CustomUrlPathHelper extends UrlPathHelper {      public DeceivingSemicolonFriendlyUrlPathHelper() {         setRemoveSemicolonContent(false);     }      @Override     public boolean shouldRemoveSemicolonContent() {         return true;     } } ```","closed","status: invalid,","salemdar","2020-06-16T15:53:44Z","2020-06-23T07:16:56Z"
"","25337","Spring Boot 2.3.1.RELEASE executing data.sql after application starts up","I am trying to run a simple Spring Boot 2.3.1.RELEASE web application (which uses an H2 database) that includes a data.sql file. The data.sql creates the database schema and inserts 3 records in the specified table. When the CommandLineRunner runs it  uses a JDBC/DAO Bean to retrieve all the records in the table. However, I'm getting an error:  Table ""PERSON"" not found  The PERSON table is suppose to be created when the data.sql is executed.  What I have found is that the data.sql is being executed after the application is started. Therefore, it doesn't exist when the CommandLineRunner runs.  Here's some of the log info:  - Application Starts:  2020-06-29 17:09:09.456  INFO 19588 --- [           main] c.i.c.DataCreateIssueApplication         : Started DataCreateIssueApplication in 3.016 seconds (JVM running for 3.461) 2020-06-29 17:09:09.467 DEBUG 19588 --- [           main] o.s.jdbc.core.JdbcTemplate               : Executing SQL query [select * from person] 2020-06-29 17:09:09.468 DEBUG 19588 --- [           main] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource  ...  - Error:  Caused by: org.springframework.jdbc.BadSqlGrammarException: StatementCallback; bad SQL grammar [select * from person]; nested exception is org.h2.jdbc.JdbcSQLSyntaxErrorException: Table ""PERSON"" not found; SQL statement: select * from person [42102-200]  ...  - data.sql executed: person table created, 3 records inserted.  2020-06-29 17:09:09.867 DEBUG 19588 --- [         task-2] o.s.jdbc.datasource.init.ScriptUtils     : Executing SQL script from URL [file:/C:/Users/garyj/Documents/STS-4.6.0-Work-Area/workspace-jpa-with-spring-boot/data-create-issue/target/classes/data.sql] 2020-06-29 17:09:09.877 DEBUG 19588 --- [         task-2] o.s.jdbc.datasource.init.ScriptUtils     : 0 returned as update count for SQL: create table person ( id integer not null, name varchar(255), location varchar(255), birth_date timestamp, constraint pk_person_id primary key (id) ) 2020-06-29 17:09:09.897 DEBUG 19588 --- [         task-2] o.s.jdbc.datasource.init.ScriptUtils     : 1 returned as update count for SQL: INSERT INTO PERSON (ID, NAME, LOCATION, BIRTH_DATE ) VALUES(10001, 'Ranga', 'Hyderabad',sysdate()) 2020-06-29 17:09:09.897 DEBUG 19588 --- [         task-2] o.s.jdbc.datasource.init.ScriptUtils     : 1 returned as update count for SQL: INSERT INTO PERSON (ID, NAME, LOCATION, BIRTH_DATE ) VALUES(10002, 'James', 'New York',sysdate()) 2020-06-29 17:09:09.897 DEBUG 19588 --- [         task-2] o.s.jdbc.datasource.init.ScriptUtils     : 1 returned as update count for SQL: INSERT INTO PERSON (ID, NAME, LOCATION, BIRTH_DATE ) VALUES(10003, 'Pieter', 'Amsterdam',sysdate()) 2020-06-29 17:09:09.898 DEBUG 19588 --- [         task-2] o.s.jdbc.datasource.init.ScriptUtils     : Executed SQL script from URL [file:/C:/Users/garyj/Documents/STS-4.6.0-Work-Area/workspace-jpa-with-spring-boot/data-create-issue/target/classes/data.sql] in 31 ms.  This doesn't happen in Spring Boot 2.2.4.RELEASE - in the pom.xml file, I changed the version:  From: 2.3.1.RELEASE  To: 2.2.4.RELEASE  I have attached a Zip file that has the Maven src and pom.xml.   [data-create-issue.zip](https://github.com/spring-projects/spring-framework/files/4848125/data-create-issue.zip)","closed","status: invalid,","garyjolly","2020-06-29T21:47:37Z","2020-07-22T00:03:40Z"
"","25746","ReactiveElasticsearchOperations: UncategorizedElasticsearchException","I am trying to get data from elastic search using spring reactiveElasticsearchOperations,but getting **UncategorizedElasticsearchException**.But I am able to see the object saved in Elastic Search successfully and when i use **CURL** Below is my Code.   **Get From Cache:**   ``` override fun get(cacheName: String, cacheKey: String): Mono {                     return reactiveElasticsearchOperations                 .get(""$cacheKey"", ElasticSearchData::class.java, IndexCoordinates.of(CACHE_INDEX))                 .doOnSuccess { cacheResponse ->                     logger.info(""Cache Response : $cacheResponse"")                 }.flatMap { getStringFromElasticData(it) }                 .onErrorResume {                     logger.warn { ""Failed to Get Response From Cache : $cacheKey"" }                     Mono.empty()                      }         }  ```   **data class**    `data class ElasticSearchData(val id: String, val timeStamp: Long, val data: String)`   **Update Cache Method:**    ``` override fun put(cacheName: String, cacheKey: String, cacheValue: String): Mono {             val elasticSearchData =                 ElasticSearchData(id = ""$cacheKey"", data = cacheValue, timeStamp = Date().time)             val result = reactiveElasticsearchOperations.save(                 elasticSearchData,                 IndexCoordinates.of(CACHE_INDEX)             ).doOnNext { logger.info { ""Updated Response in Cache Successfully for key : $it"" };Mono.just(true) }                 .onErrorResume {                     logger.warn { ""Failed Update cache for key : $cacheKey"" }                     Mono.empty()                 }             return result.flatMap { Mono.just(true) }.switchIfEmpty(Mono.just(false))         } ```    **output Message**  `     org.springframework.data.elasticsearch.UncategorizedElasticsearchException: {""_index"":""index"",""_type"":""_doc"",""_id"":""ABCD"",""_version"":14,""_seq_no"":23,""_primary_term"":1,""found"":true,""_source"":{""_class"":""com.model.ElasticSearchData"",""id"":""ABCD"",""timeStamp"":1599622932721,""data"":""testData""}}]`  Any Help Would be Appreciated","closed","for: stackoverflow,","upen4a3","2020-09-09T13:04:10Z","2020-09-09T13:13:09Z"
"","25788","Extending abstract class does not expose parameter annotations","I am on version 2.3.4.RELEASE and am seeing the same issue identified here https://github.com/spring-projects/spring-framework/issues/24127 except for abstract classes.  Here is the abstract class with the `@RequestBody` annotation:  ![image](https://user-images.githubusercontent.com/2702992/93616176-5f78ec80-f9a2-11ea-8d6a-05d86243c7ff.png)  Here is the `extended` class without the annotation:  ![image](https://user-images.githubusercontent.com/2702992/93616424-bb437580-f9a2-11ea-9a1f-4ff325b05023.png)  Postman showing the data being sent in but returning nulls in the object:  ![image](https://user-images.githubusercontent.com/2702992/93616656-0198d480-f9a3-11ea-8f00-70e705850e3c.png)  If I move the `@RequestBody` annotation to the class that extends this works. Likewise if I make the abstract class an interface and do not provide the `@RequestBody` annotation it works as well.","open","in: web,","couryrr","2020-09-18T15:37:25Z","2021-11-12T14:08:55Z"
"","24943","Spring Websocket's IllegalStateException: Already immutable","I am implementing Websocket in spring-boot application.  Here is what my configuration file looks like:  ```java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {    @Override   public void configureMessageBroker(MessageBrokerRegistry registry) {     registry.enableSimpleBroker(""/queue"", ""/topic"");     registry.setApplicationDestinationPrefixes(""/app"");   }    @Override   public void registerStompEndpoints(StompEndpointRegistry registry) {     registry.addEndpoint(""/application"").withSockJS();   }    @Override   public void configureClientInboundChannel(ChannelRegistration registration) {     registration.interceptors(         new ChannelInterceptor() {           @Override           public Message preSend(Message message, MessageChannel channel) {             StompHeaderAccessor accessor =                 MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);             if (accessor != null) {               accessor.setUser(() -> accessor.getFirstNativeHeader(""user""));               accessor.setLeaveMutable(true);             }             return message;           }         });   } } ```  Here is how I am sending message to client: ```java simpMessagingTemplate.convertAndSendToUser(                     String.valueOf(playerId),                     ""/queue/question"",                     fightQuestion.buildFightQuestionModel(playerId)) ```  But sometime on the server side i am getting following exception : ```java org.springframework.messaging.MessageDeliveryException: Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]; nested exception is java.lang.IllegalStateException: Already immutable 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:146) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:122) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.afterSessionEnded(StompSubProtocolHandler.java:629) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.clearSession(SubProtocolWebSocketHandler.java:530) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.afterConnectionClosed(SubProtocolWebSocketHandler.java:399) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.handler.WebSocketHandlerDecorator.afterConnectionClosed(WebSocketHandlerDecorator.java:85) ~[spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.handler.LoggingWebSocketHandlerDecorator.afterConnectionClosed(LoggingWebSocketHandlerDecorator.java:72) ~[spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecorator.afterConnectionClosed(ExceptionWebSocketHandlerDecorator.java:78) ~[spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.close(AbstractSockJsSession.java:223) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.handler.WebSocketSessionDecorator.close(WebSocketSessionDecorator.java:160) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator.close(ConcurrentWebSocketSessionDecorator.java:252) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.sendToClient(StompSubProtocolHandler.java:490) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageToClient(StompSubProtocolHandler.java:460) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:366) [spring-websocket-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:144) [spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201] 	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] Caused by: java.lang.IllegalStateException: Already immutable 	at org.springframework.util.Assert.state(Assert.java:73) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.messaging.support.MessageHeaderAccessor$MutableMessageHeaders.getRawHeaders(MessageHeaderAccessor.java:641) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.messaging.support.MessageHeaderAccessor.setHeader(MessageHeaderAccessor.java:311) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.messaging.simp.SimpMessageHeaderAccessor.setUser(SimpMessageHeaderAccessor.java:178) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at com.application.config.WebSocketConfig$1.preSend(WebSocketConfig.java:39) ~[classes/:na] 	at org.springframework.messaging.support.AbstractMessageChannel$ChannelInterceptorChain.applyPreSend(AbstractMessageChannel.java:178) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:132) ~[spring-messaging-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	... 17 common frames omitted ```","closed","status: invalid,","ritesh-malav","2020-04-20T13:48:27Z","2020-11-12T15:58:33Z"
"","25346","@ControllerAdvice on bean factory method does not work due overly restrictive target of the ControllerAdvice annotation","I am developing a shared component where all the configuration classes are registered using `spring.factories`.  The library provides some generic error handler implemented as a `@ControllerAdvice`  The current implementation of `@ControllerAdvice` forces me to place the annotation on the class (see below) which makes it error prone. If the user of my component decides to use overly broad classpath scan (hypothetical situation and a bad practice) it will result in the `GlobalExceptionHandler` being register multiple times.  ```java @Configuration public class SharedErrorHandlerConfiguration {      @Bean     SharedExceptionHandler sharedExceptionHandler() {         return new SharedExceptionHandler();     } } // ...  @ControllerAdvice public class SharedExceptionHandler {     // ... } ```  I would like to register the controller advice using factory method, i.e: ```java @Configuration public class SharedErrorHandlerConfiguration {      @Bean     @ControllerAdvice     SharedExceptionHandler sharedExceptionHandler() {         return new SharedExceptionHandler();     } } // ... // No annotation here public class SharedExceptionHandler {     // ... } ```   Could you please change `target` of the `@ControllerAdvice` annotation from `@Target(ElementType.TYPE)` to `@Target({ElementType.TYPE, ElementType.METHOD})` to support controller advices defined using factory method?","open","in: web,","piotrpolak","2020-06-30T17:04:18Z","2021-11-10T12:32:55Z"
"","25108","SpEL in @EventListener(condition='') does not support property resolution","I am desperately trying to use application.yml property inside `@EventListener` `condition` and I can't find a solution anywhere, I dug as far as spring forums to 2010 and endless stackoverflow questions, which I only encountered one being mentioned with no reply and suggestion to use a config bean which is just a workaround and hard to use:  ``` @RunWith(SpringRunner.class) @ContextConfiguration(classes = TestEventListenerTest.TestConfig.class, initializers = ConfigFileApplicationContextInitializer.class) @TestPropertySource(properties = {""bla.number=123""}) @EnableConfigurationProperties(TestConfigProperties.class) ``` This condition should work but it doesn't: ``` @EventListener(classes = SomeEvent.class, condition = ""event.payload.number == ${bla.number}"")         public void listen(SomeEvent someEvent) {             interactee.interact();         } ```  `${}` - trying to reference like in `@Value` results in:  `EL1041E: After parsing a valid expression, there is still more data in the expression: 'lcurly({)'`","closed","for: stackoverflow,","antonalechnovic","2020-05-19T23:48:16Z","2020-12-23T12:32:05Z"
"","25277","add @Override in class AnnotationBeanConfigurerAspect","I add @override on method in class AnnotationBeanConfigurerAspect #25276","closed","in: core,","yanghuai2020","2020-06-18T14:52:05Z","2020-06-23T08:29:04Z"
"","25193","HttpComponentsHttpInvokerRequestExecutor shouldn't throw NoHttpResponseException","https://hc.apache.org/httpcomponents-core-ga/httpcore/apidocs/org/apache/http/NoHttpResponseException.html  > Signals that the target server failed to respond with a valid HTTP response.  Here a valid HTTP response received, I think it's better throw `IllegalStateException` . https://github.com/spring-projects/spring-framework/blob/a6f4862f13f96026bad09d4f40de933035043433/spring-web/src/main/java/org/springframework/remoting/httpinvoker/HttpComponentsHttpInvokerRequestExecutor.java#L326","closed","status: declined,","quaff","2020-06-05T12:12:51Z","2020-08-12T17:01:56Z"
"","24926","Add file parameters as request parts in HtmlUnitRequestBuilder","https://github.com/spring-projects/spring-framework/issues/18551 Solved this issue. If param is an instance of KeyDataPair so add it as part, not as parameter.","closed","type: enhancement,","kobaeugenea","2020-04-18T04:56:43Z","2020-05-06T09:56:11Z"
"","25081","Avoid full synchronization in AbstractRefreshableApplicationContext.getBeanFactory() since it can lead to massive thread blocking","https://github.com/spring-projects/spring-framework/blob/b1224835be7e591fc784c565a7efdb7f09d29d26/spring-context/src/main/java/org/springframework/context/support/AbstractRefreshableApplicationContext.java#L175  On large servers running Tomcat with lots of cores we see massive thread blocking in `getBeanFactory()` due to the synchronized block. This is hit as we're using `XmlWebApplicationContext` and any time a bean is looked up during a web request the bean factory is required.   Outside of web applications we're also having another context using `GenericXmlApplicationContext` which doesn't have that problem.  Would be great to get some insight to either find a workaround on our side or fix the implementation.  Thank you Axel","closed","type: enhancement,","axel-grossmann-sap","2020-05-14T15:22:58Z","2020-06-10T09:13:56Z"
"","25839","FormHttpMessageConverter to preserve parameters from the input MediaType","https://github.com/spring-projects/spring-framework/blob/9a43d2ec208d2e8cd0866431acf26af3529f8677/spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java#L354  The contentType could have prams inside of it when it comes into this method.   This line of code will not look at those prams at those prams will will just over write them.  Instead of just making a new list here, you should take the content type that came in or was made new in the beginning of this method and start a new list from the prams of the contentType. It could look something like: Map parameters = new LinkedHashMap(contentType.getParameters()); instead of: Map parameters = new LinkedHashMap(2);  This will allow the setting of the prams in the rest controller by adding them to the contentType at that level and this will no longer over write them when working with multipart content types.  Thank you for your time  Alan Bond","closed","type: enhancement,","alan-bond","2020-09-29T16:31:39Z","2020-10-06T17:38:52Z"
"","25005","🐱‍👓optimize RestTemplate.doExecute() and use JDK7 Grammar","https://github.com/spring-projects/spring-framework/blob/8e81360eba8cca33522872cdf48eb5f0b84644cb/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L734  > 🐱‍💻When I read the RestTemplate.doExecute() source code, I found that it was based on a very old version of the JDK, and I knew that Spring5 was built on JDK 8.Such as this  ```    protected  T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback, 			@Nullable ResponseExtractor responseExtractor) throws RestClientException {  		Assert.notNull(url, ""URI is required""); 		Assert.notNull(method, ""HttpMethod is required""); 	 		try (ClientHttpResponse  response = new ClientHttpResponse()){ 			ClientHttpRequest request = createRequest(url, method); 			if (requestCallback != null) { 				requestCallback.doWithRequest(request); 			} 			response = request.execute(); 			handleResponse(url, method, response); 			return (responseExtractor != null ? responseExtractor.extractData(response) : null); 		} 		catch (IOException ex) { 			String resource = url.toString(); 			String query = url.getRawQuery(); 			resource = (query != null ? resource.substring(0, resource.indexOf('?')) : resource); 			throw new ResourceAccessException(""I/O error on "" + method.name() + 					"" request for \"""" + resource + ""\"": "" + ex.getMessage(), ex); 		} 	}  ```  ⛳Doing so makes the code more maintainable. The maintainer doesn't need to focus on anything else that doesn't matter. what do you think ?","closed","","XiaoZiShan","2020-05-02T06:09:06Z","2020-05-04T11:11:09Z"
"","25480","Wrong error message for type mismatch in jsonPath().value()","https://github.com/spring-projects/spring-framework/blob/87c5b5a66485aa3d8071e96ec36c032092c8c3c7/spring-test/src/main/java/org/springframework/test/util/JsonPathExpectationsHelper.java#L295  This is the code I was running  `.andExpect(jsonPath(""$.myRootObject.content"").value(myObject.getContent()))`  In json path the returned value has the datatype `String`. Somehow I wrongly put `byte[]` in the expected. `myObject.getContent()` returns `byte[]`. So I was trying to compare `String` with `byte[]`. The error received should be `ClassCastException`. `No Value at JSON Path` is misleading message.   So there is value at the JSON path, its just that there is mismatch in the type.  Value is present , so thrown error should give more specific issue , which is with expected and not with actual.","closed","type: bug,","g1patil","2020-07-27T23:40:31Z","2020-08-04T18:16:46Z"
"","25161","Suggest making a Set.size() > 0 judgement for AbstractApplicationContext.earlyApplicationEvents","https://github.com/spring-projects/spring-framework/blob/7e2b81729eefe31e9e8b2872b0de0adc1bad2162/spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java#L839","closed","type: enhancement,","luohaoGit","2020-05-29T03:10:03Z","2020-05-29T14:06:47Z"
"","25637","spring-web RestTemplate doExecute HttpMethod is marked as @Nullable but later asserted to be non-null","https://github.com/spring-projects/spring-framework/blob/7adeb461e0464b0d07c2e8fbe36ce0a22f0a7b5e/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L759  https://github.com/spring-projects/spring-framework/blob/7adeb461e0464b0d07c2e8fbe36ce0a22f0a7b5e/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L763","open","in: web,","PeterW-LWL","2020-08-24T07:53:55Z","2021-11-10T12:08:08Z"
"","24954","can support ConnectionPoolDataSource ?","https://github.com/spring-projects/spring-framework/blob/5721c747b26665ccf1afb5e823b9774be2bffbcf/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java#L164  getPooledConnection().getConnection()","closed","in: data,","gMan1990","2020-04-22T03:38:45Z","2020-04-22T08:18:56Z"
"","25138","Javadoc for JdbcOperations.batchUpdate should mention that negative values are possible","https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcOperations.html#batchUpdate-java.lang.String...-  In the spring java doc for this method, it says ""Returns: an array of the number of rows affected by each statement"". This statement is misleading because ""The number of rows"" would never be negative.  However, this method could delegate to https://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Statement.html#executeBatch() where negative values are possible, such as SUCCESS_NO_INFO/-2  The Spring javadoc should make this clear.","closed","type: documentation,","tongc","2020-05-27T11:53:25Z","2020-05-29T14:06:48Z"
"","25347","Documentation - possibly wrong example","https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#aop-schema-params  There is code example in this chapter of documentation ``` public interface PersonService {      Person getPerson(String personName, int age); }  public class DefaultFooService implements FooService {      public Person getPerson(String name, int age) {         return new Person(name, age);     } } ``` Maybe you mean  ``` public class DefaultPersonService implements PersonService {} ``` instead ``` public class DefaultFooService implements FooService {} ``` Because further in the example XML configuration is written ```  ```","closed","status: superseded,","MaksimKoniukhov","2020-06-30T17:50:08Z","2020-07-01T08:40:01Z"
"","25015","WebTestClient ignores @Valid on list parameters","Hi,   I've got simple `RestController` with two endpoints, one POST on `/` for a single entity and one POST on `/bulk` for a list of entities. Both are annotated with `@Valid`, and the `RestController` is annotated `@Validated`.  All works fine and throws errors when missing `@NotBlank` entity fields, but when writing unit tests with `WebTestClient` I found out that the `@Valid` on the List of entities is ignored. Testing the single entity POST properly throws a 400 though.  Here's the controller:  ```java @Validated @RestController @RequestMapping(""/entities"") public class ApiController {      @PostMapping     public ResponseEntity save(@Valid @RequestBody Entity entity) {         //deal with valid entity     }      @PostMapping(""/bulk"")     @NotEmpty(message = ""List is not allowed to be empty"")     public ResponseEntity saveAll(@RequestBody @Valid List entities) {         //deal with valid entities     } } ```  This is the JUnit test method:  ```java @Test void testSaveAllShouldFailWhenRequiredFieldsAreMissing() {     WebTestClient.bindToController(apiController).build()         .post()         .uri(""/entities/bulk"")         .bodyValue(List.of(                 Entity.builder().requiredField(""dummy"").build(),                 Entity.builder().build()))         .exchange()         .expectStatus().isBadRequest(); } ```  The `requiredField` in the entity is annotated with `@NotBlank`.  I would expect this test to be succesfull (eg. the `WebTestClient` should receive a 400) but it doesn't. A similar test for the rest endpoint with a single entity works as expected.","closed","for: stackoverflow,","gvermoen","2020-05-05T13:18:35Z","2020-05-06T11:18:16Z"
"","25673","Spring Web Client is not using proxy if its configured","Hi, When I use Spring web client behind corporate proxy its not using the proxy server to connect. I thought its netty and oauth2 client. Seems its webclient is not using the proxy server.  Here is the link for the sample code :  https://github.com/kmariappan2016/spring-web-client.git","closed","for: stackoverflow,","kmariappan2016","2020-09-01T15:00:05Z","2020-09-01T15:19:27Z"
"","25413","SimpleUrlAuthenticationFailureHandler Exception","Hi, Spring Boot 2.3.1 RELEASE I am trying to handle authentication failure using SimpleUrlAuthenticationFailureHandler and redirect or forward response URL to a new destination URL. Two issues observed: 1.)  The method: setDefaultFailureUrl(java.lang.String defaultFailureUrl) is not functioning. 2.) The constructor: SimpleUrlAuthenticationFailureHandler(java.lang.String defaultFailureUrl) would not permit literal String as a parameter unless as bean(object).  [AuthenticationHandler.pdf](https://github.com/spring-projects/spring-framework/files/4939008/AuthenticationHandler.pdf)","closed","for: external-project,","ftanimowo","2020-07-17T16:44:22Z","2020-07-20T07:18:41Z"
"","25191","Expose access to STOMP SimpleMessageBroker sessions user Principal","Hi,  We have a Spring application with a SockJS / STOMP SimpleMessageBroker setup. User authentification happens through a JWT token passed in a STOMP CONNECT message header.  Everything is working as desired except we would like to close the broker sessions for the users with an expired JWT token. So users are not able to receive messages after their authentication expired.  To do so, I wanted to have a scheduled task that would inspect all the open sessions principals to check if they are expired, and send a DISCONNECT message when necessary.  However I've not been able to find a way to access the Principal object for the open sessions (seems to be stored in SimpleBrokerMessageHandler.SessionInfo).  Am I missing something or is this not currently possible?","closed","type: enhancement,","bgK","2020-06-05T11:36:56Z","2020-10-19T20:41:17Z"
"","25001","Incorrect reference information about CGLIB supported method visibility","Hi,  Please update the documentation to reflect the actual behaviour: In case of Proxies create by CGLIB it is stated that: ""CGLIB proxies intercept only public method calls! Do not call non-public methods on such a proxy. They are not delegated to the actual scoped target object.""  But this is not true, CGLIB proxies created by Spring-AOP mechanism can in fact intercept non-public methods too (protected and package-default). Probably this claim should be better off as a ""recommendation"".  This claim is found under: PDF Spring Framework Reference Documentation 5.0.0.M1 page 55 Also under current reference (from today): https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-other-injection  Similar claim occurrence: ""Due to the proxy-based nature of Spring’s AOP framework, protected methods are by definition not intercepted, neither for JDK proxies (where this isn’t applicable) nor for CGLIB proxies (where this is technically possible but not recommendable for AOP purposes). As a consequence, any given pointcut will be matched against public methods only!""  I have come across this while studying for the Spring Core Certification and tested it myself. See also other opinions: https://stackoverflow.com/questions/53717707/spring-cglib-proxies-intercept-only-public-method-calls   Best regards, Georgian Dumitrache  **Affects:** \  ---","open","in: core,","gdumitrache","2020-05-01T07:26:01Z","2021-11-10T10:03:01Z"
"","25443","Cyclic dependency with setter injection and Java Config","Hi,  I'm trying to run simple spring core with Spring Circular dependency + Setter Dependency Injection + Java Config => Getting Exception. It's working fine with XML config. but its failing with java config. I'm not able to understand what is the problem.   Attached required files to replicate the issue locally.  Spring Circular dependency + Setter Dependency Injection + Java Config => Getting Exception  Spring Circular dependency + Setter Dependency Injection + XMLConfig =>  Working Fine Attached Files for debugging purpose  Exception in thread ""main"" java.lang.NoClassDefFoundError: org.springframework.beans.FatalBeanExceptionException in thread ""main"" java.lang.NoClassDefFoundError: org.springframework.beans.FatalBeanException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)  [circular.zip](https://github.com/spring-projects/spring-boot/files/4953425/circular.zip)","open","in: core,","JawinSoft","2020-07-21T12:23:03Z","2022-06-07T13:28:09Z"
"","25367","Allow auto grow for entries without default constructor in SpEL","Hi,  I wanted to add a `BigDecimal` to a list using SpEL. Auto grow only works for element types with a default constructor and since `BigDecimal` does not have a default constructor auto grow does not work with my list.  Here is an example:  ```java public class SpelTest {      public List values;          SpelExpressionParser parser;      @Before     public void setup() {         values = new ArrayList();         parser = new SpelExpressionParser(new SpelParserConfiguration(true, true));     }      @Test     public void shouldChangeValue() {         values.add(BigDecimal.ONE);          parser.parseExpression(""values[0]"").setValue(this, ""123.4"");          assertThat(values.get(0)).isEqualTo(BigDecimal.valueOf(123.4)); // passes     }      @Test     public void shouldAddValue() {         parser.parseExpression(""values[0]"").setValue(this, ""123.4"");          assertThat(values.get(0)).isEqualTo(BigDecimal.valueOf(123.4)); // fails     } } ``` Changing the first entry passes but adding an entry fails with  ``` Caused by: java.lang.NoSuchMethodException: java.math.BigDecimal.()     at java.base/java.lang.Class.getConstructor0(Class.java:3349)     at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2553)     at org.springframework.util.ReflectionUtils.accessibleConstructor(ReflectionUtils.java:185)     at org.springframework.expression.spel.ast.Indexer$CollectionIndexingValueRef.growCollectionIfNecessary(Indexer.java:715)     ... 55 more ```  My solution inserts `null` when no default constructor can be found for the element type. Not sure if this is a good solution but at least it does not seem to break any tests. Please be nice :-)","closed","status: feedback-provided,","MartinKnopf","2020-07-07T17:58:04Z","2020-07-16T14:02:59Z"
"","25133","RestTemplate Timeout is not working over 30 seconds","Hi,  I am trying to set my rest template timeout over 120 seconds. But it is not working. It is keep timing out around 30 seconds. This is happening when the client is on my local machine and the service I am making the call is running on a server. Also, client and service is on a server. But when client and service running on my local machine, timeout is working fine. Anyone know  what is causing this?   ```java @SpringBootApplication public class PlaylistPublisher {      public static void main(String[] args) {         SpringApplication.run(PlaylistPublisher.class, args);     }      @Bean     public ServletRegistrationBean dispatcherRegistration(DispatcherServlet dispatcherServlet) {         return new ServletRegistrationBean(dispatcherServlet, ""/rest/*"");     }      @Bean     public RestTemplate restTemplate() {         HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory();         clientHttpRequestFactory.setReadTimeout(120000);         return new RestTemplate(clientHttpRequestFactory);     }  } ```  ```java @Autowired RestTemplate restTemplate;      public String getService() {         UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(""https://testservice.net/US/get/2020-05-26T01:00:00.000-0400/2020-05-27T00:00:00.000-0400/QVC/Update/playout"");        return restTemplate.getForObject(                 builder.toUriString(),                 String.class);     } ```","closed","for: stackoverflow,","jacobkurian30","2020-05-26T19:46:13Z","2020-05-28T09:46:13Z"
"","25070","Custom Exceptionhandler @ControllerAdvice not working as it should","Hi,  I  created a RestExceptionHandler to manage all exceptions thrown from RestControllers. I am having a problem that RestExceptionHandler is not intercepting the exception and returning the custom message format.  The RestExceptionhandler implementation:  ``` @Order(Ordered.HIGHEST_PRECEDENCE)  @ControllerAdvice(annotations = RestController.class) public class RestExceptionHandler 	 	private static final Logger LOGGER = LoggerFactory.getLogger(RestExceptionHandler.class);  	@ExceptionHandler(ResourceNotFoundException.class) 	public ResponseEntity handleResourceNotFoundException(ResourceNotFoundException exception, 			HttpServletRequest request) { 		ErrorDetail errorDetail = new ErrorDetail(); 		errorDetail.setTimeStamp(Instant.now().getEpochSecond()); 		errorDetail.setStatus(HttpStatus.NOT_FOUND.value()); 		errorDetail.setTitle(""Resource Not Found""); 		errorDetail.setDetail(exception.getMessage()); 		errorDetail.setDeveloperMessage(exception.getClass().getName()); 		return new ResponseEntity(errorDetail, null, HttpStatus.NOT_FOUND); 	} } ```   The RestController implementation as below:  ``` @RestController @RequestMapping(""/departments"") public class DepartmentRestController {  	@Autowired 	private DepartmentService departmentService;  	protected Department verifyDeparmentExistence(int id) { 		Department department = departmentService.findById(id); 		if (department != null) { 			throw new ResourceNotFoundException(""Department with id: "" + id + "" not found.""); 		} 		return department; 	}  	@GetMapping 	public ResponseEntity findAll() { 		List departmentList = departmentService.findAll(); 		return new ResponseEntity(departmentList, HttpStatus.OK); 	}  	@GetMapping(""/{id}"") 	public ResponseEntity findById(@PathVariable int id) { 		Department department = verifyDeparmentExistence(id); 		return new ResponseEntity(department, HttpStatus.OK); 	} } ```   The ResourceNotFoundException is like below:  ``` @ResponseStatus(HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException { 	 	private static final long serialVersionUID = 1L; 	 	public ResourceNotFoundException() {} 	 	public ResourceNotFoundException(String message) { 		super(message); 	} 	 	public ResourceNotFoundException(String message, Throwable cause) { 		super(message,cause); 	}  } ```   The ErrorDetail (the custom message format that should be returned) :  ``` @Data public class ErrorDetail { 	 	private String title; 	private int status; 	private String detail; 	private long timeStamp; 	private String path; 	private String developerMessage; 	private Map errors = new HashMap(); } ```  The full project you can find it the link  below : https://github.com/rshtishi/payroll/tree/master/department","closed","status: invalid,","rshtishi","2020-05-13T20:24:34Z","2020-05-15T16:29:05Z"
"","25749","@Lookup doesn't work in case of AbstractBeanFactory's cacheBeanMetadata=false","HI! I came across the use case when I wanted to create some provider with @Lookup but when our BeanFactory has cacheBeanMetadata = false, Spring can't create a proxy for the provider and then @Lookup doesn't work.  Here is my unit test for ease reproduction https://github.com/aliaksandr-budnikau/Lookup-annotation-bug/blob/master/src/test/java/org/example/MyComponentProviderTest.java  Thanks, Alex","open","type: enhancement,","aliaksandr-budnikau","2020-09-10T07:28:04Z","2020-10-05T10:22:02Z"
"","25657","Wrong type inference in Kotlin while overriding RequestMappingHandlerMapping#getMappingForMethod","Hi!  Im trying override method `org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#getMappingForMethod` in Kotlin: ```kotlin class CustomVersionRequestMappingHandlerMapping : RequestMappingHandlerMapping() {      override fun getMappingForMethod(method: Method, handlerType: Class): RequestMappingInfo {         ...     } ``` And kotlin compiler inference return type as **non-nullable**, but base abstract method in `org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping#getMappingForMethod` declared as **nullable**: ```java @Nullable protected abstract T getMappingForMethod(Method method, Class handlerType); ``` So if I try change return type as nullable: ```kotlin override fun getMappingForMethod(method: Method, handlerType: Class): RequestMappingInfo? { ``` compiler fails with error:  > Return type is 'RequestMappingInfo?', which is not a subtype of overridden protected/*protected and package*/ open fun getMappingForMethod(method: Method, handlerType: Class): RequestMappingInfo defined in org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping  It seems like Kotlin applies nullability rules from package-info file in this case: ```java @NonNullApi @NonNullFields package org.springframework.web.reactive.result.method.annotation; ``` and it is bug.   How can I fixed that?  Thank you.","closed","type: bug,","pavelshackih","2020-08-28T14:33:51Z","2020-10-07T12:20:53Z"
"","24920","Introduce onlyNumbers() method in StringUtils","Hi!  I create a new static method on SpringUtils  Sometimes I need to compare Strings or their size in a condition and for that I create a useful in the project itself for this, but I saw that this is very common among the projects that I passed or know, so I decided to create this method so that it is more accessible to everyone and reuse the same code.  I love the spring, congrats to the team!","closed","in: core,","RhianLopes","2020-04-16T16:26:27Z","2020-04-16T16:39:44Z"
"","25023","405 Method is not Allowed exception: ""Request Method 'T' not supported"" for GET call  and ""Request Method 'ST' not supported"" for POST","Hi Team, I am facing a very strange issue in my project. It is related to rest API call using spring reactive webclient bulider. It is working fine on local and prod as well but abnormally giving  below error  after 3 or 4 request to same endpoint. ""org.springframework.web.server.MethodNotAllowedException: 405 METHOD_NOT_ALLOWED ""Request method 'T' not supported"" This is valid exception as method going to ""T"" for Get method and ""ST"" for Post method .I am not able to understand why two starting charcter truncating from method name  Please help me resolve this error.","closed","status: invalid,","manuj20","2020-05-07T04:46:38Z","2022-07-04T14:08:55Z"
"","25276","add @Override on method  in class AnnotationBeanConfigurerAspect","Hi Team, I add @Override on method  in class AnnotationBeanConfigurerAspect","closed","status: superseded,","yanghuai2020","2020-06-18T14:51:15Z","2020-07-01T08:36:04Z"
"","25462","Global and Local logging","Hi team,  Version : Spring Boot WebFlux 2.2.5.RELEASE  ## Use Case  We consume lots of API from many external teams. Consequently, we want to manage a global Webclient logging to log the response from our API and sometimes, log and trigger specific actions on specific call.  The problem is that the global logging consume the client response and the specific trigger is never triggered.  Here is the global logging :  ```  return clientResponse                         .bodyToMono(String.class)                         .doOnNext(responseBody -> {                             log.error(""[API]["" + producers + ""] Unsuccessful response received : {}"", responseBody);                         })                         .then(Mono.just(clientResponse)); ```   Here is the specific action we want to trigger on 404 response : ```  .onStatus(HttpStatus.NOT_FOUND::equals, clientResponse ->                                 clientResponse.bodyToMono(ErrorResponse.class)                                         .flatMap(errorResponse -> Errors.SIMULATION_ERROR.equals(errorResponse.getCode()) ? Mono.error(SimulationErrorException::new) :                                                 Mono.error(new NotFoundException(id)))) ```  Can you see something wrong ? Is it possible to consume both global and local ?","closed","","fgruchala","2020-07-23T08:49:19Z","2021-03-23T18:08:08Z"
"","25271","Snapshot introduces breaking change","Hi team,  It looks like the current snapshot version of spring-framework introduces breaking changes, potentially because of the Kotlin upgrade. We're seeing `org.jetbrains.kotlin.codegen.CompilationException: Back-end (JVM) Internal error: Couldn't inline method call` errors in the spring security repository when we run our snapshots tests. We tried updating our Kotlin version locally to the one used in the current spring-framework snapshot to see if it would resolve the issue, but the issue persisted.  We put up a sample project that re-creates the error – you can reference it [here](https://github.com/eleftherias/spring-kotlin-expect-test) and can duplicate the error case by running the project's tests. Another example of the issue can be found in [this Jenkins build](https://jenkins.spring.io/job/spring-security/job/master/2962/execution/node/55/log/).  **Please note that this is currently blocking the spring security team's builds.** Thank you!","closed","","elliedori","2020-06-17T18:48:09Z","2020-06-24T20:24:19Z"
"","25183","Performance enhancement in execution of ResponseEntity.of()","Hi Team,  I think I have found a very small performance enhancement when using ResponseEntity.of  Currently the code for the method is  	public static  ResponseEntity of(Optional body) { 		Assert.notNull(body, ""Body must not be null""); 		return body.map(ResponseEntity::ok).orElse(notFound().build()); 	}  That is the NOT_FOUND Response Entity is always built, even if it is not required.  The small change would be  	public static  ResponseEntity of(Optional body) { 		Assert.notNull(body, ""Body must not be null""); 		return body.map(ResponseEntity::ok).orElseGet(() -> notFound().build()); 	}  By using the orElseGet method, the construction of the NOT_FOUND Response Entity is delayed until it is required.  There maybe other considerations here, such as the construction of the lambda needs to be balanced against the construction of the NOT_FOUND Response Entity.  In your estimation, is a PR worthwhile for this small enhancement?  Cheers, Brett","closed","type: enhancement,","brett-walker","2020-06-04T07:47:28Z","2020-06-06T16:59:02Z"
"","25249","404 rather than 405","Hi Team,  I am getting 405 instead of 404 if the URL is not available. I looked into the existing issue and found that there is PR https://github.com/spring-projects/spring-framework/pull/962 which is merged. So, I have updated the spring framework to the latest version but still facing the same issue.   for example :  valid URL is **/employee/1/attendance**   if user try to hit **/employee/1/atten** which is not valid, they will get 405 indicating URL is correct but the method is not valid   Please have a look and let me know in case of more clarifications:).  /Mudassar","closed","","MRDcoder","2020-06-14T22:30:55Z","2020-06-29T11:30:34Z"
"","25486","Please specify the version used for  iText, a JAVA PDF library JAR in spring-webmvc-5.2.4.RELEASE.jaR of AbstractPdfStamperView.class","Hi Team,  Can you please let me know which version of iText, a JAVA PDF library JAR is used during compilation of `spring-webmvc-5.2.4.RELEASE.jar`.  It's used in the `AbstractPdfStamperView` class of `spring-webmvc`.","closed","","Swagatika20","2020-07-28T16:09:26Z","2020-07-29T16:11:13Z"
"","25359","Question about ResponseEntityExceptionHandler behavior","Hi Spring team,  I am extending ResponseEntityExceptionHandler to implement a global exception handler, and I come across these two problems.  1. Return ResponseEntity statement seems not working without @ResponseStatus for built-in exception types.  For example, I throw an IllegalArgumentException in controller when a param fails validation. Then I catch the exception in GlobalExceptionHandler ```java @RestControllerAdvice public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {     @ExceptionHandler(IllegalArgumentException.class)     protected ResponseEntity illegalParamErrorHandler(IllegalArgumentException ex) {         return new ResponseEntity(                 ResultUtil.error(ErrorCodeEnum.ERROR_CODE_BAD_REQUEST, ex.getMessage()),                 HttpStatus.BAD_REQUEST         );     } } ``` The response code is still 500 Internal Error instead of assigned `HttpStatus.BAD_REQUEST` as expected.  Then I tried to add `@ResponseStatus` annotation and it worked. The response code becomes 400. ```java @RestControllerAdvice public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {     @ExceptionHandler(IllegalArgumentException.class)     @ResponseStatus(HttpStatus.BAD_REQUEST)    //","closed","for: stackoverflow,","njZhuMin","2020-07-06T09:48:50Z","2020-07-13T12:15:39Z"
"","25238","component-scan causes ClassNotFoundException on lazy-init beans which otherwise fail silently","Hi I've ran into a problem, and from looking at the exception message - feels like a bug (at least in the exception message if not the behavior).  ```xml  ```  If I have the above bean definition for a class which does not exist, when the application context starts, there is no error (at debug log level there is an exception that is ignored and logging however).  If I then import some other XML, from an entirely different project - which may use component-scan and autowired beans in a completely different package:  ```xml  ```  with an example Class:  ```java package example.types.autowired;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component;  @Component public class AutowiredClass {     @Autowired     public AutowiredClass(AutowiredChild autowiredChild) {     }      @Component     public static class AutowiredChild {     } } ```   Then the application context startup fails with the following error:  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'autowiredClass' defined in file [C:\Users\ssansoy\dev\scrap\build\classes\java\main\example\types\autowired\AutowiredClass.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [example.types.MissingClass] for bean with name 'missingClass' defined in class path resource [beans.xml]; nested exception is java.lang.ClassNotFoundException: example.types.MissingClass ```  E.g. the missing class is somehow reported as being involved in my AutowiredClass - when it is not.   I see this is coming from `DefaultListableBeanFactory.findAutowireCandidates(...)` ultimately calling `doGetBeanNamesForType`, with `allowEagerInit=true`. E.g. it's testing if the `lazy-init` bean could be an autowire candidate. Is this expected behavior?   It makes sense that every bean is tested as a potential candidate, but the difference in the way the missing class is handled seemed odd.  Thanks!","closed","in: core,","SSansoy","2020-06-11T09:33:45Z","2020-06-25T14:45:33Z"
"","25587","Slow WebClient Under Heavy Load >500 users","Hi everyone, I created 2 Spring Webflux applications with the following version: spring-boot: 2.3.2.RELEASE spring-webflux: 5.2.8.RELEASE reactor-core: 3.3.8.RELEASE reactor-netty: 0.9.10.RELEASE  App1 ```kotlin @RestController class DemoController(webClientBuilder: WebClient.Builder) {  	private val webClient = webClientBuilder.build() 	private val counter = AtomicLong(0)  	@GetMapping(""/"") 	fun demo(@RequestParam delay: Long): Mono { 		return webClient.get() 			.uri(""http://localhost:8080/delay?delay=$delay"") // This calls App2 			.retrieve() 			.bodyToMono(String::class.java) 	} } ```  App2 ```kotlin @RestController class DelayController { 	@GetMapping(""/delay"") 	fun getUserWithDelay(@RequestParam delay: Long): Mono { 		return Mono.just(""OLOLO"").delayElement(Duration.ofMillis(delay)) 	} } ```  Then I run some load test scenarios:  **Scenario 1 (Expected)** Users/Threads: 500 Target Throughput: 30k/min Delay: 1s  Result when calling directly to App2: Throughput: 500/s (expected because 30k/min ~ 500/s) Median Latency: 1s (expected because the delay is also 1s)  Result when calling to App1 -> App2: Throughput: 500/s (expected because 30k/min ~ 500/s) Median Latency: 1s (expected because the delay is also 1s)  **Scenario 2 (App 1 slow, App2 expected)** Users/Threads: 1000 Target Throughput: 60k/min Delay: 1s  Result when calling directly to App2: Throughput: 1k/s (expected because 60k/min ~ 1k/s) Median Latency: 1s (expected because the delay is also 1s)  Result when calling to App1 -> App2: Throughput: 500/s (expecting 1k/s) Median Latency: 2s (expecting 1s)  **Scenario 3 (App1 slow, App2 expected)** Users/Threads: 2000 Target Throughput: 60k/min Delay: 1s  Result when calling directly to App2: Throughput: 1k/s (expected because 60k/min ~ 1k/s) Median Latency: 1s (expected because the delay is also 1s)  Result when calling to App1 -> App2: Throughput: 500/s (expecting 1k/s) Median Latency: 4s (expecting 1s)  **Summary** It's causing higher latency and lower throughput when using WebClient (App1) with higher threads (>500) from jmeter   Any advice regarding this problem?","closed","in: web,","riko-traveloka","2020-08-14T06:30:21Z","2022-02-18T19:06:24Z"
"","25245","Build from source error","Hi everyone, I have an error when,i want to build Spring framework from source.When i tap ./gradlew build in the terminal.I get this error :  Exception in thread ""main"" java.lang.RuntimeException: java.io.IOException: Server returned HTTP response code: 403 for URL: http://services.gradle.org/distributions/gradle-1.11-bin.zip","closed","status: invalid,","andresetevejob","2020-06-12T05:54:13Z","2020-06-12T07:33:56Z"
"","25259","Open single spring project","Hi all, I have cloned the spring github repository and and i have build the all project.It's possible to open in inteelij idea community, a single project like spring-orm and working on without open all the spring projects. When i open the spring-orm project in intellij idea.This is message that the ide show me : Task 'wrapper' not found in project ':spring-orm'.","closed","status: declined,","andresetevejob","2020-06-17T06:47:52Z","2020-06-17T19:38:25Z"
"","25173","CaffeineCache does not support LoadingCache consistently","Hi all CaffeineCache implementation override method `public ValueWrapper get(Object key)` and there is a specific check when a LoadingCache is provided. In this case, the CacheLoader of the LoadingCache is used to retrieve the data (if not already present int the cache).  I don't see the same behavior for the method `public  T get(Object key, @Nullable Class type)`. In this case, the CacheLoader of the LoadingCache is never used. Using only this method... the cache will be always empty.  Is there any reason for this different behavior?  Thanks Stefano","closed","type: bug,","stefano-salmaso","2020-06-01T23:42:35Z","2020-08-07T08:40:33Z"
"","25438","Reporting wrong  SpelEvaluation EL1004E when an exception is happening in the method","Hi When code is calling the JPA it is throwing a runtime exception due to transaction manager problem. But Spring Integration is reporting as  org.springframework.expression.spel.SpelEvaluationException: EL1004E: Method call: Method processQuery(somepackage.ErrorMsgByErrorCodeQuery) cannot be found on type somepackage.QueryHandler . This is wrong, it is not using the message from payload to report correct problem, so it is causing lot of confusion and taking too much time to isolate the problem. Looking for a solution.","open","in: core,","ppjohnson","2020-07-21T04:31:20Z","2021-11-10T10:53:13Z"
"","25778","Add a PropertySource/Environment.getProperty interceptor ( != ConversionService )","Hey Team,  As a bunch of adopters we use Jasypt which provides a very handy way to decrypt marked properties (e.g. `foo=encoded(12b1412)`) given a decryptor bean.  Doing this from the outside forces Jasypt to decorate original property sources via a proxy or wrapper that might lose the original type. For instance `OriginLookup` from Spring Boot is lost in translation, also some optimizations, SystemEnvironment awareness etc.   Would it be possible to add an interceptor for property resolution so we can do this kind of post processing, and why not some metrics as well if needed (lookup counts) etc.","closed","in: core,","smaldini","2020-09-16T00:57:45Z","2022-06-07T11:05:31Z"
"","25816","RequestDispatcher forward not working with OncePerRequestFilter with Spring boot 2.3.* version but working fine till 2.2.10","Here the scenarios is -  Filter1 -> filter2 -> Filter3 -> Controller   If filter 1 - (condition == true ) then skip all filters and go to controller -  _request.getRequestDispatcher(request.getServletPath()).forward(request, response);_ else  go to next chain in filter _filterChain.doFilter(request, response);_  With spring-boot 2.3.* - Its not working as with condition-1, it always going in filter-chain but with spring-boot version till 2.2.10- its working as expected.  Please advise ?","closed","in: web,","nitinit","2020-09-25T08:18:38Z","2020-11-17T18:03:39Z"
"","25341","#25263 fiexed in 5.2X","Hello,I tried to fiexed [#25263](https://github.com/spring-projects/spring-framework/issues/25263),The test case is in **ImportedConfigurationClassEnhancementTests#checkOverloadedBean**,The test passed,It's in  the Spring-Context module,You can verify it. Regards  lifejwang11","closed","","lifejwang11","2020-06-30T08:57:50Z","2022-02-18T19:06:55Z"
"","25660","Improve performance of JdkDynamicAopProxy.getProxy(ClassLoader)","Hello, while profiling workload that creates lots of projections I've found out that about 33% of `ProxyFactory.getProxy()` are taken by `JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods`, see attachment: ![](https://habrastorage.org/webt/r3/q1/zm/r3q1zmv_r76citavesjdutzvmx8.png) The hot spot is here: ```java @Override public Object getProxy(@Nullable ClassLoader classLoader) { 	if (logger.isTraceEnabled()) { 		logger.trace(""Creating JDK dynamic proxy: "" + this.advised.getTargetSource()); 	} 	Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); 	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); 	return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); } ```  It looks like we don't need to call either `JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods`, or `AopProxyUtils.completeProxiedInterfaces()` at each invocation of `JdkDynamicAopProxy.getProxy`, because their results don't depend on `ClassLoader` argument and can be calculated only once at obejct construction time, also `advised` field is declared final.  Also related methods of `ReflectionUtils` could also be trivially improved.","closed","type: enhancement,","stsypanov","2020-08-28T20:38:00Z","2020-08-30T10:04:26Z"
"","25273","XML request body cannot be deserialised by Spring web 5 with javax.xml.bind.annotation","Hello, when upgrading SpringBoot from 1.x to 2.x, Restful apis which consumes xml as request body  are broken because values are deserialised to null.  API is like:   ```java @RequestMapping(             method = POST,             consumes = {APPLICATION_XML_VALUE, TEXT_XML_VALUE},             produces = {APPLICATION_XML_VALUE, TEXT_XML_VALUE})     Response postSomething(@ApiParam(name = ""Request"", value=""A valid  xml query"") @Valid @RequestBody **XmlRequest** xmlRequest); ```  `XmlRequest` used javax.xml.bind.annotation. Then I changed annotation to jackson-dataformat-xml, request body can be deserialised as before.  I don't find any report about javax xml problem. Does SpringBoot 2 have some limitation to use this package? Should XML deserialisation use jackson xml databinding? When I refactored the code, I find out jackson xml databing has less annotation and it works not well with polymorphic subtypes.  Thanks for your help.","closed","status: invalid,","quancheng-zhao","2020-06-17T10:32:39Z","2021-02-25T15:36:18Z"
"","24842","Avoid “No decoder for session id” Exception if session is closed","Hello, We using spring websocket in stomp for chatting in service. ( android, ios app connect to server with stomp, and then send/receive stomp messages. ) when we deploy stomp web server, throws exception when server reloading. ( intermittently occurs after server reloading. )  ``` ""java.lang.IllegalStateException: No decoder for session id 'e3d585e7-f176-362b-2b7a-9dbf8630cc82'  at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageFromClient(StompSubProtocolHandler.java:231)  at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:312)  at org.springframework.web.socket.handler.WebSocketHandlerDecorator.handleMessage(WebSocketHandlerDecorator.java:75) ```  I heard that this exception occurs the connection is closed by the server and spring drops the session and everything(decoder) associated with it. This exception occurs in spring library. so we can't anything to prevent this exception occurs.  I want know about how can we prevent to occur this exception when server deployed.  I thought some cases about send to ""DISCONNET"" message client.  1. server send ""DISCONNECT"" message to client with regiseterd session id when server drops. But in now, we don't know how can get connected session id in server. If we can get session id for all client connected in server, then we can do it. or if we can extend StompSubProtocolHandler and register custom StompSubProtocolHandler, then it can be done.  2. catch IllegalStateException and send to ""DISCONNET"" message client. This error occurs in library. If we register exception handler, then we seems to control it, but we can't know about session id in clent.","closed","type: task,","donggyu81","2020-04-02T02:59:52Z","2020-04-27T12:25:41Z"
"","25836","Request data binding fails for params with an empty array ""[]"" suffix","Hello, It seems like a bug.  org.sprinframework:spring-beans:5.2.8.RELEASE  We use filterDto in our controller.   ```kotlin data class FilteDto( var types: MutableList ) ```  But when we build our request like this `types[]=first_type&types[]=second_type`. Tokens keys in propertyTokenHolder are wrong. They are just one empty string """". And then we get such output Illegal request output.  We got such stacktrace.  ``` java.lang.NumberFormatException: For input string: """" 	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[na:na] 	at java.base/java.lang.Integer.parseInt(Integer.java:662) ~[na:na] 	at java.base/java.lang.Integer.parseInt(Integer.java:770) ~[na:na] 	at org.springframework.beans.AbstractNestablePropertyAccessor.processKeyedProperty(AbstractNestablePropertyAccessor.java:322) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:275) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:266) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:97) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.validation.DataBinder.applyPropertyValues(DataBinder.java:848) ~[spring-context-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.validation.DataBinder.doBind(DataBinder.java:744) ~[spring-context-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.web.bind.WebDataBinder.doBind(WebDataBinder.java:197) ~[spring-web-5.2.8.RELEASE.jar:5.2.8.RELEASE] ```  I think problem in `AbstractNestablePropertyAccessor`. In `getPropertyNameTokens`, see 928 line in `AbstractNestablePropertyAccessor`.  Maybe in this line.  ```java 	if (key.length() > 1 && (key.startsWith(""'"") && key.endsWith(""'"")) || 							(key.startsWith(""\"""") && key.endsWith(""\""""))) { 						key = key.substring(1, key.length() - 1); 					} 					keys.add(key); ```  P.S. When we search like this `types=first_type&types=second_type` all is fine.","closed","type: enhancement,","kostya05983","2020-09-29T08:50:23Z","2021-07-09T20:02:59Z"
"","25316","#23369","Hello, I build a fix for my Problem with SpEL and Proxy-Objects, described in #23369. Now I want to contribute my changes. Regards  Florian","open","in: core,","MrCoffee77","2020-06-25T11:42:20Z","2021-11-10T10:53:13Z"
"","25255","ServletServerContainerFactoryBean Stomp mode is invalid","Hello, The tomcat web container websocket buffer size limit is 8kb, Use ServletServerContainerFactoryBean can be adjusted to 64kb. But it does not support Stomp. I have searched various materials to modify the limit, but all failed. Please give me some guidance, thank you!   ```java  @Configuration public class MyServerContainerConfigurer{       @Bean       public ServletServerContainerFactoryBean createWebSocketContainer() {             ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();             container.setMaxTextMessageBufferSize(64*1024);             container.setMaxBinaryMessageBufferSize(64*1024);             return container;       } } ```  Effective in normal mode, as shown in the following example.  ```java @Configuration @EnableWebSocket public class MyWebSocketConfigurer implements WebSocketConfigurer {      @Override     public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {         registry.addHandler(new TextWebSocketHandler(),""/endpoint"").setAllowedOrigins(""*"");     } } ```  It is invalid in Stomp mode, Example of Stomp.  ```java @Configuration @EnableWebSocketMessageBroker public class MyWebSocketMessageBrokerConfigurer implements WebSocketMessageBrokerConfigurer {       @Override     public void registerStompEndpoints(StompEndpointRegistry registry) {         registry.addEndpoint(""/portfolio"").setAllowedOrigins(""*"");     }           @Override     public void configureMessageBroker(MessageBrokerRegistry config) {         config.setPathMatcher(new AntPathMatcher("".""));         config.setApplicationDestinationPrefixes(""/app"");         config.enableSimpleBroker(""/topic"", ""/queue"");     }           @Override     public void configureWebSocketTransport(WebSocketTransportRegistration webSocketTransportRegistration) {         webSocketTransportRegistration                 .setMessageSizeLimit(1024 * 1024)                 .setSendBufferSizeLimit(1024 * 1024 );      }   } ```  Error log  ```log 2020-06-16 13:45:51.226 DEBUG 11628 --- [nio-8080-exec-4] s.w.s.h.LoggingWebSocketHandlerDecorator : StandardWebSocketSession[id=c11461a9-8340-e006-dda9-cf50716694dd, uri=ws://localhost:8080/portfolio] closed with CloseStatus[code=1009, reason=No async message support and buffer too small. Buffer size: [8,192], Message size: [11,020]] ``` --------------------- SpringBoot  Version : 2.3.0","open","in: web,","liyiorg","2020-06-16T06:44:17Z","2021-11-10T11:43:10Z"
"","25190","UriComponentBuilder using unicode for ampersand (&)","Hello,  Spring version - 5.2.5  When I try to use `UriComponentsBuilder` with 2 query params the parameter separator(ampersand &) it's solved to unicode encoding.  something like:  http://my.url.com/info/xpto?param1=123u0026param2=123  should be:  http://my.url.com/info?param1=123¶m2=123  So the problem is the `u0026`.  Code:  ```java UriComponentsBuilder.fromHttpUrl(""http://my.url.com"")             .path(""/info"")             .query(""param1={p1}"")             .query(""param2={p2}"")             .buildAndExpand(123, 123).encode().toUri() ``` I also tried to use encode before buildAndExpand, but gives the same error.  It's a expected behavior ? or some config is missing ?","closed","","jleber","2020-06-05T06:45:53Z","2020-06-10T11:21:32Z"
"","25742","Pass the exception to the HandlerExecutionChain","Hello,  If an exception is thrown, it should be passed to the `HandlerExecutionChain` which in turn passed it to any existing `HandlerInterceptor` that can used it for any business logic inside `afterCompletion()` method.  In fact, when an exception is thrown and handled, the `afterCompletion()` method of the interceptor (aka. `HandlerInterceptorAdapter`) has no clue on that exception since the `DispatcherServlet` pass `null` even if there is an exception.  A business case that can use this exception is statistics or logging (mail, jms, ...).  Thank you.","closed","","omradouane","2020-09-08T17:50:54Z","2020-09-10T09:55:49Z"
"","25768","WebClient/MockMVC issue with jquery ajax post","Hello,  i am using htmlunit with spring test in order to test all ihm interface from my web application. It works fine with html form (post and get) and with ajax get but i have a problem with ajax post request.  The controller don't received the request. If i replace post by get the junit test case works fine.  this the html view  ```html   	 		Spring Html Unit          		 		 		 		 			function postTest() { 				$.ajax({ 			        type:""post"", 					data: { 						'subject' : 'subject test', 						'message' : 'message test' 					}, 			        url:""[[@{/test/post}]]"", 			        success: function(data, textStatus, jqXHR){ 			        	$(""#result"").text(data); 			        } 			    }); 			}		 		 	 	 		Hello from Thymeleaf 		 		Test post 		 			result : 		 		 	  ```  and the controller  ```java @Controller public class WelcomeController {  	@GetMapping(""/"") 	public String init(Model model) { 		model.addAttribute(""myParam"", ""Guillaume""); 		return ""welcome""; 	}  	@PostMapping(""/test/post"") 	public @ResponseBody String post(@RequestParam String subject, @RequestParam String message, Model model) { 		return subject + "" "" + message; 	} } ```  you can also find the complete code on my github https://github.com/guisimon28/spring-test-htmlunit  Can you help me to find if there is some missing configuration or if its a htmlunig bug or pull request ?  Thanks for All  Guillaume","closed","status: invalid,","guisimon28","2020-09-14T17:05:22Z","2020-10-23T11:53:10Z"
"","24928","Partial autowire in lookup methods","Hello,  I am trying to follow Domain-Driven Design paradigm in my Spring projects. For it I am using prototype beans quiet extensively. Often I meet the situation, when for prototype initialization I require both runtime and singleton parameters, for example, if bean is supposed to represent some database entity it initializes with its ID and some database service during.  There are several ways to create beans in Spring, however, I find that `@Lookup` methods is the most convenient way to create prototype beans. However, now they can either try to find all bean dependencies in context and autowire them or all parameters should be provided to them explicitly. So, to create bean with both runtime and singleton parameters all singletons should present in the scope of caller of `@Lookup` method. This is very inconvenient and leads to abstraction leaks.  Please see https://github.com/gzoom13/spring-lookup-enhancement. Here I reproduce the issue.  #24530 should was created to fix that. I am sorry for creating issue with existing PR, but latter is not reviewed for 2 months already. Specified reproducer project above build just fine with these changes.","open","in: core,","gzoom13","2020-04-18T08:25:05Z","2021-11-10T11:58:06Z"
"","25120","Spring Data Page with Gson","Hello,  After changing from jackson: `spring.http.converters.preferred-json-mapper=jackson` to gson: `spring.http.converters.preferred-json-mapper=gson`  The endpoint below stopped working and started to return `{}` ```java @GetMapping @ApiPageable public Page getFoobaz() {     return service.getFoobaz(); } ```  The endpoint only works if I add the annotation below: ```java @Configuration @EnableWebMvc /*","open","in: web,","gustavotemple","2020-05-22T23:24:06Z","2021-11-12T12:10:33Z"
"","25325","JDK 11 build. Tests failed. Windows 10.","Hello! I want build SpringFramework with OpenJDK11.  My configuration:   openjdk version ""11"" 2018-09-25 OpenJDK Runtime Environment 18.9 (build 11+28) OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)  Windows 10.  I try to build branch 5.2.x.. I use command gradlew build and i have problem.  > Execution failed for task ':spring-aop:test'. > There were failing tests. See the report at: file:///xxx/spring-framework/spring-aop/build/reports/tests/test/index.html  > Execution failed for task ':spring-aop:test'. > There were failing tests. See the report at: file:///xxx/spring-framework/spring-aop/build/reports/tests/test/index.html  In report file i have a lot of exceptions like this: 1tests | 1failures  `org.gradle.api.internal.tasks.testing.TestSuiteExecutionException: Could not execute test class 'org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests'. 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:53) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:118) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:412) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 	at java.base/java.lang.Thread.run(Thread.java:834) Caused by: org.gradle.internal.UncheckedException: java.lang.ClassNotFoundException: org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests 	at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:67) 	at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:41) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.loadClass(JUnitPlatformTestClassProcessor.java:115) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.access$100(JUnitPlatformTestClassProcessor.java:57) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.execute(JUnitPlatformTestClassProcessor.java:92) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.execute(JUnitPlatformTestClassProcessor.java:82) 	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51) 	... 25 more Caused by: java.lang.ClassNotFoundException: org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:582) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	at java.base/java.lang.Class.forName0(Native Method) 	at java.base/java.lang.Class.forName(Class.java:398) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.loadClass(JUnitPlatformTestClassProcessor.java:113) 	... 30 more`   If i use command gradlew build -x test i have the same exceptions in spring-test module. If i use commend gradlew build -x test -x junit -x testNG i don't have exceptions.  If i use jdk 8 i don't have problems.  Is it possible to build spring-framework with jdk 11+? I will be glad to any answers.","closed","status: invalid,","belyaev-alexey","2020-06-27T16:02:24Z","2020-06-28T15:50:12Z"
"","24997","Jep 321 in RestTemplate","Hello! Can you say when restTemplate will be able work with new HttpClient in Java (Jep 321). Now I see only SimpleClientHttpRequestFactory that use old Java HttpClient (HttpURLConnection). Is a new ClientHttpRequestFactory implementation planned?","closed","status: declined,","fink-artem","2020-04-30T11:55:09Z","2020-04-30T13:01:08Z"
"","25618","Regression in SimpleThreadScope introduced in 5.2.7","Hello people  I updated today to spring 5.2.8.RELEASE and started to give error in my mock session for JUNIT   ``` java.lang.IllegalStateException: Failed to load ApplicationContext  	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) 	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:123) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:118) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) 	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329) 	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293) 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:413) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53) Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'testeEmissorLoginBean': Unsatisfied dependency expressed through field 'bean'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'loginEmissorBean': Unsatisfied dependency expressed through field 'credencial'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'credencialBean' defined in class path resource [spring-junit.xml]: Initialization of bean failed; nested exception is java.util.ConcurrentModificationException 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:893) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:879) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:128) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:275) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:243) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) 	... 25 more Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'loginEmissorBean': Unsatisfied dependency expressed through field 'credencial'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'credencialBean' defined in class path resource [spring-junit.xml]: Initialization of bean failed; nested exception is java.util.ConcurrentModificationException 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:643) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1422) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$1(AbstractBeanFactory.java:359) 	at org.springframework.context.support.SimpleThreadScope.lambda$get$0(SimpleThreadScope.java:70) 	at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1133) 	at org.springframework.context.support.SimpleThreadScope.get(SimpleThreadScope.java:70) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:356) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1304) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1224) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) 	... 43 more Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'credencialBean' defined in class path resource [spring-junit.xml]: Initialization of bean failed; nested exception is java.util.ConcurrentModificationException 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:603) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:226) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1304) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1224) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) 	... 58 more Caused by: java.util.ConcurrentModificationException 	at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134) 	at org.springframework.context.support.SimpleThreadScope.get(SimpleThreadScope.java:70) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:356) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:330) 	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:113) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1699) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	... 67 more ```   My tdd uses the following configuration:  ```xml                                                                                                              ```  in version 5.2.6.RELEASE backwards works without error. Could someone help me how to get around this? Regards","closed","in: core,","FernandoFranzini","2020-08-20T15:58:07Z","2020-08-24T01:26:39Z"
"","25274","How to accept Illegal character in query string with ServletHttpHandlerAdapter","Hello all,  For legacy reasons in my project based on spring boot 2.2.5 and spring cloud Hoxton.SR4, we should accept non URL encoded character ""|"" in query string. We had set the ""server.tomcat.relaxed-query-chars=|"" in order to let coyotte connector accept this non URL encode character.  But I am facing an issue with ServletHttpHandlerAdapter -> Failed to get request  URL: Illegal character in query  How can I deal with illegal caracters in ServletHttpHandlerAdapter like the server.tomcat.relaxed-query-chars do? Thank's","open","in: web,","et00448","2020-06-18T08:42:27Z","2021-11-12T12:09:02Z"
"","25787","Use Gradle Toolchains for JVM projects to test on unsupported JDK versions","Gradle 6.7 will introduce built-in support for [Toolchains for JVM projects](https://docs.gradle.org/6.7-rc-1/userguide/toolchains.html).  Once we upgrade to Gradle 6.7, we will should hopefully be able to replace the functionality in [`custom-java-home.gradle`](https://github.com/spring-projects/spring-framework/blob/master/gradle/custom-java-home.gradle) with the new built-in support.  Note from the Gradle team:  > Toolchains and `*Compatibility`: the moment you use toolchain at the project level, `sourceCompatibility` and `targetCompatibility` from the project have a value derived from the toolchain. What you cannot do is overwrite that value. You can still overwrite it at the task level though.","closed","type: task,","sbrannen","2020-09-18T13:50:22Z","2021-03-15T13:58:14Z"
"","25578","Upgrade to Gradle 6.6","Gradle 6.6 has been [released](https://docs.gradle.org/6.6/release-notes.html).","closed","type: dependency-upgrade,","sbrannen","2020-08-11T10:04:23Z","2020-08-11T10:15:47Z"
"","25180","Upgrade to Gradle 6.5","Gradle 6.5 has been [released](https://docs.gradle.org/6.5/release-notes.html).","closed","type: dependency-upgrade,","sbrannen","2020-06-03T12:08:52Z","2020-06-03T13:06:53Z"
"","25020","Upgrade to Gradle 6.4","Gradle 6.4 has been [released](https://docs.gradle.org/6.4/release-notes.html).","closed","type: dependency-upgrade,","sbrannen","2020-05-06T11:56:20Z","2020-06-03T12:08:41Z"
"","25285","RSocket Input/Output cardinality not being handled correctly (FNF not working)","Given the following sample:  ```java @MessageMapping(""fire-and-forget.{identifier}"") public Mono fireAndForget(@DestinationVariable String identifier) {    log.info(""Fire-and-forget is correctly being invoked with identifier: {}"", identifier);    return Mono.empty(); } ```  I would expect to invoke this as a Fire-and-forget interaction, e.g: _Following 2 examples uses the RSocket Client CLI: https://github.com/making/rsc_  > java -jar rsc.jar --debug **--fnf** --route fire-and-forget.foo-bar tcp://localhost:7000  However nothing seems to happen, if I change it to a Request/response interaction instead, a log message is being written in my console output. > java -jar rsc.jar --debug **--request** --route fire-and-forget.foo-bar tcp://localhost:7000  ``` 2020-06-19 14:09:46.805  INFO 26120 --- [ctor-http-nio-4] c.e.r.RSocketController                  : Fire-and-forget is correctly being invoked with identifier: foo-bar ```  For a full sample, checkout my code sample at https://github.com/dnijssen/rsocket-fire-and-forget  and look at the RSocketController","closed","for: external-project,","dnijssen","2020-06-19T12:25:17Z","2020-06-23T04:40:01Z"
"","25532","TransactionAspectSupport fails to select reactive transaction manager when both transaction manager variants are present","Given a transactional, reactive service:  ```java @Service static public class S { 	@Transactional 	public Flux something() { 		return Flux.just(""foobar""); 	} } ```  and two transaction managers in the context, one being an instance of `AbstractPlatformTransactionManager` and one `AbstractReactiveTransactionManager`, the service should use the reactive transaction manager as indicated by the return type.  However, the `TransactionAspectSupport` fails to determine the correct one to use.  In `determineTransactionManager` it ultimately asks the `beanFactory` for an instance of `TransactionManager`, which fails with a `org.springframework.beans.factory.NoUniqueBeanDefinitionException`.   A workaround would be specifying which tx manager to use on the annotation or to provide a configured like this  ```java @Component static class F implements TransactionManagementConfigurer {  	private final ReactiveTransactionManager reactiveTransactionManager;  	public F(ReactiveTransactionManager reactiveTransactionManager) { 		this.reactiveTransactionManager = reactiveTransactionManager; 	}  	@Override 	public TransactionManager annotationDrivenTransactionManager() { 		return reactiveTransactionManager; 	} } ```  but that would be contra intuitive compared to how this is solved with Spring Data repositories.  Having two very distinguishable transaction managers on the context will be the case with the upcoming changes in Spring Boot 2.4 and Spring Data Neo4j 6: It will bring an imperative and a reactive one, thus leading to problems described here.  @mp911de and I hope for respectively suggest a change in the `TransactionAspectSupport` so that it tries to determine the need for a reactive transaction manager before actually determining one and use the information - if available - to narrow down the selection of the transaction manager in cases where none is configured otherwise.","closed","type: enhancement,","michael-simons","2020-08-05T10:14:56Z","2021-01-23T12:17:25Z"
"","25248","Cache abstraction does not log hit / miss for synchronized access","General logging of hit / miss has been added in #16277. For synchronized cache contexts (`@Cacheable(sync=true)`), no logging happens yet. It's also not that straightforward, since in that case the mapping function will be passed directly to the Cache implementation (e.g. Caffeine) and Spring has no knowledge about if the mapper function has been called or if the returned value has been retrieved from the cache.  What we can do? I would propose to decorate the mapping function with an ""invoked"" flag (which will tell if the function has been invoked by the cache implementation) and with a logging for the ""miss"" case. The logging directly inside the function is necessary because we want to log misses _before_ invocation of the underlying mapper function. The flag ""invoked"" is necessary to recognize the ""hit"" case (we can only definitely say that _after_ the value has been returned from the cache implementation).  Here is the place in the code:  https://github.com/spring-projects/spring-framework/blob/1279b3b8229d67585aae02038ba0325e25b6f2ad/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java#L377-L384  The line `return wrapCacheValue(method, cache.get(key, () -> unwrapReturnValue(invokeOperation(invoker))));` could be changed to something like that:  ```java boolean[] invoked = new boolean[1]; Object returnValue = wrapCacheValue(method, cache.get(key, () -> {     invoked[0] = true; // cache miss; log ""miss"" *before* calling the underlying mapper function     if (logger.isTraceEnabled()) {         logger.trace(""No cache entry for key '"" + key + ""' in cache "" + cache.getName());     }     unwrapReturnValue(invokeOperation(invoker))); }); if (!invoked[0]) { // cache hit; log ""hit"" after retrieving the value from the cache     if (logger.isTraceEnabled()) {         logger.trace(""Cache entry for key '"" + key + ""' found in cache '"" + cache.getName() + ""'"");     } } return returnValue; ```  What do you think? Perhaps any easier solution possible?","closed","type: enhancement,","elab","2020-06-13T10:41:01Z","2020-09-02T09:31:04Z"
"","25067","Document whether code can rely on specific subclasses of HttpClientErrorException/HttpServerErrorException being thrown from DefaultResponseErrorHandler","From perusing the code, I discovered that `DefaultResponseErrorHandler` will throw subclasses of `HttpClientErrorException`/`HttpServerErrorException`, created by [`HttpClientErrorException.create()`](https://docs.spring.io/spring/docs/5.2.3.RELEASE/javadoc-api/org/springframework/web/client/HttpClientErrorException.html#create-org.springframework.http.HttpStatus-java.lang.String-org.springframework.http.HttpHeaders-byte:A-java.nio.charset.Charset-)/[`HttpServerErrorException.create()`](https://docs.spring.io/spring/docs/5.2.3.RELEASE/javadoc-api/org/springframework/web/client/HttpServerErrorException.html#create-org.springframework.http.HttpStatus-java.lang.String-org.springframework.http.HttpHeaders-byte:A-java.nio.charset.Charset-).  For instance, if the request returned a 404 error, a `HttpClientErrorException.NotFound` exception will be thrown.  That said, I don't see any documentation indicating that the subclass is what will be thrown, rather than a the superclass `HttpClientErrorException`.  I assume that it is intended that I can rely on this subclass being thrown, so I can write code like the following:  ``` try {     return restTemplate.getForObject(url, MyType.class); } catch (HttpClientErrorException.NotFound e) {     // Do something specific to 404 } catch (HttpClientErrorException e) {     // Handle other client errors } ```  instead of the clunkier:  ``` try {     return restTemplate.getForObject(url, MyType.class); } catch (HttpClientErrorException e) {     if (HttpStatus.NOT_FOUND.equals(e.getStatusCode())) {         // Do something specific to 404     } else {         // Handle other client errors     } } ```  It would be useful if it were documented that a consumer of the `RestTemplate`/`DefaultResponseErrorHandler` can rely on these specific subclasses being thrown.  This documentation could live in either or both the `DefaultResponseErrorHandler` Javadocs or the general Spring documentation.  The closest the current documentation comes to this is in the method Javadocs for [`DefaultResponseErrorHandler.handleError(response, statusCode)`](https://docs.spring.io/spring/docs/5.2.3.RELEASE/javadoc-api/org/springframework/web/client/DefaultResponseErrorHandler.html#handleError-org.springframework.http.client.ClientHttpResponse-org.springframework.http.HttpStatus-).  But all that states is that it will throw `HttpClientErrorException` or `HttpServerErrorException`, not that it will throw the appropriate subclass if it exists.  It has a ""See also"" section to the code that creates the subclasses, but that doesn't tell the user that it will be calling that, merely that the given code is related in some way.  > The default implementation throws an HttpClientErrorException if the status code is CLIENT_ERROR, an HttpServerErrorException if it is SERVER_ERROR, or an UnknownHttpStatusCodeException in other cases. > > **See Also:** > HttpClientErrorException.create(org.springframework.http.HttpStatus, java.lang.String, org.springframework.http.HttpHeaders, byte[], java.nio.charset.Charset), HttpServerErrorException.create(org.springframework.http.HttpStatus, java.lang.String, org.springframework.http.HttpHeaders, byte[], java.nio.charset.Charset)","closed","in: web,","mjustin","2020-05-13T18:12:24Z","2020-05-24T20:26:58Z"
"","24955","Assissted constructor injection is not working - in contrary to what javadoc says","From javadoc of `org.springframework.beans.factory.support.ConstructorResolver#autowireConstructor`:  > ""autowire constructor"" (with constructor arguments by type) behavior. Also applied if explicit constructor argument values are specified, matching all remaining arguments with beans from the bean factory.  So having that in mind I would expect that constructor injection would work with some of arguments injected and some provided, but it fails - reproduction code  ```java @RunWith(SpringRunner.class) @ContextConfiguration(classes = {AssistedInjectionFails.B.class, AssistedInjectionFails.C.class}) public class AssistedInjectionFails {      public static class A {     }      @Component     public static class B {     }      @Component     @Scope(""prototype"")     public static class C {         private final A a;         private final B b;          @Autowired         public C(A a, B b) {             this.a = a;             this.b = b;         }     }      @Autowired     private ApplicationContext context;      @Test     public void test() {         C c = context.getBean(C.class, new A());     } } ```  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'assistedInjectionFails.C': Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities) ```","open","in: core,","Antoniossss","2020-04-22T09:25:38Z","2020-04-22T12:12:01Z"
"","25383","Support alias for property name in web data binding","For the class  ```java class Request {          private String ftr;     // more properties } ```  And the method in controller class  ```java @GetMapping public String list(@Valid Request request) {     //... } ```  When I send a request to the method the url is `https://example.com?ftr=sms`  Is it possible to have an alias to a query parameter like in the class  ```java class Request {          @QueryParameter(name=""ftr"")     private String filter;     // ... } ```  And to map same request URL to this class?","closed","in: web,","gitterhh","2020-07-12T13:35:44Z","2021-01-18T14:55:25Z"
"","24923","change default Charset to UTF_8","for internationalization @pivotal-issuemaster This is an Obvious Fix","closed","status: declined,","wordfeng","2020-04-17T08:20:00Z","2020-04-17T08:36:40Z"
"","25667","Avoid full singleton lock for DefaultSingletonBeanRegistry.getSingleton(beanName, false)","Following up on the latest comments in #13117, `DefaultSingletonBeanRegistry.getSingleton(beanName, false)` seems to have a specific issue when called from `isSingleton` and `isTypeMatch` checks in `AbstractBeanFactory`: When `isSingletonCurrentlyInCreation` returns `true`, we're trying to enter the global lock for an early singleton exposure check... even if we're not allowed to create early references, so only able to check for an existing early reference. By turning `earlySingletonObjects` into a `ConcurrentHashMap` and separating that early reference existence check from the creation of early references (which needs to happen within the global lock), we could potentially address a whole range of issues for lookup attempts in concurrent singleton creation scenarios.","closed","type: enhancement,","jhoeller","2020-08-31T15:15:58Z","2020-09-03T22:42:21Z"
"","25402","Clarify enforceInitMethod/enforceDestroyMethod default values in AbstractBeanDefinition","Following up on #25318, the javadoc for `setEnforceInitMethod` and `setEnforceDestroyMethod` is misleading since the actual default value is dependent on whether the init/destroy method name was locally specified or coming from a defaults section.","closed","in: core,","jhoeller","2020-07-17T10:21:16Z","2020-07-17T16:00:51Z"
"","25830","Fixes #25829 by changing the check away from instanceof. Now checking…","Fixes #25829 by changing the check away from instanceof. Now checking…… if the request has parts. If this is the case we extract them otherwise use getFile(). Test is added for verification.","closed","in: web,","JWThewes","2020-09-28T20:27:19Z","2022-02-18T19:06:29Z"
"","24962","Make imported config always override the one found by package scan","Fixes #24643  **Current state**  Whether imported user config class will override a scanned one depends on its names. Unit test which is reproducing it:  `ImportTests#importedConfigOverridesScannedOne`  During nested configs processing (`ConfigurationClassParser#processMemberClasses`), all nested configs are being overridden by its scanned version loosing `importedBy` information. This is not intended behavior according to the documentation of import feature. But this accidentally made it work, because otherwise the config would have been registered twice: first by package scan, then by `ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass`.   Unit test which is reproducing it: `ComponentScanAnnotationIntegrationTests#viaContextRegistration_WithComposedAnnotation`  **Fixed version**  Change in `ConfigurationClassParser` is needed to make imported configs always override the scanned ones, preserving `importedBy` info. Due to preserving `importedBy` I had to change `ConfigurationClassBeanDefinitionReader` as well, which registers imported configs, but it did not expect that it could have been already registered (during package scanning). I used `AnnotationBeanNameGenerator` for naming to make it 100% backward compatible by preserving configs bean names.","open","in: core,","encircled","2020-04-23T10:03:19Z","2021-11-11T09:26:57Z"
"","24897","Fixed typos","Fixed minor typos in the documentation. Note: if it really was intended to set country to age (?) then my mistake.","closed","","brianhartung","2020-04-11T11:58:04Z","2020-04-14T10:56:19Z"
"","24921","Fix Javadoc link in DefaultCorsProcessor","Fixed a Javadoc link in DefaultCorsProcessor.  The Javadoc of `DefaultCorsProcessor#checkMethods` mistakenly pointed to `CorsConfiguration#checkOrigin` instead of `CorsConfiguration#checkHttpMethod`.","closed","type: task,","ollide","2020-04-16T19:45:50Z","2020-04-17T07:26:59Z"
"","24896","Fixed typos","Fixed a couple of minor documentation typos","closed","type: task,","brianhartung","2020-04-11T11:24:56Z","2020-04-15T16:36:34Z"
"","25458","Fix typos in Javadoc","fix typo(an sql)","closed","type: task,","sgc109","2020-07-22T08:11:47Z","2020-07-22T08:18:47Z"
"","25016","Support for pattern based origin cors configuration","Fix https://github.com/spring-projects/spring-framework/issues/24763  I have modified `CorsConfiguration` to support pattern based origins.  Obviously that can be done in a different ways, like using somehing else instead of standard java `Pattern` or creating a new delegate`PatternCorsConfiguration` instead of modifying existing one, so please let me know if the approach I've chosen is not the most suitable.","closed","type: enhancement,","korektur","2020-05-05T14:10:14Z","2021-10-27T07:39:16Z"
"","25062","Reduce unnecessary loops in PostProcessorRegistrationDelegate","Fix for #25061","closed","in: core,","diguage","2020-05-13T06:40:11Z","2020-12-30T16:59:51Z"
"","24967","Add KClass variant to Coroutines web API","Extend API - add ability to work with Kotlin Coroutines and generic deserialization.","closed","in: web,","imanushin","2020-04-24T21:33:27Z","2020-09-25T09:35:05Z"
"","25284","Improve Javadoc for @Value regarding supported expressions","Excerpt from the Javadoc for `@Value`:  ```java public @interface Value {  	/** 	 * The actual value expression: for example {@code #{systemProperties.myProp}}. 	 */ 	String value();  } ```  The actual value expression should be `${systemProperties.myProp}`, using `$` instead of `#`.","closed","in: core,","pxm7459","2020-06-19T09:32:22Z","2020-06-19T12:43:18Z"
"","25339","spring.mvc.servlet.path config  cause something  strange","Environment:  - Spring 2.3.0.RELEASE  - JDK 1.8  Steps to reproduce：  - Add `spring.mvc.servlet.path=/test` in application.properties.  - Define Controller,use `@RestController` in controller class,    then use `@GetMapping(""/test"")` at one method,    finally,use `@GetMapping(""/test1"")` at other method.  - start project,visit urls that I want to test.  I expect that:  - I visit http://localhost:8080/test/test, I got result.  - I visit http://localhost:8080/test/test1, I got result too.  - I visit http://localhost:8080/test, HTTP ERROR 404  - I visit http://localhost:8080/test1, HTTP ERROR 404  Actually：  - I visit http://localhost:8080/test/test, I got result.  - I visit http://localhost:8080/test/test1, I got result too.  - I visit http://localhost:8080/test, I got result.**It confused me！**  - I visit http://localhost:8080/test1, HTTP ERROR 404  In fact,I find that `WebFlux` use `spring.webflux.base-path=/test` has some problems  This is link of My demo: [https://github.com/DogeC0in/BugFinder](https://github.com/DogeC0in/BugFinder)","closed","status: duplicate,","DogeC0in","2020-06-30T08:55:32Z","2020-06-30T12:40:51Z"
"","25748","Error build spring-oxm by executing ""gradlew.bat :spring-oxm:check"" after executing task ""gradlew.bat""","Env: OS: win10(10.0.18362.1082 showed by cmd) jdk: jdk1.8.0_261(oracle jdk 64bit) gradle: 6.6.1 After I download the source code by git clone, then I use cmd, switch to the root dir of spring-framework-5.2.8, I execute ""gradlew.bat"", everything is right(BUILD SUCCESSFUL), and the next step(followed the file import-into-eclipse.md), I go to build spring-oxm by command **""gradlew.bat :spring-oxm:check""**, and it shows BUILD FAILED(Task :spring-core:compileJava FAILED), **the main error is that ""程序包jdk.jfr不存在"", it means ""package jdk.jfr does not exist""**, the full error is followed: E:\git\spring-framework-5.2.8>gradlew.bat :spring-oxm:check  > Task :spring-core:compileJava E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:19: 错误: 程序包jdk.jfr不存在 import jdk.jfr.Category;               ^ E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:20: 错误: 程序包jdk.jfr不存在 import jdk.jfr.Description;               ^ E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:21: 错误: 程序包jdk.jfr不存在 import jdk.jfr.Event;               ^ E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:22: 错误: 程序包jdk.jfr不存在 import jdk.jfr.Label;               ^ E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:37: 错误: 找不到符号 class FlightRecorderStartupEvent extends Event {                                          ^   符号: 类 Event E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:34: 错误: 找不到符号 @Category(""Spring Application"")  ^   符号: 类 Category E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:35: 错误: 找不到符号 @Label(""Startup Step"")  ^   符号: 类 Label E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:36: 错误: 找不到符号 @Description(""Spring Application Startup"")  ^   符号: 类 Description E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:43: 错误: 找不到符号         @Label(""Name"")          ^   符号:   类 Label   位置: 类 FlightRecorderStartupEvent E:\git\spring-framework-5.2.8\spring-core\src\main\java\org\springframework\core\metrics\jfr\FlightRecorderStartupEvent.java:46: 错误: 找不到符号         @Label(""Tags"")          ^   符号:   类 Label   位置: 类 FlightRecorderStartupEvent  > Task :spring-core:compileJava FAILED  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-core:compileJava'. > Compilation failed; see the compiler error output for details.  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0. Use '--warning-mode all' to show the individual deprecation warnings. See https://docs.gradle.org/6.6/userguide/command_line_interface.html#sec:command_line_warnings  BUILD FAILED in 10s 20 actionable tasks: 3 executed, 17 up-to-date  ------- What should I do?","closed","status: invalid,","xiao911wei","2020-09-10T03:10:46Z","2020-09-11T09:30:40Z"
"","25232","Wrap ternary operator within parentheses as outlined in Code Style","enhancement readability about ternary operator","closed","type: task,","lee-garden","2020-06-10T16:41:46Z","2020-06-11T13:33:59Z"
"","25734","Redundant code in PostProcessorRegistrationDelegate that reduces performance","English: In PostProcessorRegistrationDelegate invokeBeanFactoryPostProcessors method, after the first phase of the spring BeanFactoryPostProcessor, appeared with orderedPostProcessorNames and PostProcessorName nonOrderedPostProcessorNames records, After iterating to get its BeanFactoryPostProcessor, a total of 4 LIst result sets and 2 loops can be used to process it with 2 LIst result sets to improve performance!  Chinese: 在PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法中，执行完第一阶段的BeanFactoryPostProcessor，出现了用orderedPostProcessorNames和nonOrderedPostProcessorNames记录PostProcessorName，后面遍历获取其BeanFactoryPostProcessor，总共用了4个LIst结果集和2次循环，可以使用2次List结果集对其进行处理，提高性能！  Specific code： ```java code 		List priorityOrderedPostProcessors = new ArrayList(); 		List orderedPostProcessorNames = new ArrayList(); 		List nonOrderedPostProcessorNames = new ArrayList(); 		for (String ppName : postProcessorNames) { 			if (processedBeans.contains(ppName)) { 				// skip - already processed in first phase above 			} 			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); 			} 			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { 				orderedPostProcessorNames.add(ppName); 			} 			else { 				nonOrderedPostProcessorNames.add(ppName); 			} 		}  		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. 		sortPostProcessors(priorityOrderedPostProcessors, beanFactory); 		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);  		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.                // first loop 		List orderedPostProcessors = new ArrayList(orderedPostProcessorNames.size()); 		for (String postProcessorName : orderedPostProcessorNames) { 			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); 		} 		sortPostProcessors(orderedPostProcessors, beanFactory); 		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);  		// Finally, invoke all other BeanFactoryPostProcessors.                // second loop 		List nonOrderedPostProcessors = new ArrayList(nonOrderedPostProcessorNames.size()); 		for (String postProcessorName : nonOrderedPostProcessorNames) { 			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); 		} 		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); ```","closed","in: core,","Cw404","2020-09-08T06:58:25Z","2020-12-30T14:57:05Z"
"","25671","Improve PathResourceResolverTests to remove the last occurrence of 'springframework'","English is not my native language, please excuse typing errors. I build spring-framework source code locally. When I execute 'gradlew build' command, it shows test case failed. I found it because my code path contain a fragment 'springframework', and I think put source code in a path contain 'springframework' is pretty normal, so I fixed this by use a regular expression.","closed","type: task,","genie2014","2020-09-01T04:11:25Z","2020-09-13T20:32:01Z"
"","25646","Fix appendix typos in ContentDisposition","Encountered a few minor typos here while working on some changes.","closed","type: task,","kashike","2020-08-26T08:29:40Z","2020-08-26T10:33:29Z"
"","25533","Upgrade Hibernate support baseline to 5.2+","Driven by backlog requests (such as upgrading the dialects #22326) and a recent desire to expose `SessionFactory` and `Session` as the extended JPA interfaces in `HibernateJpaVendorAdapter` (since the older interfaces are deprecated as of Hibernate 5.2), we'll upgrade the baseline to Hibernate ORM 5.2+ for Spring Framework 5.3. This allows for cleaning up a lot of reflective code, in particular in `HibernateTemplate`, as well as streamlining our Hibernate/JPA resource unification (started in #21540).  Since JBoss EAP 7.2 upgraded to JPA 2.2 and Hibernate ORM 5.3 in January 2019, with even JBoss EAP 7.3 (still on Hibernate ORM 5.3.x) out in the meantime, this should also be acceptable for Spring usage on JBoss (which previously forced us to retain Hibernate ORM 5.1.x support). For Spring Boot purposes, we'll keep focusing on the Hibernate ORM 5.4.x line. For strict JPA 2.1 compatibility, the only Hibernate generation that remains fully supported by Spring is the Hibernate ORM 5.2.x line.  Note that Spring JPA setups may always choose **not** to use `HibernateJpaVendorAdapter` in which case any Hibernate version can be used. Our official baseline only applies to `HibernateJpaVendorAdapter` and to the native `orm.hibernate5` support package; beyond that, it also indicates our support range for Spring Framework 5.3.x's extended maintenance period.","closed","type: task,","jhoeller","2020-08-05T10:59:06Z","2020-10-13T13:02:47Z"
"","24871","Honor overridden AcceptHeaderLocaleContextResolver.getDefaultLocale()","Don't access the `defaultLocale` field directly, but use the getter method, so it can be overridden.  The sibling class `org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver` already uses the getter.","closed","type: enhancement,","larsgrefer","2020-04-06T14:12:45Z","2020-04-09T09:37:51Z"
"","25104","Fix for Sonartype vulnerability CVE-2016-1000027 in Spring-web project","Do we have fix for Sonartype vulnerability CVE-2016-1000027 in Spring-web project in any of the latest version of Spring-web jar?","closed","for: stackoverflow,","gituserjava","2020-05-19T11:31:34Z","2021-03-30T12:23:23Z"
"","25275","Revisit ScriptUtils and related classes in spring-r2dbc","Determine if common functionality for script parsing and execution can be extracted from `spring-jdbc` (package `org.springframework.jdbc.datasource.init`) and `spring-r2dbc` (package `org.springframework.r2dbc.connection.init`).  See related discussions in #25065.","closed","in: data,","sbrannen","2020-06-18T12:11:22Z","2020-10-27T10:53:56Z"
"","25428","Defer creating logger in StandardWebSocketHandlerAdapter","Defer creating logger for StandardWebSocketHandlerAdapter to avoid early log4j2 initializing  Fix https://github.com/spring-projects/spring-framework/issues/25427","closed","type: enhancement,","quaff","2020-07-20T08:03:45Z","2020-07-20T13:51:31Z"
"","24878","Collect metrics during application context startup","Debugging issues about slow application startup times or even figuring out the sequence of events during the application context startup can be challenging.  This issue is about providing a low-cost, safe and metadata-rich strategy to collect metrics during the application context startup. This should be opt-in only and have little to no cost when disabled.  Collected data and metrics should help to:  * have a better understanding of the application context startup process * identify problematic infrastructure components (like beans taking a lot of time or resources during `@PostConstruct` processing, creating beans that should have been guarded with conditions, etc).","closed","type: enhancement,","bclozel","2020-04-07T16:49:13Z","2020-07-27T21:20:36Z"
"","24882","Provide programmatical means to get beans of type in order","Currently, the _Spring Framework_ API (e.g. `ListableBeanFactory`) provides no programmatic means to acquire beans in order.  It is possible, however, to acquire beans in order, for beans in/directly annotated with the `@Order` annotation or beans in/directly implementing the `Ordered` interface, using dependency injection (DI) with the `@Autowired` or `@Resource` annotations.  For example, given the following bean classes...  ````java class SomeBean { ... }  class X extends SomeBean implements Ordered {    @Override   public int getOrder() {     return -1; }  @Order(-2) class Y extends SomeBean { }  class Z extends ZeroOrderedBean { }  @Order(0) abstract class ZeroOrderedBean extends SomeBean { } ````  And configuration...  ````java @Configuration class MyConfiguration {    @Bean(""A"")   @Order(3)   SomeBean a() {     return  new SomeBean();   }    @Bean(""B"")   @Order(1)   SomeBean b() {     return new SomeBean();   }    @Bean(""C"")   @Order(2)   SomeBean c() {     return new SomeBean();   }    @Bean(""D"")   @Order(4)   SomeBean d() {     return new SomeBean();   }    @Bean(""U"")   SomeBean unorderedBean() {     return new SomeBean();   }    @Bean(""X"")   X x() {     return new X();   }    @Bean(""Y"")   Y y() {     return new Y();   }    @Bean(""Z"")   Z z() {     return new Z();   } } ````  Then, an application component can inject an array or List of `SomeBean` in order, like so...  ````java @Component class MyApplicationComponent {    @Autowired   SomeBean[] someBeans;    ... } ````  All `SomeBean` objects will be added to the array in the following order: `Y, X, Z, B, C, A, D, U`.  This is aptly documented and described in the `Order` annotation [Javadoc](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/Order.html).  However, as a developer, if I wanted to acquire the beans using some programmatic means in the same order, this is not possible via the API (e.g. such as `ListableBeanFactory.getBeansOfType(..)`), AFAIK.    [`ListableBeanFactory.getBeansOfType(..)`](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html#getBeansOfType-java.lang.Class-boolean-boolean-) returns beans in bean definition declaration order as far as possible, as described in the [Javadoc](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html#getBeansOfType-java.lang.Class-boolean-boolean-).  However, this is not exactly the outcome I was looking to achieve in my particular case.  There are a few utility classes, such as [`BeanFactoryUtils`](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactoryUtils.html) and [`BeanFactoryAnnotationUtils`](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.html) containing a few extended container functions.  However, none contain a function quite like I describe here.  The  [`AutowireCapableBeanFactory.resolveDependency(..)`](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/AutowireCapableBeanFactory.html#resolveDependency-org.springframework.beans.factory.config.DependencyDescriptor-java.lang.String-java.util.Set-org.springframework.beans.TypeConverter-) container method handles dependency injection points, but is not exactly the API I am looking to call.  Rather, I prefer something more like `getBeansOfType(..)`.  To better demonstrate what I am asking for, I have built a utility class method in SDG to perform the desired function.  This can be seen in the [`SpringUtils.getBeansOfTypeOrdered(..)`](https://github.com/spring-projects/spring-data-geode/blob/master/spring-data-geode/src/main/java/org/springframework/data/gemfire/util/SpringUtils.java#L93-L175) method along with the associated helper methods.  I have also written a [test](https://github.com/spring-projects/spring-data-geode/blob/master/spring-data-geode/src/test/java/org/springframework/context/ApplicationContextBeanOrderingIntegrationTests.java#L215-L226) to demonstrate and assert the desired behavior.  If this function would be useful in the core Spring Framework, as part of a utility class or something, please consider.  If not, feel free to ignore and close this ticket.  Thank you for your consideration.","closed","status: invalid,","jxblum","2020-04-08T15:11:11Z","2020-04-08T15:20:45Z"
"","25678","Polish StartupStep interface ""tags"" method","Currently the `StartupStep` interface has a `Tags tags()` method that exposes the immutable collection of Tags.  We should update the Javadoc. Right now it's mentioning a ""mutable"" collection, but the mutating methods have been moved in the meantime to the `StartupStep` interface directly.  Also, for consistency we should make the `tags` a proper getter method.","closed","type: task,","bclozel","2020-09-02T15:57:19Z","2020-09-02T15:59:35Z"
"","25718","Early configuration of ApplicationStartup on BeanFactory","Currently the `GenericApplicationContext` configures the `AppliationStartup` on the `BeanFactory` only right before refreshing the `BeanFactory`. Delaying this has no purpose and we should instead configure it as soon as possible by overriding the setter method.","closed","type: task,","bclozel","2020-09-07T08:47:07Z","2020-09-07T08:49:17Z"
"","25037","Document all predefined variables from ApplicationContext available in SpEL expressions","Currently the [document](https://github.com/spring-projects/spring-framework/blob/master/src/docs/asciidoc/core/core-expressions.adoc#expressions-in-bean-definitions) only mentioned `systemProperties` as predefined variable, actually all builtin beans registered by `AbstractApplicationContext` are predefined variables, such as `environment` and `systemEnvironment` and `messageSource` and `applicationEventMulticaster` and `lifecycleProcessor`. It's worthy to add a new section describe those predefined variables.","closed","in: core,","quaff","2020-05-08T10:58:37Z","2020-05-18T12:31:16Z"
"","24942","24901 - Fix to handle static part of path variable URI mappings performance","Currently Spring webmvc looks up direct URLs and fall back to evaluating every URL mapped if there is no exact match based on direct URLs mappings. Due to this, URI with path variables, always go through larger look up evaluations poor performance. This PR stores static URIs as part of a MappingRegistry in a new Map to match incoming URIs to identify partial matches to cut down the mapping evaluations and hence improves performance","closed","status: superseded,","viswaramamoorthy","2020-04-20T13:31:09Z","2020-04-20T16:34:28Z"
"","24839","'args' argument of 'JdbcTemplate#query(String, Object[], RowCallbackHandler)' method should be marked @Nullable","Currently second parameter of method `query(String, Object[], RowCallbackHandler)` is not annotated as `@Nullable`. It leads to warnings from IDEA if I try to pass `null` value there. https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java#L737 I think nullability of paramters should match with its brother-twin-method `query(String, RowCallbackHandler, @Nullable Object...)`","closed","type: enhancement,","turbanoff","2020-04-01T17:20:54Z","2020-04-03T19:15:33Z"
"","25207","Optimize cache usage in DefaultListableBeanFactory.getBeanNamesForType()","Current Versions, The set value is not assigned to `allBeanNamesByType` attribute when the property is obtained. This method:  ```java @Override public String[] getBeanNamesForType(@Nullable Class type, boolean includeNonSingletons, boolean allowEagerInit) { 	if (!isConfigurationFrozen() || type == null || !allowEagerInit) { 		return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit); 	} 	Map, String[]> cache = 			(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType); 	String[] resolvedBeanNames = cache.get(type); 	if (resolvedBeanNames != null) { 		return resolvedBeanNames; 	} 	resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true); 	if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) { 		this.allBeanNamesByType.put(type, resolvedBeanNames); 	} 	return resolvedBeanNames; } ```","closed","in: core,","z-htao","2020-06-08T10:21:55Z","2020-06-09T13:27:54Z"
"","25198","The class of DefaultListableBeanFactory allBeanNamesByType attribute optimization Suggestions","Current Versions  This method:  	@Override 	public String[] getBeanNamesForType(@Nullable Class type, boolean includeNonSingletons, boolean allowEagerInit) { 		if (!isConfigurationFrozen() || type == null || !allowEagerInit) { 			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit); 		} 		Map, String[]> cache = 				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType); 		String[] resolvedBeanNames = cache.get(type); 		if (resolvedBeanNames != null) { 			return resolvedBeanNames; 		} 		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true); 		if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) { 			this.allBeanNamesByType.put(type, resolvedBeanNames); 		} 		return resolvedBeanNames; 	}  The set value is not assigned to allBeanNamesByType attribute when the property is obtained.","open","in: core,","z-htao","2020-06-06T15:37:48Z","2021-11-10T12:35:33Z"
"","25774","Incorrect example in javadocs of Assert.notNull(object, messageSupplier)","Current javadoc of `Assert.notNull(object, messageSupplier)` methods contains an example:  ```java Assert.notNull(clazz, () -> ""The class '"" + clazz.getName() + ""' must not be null""); ```  https://github.com/spring-projects/spring-framework/blob/fe9f29f03148ee0a28019a7f3322a126d2bced30/spring-core/src/main/java/org/springframework/util/Assert.java#L205-L220  This example is incorrect because it will lead to NPE in the `messageSupplier.get()`, that will be called if `clazz` is null.  I can create a PR to fix this, but I'm unsure what simple and descriptive example can show the intention of this variant of the method.  Whatever comes to my mind contains another object, that will be used in the message (not the object under assertion). Like:  ```java Object someObj = getSomeObj(); Assert.notNull(clazz, () -> ""Some message that involves '"" + someObj.someMethod()); ```  If there is not `someObj` in the equation, then why we need a `Supplier` in the first place?  But this is obviously not a good example. Too broad.  But javadoc need to be fixed anyway. It is just confusing now.","closed","in: core,","xak2000","2020-09-15T13:13:24Z","2020-10-07T11:21:22Z"
"","24946","Rid pointless wrapping with BufferedInputStream from class reading","Current implementation of `SimpleMetadataReader.getClassReader()` wraps `InputStream` of argument  resource with `BufferedInputStream` which is pointless. Rationale: - bufferisation anyway happens in `ClassReader.readStream()` - buffer sizes are different in `BufferedInputStream` and in `ClassReader.readStream()`: 8192 vs 4096 which means that `ClassReader.readStream()` has to do two calls to read full buffer of `BufferedInputStream` - most of the `InputStreams` returned from JDK classes are already wrapped into `BufferedInputStream`, e.g. `FileURLConnection.getInputStream()` or built around `ByteBuffer`  I've used the benchmark to measure impact of this change: ```java @State(org.openjdk.jmh.annotations.Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MICROSECONDS) @Fork(jvmArgsAppend = {""-Xms2g"", ""-Xmx2g"", ""-XX:+UseParallelGC""}) public class MetadataReaderBenchmark {   private final MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();    @Benchmark   public Object read() throws IOException {     return metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName()).getAnnotationMetadata();   }    @Component(""myName"")   @Scope(BeanDefinition.SCOPE_PROTOTYPE)   private static class AnnotatedComponent implements Serializable {     private final Dependency dep;      @Autowired     public AnnotatedComponent(@Qualifier(""myColor"") Dependency dep) {       this.dep = dep;     }      private static class Dependency {     }   } } ``` For JDK 8 and 11 it gives ``` JDK 8  original                                        Mode  Cnt      Score     Error   Units read                                   avgt  100    122.041 ±   1.286   us/op read:·gc.alloc.rate                    avgt  100    264.757 ±   2.681  MB/sec read:·gc.alloc.rate.norm               avgt  100  50795.798 ±  13.941    B/op","closed","type: enhancement,","stsypanov","2020-04-20T21:18:20Z","2020-05-14T13:36:10Z"
"","25535","Provide a way to read/write fixed-length byte chunks","Creating an issue here as suggested in https://github.com/reactor/reactor-core/issues/2300#issuecomment-669253301  ## Motivation When working with binary data (bytes), it is sometimes necessary to send the data in chunks of exact size, with the possible exception for the last one, of course. Note that I'm not talking about TCP packets, but data sent by the client to the   server without a POJO abstraction. This turns out to be surprisingly difficult to achieve in a non-blocking manner using the `WebClient`. The closest I've come is the following: ``` HttpClient.create()         .httpResponseDecoder { it.maxChunkSize(chunkSize) } ``` However, this doesn't guarantee that all chunks are exactly of size `chunkSize`, it only guarantees that the chunk size is less than or equal to `chunkSize`.  ## Desired solution 1. Provide a `BodyExtractor` that creates a `Flux`, where each `DataBuffer` contains exactly the number of bytes specified. It'll be the responsibility of the `BodyExtractor` to resize the packets it receives from Netty. 2. Provide an encoder on the `TcpClient` that can send chunks of exact size.  ## Considered alternatives Short of writing my own Netty handlers (which isn't difficult, except for the pesky reference counting), the only available client is I could find that could do this is [Ktor Http Client](https://ktor.io/clients/index.html). Ktor is developed by JetBrains mostly for the server side, and to say their documentation is poor is an understatement. They are also not as battle-tested as `WebClient`, so I'd like to be able to use `WebClient` if possible.  ## Additional context One of the use cases for this feature is streaming audio files. Uncompressed format like WAV comes with a header (44 bytes for WAV), that the recipient may not want. Using exact-size chunks would let us drop the header and only transmit the data. Netty provides the [LengthFieldBasedFrameDecoder](https://netty.io/4.0/api/io/netty/handler/codec/LengthFieldBasedFrameDecoder.html) for this exact purpose.","open","in: web,","asarkar","2020-08-05T21:04:06Z","2021-11-08T11:17:42Z"
"","25159","Tests for gh-25140","Created unit tests for   ``` CollectionUtils.toMultiValueMap ```  as suggested by @jhoeller in gh-25140   I just followed the instructions given there although I could imagine a better solution which is a lot more DRY.   I will create a second PR for comparison.  I would have 2 small questions:   1. The code actually being tested lies in  ``` CollectionUtils ```  but the test I have named **CollectionUtilsMultiValueMapAdapterTests**.   Is this OK with you or are you following a strong name convention, thus I should move the tests to *CollectionUtilsTest* ?   2. Is the gh issue number ok or should I create a separate one?","closed","status: superseded,","midumitrescu","2020-05-28T22:00:38Z","2020-05-29T14:41:31Z"
"","25148","Refactoring for MockServerHttpRequest","Created a small refactoring for gh-25109.   Changed:   1. Field duplication 2. Set DefaultBodyBuilder as protected, to allow children from other packages to call constructor (it seemed very constrictive to allow the call of the contructor only from the existing package) 3. Moved the  ``` Assert.notNull(method, ""HttpMethod is required. If testing a custom HTTP method, "" + 					""please use the variant that accepts a String based HTTP method.""); ```   to DefaultBodyContructor to also catch the contructor call  ``` public static BodyBuilder method(HttpMethod method, URI url) { 		return new DefaultBodyBuilder(method, url); 	} ``` to leave the main constructor easier to understand and failfast when constructing he builder. Also, messages when calling the  ```  MockServerHttpRequest.method(null, *any URI*) ``` would have failed with another kind of assertion message than  ``` MockServerHttpRequest.method(null, urlTemplate, param1, param2) ```  3. Extended the check for the string value of HttpMethod to exclude the set of HttpMethod to only whitespaces, as this, imho, makes no sense","closed","type: task,","midumitrescu","2020-05-28T10:11:22Z","2020-05-29T17:12:48Z"
"","25365","Could not find reactor-core-3.4.0-M1.jar (io.projectreactor:reactor-core:3.4.0-M1).","Could not find reactor-core-3.4.0-M1.jar (io.projectreactor:reactor-core:3.4.0-M1). Searched in the following locations:     http://nexus.bsdn.org/content/groups/public/io/projectreactor/reactor-core/3.4.0-M1/reactor-core-3.4.0-M1.jar  Possible solution:  - Declare repository providing the artifact, see the documentation at https://docs.gradle.org/current/userguide/declaring_repositories.html","closed","status: invalid,","kujin521","2020-07-07T09:07:11Z","2020-07-07T09:32:17Z"
"","25184","NamedParameterJdbcTemplate does not correctly parse sequence of single quote (') and question mark (?)","Consider the following code snippet:  ```java         BasicDataSource datasource = new BasicDataSource();         datasource.setDriverClassName(""com.mysql.jdbc.Driver"");         datasource.setUrl(""jdbc:mysql://127.0.0.1"");         datasource.setUsername(""username"");         datasource.setPassword(""password"");          NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(datasource);         template.queryForObject(""SELECT COUNT(*) FROM table_name WHERE key ='\'?'"", EmptySqlParameterSource.INSTANCE, Integer.class); ```  When you run it the following exception is thrown:  ``` org.springframework.dao.InvalidDataAccessApiUsageException: SQL [SELECT COUNT(*) FROM table_name WHERE key =''\?']: given 1 parameters but expected 0 ```  Most likely this is due to the implementation of `org.springframework.jdbc.core.namedparam.NamedParameterUtils#parseSqlStatement` where skip the quoted parts of the statements using the `skipCommentsAndQuotes` method. However this implementation also treats escaped quote mark `\'` as end of skipped sequence, thus, the question mark is not stripped out, and further code:  ```java 				if (c == '?') { 					int j = i + 1; 					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) { 						// Postgres-style ""??"", ""?|"", ""?&"" operator should be skipped 						i = i + 2; 						continue; 					} 					unnamedParameterCount++; 					totalParameterCount++; 				} ```  Considers that it found a placeholder for a parameter in the statement, that results in an exception.","open","in: data,","georgespear","2020-06-04T13:57:12Z","2020-07-18T14:27:39Z"
"","25239","Add tests for Assert.noNullElements(Collection, ...)","Commit 4000b244ff7b1db1f4eba9c4dbf2fc97162da254 introduced new variants for `noNullElements` in `org.springframework.util.Assert`.  This commit adds the corresponding tests to `AssertTests`.  If merged, this resolves #12580.","closed","in: core,","rweisleder","2020-06-11T14:45:06Z","2020-06-12T07:42:25Z"
"","24881","Add If-Match support and improve If-None-Match wildcard support","Coming from version 5.2.3.  RFC 7232, section 3.2 says: > If-None-Match can also be used with a value of ""*"" to prevent an    unsafe request method (e.g., PUT) from inadvertently modifying an    existing representation of the target resource when the client    believes that the resource does not have a current representation    (Section 4.2.1 of [RFC7231]).  This is a variation on the ""lost    update"" problem that might arise if more than one client attempts to    create an initial representation for the target resource.  My understanding is that only value `*` is allowed, anything else is invalid (400?). Yet, `#validateIfNoneMatch(String)` does not make a difference between the method types. I cannot also provide a `null` ETag to denote that the target resource does not exist.  Do I need to handle this manually?  PS: Issue for clarification: https://github.com/httpwg/http-core/issues/356","closed","type: enhancement,","michael-o","2020-04-08T12:23:02Z","2022-06-21T17:29:39Z"
"","25466","Spring Beans does not properly unwrap value if the value is java.util.Optional","class `AbstractNestablePropertyAccessor`,  method `getPropertyValue` is not doing unwrapping of `Optional`, that causes `InvalidPropertyException` being thrown:  ``` throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, 								""Property referenced in indexed property path '"" + propertyName + 										""' is neither an array nor a List nor a Set nor a Map; returned value was ["" + value + ""]""); ```  I think `Optional` should be natively supported and value unwrapping should take place.  I have a spring-boot application that is configured to use HibernateValidator, when constraint violation is happening, HV itself is behaving by the book throwing a proper exception.  This issue is forcing me to do manual pojo validations instead of relying on HibernateValidator.  More details can be found here:  https://hibernate.atlassian.net/jira/software/c/projects/HV/issues/HV-1794 Jira: HV-1794.  Let me know if you need more details.","open","in: core,","imochurad","2020-07-23T18:43:00Z","2021-11-12T12:08:06Z"
"","25554","Use Groovy syntax highlighting in reference manual","Change the language name of the source block for highlight.  This is an improved version of  #25540.","closed","type: documentation,","diguage","2020-08-06T23:26:26Z","2020-08-10T12:50:11Z"
"","25162","Nested Exception's message should not include the messages from causal chain","Change NestedRuntimeException, NestedCheckedException, etc so that the exception's `getMessage()` does not include the nested exception information.   [NestedRuntimeException](https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/core/NestedRuntimeException.html) was first introduced all the way back in [spring 1.0](https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/core/NestedRuntimeException.html) as compatibility for code still running in Java 1.3 or older version, which did not have exception chaining feature. To easily make the chained exception messages visible to the user on such old Java versions, `getMessage()` recursively included the messages.  We are long past Java 1.3. Nowadays, the nested message information is extremely, unnecessarily verbose and repetitive. Look at an [example exception](https://pastebin.com/raw/dbaTDDky) from a toy application.  And then look at [the same exception](https://pastebin.com/raw/ww0s9TtK) without nested messages.  In typical large applications, the problem is exacerbated because the exception messages/stacktraces can span many many console pages. In most cases, we must locate the root exception anyways to make sense of it all because both the root exception message _and_ the root stacktrace are needed to accurately diagnose the problem. The nested messages only impede the diagnostics.  Please remove nested exception messages.","closed","type: enhancement,","maxxedev","2020-05-29T08:28:15Z","2022-06-14T12:04:24Z"
"","25508","Optimize AggregatesSpliterator to avoid repetitive work","change   ```java if (mergedAnnotation == null) {     return tryAdvance(aggregate, action); } ```  to  ```java if (mergedAnnotation == null) {     return tryAdvance(aggregate, action, lowestDistance, annotationResult); } ```  to avoid repetitive visiting to the former code.  Testcase passed.","open","in: core,","yilianhuaixiao","2020-08-03T06:23:53Z","2021-04-27T05:06:14Z"
"","25088","Missing null checks in AbstractMessageChannel.addInterceptor/setInterceptors","Causes downstream NPEs at runtime...  https://stackoverflow.com/questions/61828635/occassional-nullpointerexception-when-publishing-stomp-message-using-springframe/61828913#61828913  ``` Caused by: java.lang.NullPointerException 	at org.springframework.messaging.support.AbstractMessageChannel$ChannelInterceptorChain.applyPreSend(AbstractMessageChannel.java:178) 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:132) 	... 2 more ```","closed","type: enhancement,","garyrussell","2020-05-15T22:12:23Z","2020-09-11T06:41:31Z"
"","25195","RestTemplate adds Content-Length for multipart form-data","by using `curl -F ""foo=123;type=text/plain"" url.com`, it give the following output: ``` Content-Disposition: form-data; name=""foo"" Content-Type: text/plain  123 ```  However, by using RestTemplate, it adds `Content-Length` in `MessageConverter addDefaultHeaders` methods, so the result becomes: ``` Content-Disposition: form-data; name=""foo"" Content-Type: text/plain;charset=UTF-8 Content-Length: 3  123 ``` And this Content-Length causes trouble to the other end server, that it could not understand. And I was thinking, since boundary is used to identify the boundary, can Content-Length be removed?","closed","type: enhancement,","Jovons","2020-06-06T04:03:25Z","2020-06-16T13:07:00Z"
"","25555","Remove @Nullable from CookieLocaleResolver#determineDefaultLocale()","By definition, this method should not return `null`.","closed","type: task,","ttddyy","2020-08-07T00:14:25Z","2020-08-07T17:05:40Z"
"","25126","Polish StringHttpMessageConverter.getContentTypeCharset()","Bug: Possible null pointer dereference in org.springframework.http.converter.StringHttpMessageConverter.getContentTypeCharset(MediaType) due to return value of called method  The return value from a method is dereferenced without a null check, and the return value of that method is one that should generally be checked for null.  This may lead to a NullPointerException when the code is executed.","closed","type: task,","quaff","2020-05-26T03:01:45Z","2020-05-26T16:59:46Z"
"","25096","Fix race condition in WriteResultPublisher between subscription and error in publishError","Between subscription and completion in publishError  Similar to https://github.com/spring-projects/spring-framework/pull/24989, but in publishError instead of publishComplete.","closed","type: bug,","danielra","2020-05-18T17:51:00Z","2020-05-27T18:14:03Z"
"","25857","Support multiple aliases via @AliasFor","Before time ,one annotation attribute only supports one alias ,you can only do like this:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test1 {         String test1() default ""test1"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test2 {         String test2() default ""test2"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test1     @Test2     public @interface Test3 {          @AliasFor(annotation = Test1.class, attribute = ""test1"")         String test3() default ""test3"";          @AliasFor(annotation = Test2.class, attribute = ""test2"")         String test4() default ""test4"";     } ```  But now ,you can do this more easily:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test1     @Test2     public @interface Test3 {          @AliasFor(annotation = Test1.class, attribute = ""test1"")         @AliasFor(annotation = Test2.class, attribute = ""test2"")         String test3() default ""test3"";     } ```  Moreover, the mutual aliasing of different attributes in the same annotation can break the original limitation (although this kind of use scenario is less):  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test4 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test"";          @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test"";     } ```  Combine examples above, you can use @AliasFors like this:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test5 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test1"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test1"";          @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test1"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test5     public @interface Test6 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test2"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test2"";          @AliasFor(annotation = Test5.class)         @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test2"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test6     public @interface Test7 {          @AliasFor(annotation = Test6.class)         String test3() default ""test3"";     }      @Test7(test3 = ""override the method"")     public static class Element4 {     }      @Test     public void test3() {         Test5 test5 = AnnotatedElementUtils.getMergedAnnotation(Element4.class, Test5.class);         Test6 test6 = AnnotatedElementUtils.getMergedAnnotation(Element4.class, Test6.class);         System.out.println(test5.toString());         System.out.println(test6.toString());         assertEquals(""override the method"", test6.test1());         assertEquals(""override the method"", test6.test2());         assertEquals(""override the method"", test6.test3());         assertEquals(""override the method"", test5.test1());         assertEquals(""override the method"", test5.test2());         assertEquals(""override the method"", test5.test3());     } ```  For more details, please read `org.springframework.core.annotation.AlisforsTests`.","closed","type: enhancement,","dragon-zhang","2020-10-04T08:11:23Z","2020-11-05T01:08:00Z"
"","25735","changing ConfigurationPhase.REGISTER_BEAN to ConfigurationPhase.PARSE…","Because  the calling time  of` doProcessConfigurationClass`  is still in  parsing configuration class phase, not  all  @Configuration  have been parsed.   So  here should be ConfigurationPhase.PARSE_CONFIGURATION.","closed","","yilianhuaixiao","2020-09-08T08:12:27Z","2022-02-18T19:06:27Z"
"","25377","Bean Validation API 2.0 does not work with Groovy in MVC","Bean Validation Api 2.0 not working with Spring MVC on top of Groovy 3.  So this code snippet won't work: ``` @RestController class DemoController {     @PostMapping(""api"")     String post(@Validated @RequestBody Names names, BindingResult result){         return ""Hello"";     } }   class Names {     @NotEmpty     List< @NotEmpty String> names; } ```  Validation on Type Param String are not triggering","open","in: core,","ankurpathak","2020-07-09T10:35:36Z","2021-11-12T12:53:37Z"
"","24981","Improve performance for synthesizing a single annotation instance","Based on the findings in #24961 and #24970, it appears that we can improve the runtime performance for method parameter annotations synthesized due to their use of `@AliasFor`.  Annotations such as `@RequestParam` can only be declared directly on parameters (due to the `@Target(ElementType.PARAMETER)` declaration). Consequently, they can never be _merged_ in the sense of `findMergedAnnotation()`. Similarly, the internal data structures in the `MergedAnnotation` API that support annotation attribute overriding (i.e., ""merging"") are never used for such annotations.  In addition, within the Spring Framework, `@RequestParam` is only looked up via `SynthesizingMethodParameter`, which delegates to `AnnotationUtils.synthesizeAnnotation()` to support the use of `@AliasFor`.  In 5.2.x, this is implemented using `MergedAnnotation.from(...)`:  https://github.com/spring-projects/spring-framework/blob/73fadd8b7c02938a0155ff49a40b4257092d1dc4/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java#L1188-L1195  Whereas, in 5.1.x, this is implemented using the `DefaultAnnotationAttributeExtractor`:  https://github.com/spring-projects/spring-framework/blob/ea7b0103c5b9ab403b75197f5f1f4582c85eb2fd/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java#L1556-L1574  The major difference here is that direct use of `DefaultAnnotationAttributeExtractor` avoids any extra overhead incurred by searching for annotation attribute overrides. In addition, `DefaultAnnotationAttributeExtractor` uses a direct approach for accessing the non-aliased values of the original annotation, thereby avoiding any complex lookups, conversions, adaptations, etc.  For example, if we still had a direct lookup mechanism for the `required` attribute in `@RequestParam`, then #24961 never would have surfaced as a regression since `TypeMappedAnnotation.getValue(...)` would not come into play.  In summary, the use of the `MergedAnnotation` API for direct synthesis of a single annotation without any form of attribute override support results in unnecessary runtime overhead and a regression in performance in Spring Framework 5.2.x.  We should therefore consider reintroducing the `DefaultAnnotationAttributeExtractor` / `MapAnnotationAttributeExtractor` dichotomy that existed prior to 5.2, or we should investigate an alternative means for synthesizing an annotation directly from a concrete annotation instance with limited support for `@AliasFor` for locally aliased attributes as is needed by clients such as `SynthesizingMethodParameter`.","open","in: core,","sbrannen","2020-04-27T11:58:38Z","2021-01-24T11:45:11Z"
"","25860","Improve R2DBC DatabaseClient documentation regarding array/Collection-like bind parameters","Based on spring-projects/spring-data-r2dbc#474, the documentation showing usage of `Collection`-like bind parameters leads to an assumption, that collection values can be used also for updating array columns.  We should clarify by adding a note that R2DBC doesn't support `Collection`-like values and this feature is solely a Spring feature. We also should mention that inserting/updating array-typed columns (as in Postgres) requires an array-type that is supported by the R2DBC driver, which are typically Java arrays (e.g. `String[]` to update a `text[]` column instead of using `Collection`).  I can submit a pull request to update the docs.","closed","type: documentation,","mp911de","2020-10-06T10:24:57Z","2020-10-26T16:49:21Z"
"","25835","SimpMessagingTemplate.convertAndSend results in UnsupportedOperationException when Spring Cloud Sleuth is present","Backport of gh-25821","closed","type: backport,","spring-projects-issues","2020-09-29T08:46:19Z","2020-10-01T15:14:13Z"
"","25812","Add MariaDB to the supported database products for procedures and functions","Backport of gh-25811","closed","type: backport,","spring-projects-issues","2020-09-24T13:39:10Z","2020-09-25T10:25:18Z"
"","25807","ClassCastException when wiring bean using method injection (NullBean instead of 'null')","Backport of gh-25806","closed","type: backport,","spring-projects-issues","2020-09-23T11:39:02Z","2020-09-25T10:23:19Z"
"","25790","Construct StringWriter instances with appropriate initial size","Backport of gh-25789","closed","type: backport,","spring-projects-issues","2020-09-18T16:09:19Z","2020-10-07T13:10:58Z"
"","25794","Published reference documentation contains unnecessary folders and files","Backport of gh-25783","closed","type: backport,","spring-projects-issues","2020-09-21T09:33:35Z","2020-09-21T15:25:23Z"
"","25775","Incorrect example in javadocs of Assert.notNull(object, messageSupplier)","Backport of gh-25774","closed","type: backport,","spring-projects-issues","2020-09-15T13:18:45Z","2020-09-15T14:31:34Z"
"","25722","PropertiesLoaderSupport should ignore socket/connect exceptions as well","Backport of gh-25717","closed","type: backport,","spring-projects-issues","2020-09-07T09:33:27Z","2020-09-07T16:51:05Z"
"","25721","PropertiesLoaderSupport should ignore socket/connect exceptions as well","Backport of gh-25717","closed","type: backport,","spring-projects-issues","2020-09-07T09:33:19Z","2020-09-07T16:27:56Z"
"","25720","PropertiesLoaderSupport should ignore socket/connect exceptions as well","Backport of gh-25717","closed","type: backport,","spring-projects-issues","2020-09-07T09:33:02Z","2020-09-07T16:21:56Z"
"","25709","CallMetaDataContext.reconcileParameters overwrites cursor name","Backport of gh-25707","closed","type: backport,","spring-projects-issues","2020-09-04T19:46:25Z","2020-09-05T11:56:12Z"
"","25708","CallMetaDataContext.reconcileParameters overwrites cursor name","Backport of gh-25707","closed","type: backport,","spring-projects-issues","2020-09-04T19:46:18Z","2020-09-05T11:30:56Z"
"","25713","VerifyErrors when using SpEL compilation with Thymeleaf when invoking a default method defined in an interface","Backport of gh-25706","closed","type: backport,","spring-projects-issues","2020-09-05T10:36:10Z","2020-09-05T12:29:34Z"
"","25712","VerifyErrors when using SpEL compilation with Thymeleaf when invoking a default method defined in an interface","Backport of gh-25706","closed","type: backport,","spring-projects-issues","2020-09-05T10:36:04Z","2020-09-05T11:56:12Z"
"","25711","VerifyErrors when using SpEL compilation with Thymeleaf when invoking a default method defined in an interface","Backport of gh-25706","closed","type: backport,","spring-projects-issues","2020-09-05T10:35:55Z","2020-09-05T11:30:56Z"
"","25700","Backport UrlPathHelper optimizations","Backport of gh-25690","closed","type: backport,","spring-projects-issues","2020-09-04T07:00:56Z","2020-09-08T11:32:44Z"
"","25699","Backport UrlPathHelper optimizations","Backport of gh-25690","closed","type: backport,","spring-projects-issues","2020-09-04T07:00:55Z","2020-09-08T11:03:30Z"
"","25698","Backport UrlPathHelper optimizations","Backport of gh-25690","closed","type: backport,","spring-projects-issues","2020-09-04T07:00:55Z","2020-09-08T10:35:59Z"
"","25694","SQLErrorCodesFactory.getErrorCodes(DataSource) returns empty error codes if access to transactional connection fails","Backport of gh-25681","closed","type: backport,","spring-projects-issues","2020-09-03T21:11:00Z","2020-09-03T21:30:36Z"
"","25693","SQLErrorCodesFactory.getErrorCodes(DataSource) returns empty error codes if access to transactional connection fails","Backport of gh-25681","closed","type: backport,","spring-projects-issues","2020-09-03T21:10:53Z","2020-09-03T21:22:31Z"
"","25692","SQLErrorCodesFactory.getErrorCodes(DataSource) returns empty error codes if access to transactional connection fails","Backport of gh-25681","closed","type: backport,","spring-projects-issues","2020-09-03T21:10:46Z","2020-09-03T21:15:37Z"
"","25676","Make ""org.springframework.util.unit.DataSize"" class Serializable","Backport of gh-25675","closed","type: backport,","spring-projects-issues","2020-09-02T09:31:43Z","2020-09-03T22:14:56Z"
"","25695","Avoid full singleton lock for DefaultSingletonBeanRegistry.getSingleton(beanName, false)","Backport of gh-25667","closed","type: backport,","spring-projects-issues","2020-09-03T22:42:22Z","2020-09-03T22:43:23Z"
"","25818","Wrong type inference in Kotlin while overriding RequestMappingHandlerMapping#getMappingForMethod","Backport of gh-25657","closed","type: backport,","spring-projects-issues","2020-09-25T13:29:35Z","2020-09-25T16:04:45Z"
"","25659","Joda-Time presence check fails to detect Joda-Time 2.x specifically","Backport of gh-25655","closed","type: backport,","spring-projects-issues","2020-08-28T17:50:12Z","2020-08-28T20:48:30Z"
"","25658","Joda-Time presence check fails to detect Joda-Time 2.x specifically","Backport of gh-25655","closed","type: backport,","spring-projects-issues","2020-08-28T17:49:13Z","2020-08-28T20:24:50Z"
"","25644","Potential integer overflow in AbstractResourceBasedMessageSource.setCacheSeconds(int)","Backport of gh-25613","closed","type: backport,","spring-projects-issues","2020-08-25T11:06:56Z","2020-08-27T14:17:17Z"
"","25643","Potential integer overflow in AbstractResourceBasedMessageSource.setCacheSeconds(int)","Backport of gh-25613","closed","type: backport,","spring-projects-issues","2020-08-25T11:06:50Z","2020-08-27T13:58:58Z"
"","25642","Potential integer overflow in AbstractResourceBasedMessageSource.setCacheSeconds(int)","Backport of gh-25613","closed","type: backport,","spring-projects-issues","2020-08-25T11:06:41Z","2020-08-27T13:37:14Z"
"","25703","Prevent confusion about build(boolean) method in UriComponentsBuilder","Backport of gh-25604","closed","type: backport,","spring-projects-issues","2020-09-04T07:12:50Z","2020-09-08T11:32:44Z"
"","25702","Prevent confusion about build(boolean) method in UriComponentsBuilder","Backport of gh-25604","closed","type: backport,","spring-projects-issues","2020-09-04T07:12:44Z","2020-09-08T11:03:31Z"
"","25701","Prevent confusion about build(boolean) method in UriComponentsBuilder","Backport of gh-25604","closed","type: backport,","spring-projects-issues","2020-09-04T07:12:23Z","2020-09-08T10:35:59Z"
"","25705","Document how to specify Jackson JSON view serialization hints with @RestController and Webflux","Backport of gh-25596","closed","type: backport,","spring-projects-issues","2020-09-04T07:15:36Z","2020-09-08T11:03:31Z"
"","25704","Document how to specify Jackson JSON view serialization hints with @RestController and Webflux","Backport of gh-25596","closed","type: backport,","spring-projects-issues","2020-09-04T07:15:29Z","2020-09-08T10:36:00Z"
"","25740","FileUrlResource isWritable method returns true if URL protocol is not indicating a file","Backport of gh-25584","closed","type: backport,","spring-projects-issues","2020-09-08T10:03:44Z","2020-09-08T11:20:14Z"
"","25739","FileUrlResource isWritable method returns true if URL protocol is not indicating a file","Backport of gh-25584","closed","type: backport,","spring-projects-issues","2020-09-08T10:03:35Z","2020-09-08T10:43:50Z"
"","25565","Lazy dependency proxy does not populate bean dependencies","Backport of gh-25562","closed","type: backport,","spring-projects-issues","2020-08-07T19:39:16Z","2020-08-07T20:10:23Z"
"","25564","Lazy dependency proxy does not populate bean dependencies","Backport of gh-25562","closed","type: backport,","spring-projects-issues","2020-08-07T19:39:10Z","2020-08-07T20:01:59Z"
"","25563","Lazy dependency proxy does not populate bean dependencies","Backport of gh-25562","closed","type: backport,","spring-projects-issues","2020-08-07T19:39:03Z","2020-08-07T19:57:13Z"
"","25551","Possible optimization in UrlResource","Backport of gh-25531","closed","type: backport,","spring-projects-issues","2020-08-06T14:18:25Z","2020-08-07T13:16:13Z"
"","25550","Possible optimization in UrlResource","Backport of gh-25531","closed","type: backport,","spring-projects-issues","2020-08-06T14:18:18Z","2020-08-07T12:52:40Z"
"","25525","StaticListableBeanFactory.isSingleton() returns false for singleton beans","Backport of gh-25522","closed","type: backport,","spring-projects-issues","2020-08-04T11:27:44Z","2020-08-04T14:55:02Z"
"","25524","StaticListableBeanFactory.isSingleton() returns false for singleton beans","Backport of gh-25522","closed","type: backport,","spring-projects-issues","2020-08-04T11:27:35Z","2020-08-04T14:42:41Z"
"","25523","StaticListableBeanFactory.isSingleton() returns false for singleton beans","Backport of gh-25522","closed","type: backport,","spring-projects-issues","2020-08-04T11:27:24Z","2020-08-04T13:54:58Z"
"","25691","Expose protected method to determine charset in AbstractJackson2HttpMessageConverter","Backport of gh-25509","closed","type: backport,","spring-projects-issues","2020-09-03T20:26:03Z","2020-09-08T10:36:54Z"
"","25512","MockHttpServletResponse reset() does not reset charset field","Backport of gh-25501","closed","type: backport,","spring-projects-issues","2020-08-03T14:27:25Z","2020-08-07T13:43:07Z"
"","25511","MockHttpServletResponse reset() does not reset charset field","Backport of gh-25501","closed","type: backport,","spring-projects-issues","2020-08-03T14:27:15Z","2020-08-07T13:16:13Z"
"","25510","MockHttpServletResponse reset() does not reset charset field","Backport of gh-25501","closed","type: backport,","spring-projects-issues","2020-08-03T14:27:06Z","2020-08-07T12:52:41Z"
"","25515","Refine use of substring operations","Backport of gh-25445","closed","type: backport,","spring-projects-issues","2020-08-03T14:46:19Z","2020-08-07T13:43:07Z"
"","25514","Refine use of substring operations","Backport of gh-25445","closed","type: backport,","spring-projects-issues","2020-08-03T14:46:10Z","2020-08-07T13:16:13Z"
"","25513","Refine use of substring operations","Backport of gh-25445","closed","type: backport,","spring-projects-issues","2020-08-03T14:45:59Z","2020-08-07T12:52:40Z"
"","25435","Defer creating logger in StandardWebSocketHandlerAdapter","Backport of gh-25427","closed","type: backport,","spring-projects-issues","2020-07-20T15:08:26Z","2020-07-20T15:24:06Z"
"","25434","Defer creating logger in StandardWebSocketHandlerAdapter","Backport of gh-25427","closed","type: backport,","spring-projects-issues","2020-07-20T15:08:17Z","2020-07-20T15:20:45Z"
"","25433","Defer creating logger in StandardWebSocketHandlerAdapter","Backport of gh-25427","closed","type: backport,","spring-projects-issues","2020-07-20T15:08:09Z","2020-07-20T15:17:12Z"
"","25426","UriComponentsBuilder.cloneBuilder() cause sharing query parameters between builders","Backport of gh-25423","closed","type: backport,","spring-projects-issues","2020-07-20T05:02:31Z","2020-07-20T06:02:15Z"
"","25425","UriComponentsBuilder.cloneBuilder() cause sharing query parameters between builders","Backport of gh-25423","closed","type: backport,","spring-projects-issues","2020-07-20T05:02:21Z","2020-07-20T05:45:18Z"
"","25424","UriComponentsBuilder.cloneBuilder() cause sharing query parameters between builders","Backport of gh-25423","closed","type: backport,","spring-projects-issues","2020-07-20T05:02:15Z","2020-07-20T05:35:29Z"
"","25405","Clarify enforceInitMethod/enforceDestroyMethod default values in AbstractBeanDefinition","Backport of gh-25402","closed","type: backport,","spring-projects-issues","2020-07-17T10:22:16Z","2020-07-17T17:06:59Z"
"","25404","Clarify enforceInitMethod/enforceDestroyMethod default values in AbstractBeanDefinition","Backport of gh-25402","closed","type: backport,","spring-projects-issues","2020-07-17T10:22:09Z","2020-07-17T17:02:18Z"
"","25403","Clarify enforceInitMethod/enforceDestroyMethod default values in AbstractBeanDefinition","Backport of gh-25402","closed","type: backport,","spring-projects-issues","2020-07-17T10:21:58Z","2020-07-17T16:35:48Z"
"","25406","MutablePropertySources will not find or remove proxied sources","Backport of gh-25369","closed","type: backport,","spring-projects-issues","2020-07-17T10:46:46Z","2020-07-17T16:35:48Z"
"","25363","Profiles should be comparable when created via Profiles.of()","Backport of gh-25340","closed","type: backport,","spring-projects-issues","2020-07-06T16:50:18Z","2020-07-07T12:45:23Z"
"","25343","MappingJackson2HttpMessageConverter might be too specific in its Charset support","Backport of gh-25322","closed","type: backport,","spring-projects-issues","2020-06-30T09:45:54Z","2020-07-06T16:51:26Z"
"","25286","ServerHttpRequest.getSslInfo() always returns null for reactor-netty HTTP/2 requests","Backport of gh-25278","closed","type: backport,","spring-projects-issues","2020-06-19T14:44:27Z","2020-06-20T18:02:13Z"
"","25269","NoRollbackFor rule causes TransactionAspectSupport to log unwarranted ""exception overridden"" error on WebSphere","Backport of gh-25253","closed","type: backport,","spring-projects-issues","2020-06-17T13:27:34Z","2020-06-17T14:26:04Z"
"","25268","NoRollbackFor rule causes TransactionAspectSupport to log unwarranted ""exception overridden"" error on WebSphere","Backport of gh-25253","closed","type: backport,","spring-projects-issues","2020-06-17T13:27:27Z","2020-06-17T14:21:21Z"
"","25267","NoRollbackFor rule causes TransactionAspectSupport to log unwarranted ""exception overridden"" error on WebSphere","Backport of gh-25253","closed","type: backport,","spring-projects-issues","2020-06-17T13:27:20Z","2020-06-17T14:17:34Z"
"","25252","AbstractJackson2HttpMessageConverter - Check for encoding breaks JSON to POJO de-serialization experience","Backport of gh-25247","closed","type: backport,","spring-projects-issues","2020-06-15T14:52:53Z","2020-06-16T12:30:42Z"
"","25243","The AbstractTemplateViewResolver class is not abstract","Backport of gh-25240","closed","type: backport,","spring-projects-issues","2020-06-11T20:50:32Z","2020-06-11T22:34:10Z"
"","25242","The AbstractTemplateViewResolver class is not abstract","Backport of gh-25240","closed","type: backport,","spring-projects-issues","2020-06-11T20:50:24Z","2020-06-11T22:26:55Z"
"","25241","The AbstractTemplateViewResolver class is not abstract","Backport of gh-25240","closed","type: backport,","spring-projects-issues","2020-06-11T20:50:19Z","2020-06-11T22:14:21Z"
"","25235","Document exception handling limitations in TaskDecorator implementations (specifically for ThreadPoolTaskExecutor#submit)","Backport of gh-25231","closed","type: backport,","spring-projects-issues","2020-06-10T17:00:52Z","2020-06-10T21:09:12Z"
"","25234","Document exception handling limitations in TaskDecorator implementations (specifically for ThreadPoolTaskExecutor#submit)","Backport of gh-25231","closed","type: backport,","spring-projects-issues","2020-06-10T17:00:46Z","2020-06-10T21:05:58Z"
"","25233","Document exception handling limitations in TaskDecorator implementations (specifically for ThreadPoolTaskExecutor#submit)","Backport of gh-25231","closed","type: backport,","spring-projects-issues","2020-06-10T17:00:39Z","2020-06-10T21:00:54Z"
"","25197","Performance enhancement in execution of ResponseEntity.of()","Backport of gh-25183","closed","type: backport,","spring-projects-issues","2020-06-06T15:29:56Z","2020-06-06T17:15:48Z"
"","25181","Support for shared GroovyClassLoader in GroovyScriptFactory","Backport of gh-25177","closed","type: backport,","spring-projects-issues","2020-06-03T12:58:28Z","2020-06-06T14:58:25Z"
"","25176","Configure Gradle wrapper validation action","Backport of gh-25175","closed","type: backport,","spring-projects-issues","2020-06-02T12:35:48Z","2020-06-02T12:45:42Z"
"","25154","Make use of custom types configurable in YamlProcessor","Backport of gh-25152","closed","type: backport,","spring-projects-issues","2020-05-28T13:34:36Z","2020-05-29T12:16:04Z"
"","25150","ExchangeStrategies custom codec's reader & writer are not registered","Backport of gh-25149","closed","type: backport,","spring-projects-issues","2020-05-28T10:32:20Z","2020-05-28T13:35:57Z"
"","25227","MultiValueMapAdapter.getFirst fails with IndexOutOfBoundsException in case of empty List","Backport of gh-25140","closed","type: backport,","spring-projects-issues","2020-06-10T09:16:23Z","2020-06-10T10:20:09Z"
"","25226","MultiValueMapAdapter.getFirst fails with IndexOutOfBoundsException in case of empty List","Backport of gh-25140","closed","type: backport,","spring-projects-issues","2020-06-10T09:16:16Z","2020-06-10T09:24:58Z"
"","25141","MultiValueMapAdapter.getFirst fails with IndexOutOfBoundsException in case of empty List","Backport of gh-25140","closed","type: backport,","spring-projects-issues","2020-05-27T16:06:18Z","2020-05-29T14:33:03Z"
"","25225","WebSphereUowTransactionManager causes exception for PROPAGATION_SUPPORTS when timeout is specified","Backport of gh-25132","closed","type: backport,","spring-projects-issues","2020-06-10T09:15:37Z","2020-06-10T10:20:09Z"
"","25224","WebSphereUowTransactionManager causes exception for PROPAGATION_SUPPORTS when timeout is specified","Backport of gh-25132","closed","type: backport,","spring-projects-issues","2020-06-10T09:15:30Z","2020-06-10T09:24:58Z"
"","25135","WebSphereUowTransactionManager causes exception for PROPAGATION_SUPPORTS when timeout is specified","Backport of gh-25132","closed","type: backport,","spring-projects-issues","2020-05-26T21:40:20Z","2020-05-26T21:58:12Z"
"","25223","Avoid ClassCastException on IllegalArgumentException when invoking sync get cache method","Backport of gh-25110","closed","type: backport,","spring-projects-issues","2020-06-10T09:15:10Z","2020-06-10T10:20:09Z"
"","25222","Avoid ClassCastException on IllegalArgumentException when invoking sync get cache method","Backport of gh-25110","closed","type: backport,","spring-projects-issues","2020-06-10T09:15:03Z","2020-06-10T09:24:58Z"
"","25118","Avoid ClassCastException on IllegalArgumentException when invoking sync get cache method","Backport of gh-25110","closed","type: backport,","spring-projects-issues","2020-05-22T14:24:47Z","2020-05-22T15:40:44Z"
"","25107","DefaultServerRequestBuilder does not respect attributes when building the ServerRequest","Backport of gh-25106","closed","type: backport,","spring-projects-issues","2020-05-19T17:21:40Z","2020-05-22T15:42:06Z"
"","25102","Fix race condition in WriteResultPublisher between subscription and error in publishError","Backport of gh-25096","closed","type: backport,","spring-projects-issues","2020-05-19T11:19:43Z","2020-05-28T06:00:38Z"
"","25221","Missing null checks in AbstractMessageChannel.addInterceptor/setInterceptors","Backport of gh-25088","closed","type: backport,","spring-projects-issues","2020-06-10T09:14:33Z","2020-06-10T10:20:09Z"
"","25220","Missing null checks in AbstractMessageChannel.addInterceptor/setInterceptors","Backport of gh-25088","closed","type: backport,","spring-projects-issues","2020-06-10T09:14:26Z","2020-06-10T09:34:01Z"
"","25089","Missing null checks in AbstractMessageChannel.addInterceptor","Backport of gh-25088","closed","type: backport,","spring-projects-issues","2020-05-16T15:51:23Z","2020-06-10T09:34:13Z"
"","25219","Avoid full synchronization in AbstractRefreshableApplicationContext.getBeanFactory() since it can lead to massive thread blocking","Backport of gh-25081","closed","type: backport,","spring-projects-issues","2020-06-10T09:13:56Z","2020-06-10T10:20:09Z"
"","25218","Avoid full synchronization in AbstractRefreshableApplicationContext.getBeanFactory() since it can lead to massive thread blocking","Backport of gh-25081","closed","type: backport,","spring-projects-issues","2020-06-10T09:13:46Z","2020-06-10T09:24:57Z"
"","25083","Avoid full synchronization in AbstractRefreshableApplicationContext.getBeanFactory() since it can lead to massive thread blocking","Backport of gh-25081","closed","type: backport,","spring-projects-issues","2020-05-14T17:09:41Z","2020-05-18T13:22:07Z"
"","25185","AbstractJackson2HttpMessageConverter does not respect character encoding in canRead/canWrite","Backport of gh-25076","closed","type: backport,","spring-projects-issues","2020-06-04T15:42:16Z","2020-06-06T09:48:00Z"
"","25035","HttpHeaders equals may return false without comparing actual content","Backport of gh-25034","closed","type: backport,","spring-projects-issues","2020-05-08T07:50:00Z","2020-06-06T14:58:25Z"
"","25026","Fix concurrency issues in XStreamMarshaller","Backport of gh-25017","closed","type: backport,","spring-projects-issues","2020-05-07T10:19:27Z","2020-05-07T11:10:10Z"
"","25004","Fix race condition in WriteResultPublisher between subscription and completion in publishComplete","Backport of gh-24989","closed","type: backport,","spring-projects-issues","2020-05-01T10:53:12Z","2020-05-04T10:25:05Z"
"","25003","Avoid logging exception for closed session in AbstractSockJsSession","Backport of gh-24986","closed","type: backport,","spring-projects-issues","2020-05-01T10:52:27Z","2020-05-04T10:25:05Z"
"","24939","Remove potentially confusing kotlin-reflect related log message","Backport of gh-24935","closed","type: backport,","spring-projects-issues","2020-04-20T08:17:16Z","2020-04-20T09:02:24Z"
"","24919","MockHttpServletRequest should not strip brackets from IPV6 address supplied via Host header","Backport of gh-24916","closed","type: backport,","spring-projects-issues","2020-04-16T14:55:08Z","2020-04-17T15:27:11Z"
"","24918","MockHttpServletRequest should not strip brackets from IPV6 address supplied via Host header","Backport of gh-24916","closed","type: backport,","spring-projects-issues","2020-04-16T14:54:57Z","2020-04-17T14:39:30Z"
"","24917","MockHttpServletRequest should not strip brackets from IPV6 address supplied via Host header","Backport of gh-24916","closed","type: backport,","spring-projects-issues","2020-04-16T14:52:59Z","2020-04-17T14:29:15Z"
"","24973","Caching of autowire candidate metadata for lazy beans","Backport of gh-24904","closed","type: backport,","spring-projects-issues","2020-04-25T15:09:17Z","2020-04-25T15:15:29Z"
"","24972","Put a limit on the size of DefaultSingletonBeanRegistry#suppressedExceptions","Backport of gh-24902","closed","type: backport,","spring-projects-issues","2020-04-25T15:09:01Z","2020-04-25T15:15:29Z"
"","24877","Honor overridden AcceptHeaderLocaleContextResolver.getDefaultLocale()","Backport of gh-24871","closed","type: backport,","spring-projects-issues","2020-04-07T16:20:32Z","2020-04-09T10:07:23Z"
"","24876","Honor overridden AcceptHeaderLocaleContextResolver.getDefaultLocale()","Backport of gh-24871","closed","type: backport,","spring-projects-issues","2020-04-07T16:20:25Z","2020-04-09T10:03:57Z"
"","24860","Connection created by SingleConnectionDataSource with suppressClose=true always returns isClosed=false even if the target connection is closed","Backport of gh-24853","closed","type: backport,","spring-projects-issues","2020-04-03T14:36:19Z","2020-04-03T20:03:49Z"
"","24859","Connection created by SingleConnectionDataSource with suppressClose=true always returns isClosed=false even if the target connection is closed","Backport of gh-24853","closed","type: backport,","spring-projects-issues","2020-04-03T14:36:10Z","2020-04-03T19:58:59Z"
"","24858","Connection created by SingleConnectionDataSource with suppressClose=true always returns isClosed=false even if the target connection is closed","Backport of gh-24853","closed","type: backport,","spring-projects-issues","2020-04-03T14:36:02Z","2020-04-03T19:53:46Z"
"","24857","DefaultListableBeanFactory.getBean(Class) throws NoSuchBeanDefinitionException on existing bean if getBean(Class) previously tried before registration","Backport of gh-24852","closed","type: backport,","spring-projects-issues","2020-04-03T14:35:42Z","2020-04-03T20:03:48Z"
"","24856","DefaultListableBeanFactory.getBean(Class) throws NoSuchBeanDefinitionException on existing bean if getBean(Class) previously tried before registration","Backport of gh-24852","closed","type: backport,","spring-projects-issues","2020-04-03T14:35:33Z","2020-04-03T19:58:58Z"
"","24855","DefaultListableBeanFactory.getBean(Class) throws NoSuchBeanDefinitionException on existing bean if getBean(Class) previously tried before registration","Backport of gh-24852","closed","type: backport,","spring-projects-issues","2020-04-03T14:35:25Z","2020-04-03T19:53:46Z"
"","25549","Synchronized blocks in MethodOverrides are hurting concurrency","Backport of gh-23448","closed","type: backport,","spring-projects-issues","2020-08-06T14:10:00Z","2020-08-07T13:43:08Z"
"","25416","Unnecessarily alarming stack trace logged during scheduler resolution","Backport of gh-23268","closed","type: backport,","spring-projects-issues","2020-07-19T15:14:44Z","2020-07-19T18:14:07Z"
"","25419","Oracle LOB segments holding TEMP space after executing SP using SimpleJdbcCall with SqlParameterSource","Backport of gh-22972","closed","type: backport,","spring-projects-issues","2020-07-19T15:49:26Z","2020-07-19T18:49:39Z"
"","25418","Oracle LOB segments holding TEMP space after executing SP using SimpleJdbcCall with SqlParameterSource","Backport of gh-22972","closed","type: backport,","spring-projects-issues","2020-07-19T15:49:05Z","2020-07-19T18:34:16Z"
"","25417","Oracle LOB segments holding TEMP space after executing SP using SimpleJdbcCall with SqlParameterSource","Backport of gh-22972","closed","type: backport,","spring-projects-issues","2020-07-19T15:48:58Z","2020-07-19T18:14:07Z"
"","25422","DefaultListableBeanFactory.getBean(Class) may throw NoSuchBeanDefinitionException when removeBeanDefinition is being called simultaneously to remove an unrelated bean","Backport of gh-22263","closed","type: backport,","spring-projects-issues","2020-07-19T16:37:09Z","2020-07-19T18:34:16Z"
"","25421","DefaultListableBeanFactory.getBean(Class) may throw NoSuchBeanDefinitionException when removeBeanDefinition is being called simultaneously to remove an unrelated bean","Backport of gh-22263","closed","type: backport,","spring-projects-issues","2020-07-19T16:37:01Z","2020-07-19T18:14:07Z"
"","25323","Need to know transaction.isReadonly while getting connection - spring-jdbc","Backgroup:  I have a large project with more than 500 nodes need to connection to one Database,  so connection count is too high. In order to reduce db connections, I want to reuse one connection for all readonly transactions. So, I need to get the ""TransactionSynchronizationManager.isCurrentTransactionReadOnly()"" in Datasource.getConnection() method. While, in spring-jdbc-5.2.2, DataSourceTransactionManager.doBegin method, the connection is gotten at line 263, the readonly flag is setted at line 298.  Suggestion: Set the readonly flag before getting connection. e.g.  in DataSourceTransactionManager.doBegin method  > protected void doBegin(Object transaction, TransactionDefinition definition) { >     **TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());** >     DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; >     ... >     **Connection newCon = obtainDataSource().getConnection();** >     ...  Then I will override a Datasource, that, return one shared connection to all readonly transactions.","closed","status: superseded,","johnny2002","2020-06-27T03:49:54Z","2021-11-12T13:34:20Z"
"","25394","Add convert(Object, TypeDescriptor) method to ConversionService","At the moment there is the method  ```java Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType); ```  And usually `sourceType` can be deduced from `source` and it is unnecessary to specify the `sourceType`. Please add a new `convert` method which will remove necessity to specify the type descriptor if it is the same as `source`.  ```java Object convert(@Nullable Object source, TypeDescriptor targetType) {     return convert(source, TypeDescriptor.forObject(source), targetType); } ```","open","type: enhancement,","raderio","2020-07-15T15:57:33Z","2020-07-27T14:48:45Z"
"","25261","Remove redundant assignment of default values to volatile fields","Assignment of default values to fields in general case is redundant, because the value will be there according to JLS. However in case of volatile field there is also performance issue, consider benchmark ```java @State(Scope.Thread) @OutputTimeUnit(TimeUnit.NANOSECONDS) @BenchmarkMode(value = Mode.AverageTime) @Fork(jvmArgsAppend = {""-Xms4g"", ""-Xmx4g""}) public class VolatileFieldBenchmark  {   @Benchmark   public Object explicitInit() {     return new Class1();   }   @Benchmark   public Object noInit() {     return new Class2();   }   private static class Class1 {     private volatile boolean field = false;     public boolean isField() {       return field;     }     public void setField(boolean field) {       this.field = field;     }   }   private static class Class2 {     private volatile boolean field;     public boolean isField() {       return field;     }     public void setField(boolean field) {       this.field = field;     }   } } ``` The benchmark demonstrates that instantiation of a class without default value assignment takes less time: ``` Benchmark                            Mode  Cnt   Score   Error  Units VolatileFieldBenchmark.explicitInit  avgt   40  11.087 ± 0.140  ns/op VolatileFieldBenchmark.noInit        avgt   40   3.367 ± 0.131  ns/op ```","closed","in: core,","stsypanov","2020-06-17T08:17:09Z","2020-06-17T11:01:32Z"
"","24872","Upgrade to ASM 9.0","ASM 8.0(.1) being released now, we're anticipating ASM 9.0 to be picked up in Spring Framework 5.3, turning record support non-experimental for JDK 15 and introducing early JDK 16 support.  Our 5.2.x line is currently on ASM 7.3.1 (#24438) and will likely stay on that branch, with record support remaining experimental (#24722) for the time being.","closed","type: dependency-upgrade,","jhoeller","2020-04-06T16:45:04Z","2020-07-07T14:18:33Z"
"","25456","Use Integer.parseInt instead of Integer.valueOf for primitive int","as title.","closed","type: task,","XenoAmess","2020-07-21T16:00:07Z","2020-07-22T09:10:35Z"
"","25455","use regionMatch to reduce subString creation in CodeFlow.isPrimitiveOrUnboxableSupportedNumber","as title.","closed","status: declined,","XenoAmess","2020-07-21T15:59:25Z","2020-07-25T03:23:13Z"
"","25454","Use List.sort instead of Collection.sort in tests","as title.","closed","type: task,","XenoAmess","2020-07-21T15:58:21Z","2020-07-22T09:37:20Z"
"","25445","Refine use of substring operations","as title.","closed","type: enhancement,","XenoAmess","2020-07-21T15:51:30Z","2020-08-07T12:58:20Z"
"","25453","Use Stream#toArray in TestCompiler","as title","closed","type: task,","XenoAmess","2020-07-21T15:57:33Z","2020-07-22T08:43:02Z"
"","25452","Use `private static` instead of `static private` for method declarations","as title","closed","type: task,","XenoAmess","2020-07-21T15:57:06Z","2020-07-29T16:15:30Z"
"","25451","change C style array declaration","as title","closed","status: declined,","XenoAmess","2020-07-21T15:55:07Z","2020-07-21T16:18:49Z"
"","25449","Simplify if-statements with instanceof checks","as title","closed","status: feedback-provided,","XenoAmess","2020-07-21T15:53:26Z","2020-07-22T08:34:42Z"
"","25448","Fix links in Javadoc","as title","closed","status: feedback-provided,","XenoAmess","2020-07-21T15:52:31Z","2020-07-22T08:25:24Z"
"","25447","Use System.currentTimeMillis() in AbstractSockJsService","as title","closed","status: feedback-provided,","XenoAmess","2020-07-21T15:52:12Z","2020-07-22T08:42:24Z"
"","25446","Use instanceof instead of Class#isInstance where feasible","as title","closed","type: task,","XenoAmess","2020-07-21T15:52:01Z","2020-07-22T13:36:12Z"
"","25487","Updated as per standard design practice","As this class would be used in other Comparators, we should make this as singleton design pattern. I have just modified this class, so that it can be used in concurrent environments.","closed","status: declined,","abhishek-abhi","2020-07-28T19:20:11Z","2020-08-09T08:13:52Z"
"","25641","Change field configurationClasses type to set in ConfigurationClassParser","As the only set method for this.configurationClasses is ``` 	this.configurationClasses.put(configClass,configClass); ``` ,  maybe using  `Set` is better than `Map`.","closed","in: core,","yilianhuaixiao","2020-08-25T09:46:47Z","2021-12-10T22:56:43Z"
"","25131","Avoid need for default constructor in ContextAnnotationAutowireCandidateResolver subclasses","As reported [here](https://github.com/spring-projects/spring-boot/issues/16230), it seems that under certain circumstances, the `BeanFactory` expects `ContextAnnotationAutowireCandidateResolver`s to expose a default constructor which limits the ability to populate instances with configuration on construction.","closed","type: enhancement,","odrotbohm","2020-05-26T15:11:08Z","2020-05-26T21:45:28Z"
"","25307","spring-kafka critical vulnerability CVE-2018-1270","As per pivotal documentation (https://tanzu.vmware.com/security/cve-2018-1270), the critical vulnerability CVE-2018-1270 is fixed in Spring versions 5.0.5 and latest. But still getting this vulnerability in Spring version 5.2.3 .","closed","for: external-project,","dipindas","2020-06-23T18:13:20Z","2020-06-23T19:07:00Z"
"","25476","Add CompletionStageWrappingResponse for async support","As part of a problem I ran into detailed in [this question from stackoverflow](https://stackoverflow.com/questions/63019544/springboot-functional-web-mvc-missing-a-way-to-return-completablefuturerespons?noredirect=1#comment111442460_63019544) I created CompletionStageWrappingResponse for cases where a ServerResponse needs to be created in a completion stage (complete with status, headers and cookies).  Please take into consideration, that declarative webmvc has this feature with `CompletionStage`  I have added the whenComplete builder method to ServerResponse so now it will be possible for a user to do:  ```java RouterFunctions.route().route(RequestPredicates.path(""/helloWorld/{option}""), x -> ServerResponse.whenComplete(service.futureFoo()); ```  where the service will be able to in an asynchronous stream decide what response it wants to offer like so ```java CompletionStage futureFoo(){     return CompletableFuture.supplyAsync(()-> /* some async process returning a boolean */)                   .thenApply(x-> x ? ServerResponse.ok().body(""true"") :                        ServerResponse.status(HttpStatus.FOUND).location(URI.create(""/look/somewhere/else"").build()); } ```  I have a use case for this behaviour in my production deployed application. As a half measure I have created a 'mycompany-spring-extras' library with this functionality.  As I don't want to find myself in trouble when in the future migrating to newer versions of spring, I humbly try to contribute this code.  Best regards, Alex.","closed","status: duplicate,","alexfeigin","2020-07-24T22:30:14Z","2020-11-19T16:12:34Z"
"","25797","Support for HTTP Request Method: SEARCH","As of RFC 5323 (https://tools.ietf.org/html/rfc5323) a HTTP SEARCH method was proposed. This RFC then got refined by https://trac.tools.ietf.org/id/draft-snell-search-method-00.html and others.  SEARCH is useful to replace GET methods which would require a long size of request parameters (exceeding the maximum query length), or that would require a body to be sent (although currently allowed by the specification many languages / browsers will not allow it)  Although this RFC is still not approved we start to see some support for it in multiple libraries. Is this verb planned to be supported on Spring?","open","status: feedback-provided,","joao-rebelo","2020-09-22T10:35:19Z","2021-11-08T11:46:09Z"
"","25650","Replace remaining usage of LinkedList with ArrayList/ArrayDeque","As of 2020 there's no need to use `LinkedList`: - empty `ArrayList` is more lightweight than `LinkedList`: ```java @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(jvmArgsAppend = {""-Xms2g"", ""-Xmx2g""}) public class ListBenchmark {   @Benchmark   public Object arrayList() {     return new ArrayList();   }    @Benchmark   public Object linkedList() {     return new LinkedList();   } } ``` which on JDK 11 gives ``` ListBenchmark.arrayList                                    avgt   15     4.011 ±   0.120   ns/op ListBenchmark.arrayList:·gc.alloc.rate.norm                avgt   15    24.002 ±   0.001    B/op  ListBenchmark.linkedList                                   avgt   15     4.243 ±   0.181   ns/op ListBenchmark.linkedList:·gc.alloc.rate.norm               avgt   15    32.002 ±   0.001    B/op ``` if we put one element then `LinkedList` wins: ``` enchmark                                                  Mode  Cnt     Score     Error   Units ListBenchmark.arrayList                                    avgt   15     9.188 ±   0.831   ns/op ListBenchmark.arrayList:·gc.alloc.rate.norm                avgt   15    80.005 ±   0.001    B/op ListBenchmark.linkedList                                   avgt   15     8.148 ±   0.285   ns/op ListBenchmark.linkedList:·gc.alloc.rate.norm               avgt   15    56.004 ±   0.001    B/op ``` in other cases `LinkedList` looses: ``` 2 elements Benchmark                                                  Mode  Cnt     Score     Error   Units ListBenchmark.arrayList                                    avgt   15    11.308 ±   0.290   ns/op ListBenchmark.arrayList:·gc.alloc.rate.norm                avgt   15    80.006 ±   0.001    B/op ListBenchmark.linkedList                                   avgt   15    11.898 ±   0.608   ns/op ListBenchmark.linkedList:·gc.alloc.rate.norm               avgt   15    80.006 ±   0.001    B/op  3 elements ListBenchmark.arrayList                                    avgt   15    14.763 ±   1.452   ns/op ListBenchmark.arrayList:·gc.alloc.rate.norm                avgt   15    80.006 ±   0.001    B/op ListBenchmark.linkedList                                   avgt   15    19.166 ±   1.686   ns/op ListBenchmark.linkedList:·gc.alloc.rate.norm               avgt   15   104.008 ±   0.001    B/op ``` - `ArrayList` provides better data locality and less cache-misses due to usage of array - `LinkedList` consumes much more memory per element, see [https://stackoverflow.com/a/7671021/12473843](https://stackoverflow.com/a/7671021/12473843) - the only case when `LinkedList` could probably win (re-use of existing iterators to insert and remove elements) are comparatively seldom, in most of the cases we just store elements and iterate over them - if frequently used `LinkedList` gets C2-compiled and thus requires space in Code Cache","closed","in: core,","stsypanov","2020-08-26T11:32:45Z","2020-08-26T16:33:18Z"
"","24838","Document default constructor as fallback for multiple non-@Autowired constructors","As mentioned by @ElmehdiBenh in https://github.com/spring-projects/spring-framework/issues/23263#issuecomment-606966126, our documentation currently fails to point out that a default constructor (if present) will be used as the fallback constructor for autowiring if multiple constructors are present and none of them is annotated with `@Autowired`.  We should therefore make this clear in the documentation, both in the Javadoc for `@Autowired` and in the [reference manual](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation).","closed","in: core,","sbrannen","2020-04-01T16:19:45Z","2020-04-07T12:36:32Z"
"","25066","Simplify use of HttpContext in HttpComponentsClientHttpRequestFactory in support of user associated connections","As described in the Apache [HttpClient docs](http://hc.apache.org/httpcomponents-client-4.5.x/tutorial/html/advanced.html#stateful_conn) a pooled connection may be associated with a user, for example if there is a client certificate involved such as with mutual TLS. In that case it becomes necessary to select a user token for each request to ensure only pooled connections for that user may be re-used.  There is a `UserTokenHandler` strategy in Apache HttpComponents but in the 4.5.x branch that is only used to associate an already established connection with the local user. So that strategy alone can't be used as a solution (e.g. to use a fixed single identity) and applications have to set the user token on the `ClientContext` before each request. Currently the only way to do that with the `RestTemplate` is by overriding `HttpComponentsClientHttpRequestFactory#createHttpContext`.   All this is not easy to find, here are some example SO threads [[1]](https://stackoverflow.com/questions/57201434/spring-resttemplate-does-not-allow-for-persistent-https-connections) and [[2]](https://stackoverflow.com/questions/32819709/http-client-4-5-not-reusing-the-same-connection-using-pooling-connection-manager) and even then having to override a protected method along with lack of any guidance feels less than ideal.   We can't remove the need for an application to decide which request is associated with which user but we can make this a little easier and better supported by allowing a fixed user token to be configured on `HttpComponentsClientHttpRequestFactory` or accepting a `BiFunction` to create the `HttpContext` for each request that would at least eliminate the need to extend. We can also improve the Javadoc to provide concrete pointers for those cases.","closed","type: enhancement,","rstoyanchev","2020-05-13T15:54:14Z","2020-05-24T20:26:59Z"
"","25770","MimeMessageHelper should not encode attachment filenames by default","As a follow-up to #25755, the `MimeUtility.encodeText(attachmentFilename)` call should be skipped by default through setting the newly introduced `encodeFilenames` property to `false` by default in the 5.3 line (while it remains at `true` in 5.2.9).","closed","type: enhancement,","jhoeller","2020-09-14T19:55:11Z","2020-09-14T20:42:44Z"
"","25580","Declare interfaces as @FunctionalInterface where feasible","As a follow up to #25571, in my opinion, the following are the remaining potential candidates for being annotated with `@FunctionalInterface`, especially the first two.  - `org.springframework.context.ApplicationContextInitializer` - `org.springframework.test.web.servlet.DispatcherServletCustomizer` - `org.springframework.validation.MessageCodeFormatter` - `org.springframework.util.IdGenerator` - `org.springframework.beans.factory.config.YamlProcessor.MatchCallback` - `org.springframework.beans.factory.config.YamlProcessor.DocumentMatcher`","closed","type: enhancement,","sbrannen","2020-08-11T14:38:10Z","2020-08-11T15:27:32Z"
"","25344","Avoid using LiveBeansView in GraalVM native images","As a follow up of #25179, this issue intend to avoid using `LiveBeansView` (not anymore used in Spring Boot, mainly used via STS) when running as native image.","closed","","sdeleuze","2020-06-30T12:41:13Z","2020-07-27T10:22:57Z"
"","25771","Add kotlinx.serialization JSON support to Spring WebFlux","As a follow up of #21188, we should add support for [kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization) JSON to WebFlux. This will not support `Flow` decoding because the library does not support yet [non-blocking parsing of JSON tokens like Jackson does](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java).","closed","type: enhancement,","sdeleuze","2020-09-14T21:34:37Z","2020-10-06T21:03:17Z"
"","25024","Drop unnecessary intermediate StringBuilder.toString() call in ServerSentEventHttpMessageReader","Apart from simplification this transformation is likely to bring faster code which consumes less memory.","closed","type: enhancement,","stsypanov","2020-05-07T09:41:40Z","2020-05-18T18:51:23Z"
"","25754","@Autowired/@Resource dose not work when bean implements BeanFactoryPostProcessor","Annotation-drived auto injection dose not work for bean instantiation if the bean implements `BeanFactoryPostProcessor` interface. Both `ClassPathXmlApplication` and `AnnotationConfApplicationContext` met this problem, I think wether this should be spring's bug or not. Here are tow examples helping to reproduce:  **By XML**  ```java package autoinject;  public class BusinessService { } ```  ```java package autoinject;  import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.config.BeanFactoryPostProcessor; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  public class SampleBeanFactoryPostProcessor implements BeanFactoryPostProcessor {      @Autowired     private BusinessService businessService;      public BusinessService getBusinessService() {         return businessService;     }      public void setBusinessService(BusinessService businessService) {         this.businessService = businessService;     }      @Override     public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {      } } ```  ```xml                                     ```  ```java package autoinject;  import org.junit.Assert; import org.junit.Test; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext;  public class AutoInjectTest {      @Test     public void testAutoInject() {         ConfigurableApplicationContext appContext = new ClassPathXmlApplicationContext(""classpath:autoinject.xml"");         SampleBeanFactoryPostProcessor beanFactoryPostProcessor = (SampleBeanFactoryPostProcessor) appContext.getBean(""sampleBeanFactoryPostProcessor"");         Assert.assertNotNull(""NOT INJECTED!!!"", beanFactoryPostProcessor.getBusinessService());     }  } ```  Output: ```shell ...... java.lang.AssertionError: NOT INJECTED!!!  	at org.junit.Assert.fail(Assert.java:89) 	at org.junit.Assert.assertTrue(Assert.java:42) ...... ```  Property `businessService` is not auto injected for bean `sampleBeanFactoryPostProcessor`.  **By Annotation**  ```java package annotationautoinject;  import org.springframework.stereotype.Component;  @Component public class BookDao { } ```  ```java package annotationautoinject;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component;  @Component public class BusinessService {      @Autowired     private BookDao bookDao;      public BookDao getBookDao() {         return bookDao;     }      public void setBookDao(BookDao bookDao) {         this.bookDao = bookDao;     }  } ```  ```java package annotationautoinject;  import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.config.BeanFactoryPostProcessor; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.stereotype.Component;  @Component public class SampleBeanFactoryPostProcessor implements BeanFactoryPostProcessor {      @Autowired     private BusinessService businessService;      public BusinessService getBusinessService() {         return businessService;     }      public void setBusinessService(BusinessService businessService) {         this.businessService = businessService;     }      @Override     public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {      } } ```  ```java package annotationautoinject;  import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration;  @Configuration @ComponentScan(basePackageClasses = Main.class) public class Main { } ```  ```java package annotationautoinject;  import org.junit.Assert; import org.junit.Test; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext;  public class AnnotationAutoInjectTest {      @Test     public void testAutoInject() {         ConfigurableApplicationContext appContext = new AnnotationConfigApplicationContext(Main.class);         BusinessService businessService = (BusinessService) appContext.getBean(""businessService"");         Assert.assertNotNull(""businessService IS NULL!!!"", businessService);         Assert.assertNotNull(""bookDao IS NOT INJECTED!!!"", businessService.getBookDao());         SampleBeanFactoryPostProcessor beanFactoryPostProcessor = (SampleBeanFactoryPostProcessor) appContext.getBean(""sampleBeanFactoryPostProcessor"");         Assert.assertNotNull(""sampleBeanFactoryPostProcessor IS NULL!!!"", beanFactoryPostProcessor);         Assert.assertNotNull(""businessService IS NOT INJECTED!!!"", beanFactoryPostProcessor.getBusinessService());     }  } ```  Output: ```shell ...... java.lang.AssertionError: businessService IS NOT INJECTED!!!  	at org.junit.Assert.fail(Assert.java:89) 	at org.junit.Assert.assertTrue(Assert.java:42) ...... ```  Property `businessService` is not auto injected for bean `sampleBeanFactoryPostProcessor`, but property `bookDao` is injected for bean `businessService`.  Tested spring version: `2.5.5`, `3.1.0`, `4.3.10`, `5.2.8`  Please help to confirm this problem, thanks.","closed","in: core,","liuming-dev","2020-09-11T08:26:51Z","2020-09-11T08:41:51Z"
"","24994","Preserve Http Response Info When MessageConverter Not Found Case","And Introduce Detail Purpose When Response Could Not Extract  https://github.com/spring-projects/spring-framework/issues/24964","closed","status: superseded,","devinabyss","2020-04-29T21:18:12Z","2020-05-07T07:42:22Z"
"","25282","Allow configuration of binary body printing in mock responses","Although there have been multiple issues over the years, trying to address this issue, the actual problem is still not solved and even for the cases it is, many might not find the output valuable in the way it is done.  Specifically, the issue of printing binary response body data either not at all or in a way that doesn't potentially mess up the users' terminal or is otherwise useless is still not solved at all and hasn't been addressed so far.  For requests (`MockHttpServletRequest`), preventing the output of binary data seems to work because: 1. the default value for field `characterEncoding` is `null` 2. the bean setter method id being called during tests by `MockHttpServletRequestBuilder`, which also means it actually can be influenced  For responses (`MockHttpServletResponse`), the same is impossible, because: 1. the field `characterEncoding` by default is `ISO-8859-1` 2. there seems to be no code that ever could set this field to `null` (only to other non-null values), except for the `reset()` method, which doesn't seem to be used  In addition, I personally have had many cases over the years where it would have been nice to see binary contents printed as standard base64, truncated to a configurable maximum length, so the console or CI logs don't get flooded.  This missing feature lead me to implement similar printf-code in tests over dozens of projects over and over again.","open","in: test,","ancoron","2020-06-18T21:58:45Z","2020-06-22T11:54:27Z"
"","25153","Provide a flag to disable SpEL support","Along to #25151, this issue intend to provide a `spring.spel.ignore` flag to disable SpEL support in a way that prevent it to be compiled intro GraalVM native images.  For the record this allows to reduce native image size by 1.4M, RSS memory consumption by 2M and build time by 5.5s with Java 8.  Usage of SpEL support with the flag enabled should trigger a proper exception with a message explaining how to re-enable it.  The work done on [spring-graalvm-native substitutions](https://github.com/spring-projects-experimental/spring-graalvm-native/tree/master/spring-graalvm-native-substitutions) has allows to identify a first set of classes where SpEL support should be removed:  - Remove `EventExpressionEvaluator` usage from `org.springframework.context.event.EventListenerMethodProcessor` and `org.springframework.context.event.ApplicationListenerMethodAdapter` - Remove `beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader());` from `org.springframework.context.support.AbstractApplicationContext`  Such flag could also be used on Spring Boot side as well if needed.","closed","type: enhancement,","sdeleuze","2020-05-28T12:23:44Z","2021-01-06T18:41:25Z"
"","25808","Avoid repeated Charset resolution in MimeType","Along the lines of the `toString()` caching in #22340, we can also cache the resolved `Charset` instance in `MimeType`, in particular for repeated `getCharset()` calls in `if` conditions (which are quite common in our converter implementations).","closed","type: enhancement,","jhoeller","2020-09-23T15:22:47Z","2020-09-25T08:53:59Z"
"","25165","Deprecate InstantiationAwareBeanPostProcessorAdapter","Along the lines of gh-25147, we should also deprecate `InstantiationAwareBeanPostProcessorAdapter` and let the corresponding post-processors implement the `(Smart)InstantiationAwareBeanPostProcessor` interface direcly (relying on the default methods there).","closed","in: core,","jhoeller","2020-05-29T17:54:25Z","2020-05-29T21:08:47Z"
"","25264","Compatibility with JDK 16","Along the lines of #24517, this issue aims to track JDK 16 compatibility.  For the time being (i.e., during the 5.3.x time frame), we'll simply set up a CI build compiling and executing tests against JDK 16 early access builds.  At this time, however, we are waiting on support for JDK 16 in the following.  - [ASM](https://gitlab.ow2.org/asm/asm/issues/317911) - Gradle: https://github.com/gradle/gradle/issues/13481 and https://github.com/gradle/gradle/issues/14714","closed","in: core,","sbrannen","2020-06-17T10:44:10Z","2021-03-15T23:04:28Z"
"","25791","Provide path-based locale change interceptor in Spring MVC","Almost all the guidelines for developers suggests to switch languages using `LocaleChangeInterceptor` in such way:    --- How can we make language code be an essential part of URL? For example:     As it stands now, there are hacky ways to handle this using some combination of `Filters` and `Interceptors`.  ```java @Component public class PathVariableLocaleFilter extends OncePerRequestFilter {   private static final Logger LOG = LoggerFactory.getLogger(PathVariableLocaleFilter.class);    @Override   protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)         throws ServletException, IOException {     String url = defaultString(request.getRequestURI().substring(request.getContextPath().length()));     String[] variables = url.split(""/"");      if (variables.length > 1 && isLocale(variables[1])) {         LOG.debug(""Found locale {}"", variables[1]);         request.setAttribute(LOCALE_ATTRIBUTE_NAME, variables[1]);         String newUrl = StringUtils.removeStart(url, '/' + variables[1]);         LOG.trace(""Dispatching to new url \'{}\'"", newUrl);         RequestDispatcher dispatcher = request.getRequestDispatcher(newUrl);         dispatcher.forward(request, response);     } else {         filterChain.doFilter(request, response);     }   }    private boolean isLocale(String locale) {     //validate the string here against an accepted list of locales or whatever     try {         LocaleUtils.toLocale(locale);         return true;     } catch (IllegalArgumentException e) {         LOG.trace(""Variable \'{}\' is not a Locale"", locale);     }     return false;   } }  // -- public class LocaleAttributeChangeInterceptor extends HandlerInterceptorAdapter {   public static final String LOCALE_ATTRIBUTE_NAME = LocaleAttributeChangeInterceptor.class.getName() + "".LOCALE"";    @Override   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {      Object newLocale = request.getAttribute(LOCALE_ATTRIBUTE_NAME);     if (newLocale != null) {         LocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);         if (localeResolver == null) {             throw new IllegalStateException(""No LocaleResolver found: not in a DispatcherServlet request?"");         }         localeResolver.setLocale(request, response, StringUtils.parseLocaleString(newLocale.toString()));     }     // Proceed in any case.     return true;   } }  // -- @Configuration public class MvcConfiguration implements WebMvcConfigurer {   @Override   public void addInterceptors(InterceptorRegistry registry) {     registry.addInterceptor(new LocaleAttributeChangeInterceptor());   }    @Bean(name = ""localeResolver"")   public LocaleResolver getLocaleResolver() {     return new CookieLocaleResolver();   } } ```  There should be core framework support for something like this.","closed","in: web,","juliuskrah","2020-09-18T20:39:59Z","2022-05-31T11:15:33Z"
"","25847","Subclasses of UrlBasedViewResolver could avoid reflection when creating instances of View","All subclasses (I think) currently delegate creation of `View` instances to the parent class, which only knows the `View` class, so has to instantiate it reflectively. It would be nice for subclasses, which mostly know how to create their own, specific `View` instances, to be able to provide a `Supplier` instead, and for that to be the default behaviour.","closed","type: enhancement,","dsyer","2020-10-01T13:14:57Z","2020-10-06T14:56:45Z"
"","24977","Aggregate TestExecutionListener orders","Aggregated `TestExecutionListener` orders into `SpringTestExecutionListenerOrder`, in order to help third-party integrators when choosing the order for a new listener.  I have done two similar PRs in [spring-boot](https://github.com/spring-projects/spring-boot/pull/21133) and [spring-security](https://github.com/spring-projects/spring-security/pull/8436) projects.","closed","status: declined,","andreisilviudragnea","2020-04-26T12:56:31Z","2021-01-17T17:06:39Z"
"","25820","Deprecate LiveBeansView","After various discussions with Spring team and in #21327, we have decided to deprecate `LiveBeansView` in order to allow its removal in Spring Framework 6. Spring Boot doesn't use it anymore and we believe that this kind of feature should be addressed in the future on Spring Boot side, especially with actuators. This will allow a clearer separation of concerns between Framework and Boot which will likely benefits to the 2 projects and to the users. This will also improve consistency between JVM and native where it is disabled (see #25344).","closed","type: enhancement,","sdeleuze","2020-09-25T17:04:04Z","2020-09-25T18:07:33Z"
"","25348","Zombie socket file descriptors issue","After uprading from spring boot 2.3.0 to 2.3.1, our application in staging environment quickly reached linux maximum open files limit. Using `lsof -i 6 -p ` to check open file descriptors of the spring boot webflux application, there are lots this kind of open file descriptors: ``` java      898        ce-devel 2540u     sock                0,8       0t0     27988 protocol: TCPv6 java      898        ce-devel 2541u     sock                0,8       0t0     27989 protocol: TCPv6 java      898        ce-devel 2542u     sock                0,8       0t0     27990 protocol: TCPv6 java      898        ce-devel 2543u     sock                0,8       0t0     27991 protocol: TCPv6 java      898        ce-devel 2544u     sock                0,8       0t0     27992 protocol: TCPv6 java      898        ce-devel 2545u     sock                0,8       0t0     27993 protocol: TCPv6 java      898        ce-devel 2546u     sock                0,8       0t0     27994 protocol: TCPv6 java      898        ce-devel 2547u     sock                0,8       0t0     27995 protocol: TCPv6 java      898        ce-devel 2548u     sock                0,8       0t0     27996 protocol: TCPv6 java      898        ce-devel 2549u     sock                0,8       0t0     27997 protocol: TCPv6 java      898        ce-devel 2550u     sock                0,8       0t0     27998 protocol: TCPv6 java      898        ce-devel 2551u     sock                0,8       0t0     27999 protocol: TCPv6 java      898        ce-devel 2552u     sock                0,8       0t0     28000 protocol: TCPv6 java      898        ce-devel 2553u     sock                0,8       0t0     28001 protocol: TCPv6 java      898        ce-devel 2554u     sock                0,8       0t0     28002 protocol: TCPv6 java      898        ce-devel 2555u     sock                0,8       0t0     28003 protocol: TCPv6 java      898        ce-devel 2556u     sock                0,8       0t0     28004 protocol: TCPv6 java      898        ce-devel 2557u     sock                0,8       0t0     28005 protocol: TCPv6 java      898        ce-devel 2558u     sock                0,8       0t0     28006 protocol: TCPv6 java      898        ce-devel 2559u     sock                0,8       0t0     28007 protocol: TCPv6 java      898        ce-devel 2560u     sock                0,8       0t0     28008 protocol: TCPv6 java      898        ce-devel 2561u     sock                0,8       0t0     28009 protocol: TCPv6 java      898        ce-devel 2562u     sock                0,8       0t0     28010 protocol: TCPv6 ``` and the number keep increasing. Downgrading to spring boot 2.3.0 solved the problem.  This problem only occurs resides in applications where reactor netty based webclients are used with no special configuration: ```     @LoadBalanced     @Bean     public WebClient.Builder loadBalancedWebClient() {         return WebClient.builder();     }      @Primary     @Bean     public WebClient.Builder webClient() {         return WebClient.builder();     } ```   So I think the problem exists in `WebClient.Builder` or `reactor netty`. I think this is really a serious issue and stopped us from upgrading to newer version.   For your reference : https://serverfault.com/questions/1000338/in-lsof-output-what-are-those-sock-lines","closed","status: duplicate,","andyfromktm","2020-07-01T01:09:34Z","2020-07-01T05:58:58Z"
"","25606","Exception occurs when testing with TestNG 7.3.0","After upgrading TestNG from 7.1.0 to 7.3.0, tests fail with:  ``` java.lang.IllegalStateException: org.springframework.web.context.support.GenericWebApplicationContext@5567c481 has been closed already ```  I have tests that create multiple application contexts.  Is TestNG 7.3.0 supported?","closed","status: duplicate,","cdalexndr","2020-08-17T20:13:05Z","2020-10-16T10:32:41Z"
"","25674","Eager cancellation fails with WebClient","After this fix spring-projects/spring-framework@21d0696 ReactorHttpClientResponse has introduced a state manager to check on cancellation state.  I wonder if that fix needs to happen upstream in reactor or reactor netty yet but now you will throw the IllegalStateException with `""The client response body has been released already due to cancellation.""` if you do an equivalent of:  ```java ClientResponse r = webclient.post()                .uri(""/bla"")                .exchange()                .take(1)                .block() ```","closed","status: superseded,","smaldini","2020-09-01T23:28:46Z","2020-09-30T09:36:21Z"
"","25811","Add MariaDB to the supported database products for procedures and functions","After switching the database driver from `mysql-connector-java` to `mariadb-java-client` in one of our applications, stored procedures called with `SimpleJdbcCall` no longer worked and failed with an exception like `java.sql.SQLSyntaxErrorException: Incorrect number of arguments for PROCEDURE foo.bar; expected 12, got 0`.  After some investigation I noticed that the `CallMetaDataProviderFactory` has a list called `supportedDatabaseProductsForProcedures` (which contains `MySQL`, but not `MariaDB`) so `accessProcedureColumnMetaData` was set to `false` and `initializeWithProcedureColumnMetaData` was not called on the `CallMetaDataProvider`; thus no parameters where added to the procedure call, resulting in the `SQLSyntaxErrorException`.  So I think `MariaDB` should be added to the `supportedDatabaseProductsForProcedures`.","closed","type: enhancement,","queueseven","2020-09-24T13:31:21Z","2020-09-25T10:56:14Z"
"","25669","Avoid repeated calls to getPathWithinApplication from UrlPathHelper.getLookupPathForRequest","After looking at: ![Screenshot_20200901_084804](https://user-images.githubusercontent.com/7076477/91775993-e18db500-ec2f-11ea-9839-9f6a646c3e54.png) I think an easy optimisation exists `UrlPathHelper.getLookupPathForRequest(HttpServletRequest)`.  I notice that it calls `getPathWithinServletMapping` which calls `getPathWithinApplication`, later it decides it is not happy with the result and so calls `getPathWithinApplication` again.  I suspect it should be easy enough to change `getLookupPathForRequest` to first call `getPathWithinApplication` then pass that into `getPathWithinServletMapping`, if that doesn't return a satisfactory result return the already computed value of: `getPathWithinApplication`","closed","type: enhancement,","LukeButters","2020-08-31T22:51:49Z","2020-09-01T21:38:33Z"
"","25265","added possibility to extend ModelAttributeMethodArgumentResolver","Added possibility to extend ModelAttributeMethodArgumentResolver , in order to populate objects in same way, but with different set of data.  Example use-cases:  - I want to populate object with data from headers, instead of common set of fields for model attribute resolution; - I want to manipulate with field values before set them to POJO in controller in case of custom annotated object  This is pretty much available in non-flux ModelAttributeMethodProcessor (since we can extend that and override some methods)  Logic in this class pretty much complicated to copy-paste or write own resolver, so I guess it's better to allow reuse code with possibility to add own data to bind.","closed","type: enhancement,","tdanylchuk","2020-06-17T12:31:44Z","2020-08-06T16:29:16Z"
"","25097","BeanDefinitionDsl composition","Added new `beans` method to BeanDefinitionDsl, to allow nesting beans definitions. Currently it's not possible.","open","in: core,","krzykrucz","2020-05-18T18:03:34Z","2021-11-11T09:51:11Z"
"","25356","Added a method to ignore null values when copying bean properties.","Added a method to ignore null values when copying bean properties","closed","in: core,","gauravat16","2020-07-05T12:30:34Z","2021-12-10T23:07:44Z"
"","25571","Declare MessagePostProcessor as a @FunctionalInterface","Add the FunctionalInterface annotation to the MessagePostProcessor interfaces in the spring-jms and spring-messaging projects.","closed","type: enhancement,","marschall","2020-08-09T11:53:07Z","2020-08-10T09:37:23Z"
"","24849","Add ability to register additional extensions with @SpringJUnitConfig","Add the ability to provide additional extensions when using `@SpringJunitConfig`  The convenience annotation is nice but can't be used when there's more than 1 extension. A common example of this would be utilizing LocalStack:  ``` @ExtendWith({SpringExtension.class, LocalstackDockerExtension.class}) ``` Note that multiple `@ExtendWith` annotations are supported but supporting multiple within `@SpringJunitConfig` would be a nice addition/convenience to reduce the amount of annotations ... especially since tests often have several on the class already.","closed","status: invalid,","dustinschultz","2020-04-02T14:31:15Z","2020-04-02T15:40:26Z"
"","24930","Support multi-module path pattern in FreeMarkerConfigurationFactoryBean","add support for multi-module project path pattern fixes #24929","open","type: enhancement,","lonecloud","2020-04-18T15:30:17Z","2021-12-06T14:24:07Z"
"","24866","Add Encoder and Decoder for Netty ByteBuf","Add support for encoding and decoding of `ByteBuf`, see #24615.","closed","type: enhancement,","encircled","2020-04-05T18:03:21Z","2020-05-05T17:22:35Z"
"","25827","Document DefaultPartHttpMessageReader","Add reference documentation for the DefaultPartHttpMessageReader.","closed","in: web,","poutsma","2020-09-28T08:18:03Z","2020-09-28T08:57:48Z"
"","25651","Add logPrefix to the log statement","Add logPrefix to the log statement to provide better debugging experience","closed","type: task,","violetagg","2020-08-26T13:38:29Z","2021-05-07T09:01:29Z"
"","25852","Add Dependencies Manifest Entry to spring-core","Add a Dependencies manifest entry with the value jdk.unsupported to spring-core.  Objenesis repackaged in Spring Core needs access to `sun.reflect.ReflectionFactory` located in the `jdk.unsupported` module. WildFly by default restricts applications from accessing the `jdk.unsupported` module ([WFCORE-4055](https://issues.redhat.com/browse/WFCORE-4055)). This leads to obscure exceptions like #21528. In our case the default constructor of a Spring Batch job scoped bean could not be found. This was confusing because the bean had an autowired non-default constructor. The problem and solution were not obvious to us.  To give Objenesis in spring-core access to the `jdk.unsupported` module users need to do either of the following:  - Add a [Dependencies](https://docs.wildfly.org/20/Developer_Guide.html#dependencies-manifest-entries) manifest entry to the application or module itself - Use [jboss-deployment-structure.xml](https://docs.wildfly.org/20/Developer_Guide.html#jboss-deployment-structure-file)  As Spring Core uses a repackaged Objenesis we can instead add the `Dependencies` manifest header to spring-core itself making things ""just work""(tm) for Spring users on WildFly.","closed","type: enhancement,","marschall","2020-10-02T16:33:15Z","2021-01-07T14:45:44Z"
"","25813","Support custom TimeUnits in StopWatch","Add `TimeUnit` support in `StopWatch` util class.  - Provide `StopWatch#getLastTime` and `StopWatch#getTotalTime` - Modify the print format for tasks  / include default `TimeUnit` in nanoseconds  See #25803","open","type: enhancement,","ak98neon","2020-09-24T19:47:57Z","2021-12-10T14:40:25Z"
"","25737","Issue with Forwarded Header and Multiple Values","According to the [RFC7239 specification](https://tools.ietf.org/html/rfc7239), syntax for **Forwarded Header** is as follows: `Forwarded: by=;for=;host=;proto=`  This values are used by Spring (all recent versions), if present, in order to reflect the client-originated protocol and address (when allowed through a configuration). There is a problem when using multiple values in this header: ``` # Multiple values can be appended using a comma Forwarded: for=192.0.2.43,for=198.51.100.17;proto=https;host=xxx.yyy.com;by=10.97.9.10 ```  The code in `UriComponentsBuilder#adaptFromForwardedHeaders:798-800` is getting the first **Forwarded Header**, if multiple are found, split it by comma and use only the first part: https://github.com/spring-projects/spring-framework/blob/a4dc13a0435484d5704e72a94a4e41c690afb381/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L800  In our case we have result value - `Forwarded: for=192.0.2.43` where all useful information is trimmed. Is this really an issue or there is something that I am missing?","closed","type: bug,","zdravko-nestorov","2020-09-08T09:37:08Z","2020-09-10T12:00:01Z"
"","25538","Use lowercase property names in SpEL examples","According to java code conventions","closed","in: core,","quaff","2020-08-06T01:21:48Z","2020-10-27T10:50:18Z"
"","24980","Cache meta-annotations for stereotype check in AnnotationBeanNameGenerator","According to https://github.com/spring-projects/spring-framework/issues/23905#issuecomment-604134669, the `getMetaAnnotationTypes` usage in `AnnotationBeanNameGenerator` turned into a bottleneck since `getMetaAnnotationTypes` is implemented using on-demand retrieval now. As a consequence, we should cache its result for the stereotype check in `AnnotationBeanNameGenerator`.","closed","type: enhancement,","jhoeller","2020-04-27T11:34:37Z","2020-04-27T11:48:35Z"
"","25473","3.2.x","aaaaa","closed","status: invalid,","Loveinglin","2020-07-24T15:47:34Z","2020-07-24T15:50:16Z"
"","25411","Introduce abstraction for unified handling of bound request payload and validation errors","A typical controller method to process a request body currently looks something like this:  ```java class MyController {    @PostMapping(""/comments"")   HttpEntity postComment(@Valid @RequestBody CommentDto payload, Errors errors) { … } } ```  The method separates the concept of a validated request body into the actual payload as well as potentially occurred binding and validation errors as a separate object. However, there is an implicit requirement of the `Errors` instance having to follow the `@RequestBody` annotated object immediately as there could potentially multiple ones involved in a single request.  It would be cool if there was a single type that could be declared on a handler method that captures the individual aspects involved here:  ```java class MyController {    @PostMapping(""/comments"")   HttpEntity postComment(Payload payload) { … } } ```  That type would expose both the mapped target object (`CommentDto`) as well as the `Errors` to the controller method. Ideally, that framework provided abstraction could then in turn be transformable into a user defined type, that could the provide specialized API to process the request. E.g. in a project I recently used a monadic type to define the processing in a pipeline-like way:  ```java return MappedPayloads.of(payload, errors)   .notFoundIf(…)                                   // always turn into 404 if predicate matches   .map((it, err) -> representations.from(it, err)) // *always* invoke translation into domain object potentially producing additional errors   .mapIfValid(repository::save)                    // invoke business operations on the entity (only if no errors have been accumlated so far)   .mapIfValid(representations::toRepresentation)   // produce representation from result of the business operation   .concludeIfValid(ResponseEntity::ok);            // prepare response ```  The fundamental idea of that is that processing steps can accumulate additional errors and only execute the `mapIfValid(…)` steps and eventually end up in `concludeIfValid(…)` if no errors have been accumulated until that. If at least one error has occurred, a `ResponseEntity` with the `Errors` instance (to be processed by an `HttpMessageConverter`) would be created. A `404 Not Found` would be produced if the `notFoundIf(…)` guard kicks in.  As this is a highly opinionated way of processing requests, I think a reasonable balance is to allow users to declare such a type in a way that Spring MVC can actually produce it as handler method argument. The current arrangement of `HandlerMethodArgumentResolvers` unfortunately doesn't allow that.  A framework provided, unified type (like `Payload` shown above) plus a dedicated mapping step into user code space would solve that issue. I was wondering if, in case the user type could carry some annotation plus/or a dedicated factory method to be constructed from a `Payload`, that mapping step could be invoked by Spring MVC's argument resolution. E.g. a declaration of `MappedPayload` like this:  ```java class MappedPayload {    static  MappedPayload of(Payload payload) { … }    … } ```  would allow `MappedPayload` be immediately used like this:  ```java class MyController {    @PostMapping(""/comments"")   HttpEntity postComment(MappedPayload payload) { … } } ```","closed","type: enhancement,","odrotbohm","2020-07-17T14:40:55Z","2022-07-05T10:34:17Z"
"","25531","Possible optimization in UrlResource","`UrlResource` computes a `cleanedUrl` in its constructor, but only uses it in a small number of methods (e.g. `hashCode()`). It has some `String` manipulations in it that can be expensive, so it might make sense to compute it lazily.  Some benchmarks (instantiate a `FileUrlResource` and check if it `exists()`):  ``` class                                method   median      mean        range com.example.bench.ResourceBenchmark  lazy     441889.554  460384.372  16671.778 com.example.bench.ResourceBenchmark  default  415765.658  440910.870  18462.893 ```  I think the fact that the median comparison is much more dramatic is probably because of garbage collection, which is quite noisy, and would be more common in the default case.  Spring Boot computes quite a few of these `FileUrlResources` on startup as it searches for `application.properties` files. The difference is just about noticeable (a few milliseconds on startup, and fewer GC failures).","closed","type: enhancement,","dsyer","2020-08-05T09:46:06Z","2020-08-07T11:34:31Z"
"","25100","Make use of HttpServletMapping when available","`UrlPathHelper` determines the portion of the path to use for application mappings which is the path after the contextPath and after a servletPath prefix.  The determination of the servletPath prefix is difficult and inherently fragile. It depends on the Servlet mapping type, which is not known at runtime (prior to Servlet 4.0). Furthermore, the servletPath is decoded and normalized while the full path [requestURI](https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletRequest.html#getRequestURI--) is neither, so the `requestURI` must be decoded to be comparable but that can result in additional `/` or `;` which can change the path, and so can normalizations by Servlet containers.  One way out is to set `alwaysUseFullPath=true` on `UrlPathHelper` which only deals with the contextPath and that's fine for the most common, default Servlet mapping `""/"". It's only the Servlet mapping by path prefix that requires a determination of the Servlet path but that's less common and historic.  In Servlet 4.0, the request exposes [HttpServletMapping](https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletMapping.html) with details about the current mapping including the Servlet mapping pattern, the mapping type, and the part of the URL that matched. This does not solve the issues with determining the path after the servletPath, but knowing the mapping type can help to avoid looking for a servletPath prefix where there is none. Effectively for all [mapping types](https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/MappingMatch.html) except `MappingMatch.PATH` we can process as if `alwaysUseFullPath=true`.","closed","type: enhancement,","rstoyanchev","2020-05-19T05:58:49Z","2020-05-19T09:35:11Z"
"","24870","Improve performance of StringUtils.deleteAny()","`StringUtils.deleteAny()` can be improved in a trivial way to reduce bounds check and possible reallocations in `StringBuilder` by using `char[]`. This simple change demonstrates significant improvement. Benchmark: ```java @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(jvmArgsAppend = {""-Xms2g"", ""-Xmx2g"", ""-XX:+UseParallelGC""}) public class DeleteAnyBenchmark {    @Benchmark   public String original() {     return deleteAny(""key1=value1 "", ""\"""");   }    @Benchmark   public String patched() {     return deleteAnyPatched(""key1=value1 "", ""\"""");   }    private static String deleteAny(String inString, String charsToDelete) {     StringBuilder sb = new StringBuilder(inString.length());     for (int i = 0; i < inString.length(); i++) {       char c = inString.charAt(i);       if (charsToDelete.indexOf(c) == -1) {         sb.append(c);       }     }     return sb.toString();   }    private static String deleteAnyPatched(String inString, String charsToDelete) {     int lastCharIndex = 0;     char[] result = new char[inString.length()];     for (int i = 0; i < inString.length(); i++) {       char c = inString.charAt(i);       if (charsToDelete.indexOf(c) == -1) {         result[lastCharIndex++] = c;       }     }     return new String(result, 0, lastCharIndex);   }  } ``` and its results for Java 8 ``` Benchmark                                                     Mode  Cnt     Score     Error   Units DeleteAnyBenchmark.original                                   avgt   50    90.203 ±   4.317   ns/op DeleteAnyBenchmark.original:·gc.alloc.rate                    avgt   50   738.784 ±  31.462  MB/sec DeleteAnyBenchmark.original:·gc.alloc.rate.norm               avgt   50   104.000 ±   0.001    B/op DeleteAnyBenchmark.original:·gc.churn.PS_Eden_Space           avgt   50   750.517 ± 107.126  MB/sec DeleteAnyBenchmark.original:·gc.churn.PS_Eden_Space.norm      avgt   50   105.389 ±  14.303    B/op DeleteAnyBenchmark.original:·gc.churn.PS_Survivor_Space       avgt   50     0.030 ±   0.015  MB/sec DeleteAnyBenchmark.original:·gc.churn.PS_Survivor_Space.norm  avgt   50     0.004 ±   0.002    B/op DeleteAnyBenchmark.original:·gc.count                         avgt   50    83.000            counts DeleteAnyBenchmark.original:·gc.time                          avgt   50    84.000                ms DeleteAnyBenchmark.patched                                    avgt   50    25.391 ±   1.118   ns/op DeleteAnyBenchmark.patched:·gc.alloc.rate                     avgt   50  2622.055 ± 107.408  MB/sec DeleteAnyBenchmark.patched:·gc.alloc.rate.norm                avgt   50   104.000 ±   0.001    B/op DeleteAnyBenchmark.patched:·gc.churn.PS_Eden_Space            avgt   50  2606.384 ± 126.905  MB/sec DeleteAnyBenchmark.patched:·gc.churn.PS_Eden_Space.norm       avgt   50   103.466 ±   3.549    B/op DeleteAnyBenchmark.patched:·gc.churn.PS_Survivor_Space        avgt   50     0.066 ±   0.015  MB/sec DeleteAnyBenchmark.patched:·gc.churn.PS_Survivor_Space.norm   avgt   50     0.003 ±   0.001    B/op DeleteAnyBenchmark.patched:·gc.count                          avgt   50   287.000            counts DeleteAnyBenchmark.patched:·gc.time                           avgt   50   260.000                ms ```","closed","type: enhancement,","stsypanov","2020-04-06T12:19:16Z","2020-04-12T07:39:53Z"
"","25335","Leverage spring.ignore.xml flag to avoid SQLErrorCodeSQLExceptionTranslator","`SQLErrorCodeSQLExceptionTranslator` transitively uses `SQLErrorCodesFactory` which is using `XmlBeanDefinitionReader` to parse `sql-error-codes.xml`, triggering the usage of the XML parsing infrastructure that has a significant cost on GraalVM native images.  This issue is a follow up of #25151 and introduces the usage of `SQLExceptionSubclassTranslator` instead when `spring.ignore.xml` is `true`.","closed","type: enhancement,","sdeleuze","2020-06-29T18:34:58Z","2020-07-27T10:23:51Z"
"","25780","Resolve Principal argument only when not annotated","`ServletRequestMethodArgumentResolver` happend early in the `ArgumentResolver` chain. One of his ability is to resolve `Principal`, that's great and it works well.  But when a parameter of type `Principal` is annotated we don't want to get the `Principal` from the `HttpServletRequest.getUserPrincipal()`. This feature is even in conflict with the **spring-security** documentation and the [`@AuthenticationPrincipal`](https://docs.spring.io/spring-security/site/docs/4.2.15.RELEASE/apidocs/org/springframework/security/web/bind/annotation/AuthenticationPrincipal.html) annotation which is supposed to resolve the Principal from Authentication.getPrincipal().  Having the `ServletRequestMethodArgumentResolver` resolving annotated `Principal` makes the `@AuthenticationPrincipal` and `AuthenticationPrincipalArgumentResolver` useless and missleading.  Fix spring-projects/spring-security#4151","closed","type: enhancement,","anthonyraymond","2020-09-16T13:31:22Z","2022-03-30T21:26:47Z"
"","25386","Reconsider RequestMappingHandlerMapping automatically picking up types annotated with @RequestMapping on the type level","`RequestMappingHandlerMapping.isHandler(…)` not only picks up types annotated with `@Controller` but also ones that are annotated with `@RequestMapping` on the type level. This is problematic in cases in which other `HandlerMapping` instances are registered that might be supposed to handle those controllers.  A prominent example of this is Spring Data REST, which registers a dedicated mapping to expose HTTP resources for Spring Data repositories. Users can selectively override those resources by declaring a controller themselves and just declare a handler method for e.g. the URI of an item resource and an HTTP verb of choice. If that controller now declares an `@RequestMapping` on the type level, the Spring MVC registered one will pick up that class, and not see any other mappings defined for the same URI pattern but exposing support for other HTTP methods potentially available in subsequent `HanderMapping` implementations.  This is a pretty common error scenario reported by users (see [this StackOverflow](https://stackoverflow.com/questions/62865947/restrepositorycontroller-hide-rest-repository-endpoints/62877864) question for example). It's also pretty hard to explain to users as it involves talking about quite a few implementation details.  Removing the explicit handling of `@RequestMapping` on the type level bears the risk that controller implementations not also being annotated with `@Controller` would not be picked up automatically anymore. I haven't found any Spring MVC related documentation that actually shows an example of code not using the annotations in combination when used at the type level. A fix for that issue would be to also annotate the affected controller type with `@Controller`. I can see this being suboptimal for a release in a minor version but for 6.0 we should at least reevaluate.","closed","status: duplicate,","odrotbohm","2020-07-13T14:29:00Z","2020-07-14T12:01:58Z"
"","24959","Use WebsocketServerSpec in ReactorNettyRequestUpgradeStrategy","`ReactorNettyRequestUpgradeStrategy` has properties that are passed as parameters to `HttpServerResponse#sendWebSocket` during WebSocket upgrades. In 0.9.5 Reactor Netty added `WebsocketServerSpec` as a way of passing any number of parameters. It is no longer possible to avoid use of this new API because it's the only way to pass some parameters, e.g. `compress`, based on #24903.   We can switch to  `WebsocketServerSpec` and deprecate the properties in `ReactorNettyRequestUpgradeStrategy` which does mean that use of Reactor Netty 0.9.5 will be required as of 5.2.6 but that is highly advisable in any case due to [CVE-2020-5403](https://tanzu.vmware.com/security/cve-2020-5403) and [CVE-2020-5404](https://tanzu.vmware.com/security/cve-2020-5404).","closed","type: enhancement,","rstoyanchev","2020-04-23T06:55:09Z","2020-04-23T12:50:41Z"
"","25616","Introduce ApplicationEvents abstraction to capture application events published during a test","`PublishedEventsExtension` registers a composite `ApplicationListener` backed by thread-bound individual listeners to capture all application events published during the execution of a test method. Those would declare a `PublishedEvents` parameter to the method which provides API to define assertions based on the events published:  ```java @ExtendWith(PublishedEventsExtension.class) class SampleTests {    @Test   void someTestMethod(PublishedEvents events) {      // Filter events by type and predicate     assertThat(events.ofType(MyEventType.class).matching(it -> …)).hasSize(2);   } } ```","closed","type: enhancement,","odrotbohm","2020-08-19T20:26:08Z","2020-12-21T14:03:25Z"
"","25369","MutablePropertySources will not find or remove proxied sources","`MutablePropertySources` has `get` and `remove` methods that look like this:  ```java @Override @Nullable public PropertySource get(String name) { 	int index = this.propertySourceList.indexOf(PropertySource.named(name)); 	return (index != -1 ? this.propertySourceList.get(index) : null); } ```  These attempt to find the index of a property source index by checking for the name. The `PropertySource.named` method returns a `ComparisonPropertySource` which depends on the inherited `PropertySource` `equals` and `hashCode` implementations.  The equals method looks like this:  ```java 	@Override 	public boolean equals(@Nullable Object other) { 		return (this == other || (other instanceof PropertySource && 				ObjectUtils.nullSafeEquals(this.name, ((PropertySource) other).name))); 	} ```  If you are using a library such as [jasypt](http://www.jasypt.org/), it's possible that your property source will be a proxy instance and won't actually contain a populated `name` field. The equals method could use `((PropertySource) other).getName()))` which would solve this issue.","closed","type: enhancement,","philwebb","2020-07-08T01:18:53Z","2020-07-17T16:00:52Z"
"","25520","Standalone MockMvc ignores @RestControllerAdvice annotation attributes","`MockMvc` created by `MockMvcBuilders.standaloneSetup()` ignores `@RestControllerAdvice` annotation attributes but works well for a `@ControllerAdvice`/`ResponseBody` pair.  - Spring Boot: 2.3.2 - Spring Framework: 5.2.8  Example: https://github.com/thecederick/MockMvc-ignores-RestControllerAdvice-annotation-fields  ### Failing Configuration  Controller:  ```java @RestController @RequestMapping public class Api1Controller {      @PostMapping(value = ""/endpoint1"")     public String endpoint() {         return ""done"";     } } ```  Controller advice:  ```java @RestControllerAdvice(assignableTypes = Api1Controller.class) @Order(Ordered.HIGHEST_PRECEDENCE) public class Api1ControllerAdvice {      @ExceptionHandler(Throwable.class)     public String handleException(Throwable throwable) {         return this.getClass() + "" - "" + throwable.getClass();     } } ```  Test:  ```java     @BeforeEach     public void setup() {         this.mockMvc = MockMvcBuilders                 .standaloneSetup(controller)                 .addDispatcherServletCustomizer(                         dispatcherServlet -> dispatcherServlet.setThrowExceptionIfNoHandlerFound(true))                 .setControllerAdvice(Api1ControllerAdvice.class, DefaultControllerAdvice.class)                 .build();     }      @Test     void notFound() throws Exception {         mockMvc                 .perform(                         post(""/test"")                                 .contentType(""application/json"")                                 .content(""{}""))                 .andExpect(content().string(                         ""class com.example.demo.root.DefaultControllerAdvice - class org.springframework.web.servlet.NoHandlerFoundException""));     } ```  ### Working Configuration  ```java @RestController @RequestMapping public class Api2Controller {      @PostMapping(value = ""/endpoint2"")     public String endpoint() {         return ""done"";     } } ```  Controller advice:  ```java @ControllerAdvice(assignableTypes = Api2Controller.class) @ResponseBody @Order(Ordered.HIGHEST_PRECEDENCE) public class Api2ControllerAdvice {      @ExceptionHandler(Throwable.class)     public String handleException(Throwable throwable) {         return this.getClass() + "" - "" + throwable.getClass();     } } ```  Test:  ```java     @BeforeEach     public void setup() {         this.mockMvc = MockMvcBuilders                 .standaloneSetup(controller)                 .addDispatcherServletCustomizer(                         dispatcherServlet -> dispatcherServlet.setThrowExceptionIfNoHandlerFound(true))                 .setControllerAdvice(                         Api2ControllerAdvice.class,                         DefaultControllerAdvice.class)                 .build();     }      @Test     void notFound() throws Exception {         mockMvc                 .perform(                         post(""/test"")                                 .contentType(""application/json"")                                 .content(""{}""))                 .andExpect(content().string(                         ""class com.example.demo.root.DefaultControllerAdvice - class org.springframework.web.servlet.NoHandlerFoundException""));     } ```  ### Default advice  ```java @RestControllerAdvice @Order(Ordered.LOWEST_PRECEDENCE) public class DefaultControllerAdvice {      @ExceptionHandler(Throwable.class)     public String handleException(Throwable throwable) {         return this.getClass() + "" - "" + throwable.getClass();     } } ```  ### Summary  In the first configuration using the `@RestControllerAdvice` annotation the test fails; with the second one, it passes as expected.","closed","type: regression,","thecederick","2020-08-04T08:20:17Z","2020-08-06T07:18:40Z"
"","25809","Optimize String argument resolution in MessageTag","`MessageTag.resolveArguments` contains old logic for checking a single String array element which seems to be dead code since a String element can never be an array itself, making all the differentiation pointless since we'll always return the given String anyway. Streamlining this towards a straight return of the original String array is not only easier to read but also avoids wasting CPU cycles.","closed","type: enhancement,","jhoeller","2020-09-23T15:51:34Z","2020-10-16T13:45:52Z"
"","25828","Support for an async determination of status and headers with a WebMvc HandlerFunction","`HandlerFunction` returns `ServerResponse` which supports providing a `Publisher` or `CompletableFuture` for the body but there is no way to determine the response status and headers asynchronously like there is in WebFlux where the return value is `Mono","closed","type: enhancement,","rstoyanchev","2020-09-28T15:08:17Z","2020-10-02T08:43:26Z"
"","25033","InvocableHandlerMethod incorrectly resolves arguments by type","`getMethodArgumentValues()` performs early argument resolution by type; even when parameters are annotated and should be resolved by the resolvers.  ```java @Test void testInvocableHandlerMethod() throws Exception { 	TestClass bean = new TestClass(); 	InvocableHandlerMethod handler = messageHandlerFactory().createInvocableHandlerMethod(bean, 			TestClass.class.getDeclaredMethod(""defMethod"", Object.class, String.class)); 	handler.invoke(new GenericMessage(""foo"", Collections.singletonMap(""bar"", ""baz"")), ""foo""); 	assertThat(bean.object).isEqualTo(""foo""); 	assertThat(bean.bar).isEqualTo(""baz""); }  private MessageHandlerMethodFactory messageHandlerFactory() { 	DefaultMessageHandlerMethodFactory defaultFactory = new DefaultMessageHandlerMethodFactory(); 	DefaultFormattingConversionService cs = new DefaultFormattingConversionService(); 	defaultFactory.setConversionService(cs); 	GenericMessageConverter messageConverter = new GenericMessageConverter(cs); 	defaultFactory.setMessageConverter(messageConverter); 	defaultFactory.afterPropertiesSet(); 	return defaultFactory; }  public static class TestClass {  	Object object;  	String bar;  	public void defMethod(Object obj, @Header(""bar"") String bar) { 		this.object = obj; 		this.bar = bar; 	}  } ```  Both parameters are resolved via the `providedArgs` (`foo`, `foo`).  Manifested [in this Spring for Apache Kafka issue](https://github.com/spring-projects/spring-kafka/issues/1479).  I can probably work around it in spring-kafka by subclassing  and overriding `findProvidedArgument()`  to ignore parameters with `@Header` annotations, but thought I should raise it here because the same issue would apply to other `messaging` apps.  Oops - `findProvidedArgument` is static, and I can't override `getMethodArgumentValues` because it uses private fields.","closed","in: messaging,","garyrussell","2020-05-07T20:02:48Z","2020-05-26T17:38:55Z"
"","25751","Deprecate WebClient#exchange() and provide safer alternatives","`exchange()` provides more flexibility than `retrieve()` but leaves the full handling of the response to the application and it remains difficult to use it correctly in order to avoid memory and connection leaks. `retrieve()` is safer because it wraps the handling of the response (and the framework can ensure correct release of resources) and since 5.2 with access to the response status and headers via `ResponseEntity`, `retrieve()` can cover all of common use cases.   The actual reasons for using `exchange()` are few. One example is the ability to suppress an error status and produce either a typed object from a successful response or a different object from an error response with the output consumed as `Mono`. However `exchange()` continues to be used much more widely than that.  It is time to provide a safer alternative to `exchange()` that retains the same flexibility but allows the WebClient to be involved in the handling of the response. For example:  ```java  Mono exchangeToMono(Function responseHandler);   Flux exchangeToFlux(Function responseHandler); ```  We can then deprecate `exchange()` and remove it in the next major version.","closed","type: enhancement,","rstoyanchev","2020-09-10T16:04:42Z","2021-02-10T06:02:52Z"
"","25166","BeanCurrentlyInCreationException with DelegatingWebFluxConfiguration","`DelegatingWebFluxConfiguration` can trigger `BeanCurrentlyInCreationException` under a few circumstances.  # ReactiveAdapterRegistry  The first problem is that it is difficult to provide a `HandlerMethodArgumentResolver` that needs the `ReactiveAdapterRegistry` because this can cause a cycle depending on the order the beans are instantiated. For example, [this test](https://github.com/rwinch/gh-8596/blob/1f500adcc65fd1b4af6a8ed06bc4753419306d03/src/test/java/com/example/demo/MinimalTest.java#L30) produces a cycle:  1. [`authenticationPrincipalArgumentResolver`](https://github.com/rwinch/gh-8596/blob/1f500adcc65fd1b4af6a8ed06bc4753419306d03/src/main/java/com/example/demo/ArgumentResolverConfig.java#L33) is requested 1. It triggers the creation of [`ReactiveAdapterRegistry`](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webflux/src/main/java/org/springframework/web/reactive/config/WebFluxConfigurationSupport.java#L368) which is a dependant bean 1. In order to create `ReactiveAdapterRegistry`, `DelegatingWebFluxConfiguration` needs to be created which [requires all `WebFluxConfigurer`](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webflux/src/main/java/org/springframework/web/reactive/config/DelegatingWebFluxConfiguration.java#L46) instances to be wired into it. 1. This tries to retrieve all `WebFluxConfigurer` instances. One of which is [`authenticationPrincipalArgumentResolverConfigurer`](https://github.com/rwinch/gh-8596/blob/1f500adcc65fd1b4af6a8ed06bc4753419306d03/src/main/java/com/example/demo/ArgumentResolverConfig.java#L22) which provides our `authenticationPrincipalArgumentResolver` bean as an argument resolver. 1. This requests  [`authenticationPrincipalArgumentResolver`](https://github.com/rwinch/gh-8596/blob/1f500adcc65fd1b4af6a8ed06bc4753419306d03/src/main/java/com/example/demo/ArgumentResolverConfig.java#L33) which is a cycle  One option to make this less likely to happen is to define `authenticationPrincipalArgumentResolverConfigurer` as:  ```java @Bean public WebFluxConfigurer authenticationPrincipalArgumentResolverConfigurer( 		ObjectProvider authenticationPrincipalArgumentResolver) { 	return new WebFluxConfigurer() { 		@Override 		public void configureArgumentResolvers(ArgumentResolverConfigurer configurer) { 			configurer.addCustomResolver(authenticationPrincipalArgumentResolver.getObject()); 		} 	}; } ```  This delays the lookup of `AuthenticationPrincipalArgumentResolver`. However, this has a few drawbacks.   1. The first drawback is that while it reduces the likelihood of an error, it doesn't remove the cycle between `ArgumentResolverConfig` and  `WebFluxConfigurationSupport`. 2. Second, it requires every `AuthenticationPrincipalArgumentResolver` configuration needing `ReactiveAdapterRegistry` (I'd argue that is pretty much every `AuthenticationPrincipalArgumentResolver`) to have the burden of fixing the issue rather than decoupling the beans (`HandlerMethodArgumentResolver` and `ReactiveAdapterRegistry`) that are likely dependant on one another).  We could move the delay inside `DelegatingWebFluxConfiguration` by autowiring `ObjectProvider` instead. However, this only fixes the second problem and leaves the cycle present.  Another option is to make the definition of  [`ReactiveAdapterRegistry`](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webflux/src/main/java/org/springframework/web/reactive/config/WebFluxConfigurationSupport.java#L368) a static method. This would ensure that `DelegatingWebFluxConfiguration` does not need to be instantiated. Yet another option would be to move `ReactiveAdapterRegistry` to another configuration, but this could break other applications.  # ResourceUrlProvider Can Cause Early Initialization of DelegatingWebFluxConfiguration  [`ResourceUrlProvider`](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceUrlProvider.java#L53) implements `ApplicationListener` which can trigger early initialization of `DelegatingWebFluxConfiguration`. As soon as an `ApplicationEvent` is published, the ``ApplicationListener``s need initialized. Since `ResourceUrlProvider` is defined by `DelegatingWebFluxConfiguration` it initializes `DelegatingWebFluxConfiguration` and all of its dependant beans very early on.  This is what is why [the originally reported issue](https://github.com/spring-projects/spring-boot/issues/21580) would happen in Boot 2.3.0 and not in previous versions. Specifically the changes for https://github.com/spring-projects/spring-boot/issues/21325 moved the publishing of the `ReactiveWebServerInitializedEvent` from [finishRefresh](https://github.com/spring-projects/spring-boot/commit/240898121ff8a06d5e3fdc53f992b1130f81cc96#diff-f249c0158f71e311034decd03a274954L122) to ``SmartLifecycle``'s [`start`](https://github.com/spring-projects/spring-boot/commit/240898121ff8a06d5e3fdc53f992b1130f81cc96#diff-485f650bc0971880fc23ef5e4e4d2602R387) method. This changed the order that `DelegatingWebFluxConfiguration` was created and triggered the bean cycle to happen.  One solution is to move the `ResourceUrlProvider` bean definition to a static method.  **Related Issues**  - https://github.com/spring-projects/spring-boot/issues/21580 - https://github.com/spring-projects/spring-security/issues/8596","open","type: enhancement,","rwinch","2020-05-29T20:22:34Z","2022-06-07T08:39:05Z"
"","25682","Support for beans of a generic type in BeanFactoryAnnotationUtils","`BeanFactoryAnnotationUtils` currently only provides methods to extract beans by raw type. Overloaded methods that work with `ResolvableType` (for instance) would be helpful - they could be implemented using the `ObjectProvider` abstraction.","open","in: core,","dsyer","2020-09-03T06:24:33Z","2021-11-11T09:06:11Z"
"","25582","@Transactional does not work on package protected methods of CGLib proxies","`AnnotationTransactionAttributeSource` contains a flag whether to only consider public methods, set to `true` by default. I assume that stems from the times when JDK proxies where the primary way of applying proxies and with those only public methods can be intercepted anyway.  With CGLib proxies this is different. Package private methods *can* be invoked on the proxy and properly make their way through the AOP infrastructure. However, the lookup of transaction attributes is eagerly aborted due to the flag mentioned above. This creates confusing situations (assume `@EnableGlobalMethodSecurity` and `@EnableTransactionManagement` applied):  ```java @Component class MyClass {    @Secured(…)   @Transactional   void someMethod() { … } } ```  In this example, the security annotations *are* applied as the security infrastructure does not work with a flag like this and the advice is registered for the method invocation. The transactional annotations are *not* applied, as the method is not inspected for transactional annotations in the first place.  I wonder if it makes sense to flip the flag based on the `proxyTargetClass` attribute in `@EnableTransactionManagement`. If that is set to true, CGLib proxies are created and thus, transaction annotations should be regarded on package protected methods. This seems to be especially important in the context of Spring Boot setting this flag to `true` by default.  A current workaround is demonstrated in [this commit](https://github.com/quarano/quarano-application/commit/4d4e8239de7ee0a4a6b7ef4af1b8431932dee8b5), which uses a `PriorityOrdered` `BeanPostProcessor` to reflectively flip the flag, not considering any configuration as in that particular case we know we're always gonna run with CGLib proxies.","closed","type: enhancement,","odrotbohm","2020-08-12T16:37:19Z","2021-12-14T10:07:22Z"
"","25838","AbstractJackson2Decoder.decodeToMono should use non-blocking parser","`AbstractJackson2Decoder.decodeToMono` [currently uses `DataBufferUtils.join` to join all DataBuffers](https://github.com/spring-projects/spring-framework/blob/a6bede22c113e69206c13735dbf820c7cb043e2e/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java#L158), [converts the result to an input stream, and then uses jackson's blocking parser](https://github.com/spring-projects/spring-framework/blob/a6bede22c113e69206c13735dbf820c7cb043e2e/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java#L168).   This approach reads all DataBuffers for the entire payload into memory at the same time.  For large payloads, this is not memory efficient.  On the other hand, `AbstractJackson2Decoder.decode` uses jackson's non-blocking parser.  This approach does not require reading all buffers into memory at the same time.  i.e. each buffer can be processed individually, and released as it is parsed.  For larger payloads, I think it would be better if `decodeToMono` also used jackson's non-blocking parser.  This would allow each data buffer to be processed individually and released, rather than having to read the entire payload into memory.  Using the non-blocking parser would allow the `maxInMemorySize` to be increased to accommodate occasional large payloads, and allow the server to be more memory efficient when reading them.  It would also bring the behavior of JSON parsing in WebFlux more inline with the behavior of JSON parsing in WebMVC.  WebMVC's `AbstractJackson2HttpMessageConverter` does not read the entire payload into memory and does not enforce a `maxInMemorySize`.   FWIW, I started looking into this when I hit a `DataBufferLimitException` for some occasional large payloads.  I'd like to increase the `maxInMemorySize`, but then I noticed the consequence of loading everything into memory at the same time, which was a bit surprising since WebMVC doesn't have this limit.  What are your thoughts?","open","status: pending-design-work,","philsttr","2020-09-29T16:30:17Z","2020-10-03T21:49:20Z"
"","25022","Change to placeholder value in XML is not reevaluated at runtime","```java package com.example; public class PlainBean { 	private int value; 	public int getValue() { 		return value; 	} 	public void setValue(int value) { 		this.value = value; 	} } ``` ```xml   	 	  ``` ```java @RunWith(SpringRunner.class) @ContextConfiguration(locations = ""ctx.xml"") public class PlainBeanTest { 	@Autowired 	private ApplicationContext ctx; 	@Test 	public void test() { 		assertEquals(10, ctx.getBean(PlainBean.class).getValue()); // default value 		((ConfigurableEnvironment) ctx.getEnvironment()).getPropertySources() 				.addFirst(new MapPropertySource(""overriden"", Collections.singletonMap(""value"", ""12""))); 		assertEquals(12, ctx.getBean(PlainBean.class).getValue()); // test failed 	} }  ``` But test will pass if using `@Value(""${value:10}"")` instead of `p:value=""${value:10}""` , here is test project [ps.zip](https://github.com/spring-projects/spring-framework/files/4590718/ps.zip)","closed","in: core,","quaff","2020-05-07T04:30:57Z","2020-05-11T00:34:30Z"
"","25765","Support registration of null reference for BeanFactoryPostProcessor","```java import org.junit.jupiter.api.Test; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.core.env.Environment; import org.springframework.core.env.Profiles;  public class NullBeanDefinitionRegistryPostProcessorTest {  	@Test 	public void test() { 		try (AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext()) { 			ctx.register(TestConfiguration.class); 			// ctx.getEnvironment().setActiveProfiles(""enhancement"");  // uncomment it to pass test 			ctx.refresh(); 		} 	}  	static class TestConfiguration { 		@Bean 		protected static BeanDefinitionRegistryPostProcessor enhancementBeanDefinitionRegistryPostProcessor( 				Environment env) { 			if (env.acceptsProfiles(Profiles.of(""enhancement""))) { 				return new BeanDefinitionRegistryPostProcessor() { 					@Override 					public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) 							throws BeansException { 						// do some enhancement 					}  					@Override 					public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) 							throws BeansException { 						// do some enhancement 					} 				}; 			} else { 				return null; 			} 		} 	} } ```  ``` org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'enhancementBeanDefinitionRegistryPostProcessor' is expected to be of type 'org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor' but was actually of type 'org.springframework.beans.factory.support.NullBean' 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:399) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:119) 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:707) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:533) ```","closed","in: core,","quaff","2020-09-14T08:17:41Z","2020-09-17T12:45:36Z"
"","24963","GenericTypeResolver.resolveType() should resolve ParameterizedType recursively","```java import java.lang.reflect.Method; import java.lang.reflect.Type; import java.util.List; import org.springframework.core.GenericTypeResolver;  public class Main { 	public interface Parent { 		T m1(); 		List m2(); 		List m3(); 	} 	public interface Child extends Parent { 	} 	public static void main(String[] args) { 		for (Method m : Parent.class.getMethods()) { 			Type type = m.getGenericReturnType(); 			type = GenericTypeResolver.resolveType(type, Child.class); 			System.out.println(""method "" + m.getName() + ""() will return "" + type); 		} 	} } ``` will print ``` method m3() will return java.util.List method m1() will return class java.lang.String method m2() will return java.util.List ``` The expected type for m3 should be `java.util.List`","open","in: core,","quaff","2020-04-23T10:59:49Z","2022-04-18T10:25:28Z"
"","25128","Avoid duplicate addition of void.class in ClassUtils static initialization","```java  static { 		primitiveWrapperTypeMap.put(Boolean.class, boolean.class); 		primitiveWrapperTypeMap.put(Byte.class, byte.class); 		// ...                // Add 'void.class' repeatedly 		primitiveTypes.add(void.class); 		// ... 	} ```","closed","status: feedback-provided,","cherishsince","2020-05-26T07:52:17Z","2020-05-26T09:20:18Z"
"","25371","[spring-test] When test methods have parameters, it has a error: No ParameterResolver registered for parameter.","``` package com.example.demo;  import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit.jupiter.SpringExtension; @SpringBootTest  @ExtendWith(SpringExtension.class) class DemoApplicationTests {  	@Test 	void contextLoads(String string) { 	} } ``` The code is very simple. But when I test the code, it show error like: ``` org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [java.lang.String string] in method [void com.example.demo.DemoApplicationTests.contextLoads(java.lang.String)]. ``` You can see the code: ``` SpringExtension implements ParameterResolver ``` Is there something wrong?","closed","","bahuwang","2020-07-08T11:24:32Z","2022-02-18T19:06:56Z"
"","25680","Convert java.util.Date to java.time.*","``` 	Date date = new Date(); 	ConversionService cs = DefaultConversionService.getSharedInstance(); 	cs.convert(date, Year.class); 	cs.convert(date, YearMonth.class); 	cs.convert(date, LocalDate.class); 	cs.convert(date, LocalDateTime.class); ``` Feel free to close it if you don't think it's worthwhile.","closed","status: declined,","quaff","2020-09-03T02:21:53Z","2020-09-03T09:23:39Z"
"","25378","The  namespace element does not support the allowCoreThreadTimeOut property","`` in `spring-task-4.3.xsd` can set the `id`, `pool-size`, `queue-capacity`, `keep-alive`, and `rejection-policy` attributes of the `ThreadPoolTaskExecutor`, but it cannot set the `allowCoreThreadTimeOut` attribute.  What is the reason for this design？  So the only way to use `@Async` annotation is define a Config class with `@Configuration` and `@EnableAsync` annotation when I just wanna set the ThreadPoolTaskExecutor's `allowCoreThreadTimeOut`  attribute to `true`?","closed","in: core,","ChaosL","2020-07-09T14:24:37Z","2020-07-09T16:36:44Z"
"","25590","Inconsistent log level in @Bean javadoc and ConfigurationClassEnhancer","`@Bean` javadoc [states](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/Bean.java#L196-L199) when BFPP is defined with non-static method, it writes a `WARN-level` log message.  > This works out in BFPP cases, as they are not typically referenced by other @Bean methods.  > As a reminder, a **WARN-level log message** will be issued for any non-static @Bean methods having a return type assignable to BeanFactoryPostProcessor   The commit 9a43d2ec208d2e8cd0866431acf26af3529f8677 (SPR-16946, #21485) updated the logging level in `ConfigurationClassEnhancer` and [this message shows up as `INFO` log](https://github.com/spring-projects/spring-framework/blob/5aa37ea07b31a6408e244f99d9440fba202f76ff/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java#L321-L330).  ```java if (logger.isInfoEnabled() &&     BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {   logger.info(String.format(""@Bean method %s.%s is non-static and returns an object "" +           ""assignable to Spring's BeanFactoryPostProcessor interface. This will "" +           ""result in a failure to process annotations such as @Autowired, "" +           ""@Resource and @PostConstruct within the method's declaring "" +           ""@Configuration class. Add the 'static' modifier to this method to avoid "" +           ""these container lifecycle issues; see @Bean javadoc for complete details."",       beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName())); } ```  So, either javadoc or log level need to be updated to match actual description and behavior.","closed","in: core,","ttddyy","2020-08-14T20:17:35Z","2020-08-16T18:04:57Z"
"","25491","Add MediaType.APPLICATION_JSON_SEQ for application/json-seq","[JSON Text Sequences](https://tools.ietf.org/html/rfc7464) should be added to MediaType like NDJSON, jackson will supports it later, please see https://github.com/FasterXML/jackson-core/issues/633","closed","status: declined,","quaff","2020-07-30T01:45:16Z","2021-11-25T22:07:41Z"
"","25504","HttpLogging uses misleading logger name","[HttpLogging](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/HttpLogging.java) hard codes the logger name to `org.springframework.web`, which is wrong. ``` private static final Log fallbackLogger = 			LogFactory.getLog(""org.springframework.web."" + HttpLogging.class.getSimpleName()); ```","closed","in: web,","asarkar","2020-08-01T01:24:35Z","2020-08-04T11:53:33Z"
"","25670","LinkedMultiValueMap Bug","[Here](https://github.com/spring-projects/spring-framework/blob/210dd0392faf84b4068f989d7ffbc217cfe60fd8/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java#L386) ![bug](https://user-images.githubusercontent.com/43698473/91788829-c9259680-ec3f-11ea-8fac-b9f3bcfd32f4.jpg)  It can only get by the _Literal_. I think It could get by the _Object_ too.","closed","status: invalid,","CoderYellow","2020-09-01T02:44:04Z","2020-09-01T05:02:08Z"
"","25726","ClassPathScanningCandidateComponentProvider behaviour not scanning annotated classes anymore (spring-context 5.1.17 -> 5.2.8)","[demo-annotationtypefilter.zip](https://github.com/spring-projects/spring-framework/files/5183203/demo-annotationtypefilter.zip) Hi, first time here. Please bear with me if this report has to be fixed somehow.  We have recently upgraded Spring Boot 2.1.16 to 2.3.3 and we have found differences in the behaviour of `ClassPathScanningCandidateComponentProvider` which are breaking something we had working.  Essentially, we have a `@Configuration` class implementing `ResourceLoaderAware, EnvironmentAware, ImportBeanDefinitionRegistrar` which includes an snippet like this one:  ``` 	ClassPathScanningCandidateComponentProvider scanner = getScanner(); 	AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(HappyAnnotation.class); 	scanner.addIncludeFilter(annotationTypeFilter); 	scanner.setResourceLoader(this.resourceLoader); 	Set candidateComponents = scanner.findCandidateComponents(""com""); ```  With this, we would be able to find interfaces in the classpath annotated with `@HappyAnnotation`, to which we would do some operation later to have them registered in the Spring context. Now the `candidateComponents` is empty, so nothing will be registered.  We have noticed several things:  - `ClassPathScanningCandidateComponentProvider` makes use of a `SimpleMetadataReader` at some point. The implementation for it has changed. - The former implementation for `SimpleMetadataReader` made use of a visitor called `AnnotationMetadataReadingVisitor`. It has been deprecated and `SimpleAnnotationMetadataReadingVisitor` is being used instead. - The new implementation of `SimpleMetadataReader` ends up with an attribute `annotationMetadata` of type `SimpleAnnotationMetadata`, which at the same time has `annotations` (`TypeMappedAnnotations`) with an `annotationFilter` being shown in debug as ""All annotations filtered"", which suggests all annotations are ignored. - I have seen that `AnnotationMetadataReadingVisitor` is mentioned to be deprecated and replaced for the other one but _no public replacement for it is being provided_, as per documentation. I am not really sure this pattern we use is valid anymore.  I attach an small project that reproduces the issue. Just change the commented spring boot parent version in the pom for the other one to reproduce.  If not a bug and if time allows, please forward me to some documentation which explains how to get our `Set` correctly in this version.  Thanks in advance,   JP","closed","in: core,","jplatasv","2020-09-07T13:34:45Z","2020-09-14T10:18:25Z"
"","25539","Fix asciidoctor syntax for source","[Asciidoctor User Manual: Normalize Block Indentation](https://asciidoctor.org/docs/user-manual/#normalize-block-indentation)  ![image](https://user-images.githubusercontent.com/2121467/89483826-98347c00-d7cf-11ea-884d-4a6dc8ac3692.png)","closed","type: documentation,","diguage","2020-08-06T02:40:16Z","2020-08-07T02:16:35Z"
"","25545","Merge source and substitution configuration in reference docs","[Asciidoctor User Manual: Applying Substitutions](https://asciidoctor.org/docs/user-manual/#applying-substitutions)  ![image](https://user-images.githubusercontent.com/2121467/89516472-0ea29f80-d80b-11ea-9954-38c082fda4a0.png)  ----  I changed the code with `sed` script:  ```bash find . -name ""*.adoc"" -type f -print0 | xargs -0 gsed -i -f source.sed ```  source.sed:  ``` :begin /indent=0\]/,/\[subs=""verbatim,quotes/ {     /subs=""verbatim,quotes/! {         $! {             N;               b begin         }     }     s/indent=0\]\n\[subs=""verbatim,quotes/indent=0,subs=""verbatim,quotes/; } ```","closed","type: task,","diguage","2020-08-06T09:35:00Z","2020-12-30T14:55:47Z"
"","25101","@TransactionalEventListener not works, TransactionSynchronizationManager.registerSynchronization works well","@TransactionalEventListener public void A(){ ... }  @Transactional ... public void A(){ ... A(); }  coding as above, while method A execute before transaction committed","closed","for: stackoverflow,","jhz1103","2020-05-19T08:03:37Z","2020-05-19T08:08:53Z"
"","24925","Simplify some control flow code","@sbrannen Thank you    link #24907","closed","type: task,","Deycoesr","2020-04-17T16:25:32Z","2020-04-17T16:34:37Z"
"","25469","WebClient reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response","@rstoyanchev   When I use WebClient,every day I get a few error level exceptions.  > org.springframework:spring-webflux:jar:5.2.7.RELEASE  ``` [reactor-http-epoll-4][19:26:50.633][WARN][HttpClientConnect:299] [id: 0x08f18aef, L:/10.14.17.53:59710 ! R:host/xx.xx.xx.xx:443] The connection observed an error reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response [reactor-http-epoll-4][19:26:50.634][ERROR][AbstractErrorWebExceptionHandler:122] [2711c447] 500 Server Error for HTTP POST ""gateway-uri"" reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response         Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: Error has been observed at the following site(s):         |_ checkpoint ⇢ Request to POST uri [DefaultWebClient]         |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]         |_ checkpoint ⇢ org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain]         |_ checkpoint ⇢ HTTP POST ""gateway-uri"" [ExceptionHandlingWebHandler] Stack trace: ```  code: ``` WebClient webClient = WebClient.create(); Mono result =webClient.post().uri(url).contentType(MediaType.APPLICATION_JSON).bodyValue(""{}"").retrieve().bodyToMono(String.class); ```  https://github.com/spring-cloud/spring-cloud-gateway/issues/1860","closed","","CantosSong","2020-07-24T03:21:59Z","2020-07-24T11:36:52Z"
"","25370","please help me : how do RestTemplate exchange()method  post   key-value data to server?","@PostMapping(value = ""test2"")     @ResponseBody     public ResponseBox test2(int id, String username, String password) {         System.out.println(""post test2 run id="" + id + "" username="" + username + "" password="" + password);         ResponseBox box = new ResponseBox();         box.setResponseCode(200);         box.setData(""test2 value"");         box.setMessage(""操作成功"");         return box;     }  -------------------------------------------------- public class Test2 {     public static void main(String[] args) throws JsonProcessingException {         int id = 100;         String username = ""~!@#$%^&*()_+-={}[]|;:'?,./"";         String password = ""~!@#$%^&*()_+-={}[]|;:'?,./"";          HttpHeaders headers = new HttpHeaders();         headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);           //??????what do ??  top 3 param use post type submit springMVC controller         //note:no create entity class way. like key=value          HttpEntity entity = new HttpEntity( ???,headers);          RestTemplate template = new RestTemplate();         ResponseEntity responseEntity = template.exchange(URI.create(""http://localhost:8080/post/test2""), HttpMethod.POST, entity, new ParameterizedTypeReference() {         });         ResponseBox box = responseEntity.getBody();         System.out.println(box.getResponseCode() + "" "" + box.getData() + "" "" + box.getMessage());     } }  ---------------------------- internet not find answer , so go to the issues ..thank you !!!","closed","for: stackoverflow,","startjava","2020-07-08T06:44:15Z","2020-07-08T07:59:59Z"
"","25519","DefaultMessageListenerContainer stops listening","5.0.8.RELEASE erro： All scheduled consumers have been paused, probably due to tasks having been rejected. Check your thread pool configuration! Manual recovery necessary through a start() call.   Question: in what scenarios will this problem occur? How to solve it?  thank you","open","in: messaging,","xiangyang-gao","2020-08-04T08:14:15Z","2021-11-10T12:03:41Z"
"","25611","./gradlew :spring-oxm:compileTestJava  error","40 actionable tasks: 40 up-to-date Build scan background action failed. org.gradle.process.internal.ExecException: Process 'command 'git'' finished with non-zero exit value 128         at org.gradle.process.internal.DefaultExecHandle$ExecResultImpl.assertNormalExitValue(DefaultExecHandle.java:409)         at org.gradle.process.internal.DefaultExecAction.execute(DefaultExecAction.java:38)         at org.gradle.process.internal.DefaultExecActionFactory.exec(DefaultExecActionFactory.java:145)         at io.spring.ge.WorkingDirectoryProcessOperations.exec(WorkingDirectoryProcessOperations.java:45)         at io.spring.ge.BuildScanConventions.exec(BuildScanConventions.java:161)         at io.spring.ge.BuildScanConventions.addGitMetadata(BuildScanConventions.java:110)         at com.gradle.scan.plugin.internal.api.j.a(SourceFile:22)         at com.gradle.scan.plugin.internal.api.k$a.a(SourceFile:112)         at com.gradle.scan.plugin.internal.api.h.a(SourceFile:62)         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)         at java.util.concurrent.FutureTask.run(FutureTask.java:266)         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)         at java.lang.Thread.run(Thread.java:745)","closed","","WangAlainDelon","2020-08-18T16:44:54Z","2020-08-20T12:01:36Z"
"","25685","拉去分支","111","closed","","LiuSirZ","2020-09-03T10:00:58Z","2020-09-03T10:02:14Z"
"","25012","5.0.x","1","closed","status: invalid,","LOVEGREY","2020-05-04T15:06:12Z","2020-05-04T15:10:13Z"
"","25011","5.0.x","1","closed","status: invalid,","LOVEGREY","2020-05-04T15:01:12Z","2020-05-04T15:02:38Z"
"","24922","Illegal reflective access by org.springframework.cglib.core.ReflectUtils  - spring-core-5.2.5.RELEASE.jar",".m2/repository/org/springframework/spring-core/5.2.5.RELEASE/spring-core-5.2.5.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)  **started to appear when using Spring HATEOAS - linkTo(methodOn(Some.class))**","open","in: core,","mananmehta11","2020-04-17T05:47:50Z","2021-11-10T10:03:00Z"
"","25009","gradle dependency","- spring framework version : 5.2.3.RELEASE - I introduced the following dependency when creating the subproject, but I did not find the dependency in the idea ``` plugins {     id 'java' }  group 'org.springframework' version '5.2.3.RELEASE'  repositories {     mavenCentral() }  dependencies {     compile(project("":spring-beans""))     compile(project("":spring-core""))      testCompile group: 'junit', name: 'junit', version: '4.12' }  ``` - gradle config  ![image](https://user-images.githubusercontent.com/26766909/80976040-843a5080-8e55-11ea-9732-1e83542afe89.png)  - Abnormal warehouse:  https://github.com/SourceHot/spring-framework-read/tree/source-hot-5.2.3/source-hot-spring-overview","closed","for: stackoverflow,","huifer","2020-05-04T14:23:34Z","2020-05-05T14:29:18Z"
"","25410","Cannot use version-agnostic WebJars on static resource paths that include the library name","**WebFlux doesn't support version-agnostic WebJars** (without hard-coding their version number in the code) to be hosted from a static resource path **if it already specifies the specific WebJar name (e.g. `swagger-ui`) in the fixed part of the path**; but it does work when its name is contained in the ""variable part"" of the path. Of course, this isn't as important as the fact that **this isn't documented anywhere**, making users spend days debugging an issue caused by a simple code refactoring, as it behaves ambiguously under different circumstances, requiring learning the entire Spring internal implementation to even understand the issue.  Here is a reproducible example where a mapping `localhost:8080/swagger-ui/index.html` doesn't work:   Hidden import statements  ```java import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.config.ResourceHandlerRegistry; import org.springframework.web.reactive.config.WebFluxConfigurer; ```   ```java @Configuration public class WebConfiguration {     @Bean     public WebFluxConfigurer webConfigurer() {         return new WebFluxConfigurer() {             @Override             public void addResourceHandlers(ResourceHandlerRegistry registry) {                 registry.addResourceHandler(""/swagger-ui/**"")                         .addResourceLocations(""classpath:/META-INF/resources/webjars/swagger-ui/"")                         .resourceChain(false);             }         };     } } ```  Under the Spring implementation, the variables are set as follows:  * `requestPath` = ""`index.html`"" * `locations` = List [""`META-INF/resources/webjars/swagger-ui/`""]  when `resolveResourceInternal` is called (from `ResourceWebHandler.handle`), executed at https://github.com/spring-projects/spring-framework/blob/6fbd4841ec4a20cfd8c5338c6bcf0171839c2326/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/WebJarsResourceResolver.java#L80  which calls `findWebJarResourcePath` with a `path` parameter having value ""`index.html`"" on line https://github.com/spring-projects/spring-framework/blob/6fbd4841ec4a20cfd8c5338c6bcf0171839c2326/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/WebJarsResourceResolver.java#L103  This function **wrongly assumes** that the `path` parameter contains a path like `swagger-ui/index.html` instead, thus it fails and returns null. As a first possible workaround that I see, the `path` could be concatenated with the content of `locations`; but I don't have any knowledge of the internals or motivations behind the current approach. At the very least, some parameter could be exposed to allow explicitly adding one level of a parent hierarchy.  * By the way, I noticed that even whenever a path doesn't contain any webjars reference, e.g. when simply using `registry.addResourceHandler(""/something/**"").addResourceLocations(""classpath:/META-INF/resources/"").resourceChain(false);`, and the user requests a page like `localhost:8080/something/swagger-ui/index.html`, the aforementioned code is still fully executed, calculating the entire swagger-ui WebJars path and properly returning it (though it ends up as a 404 Not Found page in the end, so it isn't necessarily a bug) for no reason, which could be avoided in my opinion; maybe this could be addressed together with this issue.  # Background  * WebJars project allows you to specify your web libraries (JavaScript, CSS, etc) as dependencies in your Java web applications. < https://jamesward.com/2012/04/30/webjars-in-spring-mvc/ > * Spring MVC makes it easy to expose static assets in JAR files using ResourceHandlers. < https://www.webjars.org/documentation#springmvc > * The resourceChain() method must be called for version-agnostic WebJars. < http://zetcode.com/spring/webjars/ > * This [is used by WebFluxAutoConfiguration](https://github.com/spring-projects/spring-boot/blob/e438864ad99449f8ad95293c6472194efc3add30/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration.java#L173) by default. * Spring Boot [documentation about hosting static content](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-static-content). To use version agnostic URLs for Webjars, add the webjars-locator-core dependency * Some resources mention that we need to include `org.webjars:webjars-locator` as a dependency (Maven, Gradle), while other mention simply the `org.webjars:webjars-locator-core`.  An example of a correctly working usage can be like this, where we refer to the WebJars via the /webjars/ path. ``` @Override public void addResourceHandlers(ResourceHandlerRegistry registry) {     registry.addResourceHandler(""/webjars/**"")             .addResourceLocations(""/webjars/"").resourceChain(false); } ``` And of course, security has to be set up like ``` .pathMatchers(HttpMethod.GET, ""/webjars/**"").permitAll() ```  **Affects:** spring-webflux-5.2.7","closed","for: external-project,","scscgit","2020-07-17T13:19:33Z","2021-10-28T08:21:54Z"
"","25304","MappingJackson2HttpMessageConverter default character set issue","**Version: Spring Framework 5.2.7**  `MappingJackson2HttpMessageConverter`  ```  * By default, this converter supports {@code application/json} and {@code application/*+json}  * with {@code UTF-8} character set. This can be overridden by setting the  * {@link #setSupportedMediaTypes supportedMediaTypes} property. ```  The above comment says that MappingJackson2HttpMessageConverter's default charater set is UTF-8.  ![image](https://user-images.githubusercontent.com/34656258/85402209-3d83ef80-b596-11ea-9b35-fe5e2cf0a1be.png)  But my MappingJackson2HttpMessageConverter's  default characterSet is null.  Is the comment wrong? Or am I doing somethig wrong?  Is the default character set deprecated?  If the default character set is deprecated, I think it would be better to delete the content from the comment.","closed","","kyucumber","2020-06-23T12:21:25Z","2020-06-26T08:11:33Z"
"","25014","spring webflux IO  is not executed  by  eventloop thread when using publishOn?","**environment :** spring-boot-starter-webflux + netty embedded  **code:** in my rest controller, code is  ```java     @GetMapping(path = ""/flux"")     public Flux getAllRecord() {         Flux stream = Flux.range(0, 1)                 .publishOn(s)                 .map(i -> {                         System.out.println(Thread.currentThread().getName());                         return userService.getAllUser();                     }                 );         return stream;     } ```  **problem:** according to reactor design pattern and netty's principle,  network IO need be executed on one thread associated with eventloop. but i found that when using webflux with  api ""publishOn(ExecutorService)"",  the netty method ChannelHandlerContext.write(ByteBuf) is invoked by custom thread pool, not by nio-event-loop thread.  is it reasonable? or webflux need change codes to do read/write IO using nio eventloop thread  according to reactor pattern or netty's  principle?","closed","for: stackoverflow,","jiemar","2020-05-05T04:03:15Z","2020-05-05T15:01:53Z"
"","25385","Document initialization and shutdown logging semantics for the TestContext framework","**Current Behavior**  The default logging configuration for Spring Boot is to send logs to the console.  Info logs  are printed at application context startup and via shutdown hook  when the application context is shutting down. Due to the way that test runners in gradle, intellj, and other tools capture console for tests we end up with stray output.  ``` > Task :components:database:test 2020-07-12 09:54:24.952  INFO 46723 --- [extShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2020-07-12 09:54:24.954  INFO 46723 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor' 2020-07-12 09:54:24.955  INFO 46723 --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated... 2020-07-12 09:54:25.402  INFO 46723 --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed. ```  You can see a  detailed discussion on this at [Gradle Issue 12423](https://github.com/gradle/gradle/issues/12423) and a project to reproduce the issue.   I am working on a  multi module project and I end up with a lot of shutdown  hook noise in my console every time  I run `./gradlew build`.  Ideally there is no shutdown hook output displayed to the screen.  **Why this problem occurs**  Test runners want to associate the execution of a test with the console output of that test. Lets say you have a method such as   ```java @Test  void testSomething(){   // given   // when    System.out.println(""Hello"");  // then  } ```  The test runners want to generate a report that can display the  console output that  was generated  when the `testSomething`  method was executing. When there are multiple threads present things become unpredictable if there is a test executing whatever  threads on the JVM print to the console gets associated with that test.  Consider the screenshot below.      The test case being executed does not not actually print any output , the output captured is from the spring initialization code running on what appears to  be  a  test containers, this happens to  be an integration test against a PostgreSQL database launched via test containers project.     According to a [post](https://discuss.gradle.org/t/capturing-test-output-from-multiple-threads/13464/4) from Luke Daly from the gradle team  when there are multiple threads.   > Gradle captures the output during tests, and associates it with the test case. Within a shutdown hook, there’s no test case to associate it with and nowhere else to send it other than to “the console”. This is the safest default as that output might be useful information, and there’s no other way to capture it.  So the observed behavior is not a bug in Gradle or Spring, but it is caused by the interaction between the default behaviors of spring and Gradle. BTW I see the same issue when running tests in intelliJ the output that intellij associates with each of the test case methods is somewhat random due to thread timing issues.   **Workaround 1**  One option is to turn off console logging in SpringBoot by setting   ``` logging:   level:     root: error ```  this works no more shutdown hook info output. When a test class marked up with `@SpringBootTest` runs it is quite useful to be able to inspect the console and see what version of boot is running, how long things took any useful info messages. Therefore this workaround is not desirable. The current of state of initalization and shutdown output being associated with random `@Test` methods is also  undesirable.   **Workaround 2** I created a logback-spring.xml file and used it to direct logs from test executions to a log file, using profiles and  the log file below.   ```xml                                                                            ```  The disadvantage of this workaround is that intelliJ Junit runner no longer displays any of the startup up/shutdown output I have to go to `build/logs` to get it.  **Desired Behavior**  The workarounds are not ideal would be nice if there was a way to auto configure this type of setup or at  the very least  explain this  issue in the docs.","closed","type: documentation,","asaikali","2020-07-12T14:35:20Z","2021-01-11T17:02:47Z"
"","25358","Support for customization of 404 response when RouterFunctionWebHandler finds no routes","**Context** Next to the default WebServer a service starts another server to handle admin requests on a different port. The admin webserver is connected to the `HttpHandler` created by `RouterFunctions.toHttpHandler`.  When the admin server processes a request for a path not mapped to any `RouterFunction` then the admin server responds with a 404 NotFound status code and an empty response body.  Currently it is not possible to have a different response body.   Changing the `RouterFunctionWebHandler` to return a `Mono.error(new ResponseStatusException(HttpStatus.NOT_FOUND))` instead of `ServerResponse.notFound().build()`  allows clients to implement an exception handler that customizes the response body.  Default behavior does not change because `WebFluxResponseStatusExceptionHandler` is the default handler.","closed","type: enhancement,","ivd-git","2020-07-06T08:14:30Z","2021-12-03T12:03:12Z"
"","25832","Why XmlBeanDefinitionReader does not define a private static Set to solve resourcesCurrentlyBeingLoaded reloading?","**Affects:v5.2.x \  ---   ThreadLocal processing can only prevent the current thread from repeated loading. Why not use Set for processing, which can prevent multiple threads from repeated loading. Is this designed to load the latest XML resources under the scenario where the XML resources have been modified?","closed","","hzmpay","2020-09-29T03:03:57Z","2022-02-18T19:06:30Z"
"","25157","Add Property origin information to PropertyResolver","**Affects:** v5.2.6.RELEASE ---  I would like to be able to debug and log out where properties come from.  This becomes needed if you are using Spring Boot with multiple microservices sharing configuration files but each having their own configuration file.  It becomes hard to determine where a property is being set and why the one you intended on being effective is not.  Could we get origin information added to PropertyResolver interface.  This could be added by adding a function like *Origin getPropertyOrigin(String)*.  The default implementation may just be to return the an Origin that just contains a string with the class name of the resolver but ideally it would return something like what *org.springframework.boot.origin.OriginLookup* returns.  Looking at the packages it looks like Spring Boot layers origin information onto the Spring Framework Environment framework but would like this to be available instanceof casts.  For example this is how I emulate this behavior now: ```         private String getPropertySourceName(String property, Environment environment) 	{ 		String propertySourceName = """";  		if (environment instanceof AbstractEnvironment) 		{  			MutablePropertySources propertySources = ((AbstractEnvironment) environment).getPropertySources();  			for (PropertySource propertySource : propertySources) 			{ 				Object propertyValue = propertySource.getProperty(property);  				if (propertyValue != null) 				{ 					if (propertySource instanceof OriginLookup) 					{ 						Origin origin = ((OriginLookup) propertySource).getOrigin(property); 						propertySourceName = origin.toString(); 					} else 					{ 						propertySourceName = propertySource.getName(); 					} 					break; 				} 			} 		}  		return propertySourceName; 	} ```","closed","for: external-project,","ddcruver","2020-05-28T16:40:53Z","2020-06-03T16:41:06Z"
"","24948","Describe that bean disposal is unsupported for the beans created by FactoryBean","**Affects:** v5.2.5.RELEASE  In https://github.com/spring-projects/spring-framework/issues/14668, the [comment](https://github.com/spring-projects/spring-framework/issues/14668#issuecomment-453398972) described clearly that the Spring framework is only responsible for managing the lifecycle of the FactoryBean, not the lifecycle of the beans that created by the FactoryBean.  However, this description doesn't appear in the [javadoc of FactoryBean](https://javadoc.io/doc/org.springframework/spring-beans/5.2.5.RELEASE/org/springframework/beans/factory/FactoryBean.html). I think it would be great to mention the following points in the documentation:  1. The Spring framework is only responsible for managing the lifecycle of the FactoryBean, not the lifecycle of the beans that created by the FactoryBean. 2. Therefore, the `Closeable.close()` method on the created beans will not be called. 3. FactoryBean should implement DisposableBean and delegate the `Closeable.close()` calls to the underlying beans.","closed","in: core,","johnlinp","2020-04-21T00:28:45Z","2020-04-25T14:39:02Z"
"","25336","ExceptionHandler questionable behavior exposing exception causes","**Affects:** v4.3.0.RELEASE  ---   In the [v4.3.0.RELEASE](https://github.com/spring-projects/spring-framework/releases/tag/v4.3.0.RELEASE) release a change was made to the `ExceptionHandler` mechanism so that it not only matches handlers based on the observed exception but also the on the first level cause of that exception. This is problematic in scenarios like the following: ``` class Controller {   void endpoint1() {     throw new ExceptionA();   }   void endpoint2() {     try {        ...     } catch (ExceptionA e) {       throw new ExceptionB(e);     }   } ``` if ExceptionA is thrown is want the `ExceptionA` handler to be used, but if `ExceptionB` is thrown, then i want the handler for ExceptionB to be used.  I believe that should be the case regardless of the order of the handlers, because when an exception is caught and wrapped it is the outer exception that is intended to be surfaced and also what has more relevant high level information of what failed, details belong in the logs. (eg: `ExceptionA` could be `IllegalArgumentException`, while `ExceptionB` could be `InvalidUsernameException`). In addition to that, having added that feature changed the behavior of the handlers and potentially exposed details that were not intended to be public.  I suggest that such this is made optional and disabled by default (or, preferably, removed), if kept, looking at the first cause seem arbitrary, why not the second cause? why not the root cause? why not any exception in cause chain?","closed","in: web,","enriquedacostacambio","2020-06-29T20:54:08Z","2021-10-08T14:14:08Z"
"","25437","400 Header Folding calling a jetty api","**Affects:** spring-web-5.2.6.RELEASE  ---   Hello there   Having this particular issue with this spring versions  worun@rn-aosd-d00-lapp01:/Local/AS/Sentinel/packages/NemoDataSetsService-21-2-0-20200720-224046-4/lib$ ls -alt | grep spring-web -rw-r--r--. 1 worun worun  1436459 Jun 25 21:20 spring-web-5.2.6.RELEASE.jar -rw-r--r--. 1 worun worun   954967 Jun 25 21:20 spring-webmvc-5.2.6.RELEASE.jar   org.springframework.web.client.HttpClientErrorException$BadRequest: 400 Header Folding 	at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:79) 	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:122) 	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:102) 	at org.springframework.web.client.ResponseErrorHandler.handleError(ResponseErrorHandler.java:63) 	at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:778) 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:736) 	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:637) 	at com.apple.store.datasets.service.spring.proxy.DataSetsAuthoringServiceSpringAPIProxy.meta(DataSetsAuthoringServiceSpringAPIProxy.java:601)  400 Header Folding   Any idea what could be wrong?  This is the snippet of code:       @Secured({ ""datasets:view"" })     @RequestMapping(value = ""dataSet/v1/{site}/{type}/{versionKey}/meta.json"", method = RequestMethod.GET, produces = ""application/json;charset=UTF-8"")     @ResponseBody     public ResponseEntity meta(@PathVariable String site, @PathVariable String type,         @PathVariable String versionKey, HttpServletRequest request, Principal principal) {          try {              String uriString = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);              String servicebaseURL = null;             TypeProxy typeProxy = dataSetsAPIProxyConfiguration.getProxyConfiguration().get(site + ""/"" + type);             if (typeProxy != null) {                 servicebaseURL = typeProxy.getAuthoringProxy().getBaseURL();             }              if (servicebaseURL == null) {                 throw new IllegalArgumentException(""No proxy endpoints configured for Site/Type "" + site + ""/"" + type);             }              URI uri = new URI(servicebaseURL + ""/"" + uriString);           //  HttpHeaders headers = new HttpHeaders(); 			/* 			 * headers.add(""content-type"", ""application/json""); 			 * dataSetsHeadersUtil.updateHttpHeaders(headers); transferAudit(principal, 			 * headers); 			 */                                      RequestEntity requestEntity = new RequestEntity(HttpMethod.GET, uri);              ResponseEntity dataTypeDefinitionResponse = dataSetsRestTemplate.exchange(requestEntity, DataTypeDefinition.class);              if (dataTypeDefinitionResponse.getStatusCode() == HttpStatus.OK) {                 Map response = new HashMap();                 ObjectMapper objectMapper = new ObjectMapper();                 TypeReference typeReference = new TypeReference() {                 };                 response.put(""status"", ""SUCCESS"");                 response.put(""data"", objectMapper.convertValue(dataTypeDefinitionResponse.getBody(), typeReference));                  return new ResponseEntity(response, HttpStatus.OK);             } else {                 return new ResponseEntity(HttpStatus.NOT_FOUND);             }          } catch (HttpClientErrorException httpClientErrorException) {             log.error(""Critical error proxying keys call"", httpClientErrorException);             return new ResponseEntity(httpClientErrorException.getStatusCode());         } catch (Exception exception) {             log.error(""Critical error proxying keys call"", exception);             return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);         }     }","closed","status: invalid,","maugomez77","2020-07-20T23:16:36Z","2020-07-22T08:49:48Z"
"","25530","Version number not displayed in ObjectOptimisticLockingFailureException","**Affects:** spring-orm:5.1.9 release  ---  sample exception thrown message:  ``` org.springframework.orm.ObjectOptimisticLockingFailureException: Object of class [com.***.app.domain.Customer] with identifier [421969]: optimistic locking failed; nested exception is org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) : [com.***.app.domain.Customer#421969]; nested exception is org.springframework.orm.ObjectOptimisticLockingFailureException: Object of class [com.**.app.domain.Customer] with identifier [421969]: optimistic locking failed; nested exception is org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) : [com.***.app.domain.Customer#421969] ```  ISSUE Here is only Identifier is showing but not version at which it occured","closed","status: invalid,","surapuramakhil","2020-08-05T05:15:43Z","2020-08-06T14:30:43Z"
"","24852","DefaultListableBeanFactory.getBean(Class) throws NoSuchBeanDefinitionException on existing bean if getBean(Class) previously tried before registration","**Affects:** spring-context:5.2.5.RELEASE  ---  I register a new `BeanDefinition` via `context.registerBeanDefinition` , but I still have `NoSuchBeanDefinitionException` on `context.getBean` because `context.getBean` cached my previous call before bean registration.  Only if I call `context.getBeanFactory().clearMetadataCache()` manually this code doesn't throw any exception, but now it does.  ```java import static org.assertj.core.api.Assertions.assertThat;  import lombok.extern.slf4j.Slf4j; import org.junit.Test; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionBuilder; import org.springframework.context.support.GenericApplicationContext;  @Slf4j public class DefaultListableBeanFactoryRedundantCacheTest {      @Test     public void noSuchBeanDefinitionExceptionAfterRegisterBean() {         try (GenericApplicationContext context = new GenericApplicationContext()) {             context.refresh();             NoSuchBeanDefinitionException exception = null;             try {                 context.getBean(Bean.class);             } catch (NoSuchBeanDefinitionException ex) {                 exception = ex;                 log.error(""It's ok. "" +                         ""But 'org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType"" +                         ""(java.lang.Class, boolean, boolean)' has added bean to cache '#501 - cache.put(type, resolvedBeanNames);'""                     , ex);             }             assertThat(exception).isInstanceOf(NoSuchBeanDefinitionException.class);              /* No Clear Metadata Cache 'context.getBeanFactory().clearMetadataCache()' */              final BeanDefinition definition = BeanDefinitionBuilder                 .genericBeanDefinition(Bean.class)                 .getBeanDefinition();             context.registerBeanDefinition(""myBean"", definition);              final Bean newBean = context.getBean(Bean.class);              assertThat(newBean).isNotNull();         }     } } ```  I think unsuccessful resolved bean shouldn't be cached in `getBeanNamesForType`.","closed","in: core,","kochetkov-ma","2020-04-03T08:11:44Z","2020-10-18T14:23:18Z"
"","25822","UriComponentsBuilder controller method argument has no path","**Affects:** Spring WebFlux 5.2.9  From [the documentation][1] about Spring WebFlux controller annotated method arguments: > UriComponentsBuilder | For preparing a URL relative to the current request’s host, port, scheme, and path.  When reading this, I understood that the injected builder would include the full path to my controller method, which seemed confirmed by #20546 stating that an injected builder should behave like `UriComponentsBuilder.fromHttpRequest(request)`.  However, when building a war that is deployed to tomcat 9.0.27 under the application context ""/context"":  ```java @Controller @RequestMapping (""/controller"") public class MyController {    private static final Logger logger = LoggerFactory.getLogger (MyController.class);    @GetMapping (""/method"")   public void method (       UriComponentsBuilder builder,       ServerHttpRequest request   ) {    logger.info (""Injected: {}"", builder.build (emptyMap ())); // -> http://localhost:8080/    logger.info (""Constructed: {}"", UriComponentsBuilder.fromHttpRequest (request).build (emptyMap ())); // -> http://localhost:8080/context/controller/method   } } ```  Note that I’m fine if the spec changed after #20546 was drafted. The documentation however should be updated.  Interestingly, answers to #21449 state that the injected builder should be ""application relative"". My understanding of this sentence is that it should include the application context path, but not the controller path. This would have been exactly what I need, but isn’t what I see.  I haven’t tested what happens with non-reactive controllers. Obviously, we want the behavior to match in all three places:  - WebFlux  - Web MVC  - latest documentation.  [1]: https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-methods","closed","type: bug,","EtienneMiret","2020-09-26T18:19:17Z","2020-10-15T21:12:09Z"
"","25663","Changed @PathVariable at the end of the path to include the extension","**Affects:** Spring MVC 5.3.0-M2  --- https://github.com/spring-projects/spring-framework/commit/567265123b738045db4808960331812adc3a7aab Changed @PathVariable at the end of the path to include the extension.  For example:  ```java @RestController public class SampleController {    @GetMapping(""/{str}""}   public String sample(@PathVariable(""str"") String str) {     return str;   } } ```  When request to `/hoge`, path variable is `hoge`. When request to `/hoge.html`, I expected `hoge` but actual `hoge.html`.  To map the request with or without extension, I need to make the following changes.  ```java @RestController public class SampleController {    @GetMapping({ ""/{str}"", ""/{str}.*"" }}   public String sample(@PathVariable(""str"") String str) {     return str;   } } ```  Is this an intentional design change? or a bug?  Regards.","closed","status: waiting-for-feedback,","yoshikawaa","2020-08-31T07:23:23Z","2022-02-18T19:06:25Z"
"","25741","Current log level not checked by LogAccessor supplier-enabled logging methods","**Affects:** Spring Framework version: 5.2.8  `org.springframework.kafka.core.KafkaTemplate` is using the `org.springframework.core.log.LogAccessor` `Supplier`-enabled logging methods (trace etc.). Unfortunately, `LogAccessor` does not check the currently enabled log level, so it always creates an additional `SupplierMessage` object even of the data never gets logged. In addition, in case the standard JCL -> SLF4J bridge (`jcl-over-slf4j.jar`) of the SLF4J project is being used instead of `spring-jcl`, the SLF4JLog class of this bridge unfortunately also converts the object to a string unconditionally, probably as it assumes the log level has been checked before, which slows down processing dramatically.  Assuming that the `LogAccessor` `Supplier`-enabled logging methods are intended to be called without log level check before, wouldn't it be better to at least check the log level in `LogAccessor` in these methods, to avoid creating objects / converting the objects to String unnecessarily?","closed","type: enhancement,","rschuetz","2020-09-08T12:43:46Z","2020-09-08T15:19:44Z"
"","25858","Native Hibernate 5 bootstrapping with JTA transaction manager requires hibernate.transaction.coordinator_class=jta to be set","**Affects:** Spring Framework 5.2.9.RELEASE, Hibernate 5.4.21.Final  ---  Suspected connection leak in Spring Hibernation 5 integration with using JTA transaction manager. Consider the following sample application context XML: ```xml    	  	  	 	  	 		 		 			 				 			 		 		 			 				 			 		 	  	   	 	 		 	  	 	 		 	  ```  Calling myService will be suspected connection leak due to Hibernate session has NOT been close. Debugging found `org.springframework.orm.hibernate5.SpringSessionSynchronization` has NOT been registered due to [`org.springframework.orm.hibernate5.SpringSessionContext`](https://github.com/spring-projects/spring-framework/blob/master/spring-orm/src/main/java/org/springframework/orm/hibernate5/SpringSessionContext.java#L121) returned at line 122 while `SpringSessionSynchronization` registration is in line 136.  In this example we tried to use `HibernateTransactionManager` and it is working correctly, but using ` JtaTransactionManager` encountered such issue.","closed","type: enhancement,","sammyhk","2020-10-06T03:16:45Z","2020-10-08T12:23:00Z"
"","25806","ClassCastException when wiring bean using method injection (NullBean instead of 'null')","**Affects:** Spring Framework 5.2.9.RELEASE  ---  We are upgrading from Spring 4 to Spring 5 and encountered `java.lang.ClassCastException: class org.springframework.beans.factory.support.NullBean cannot be cast to class XXX` when one of our bean configured to use method injection where the injected bean is constructed from a factory method which is possible to return null.  Considering the following example code: ```java @Configuration public class Testing {      public static class MyObject {     }      public static interface MyInterface {         MyObject getFoo();     }      public static class MyInterfaceImpl implements MyInterface {         private MyObject foo;         @Override         public MyObject getFoo() {             return foo;         }         public void setFoo(MyObject foo) {             this.foo = foo;         }     }      @Component(""myInterfaceImpl2"")     public static interface MyInterface2 extends MyInterface {         @Lookup(""myObject"")         @Override         MyObject getFoo();     }      @Bean(""myObject"")     public MyObject myObject() {         return null;     }      @Bean(""myInterfaceImpl1"")     public MyInterface myInterfaceImpl1(MyObject myObject) {         MyInterfaceImpl myInterfaceImpl1 = new MyInterfaceImpl();         myInterfaceImpl1.setFoo(myObject);         return myInterfaceImpl1;     }      public static void main(String[] args) {         try (AbstractApplicationContext applicationContext = new AnnotationConfigApplicationContext(""com.github.sammyhk.test"")) {             for (String beanName : Arrays.asList(""myInterfaceImpl1"", ""myInterfaceImpl2"")) {                 MyInterface myInterfaceImpl = applicationContext.getBean(beanName, MyInterface.class);                 MyObject myObject = myInterfaceImpl.getFoo();                 System.out.println(beanName + "": "" + myObject);             }         }     } } ``` The above code will output: ```txt myInterfaceImpl1: null Exception in thread ""main"" java.lang.ClassCastException: class org.springframework.beans.factory.support.NullBean cannot be cast to class XXX$MyObject ```  Suspected this should be a bug because traditional bean injection do not provide `org.springframework.beans.factory.support.NullBean`, only method injection encountered this issue.","closed","in: core,","sammyhk","2020-09-23T10:50:36Z","2020-10-07T11:19:19Z"
"","25785","Set the sameSite cookie attribute in ClientHttpResponse implementations","**Affects:** Spring Framework 5.2.9 (and below)  I would like to have direct access to the sameSite attribute when using `WebTestClient` (`body.getResponseCookies()`).  [ReactorClientHttpResponse#getCookies()](https://github.com/spring-projects/spring-framework/blob/47a3a5c97011a4e147db9a4cab3e85c8486fcec7/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java#L135) doesn't set the sameSite attribute on the `ResponseCookie`.  ```java this.response.cookies().values().stream().flatMap(Collection::stream) 	.forEach(c ->  		result.add(c.name(), ResponseCookie.fromClientResponse(c.name(), c.value()) 				.domain(c.domain()) 				.path(c.path()) 				.maxAge(c.maxAge()) 				.secure(c.isSecure()) 				.httpOnly(c.isHttpOnly()) 				.build())); ```  `this.response.cookies()` returns a `io.netty.handler.codec.http.cookie.Cookie` (the interface), but the implementation is `io.netty.handler.codec.http.cookie.DefaultCookie`, which supports the sameSite attribute.  Is there any compelling reason not to test if the implementation is [`DefaultCookie`](https://netty.io/4.1/api/io/netty/handler/codec/http/cookie/DefaultCookie.html#sameSite--) and if it is to set the sameSite attribute on the returned `ResponseCookie` ?","closed","type: enhancement,","DamianFekete","2020-09-18T12:36:42Z","2020-09-22T07:45:43Z"
"","25541","Webflux Routing DSL's onError filters execute in unexpected order","**Affects:** Spring Framework 5.2.7  Hello. I am trying to use the `onError` functions of the Kotlin DSL `coRouter` to create a global error handler on the root of my routes.  Everything was looking right at first, but after some times, we perceived some errors were not being captured by the right handler:  ```kotlin     @Bean     fun rootRoute() = coRouter {         GET(""/error"") { throw IOException("""") }          onError { e, _ ->  badRequest().bodyValueAndAwait(""IOException"") }         onError { e, _ -> badRequest().bodyValueAndAwait(""Exception"") }     } ```  In this MWE, it seems that every time we hit ""/error"", and therefore have an `IOException`, the exception is captured by the generic `Exception` handler, instead of by the `IOException` one. After some investigation, we discovered that if we switched the order of the `onError`s, the correct filter start being applied.  It seems that although the error filters are arranged in the correct order inside `RouterFunctionBuilder`, this ordering causes the last error handlers being verified before.  I found no documentation explaining how the `onError` handlers worked when using the `CoRouterFunctionDsl` and `RouterFunctionDsl`, but I am almost certain this is not the desired behaviour, and if it is, we have to document it better.  _______  As an extra example:  ```kotlin     @Bean     fun rootRoute() = coRouter {         GET(""/error"") { throw IOException("""") }          onError({ println(""first""); false }) { e, _ -> badRequest().buildAndAwait() }         onError({ println(""second""); false }) { e, _ -> badRequest().buildAndAwait() }     } ```  This example, when doing a GET at ""/errors"", prints the following lines:  ``` second first ```","closed","type: bug,","Megamiun","2020-08-06T02:59:55Z","2020-10-06T13:35:24Z"
"","25294","Bean not mapping entity array since 5.2.7","**Affects:** Spring Framework 5.2.7  ---  My app was working correctly with Spring Boot 2.3.0 which uses Spring Framework 5.2.6  On updating to Spring Boot 2.3.1 which users 5.2.7, some of my Web MVC forms no longer work.  The forms in question have an array of entities as one of the fields, e.g. Location[] locations, where Location is a JPA Entity I've created.  My form submits a group of checkboxes with the values as entity IDs, and up until Boot 2.3.1 Spring was transparently mapping the ID numbers submitted to the entities.  I've been digging through TypeConverterDelegate and GenericConversionService but can't seem to identify why this has stopped working. In 5.2.6 it looks like ArrayToArrayConverter kicks in to convert the String[] to a Location[] via a CollectionToArrayConverter. This then looks up a DomainClassConverter.ToEntityConverter which does the ""clever bit"" of getting the ID into an actual entity.","closed","for: external-project,","leccelecce","2020-06-20T17:47:20Z","2020-09-26T14:28:14Z"
"","25279","Mutating a ServerHttpRequest breaks the existing context path","**Affects:** Spring Framework 5.2.7  ### Context  I have a WebFlux application with many controllers, and the particular need of having to pre-process and inject additional data in some cases.  In order to do so, a `WebFilter` is used, and the `ServerHttpRequest` as well as its containing `ServerWebExchange` is mutated through their `.mutate()` methods.  Additionally, I use Spring Boot 2.3.1+, which comes with a new `spring.webflux.base-path` configuration property that seemingly sets up a `ContextPathCompositeHandler` to emulate how the context path is handled in, e.g., servlets.  ### Issue  The problem here is that setting a `WebFilter` that mutates the incoming `ServerHttpRequest` seems to break WebFlux applications that are using the new Spring Boot `spring.webflux.base-path`. Requests end up never being routed to their respective controllers, and the affected URLs will always return a 404 Not Found HTTP response.  While this is a Spring Boot configuration property, I believe that it is caused by an underlying Spring Web bug: - `getRequest().getPath().pathWithinApplication()` from `ServerWebExchange` seems to be used for routing by Spring WebFlux, as evidenced by [this line in `AbstractUrlHandlerMapping`](https://github.com/spring-projects/spring-framework/blob/dc3801043f59cfce0f17224d7937def91f21171a/spring-webflux/src/main/java/org/springframework/web/reactive/handler/AbstractUrlHandlerMapping.java#L87). - This value is set by the aforementioned `ContextPathCompositeHandler` by [mutating the context path of the incoming request](https://github.com/spring-projects/spring-framework/blob/dc3801043f59cfce0f17224d7937def91f21171a/spring-web/src/main/java/org/springframework/http/server/reactive/ContextPathCompositeHandler.java#L73). - When the [request is mutated again](https://github.com/spring-projects/spring-framework/blob/dc3801043f59cfce0f17224d7937def91f21171a/spring-web/src/main/java/org/springframework/http/server/reactive/ServerHttpRequest.java#L101) by the `WebFilter`, neither the `uriPath` nor the `contextPath` is copied [into the internally used builder](https://github.com/spring-projects/spring-framework/blob/dc3801043f59cfce0f17224d7937def91f21171a/spring-web/src/main/java/org/springframework/http/server/reactive/DefaultServerHttpRequestBuilder.java#L65). The URI itself is copied, but the information about which part is the internal application path and which part is the context path is lost.  While I'm not 100% sure that this is a bug (this might be intended?), I think that it is fair to expect no information to be lost or changed when a `ServerHttpRequest` is mutated - except of course the parts that are explicitly written otherwise.  ### Resolution  I think that changing the `mutate()` method mentioned above to create a carbon copy of the initial `ServerHttpRequest` is the way to go - or at least using its `getPath().contextPath()` as the default context path in `DefaultServerHttpRequestBuilder`. It would definitely fix the problem, although I'm not entirely sure about backwards compatibility.  As such, and since I wasn't even sure whether it was a bug or not, I wanted to open a discussion first and didn't try to fix it myself - although I would gladly open a pull request if this is confirmed to be a bug and the proposed resolution seems acceptable.  ### Example  I quickly built a small, straightforward Spring Boot project that reproduces and demonstrates the issue.  [demo.zip](https://github.com/spring-projects/spring-framework/files/4799368/demo.zip)  ### Related issues  I only found one similar issue that might be related to this underlying ""bug"": - GH-25270","closed","type: bug,","ltfourrier","2020-06-18T15:03:35Z","2020-06-22T17:21:50Z"
"","24950","HttpHeaders#getETagValuesAsList(String) does not document IAE","**Affects:** Spring Framework 5.2.5.RELEASE --- The above mentioned method does not document this: https://github.com/spring-projects/spring-framework/blob/8d31dcaa297c3e9001a6e8470b400641ae1c49d0/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L1562-L1565  This results in a 500 while it should be a 400 for the client. Either document this fact or use a `ResponseStatusException`.","closed","in: web,","michael-o","2020-04-21T10:51:29Z","2020-04-24T12:03:40Z"
"","24944","ResponseStatusExceptionResolver ignores ResponseStatusException headers","**Affects:** Spring Framework 5.2.5.RELEASE  ---  When throwing a derived exception like: ```java 	public class NotModifiedStatusException extends ResponseStatusException {  		private static final long serialVersionUID = -4380761922076567306L;  		private String etag;  		public NotModifiedStatusException(String etag) { 			super(HttpStatus.NOT_MODIFIED); 			this.etag = etag; 		}  		@Override 		public Map getHeaders() { 			return getResponseHeaders().toSingleValueMap(); 		}  		@Override 		public HttpHeaders getResponseHeaders() { 			HttpHeaders headers = new HttpHeaders(); 			headers.setETag(etag); 			return headers; 		}  	} ```  the headers are completely ignored: ``` 17:56:01,681 [http-nio-127.0.0.1-8081-exec-5] DEBUG o.s.w.s.m.a.ResponseStatusExceptionResolver: Resolved [...NotModifiedStatusException: 304 NOT_MODIFIED] 17:56:01,681 [http-nio-127.0.0.1-8081-exec-5] TRACE o.s.web.servlet.DispatcherServlet: No view rendering, null ModelAndView returned. 17:56:01,681 [http-nio-127.0.0.1-8081-exec-5] DEBUG o.s.web.servlet.DispatcherServlet: Completed 304 NOT_MODIFIED, headers={} ```  It happily ignores the headers: https://github.com/spring-projects/spring-framework/blob/8d31dcaa297c3e9001a6e8470b400641ae1c49d0/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/annotation/ResponseStatusExceptionResolver.java#L128-L133  My naive solution seems to work:  ```java @Component public class HeaderAwareResponseStatusExceptionResolver extends ResponseStatusExceptionResolver {  	@Override 	public int getOrder() { 		return super.getOrder() + 1; 	}  	@Override 	protected ModelAndView resolveResponseStatusException(ResponseStatusException ex, 			HttpServletRequest request, HttpServletResponse response, Object handler) 			throws Exception { 		int statusCode = ex.getStatus().value(); 		String reason = ex.getReason(); 		HttpHeaders headers = ex.getResponseHeaders();  		headers.forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));  		if (!StringUtils.hasLength(reason)) { 			response.sendError(statusCode); 		} else { 			response.sendError(statusCode, reason); 		} 		return new ModelAndView(); 	}  } ```","closed","type: enhancement,","michael-o","2020-04-20T16:24:44Z","2020-04-27T10:24:52Z"
"","25177","Support for shared GroovyClassLoader in GroovyScriptFactory","**Affects:** Spring Framework 4.3.4  ---  I use `ScriptFactoryPostProcessor` to create Groovy class bean and register in spring context. I have three thousand groovy file need to load.  I debug spring code and found that Spring uses `GroovyScriptFactory` to parse groovy class, but every time a new `GroovyClassLoader` is used and caues JVM metaspace space error.   ```java 	/** 	 * Build a {@link GroovyClassLoader} for the given {@code ClassLoader}. 	 * @param classLoader the ClassLoader to build a GroovyClassLoader for 	 * @since 4.3.3 	 */ 	protected GroovyClassLoader buildGroovyClassLoader(ClassLoader classLoader) { 		return (this.compilerConfiguration != null ? 				new GroovyClassLoader(classLoader, this.compilerConfiguration) : new GroovyClassLoader(classLoader)); 	} ```  ### Issue  why Every time new `GroovyScriptFactory` instance to parse groovy?  groovy in jave8 has metaspace bug. see  https://stackoverflow.com/questions/37301117/java-groovy-memory-leak-in-groovyclassloader  To solve this bug, we need to use global `GroovyClassLoader` instance to parse groovy.  how to solve ?","closed","type: enhancement,","change2","2020-06-02T13:20:59Z","2020-06-10T09:00:22Z"
"","25315","ReactorNetty websocket issue for multiple clients with different protocols","**Affects:** Spring Framework >= v5.2.6  ---   We've observed an issue, using spring-cloud-gateway, where websocket handshakes fail if different clients, with different websocket protocols, are connecting in succession: 1. wsClientA connects without any (sub-)protocol -> success  2. wsClientB connects with protocol `v10.stomp` -> success 3. wsClientA connects without any protocol -> failure  The bug first appeared in spring-webflux v5.2.6, with the newly introduced [ReactorNettyRequestUpgradeStrategy](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/ReactorNettyRequestUpgradeStrategy.java) (#24959 -> [0520ee0](https://github.com/spring-projects/spring-framework/commit/0520ee0fb62464687b74e7ad3bc234c30baa3732), ping @rstoyanchev).   The global `WebsocketServerSpec.Builder` is mutated for each request, persisting the client-specific protocol across requests, and thereby potentially breaking subsequent requests for clients with different (or `null`) subprotocols (see [ReactorNettyRequestUpgradeStrategy.java#L89](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/ReactorNettyRequestUpgradeStrategy.java#L89)).   In the example above, the third handshake request is silently aborted in [HttpServerOperations.java#L649](https://github.com/reactor/reactor-netty/blob/master/src/main/java/reactor/netty/http/server/HttpServerOperations.java#L649), because `websocketServerSpec.protocols()` is set (by the second request), but `ops.selectedSubprotocol()` is `null`.  I created a simple WebSocketIntegration testcase to reproduce the issue:  https://github.com/Croissong/spring-framework/blob/ReactorNetty-websocket-protocol-bug/spring-webflux/src/test/java/org/springframework/web/reactive/socket/ReactorNettyWebsocketProtocolBugTests.java. The test fails for all combinations using the ReactorHttpServer. However, the ReactorNettyWebSocketClient uses the same logic: [ReactorNettyWebSocketClient.java#L111](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/socket/client/ReactorNettyWebSocketClient.java#L111).","closed","type: regression,","Croissong","2020-06-25T09:26:39Z","2020-07-20T15:08:59Z"
"","25815","Fail to map GET query params in pojo","**Affects:** Spring boot 2.4.0-SNAPSHOT **Affects:** Spring boot 2.3.4.RELEASE **Affects:** Spring boot 2.1.9.RELEASE  --- Same behavior with kotlin version 1.3.72 and 1.4.10 Tested with java 8  ---  I try to map a GET request into a pojo class in kotlin. The method param resolver fail to map properly the query params.  I used to have no problem to do this mapping in Java; I am not sure anymore but I think it was working before for Kotlin with Set/List/etc. Now it does not work anymore.  I don't think I have to implement my own HandlerMethodArgumentResolver  for all my custom criterias, I use only basic fields, and java works but not kotlin.  I know about StringToCollectionConverter, DelimitedStringToCollectionConverter and etc but it does not seem to be working with Kotlin Data class (or normal class)  With examples below we see that if I repeat the key and use one value per key then I get good collection for java/kotlin but if I use comma separated values for kotlin then it will either throw due to cast fail either put the whole string as one value.  The behavior is different between Java and Kotlin; they should have same behavior (and so support same as Java -> comma separated values)  --- Do a get with: `localhost:8080/test/param/test-1?projectIdIn2=1,2,3&projectIdIn3=1,2,4&projectIdIn4=1,2,5&projectIdIn5=1,2,6&projectIdIn6=1,2,7&projectIdIn8=1,2,9&projectIdIn1=1&projectIdIn1=3`  Fail with `2020-09-25 15:36:19.865  WARN 10780 --- [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.method.annotation.ModelAttributeMethodProcessor$1: org.springframework.validation.BeanPropertyBindingResult: 2 errors Field error in object 'simpleCriteria' on field 'projectIdIn3': rejected value [1,2,4]; codes [typeMismatch.simpleCriteria.projectIdIn3,typeMismatch.projectIdIn3,typeMismatch.java.util.Set,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [simpleCriteria.projectIdIn3,projectIdIn3]; arguments []; default message [projectIdIn3]]; default message [Failed to convert value of type 'java.lang.String[]' to required type 'java.util.Set'; nested exception is java.lang.NumberFormatException: For input string: ""1,2,4""] Field error in object 'simpleCriteria' on field 'projectIdIn5': rejected value [1,2,6]; codes [typeMismatch.simpleCriteria.projectIdIn5,typeMismatch.projectIdIn5,typeMismatch.java.util.List,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [simpleCriteria.projectIdIn5,projectIdIn5]; arguments []; default message [projectIdIn5]]; default message [Failed to convert value of type 'java.lang.String[]' to required type 'java.util.List'; nested exception is java.lang.NumberFormatException: For input string: ""1,2,6""]]`  --- Same request as above but with java pojo: `localhost:8080/test/param/test-java-1?projectIdIn2=1,2,3&projectIdIn3=1,2,4&projectIdIn4=1,2,5&projectIdIn5=1,2,6&projectIdIn6=1,2,7&projectIdIn8=1,2,9&projectIdIn1=1&projectIdIn1=3`  It will return a JSON: `{""projectIdIn1"":[1,3],""projectIdIn2"":[""1"",""2"",""3""],""projectIdIn5"":[1,2,6],""projectIdIn6"":[""1"",""2"",""7""]}`  --- Request for: `localhost:8080/test/param/test-3?projectIdIn2=1,2,3&projectIdIn3=1,2,4&projectIdIn4=1,2,5&projectIdIn5=1,2,6&projectIdIn6=1,2,7&projectIdIn7=1,2,8&projectIdIn8=1,2,9&enum2=beijing,shanghai&projectIdIn1=5&projectIdIn1=6`  Result: `{""projectIdIn1"":[5,6],""projectIdIn2"":[""1"",""2"",""3""],""projectIdIn3"":[1,2,4],""projectIdIn4"":[""1"",""2"",""5""],""projectIdIn5"":[1,2,6],""projectIdIn6"":[""1"",""2"",""7""],""projectIdIn7"":[1,2,8],""projectIdIn8"":[""1"",""2"",""9""],""enum1"":null,""enum2"":[""beijing"",""shanghai""],""enum3"":null}`  ---  ```  @RestController @RequestMapping(""/test/param"") class TestController {      @GetMapping(""/test-java-1"")     fun test1(criteria: JavaCriteria): JavaCriteria {         return criteria     }      @GetMapping(""/test-1"")     fun test1(criteria: SimpleCriteria): SimpleCriteria {         return criteria     }      @GetMapping(""/test-3"")     fun test3(             @RequestParam projectIdIn1: Set? = null,             @RequestParam projectIdIn2: Set? = null,             @RequestParam projectIdIn3: Set? = null,             @RequestParam projectIdIn4: Set? = null,             @RequestParam projectIdIn5: List? = null,             @RequestParam projectIdIn6: List? = null,             @RequestParam projectIdIn7: List? = null,             @RequestParam projectIdIn8: List? = null     ): SimpleCriteria {         return SimpleCriteria(                 projectIdIn1,                 projectIdIn2,                 projectIdIn3,                 projectIdIn4,                 projectIdIn5,                 projectIdIn6,                 projectIdIn7,                 projectIdIn8         )     }  }  typealias ProjectId = Long typealias ProjectIdNew = String  data class SimpleCriteria(         val projectIdIn1: Set? = null, // fails to convert 1,2         val projectIdIn2: Set? = null, // Get a list with one element ""1,2""         val projectIdIn3: Set? = null, // fails to convert 1,2         val projectIdIn4: Set? = null, // Get a list with one element ""1,2""         val projectIdIn5: List? = null, // fails to convert 1,2         val projectIdIn6: List? = null, // Get a list with one element ""1,2""         val projectIdIn7: List? = null, // fails to convert 1,2         val projectIdIn8: List? = null // Get a list with one element ""1,2"" )  public class JavaCriteria {      private Set projectIdIn1;     private Set projectIdIn2;     private List projectIdIn5;     private List projectIdIn6;      public JavaCriteria() {     }      public Set getProjectIdIn1() {         return projectIdIn1;     }      public void setProjectIdIn1(final Set projectIdIn1) {         this.projectIdIn1 = projectIdIn1;     }      public Set getProjectIdIn2() {         return projectIdIn2;     }      public void setProjectIdIn2(final Set projectIdIn2) {         this.projectIdIn2 = projectIdIn2;     }      public List getProjectIdIn5() {         return projectIdIn5;     }      public void setProjectIdIn5(final List projectIdIn5) {         this.projectIdIn5 = projectIdIn5;     }      public List getProjectIdIn6() {         return projectIdIn6;     }      public void setProjectIdIn6(final List projectIdIn6) {         this.projectIdIn6 = projectIdIn6;     }      @Override     public boolean equals(final Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         final JavaCriteria that = (JavaCriteria) o;         return Objects.equals(projectIdIn1, that.projectIdIn1) &&                 Objects.equals(projectIdIn2, that.projectIdIn2) &&                 Objects.equals(projectIdIn5, that.projectIdIn5) &&                 Objects.equals(projectIdIn6, that.projectIdIn6);     }      @Override     public int hashCode() {         return Objects.hash(projectIdIn1, projectIdIn2, projectIdIn5, projectIdIn6);     }      @Override     public String toString() {         return ""JavaCriteria{"" +                 ""projectIdIn1="" + projectIdIn1 +                 "", projectIdIn2="" + projectIdIn2 +                 "", projectIdIn5="" + projectIdIn5 +                 "", projectIdIn6="" + projectIdIn6 +                 '}';     } }  ```","open","in: web,","Blackdread","2020-09-25T07:43:54Z","2021-11-08T11:46:09Z"
"","25317","Rest Template is not thread safe for headers when there are lot of concurrent threads","**Affects:** Spring Boot 2.2.6  ---  When we use a shared RestTemplate across multiple threads, there are issues when lot of concurrent threads are setting different headers while sending the request.  We could see that RestTemplate is sending wrong headers (set by another request thread) in outgoing request for a request thread.  Our code is simply autowiring and using a single common instance using @Bean and rest template builder.  **Config Class** ```java @Configuration public class MyRestTemplateConfig {   @Autowired   private RestTemplateBuilder restTemplateBuilder;    @Bean   public RestTemplate myRestTemplate() {     return restTemplateBuilder.build();   } } ```  **Client where it's injected** ```java   @Autowired   @Qualifier(""myRestTemplate"")   public RestTemplate myRestTemplate; ```  **Code where it's used** ```java HttpEntity requestEntity = new HttpEntity(payload, headers); myRestTemplate.exchange(url, method, requestEntity, responseType); ```  Someone else also ran into this issue: https://stackoverflow.com/questions/59621966/spring-resttemplate-seems-to-not-be-thread-safe-wrt-headers  This problem can be reproducible by sending multiple concurrent requests (with different headers) with JMeter. Add unique IDs to those requests to trace. You can check the incoming headers in target server. RestTemplate is mismatching headers sometimes.","closed","","rahulrastogi8","2020-06-25T14:17:35Z","2020-07-14T07:31:40Z"
"","24895","resttemplate not send body unicode chars","**Affects:** Spring Boot 2.1.13  --- i have tryed to send same body with: curl, postman and rest template with java.  with rest template chars not show correctly ```java private CompletableFuture sendToFCM(String entity, String firebaseServerKey) {         RestTemplate restTemplate = new RestTemplate();          HttpHeaders headers = new HttpHeaders();         headers.setContentType(MediaType.APPLICATION_JSON);         headers.set(""Authorization"", ""key="" + firebaseServerKey);         HttpEntity request = new HttpEntity(entity, headers);         restTemplate.getMessageConverters().add(0, new StringHttpMessageConverter(StandardCharsets.UTF_8));          String firebaseResponse = restTemplate.postForObject(FIREBASE_API_URL, request, String.class);         return CompletableFuture.completedFuture(firebaseResponse);     } ``` I attach > curl -X POST --header ""Authorization: key=KEY IS HIDDEN""     --Header ""Content-Type: application/json;charset=ISO-8859-1""     https://fcm.googleapis.com/fcm/send     -d '{""to"":""/topics/VgtARwhilq"",""notification"":{""body"":""\uD83D\uDD25"",""content_available"":true,""priority"":""high"",""title"":""\uD83D\uDD25""},""data"":{""click_action"":""FLUTTER_NOTIFICATION_CLICK"",""body"":""\uD83D\uDD25"",""title"":""\uD83D\uDD25"",""content_available"":true,""priority"":""high""}}'  curl or postman result is right ![call with curl](https://user-images.githubusercontent.com/14055863/79001979-ca9ad900-7b4f-11ea-8d5c-76d50f57170f.jpeg)  Can you help me?  Best Regards","closed","for: stackoverflow,","sante85","2020-04-10T15:23:38Z","2020-04-15T15:55:23Z"
"","25129","@TransactionalEventListener cannot work with TaskExecutor","**Affects:** Spring 4.2 --- I came to believe that a `@TransactionalEventListener` cannot work with a `applicationEventMulticaster` bean that uses a `taskExecutor` that invokes the listener call in a new / different thread. Inside a new thread, which cannot be transaction synchronized in my understanding, the call to the listener will be discarded, unless the `@TransactionalEventListener(fallbackExecution = true)` is set. So, proper coupling to a transaction seems to be impossible.  Should you desire a true asynchronous invocation on other event handlers, you will have to provide a task executor that delegates the invocation to different threads.  JavaDoc doesn't indicate that `@TransactionalEventListener` cannot work with a non-synchronous task executor in place. But, I might be doing something wrong after all. As far as I can tell, the code in spring-tx library behaves as it should, but can only work when no task executor is used at all in the event multicaster, or an executor like `org.springframework.core.task.SyncTaskExecutor` is used.","closed","status: invalid,","weaselmetal","2020-05-26T12:03:45Z","2020-05-26T15:32:40Z"
"","25614","Spring Content Indexer is not incremental","**Affects:** org.springframework:spring-context-indexer:5.2.8  Running Gradle build with `--info` shows that Spring Content Indexer causes full recompilation, even if totally unrelated file is changed in our project.   > Full recompilation is required because org.springframework.context.index.processor.CandidateComponentsIndexer is not incremental. Analysis took 0.042 secs.  Anything I can do to help with this issue? Are there any practical reasons why we can't declare the processor as incremental?   ---","open","type: enhancement,","sergekukharev","2020-08-19T14:31:21Z","2020-08-20T11:53:52Z"
"","25099","WebSocketMessage's methods `fromMessage` and `toFrames` ignore  Netty WebSocketFrame metadata","**Affects:** LATEST (since ReactorNettyWebSocketSession introduced)  ## Expected Behavior Add metadata property to the WebSocketMessage POJO. And by-pass Netty WebSocketFrame metadata in ReactorNettyWebSocketSession implementation.  ## Motivation To allow proxy compressed WebSocket frames through Spring Cloud Gateway metadata of the [WebSocketFrame](https://github.com/netty/netty/blob/f66412c84c57f77915accb003dec8dc9b3896afe/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java#L31-L36)  (`rsv` and  `finalFragment`) should be processed. This will open the possibility to proxy frames ""as is"" and avoid unwanted decompress\compress cycles inside the proxy service.  This will be also useful for the Undertow implementation soon since the migration to Netty was announced(http://undertow.io/blog/2019/04/15/Undertow-3.html) Metadata can be useful for other implementation in the future.   ## Possible Solution Since internal Spring WebSocketMessage is the generic POJO for the multiple servers I'd propose adding some metadata to the WebSocketMessage which and use it for any metadata needs to be passed through the `toMessage` and `toFrame` methods.   For the specific ReactorNettyWebSocketSession implementation it may looks like: ```java //avoided constants similar extractions     protected WebSocketMessage toMessage(WebSocketFrame frame) {         DataBuffer payload = bufferFactory().wrap(frame.content());          return new WebSocketMessage(messageTypes.get(frame.getClass()), payload,extractFrameMetadata(frame));     }      private void extractFrameMetadata(WebSocketFrame frame) {         Map frameMetadata = new HashMap();         frameMetadata.put(""rsv"",frame.rsv());         frameMetadata.put(""finalFragment"", frame.isFinalFragment());     }      protected WebSocketFrame toFrame(WebSocketMessage message) {         ByteBuf byteBuf = NettyDataBufferFactory.toByteBuf(message.getPayload());         if (WebSocketMessage.Type.TEXT.equals(message.getType())) {             return new TextWebSocketFrame(byteBuf,message.getMetadataEntry(""rsv""), message.getMetadataEntry(""finalFragment""));         }         else if (WebSocketMessage.Type.BINARY.equals(message.getType())) {             return new BinaryWebSocketFrame(byteBuf,message.getMetadataEntry(""rsv""), message.getMetadataEntry(""finalFragment""));         }         else if (WebSocketMessage.Type.PING.equals(message.getType())) {             return new PingWebSocketFrame(byteBuf,message.getMetadataEntry(""rsv""), message.getMetadataEntry(""finalFragment""));         }         else if (WebSocketMessage.Type.PONG.equals(message.getType())) {             return new PongWebSocketFrame(byteBuf,message.getMetadataEntry(""rsv""), message.getMetadataEntry(""finalFragment""));         }         else {             throw new IllegalArgumentException(""Unexpected message type: "" + message.getType());         }     } ```","closed","type: enhancement,","Fetsivalen","2020-05-18T21:21:42Z","2020-07-27T18:21:08Z"
"","25119","[Improvement] Add ability to configure response timeout for handshake operation in WebSocketClient","**Affects:** Latest  ## Expected Behavior WebSocketClient should give an ability to configure timeout fro the handshake operation, and not discards established Web-Socket connection. for the reactor netty solution was described in [this comment](https://github.com/reactor/reactor-netty/issues/1100#issuecomment-631229421)    ## Actual Behavior [Reactor timeout](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder-reactor-timeout) applied after [execute](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/socket/client/ReactorNettyWebSocketClient.java#L132) acts as a response timeout for the Http request, but as well discards established Web-Socket connection.  In the Reactor-netty there are 2 separate methods for establishing Handshake and maintaining the established connections in [WebsocketFinalizer](https://github.com/reactor/reactor-netty/blob/master/src/main/java/reactor/netty/http/client/WebsocketFinalizer.java#L83-L88) and it will be handy to have similar API in WebSocketClient.","open","in: web,","Fetsivalen","2020-05-22T15:48:59Z","2021-11-12T12:09:02Z"
"","24873","Avoid using Regex for matching URL paths when possible as doing so causes more of the request time to be spent in regex then doing the API call itself.","**Affects:** I don't know of a version this does not affect.  Hi, profiling reveals that a bunch of time is spent in in this stack trace: ```     at java.base@11.0.3/java.util.regex.Matcher.(Matcher.java:248)     at java.base@11.0.3/java.util.regex.Pattern.matcher(Pattern.java:1133)     at org.springframework.util.AntPathMatcher$AntPathStringMatcher.matchStrings(AntPathMatcher.java:686)     at org.springframework.util.AntPathMatcher.matchStrings(AntPathMatcher.java:421)     at org.springframework.util.AntPathMatcher.doMatch(AntPathMatcher.java:218)     at org.springframework.util.AntPathMatcher.match(AntPathMatcher.java:177)     at org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getMatchingPattern(PatternsRequestCondition.java:258)     at org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getMatchingPatterns(PatternsRequestCondition.java:223)     at org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getMatchingCondition(PatternsRequestCondition.java:205)     at org.springframework.web.servlet.mvc.method.RequestMappingInfo.getMatchingCondition(RequestMappingInfo.java:229)     at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:93)     at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:57)     at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.addMatchingMappings(AbstractHandlerMethodMapping.java:428)     at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:394)     at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:368)     at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:65)     at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:401)     at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1231)     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1014)     at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)     at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005)     at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ```  I think this is trying to work out which API method to call and to do that it is matching the URL path against a regex. Regex is extremely slow, by using regex here it makes the APIs spend most of their time in this rather than doing the actual work. This is not good especially when we want to use spring to slice up an application served over many APIs e.g. micro services. I think a case in which this gets especially bad is when many APIs exist, I think this does a linear search :(.  One step towards not having all time spent in this regex matching would be to create simple matchers for some of the more trivial and common cases like those where the API method is not presenting a complex regex. I think some thought might need to go into this, you may want to collection the `value` of a bunch of `@RequestMapping`s to find out what common styles of request mappings are in use.  I think this is looking at all `@RequestMapping` trying to find which ones match, perhaps what might also work is having the matcher defined as two sections a quick match which is fast to exclude (e.g. path length, starts with X etc) and if that matches then go on to the slow regex matching.","closed","status: declined,","LukeButters","2020-04-07T03:55:20Z","2020-04-24T07:10:22Z"
"","25231","Document exception handling limitations in TaskDecorator implementations (specifically for ThreadPoolTaskExecutor#submit)","**Affects:** demonstrated against 5.2.6.RELEASE  `ThreadPoolTaskExecutor.setTaskDecorator()` allows you to, for example, catch and log any exceptions thrown by tasks submitted to the executor. In my application this functionality is very important, because otherwise bugs that cause exceptions would be completely swallowed and lurk indefinitely, unnoticed.  The bug is that this works if you use `ThreadPoolTaskExecutor.execute()` to submit your task, but it doesn't work if you use `ThreadPoolTaskExecutor.submit()` to submit your task.  Basically, when invoking any `ThreadPoolTaskExecutor` method that returns a `Future`, there is extra wrapping involved that catches and swallows thrown exceptions before they can reach the configured `TaskDecorator`. This is a reversed wrapping order from that one would expect.  Here's a program that demonstrates the problem:  ```java import org.springframework.core.task.TaskDecorator; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;  public class ThreadPoolTaskExecutorBug {      public static void main(String[] args) throws Exception {          // Setup executor         ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();         executor.setTaskDecorator(action -> () -> {             try {                 System.out.println(""invoking "" + action + "".run()"");                 action.run();                 System.out.println(""successful return from "" + action + "".run()"");             } catch (Throwable t) {                 System.out.println(""caught exception from "" + action + "".run(): "" + t.getMessage());             }         });         executor.afterPropertiesSet();          System.out.println();         System.out.println(""TEST #1"");         executor.execute(new Action(1));         Thread.sleep(500);          System.out.println();         System.out.println(""TEST #2"");         executor.submit(new Action(2));         Thread.sleep(500);          System.out.println();         executor.shutdown();     }      public static class Action implements Runnable {          private final int id;          public Action(int id) {             this.id = id;         }          @Override         public void run() {             System.out.println(this + "": run() invoked"");             System.out.println(this + "": run() throwing exception"");             throw new RuntimeException(""exception thrown by "" + this);         }          @Override         public String toString() {             return ""Action#"" + this.id;         }     } } ```  Here's the output:  ``` Jun 10, 2020 10:32:18 AM org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor initialize INFO: Initializing ExecutorService  TEST #1 invoking Action#1.run() Action#1: run() invoked Action#1: run() throwing exception caught exception from Action#1.run(): exception thrown by Action#1  TEST #2 invoking java.util.concurrent.FutureTask@62f7c498.run() Action#2: run() invoked Action#2: run() throwing exception successful return from java.util.concurrent.FutureTask@62f7c498.run()  Jun 10, 2020 10:32:19 AM org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor shutdown INFO: Shutting down ExecutorService ```  Note that under `TEST #2` the action throws an exception, just like in `TEST #1`, but the configured `TaskDecorator` never gets a chance to catch and log the exception.","closed","in: core,","archiecobbs","2020-06-10T15:36:38Z","2020-06-10T21:31:13Z"
"","25432","@MockBean(answer: org.mockito.Answers, ...) should be interface to allow custom answers","**Affects:** current, see https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/mock/mockito/MockBean.html  ---  I am trying to get my mock to return a custom exception for every method call. This should be fairly easy by passing it a custom `answer` implementation which `implements Answer` and overrides `public Object answer(InvocationOnMock invocation) throws Throwable`.  For example consider this example modeled after `org.mockito.Answers` (which is referenced in the API doc): ```java package com.foo.utils;  import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;  public enum ExceptionAnswers implements Answer {   RUNTIME_EXCEPTION(new RuntimeExceptionAnswer());     private final Answer implementation;    ExceptionAnswers(Answer implementation) {     this.implementation = implementation;   }    @Override   public Object answer(InvocationOnMock invocation) throws Throwable {     return implementation.answer(invocation);   }    public static class RuntimeExceptionAnswer implements Answer {     public Object answer( InvocationOnMock invocation ) {       throw new RuntimeException ( invocation.getMethod().getName() + "" threw RuntimeException"" );     }   } } ```  and its usage as for example  ```java package com.allianz.cee.sme.controller;  import com.foo.service.CompanyService; import com.foo.utils.ExceptionAnswers; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc;  import static io.restassured.module.mockmvc.RestAssuredMockMvc.given;  @SpringBootTest @AutoConfigureMockMvc class CompanyControllerTest {    @Autowired   MockMvc mockMvc;    @MockBean(answer = ExceptionAnswers.RUNTIME_EXCEPTION)   CompanyService mockService;    @Test   void doSomething(){...} } ```  However, this will give me the following error:  *Incompatible types. Found: 'com.foo.utils.ExceptionAnswers', required: 'org.mockito.Answers'*  This hard dependency on the mockito.Answers enum prevents any extension and customization as an enum can not be extended.  Now the great thing is that mockito.Answers already `implements Answer` so all that needs to be done is to change the type of @MockBean's `answer` field.  Please let me know if you need more information.  Cheers!","open","in: test,","MrTomato","2020-07-20T14:09:25Z","2021-11-10T11:50:23Z"
"","25782","Unable to change Clock for spring framework scheduling","**Affects:** All versions, tested with 4.3.10 and verified to still be a problem in tip of master ec97089  ---   It seems that Spring task scheduler implementation still uses old java.util.Date for some of its timings (esp. tasks delayed by time) and it is not possible to easily inject a different clock source, such as java.time.Clock bean instance or via SchedulerConfigurer.  Such a feature would be very valuable for unit testing time-dependent functionality, which now requires use of PowerMock or JMockit to directly patch System.currentTimeMillis, Clock.systemUTC or both.","closed","type: enhancement,","AstralStorm","2020-09-17T09:42:21Z","2020-09-18T08:31:43Z"
"","25494","Extract Controller API to separate package","**Affects:** All  ---   There is a really nice consequence of how the official Jax-RS API is structured. Since the implementation of the Jax-RS API is not packaged with the API itself (obviously) there is a way to define REST APIs by creating a package, let's call it _service-api_ so that not only the methods, but all the URI paths, the request methods, or even the accepted mime-types can be defined for every method in the _service-api_ package.  Based on this package we can create the _service-client_ and _service-impl_ modules so that both packages instantly know how to communicate with eachother through the defined REST API and none of the API information needs to get duplicated.  A similar feature (although not necessarily bounded to REST APIs) could be achieved with the Spring framework by extracting the @Controller, ResponseEntity and related annotations/classes to a different package.  It could be a nice addition to the way teams implement REST APIs. The reason a team might not want to use Jax-RS instead of Spring controller is that there are some nice features already in the Spring Controllers, for example, that the ResponseEntity can take a generic type, as opposed to the Jax-RS's Response, or the way Spring controllers handle exceptions.  ----------------------  Maybe the above description is a little cluttered, so I'll try and show an example of what I'm thinking about:  We have 3 packages: _service-api_, _service-impl_, _service-client_:  *service-api.jar:* ```  @RequestMapping(""/api/service"") public interface Service {     @GetMapping     ResponseEntity getStuff(); } ```  *service-impl.jar:* ``` @RestController public class ServiceImpl implements Service {     // ... } ```  *service-client.jar:* ``` @Configuration public class Config {     @Bean     public Service client() {         return RestClient.api(Service.class);     } }  @Component public class SomeBean {     @Autowired     private Service client;      // ...      public void callService() {         client.getStuff();     }      // ...  } ```","closed","in: web,","rolaca11","2020-07-30T15:44:50Z","2020-09-03T13:53:26Z"
"","25756","Spring Integration Issue With Latest XXE Patch and WebSphere 9.0","**Affects:** \Spring Integration Versions: >=4.3.19 >=5.0.11 >=5.1.2 Related to the Spring Integration versions found here: [https://github.com/advisories/GHSA-wr5r-m8pc-85j9] ---  When we deployed our application with Spring Integration 5.3.2.RELEASE we discovered that our application failed to deploy to WebSphere 9.0 via script or the console. Deploying via Eclipse worked fine. In the WebSphere SystemOut.log, we found the following error message: ""org.springframework.xml.validation.XmlValidationException: Could not create Schema: Failed to load external schema document ""wsjar:file:..."", because ""wsjar"" access is not allowed"". This occurred when loading XSD files contained in another jar from our interfaces war.  We traced the issue to the org.springframework.xml.validation.SchemaFactoryUtils. class called via Jaxp15ValidatorFactory.createValidator(...) and SchemaLoaderUtils.loadSchema(...). The SchemaFactoryUtils.newInstance(...) method has a hard coded list of protocols (see attached image of code). This list does not include WebSphere's proprietary wsjar protocol. ![SchemaFactoryUtils_MissingWSJARProtocol](https://user-images.githubusercontent.com/33791605/92931312-45bf2e80-f411-11ea-9d0e-bfe2a7f0a51a.jpg)  To resolve our issue, we created a custom XML validator, which adds wsjar to the accepted protocols and applied to our int-xml:validating-filter in our integration flow configuration.","closed","for: external-project,","willweyant","2020-09-11T13:40:00Z","2020-09-11T14:10:50Z"
"","25542","Spring 5.2.2 documentation index incorrect","**Affects:** \Spring 5.2.2  ---  I hope this is the right place to report issues regarding the documentation.  It seems that the documentation of spring-framework core is not parsed correctly and the chapters towards the end (e.g., about validation) do not appear in the index. See https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html .","closed","status: duplicate,","karge-itestra","2020-08-06T06:54:00Z","2020-08-06T13:27:27Z"
"","25707","CallMetaDataContext.reconcileParameters overwrites cursor name","**Affects:** \SB2 org.springframework:spring-jdbc:5.1.9.RELEASE Explanation. Existing code is using a named cursor. When the Resultset comes back, it is always empty, even though when I debug through the spring-jdbc I see it getting created with correct results. The issue is with the named cursor.  Example:  > this.simpleJdbcCall = new SimpleJdbcCall(jdbcTemplate) >                 .withSchemaName(""schema"") >                 .withFunctionName(""functionName"") >                 .returningResultSet(""myCursorName"", mapperInstance);  if I name the cursor 'returnValue' then it works. Searching through the code, I saw that it is over writing 'myCursorName' with 'returnValue'. 'returnValue' seems to be the default name used internally. In SimpleJdbcCall:  > 	public  T executeFunction(Class returnType, SqlParameterSource args) { > 		return (T) doExecute(args).get(getScalarOutParameterName()); > 	}  'getScalarOutParameterName()' is returning 'returnValue' even though I named it as '.returningResultSet(""myCursorName"",'  But I also traced this to `CallMetaDataContext.reconcileParameters` around line 396:  > 	param = declaredParams.get(getFunctionReturnName()); > 	if (param == null && !getOutParameterNames().isEmpty()) { > 		param = declaredParams.get(getOutParameterNames().get(0).toLowerCase()); > 	} > 	if (param == null) { > 		throw new InvalidDataAccessApiUsageException( > 				""Unable to locate declared parameter for function return value - "" + > 				"" add an SqlOutParameter with name '"" + getFunctionReturnName() + ""'""); > 	} > 	else if (paramName != null) { > 		setFunctionReturnName(paramName); > 	}  In older version it used to have (the last 3 lines):  > 	else { > 		setFunctionReturnName(param.getName()); > 	}  paramName is 'returnValue', but it should be using what I supplied which is 'param.getName()'. Then this would return the correct ruleset: return (T) doExecute(args).get(getScalarOutParameterName());  Please advise. Thanks.","closed","type: regression,","javadoug4","2020-09-04T17:31:56Z","2020-09-05T11:13:06Z"
"","25465","PathMatchingResourcePatternResolver does not return the subdirectory of a URL resource in Quarkus.","**Affects:** \5.2.8.RELEASE  --- I use `org.springframework.core.io.support.PathMatchingResourcePatternResolver` to find resources packaged inside a jar which are in a subdirectory.  When I do this in a normal Java application the resource that is found correctly looks like this:      URL [jar:file:/home/nbasjes/.m2/repository/org/acme/resourcelib/1.0-SNAPSHOT/resourcelib-1.0-SNAPSHOT.jar!/Content/world.txt]  yet when I run the exact same code in a Quarkus application it finds the file yet the returned resource does not have the subdirectory of the file.      URL [jar:file:/home/nbasjes/.m2/repository/org/acme/resourcelib/1.0-SNAPSHOT/resourcelib-1.0-SNAPSHOT.jar!/world.txt]  So the difference is that in the Quarkus setup the resource is not reported in the actual subdirectory it is really stored in. Thus: loading the resource will fail with a file not found.  I was able to create a very small reproduction of the problem. https://github.com/nielsbasjes/BugReport-SpringQuarkus-ResourceLoading  Note that this was reported as a bug in the library I have written: https://github.com/nielsbasjes/yauaa/issues/216","closed","for: external-project,","nielsbasjes","2020-07-23T17:36:07Z","2020-07-23T20:05:29Z"
"","25755","MimeMessageHelper.addAttachment: configurable encoding of attachment filename","**Affects:** \5.2.8.RELEASE  ---   I've encountered the following issue in `org.springframework.mail.javamail.MimeMessageHelper#addAttachment(java.lang.String, javax.activation.DataSource)`:  The attachment filename ist added to the MimeBodyPart after calling MimeUtility.encodeText(): `mimeBodyPart.setFileName(MimeUtility.encodeText(attachmentFilename));`  For longer filenames with non-ASCII characters like german umlauts, this results in a wrong encoding of the filename.   Example: Filename is:  `xxxxxxxxxxxxxxxxx xxxxxäxßxxxxx xxxxxxx.pdf`  This get's encoded as: ``` Content-Type: application/pdf; name*0=""=?UTF-8?Q?xxxxxxxxxxxxxxxxx=5Fxxxxx=C3=A4u=C3=9Fxxxxx=5Fxxx""; name*1=""xxxx.pdf?="" Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename*0=""=?UTF-8?Q?xxxxxxxxxxxxxxxxxx=5Fxxxxx=C3=A4x=C3=9Fxxxxx=5Fxxx""; filename*1=""xxxx.pdf?="" ```  Please note: - The encoded filename starts with =?UTF-8?Q?, which implies encoding according to RFC-1342 - The encoded filename is splitted into two lines, indicated by the parameter name suffiexes *0 and *1. This implies encoding accroding to RFC-2231.   This mix of encodings is invalid and it leads to a faulty display of attachment filenames in mailclients, most prominently perhaps Microsoft Outlook.  Please refer to the javamail FAQ for more details: https://javaee.github.io/javamail/FAQ#encodefilename  Would it be possible to remove the call to MimeUtility.encodeText from this method or make it optional?  (edit: fixed typos)","closed","type: enhancement,","achimbitzer","2020-09-11T09:18:00Z","2020-09-14T20:42:44Z"
"","25240","The AbstractTemplateViewResolver class is not abstract","**Affects:** \5.2.6.RELEASE and minor (since 1.1)  ---   If I see the javadoc of the [AbstractTemplateViewResolver](https://docs.spring.io/spring/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/view/AbstractTemplateViewResolver.html) class, it indicates:  ``` public class AbstractTemplateViewResolver extends UrlBasedViewResolver  Abstract base class for template view resolvers, in particular for FreeMarker views. ```  Well the class really is not abstract how is expected.  Of course it comes from the source code:  * [AbstractTemplateViewResolver.java](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractTemplateViewResolver.java)","closed","in: core,","manueljordan","2020-06-11T19:45:03Z","2020-06-11T21:58:19Z"
"","25134","QueryDslPredicateExecutor should support deleting by predicate","**Affects:** \5.2.6.RELEASE  [QueryDslPredicateExecutor](https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/querydsl/QuerydslPredicateExecutor.java) supports querying by a QueryDsl predicate but does not support  deleting items by a Predicate. It would be useful to also support deletion via predicate.","closed","for: external-project,","yissacharcw","2020-05-26T21:28:26Z","2020-05-27T09:24:29Z"
"","24979","ResourceUtils.isUrl not considers classpath*: a valid protocol","**Affects:** \5.2.5  Discovered when trying to set `spring.cloud.bootstrap.location` to something like `classpath*:/config/`, but it didn't work because internally SpringBoot calls `org.springframework.util.ResourceUtils#isUrl` with supplied location and when receives `false` prepends it with `file:`. As a result it ends up with `file:classpath*:/config/` in my case, which is obviously incorrect.  ### Expected result `ResourceUtils.isUrl(""classpath*:/some/path/"") == true` just like in case of another pseudo-protocol `classpath:`.","closed","status: invalid,","vkochnev","2020-04-26T20:58:02Z","2020-04-27T11:03:47Z"
"","24982","Cannot use SpEL expression to inject an array into @CrossOrigin's value attribute","**Affects:** \5.2.2  we usually inject an array use comma like this： ```properties key=A,B,C ``` ```java @Value(""${key}"") String[] keys; ```  but can't inject an array like below ```properties origin=http://domainA.com,http://domainB.com ``` only key have one element, below SpEL can work fine, if key have more than 2 elements, it won't work ```java @CrossOrigin(value = ""${origin}"") ``` Or ```java @CrossOrigin(value = ""#{'${origin}'.split(',')}"") ```  Can provide any advice?","closed","status: superseded,","Ikki-Dai","2020-04-27T12:30:49Z","2022-02-08T13:12:26Z"
"","25168","differences in default JSON deserialziation configs between mvc and websocket","**Affects:** \5.2.2  ---   I am not sure if this is the correct repository (maybe Websocket?), but i found a different behavior in JSON deserialization in Websocket-Endpoints and Mvc-Endpoints.   While Mvc-Endpoints require setter to parse data correctly, this is not the case for Websocket-Endpoints.    of cause this is not a bug, but more an feature-request/improvement.  For me, i would prefer the Jackson-Config as used in Websocket (not to be forced to use setters), but at least, wouldnt it be better to use the same config for both (as long as one is not explicitly customized)?  Here is a small example:   ``` @Controller public class Test {      @PostMapping(""/api/data-test"")     public void getDataByPost(DataRequest request, HttpSession session) {         System.out.println(request.dataId); // Without setter the value is 0, with setter the correct value is available     }      @MessageMapping(""/api/data-test"")     public void getData(DataRequest request, SimpMessageHeaderAccessor headerAccessor) {         System.out.println(request.dataId); // correct value is available  (as long the attribute is public)     }      public static class DataRequest {         public int dataId;         // public int getDataId() { return dataId; }         // public void setDataId(int dataId) { this.dataId = dataId; }     } } ```","closed","","sunchezz89","2020-05-30T11:50:31Z","2020-06-16T13:22:29Z"
"","24904","Caching of autowire candidate metadata for lazy beans","**Affects:** \5.1.10.RELEASE  --- Ran into a performance regression when some of the beans in my application were lazified. Running this with Spring `5.1.10.RELEASE`.   The hotspot was identified to be the synchronized lock taken in `SimpleAliasRegistry::getAliases`. See stack trace      at org.springframework.core.SimpleAliasRegistry.getAliases(SimpleAliasRegistry.java:131)        at org.springframework.beans.factory.support.AbstractBeanFactory.getAliases(AbstractBeanFactory.java:670)        at org.springframework.beans.factory.support.DefaultListableBeanFactory.isAutowireCandidate(DefaultListableBeanFactory.java:763)        at org.springframework.beans.factory.support.DefaultListableBeanFactory.isAutowireCandidate(DefaultListableBeanFactory.java:725)        at org.springframework.beans.factory.support.DefaultListableBeanFactory.isAutowireCandidate(DefaultListableBeanFactory.java:709)        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1434)        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1218)        at org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver$1.getTarget(ContextAnnotationAutowireCandidateResolver.java:90)        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:192)  The issue appears to be coming from the synchronized block in the following code.      public String[] getAliases(String name) {       List result = new ArrayList();       synchronized (this.aliasMap) {  //","closed","type: enhancement,","rahulsh1","2020-04-14T03:11:07Z","2020-04-25T15:09:17Z"
"","25400","wrong exception message","**Affects:** \ springframework:5.1.7.RELEASE When i add @Transactional to a non-public method, then Spring show me a exception message as follow: ``` java.lang.IllegalStateException: Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.  at org.springframework.aop.framework.AopContext.currentProxy(AopContext.java:69) 	at cn.hydee.honey.demo.service.TransactionService.entry(TransactionService.java:32) 	at cn.hydee.honey.demo.service.TransactionServiceTest.testEntry(TransactionServiceTest.java:24) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) 	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) 	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) 	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) 	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) ```  My code: ``` public void entry() {         // 调用第三方接口.         System.out.println(""调用第三方接口。。。"");          // 修改内部数据.          // 方法一.         ((TransactionService) AopContext.currentProxy()).saveData();     }      @Transactional(rollbackFor = Exception.class)     void saveData() {         System.out.println(""写本地数据库-表1。。。"");         bizLogRepository.insert(BizLog.builder().type(""aaa"").level(1).content(""111"").build());          System.out.println(""写本地数据库-表2。。。"");         bizLogRepository.insert(BizLog.builder().type(""bbb"").level(1).build());     } ``` ---","open","in: core,","panyi5202","2020-07-17T08:08:39Z","2021-11-10T10:03:02Z"
"","25853","* 5a39f73 fix: encoding issues with non-ascii chars. * a60d77a new: pkg: added ``.travis.yml`` for automated tests.  * 57129ba new: much greater performance on big repository by issuing only one shell command for all the commits. (fixes #7) * 6b4b267 chg: dev: refactored out the formatting characters from GIT. * 197b069 new: dev: reverse ``natural`` order to get reverse chronological order by default. !refactor  * 6b891bc new: add utf-8 encoding declaration !minor","**Affects:** \ * 5a39f73 fix: encoding issues with non-ascii chars. * a60d77a new: pkg: added ``.travis.yml`` for automated tests.  * 57129ba new: much greater performance on big repository by issuing only one shell command for all the commits. (fixes #7) * 6b4b267 chg: dev: refactored out the formatting characters from GIT. * 197b069 new: dev: reverse ``natural`` order to get reverse chronological order by default. !refactor  * 6b891bc new: add utf-8 encoding declaration !minor  ---","closed","","NIKOLAY73731","2020-10-03T01:41:25Z","2020-10-03T01:41:47Z"
"","25851","A problem occurred evaluating project ':spring-beans'","**Affects:** \ > No such property: classesDirectory for class: org.gradle.api.internal.file.DefaultSourceDirectorySet --- No such property: classesDirectory for class: org.gradle.api.internal.file.DefaultSourceDirectorySet","closed","","NewDayxjc","2020-10-02T03:11:36Z","2020-10-16T07:10:43Z"
"","25389","builder.localeContextResolver is invoked twice in WebHttpHandlerBuilder.applicationContext","**Affects:** \ ![image](https://user-images.githubusercontent.com/38878763/87452259-972a8780-c633-11ea-93a3-3f304bcd4bfc.png)  ---","closed","type: task,","peacetrue","2020-07-14T16:40:40Z","2020-07-15T17:17:14Z"
"","25399","SimpleJdbcCall does not find stored function with PostgreSQL driver 42.2.11","**Affects:** \  We use Spring Boot 2.2.6.RELEASE, which includes jdbc driver PostgreSQL version 42.2.11.  We use `SimpleJdbcCall` for calling stored function in PostgreSQL database version 11.1.  But when we called stored function, we got `InvalidDataAccessApiUsageException` with message `Unable to determine the correct call signature - no procedure/function/signature for 'set_application_variables'`.  I looked under the hood and saw that at the stage compile stored function and gather meta information for it, we call `PgDatabaseMetaData.getProcedures(String catalog, String schemaPattern, String procedureNamePattern)`. In the version [42.2.11](https://jdbc.postgresql.org/documentation/changelog.html#version_42.2.11) PostgreSQL jdbc driver was added verification for returning only procedures. ```java public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern)       throws SQLException {     ...     if (connection.haveMinimumServerVersion(ServerVersion.v11)) {  //check version of database       sql += "" AND p.prokind='p'""; //check that it is stored procedure     }    ... ```  Class where we call stored function. ```java     @PostConstruct     private void init() {         this.jdbcCallStoredProcedure = new SimpleJdbcCall(dataSource)                 .withSchemaName(SCHEMA_NAME)                 .withFunctionName(STORED_FUNCTION_NAME)                 .declareParameters(                         new SqlParameter(APP_IGNORE_AUDIT, Types.BOOLEAN),                         new SqlParameter(APP_USERNAME, Types.VARCHAR),                         new SqlParameter(APP_TRACE_ID, Types.VARCHAR));     }      public void save(AuditInfo auditInfo) {         try {             SqlParameterSource procedureParameters = new MapSqlParameterSource()                     .addValue(APP_IGNORE_AUDIT, auditInfo.isIgnoreAudit())                     .addValue(APP_USERNAME, auditInfo.getUserName())                     .addValue(APP_TRACE_ID, auditInfo.getTraceId());             jdbcCallStoredProcedure.executeFunction(Void.class, procedureParameters);         } catch (RuntimeException e) {             log.error(""Cannot call stored procedure - set_application_variables which sets transaction variable"" +                     "" for passing application parameters to audit table in the database."", e);         }     } ``` Stored function. ```sql create or replace function vg_common_db_audit.set_application_variables(app_ignore_audit boolean, app_username text, app_trace_id text) returns void as $body$                 begin                     --some logic                 end; $body$ language plpgsql; ```   **Workaround**: as workaround we turned off verification meta data via JDBC with method `withoutProcedureColumnMetaDataAccess()` in `SimpleJdbcCall`.","closed","type: bug,","rmartseniuk","2020-07-16T15:38:05Z","2020-07-17T16:00:52Z"
"","25106","DefaultServerRequestBuilder does not respect attributes when building the ServerRequest","**Affects:** \  spring-webflux. The class **org.springframework.web.reactive.function.server.DefaultServerRequestBuilder** does not respect **attributes** when building the **org.springframework.web.reactive.function.server.ServerRequest**.  When you use ` ServerRequest.from(initialRequest)                 .attribute(""somename"", ""somevalue"")                 .build(); ` - the resulting ServerRequest does not have the attribute specified. Could be easily tracked by source code ---","closed","type: bug,","sergiisinelnychenko","2020-05-19T16:20:37Z","2020-05-21T08:44:28Z"
"","25675","Make ""org.springframework.util.unit.DataSize"" class Serializable","**Affects:** \  --- When using DataSize as a ConfigurationPorperties I'm not able to serialize the ConfigurationProperties.  I'm working on a project with Apache Ignite and it is trying to serialize the Configuration Properties classes. When using DataSize as properties it is getting the following exception:  java.io.NotSerializableException: org.springframework.util.unit.DataSize    ```java java.lang.IllegalStateException: Failed to load ApplicationContext 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) 	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:123) 	at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) 	at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) 	at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:98) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$5(ClassBasedTestDescriptor.java:341) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.executeAndMaskThrowable(ClassBasedTestDescriptor.java:346) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$6(ClassBasedTestDescriptor.java:341) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1624) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312) 	at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735) 	at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734) 	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestInstancePostProcessors(ClassBasedTestDescriptor.java:340) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:263) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$2(ClassBasedTestDescriptor.java:256) 	at java.base/java.util.Optional.orElseGet(Optional.java:362) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$3(ClassBasedTestDescriptor.java:255) 	at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:29) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:108) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:107) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:71) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:107) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:107) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:75) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1510) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1510) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:133) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 	at java.base/java.lang.Thread.run(Thread.java:832) Caused by: class org.apache.ignite.IgniteException: Failed to start IgniteSpringBean 	at org.apache.ignite.IgniteSpringBean.afterSingletonsInstantiated(IgniteSpringBean.java:175) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:910) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:879) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) 	at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:120) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) 	... 88 more Caused by: class org.apache.ignite.IgniteCheckedException: Failed to serialize object: DataStorageConfiguration [sysRegionInitSize=10485760, sysRegionMaxSize=41943040, pageSize=4096, concLvl=0, dfltDataRegConf=DataRegionConfiguration [name=default, maxSize=1073741824, initSize=104857600, swapPath=null, pageEvictionMode=DISABLED, evictionThreshold=0.9, emptyPagesPoolSize=100, metricsEnabled=true, metricsSubIntervalCount=5, metricsRateTimeInterval=60000, persistenceEnabled=false, checkpointPageBufSize=0, lazyMemoryAllocation=true], dataRegions=DataRegionConfiguration[] [DataRegionConfiguration [name=DATAREGION1, maxSize=1073741824, initSize=104857600, swapPath=null, pageEvictionMode=DISABLED, evictionThreshold=0.9, emptyPagesPoolSize=100, metricsEnabled=true, metricsSubIntervalCount=5, metricsRateTimeInterval=60000, persistenceEnabled=false, checkpointPageBufSize=0, lazyMemoryAllocation=true], DataRegionConfiguration [name=DATAREGION2, maxSize=1073741824, initSize=104857600, swapPath=null, pageEvictionMode=DISABLED, evictionThreshold=0.9, emptyPagesPoolSize=100, metricsEnabled=true, metricsSubIntervalCount=5, metricsRateTimeInterval=60000, persistenceEnabled=false, checkpointPageBufSize=0, lazyMemoryAllocation=true]], storagePath=null, checkpointFreq=180000, lockWaitTime=10000, checkpointThreads=4, checkpointWriteOrder=SEQUENTIAL, walHistSize=20, maxWalArchiveSize=1073741824, walSegments=10, walSegmentSize=67108864, walPath=db/wal, walArchivePath=db/wal/archive, metricsEnabled=false, walMode=LOG_ONLY, walTlbSize=131072, walBuffSize=0, walFlushFreq=2000, walFsyncDelay=1000, walRecordIterBuffSize=67108864, alwaysWriteFullPages=false, fileIOFactory=org.apache.ignite.internal.processors.cache.persistence.file.AsyncFileIOFactory@39c9655, metricsSubIntervalCnt=5, metricsRateTimeInterval=60000, walAutoArchiveAfterInactivity=-1, writeThrottlingEnabled=false, walCompactionEnabled=false, walCompactionLevel=1, checkpointReadLockTimeout=null, walPageCompression=DISABLED, walPageCompressionLevel=null] 	at org.apache.ignite.marshaller.jdk.JdkMarshaller.marshal0(JdkMarshaller.java:102) 	at org.apache.ignite.marshaller.jdk.JdkMarshaller.marshal0(JdkMarshaller.java:109) 	at org.apache.ignite.marshaller.AbstractNodeNameAwareMarshaller.marshal(AbstractNodeNameAwareMarshaller.java:57) 	at org.apache.ignite.internal.IgniteKernal.addDataStorageConfigurationAttributes(IgniteKernal.java:1932) 	at org.apache.ignite.internal.IgniteKernal.fillNodeAttributes(IgniteKernal.java:1883) 	at org.apache.ignite.internal.IgniteKernal.start(IgniteKernal.java:1246) 	at org.apache.ignite.internal.IgnitionEx$IgniteNamedInstance.start0(IgnitionEx.java:2045) 	at org.apache.ignite.internal.IgnitionEx$IgniteNamedInstance.start(IgnitionEx.java:1703) 	at org.apache.ignite.internal.IgnitionEx.start0(IgnitionEx.java:1117) 	at org.apache.ignite.internal.IgnitionEx.start(IgnitionEx.java:615) 	at org.apache.ignite.IgniteSpring.start(IgniteSpring.java:66) 	at org.apache.ignite.IgniteSpringBean.afterSingletonsInstantiated(IgniteSpringBean.java:172) 	... 98 more Caused by: java.io.NotSerializableException: org.springframework.util.unit.DataSize 	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1193) 	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1579) 	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1536) 	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1444) 	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1187) 	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1579) 	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1536) 	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1444) 	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1187) 	at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:353) 	at org.apache.ignite.marshaller.jdk.JdkMarshaller.marshal0(JdkMarshaller.java:97) 	... 109 more ```","closed","in: core,","hmmlopez","2020-09-02T09:22:08Z","2020-09-03T22:14:39Z"
"","25214","run demo turn an error","**Affects:** \  --- ``` Warning:Kotlin: Classpath entry points to a non-existent location: F:\IdeaWorkspace\spring-framework\spring-core\build\libs\spring-objenesis-repack-3.1.jar Information:Kotlin: starting the daemon as: E:\jdk-13.0.2 2\jdk-13.0.2\bin\java -cp E:\Program Files\JetBrains\IntelliJ IDEA 2019.1\plugins\Kotlin\kotlinc\lib\kotlin-compiler.jar -Djava.awt.headless=true -Djava.rmi.server.hostname=127.0.0.1 -Xmx700m -Dkotlin.incremental.compilation=true -Dkotlin.incremental.compilation.js=true org.jetbrains.kotlin.daemon.KotlinCompileDaemon --daemon-runFilesPath C:\Users\admin\AppData\Local\kotlin\daemon --daemon-autoshutdownIdleSeconds=7200 --daemon-compilerClasspath E:\Program Files\JetBrains\IntelliJ IDEA 2019.1\plugins\Kotlin\kotlinc\lib\kotlin-compiler.jar Information:Kotlin: Unable to get response from daemon in 10000 ms Information:Kotlin: ERROR: unable to retrieve daemon JVM options, assuming daemon is dead: Connection refused to host: 127.0.0.1; nested exception is:  	java.net.ConnectException: Connection refused: connect ``` --- ``` Information:Kotlin: found daemon on port 17212 (3613 ms old), trying to connect Information:Kotlin: kotlinc-jvm 1.3.21 (JRE 13.0.2+8) Information:2020/6/9 17:43 - Build completed with 1 error and 2 warnings in 2 m 7 s 540 ms Error:Kotlin: warnings found and -Werror specified Warning:Kotlin: Classpath entry points to a non-existent location: F:\IdeaWorkspace\spring-framework\spring-core\build\libs\spring-cglib-repack-3.3.0.jar ```  ---  how can I resolve this problem, thanks","closed","","wukong-yu","2020-06-09T09:48:49Z","2022-02-18T19:06:52Z"
"","25632","Possible fix - Quartz: Make MethodInvokingJobDetailFactoryBeans compatible with quartz JobStore.","**Affects:** \  ---  Hello, @jhoeller tagging you since you've contributed majorly to the quartz implementation I was able to figure out a method to make the MethodInvokingJobDetailFactoryBean compatible with the persistent store.  Note that CronUtil is a utility class that I've made, and assume the invoked methods/constants are able to do the job.  The gist is to simply replace the jobDataMap ""methodInvoker"" with primitives, and use those strings to create instances in the create instance method. The example doesn't take into consideration arguments(feature can at least enable methods that don't require arguments), but just provides a possible way of achieving this. Would love to contribute as a generic implementation with a PR. Here's how: ```java	                  // Build JobDetail instance. 		JobDetailImpl jdi = new JobDetailImpl(); 		jdi.setName(name); 		jdi.setGroup(this.group); 		jdi.setJobClass((Class) jobClass); 		jdi.setDurability(true);                  // remove this line 		// jdi.getJobDataMap().put(""methodInvoker"", this);                  // add method/class qualifying primitives to the jobDataMap 	        jobDetail.getJobDataMap().put(CronUtil.METHOD_INVOKING_JOB_TARGET_METHOD, ""targetMethodAsString"");                 jobDetail.getJobDataMap().put(CronUtil.METHOD_INVOKING_JOB_TARGET_CLASS, ""targetClassAsString"");                 // and some others in order to support static methods, Maybe a serializable POJO. ```  And I overrode the createInstance method, ```java /**  * Class that overrides the createJobInstance method so as to  * delegate job instance creation to the beanFactory,  * rather than have quartz do it by calling {@code clazz.getInstance()}.  * This allows for spring-based autowiring and classes with  * members in their constructors  */ public final class AutowiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {      private AutowireCapableBeanFactory beanFactory;      @Override     public void setApplicationContext(final ApplicationContext context) {         beanFactory = context.getAutowireCapableBeanFactory();     }       @Override     protected Object createJobInstance(final TriggerFiredBundle bundle) {         JobDetail jobDetail = bundle.getJobDetail();         JobDataMap jobDataMap = jobDetail.getJobDataMap();         if (jobDataMap.getBoolean(CronUtil.IS_METHOD_INVOKING_JOB)) {             return getMethodInvokingJob(jobDetail, jobDataMap);         }         return getNormalJob(jobDetail);     }      private Object getNormalJob(JobDetail jobDetail) {         Class","closed","","Presto412","2020-08-23T07:39:14Z","2022-02-18T19:06:24Z"
"","25156","WebSocketConnectionManager does not try to reconnect","**Affects:** \  ---   When websocket connection is broken due to network issues, WebSocketConnectionManager does not try to reconnect. I could not could any existing solution to that, not requiring any coding.  To my understanding: it keeps the status ""isRunning()==true"" and does not bother to look at used WebSocketSession if it still declares ""isOpen()==true"". It requires either manually do ""stop()"" and ""start()"" on WebSocketConnectionManager or refreshing the spring context (if in spring and ""autoStartup=true"").  In my project I have fixed it by introducing 2 new classes (a new ReconnectingWebSocketConnectionManager with a new decorating ReconnectingWebSocketHandler - see (EDIT: simplified) snippets below).  I was wondering if there is any easier solution?  ``` public class ReconnectingWebSocketConnectionManager extends WebSocketConnectionManager {      public ReconnectingWebSocketConnectionManager(WebSocketClient client, WebSocketHandler webSocketHandler,             String uriTemplate, Object... uriVariables) {         super(client, webSocketHandler, uriTemplate, uriVariables);     }      @Override     protected WebSocketHandler decorateWebSocketHandler(WebSocketHandler handler) {         return new ReconnectingWebSocketHandler(super.decorateWebSocketHandler(handler), this);     } }  public class ReconnectingWebSocketHandler extends WebSocketHandlerDecorator {      private static final Log logger = LogFactory.getLog(ReconnectingWebSocketHandler.class);      private ConnectionManagerSupport connectionManager;      public ReconnectingWebSocketHandler(WebSocketHandler delegate, ConnectionManagerSupport connectionManager) {         super(delegate);         this.connectionManager = connectionManager;     }      @Override     public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {         super.afterConnectionClosed(session, status);         if (session != null && !session.isOpen()) {             logger.debug(""Reconnecting..."");             this.connectionManager.stop();             this.connectionManager.start();             logger.debug(""Reconnected..."");         }     }  } ```","open","in: web,","artmiar","2020-05-28T15:08:39Z","2022-07-11T11:58:30Z"
"","25576","eiifcckjeldbglguifglnhrudckdgrdjcntljkdiihur","**Affects:** \  ---","closed","","morekaly","2020-08-10T21:28:01Z","2020-08-10T21:29:07Z"
"","25575","eiifcckjeldbuertiljrdfjleiervvdvhdukvtjclkju","**Affects:** \  ---","closed","","morekaly","2020-08-10T21:27:37Z","2020-08-10T21:28:56Z"
"","25440","How to easily read the source code","**Affects:** \  ---","closed","for: stackoverflow,","labichaoren","2020-07-21T06:44:58Z","2020-07-22T08:45:31Z"
"","25306","Is it possible for connecting Kafka event register only after transaction commit happens - Async Distributed systems","**Affects:** \  ---","closed","for: stackoverflow,","surapuramakhil","2020-06-23T18:07:30Z","2021-11-10T12:13:10Z"
"","25164","cvc-complex-type.2.4.c: The matching wildcard is strict, but no declaration can be found for element 'context:componant-scan'.","**Affects:** \  ---","closed","for: stackoverflow,","Pramod1897","2020-05-29T17:08:58Z","2020-05-29T17:34:48Z"
"","25281","Support multiple Content-Language header values in MockHttpServletResponse","**Affects:** 5.x+  --- The current code in https://github.com/spring-projects/spring-framework/blob/3aa2605fdaa56d5c007f476f3f9bd1c550ec368c/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletResponse.java#L641-L644  prevent to set multiple languages in the response Content-Language header. A value of ""en, it"" is translated to the ""en"" Locale and the subsequent call to setLocale   https://github.com/spring-projects/spring-framework/blob/3aa2605fdaa56d5c007f476f3f9bd1c550ec368c/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletResponse.java#L344-L346  force the Content-Language to be only ""en"".  The use of comma separated values for languages is perfectly fine according to the specification, see second example here https://www.w3.org/International/questions/qa-http-and-lang#http_summary","closed","type: enhancement,","abollini","2020-06-18T21:35:59Z","2020-07-27T15:55:50Z"
"","25783","Published reference documentation contains unnecessary folders and files","**Affects:** 5.x  The directory for the PDF documentation contains HTML files and  JS and CSS directories that, AFAIK, don't need to be there and can be a bit confusing.  For example, if you're not familiar with Asciidoctor you may open `docinfo.html` expecting some information about the PDF documentation. You get a blank page instead.","closed","type: documentation,","wilkinsona","2020-09-18T08:28:29Z","2020-09-24T16:16:54Z"
"","25854","WebTestClient no longer captures the URI template","**Affects:** 5.3.0-SNAPSHOT  This is a regression introduced by https://github.com/spring-projects/spring-framework/commit/bedf2de6141ad2e667ca4f8805f495330d5ff9a6. All of the `uri` methods delegating to `uri(URI)` means that the URI template is captured and then immediately nulled out again. This breaks Spring REST Docs' ability to document a request's path parameters.  See https://stackoverflow.com/questions/64174707/spring-rest-docs-failing-to-document-pathparameters-using-webtestclient for background.","closed","type: regression,","wilkinsona","2020-10-03T11:11:13Z","2020-10-06T17:39:24Z"
"","25353","Creating ServerRequest from MockHttpServletRequest changed behaviour 5.3.0-M1","**Affects:** 5.3.0-M1  --- In 5.2.7 we could call ServerRequest.create(MockHttpServletRequest()) in our tests. With 5.3.0-M1 this causes an assert error in ServerRequestPathUtils since it expects a request attribute containing the RequestPath (ServerRequestPathUtils:70).","closed","type: regression,","jwalter","2020-07-01T10:39:31Z","2020-07-13T14:00:24Z"
"","25291","AllEncompassingFormHttpMessageConverter now uses both JAXB and Jackson by default","**Affects:** 5.3 snapshots  When both JAX-B and Jackson are on the classpath, `AllEncompassingFormHttpMessageConverter` will now configure both `Jaxb2RootElementHttpMessageConverter` and `MappingJackson2XmlHttpMessageConverter`. Previously, the latter was preferred. This change in behaviour was introduced in https://github.com/spring-projects/spring-framework/commit/1e501f2583efd7521fe457453e5f866bcb8c509a as the `jackson2XmlPresent` flag is no longer being checked when deciding if `Jaxb2RootElementHttpMessageConverter` should be configured.","closed","type: regression,","wilkinsona","2020-06-19T20:59:43Z","2020-06-20T15:20:29Z"
"","25290","Spring MVC's locale resolver can no longer be customized in parent context","**Affects:** 5.3 snapshots  The fix for #25209 appears to have removed or at least limited the ability to customize the locale resolver that is used by the `DispatcherServlet`.  The introduction of a default `LocaleResolver` bean means that Spring Boot's auto-configuration of a `LocaleResolver` backs off as it is presumed that the bean that's now present is one provided by the user. This means that the `spring.mvc.locale` and `spring.mvc.locale-resolver` properties are no longer honoured.  This change will also break any Spring Boot user who has defined their own `localeResolver` bean as it would attempt to override the bean defined by `WebMvcConfigurationSupport`. This will fail as bean definition overriding is disabled by default in Boot.","closed","status: feedback-provided,","wilkinsona","2020-06-19T20:46:56Z","2022-04-04T10:02:19Z"
"","25831","Race condition in DataBufferUtils.readAsynchronousFileChannel resulting in FD leak (Channel remains open)","**Affects:** 5.2.x (but probably others too)   --- DataBufferUtils.readAsynchronousFileChannel is prone to file descriptor leak with certain race condition.  Channel is created using method Flux.using and provided channel supplier.  ```java Flux flux = Flux.using(channelSupplier, 				channel -> Flux.create(sink -> { 					ReadCompletionHandler handler = 							new ReadCompletionHandler(channel, sink, position, bufferFactory, bufferSize); 					sink.onCancel(handler::cancel); 					sink.onRequest(handler::request); 				}), 				channel -> { 					// Do not close channel from here, rather wait for the current read callback 					// and then complete after releasing the DataBuffer. 				}); ``` However, the builtin Flux cleanup method isn't used here and instead it relies on sink and channel callbacks. This is probably the core of this issue, although it seems reasonable why it was done like this (to prevent DataBuffer leaks as each DataBuffer needs to be released).   Let's presume the Flux is subscribed and something like this happens:  ``` onSubscribe([Fuseable] FluxOnAssembly.OnAssemblyConditionalSubscriber) request(128) onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 4100, cap: 8192)) cancel() ``` This can result in following chain of events in ReadCompletionHandler: * completed() method is called (but not finished) with disposed=false, passing the initial condition ```isNotDisposed``` and second condition ```read != -1``` * cancel() method is called while having disposed = false and reading = true, which results in:    * Channel is not closed (because of condition ```if (!reading.get()) {closeChannel(channel)```}    * disposed is set to true * read() method is called from completed handler while disposed=true, which result in NOOP (because of condition ```java sink.requestedFromDownstream() > 0 && isNotDisposed && reading.compareAndSet(false, true)``` * completed() method finishes  The outcome of this chain of events is that the Channel is left open and nobody ever closes it as no further callbacks are delivered (the sink is cancelled and cancel event was delivered, the channel finished last reading operation and no further operations were performed).   The race condition is inevitable because while AtomicBooleans are used to synchronize the callbacks between NIO2 and Reactor. The outcomes are driven by 2 AtomicBooleans which in this case results in non atomic synchronization of operations if certain order of operations happen across different threads.   I would be willing to help with PR, but I don't believe there is simple fix as this looks as more fundamental design flaw in this code. While it would be easy to check if disposed==true in read() method and if yes and no reading is going to happen, then close the channel, I don't believe this will cover all possible scenarios how the methods can be executed in parallel and the resulting order of operations serialized. In my opinion the Flux cleanup handler should be used to atomically set disposed to true, also checking if reading is in progress and if not, close the channel or single atomic state needs to be used instead of 2 independent booleans.   Also it's pretty fundamental part of framework as this method (readAsynchronousFileChannel) is used by the framework itself to for example serve resources, so it may be worth having bit of discussion how this should be fixed for all possible cases.","closed","in: core,","gitdude1458","2020-09-29T02:29:15Z","2020-10-15T16:29:13Z"
"","25171","@ComponentScan not finding @Repositories in external modules","**Affects:** 5.2.x  I'm trying to create @Repository definitions in a common library / module, and then use them in a  separate module with an application defined. I've declared a @ComponentScanner and provided class path entries to the bases for searching.  I've also declared @EnableMongoRepositories, with an additional classpath entry to point to the very package that the repositories are in.  The repositories are not being found.  I've traced this to what I believe to be a bug in ClassPathScanningCandidateComponentProvider.isCandidateComponent.  The logic is as follows:  ``` 	protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { 		AnnotationMetadata metadata = beanDefinition.getMetadata(); 		return (metadata.isIndependent() && (metadata.isConcrete() || 				(metadata.isAbstract() &&                                    metadata.hasAnnotatedMethods(Lookup.class.getName())))); 	}  ``` Repository definitions are only interfaces (metadata.isAbstract() == true), but their methods are only rarely annotated.  In fact, there are enough default methods injected that there will often be no methods explicitly declared.  So, metadata.hasAnnotatedMethods will fail.   This is preventing the bean from being loaded and processed, and from being autowired, etc.","closed","","jklappenbach","2020-05-31T20:19:28Z","2020-06-17T05:42:24Z"
"","25716","Easing the application of CORS default settings through the WebMvcConfigurer#corsConfigurer method","**Affects:** 5.2.x  --- Hello, the intent of this issue is to explore ways to ease the configuration of CORS through `WebMvcConfigurer#corsConfigurer` and a `CorsConfiguration` instance that might have been obtained e.g. via a Spring Boot `ConfigurationProperties` on a `CorsConfiguration` bean.  Currently, if one wants to leverage Spring Boot properties to override CorsConfiguration default values, one needs to do something like this, which is really verbose, duplicates existing code, and prone to error (NullPointerException protection, etc.):  ```java     @Bean     @ConfigurationProperties(""cors"")     public CorsConfiguration corsConfiguration() {         final CorsConfiguration corsConfiguration = new CorsConfiguration();         corsConfiguration.applyPermitDefaultValues();         return corsConfiguration;     }      @Bean     public WebMvcConfigurer corsConfigurer(CorsConfiguration globalCorsConfiguration) {         return new WebMvcConfigurer() {              @Override             public void addCorsMappings(CorsRegistry registry) {                 final CorsRegistration registration = registry.addMapping(""/**"");                 combine(registration, globalCorsConfiguration);             }         };     }      /**      * Combines the registration's {@link CorsConfiguration} with {@code corsConfiguration},      * as if {@link CorsConfiguration#combine(CorsConfiguration)} had been called on the registration's      * {@link CorsConfiguration}.      *       * This method is required since {@link CorsRegistration#getCorsConfiguration()} is not public,      * it cannot be called and thus {@link CorsConfiguration#combine(CorsConfiguration)} cannot be called.      */     void combine(CorsRegistration registration, CorsConfiguration corsConfiguration) {         if (corsConfiguration.getAllowCredentials() != null) {             registration.allowCredentials(corsConfiguration.getAllowCredentials());         }         if (corsConfiguration.getAllowedHeaders() != null) {             registration                     .allowedHeaders(corsConfiguration.getAllowedHeaders().toArray(new String[corsConfiguration.getAllowedHeaders().size()]));         }         if (corsConfiguration.getAllowedMethods() != null) {             registration                     .allowedMethods(corsConfiguration.getAllowedMethods().toArray(new String[corsConfiguration.getAllowedHeaders().size()]));         }         if (corsConfiguration.getAllowedOrigins() != null) {             registration                     .allowedOrigins(corsConfiguration.getAllowedOrigins().toArray(new String[corsConfiguration.getAllowedHeaders().size()]));         }         if (corsConfiguration.getExposedHeaders() != null) {             registration                     .exposedHeaders(corsConfiguration.getExposedHeaders().toArray(new String[corsConfiguration.getAllowedHeaders().size()]));         }         if (corsConfiguration.getMaxAge() != null) {             registration.maxAge(corsConfiguration.getMaxAge());         }     } ```  I see at least two ways in which it could be simplified in the calling code:  ```java     @Bean     @ConfigurationProperties(""cors"")     public CorsConfiguration corsConfiguration() {         final CorsConfiguration corsConfiguration = new CorsConfiguration();         corsConfiguration.applyPermitDefaultValues();         return corsConfiguration;     }      @Bean     public WebMvcConfigurer corsConfigurer(CorsConfiguration globalCorsConfiguration) {         return new WebMvcConfigurer() {              @Override             public void addCorsMappings(CorsRegistry registry) {                 // Design 1: with CorsRegistration#getCorsConfiguration() made public instead of protected                 final CorsRegistration registration = registry.addMapping(""/**"");                 registration.getCorsConfiguration().combine(globalCorsConfiguration);                  // Design 2: with an additional CorsRegistration#combineConfiguration() method                 registry.addMapping(""/**"").combineWithConfiguration(globalCorsConfiguration);             }         };     } ```  The first solution would be to change the visibility of the `CorsRegistration#getCorsConfiguration()` method and set it `public`.  The second solution would be to add a new `CorsRegistration#combineWithConfiguration()` method that would delegate to the `CorsConfiguration#combine()` method of the internal `configuration` field, and return `this` (the `CorsRegistration` configuration) to not break the fluent API style of `CorsRegistration`.  What do you think?  Not sure it's a good practice, but let me cc @sdeleuze which was involved in a Spring Boot issue around the same topic, earlier: https://github.com/spring-projects/spring-boot/issues/3052","closed","type: enhancement,","lpetit-yseop","2020-09-07T06:37:41Z","2020-09-25T20:57:24Z"
"","25805","Document that TransactionalEventListener only works with non-reactive transactions","**Affects:** 5.2.9  ---  The problem described here can be reproduced using the following sample project: https://github.com/codependent/transactional-event-sample  In a Spring Boot Webflux application with Reactive Mongodb as repository, I would like to take advantage of Spring's event publishing in a transactional way, thus I tried using `TransactionalEventListener`. The problem is even though the `ReactiveTransactionManager` has started an actual transaction, when dealing with the event, `ApplicationListenerMethodTransactionalAdapter.onApplicationEvent()` considers both `TransactionSynchronizationManager.isSynchronizationActive()` and `TransactionSynchronizationManager.isActualTransactionActive()` as false.  Below you can see the logs of this process:  ``` 2020-09-23 09:46:14.206 TRACE 32760 --- [ctor-http-nio-2] t.a.AnnotationTransactionAttributeSource : Adding transactional method 'com.codependent.sample.service.UserServiceImpl.create' with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2020-09-23 09:46:14.286 TRACE 32760 --- [ctor-http-nio-2] .s.t.r.TransactionSynchronizationManager : Bound value [org.springframework.data.mongodb.ReactiveMongoResourceHolder@d351c8c7] for key [org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory@209f1e30] to context [2b9f14a3-bcbf-4b45-9c9b-3f9dc689d1af] 2020-09-23 09:46:14.286 TRACE 32760 --- [ctor-http-nio-2] .s.t.r.TransactionSynchronizationManager : Initializing transaction synchronization 2020-09-23 09:46:14.286 TRACE 32760 --- [ctor-http-nio-2] o.s.t.i.TransactionInterceptor           : Getting transaction for [com.codependent.sample.service.UserServiceImpl.create] 2020-09-23 09:46:14.288  INFO 32760 --- [ctor-http-nio-2] c.c.sample.service.UserServiceImpl       : create() isSyncActive false - isTxActive false 2020-09-23 09:46:14.311 DEBUG 32760 --- [ctor-http-nio-2] cationListenerMethodTransactionalAdapter : No transaction is active - skipping org.springframework.context.PayloadApplicationEvent[source=org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@f0ba5602, started on Wed Sep 23 09:37:21 CEST 2020] 2020-09-23 09:46:14.313 DEBUG 32760 --- [ctor-http-nio-2] cationListenerMethodTransactionalAdapter : No transaction is active - skipping org.springframework.data.mongodb.core.mapping.event.BeforeConvertEvent[source=User(id=null, name=John Doe)] 2020-09-23 09:46:14.323 DEBUG 32760 --- [ctor-http-nio-2] cationListenerMethodTransactionalAdapter : No transaction is active - skipping org.springframework.data.mongodb.core.mapping.event.BeforeSaveEvent[source=User(id=null, name=John Doe)] 2020-09-23 09:46:14.328 TRACE 32760 --- [ctor-http-nio-2] .s.t.r.TransactionSynchronizationManager : Retrieved value [org.springframework.data.mongodb.ReactiveMongoResourceHolder@d351c8c7] for key [org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory@209f1e30] bound to context [2b9f14a3-bcbf-4b45-9c9b-3f9dc689d1af: com.codependent.sample.service.UserServiceImpl.create] 2020-09-23 09:46:14.917  INFO 32760 --- [ntLoopGroup-3-4] org.mongodb.driver.connection            : Opened connection [connectionId{localValue:4, serverValue:198137}] to insight-dev-shard-00-00-otcb8.gcp.mongodb.net:27017 2020-09-23 09:46:14.979 DEBUG 32760 --- [ntLoopGroup-3-4] cationListenerMethodTransactionalAdapter : No transaction is active - skipping org.springframework.data.mongodb.core.mapping.event.AfterSaveEvent[source=User(id=5f6afd4626e83e41147e429a, name=John Doe)] 2020-09-23 09:46:14.979 TRACE 32760 --- [ntLoopGroup-3-4] o.s.t.i.TransactionInterceptor           : Completing transaction for [com.codependent.sample.service.UserServiceImpl.create] 2020-09-23 09:46:15.041 TRACE 32760 --- [ntLoopGroup-3-4] .s.t.r.TransactionSynchronizationManager : Clearing transaction synchronization 2020-09-23 09:46:15.043 TRACE 32760 --- [ntLoopGroup-3-4] .s.t.r.TransactionSynchronizationManager : Removed value [org.springframework.data.mongodb.ReactiveMongoResourceHolder@d351c8c7] for key [org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory@209f1e30] from context [2b9f14a3-bcbf-4b45-9c9b-3f9dc689d1af] ```  The first four lines show that there is an actual transaction, however, inside my transactional method I print the following (5th log line): ```         logger.info(""create() isSyncActive {} - isTxActive {}"",                 TransactionSynchronizationManager.isSynchronizationActive(),                 TransactionSynchronizationManager.isActualTransactionActive()) ``` which shows `create() isSyncActive false - isTxActive false`. I seems that `TransactionSynchronizationManager` isn't considering the ongoing Reactive Mongo transaction and in the 6th log line, when `ApplicationListenerMethodTransactionalAdapter.onApplicationEvent()` kicks in, it doesn't synchronize the transaction, and just skips it.  MongoDb Transaction config:  ``` @EnableTransactionManagement @Configuration class MongoDbConfiguration {      @Bean     fun mongoTransactionManager(dbFactory: ReactiveMongoDatabaseFactory) =             ReactiveMongoTransactionManager(dbFactory)  } ```  Service and event listener:  ``` @Service @Transactional class UserServiceImpl(private val userRepository: UserRepository) : UserService {      private val logger = LoggerFactory.getLogger(javaClass)      override fun create(user: User): Mono {         logger.info(""create() isSyncActive {} - isTxActive {}"",                 TransactionSynchronizationManager.isSynchronizationActive(),                 TransactionSynchronizationManager.isActualTransactionActive())          return userRepository.save(user.complete())     } ```  ``` @Service class UserEventListener {      private val logger = LoggerFactory.getLogger(javaClass)      @TransactionalEventListener     @Transactional     fun userCreated(event: UserCreatedEvent){         logger.info(""userCreated({})"", event)     } ```  ``` @Document(collection = ""sample-user"") data class User (var id: String?, var name: String) : AbstractAggregateRoot(){      fun complete(): User {         registerEvent(UserCreatedEvent(name))         return this     }  } ```  In order to use the sample you need a Mongodb 4.x instance with replication enabled (to support transactions), e.g. Mongo Atlas, configuring the appropriate value in application.yml:  ``` spring:   data:     mongodb:       uri: xxx ```  After starting the application just call: `curl -X POST localhost:8080/users -d '{""name"": ""John Doe""}' -H ""content-type: application/json""`","closed","type: documentation,","codependent","2020-09-23T08:18:22Z","2022-06-26T15:45:07Z"
"","25801","Thread-scoped bean creation freezes if dependent bean is retrieved before dependency bean","**Affects:** 5.2.9  ---  It seems that if a dependent thread-scoped bean is retrieved from the `ApplicationContext` before the thread-scoped dependency, then bean creation could lock up in an infinite loop, never to return again.  Regression bug. Works fine with spring-framework 5.2.7, fails with spring-framework 5.2.9. May be a bug in spring-test rather than spring-context. May be hard to reproduce, hoping that this limited information is sufficient to lead to a fix.  `SimpleThreadScope` likely relevant since `SimpleThreadScope` has an infinite loop - the bean creation freezes in:  ```java // org.springframework.context.support.SimpleThreadScope.class, the scope map is empty public Object get(String name, ObjectFactory objectFactory) {        Map scope = (Map)this.threadScope.get();          return scope.computeIfAbsent(name, (k) -> {            return objectFactory.getObject();      });  ```  Standalone test case:  ```java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.config.Scope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.support.GenericApplicationContext; import org.springframework.context.support.SimpleThreadScope; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestContext; import org.springframework.test.context.TestExecutionListeners; import org.springframework.test.context.junit.jupiter.SpringExtension; import org.springframework.test.context.support.AbstractTestExecutionListener; import org.springframework.test.context.support.AnnotationConfigContextLoader; import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;  @ExtendWith(SpringExtension.class) @ContextConfiguration(classes={MyTest.MyTestConfig.class},         loader= AnnotationConfigContextLoader.class) @TestExecutionListeners({MyTest.MyTestExecutionListener.class,         DependencyInjectionTestExecutionListener.class}) public class MyTest {     @Autowired     private MyView removeNodeStatusScreen;      @Test     void justRun() {         System.out.println(""This test should run"");     }      @Configuration     static class MyTestConfig {         @Bean         @org.springframework.context.annotation.Scope(""thread"")         // The bean name seems to matter, if I change the name the test passes         public MyView removeNodeStatusScreen(                 MyPresenter myPresenter) {             return new MyView(myPresenter);         }          @Bean         @org.springframework.context.annotation.Scope(""thread"")         // The bean name seems to matter, if I change the name the test passes         public MyPresenter removeNodeStatusPresenter() {             return new MyPresenter();         }     }      static class MyTestExecutionListener             extends AbstractTestExecutionListener {          @Override         public void prepareTestInstance(TestContext testContext) throws Exception {             if (testContext.getApplicationContext() instanceof GenericApplicationContext) {                 GenericApplicationContext context =                         (GenericApplicationContext) testContext.getApplicationContext();                 ConfigurableListableBeanFactory beanFactory = context                         .getBeanFactory();                 Scope viewScope = new SimpleThreadScope();                 beanFactory.registerScope(""thread"", viewScope);             }         }     }      public static class MyPresenter {         public MyPresenter() {         }     }      public static class MyView {         public MyView(MyPresenter myPresenter) {         }     } }  ```  2 possible workarounds found:  Workaround 1: Add `@DependsOn` annotation to configuration class. However, `@DependsOn` would not be necessary if there were no bug:  ```java @Configuration public class MyConfig {   @ViewScope   @Bean    @DependsOn(""myPresenter"")   public MyView myView(MyPresenter myPresenter) {     return new MyView(myPresenter);   }    @Bean   @ViewScope   public MyPresenter myPresenter() {      return new myPresenter();   } }  ```  Workaround 2: swap order of beans in test. The order of the beans would not matter if there were no bug.  ```java class MyConfigTest {   // myView depends on myPresenter, so make sure the myPresenter is declared first   // Otherwise test freezes on bean creation   @Autowired   MyPresenter myPresenter;    @Autowired   MyView myView; ... ```","closed","in: core,","nguyenquoc","2020-09-23T00:28:35Z","2020-09-25T09:27:36Z"
"","25588","spring-jdbc don't set out parameter name from metadata for Postgresql function after issue#25399","**Affects:** 5.2.8.RELEASE  When using PostgreSQL driver 42.2.11 and higher and spring-jdbc version 5.2.8.RELEASE and calling Postgresql function then `CallMetaDataContext.actualFunctionReturnName` from function metadata is not set. Related to issue # 25399 there was a split in GenericCallMetaDataProvider: ```java function? databaseMetaData.getFunctionColumns (metaDataCatalogName, metaDataSchemaName, metaDataProcedureName, null): databaseMetaData.getProcedureColumns (metaDataCatalogName, metaDataSchemaName, metaDataProcedureName, null) ``` And for functions it returns columnType = 4, previously it returned columnType = 5.  Because of this, the condition is not met in `CallMetaDataContext.reconcileParameters`: ```java if (meta.isReturnParameter()) {         // DatabaseMetaData.procedureColumnReturn or possibly procedureColumnResult         if (!isFunction() && !isReturnValueRequired() && paramName != null &&                 provider.byPassReturnParameter(paramName)) {             if (logger.isDebugEnabled()) {                 logger.debug(""Bypassing meta-data return parameter for '"" + paramName + ""'"");             }         }         else {             String returnNameToUse =                     (StringUtils.hasLength(paramNameToUse) ? paramNameToUse : getFunctionReturnName());             workParams.add(provider.createDefaultOutParameter(returnNameToUse, meta));             if (isFunction()) {                 setFunctionReturnName(returnNameToUse);                 outParamNames.add(returnNameToUse);             }             if (logger.isDebugEnabled()) {                 logger.debug(""Added meta-data return parameter for '"" + returnNameToUse + ""'"");             }         }     } ```  and `setFunctionReturnName` is not called. It is not executed because `isReturnParameter` looks like: ```java public boolean isReturnParameter() { 		return (this.parameterType == DatabaseMetaData.procedureColumnReturn || 				this.parameterType == DatabaseMetaData.procedureColumnResult); 	} ```  Only the type of parameters for the procedure are checked.  Because of this, the output parameter for the function is passed in the metadata as `returnValue`, `setFunctionReturnName` is not called, and spring uses the default name `return`, and does not find such a parameter in the results.","closed","type: bug,","ddrko22","2020-08-14T08:31:34Z","2020-09-07T16:11:23Z"
"","25634","AnnotatedElementUtils.getMergedAnnotationAttributes() does not work as expected for 'value' annotation attribute","**Affects:** 5.2.8.RELEASE  Hello, I have a problem with correctly resolving annotations data when the default `value` field is involved. I've created a shortcut annotation:    @PutJsonMapping  ```java import org.springframework.core.annotation.AliasFor; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod;  import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented @RequestMapping(method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE) public @interface PutJsonMapping {      @AliasFor(annotation = RequestMapping.class)     String name() default """";      @AliasFor(annotation = RequestMapping.class, attribute = ""path"")     String[] value() default {};      @AliasFor(annotation = RequestMapping.class)     String[] path() default {};      @AliasFor(annotation = RequestMapping.class)     String[] params() default {};      @AliasFor(annotation = RequestMapping.class)     String[] headers() default {};      @AliasFor(annotation = RequestMapping.class)     String[] produces() default MediaType.APPLICATION_JSON_VALUE;  } ```    I use it on a method and then I try to inspect the annotation values like this  ```java var requestMapping = AnnotatedElementUtils.getMergedAnnotationAttributes(method, RequestMapping.class); ```  When I use it like this  ```java @PutJsonMapping(""/{token}"") public ResponseEntity confirm() ```  The requestMapping has empty path and value fields  ![image](https://user-images.githubusercontent.com/158625/90981571-162fab80-e562-11ea-96b1-aba4054574cf.png)  If I inspect the method reflection, I see that the value is present  ![annotations](https://user-images.githubusercontent.com/158625/90981654-a4a42d00-e562-11ea-8467-fc09b8287463.png)  But if I change the usage to   ```java @PutJsonMapping(path = ""/{token}"") public ResponseEntity confirm() ```  now the aliasing starts working as expected  ![image](https://user-images.githubusercontent.com/158625/90981725-fe0c5c00-e562-11ea-99f7-3d518f57b44f.png)  IMHO the `@AliasFor` should work the way I tried to use it.  ----  The framework as a whole behaves correctly, so it has to be resolving the path somehow, it's just that when I try to inspect the method annotations using `AnnotatedElementUtils`, then it behaves unexpectedly.  ----  Also, since the `RequestMapping` has aliased `value`  ```java public @interface RequestMapping {  	String name() default """";  	@AliasFor(""path"") 	String[] value() default {}; ```  I would expect this to work even just like this (without explicitly writing the `attribute = ""path""`)  ```java public @interface PutJsonMapping {      @AliasFor(annotation = RequestMapping.class)     String name() default """";      @AliasFor(annotation = RequestMapping.class)     String[] value() default {};  ```","closed","in: core,","fprochazka","2020-08-23T15:09:21Z","2021-02-24T14:27:21Z"
"","25505","1st instance of AOP proxy leaks its advice","**Affects:** 5.2.8.RELEASE  A programmer supplies an implementation of `org.aopalliance.aop.Advice` to `ProxyFactory.addAdvice()`. A custom advice may occupy a lot of memory, nobody forbids that. Then `ProxyFactory.getProxy()` will generate a class for the current factory config and put it in a cache:  ``` 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:28) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:57) 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205) 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:155) 	at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:97) ```  Both key and value weakly refer to the custom Advice, however, **there's a strong reference to the `ProxyCallbackFilter` from the generated class** (I couldn't determine the exact field in the generated class, but Eclipse shows there's a reference)    And this class is loaded in the application classloader and will not be collected. I think this is why the initial Advice instances are not collected.  There's no reason for the generated class to refer the original advices because when a new proxy is created, new advice instances are used even if their classes are the same. Also, I think maybe we shouldn't store the custom advices as part of the key. `ProxyCallbackFilter` only compares the advice classes and the advisor pointcuts in its `equals()` method.  Here's the test program:  ```java     package org.foo.testproxy;          import java.lang.ref.WeakReference;     import java.util.ArrayList;     import java.util.List;     import java.util.Objects;          import org.aopalliance.intercept.MethodInterceptor;     import org.aopalliance.intercept.MethodInvocation;     import org.springframework.aop.Advisor;     import org.springframework.aop.framework.ProxyFactory;          public class TestGC {              public static void main(String[] args) throws Exception {             doStuff();             doStuff();             gc();             if (proxyRef.get() != null) throw new Exception(""unexpected"");             if (factoryRef.get() != null) throw new Exception(""unexpected"");             Advisor advisor = Objects.requireNonNull(advisorRefs.get(0).get());             System.out.println(""advisor leaked"");             advisor.getClass(); // breakpoint here         }              static List advisorRefs = new ArrayList();         static WeakReference advisorsRef;         static WeakReference factoryRef;         static WeakReference proxyRef;              static void doStuff() {             A obj = new A();             ProxyFactory factory = new ProxyFactory(obj) {                 {                     advisorsRef = new WeakReference( getAdvisorsInternal() );                 }             };             factory.addAdvice(new TestInterceptor());             advisorRefs.add( new WeakReference( factory.getAdvisors()[0]) );             factoryRef = new WeakReference( factory );             proxyRef =  new WeakReference( factory.getProxy() );         }                  static class A {         }                  static class TestInterceptor implements MethodInterceptor {             public Object invoke(MethodInvocation invocation) throws Throwable {                 return invocation.proceed();             }         }                  private static void gc() {             for (int i = 0; i < 100; i++) {                 (new byte[1000000]).getClass();                 System.gc();             }         }     } ```","open","in: core,","basi01","2020-08-01T12:50:46Z","2020-08-10T12:25:18Z"
"","25581","WebSocket configuration doesn't work properly with the buffer size limitation","**Affects:** 5.2.8.RELEASE  --- ```java @Configuration @EnableWebSocketMessageBroker public class MyConfig implements WebSocketMessageBrokerConfigurer {  	@Override 	public void configureMessageBroker(MessageBrokerRegistry registry) { 		// ... 		registry.setPreservePublishOrder(true); 	}  	@Override 	public void configureWebSocketTransport(WebSocketTransportRegistration registry) { 		registry.setSendBufferSizeLimit(512 * 1024); 	} } ```  The setSendBufferSizeLimit method has no more effect after setPreservePublishOrder(true).  The reason is that the instance of OrderedMessageSender keeps all messages and sends only one message at a time to the buffer.  Thus, the application can slow down significantly or even crash with OutOfMemory Error instead of just closing the WebSocket connection when the messages queue overflow.  Memory Analyzer shows how OrderedMessageSender can occupy the whole heap: ![Heap](https://user-images.githubusercontent.com/15262557/89906785-7c2c4280-dbf4-11ea-933d-13a0a4aede6e.png)","closed","type: enhancement,","OleksiiKlochko","2020-08-11T15:02:48Z","2020-09-11T18:16:55Z"
"","25784","UriComponentsBuilder should not treat a dot followed by a number as illegal","**Affects:** 5.2.8.RELEASE  ---  There is an issue when using UriComponentsBuilder to build a URI for an address that contains a . followed by a number. The address is valid as an internal Kubernetes cluster address but fails the UriComponentsBuilder validation for the ""illegal character"" of ""."" This issue can be overcome by wrapping the String output in a URL object and then calling the .toUri method on the result, where no error is thrown.  See following code for example:  ```java     @Test     public void test() throws URISyntaxException, MalformedURLException {                  UriComponentsBuilder uriComponentsBuilder = getUriBuilder();         String query = String.format(""(eq,attribute,%s)"", ""23426342786242"");          //Without .toUri and Cast to URL does not throw error results in:         // http://deployment-name.20-14/api/path/to/resource?filter=(eq,attribute,23426342786242)         String noToUri = uriComponentsBuilder                 .queryParam(""filter"", query).build().toString();         URI uri2 = new URL(noToUri).toURI();          //With .toUri straight from build results in :         // java.lang.IllegalStateException: Could not create URI object: Illegal character in hostname at index 23:          // http://deployment-name.20-14/api/path/to/resource?filter=(eq,attribute,23426342786242)         URI test =getUriBuilder()                 .queryParam(""filter"", query).build().toUri();      }      private UriComponentsBuilder getUriBuilder(String... pathSegments) {         return UriComponentsBuilder.fromHttpUrl(""http://deployment-name.20-14"")                 .path(""/api/path/to/resource"")                 .pathSegment(pathSegments);     } ```","closed","status: declined,","jenniferbain","2020-09-18T10:21:10Z","2020-09-22T16:31:03Z"
"","25543","IntegerToEnumConverterFactory is not applied to web request parameters","**Affects:** 5.2.8.RELEASE  ---  I have a controller like this  ```java @RestController @RequestMapping(""/dict"") public class EnumTestController {      @GetMapping(""/convert"")     public EnabledEnum convert(@RequestParam EnabledEnum enabledEnum) {         return enabledEnum;     }  } ```  and `EnabledEnum` is  ```java public enum EnabledEnum {     DISABLE, ENABLE; } ```  I use http://localhost:8080/dict/convert?enabledEnum=0 to request, but it throws exception with the stack trace:  ``` Caused by: org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [@org.springframework.web.bind.annotation.RequestParam org.gywebframework.web.sample.constant.EnabledEnum] for value '0'; nested exception is java.lang.IllegalArgumentException: No enum constant org.gywebframework.web.sample.constant.EnabledEnum.0 	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:47) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:191) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:129) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:693) ~[spring-context-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:125) ~[spring-web-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	... 92 common frames omitted Caused by: java.lang.IllegalArgumentException: No enum constant org.gywebframework.web.sample.constant.EnabledEnum.0 	at java.base/java.lang.Enum.valueOf(Enum.java:240) ~[na:na] 	at org.springframework.core.convert.support.StringToEnumConverterFactory$StringToEnum.convert(StringToEnumConverterFactory.java:52) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.core.convert.support.StringToEnumConverterFactory$StringToEnum.convert(StringToEnumConverterFactory.java:38) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.core.convert.support.GenericConversionService$ConverterFactoryAdapter.convert(GenericConversionService.java:436) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] 	... 98 common frames omitted ```  `org.springframework.core.convert.support.GenericConversionService#convert(Object, TypeDescriptor, TypeDescriptor)` is using `org.springframework.core.convert.support.StringToEnumConverterFactory`, not `org.springframework.core.convert.support.IntegerToEnumConverterFactory`.","open","in: core,","gcdd1993","2020-08-06T08:03:09Z","2020-08-13T13:44:18Z"
"","25534","RestTemplate cannot use streaming and interceptors","**Affects:** 5.2.8.RELEASE  ---  Hello,  I have an application that can send very large files over HTTPS with RestTemplate but I cannot buffer the whole file in RAM (not enough memory available). That is why I want to use the streaming capabilities of RestTemplate.  To send large files with `RestTemplate` we can use the streaming by setting `bufferRequestBody` to false in a `HttpComponentsClientHttpRequestFactory`, and create the `RestTemplate` with this factory  If we do not use interceptors during the request, everything is fine and we can send large files. But if we use interceptors during the request, the streaming part is not called and this can lead to an OutOfMemory error. (I cannot increase the RAM)  This is due to the factory `InterceptingClientHttpRequestFactory` that is used by RestTemplate as a wrapper when interceptors are present and which does not support streaming.  Is there any chance that this will be fixed in a future version and that we can use streaming with interceptors?","closed","status: declined,","dylan-roger","2020-08-05T15:19:48Z","2020-08-12T10:47:56Z"
"","25744","Cancellation behaviour when input client requests are terminated prematurely","**Affects:** 5.2.8.RELEASE  ---  ### Spring setup  Consider the following WebFlux handler function: ``` import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.io.buffer.DataBuffer; import org.springframework.stereotype.Component; import org.springframework.web.reactive.function.BodyExtractors; import org.springframework.web.reactive.function.server.ServerRequest; import org.springframework.web.reactive.function.server.ServerResponse;  import reactor.core.publisher.Flux; import reactor.core.publisher.Mono;  @Component public class Handler {     private static final Logger LOGGER = LoggerFactory.getLogger(Handler.class);      public Mono handle(ServerRequest serverRequest) {         Flux inputBuffers = serverRequest.body(BodyExtractors.toDataBuffers())                 .cache()                 .map(d -> d.slice(0, d.readableByteCount()));          // Fork off processing using inputBuffers.         inputBuffers. ...          return inputBuffers                 .doOnNext(dataBuffer -> LOGGER.info(""Received input data buffer: {}"", dataBuffer))                 .doOnCancel(() -> LOGGER.info(""Pipeline cancelled""))                 .then(ServerResponse.accepted().build());     } } ```  The idea is that a 202 Accepted response is returned as soon as the input body is fully received, but subsequent processing is forked off in parallel reactive pipelines. The `cache` and `slice` calls are simply there to allow reuse of the input buffers.  ### Observations  I'm investigating behaviour when the input client requests are malformed or incomplete, for example: * the connection is terminated prematurely, with a number of received bytes smaller than the `Content-Length` header value. * the connection is terminated prematurely, with no final 0 sent when performing a `Transfer-Encoding: chunked` request.  When one of the above happens, a number of data buffers are received, but the main reactive pipeline in the `handle` method is then cancelled, without any error.  From what I can tell, this behaviour has several downsides: * this is quite unintuitive: if something is wrong, errors are generally raised rather than processing being silently stopped. It took me quite a bit of time to realise that a cancellation event was being issued. * there is no indication as to why the cancellation occurred, as `doOnCancel` is a simple runnable without any exception or other object provided. I'm guessing cancellation could occur for a number of reasons, not necessarily truncated client requests as described above. This makes it challenging to build any custom logging or error handling in an application. * unless I'm missing something, no metrics seem to be reported, in particular through Micrometer's built in `http_server_requests` meter. Defining custom metrics on the reactive pipelines within the `handle` method wouldn't work either, as I believe Micrometer only reports on successful completion or on error, not on cancellation. This lack of reporting means that a rogue client could be hammering an application without any visibility from the external world, which is not great in terms of security. * application code will likely be more complex. In the use case presented above where `inputBuffers` are processed asynchronously, the application needs to keep track of all created subscriptions and cancel them in a `doOnCancel` call in the main `handle` pipeline. Any other pipeline based off `inputBuffers` will otherwise receive a successful `onComplete` event, without realising that the input is actually incomplete.  I'm not sure what it would involve and whether it's even possible, but it seems like issuing an error in the pipeline rather than cancelling it would solve much of the above.  What are people's thoughts? Is there anything I've misunderstood with the current behaviour?  Thanks for reading!","closed","for: external-project,","PyvesB","2020-09-09T09:11:36Z","2021-02-17T10:18:52Z"
"","25615","Webclient Docker OffHeap Memory Leak","**Affects:** 5.2.8  We're trying to use reactive in our microservice, but we're seeing the docker memory go up until the instance is killed. We were able to identify webclient as the culprit. To be more precise, the JVM memory is normal, but when API calls are made the docker memory is not released and the instance is eventually killed without any outOfHeap errors.  I was able to reproduce the issue using a simple project.  ``` @Component public class Controller {    //This is an endpoint to another simple api   //Naturally, I use my local IP instead of localhost in the container   private static final String ENDPOINT = ""http://localhost:9090/"";    private WebClient client;      public Controller(WebClient.Builder client) {     super();     this.client = client.build();   }    @Bean   public RouterFunction router() {      return RouterFunctions.route(GET(""helloworld""), this::handle);   }    Mono handle(ServerRequest request) {      Mono helloMono =         client.get().uri(ENDPOINT + ""/hello"").retrieve().bodyToMono(String.class);      Mono worldMono =         client.get().uri(ENDPOINT + ""/world"").retrieve().bodyToMono(String.class);      return Mono.zip(helloMono, worldMono, (h, w) -> h + w)         .flatMap(s -> ServerResponse.ok().bodyValue(s));   } } ``` Here's the dockerFile. ``` FROM openjdk:8  ENV SERVICE_NAME reactive-hello-world  ADD target/reactive-hello-world-*.jar $APP_HOME/reactive-hello-world.jar  RUN mkdir /opt/reactor-netty/   EXPOSE 9010  CMD java \ 	-Dcom.sun.management.jmxremote=true \ 	-Dcom.sun.management.jmxremote.local.only=false \ 	-Dcom.sun.management.jmxremote.authenticate=false \ 	-Dcom.sun.management.jmxremote.ssl=false \ 	-Djava.rmi.server.hostname=localhost \ 	-Dcom.sun.management.jmxremote.port=9010 \ 	-Dcom.sun.management.jmxremote.rmi.port=9010 \           -Xmx190M \ 	-jar reactive-hello-world.jar  EXPOSE 8080 ``` Here's some images  Before Load Test: [![Before load test][1]][1]  After Load Test [![enter image description here][2]][2]     [1]: https://i.stack.imgur.com/KX98k.jpg   [2]: https://i.stack.imgur.com/0FRZZ.jpg  As you can see, the heap is fine but the memory hasn't decreased, I've tried a similar code using ``RestTemplate`` without issue. Edit: I've also tried the deprecated ``AsyncRestTemplate`` and I not seeing a problem with that either.  Edit: I have created the repos for this example. Please check if you can reproduce the issue.   [The Hello World Backend](https://github.com/SentryMan/api-hello-world-backend) [The Webclient Hello World](https://github.com/SentryMan/reactive-hello-world)(JMX is inside this repo) [The RestTemplate Hello World](https://github.com/SentryMan/reactive-hello-world/tree/restTemplate) [The AsyncRestTemplate Hello World](https://github.com/SentryMan/reactive-hello-world/tree/AsyncRestTemplate) [The Exchange Strategy Hello World](https://github.com/SentryMan/reactive-hello-world/tree/ExchangeStrategy)","closed","for: external-project,","SentryMan","2020-08-19T15:56:13Z","2020-09-16T13:26:38Z"
"","25689","BeanFactoryUtils.beanNamesForTypeIncludingAncestors doesn't find name for existing bean if proxied","**Affects:** 5.2.8  Using Spring Framework with Jersey 2.31, I've enabled the Spring Security global method security interceptors, initially with `proxyTargetClass = true`, which works fine.  At some point, I noticed that the JAX-RS endpoints that I want intercepted actually have interfaces, so I've set `proxyTargetClass = true`, which made Jersey want to instantiate the endpoint itself, since its `SpringComponentProvider` could no longer [find](https://github.com/eclipse-ee4j/jersey/blob/3dca77c2e0920aa9df9f76e7fc7ae6f01afb9b5f/ext/spring5/src/main/java/org/glassfish/jersey/server/spring/SpringComponentProvider.java#L108) it because `BeanFactoryUtils.beanNamesForTypeIncludingAncestors` doesn't [match](https://github.com/spring-projects/spring-framework/blob/v5.2.8.RELEASE/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java#L535) the existing instance with the class, because `ResolvableType` ends up [comparing](https://github.com/spring-projects/spring-framework/blob/v5.2.8.RELEASE/spring-core/src/main/java/org/springframework/core/ResolvableType.java#L252) the requested type with something like `com.sun.proxy.$Proxy150`  As far as I see, this is triggered by the fact that Jersey requests a bean using the implementation and not the interface (well, that's because this is how I registered the component, because it causes other complications with Bean Validation), so I'm not sure if Spring can do anything about it, but it was strange/interesting to discover different behaviors 🙂","open","in: core,","andrei-ivanov","2020-09-03T18:44:17Z","2021-11-12T12:08:07Z"
"","25776","Use the function endpoint, filter the handler function, and find that remoteAddress is null, params is empty","**Affects:** 5.2.8  ---  Use the function endpoint, filter the handler function, and find that remoteAddress is null, params is empty,can not extract values ```java RouterFunction route = route()     .path(""/person"", b1 -> b1         .nest(accept(APPLICATION_JSON), b2 -> b2             .GET(""/{id}"", handler::getPerson)             .GET("""", handler::listPeople)             .before(request -> ServerRequest.from(request)   // Because the from method does not pass in parameters                 .header(""X-RequestHeader"", ""Value"")                 .build()))         .POST(""/person"", handler::createPerson))     .after((request, response) -> logResponse(response))      .build(); ``` ```java org.springframework.web.servlet.function.DefaultServerRequestBuilder.BuiltServerRequest  @Override public Optional remoteAddress() {     return Optional.empty(); } @Override public MultiValueMap params() {     return new LinkedMultiValueMap(); } ```","closed","type: enhancement,","cashZhang27","2020-09-15T14:35:23Z","2020-10-07T08:37:50Z"
"","25423","UriComponentsBuilder.cloneBuilder() cause sharing query parameters between builders","**Affects:** 5.2.7.RELEASE ```java public static void main(String[] args) {     UriComponentsBuilder b1 = UriComponentsBuilder.fromUriString(""example.com"");     b1.queryParam(""param"", ""x"");     UriComponentsBuilder b2 = b1.cloneBuilder();      System.out.println(""b1: "" + b1.build().toUriString());     System.out.println(""b2: "" + b2.build().toUriString());     b1.queryParam(""param"", ""y"");     System.out.println(""b1: "" + b1.build().toUriString());     System.out.println(""b2: "" + b2.build().toUriString()); } ``` actual output: ``` b1: example.com?param=x b2: example.com?param=x b1: example.com?param=x¶m=y b2: example.com?param=x¶m=y ``` expected output: ``` b1: example.com?param=x b2: example.com?param=x b1: example.com?param=x¶m=y b2: example.com?param=x ``` ![queryparams_bug](https://user-images.githubusercontent.com/20819487/87886904-d5072180-ca20-11ea-8f1d-13f0457aae4e.png) ---","closed","type: bug,","Potat0x","2020-07-19T22:47:54Z","2020-07-20T05:27:25Z"
"","25501","MockHttpServletResponse reset() does not reset charset field","**Affects:** 5.2.7.RELEASE  When calling the `reset()` method of `MockHttpServletResponse`, the boolean `charset` is not reset to false.  If the response object had the charset set before being reset, `charset=null` is appended to the mime type. This can lead to an `InvalidMediaTypeException`:  ``` org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.springframework.http.InvalidMediaTypeException: Invalid mime type ""application/octet-stream;charset=null"":  unsupported charset 'null' ```","closed","type: bug,","Nkyn","2020-07-31T13:09:38Z","2020-08-03T14:27:24Z"
"","25216","WebClient: NPE and leak in case connection is reset by server.","**Affects:** 5.2.7.RELEASE  I’m having a memory leak in a real application, which I tried to reproduce with the sample: https://github.com/EtienneMiret/reactor-netty-oom.  In this sample, having a flux of integers, I call the below method on each of them and then aggregate the results:  ```java public Mono get (int i) {   return webClient.get ()       .uri (""/{index}"", i)       .exchange ()       .delayElement (Duration.ofMillis (200))       .flatMap (response -> response.bodyToMono (ByteArrayResource.class))       .map (ByteArrayResource::contentLength); } ```  When the server is behaving properly, all is fine, but in case it aborts the TCP connection, this code starts leaking memory. My bet is that the network error triggers an exception which cancels the Flux, thus preventing the `response -> response.bodyToMono (ByteArrayResource.class)` lambda from being called. The `.delayElement ()` operator is an attempt at making it more likely that the ClientResponse is built and not consumed.  If I understand properly ClientResponse’s Javadoc and #21801, my code is correctly consuming the response, and error cases (such as IO error or pipeline cancellation) should be handled by Spring. Is this indeed the case?  After the first connection reset from the server, I have the below stack: ``` reactor.core.publisher.Operators Operator called default onErrorDropped java.lang.NullPointerException: null 	at reactor.core.publisher.MonoCollect$CollectSubscriber.onNext(MonoCollect.java:124) ~[reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Body from GET http://localhost:7890/52 [DefaultClientResponse] Stack trace: 		at reactor.core.publisher.MonoCollect$CollectSubscriber.onNext(MonoCollect.java:124) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE] 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE] 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) [reactor-core-3.3.6.RELEASE.jar:3.3.6.RELEASE] 		at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:330) [reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE] 		at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:353) [reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE] 		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:605) [reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE] 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:96) [reactor-netty-0.9.8.RELEASE.jar:0.9.8.RELEASE] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:286) [netty-handler-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) [netty-codec-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) [netty-codec-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [netty-transport-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [netty-common-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.50.Final.jar:4.1.50.Final] 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.50.Final.jar:4.1.50.Final] 		at java.lang.Thread.run(Thread.java:830) [?:?] ```  And later (when the GC runs I guess), I have a number of:      io.netty.util.ResourceLeakDetector LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.  See full [error.log](https://github.com/spring-projects/spring-framework/files/4754463/error.log).  I’m still not sure where the issue is (my code? Spring? Reactor-netty?). Sorry if this turns out not to be a Spring bug.","closed","type: bug,","EtienneMiret","2020-06-09T20:00:49Z","2020-06-22T06:11:12Z"
"","25278","ServerHttpRequest.getSslInfo() always returns null for reactor-netty HTTP/2 requests","**Affects:** 5.2.7.RELEASE  --- ReactorServerHttpRequest.initSslInfo() works only for HTTP1.1 requests because the code looks for SslHandler in the channel().pipeline().  For HTTP/2 request SslHandler is locate in the channel().parent().pipeline() Example how to access: Http2StreamBridgeHandler.channelRead() (reactor-netty)  Or, maybe, you have some other elegant solution?","closed","type: bug,","dvoloshyn","2020-06-18T14:53:18Z","2020-06-19T14:45:55Z"
"","25345","MediaType.APPLICATION_JSON_UTF8_VALUE is deprecated, but encoding is incorrect without it","**Affects:** 5.2.7.RELEASE  ---  We just updated from Spring Boot `2.1.3.RELEASE` (which used Spring Framework `5.1.7.RELEASE`) to `2.3.1.RELEASE` (which uses Spring Framework `5.2.7.RELEASE`).   After finishing up and running system tests, we noticed that there are some encoding issues with non-ASCII characters. For example, with the following endpoint (details omitted):      @RequestMapping(""/v1"")     public interface Api {          @GetMapping(""/inquiry"")         @ApiOperation(value = ""..."", httpMethod = ""GET"",                 notes = ""."", response = InquiryData.class, tags = {""Inquiry""})         @ApiResponses(value = {@ApiResponse(code = 200, message = ""Data"", response = InquiryData.class),                 @ApiResponse(code = 401, message = ""Unauthorized"", response = Errors.class),                 @ApiResponse(code = 500, message = ""Internal Server Error"", response = Errors.class)})         InquiryData getInquiryData();      }  Which ordinarily would return something like the following:      {""name"":""..."",""street"":""..."",""zipCode"":""..."",""city"":""Münster"",""country"":""DE""}                                                           ^ non-ASCII  After updating to `5.2.7.RELEASE`, the following response is attained:      {""name"":""..."",""street"":""..."",""zipCode"":""..."",""city"":""MÃ¼nster"",""country"":""DE""}  We do not have any other specific `spring-web` settings for encoding and/or decoding. We do have a custom `ObjectMapper` `PostProcessor` which configures some de-/serialization properties, but nothing that should impact encoding.   The issue only seems to occur when encoding a response. Decoding a request body seems to work fine even without `consumes = MediaType.APPLICATION_JSON_UTF8_VALUE`.  Putting `@RequestMapping(value = ""/v1"", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)` also does seem to fix the issue, but `MediaType.APPLICATION_JSON_UTF8_VALUE` has been deprecated since `5.2`. IMO, this means that the default should support `UTF-8` out-of-the-box in that case.   I haven't been able to debug the issue yet, but I'll try to do so and add some more technical details to try and narrow the issue down.","closed","status: invalid,","filpano","2020-06-30T16:05:38Z","2020-07-07T09:45:40Z"
"","25645","StringHttpMessageConverter may trigger humongous allocations (G1GC)","**Affects:** 5.2.7.RELEASE  ---   I come from spring-projects/spring-boot#21308, where I noticed that Spring related code is triggering humongous allocations (g1GC). Part of these are related to Spring Boot actuators. But others are triggered by WebMVC code. This is causing regular unresponsiveness in the application(s) (pauses up-to ~100ms).  ![image](https://user-images.githubusercontent.com/803621/91182981-3343b600-e6eb-11ea-9be2-fd47bf731cc2.png)     I can share the flamegraph privately as there are other _private flames_ triggering humongous allocations.","closed","status: invalid,","bric3","2020-08-25T14:02:52Z","2021-02-03T15:24:06Z"
"","25247","AbstractJackson2HttpMessageConverter - Check for encoding breaks JSON to POJO de-serialization experience","**Affects:** 5.2.7 (Spring Boot 2.3.1) --- Due to a fix in [Issue #25076](https://github.com/spring-projects/spring-framework/issues/25076) the AbstractJackson2HttpMessageConverter also blocks the out-of-the-box JSON to POJO de-serialization for responses with an encoding/character set not being unicode.  In our case a GET request to `https://appleid.apple.com/auth/keys` responses with a  `Content-Type: application/json;charset=ISO-8859-1`, which results now in `org.springframework.web.client.UnknownContentTypeException: Could not extract response: no suitable HttpMessageConverter found for response type [class x.y.z.AppleKeyRequest] and content type [application/json;charset=ISO-8859-1]`.  It would be nice to have an option to include non compliant JSON encodings for the given default converters or to have the encoding check as opt-in to be on par with previous default behavior.","closed","type: regression,","kruegsch","2020-06-12T12:50:54Z","2020-06-17T07:47:32Z"
"","25407","Jackson2ObjectMapperBuilder rejects JaxRSFeature","**Affects:** 5.2.7 Trying to disable [JaxRSFeature.ALLOW_EMPTY_INPUT](https://github.com/FasterXML/jackson-jaxrs-providers/blob/master/base/src/main/java/com/fasterxml/jackson/jaxrs/cfg/JaxRSFeature.java#L28) I discovered that `Jackson2ObjectMapperBuilder` will throw an exception. ```java public Jackson2ObjectMapperBuilderCustomizer basicObjectMapperBuilderCustomizer() {         return builder -> {             builder.serializationInclusion(JsonInclude.Include.NON_NULL);             builder.featuresToDisable(JaxRSFeature.ALLOW_EMPTY_INPUT);         };     } ```  ```` org.springframework.beans.FatalBeanException: Unknown feature class: com.fasterxml.jackson.jaxrs.cfg.JaxRSFeature         at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.configureFeature(Jackson2ObjectMapperBuilder.java:786) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE]         at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.lambda$configure$2(Jackson2ObjectMapperBuilder.java:725) ~[spring-web-5.2.7.RELEASE.jar:5.2.7.RELEASE] ````  Please suport `JaxRSFeature` too.","closed","","andrei-ivanov","2020-07-17T12:01:22Z","2022-02-18T19:06:56Z"
"","25293","Use @SafeVarargs in Jackson2ObjectMapperBuilder#modulesToInstall","**Affects:** 5.2.7  ---  When using `Jackson2ObjectMapperBuilder#modulesToInstall(Class","closed","status: superseded,","marschall","2020-06-20T14:17:04Z","2020-06-24T13:13:14Z"
"","25084","Multicontext JCache cache is closed","**Affects:** 5.2.6.RELEASE --- Original Spring boot issue: https://github.com/spring-projects/spring-boot/issues/21458  Using a configuration similar to: https://springframework.guru/using-ehcache-3-in-spring-boot/  When two contexts are created that use the same cache manager and one of them is closed, it causes the cache manager to close and be invalid for further operations. Continuing tests in the unclosed context that uses the same cache manager results in `cache is closed` errors.  Sample repository: https://github.com/cdalexndr/spring-boot-issue-21458 Just run `gradlew test`, output: ``` Cache[testcache] is closed java.lang.IllegalStateException: Cache[testcache] is closed 	at org.ehcache.jsr107.Eh107Cache.checkClosed(Eh107Cache.java:543) 	at org.ehcache.jsr107.Eh107Cache.get(Eh107Cache.java:88) 	at org.springframework.cache.jcache.JCacheCache.lookup(JCacheCache.java:78) 	.... ```","closed","status: invalid,","cdalexndr","2020-05-15T11:25:19Z","2020-05-15T14:52:00Z"
"","25074","Deadlock in @PostConstruct block","**Affects:** 5.2.6.RELEASE ---  The following scenario triggers deadlock:  - Run non-main threads that invoke a method of `@Repository` bean in `@PostConstruct` block. - The method throws an exception. - Wait the non-main threads to be completed in `@PostConstruct` block.  This is a sample project to demonstrate it: https://github.com/izeye/spring-boot-throwaway-branches/tree/post-construct-deadlock  Just running it will trigger deadlock.  I'm not sure if this is unsupported usage or bug.","open","in: core,","izeye","2020-05-14T06:35:10Z","2021-11-12T12:08:06Z"
"","25069","DefaultClientResponseBuilder empty logPrefix when creating a DefaultClientResponse based on another","**Affects:** 5.2.6.RELEASE  The current implementation of `DefaultClientResponseBuilder` doesn't allow a logPrefix to be specified for the `DefaultClientResponse` that is being builded, neither transfer the logPrefix when an instance is builded from another `DefaultClientResponse`.  This is a problem for spring-cloud-sleuth, that wraps and mutates `DefaultClientResponses`, and doing so, the logPrefix is replaced by an empty string on the new instance.  I also opened an issue on the spring-cloud-sleuth project, that explains the use case and contains a project that simulates the problem: https://github.com/spring-cloud/spring-cloud-sleuth/issues/1591","closed","type: bug,","fabiojb","2020-05-13T18:28:35Z","2020-05-24T20:26:58Z"
"","25095","@Nullable prevents code from being compiled with -Werror","**Affects:** 5.2.6.RELEASE  Code that uses `@Nullable` cannot be compiled with `-Werror` due to the use of `When.MAYBE` on its `@Nonnull` meta-annotation. Attempting to compile code that depends on `spring-core` and that uses `@Nullable` results in a compilation failure:  ``` warning: unknown enum constant When.MAYBE   reason: class file for javax.annotation.meta.When not found error: warnings found and -Werror specified 1 error 1 warning ```  Unfortunately, there's no way to suppress such warnings so I either have to abandon trying to compile with `-Werror` or I have to add a dependency on `com.google.code.findbugs:jsr305:3.0.2`.","closed","","wilkinsona","2020-05-18T16:40:33Z","2022-02-18T19:06:50Z"
"","25059","Possible null @Autowired field depending on fields' order in @Configuration classes","**Affects:** 5.2.6.RELEASE  --- ## Issue description I ran into an issue with a rather large project today which I think raised a bug or a non handled corner case in the `@Autowired` injection process. I'll try to detail it as best as I can but please bear since it's hard to explain and english isn't my first language. A sample project is also provided.  In this large project, a number of beans are defined in a big `@Configuration` class and some others are defined as `@Component` and instantiated using component scanning in Spring Boot (component scanning does not seem to be part of the problem). Some beans defined in the `@Configuration` class depend on beans defined as `@Component` so we autowire them in the `@Configuration` class.   The issue we ran into was that a bean instantiated in the configuration class got a `null` for an autowired instance of a dependency. There are no circular dependencies and the `@Autowired` annotation is not `required=false`.  After long hours of debugging of the dependency injection path to get to that point, I realize that the order of the `@Autowired` fields had an influence, moving the problematic field up in the class definition solved the `null` instance problem. Analyzing the situation some more, I was able to craft a sample to reproduce the issue.  I understand that this is a circular dependency on some level (not in the dependencies itself but in the related classes and fields necessary to instantiate them) so I would totally understand if we don't want to support this. However, I think an exception should be thrown instead of going ahead with the `null` instance. I also agree with saying that this ""hybrid DI"" with configuration classes and components is not ideal and is easily fixable in the sample project I provided but might be harder or hidden between multiple configuration classes for a real world large project like the project we had the issue with.  ## Sample project [You can find the project here.](https://github.com/jebeaudet/spring-null-autowired) ### Class descriptions In the `beans` package, you'll find `BeanA`, `BeanB`, `BeanC`, `BeanD`, `BeanE`. Those are dummy beans to reproduce the issue with the only particularity that each bean as a non null check for each member in the constructor or in a `@PostConstruct` for autowired beans.   In the `configurations` package, you'll find 2 subpackages with the configuration classes I use for the example. The only difference is the order of the `@Autowired` fields in ` NotWorkingConfigClass` and `WorkingConfigClass`.  To run the example, simply run the main class in `NullAutowiredApplication`. Use the proper `@Import` to reproduce a working scenario and a non working scenario.  To make the application ""fail"" silently with a `null` instance, just remove the `Assert.noNullElements(beanA);` line in `BeanB`, the application will boot without any error but there will be a `null` instance of `BeanA` in the `BeanB` instance. I print the `BeanA` instance in the console too.  ### Dependency injection path The DI path is the following for the non working scenario :  1. `BeanE` is instantiated 2. Autowiring is being done on `BeanE`, it requires a `BeanD` instance 3. It finds the `BeanD` constructor `NotWorkingConfigClass`, it instantiates the configuration class 4. It starts autowiring the `@Autowired` fields in the order they appear 5. It starts with `BeanC`, instantiate the class and starts autowiring fields 6. `BeanA` is instantiated and injected in `BeanC` 7. `BeanB` constructor is found in `NotWorkingConfigClass` 8. It uses that constructor to get the instance of `BeanB` however `BeanA` is not yet autowired in this class, even though it has been instantiated earlier and has no dependencies! ** success!  Sorry for the long post and hopefully I made it clear enough for you, let me know if I can be of any help.   Thanks!","open","in: core,","jebeaudet","2020-05-13T01:27:59Z","2021-11-10T11:58:07Z"
"","25146","ExchangeStrategies custom codec's reader and writer are not registered","**Affects:** 5.2.6.RELEASE  ---  I added my custom encoder and decoder like following.  ```java ExchangeStrategies     .empty()     .codecs(configurer -> {         configurer.defaultCodecs().maxInMemorySize(properties.getMaxInMemorySize());         configurer.customCodecs().registerWithDefaultConfig(encoder);         configurer.customCodecs().registerWithDefaultConfig(decoder);     })     .build(); ```  But there is no `messageWriters` when writing body with `BodyInserts.fromValue()`.  It seems that encoder and decoder that I added above are not registered at `ExchangeStrategies`.  I think following code block has bug. Why put all readers and writers from `this` to `other`? It seems that `this` and `other` are swapped.  https://github.com/spring-projects/spring-framework/blob/90ccabd60bfe24249b3c4cbe43a25ffd0efa6eba/spring-web/src/main/java/org/springframework/http/codec/support/BaseCodecConfigurer.java#L144-L149  If it is a bug, I would like to create a PR. :)","closed","type: bug,","dlsrb6342","2020-05-28T02:12:37Z","2020-05-28T10:31:46Z"
"","25091","Document how reactive transactions work for cancellation in 5.2 and how it will work in 5.3","**Affects:** 5.2.6, current master ---  Briefly: according to my observations, Spring commits a transaction when a 'transactional reactive pipeline' gets cancelled. To the moment of such a cancellation, it could happen that only part of the work inside the transaction has been done, so a commit at that point produces partially-committed results violating the 'atomicity' transactional property.  I've created a project demonstrating the problem: https://github.com/rpuch/spring-commit-on-cancel-problems  ```java     @Test     void cancelShouldNotLeadToPartialCommit() throws InterruptedException {         // latch is used to make sure that we cancel the subscription only after the first insert has been done         CountDownLatch latch = new CountDownLatch(1);          Disposable disposable = bootService.savePair(collection, latch).subscribe();          // wait for the first insert to be executed         latch.await();          // now cancel the reactive pipeline         disposable.dispose();          // Now see what we have in the DB. Atomicity requires that we either see 0 or 2 documents.         List boots = mongoOperations.findAll(Boot.class, collection).collectList().block();          assertEquals(0, boots.size());     } ```  The main (and only) test, `PartialCommitsOnCancelTest#cancelShouldNotLeadToPartialCommit()`, does the following: it initiates a reactive pipeline having 2 inserts. Both inserts are wrapped in a (declarative) transaction. The code is crafted to make a cancellation exactly between the inserts possible:  ```java     @Transactional     public Mono savePair(String collection, CountDownLatch latch) {         return Mono.defer(() -> {             Boot left = new Boot();             left.setKind(""left"");             Boot right = new Boot();             right.setKind(""right"");              return mongoOperations.insert(left, collection)                     // signaling to the test that the first insert has been done and the subscription can be cancelled                     .then(Mono.fromRunnable(latch::countDown))                     // do not proceed to the second insert ever                     .then(Mono.fromRunnable(this::blockForever))                     .then(mongoOperations.insert(right, collection))                     .then();         });     } ```  The pipeline is initiated, and after the first insert is done (but before the second one is initiated), the test cancels the pipeline. It then inspects the collection and finds that there is exactly 1 document, which means that the transaction was committed partially.  In the log, I see the following:  ``` 2020-05-16 22:13:02.643 DEBUG 1988 --- [           main] o.s.d.m.ReactiveMongoTransactionManager  : Creating new transaction with name [com.example.commitoncancelproblems.BootService.savePair]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2020-05-16 22:13:02.667 DEBUG 1988 --- [           main] o.s.d.m.ReactiveMongoTransactionManager  : About to start transaction for session [ClientSessionImpl@5792c08c id = {""id"": {""$binary"": ""1TaU0xPNQpKaJTHdPLS05w=="", ""$type"": ""04""}}, causallyConsistent = true, txActive = false, txNumber = 0, error = d != java.lang.Boolean]. 2020-05-16 22:13:02.668 DEBUG 1988 --- [           main] o.s.d.m.ReactiveMongoTransactionManager  : Started transaction for session [ClientSessionImpl@5792c08c id = {""id"": {""$binary"": ""1TaU0xPNQpKaJTHdPLS05w=="", ""$type"": ""04""}}, causallyConsistent = true, txActive = true, txNumber = 1, error = d != java.lang.Boolean]. 2020-05-16 22:13:02.703 DEBUG 1988 --- [           main] o.s.d.m.core.ReactiveMongoTemplate       : Inserting Document containing fields: [kind, _class] in collection: e81205fa_eb5f_4492_8921_ffb3fccd2b76 2020-05-16 22:13:02.757 DEBUG 1988 --- [           main] o.s.d.m.ReactiveMongoTransactionManager  : Initiating transaction commit 2020-05-16 22:13:02.758 DEBUG 1988 --- [           main] o.s.d.m.ReactiveMongoTransactionManager  : About to commit transaction for session [ClientSessionImpl@5792c08c id = {""id"": {""$binary"": ""1TaU0xPNQpKaJTHdPLS05w=="", ""$type"": ""04""}}, causallyConsistent = true, txActive = true, txNumber = 1, error = d != java.lang.Boolean]. 2020-05-16 22:13:02.767 DEBUG 1988 --- [       Thread-6] o.s.d.m.ReactiveMongoTransactionManager  : About to release Session [ClientSessionImpl@5792c08c id = {""id"": {""$binary"": ""1TaU0xPNQpKaJTHdPLS05w=="", ""$type"": ""04""}}, causallyConsistent = true, txActive = false, txNumber = 1, error = d != java.lang.Boolean] after transaction. ```  So the code is actually run in a transaction. The `savePair()` pipeline never gets completed successfully, but the transaction gets committed producing the 'partial' result.  Looking at `TransactionAspectSupport.ReactiveTransactionSupport#invokeWithinTransaction()`, I see the following code:  ```java 	return Mono.usingWhen( 			Mono.just(it), 			txInfo -> { 				try { 					return (Mono) invocation.proceedWithInvocation(); 				} 				catch (Throwable ex) { 					return Mono.error(ex); 				} 			}, 			this::commitTransactionAfterReturning, 			(txInfo, err) -> Mono.empty(), 			this::commitTransactionAfterReturning) ```  The last parameter is `onCancel`. So it actually commits on cancel. (The same behavior is in `TransactionalOperatorImpl`; also, `spring-data-mongodb`'s `ReactiveMongoTemplate#inTransaction()` does the same, but it's a different Spring project).  This looks like a bug to me, but I can hardly believe that this behavior was implemented by mistake. Is it possible that I misunderstood something?  PS. There is an SO question with details and some context: https://stackoverflow.com/questions/61822249/spring-reactive-transaction-gets-committed-on-cancel-producing-partial-commits?noredirect=1#comment109381171_61822249","closed","type: documentation,","rpuch","2020-05-16T18:41:17Z","2020-06-08T16:45:19Z"
"","25158","Javadoc for hibernate5 OpenSessionInViewFilter mentions FlushMode.NEVER","**Affects:** 5.2.6 The javadoc for `org.springframework.orm.hibernate5.support.OpenSessionInViewFilter` mentions `FlushMode.NEVER`: ```  * NOTE: This filter will by default not flush the Hibernate Session,  * with the flush mode set to {@code FlushMode.NEVER}. It assumes to be used  * in combination with service layer transactions that care for the flushing: The  * active transaction manager will temporarily change the flush mode to  * {@code FlushMode.AUTO} during a read-write transaction, with the flush  * mode reset to {@code FlushMode.NEVER} at the end of each transaction. ```  However there is currently no  `FlushMode.NEVER` in `org.hibernate.FlushMode`, it was removed in hibernate 5.2.  Should there be `FlushMode.MANUAL`?","closed","type: documentation,","jiri-pejchal","2020-05-28T20:52:15Z","2020-05-29T14:06:48Z"
"","25013","ResourceUrlEncodingFilter causes LookupPathIndexException resulting in HTTP 400 when processing URLs indirectly referencing Welcome Files","**Affects:** 5.2.6  When the [ResourceUrlEncodingFilter](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceUrlEncodingFilter.java) receives a parcial request like `/somecontext/app/` - actually referencing Welcome Files (like `/somecontext/app/index.html`) - the initialization of the filter fails [raising a LookupPathIndexException](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceUrlEncodingFilter.java#L100) which finally leads to a HTTP 400 response status code.  When requesting URIs like `/somecontext/app/`, the servlet container (e.g. Apache Tomcat) implicitely adds the path to the respective Welcome File to the servlet path within the HttpServletRequest. This is done according to the Servlet Spec:  Servlet 3.1, section 10.10 - ""Welcome Files""  > [...] If a Web container receives a valid partial request, the Web container must examine > the welcome file list defined in the deployment descriptor. The welcome file list is an > ordered list of partial URLs with no trailing or leading /. The Web server must > append each welcome file in the order specified in the deployment descriptor to the > partial request and check whether a static resource in the WAR is mapped to that > request URI. If no match is found, the Web server MUST again append each > welcome file in the order specified in the deployment descriptor to the partial > request and check if a servlet is mapped to that request URI. The Web container > must send the request to the first resource in the WAR that matches. The container > may send the request to the welcome resource with a forward, a redirect, or a > container specific mechanism that is indistinguishable from a direct request. [...]  The ResourceUrlEncodingFilter fails [when trying to match lookupPath against requestUri](https://github.com/spring-projects/spring-framework/blob/v5.2.6.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceUrlEncodingFilter.java#L98):  ``` ... String requestUri = pathHelper.getRequestUri(this); // e.g. ""/spring-webmvc-demo/app/"" String lookupPath = pathHelper.getLookupPathForRequest(this); // e.g. ""/app/index.html"" this.indexLookupPath = requestUri.lastIndexOf(lookupPath); if (this.indexLookupPath == -1) {    throw new LookupPathIndexException(lookupPath, requestUri); } ... ```  The issue was introduced with Spring 4.3.21/5.1.2 probably with commit [50a47691](https://github.com/spring-projects/spring-framework/commit/50a4769162061f2e16dca7176f8b431093f08a27).  I've prepared a minimum demo project to show the issue: https://github.com/tknall/spring-mvc-demo  Build the maven project, deploy the resulting war file with a Servlet container (e.g. Tomcat 8.5) and run http://localhost:8080/spring-webmvc-demo/app/ actually referencing an underlying welcome file `spring-webmvc-demo/app/index.html` with the browser of your choice.  The request fails with  > Failed to find lookupPath '/app/index.html' within requestUri '/spring-webmvc-demo/app/'. This could be because the path has invalid encoded characters or isn't normalized.; nested exception is org.springframework.web.servlet.resource.ResourceUrlEncodingFilter$LookupPathIndexException: Failed to find lookupPath '/app/index.html' within requestUri '/spring-webmvc-demo/app/'. This could be because the path has invalid encoded characters or isn't normalized.","closed","status: invalid,","tknall","2020-05-04T15:46:10Z","2020-09-08T15:50:01Z"
"","25230","Support for custom cache registration in CaffeineCacheManager","**Affects:** 5.2.6  --- It is quite common to have multiple caches with different value lifetime. Right now CaffeineCacheManager creates every Cache with the default settings or the settings set through either of setCacheLoader, setCacheSpecification or setCaffeineSpec. But those settings apply to all Caches. If cacheMap would be exposed (maybe just a simple getter) it would be possible to add prebuilt caches with custom settings to it.","closed","type: enhancement,","T3rm1","2020-06-10T11:03:38Z","2020-06-10T20:56:47Z"
"","24929","Multi-module projects using FreeMarker cannot load all classpath template files","**Affects:** 5.2.6  ---  In multi-module projects,  `FreeMarkerConfigurationFactory` only can load first match resource which is in classpath. for example： ``` |-- projectA   |-- resource | |-- templates | | |-- test1.ftl | |-- projectB  | | | -- resource | | |-- templates | | | |-- test1.ftl |-- projectC   |-- resource | |-- templates | | |-- test1.ftl ``` using command  ``` java -classpath ""${BASE_PATH}/projectA/target/classes;${BASE_PATH}/projectB/target/classes;${BASE_PATH}/projectA/target/classes;"" Demo ``` using path config `classpath:/templates/`,but freemarker only can load `projectA` template files.","closed","status: superseded,","lonecloud","2020-04-18T15:28:14Z","2020-04-18T15:43:39Z"
"","24965","When autowiring, wildcards don't match type variables with same upper bounds","**Affects:** 5.2.5.RELEASE ---  In my project, I have a bean of type `Parametrized","open","in: core,","oxc","2020-04-24T13:16:15Z","2020-04-24T14:43:01Z"
"","24846","Ability to close connection on WebClient responses","**Affects:** 5.2.5.RELEASE  _This feature request arises from this [StackOverflow post](https://stackoverflow.com/questions/60833824/closing-reactor-netty-connection-on-error-status-codes). It could arguably fit either with spring-framework or reactor-netty, posting in spring-framework to start the discussion._  ---  **Context**  Some content delivery networks recommend to re-resolve DNS on certain types of status codes (e.g. 500 internal server error). To achieve this, I've added a custom Netty `DnsNameResolver` and `DnsCache`, but I also need to close the connection, otherwise it will be released back to the pool and DNS will not be re-resolved.  Two approaches have come to light so far:  **Approach 1: using Webclient alone**  This was suggested by Violeta Georgieva in [this answer](https://stackoverflow.com/a/60837837/3527464): ``` return this.webClient            .get()            .uri(""/500"")            .retrieve()            .onStatus(status -> status.equals(HttpStatus.INTERNAL_SERVER_ERROR), clientResponse -> {                 clientResponse.bodyToFlux(DataBuffer.class)                               .subscribe(new BaseSubscriber() {                                   @Override                                   protected void hookOnSubscribe(Subscription subscription) {                                       subscription.cancel();                                   }                               });                 return Mono.error(new IllegalStateException(""...""));            })            .bodyToMono(String.class); ```  Basically, subscribing to the response body and cancelling it immediately seems to close the connection. However, this relies on Spring's undocumented internal behaviour and causes bodies of error responses to be lost.  **Approach 2: using Reactor Netty's TcpClient**  This approach was my initial attempt, configuring the underlying `TcpClient` used by `WebClient`: ``` TcpClient tcpClient = TcpClient.create()         .observe((connection, newState) -> {             if (newState == State.RELEASED && connection instanceof HttpClientResponse) {                 HttpResponseStatus status = ((HttpClientResponse) connection).status();                 if (status.codeClass() != HttpStatusClass.SUCCESS) {                     connection.dispose();                 }             }         }); ```  This approach also feels clunky and leads to a potential race condition: if the connection is released back to the pool after an error status code, and the observer is notified to close that connection, a new request could acquire that pooled connection in parallel.  **Other approaches?**  Are there any other approaches that one could implement to close the connection on error status codes? Could some more convenient interfaces be added to Spring or Reactor Netty's APIs?","closed","for: external-project,","PyvesB","2020-04-02T08:43:28Z","2020-04-08T15:55:48Z"
"","25068","Add ResponseEntity.created(void) overload","**Affects:** 5.2.5.RELEASE  --- https://tools.ietf.org/html/rfc7231#section-6.3.2 says the location URI is optional. For a `PUT` request the effective URI is already provided by the client. Please provide the `ResponseEntity.created()` overload additionally to `ResponseEntity.created(URI) `.","closed","type: enhancement,","michael-o","2020-05-13T18:14:53Z","2021-02-08T14:19:31Z"
"","25052","Support configurable timeout in @Transactional","**Affects:** 5.2.5 --- Currently `@Transactional` annotation supports only hard-coded values for the `timeout` attribute. Sometimes it might be necessary for a project to externalize the timeout value via configuration (for instance, to have a quick way to increase the timeout on a critical business operation without the code changes and keep business running).  There are examples of configurable values already implemented. `@Scheduled` supports `fixedDelay / fixedDelayString`, `fixedRate / fixedRateString`, etc.   Would you be interested in this functionality? We could prepare a pull request supporting `timeoutString` in `@Transactional`.","closed","type: enhancement,","orange-buffalo","2020-05-12T07:52:29Z","2020-05-12T23:50:56Z"
"","25124","TransactionAwareCacheManagerProxy does not take into account nested transaction's propagation","**Affects:** 5.2.5  If inside an already present transaction I execute a method annotated with `@CacheEvict` **and** `@Transactional(propagation = REQUIRES_NEW)`, the cache is evicted only after the top level transaction is commited.  Not sure if this is a bug or expected behaviour.","closed","status: invalid,","egotsev","2020-05-25T09:01:10Z","2020-05-30T12:56:10Z"
"","25444","UriComponentsBuilder have problems with squere brakcets ""[ ]""","**Affects:** 5.2.5  If a query has brackets in its values, then it is not completely encoded, but accepted by the URI implementation.   Problem is with `build(boolean)` method, which works in an inconsistent way.  if parameter is `true`, then it validates if URI is *completely* encoded and fails when there are an unencoded `[]` when parameter is `false`, then it selectively encodes the URI, specifically it doesn't encode `[]`, producing again invalid URI.  Look at this test: ```   @Test   public void encoding() throws URISyntaxException {      URI uri = new URI(""http://example.com/some/path?query=[from%20to]"");     try {       UriComponentsBuilder.fromUri(uri).build(true);       fail(""It wasn't completely encoded URI"");     } catch (IllegalArgumentException e) {       //good     }      //ok, then encode it     uri = UriComponentsBuilder.fromUri(uri).build(false).toUri();     //now it is double encoded http://example.com/some/path?query=[from%2520to]      //so is it encoded now?     UriComponentsBuilder.fromUri(uri).build(true); //fail, no it is not, square brackets are there   } ```  Whatever you do, it is not possible to use `UriComponentsBuilder` on the above uri and get the valid or at least the same uri as a result.   I am not the only one confused: https://github.com/spring-cloud/spring-cloud-gateway/blob/master/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/filter/RouteToRequestUrlFilter.java#L63  ---","closed","","molsza","2020-07-21T14:46:02Z","2021-10-26T02:12:38Z"
"","24974","Cannot overwrite values from YAML list in the Spring Environment","**Affects:** 5.2.5  I have the following `application.yml`:  ```yml foo:    bar:      -        id: baz       item: value     // ... ```  Then I want to overwrite item value in tests using @DynamicPropertySource:  ```kotlin     @DynamicPropertySource     @JvmStatic     @Suppress(""unused"")     fun setupProperties(registry: DynamicPropertyRegistry) {         registry.add(""foo.bar[0].item"") { ""new value"" }     } ```  Unfortunately, the above code: 1) removes all elements from the array 2) adds one element with `item` field set to `new value`  I created a sample java project highlighting this issue: https://github.com/kkocel/dynamicproperties","closed","in: core,","kkocel","2020-04-25T17:42:35Z","2020-04-30T14:25:20Z"
"","25246","UriComponentsBuilder does not resolve regex path variables","**Affects:** 5.2.5  ---    ``` System.out.println(""template:: "" + templateStr); UriComponents uriComponents = UriComponentsBuilder.fromUriString(templateStr).build(); System.out.println(uriComponents.getPathSegments()); ```  template:: http://localhost/{urlLocale:[a-z](?:-[a-z])?}/quotes/1 [{urlLocale:[a-z](]  Looks like the ? in regex is breaking the resolution.","open","in: web,","spc16670","2020-06-12T08:27:02Z","2021-11-10T12:17:37Z"
"","25087","DefaultServerRequest bug with pathVariables when using MockServerRequest and MockServerWebExchange","**Affects:** 5.2.5  **Description** In 5.2.5 version `MockServerRequest` has been deprecated in favor of `ServerRequest.create(ServerWebExchange, List)}` combined with `MockServerWebExchange`.  Implementation of `pathVariables()` method in `DefaultServerRequest` looks like:  ``` @Override public Map pathVariables() { 	return this.exchange.getAttributeOrDefault( 		RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap()); } ``` And the problem is that `URI_TEMPLATE_VARIABLES_ATTRIBUTE` attribute is not set during creation of `MockServerWebExchange`.  So, it's impossible to get `pathVariables` from `DefaultServerRequest` implementation of ServerRequest when it's created from `MockServerRequest` and `MockServerWebExchange`.  Example of how I'm using MockServerRequest in tests (Spock). ``` final mockServerHttpRequest = MockServerHttpRequest                 .post('/foo/{bar}/{bar1}', 'var1', 'var2')                 .contentType(MediaType.APPLICATION_JSON)                 .body('{}') final mockServerWebExchange = MockServerWebExchange.from(mockServerHttpRequest) final mockServerRequest = ServerRequest.create(mockServerWebExchange, HandlerStrategies.withDefaults().messageReaders()) ``` And then this ```mockServerRequest``` is passed into handler function  as an argument.","closed","in: web,","IbrayevRamil","2020-05-15T19:15:06Z","2020-06-08T13:44:04Z"
"","25372","isAllocated check in DataBufferUtils::release hides reference counting errors","**Affects:** 5.2.4 (currently what we use); 5.3.0-SNAPSHOT  ---  https://github.com/spring-projects/spring-framework/blob/c972d861edee89c0ca97ddfe455d803f3d046ab9/spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java#L500  When testing code that is using explicit retain/release it is useful to have unit tests that exercise your code and check that the buffers are correctly released.  With the check on `isAllocated` before releasing, your code can release as many times as it wants or forget to retain, and the tests still pass; but when actually running longer tests or in production, the error is delayed until some time in the future, for example, when data is read.  ```java Flux transform(Flux inputs) { // do some work that joins or filters the input.   return inputs.filter(somePredicate)     .map(DataBufferUtils::retain) // retain just the bits that we need downstream     .doOnComplete(inputs.subscribe(DataBufferUtils::release) // causes every input to be released; the buffers that are not used should be deallocated. }  void testReferenceCounts() {   Flux inputs = createSomeSuitableData(); // every DataBuffer has a reference count of 1 from it's initial creation.      result = transform(inputs);    result.forEach(DataBufferUtils::release) // release the output. This should release & deallocate every input buffer that was not filtered    assertThat(input, everyItem(isUnallocated());   assertThat(result, everyItem(isUnallocated()); } ```  If you forget the `retain` in `transform` then you should have a fail-fast(ish) exception in the test when trying to release the `result`. With the check on `isAllocated` in `DataBufferUtils` this test would pass, and the error surfaces itself in a bit of code that is unrelated.  If you forget the `doOnComplete` then you have a memory leak, and the test fails, correctly when attempting to assert that every item is unallocated.  If you have too many `release` calls or release the wrong buffers, then the test still passes and the error surfaces somewhere else.  ---  I currently think that the check on `isAllocated` is overly defensive and makes errors much harder to diagnose.","closed","","CandleCandle","2020-07-08T15:48:34Z","2020-10-20T15:07:57Z"
"","25086","NoRollbackRuleAttributes ignored by TransactionTemplate","**Affects:** 5.2.3.RELEASE  I have replicated the issue with `5.2.3.RELEASE`, but I believe later versions are also affected.  --- **What I'm trying to do**  I need a transaction which will not be rolled back if a `RuntimeException` is thrown, but I need to do this manually (i.e. using a `TransactionTemplate`) rather than using the `@Transactional` annotation.  In summary, I am trying to achieve this behaviour...  ```java @Transactional(dontRollbackOn = RuntimeException.class) public void myMethod() { } ```  ... using a `TransactionTemplate`.  --- **Issue description:**  I have tried to achieve the behaviour outlined above by defining a new `NoRollbackRuleAttribute`and constructing a `TransactionTemplate` with it:  ```java RuleBasedTransactionAttribute rules = new RuleBasedTransactionAttribute(); rules.getRollbackRules().add(new NoRollbackRuleAttribute(RuntimeException.class));  TransactionTemplate transactionTemplateNoRollback = new TransactionTemplate(platformTransactionManager,rules);  CustomObject = transactionTemplateNoRollback.execute(           (TransactionCallback) status -> {             throw new RuntimeException(); }); ```  The `NoRollbackRuleAttribute`seems to be ignored and an `UnexpectedRollbackException` is thrown if my method my method throws any `RuntimeException`:  ``` org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only ```  ---  ***(Possible) cause***  The `TransactionTemplate(PlatformTransactionManager transactionManager, TransactionDefinition transactionDefinition)` constructor invokes the `DefaultTransactionDefinition(TransactionDefinition other)` constructor which looks as follows:  ```java public DefaultTransactionDefinition(TransactionDefinition other) { 		this.propagationBehavior = other.getPropagationBehavior(); 		this.isolationLevel = other.getIsolationLevel(); 		this.timeout = other.getTimeout(); 		this.readOnly = other.isReadOnly(); 		this.name = other.getName(); 	} ```  Neither constructor seems to do anything with the RollbackRules provided to it.  ---  *** Work around***  I have fallen back to using `@Transactional(dontRollbackOn = RuntimeException.class)` for now, but that requires me to create a new public method within a different class which is exactly what I was trying to avoid.","closed","status: invalid,","joeltoby","2020-05-15T15:47:10Z","2020-05-15T19:18:36Z"
"","25408","Can't receive Publisher in @RequestBody using Spring Web MVC","**Affects:** 5.2.3.RELEASE  ---   I have an application which uses both spring webflux and spring web mvc because of certain constraints. when i try to add an endpoint which receives a reactive type (`Publisher`) in `@RequestBody` i get an error. endpoint example: ``` @PostMapping(consumes = MediaType.APPLICATION_STREAM_JSON_VALUE) public Mono doSomething(@RequestBody Publisher entities){           //... } ``` i got this error when called the endpoint: ``` org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class org.reactivestreams.Publisher]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of org.reactivestreams.Publisher (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information ``` when i tried it in an application that uses spring webflux only, it worked well. spring web mvc does support sending a reactive type in the response, is there any limitation that prevents the support of receiving a reactive type in request body? is it something that is planned to be supported in the future?","closed","status: invalid,","mosherobinov","2020-07-17T12:50:27Z","2020-07-20T07:40:43Z"
"","25636","Calling a overloaded (Spring Integration inbound-gateway) resource mapped with same path but different method throws exception","**Affects:** 5.2.3.RELEASE   **Describe the bug** on one side we have a controller which is listening to a generic GET endpoint /api1/whatevertypes  ```java  @RestController @RequestMapping(     value = ""/api1"",     produces = {""application/json""}) @AllArgsConstructor @CrossOrigin(origins = ""*"") @Slf4j public class GenericApi {    @GetMapping(value = {""/{whatevertype}s"")   ResponseEntity getList(       @PathVariable() final String whatevertype,       @RequestHeader HttpHeaders httpHeaders) {           return ResponseEntity.status(HttpStatus.BAD_REQUEST)           .contentType(MediaType.TEXT_PLAIN)           .body(""1234"");        } } ```  on the other side we have Spring Integration http inbound-gateway which should listen to POST endpoint with the same path as above /api1/whatevertypes   ```java                            ```   when we call the POST endpoint with the path like ""%/api1/mytypes"" it throws the error: Request method 'POST' not supported ,an error  is thrown.  On debug we can see that both mappings exists but when spring is looping through it just tries to match the first map and throws an error if it doesn't find a match.  If we configure the order/prio (RequestMappingHandlerMapping) where spring i trying to resolve the path it is failing the other way round (POST is working GET doesn't).  I opened a ticket for Spring Integration (https://github.com/spring-projects/spring-integration/issues/3366) which were answered by a member with the following comment:  Please, consider to raise this issue against https://github.com/spring-projects/spring-framework. The RequestMappingInfoHandlerMapping class is managed over there together with the mentioned throw new HttpRequestMethodNotSupportedException(request.getMethod(), methods); which is not handled to let us to try other HandlerMapping in the DispatcherServlet.    **To Reproduce** Set up a GET restcontroller with a generic path and in parallel set up an Spring Integration http inbound gateway with a POST method and same path as the GET restcontroller.  Call the POST endpoint leads to   **Expected behavior** spring must loop over all possible mappings for matching before throwing an error.  Calling the POST and the GET resource with the configuration above works.","closed","status: invalid,","bischste","2020-08-24T06:12:32Z","2020-09-14T11:00:51Z"
"","25046","Logging request/response payload in REST API service","**Affects:** 5.2.2 (SpringBoot: 2.2.2) ---  Logging request/response payload should be a pretty standard and straightforward thing to configure in such a powerful and customisable web framework as Spring is. Yet there are a number of different alternatives and confusing implementation details which resulted in all sorts of advices on the internet. Take a look at this StackOverflow question for example: https://stackoverflow.com/questions/33744875/spring-boot-how-to-log-all-requests-and-responses-with-exceptions-in-single-pl I couldn't find a good standard example in the official docs, sorry if I missed it and please just point me at it then.  There are several problems that I'm facing when it comes to logging in Spring. 1. `CommonsRequestLoggingFilter` doesn't log request payload in `Before request` where it's expected to be logged. 1. Default `AbstractRequestLoggingFilter` also doesn't log payload in `Before request`. But here you can fix it if you override `getMessagePayload` method and include `wrapper.getParameterMap()` call before calling `wrapper.getContentAsByteArray()` where `wrapper` is a `ContentCachingRequestWrapper` object. 1. Even if you call `getParameterMap()` before `getContentAsByteArray()`, `ContentCachingRequestWrapper` implementation won't allow you to log anything else but POST requests with `application/x-www-form-urlencoded` content type. It's not clear to me why is this limitation.  There is some confusion here if you see. My main question I guess is about limitations in `ContentCachingRequestWrapper`, what's the reason for them and could they be removed to allow any text-based payload to be logged?","closed","status: invalid,","bigunyak","2020-05-11T04:56:08Z","2021-10-15T03:19:23Z"
"","25706","VerifyErrors when using SpEL compilation with Thymeleaf when invoking a default method defined in an interface","**Affects:** 5.2.0.RELEASE  I'm working on a Spring Boot project where the SpEL compilation is enabled through a WebMvcConfigurer:  ```java @Configuration public class WebMvcConfig implements WebMvcConfigurer {     @Autowired     private ITemplateResolver templateResolver;     @Bean     public SpringTemplateEngine templateEngine() {         SpringTemplateEngine templateEngine = new SpringTemplateEngine();          templateEngine.setEnableSpringELCompiler(true);          // ...         templateEngine.setTemplateResolver(templateResolver);         // ...          return templateEngine;     } } ```  I got a VerifyError when using an expression in some Thymeleaf views, where I try to invoke a method on an object:  ```html                Page title                                                                                                                                                                                                                                           	                                                                 								                                                                                           ```  Here is the stacktrace for the error: ``` 2020-09-02 18:22:38.218 ERROR 125577 --- [nio-8010-exec-5] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is  org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: ""item.isEditable(user)"" (template: ""itemList"" - line XXX, col XXX)] with root cause  java.lang.VerifyError: (class: spel/Ex24, method: getValue signature: (Ljava/lang/Object;Lorg/springframework/expression/EvaluationContext;)Ljava/lang/Object;) Illegal type in constant pool         at java.lang.Class.getDeclaredConstructors0(Native Method) ~[na:1.8.0_212]         at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671) ~[na:1.8.0_212]         at java.lang.Class.getConstructor0(Class.java:3075) ~[na:1.8.0_212]         at java.lang.Class.getDeclaredConstructor(Class.java:2178) ~[na:1.8.0_212]         at org.springframework.util.ReflectionUtils.accessibleConstructor(ReflectionUtils.java:185) ~[spring-core-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.expression.spel.standard.SpelCompiler.compile(SpelCompiler.java:108) ~[spring-expression-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.expression.spel.standard.SpelExpression.compileExpression(SpelExpression.java:513) ~[spring-expression-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.expression.spel.standard.SpelExpression.checkCompile(SpelExpression.java:489) ~[spring-expression-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:331) ~[spring-expression-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.processor.StandardIfTagProcessor.isVisible(StandardIfTagProcessor.java:59) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.standard.processor.AbstractStandardConditionalVisibilityTagProcessor.doProcess(AbstractStandardConditionalVisibilityTagProcessor.java:61) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.CloseElementTag.beHandled(CloseElementTag.java:139) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.GatheringModelProcessable.process(GatheringModelProcessable.java:78) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.CloseElementTag.beHandled(CloseElementTag.java:139) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.TemplateModel.process(TemplateModel.java:136) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:592) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar!/:3.0.11.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.doFilter(AbstractPreAuthenticatedProcessingFilter.java:121) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.doFilter(AbstractPreAuthenticatedProcessingFilter.java:121) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.csrf.CsrfFilter.doFilterInternal(CsrfFilter.java:117) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) ~[spring-security-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) ~[spring-boot-actuator-2.2.0.RELEASE.jar!/:2.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.0.RELEASE.jar!/:5.2.0.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:526) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1579) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_212]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_212]         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.27.jar!/:9.0.27]         at java.lang.Thread.run(Thread.java:748) [na:1.8.0_212] ```  It appears that the error occurs because the method isEditable is defined this way: ```java public class Item implements Editable {     // some fields     private String someField;      // some getters and setters     @Override    public boolean hasSomeProperty() {        return someField != null;     } } ```  ```java public interface Editable {    default boolean isEditable(User user) {         return user.isAdmin() && hasSomeProperty()    }     boolean hasSomeProperty(); } ```  Actually, when the method is defined this way, the expression compilation works nicely: ```java public class Item extends AbstractEditable {     // some fields     private String someField;      // some getters and setters     @Override    public boolean hasSomeProperty() {        return someField != null;     } } ```  ```java public abstract class AbstractEditable {    public boolean isEditable(User user) {         return user.isAdmin() && hasSomeProperty()    }     public abstract boolean hasSomeProperty(); } ```  ---","closed","in: core,","alnoprods","2020-09-04T15:45:13Z","2020-09-05T11:13:05Z"
"","25042","MockHttpServletRequest parse uri query params","**Affects:** 5.2.0.RELEASE  Currently the following returns an **empty** map: `new MockHttpServletRequest( ""GET"", ""http://test.com?a=b"" ).getParameterMap()`  URI should be parsed and query parameters returned.","closed","status: invalid,","cdalexndr","2020-05-10T17:39:28Z","2020-05-12T06:33:13Z"
"","25112","Introduce PropertyEditor for JSON mapping","**Affects:** 5.2.0.RELEASE  ---   I would like to use the Spring annotation `@Value` to map a json-format string property to a object of custom class.  For example, I want to do this:  ```java     @Value(""${some.special.book}"")     private Book book; ```  where the property file says:  ```properties some.special.book={""title"":""Animal Farm"",""id"":5566} ```  Then I have to add a `PropertyEditor` that can handle json parsing into `CustomEditorConfigurer`.  I saw that there are plenty off-the-shelf `PropertyEditor` in https://github.com/spring-projects/spring-framework/tree/master/spring-beans/src/main/java/org/springframework/beans/propertyeditors, and I wonder if we can add a `PropertyEditor` that can parse json-format string and map to a custom object (maybe with Jackson library). Thank you.","closed","in: core,","johnlinp","2020-05-21T01:58:20Z","2020-05-29T15:59:55Z"
"","25328","RestTemplate reads JSON body as ISO-8859-1 instead of UTF-8 when +json suffix content-type","**Affects:** 5.2.0 and later  `RestTemplate` reads JSON body as `ISO-8859-1` instead of `UTF-8` when content type has `+json` suffix, e.g. `application/vnd.api.v1+json`, and `responseType` is set to `String`. Note that `UTF-8` is chosen for `application/json` content-type.  This behaviour exists in Spring for a long time, but has now larger impact after Spring MVC applications stopped setting `;charset=utf-8` (#22788). We started observing it in multiple places of our ~500 Spring Boot microservices ecosystem after upgrades to Spring Boot 2.2.0 and later.  ## Details Let's consider a controller:  ```java @RestController class Controller {      @GetMapping(path = ""/hello"", produces = ""application/vnd.api.v1+json"")     Hello hello() {         return new Hello(""zażółć gęślą jaźń"");     }      static class Hello {         private final String value;          @JsonCreator         Hello(@JsonProperty(""value"") String value) {             this.value = value;         }          public String getValue() {             return value;         }     } } ```  Now let's call this controller in 2 different ways: ```java public static void main(String[] args) {     new RestTemplate().exchange(         ""http://localhost:8080/hello"", HttpMethod.GET, entityWithAcceptJsonSuffix(), String.class     ).getBody();  // 1      new RestTemplate().exchange(         ""http://localhost:8080/hello"", HttpMethod.GET, entityWithAcceptJsonSuffix(), Hello.class     ).getBody();  // 2 }  private static HttpEntity entityWithAcceptJsonSuffix() {         HttpHeaders headers = new HttpHeaders();         headers.set(""accept"", ""application/vnd.api.v1+json"");         return new HttpEntity(headers); } ```  ### Actual behaviour The body read in the setup above is:  1. `{""value"":""zaÅ¼Ã³ÅÄ gÄÅlÄ jaÅºÅ""}` 2. `{""value"":""zażółć gęślą jaźń""}`  ### Expected behaviour Both of the above should be read as `{""value"":""zażółć gęślą jaźń""}`.  From what I understand `+json` suffix content types, e.g. `application/vnd.api.v1+json`, should be interpreted as `UTF-8` by default ([RFC6839](https://tools.ietf.org/html/rfc6839#section-3.1)).","closed","in: web,","pbetkier","2020-06-29T11:39:33Z","2020-07-01T08:55:34Z"
"","24961","TypeMappedAnnotation.getValue(int,boolean,boolean) burns a lot of CPU, 2x total CPU usage on process after upgrade from 5.1 to 5.2","**Affects:** 5.2 **Type:** Bug  SpringFramework 5.2 has a regression in CPU performance when dealing with `RequestParameter`s with default values in combination with having a `Filter` that looks at the `HttpServletRequest` & `HttpServletResponse` (AccessLogging). The impact on CPU is massive when upgrading from `5.1` to `5.2`.  I replicated the behaviour here  https://github.com/jensim/spring-boot-compare-22-21  @philwebb  @jhoeller @sbrannen","closed","status: superseded,","jensim","2020-04-23T10:00:43Z","2020-04-27T12:15:35Z"
"","25752","Make path pattern optional in router functions","**Affects:** 5.2  If WebMvc.fn is used with nested routes, it is not always necessary to specify the path pattern for every registered handler.  ```kotlin accept(APPLICATION_JSON).nest {   path(""/{listId}"").nest {     GET("""", listHandler::findById)     PUT("""", listHandler::update)     DELETE("""", listHandler::delete)   }   path(""/{listId}/{taskId}"").nest {     GET("""", taskHandler::findById)     DELETE("""", taskHandler::delete)   } } ```  The path pattern is only specified at the surrounding `path` element. Below this element all handlers are related to the given path, like `/{listId}/`.  A `path` with verbs (`GET`, `PUT`, ...) would pretty much reflect the concept of a REST ""resource"".  I suggest the following syntax:  ```kotlin accept(APPLICATION_JSON).nest {   path(""/{listId}"").nest {     GET(listHandler::findById)     PUT(listHandler::update)     DELETE(listHandler::delete)   } } ``` Since all handler registrations share the same base path, there is no need to specify it on each element.  It should be possible to use predicates without a path, too.","closed","type: enhancement,","helmbold","2020-09-10T19:56:33Z","2020-10-06T09:02:52Z"
"","25629","Kotlin code that uses WebClient fails after upgrade to Spring 5.2","**Affects:** 5.2  Consider the following usage of `WebClient`: ```kotlin suspend fun getApiResponse(): String {     val webClient = WebClient.create(apiUrl)      val response = webClient.get()             .uri(""/resource"")             .exchange().awaitFirst()      // inspect response, like response.statusCode(); maybe return different result based on response attributes      return response.bodyToMono(String::class.java).awaitFirst() } ``` This code is leveraging `kotlinx-coroutines-reactor` extensions to use `WebClient` in imperative manner. It works fine on Spring Framework 5.1.   After upgrade to 5.2, this code starts failing on `response.bodyToMono(String::class.java).awaitFirst()` with the following exception: ``` The client response body has been released already due to cancellation. java.lang.IllegalStateException: The client response body has been released already due to cancellation. 	(Coroutine boundary) 	at com.example.demo.ApiConsumer.getApiResponse$suspendImpl(ApiConsumer.kt:21) ... Caused by: java.lang.IllegalStateException: The client response body has been released already due to cancellation. 	at org.springframework.http.client.reactive.ReactorClientHttpResponse.lambda$getBody$0(ReactorClientHttpResponse.java:98) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Body from GET http://localhost:37917/resource [DefaultClientResponse] ... ``` It looks like the fix for #25216 changes the behaviour of `WebClient` in a way this code starts failing.   Please find the full reproducer at orange-buffalo/spring-5.2-web-client-kotlin-reproducer@6ffd25af2a64fc27b37890d35f698e5f37df7b52 . `CancelledResponseReproducer` fails with 5.2, downgrading the dependency to 5.1 makes the test pass.","closed","type: regression,","orange-buffalo","2020-08-22T08:39:48Z","2020-10-05T11:49:52Z"
"","25840","@Autowired setters not called in PrototypeBeans created in @Configuration","**Affects:** 5.1.6.RELEASE, similar problem appeared trying with spring boot 2.3.2.RELEASE and 1.5.22.RELEASE  --- Trying to create a way to use Strategy Pattern in my service I constructed this set of classes:  MathOperProcessor is the base class for   -  MathOperAdd  -  MathOperDivide  -  MathOperMultiply   Each of them have a different set of Services @Autowired with setter injection.  And to use them as a service an Enum/@Configuration/@Service classes whose snippets are shown below (real implementation can be found in my github project [strategy-calculator branch minimum](https://github.com/toniocus/strategy-calculator/tree/minimum)).   ```java public enum MathOperEnum {          // 2 parameters     // 1 - A key to recognize the operation     // 2 - An implementation of MathOperProcessor abstract class    //       each implementation has a different set of @Autowired setters.     ADD(""add"", MathOperAdd.class),     MULTIPLY(""mult"", MathOperMultiply.class),     DIVIDE(""div"", MathOperDivide.class);          public String getKey() {         return this.key;     }      public Class","open","in: core,","toniocus","2020-09-29T17:26:57Z","2020-10-01T15:26:30Z"
"","25620","Blocked thread while reading request body in ServletServerHttpRequest","**Affects:** 5.1.15.RELEASE  ---  ## Summary of issue  We sporadically see issues with ""stuck threads"" in a WebFlux service, where one thread becomes blocked while trying to read the request body and all further incoming requests that get handled by that particular thread are suspended indefinitely (until the service eventually OOMs or is restarted).  We are not able to reproduce the issue by design, but it reoccurs regularly with no observable trigger. Time between reoccurrence is anywhere from 3 days to a month and a half, which makes it difficult to diagnose.  ## Set up  ### Versions  Spring: 5.1.15.RELEASE Jetty: 9.4.29.v20200521 Java: OpenJDK Runtime Environment Corretto-11.0.8.10.1   ### Application configuration  We have a simple WebFlux reactive service that does the following:  - Given an incoming POST request with specific fields in the JSON request body: 	- Either perform a computation based on the body fields and return a response 	- Or make an outgoing `WebClient` call to retrieve additional data from another service and then perform the same above computation - The service uses a `@RestController` style controller. - The service has a WebFilter that verifies and logs data about the incoming request's headers before it is processed by the controller. 	- The WebFilter uses `publishOn(Schedulers.parallel())` (The particular work doesn't need to be scheduled off the main thread, but it is. This _may_ be important later...) 	- The parallel scheduler was created with three threads due to the CPU configuration. - Requests are made to this service from a Node.js application with a 300ms timeout.  ## Observed symptoms  - The issue first manifests as an increasing number of requests timing out from the client. - Looking at the server, we see a monotonically increasing number of suspended requests with a corresponding increase in open file descriptors, the volume of which matches the volume of timed-out requests on the client side. - Metrics show that 1/3rd of requests are getting suspended prior to making it to the controller, while the other 2/3rds of requests continue to be processed as expected. - In the logs we see that the requests that continue to be processed are all handled on `parallel-2` and `parallel-3` threads. - There is a distinct absence of requests being handled on `parallel-1` thread after the start of the ""stalling"" issue. - Running `lsof` on the server while it is in the stalled state, we see a significant number of connections to the server stuck in the `CLOSED_WAIT` state, which matches the volume of timed-out client requests as well as the volume of suspended requests on the server.  ### Further investigation  - By connecting to the running service in the stalled state via JMX and VisualVM we see that `parallel-2` and `-3` threads continue to process incoming requests, while `parallel-1` thread is stuck in `Waiting` state. - According to the thread dump we see that the thread is blocked for content in the `ServletServerHttpRequest`  ```    java.lang.Thread.State: WAITING         at java.base@11.0.8/java.lang.Object.wait(Native Method)         - waiting on  (a java.util.ArrayDeque)         at java.base@11.0.8/java.lang.Object.wait(Object.java:328)         at app//org.eclipse.jetty.server.HttpInput.blockForContent(HttpInput.java:568)         at app//org.eclipse.jetty.server.HttpInput$1.blockForContent(HttpInput.java:1098)         at app//org.eclipse.jetty.server.HttpInput.read(HttpInput.java:318)         at java.base@11.0.8/java.io.InputStream.read(InputStream.java:205)         at app//org.springframework.http.server.reactive.ServletServerHttpRequest.readFromInputStream(ServletServerHttpRequest.java:211)         at app//org.springframework.http.server.reactive.ServletServerHttpRequest$RequestBodyPublisher.read(ServletServerHttpRequest.java:290)         at app//org.springframework.http.server.reactive.ServletServerHttpRequest$RequestBodyPublisher.read(ServletServerHttpRequest.java:266)         ... ```  (Full trace and heap dump provided below).  ## Hypothesis  Our hypothesis is that something has caused one of the parallel threads to get blocked while reading the request body. While this thread is blocked, incoming requests begin to get suspended waiting for this thread to free up and process them. This causes the increase in suspended requests (and client-side timeouts as requests never get processed).  What we are not able to determine is what is the condition that causes the thread to block on the request body in the first place.  ## Further details  We have since upgraded the service to use the latest release of Spring and Jetty (5.2.6.RELEASE and 9.4.30.v20200611). We have not seen the issue reoccur yet after 1 day, but given the wide range of time between sporadic reoccurrences we cannot positively say whether this resolves the issue or not.","open","status: feedback-provided,","scottjohnson","2020-08-20T23:16:50Z","2021-11-08T11:17:42Z"
"","24953","HttpMediaTypeNotSupportedException thrown when Jackson found multiple deserializing methods in object.","**Affects:** 5.1.10  I was trying to POST a json for a given model that have lombok's AllArgsConstructor as well as implicitly defined private constructor annotated with JsonCreate, similarly to this: ```java @Data @Builder @NoArgsConstructor @AllArgsConstructor @ToString public class Example {   private String string1;   private String string2;    @JsonCreator   private Example(@JsonProperty(""string1"") String string1, @JsonProperty(""string2"") String string2) {     this.string1 = string1;     this.string2 = string2;   }  } ```  Sending this to an endpoint with proper request body defined will result in internal error caused by HttpMediaTypeNotSupportedException with explanation:  `""Content type 'application/json;charset=utf-8' not supported""`  However when I change log level to warn I can see the real cause of the problem: (logged before exception is thrown)  > WARN  [                    ] org.springframework.http.converter.json.MappingJackson2HttpMessageConverter - Failed to evaluate Jackson deserialization for type [[simple type, class com.example.Example]]: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Conflicting property-based creators: already had explicitly marked creator [constructor for com.example.Example, annotations: {interface java.beans.ConstructorProperties=@java.beans.ConstructorProperties(value=[string1, string2])}], encountered another: [constructor for com.example.Example, annotations: {interface com.fasterxml.jackson.annotation.JsonCreator=@com.fasterxml.jackson.annotation.JsonCreator(mode=DEFAULT)}]  So basically Jackson can't deserialize because I defined two deserializing constructors (lombok adds @ConstructorProperties annotation for its generated constructors).  The current behavior suggests that my application does not support content type given by headers, when in reality I have a class that is incorrectly designed. As a result I spent some time to check my application configuration because I thought we might have incorrectly configured message converters.  I believe that the exception thrown by Spring is misleading and some other exception should be thrown instead with a real cause of the problem explained.  Below is the important part of stack trace for received error: ``` org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/json;charset=utf-8' not supported 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:225) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:158) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:131) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:127) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) ~[spring-web-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:893) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:798) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) [spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) [spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) [servlet-api.jar:?] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [servlet-api.jar:?] ```","closed","status: declined,","Zuroslaw","2020-04-22T02:29:27Z","2020-04-22T11:31:36Z"
"","25796","This is not a problem, but I am curious.","**Affects:** 5.0.x  ---  ```java boolean resolved = false; boolean autowireNecessary = false; if (args == null) { 	synchronized (mbd.constructorArgumentLock) { 		if (mbd.resolvedConstructorOrFactoryMethod != null) { 			resolved = true; 			autowireNecessary = mbd.constructorArgumentsResolved; 		} 	} } if (resolved) { 	 	if (autowireNecessary) { 		return autowireConstructor(beanName, mbd, null, null); 	} 	else { 		return instantiateBean(beanName, mbd); 	} }   ``` If autowireNecessary is false, the object is created as a factory by adding @Bean annotation, then it will not go to the constructor method, I want to know what scenario will be established？I thought for a long time，thanks!","closed","","JulianHang","2020-09-22T01:24:39Z","2020-09-22T10:11:03Z"
"","25842","ExceptionHandler does not work on a secured class/method","**Affects:** 5.0.7.RELEASE  --- On a `RestController`, it seems that exception handling does not work when the controller's class has bean proxied due to `@PreAuthorize` annotation.  In `ExceptionHandlerExceptionResolver.java` : the handled types to exception handlers mapping resolution uses proxied class instead of the original type (see line 455 : `handlerMethod.getBeanType()` )  The following (Kotlin) source code explain the problem (commenting the first line re-enable the exception handling... while disabling the security !)  ```     @PreAuthorize(""hasAuthority('anyAuthority')"")     @RestController     class AnyController : IAnyController {         override fun doSomething(): ResponseEntity {             throw ToBeHandledException()         }          @ExceptionHandler(ToBeHandledException::class)         fun handleException(e: ToBeHandledException): ResponseEntity =             ResponseEntity.ok().build()     } ```","closed","","jeremee","2020-09-29T21:13:29Z","2020-10-14T10:55:44Z"
"","24916","MockHttpServletRequest should not strip brackets from IPV6 address supplied via Host header","**Affects:** 5.0.2 - 5.2.5  ---  The latest versions of `spring-test` since 5.0.2 don't include the IPV6 address in the `getRequestURL()` in correct []-quoting.  For example if the `MockHttpServletRequest` is constructed using `""GET"", ""/""` and then the server name is set with a call to `setServerName(""::ffff:abcd:abcd"")`, then `getRequestURL()` returns `""http://[::ffff:abcd:abcd]/""` in the old versions, but latest versions return `""http://::ffff:abcd:abcd/""` which cannot be parsed by `java.net.URL`.  The problem seems to happen in the `getRequestURL()` implementation which uses `getServerName()` and does not check if the `serverName` is actually IPV6 address which should be quoted with brackets.  See [RFC 2732](https://tools.ietf.org/html/rfc2732) for reference.  ```java     @Test     public void testIPV6() {         String ipv6 = ""::ffff:abcd:abcd"";         MockHttpServletRequest request = new MockHttpServletRequest(""GET"", ""/"");         request.addHeader(""Host"", ""[""+ipv6+""]"");         request.setServerName(""[""+ipv6+""]"");         String urlString = request.getRequestURL().toString();         System.out.println(""#URL: \"""" + urlString+""\"""");         // The URL should look like: ""http://[::ffff:abcd:abcd]/""         try {             java.net.URL url = new java.net.URL(urlString);         } catch (java.net.MalformedURLException e) {             assertEquals(e, null);         }     } ```","closed","type: regression,","jusmaki","2020-04-16T10:19:39Z","2020-04-17T13:02:32Z"
"","25172","Missing reference documentation for WebSocketScope","**Affects:** 5,2,6.RELEASE  --- Didn't find any reference documentation about defining a WebSocketScope that mentioned at https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other","closed","in: web,","tamaro-skaljic","2020-06-01T19:07:33Z","2021-11-29T17:38:45Z"
"","24901","Request Mapping url with path variable matching to handler is expensive","**Affects:** 4.3.x and 5.x  ---  When request mapping URLs have path variables (e.g. /api/fetchbyid/{id}) and if a component has thousands of request mapping, Spring handler matching logic loop over all request mappings in the component. Although Spring handler logic breaks loop on first match (rightfully so), it can be pretty costly operation if the incoming url is at the bottom of natural ordering (e.g. /api/z/fetchbyid/{id}).  Due to this, there is atleast 20 to 30% cost added to rest calls with path variables  Although path variable based match has to be dynamic, logic to match request mapping can be improved by maintaining static part of the request mapping url in a lookup map. This is explained below  Say there are 26 urls mappings in  a component as shown below  /api/a/fetchbyid/{id} /api/b/fetchbyid/{id} …….. /api/z/fetchbyid/{id}  Current logic loops over all 26 mappings to identify the handler method. Instead a partial match url  Map can be maintained which can store mapping for the keys (/api/a/fetchbyid, /api/b/fetchbyid, /api/z/fetchbyid), so when a incoming URL matches the partial keys, use those mappings to identify the actual match. in the above example, it would be 1 URL mapping (/api/z/fetchbyid) to match, instead of 26. Partial lookup url map keys can be identified by chopping first occurrence of path variable and store the static part of the url as key in the new lookup Map.","closed","status: superseded,","viswaramamoorthy","2020-04-13T18:19:09Z","2020-04-20T16:33:41Z"
"","25589","Add method for `INSERT INTO` w/o `UPDATE` to JpaRepository","**Affects:** 3.3.3.RELEASE  Currently, Spring Data JPA Repositories do not provide a method which corresponds to the single statement `this.entityManager.persist(entity)`. There is the method `save(entity)`, but it requires two database queries to insert an entity. Moreover, it updates an entity, if it is already in the database. We have a requirement that the insert should fail if the row is already in the database. In order to achieve this behavior, we do the following:  1. We provide a fragment repository for the new insert(entity) method. 2. We provide an implementation of the fragment repository. The insert-method uses the single line mentioned above: `this.entityManager.persist(entity)`. 3. We add the fragment repository interface from 1.) to the repository of our entity.  Since we have tens of different repositories, we had to add the fragment repository interface to many repositories---for simple, generic, often used feature: an `INSERT INTO`.  So, I propose to add this method to the JpaRepository.","closed","for: external-project,","ChristianWulf","2020-08-14T14:42:24Z","2020-08-16T13:55:35Z"
"","25819","MultipartFile[] required controller param, not throwing exception","**Affects:** 2.3.1.RELEASE  ---  Hello,   I'm working with the following controller mapping:  ```java @PostMapping(""/upload-bag-picture"") public ResponseEntity uploadBagPicture (@RequestParam(""bagPictures"") MultipartFile[] bagPictures, @RequestParam Long bagId) { /* ... */ } ```  As you can see, it's supposed to receive an array of MultipartFiles.  I noticed that when sending the request from a Rest client, no exception is being thrown when the files parameter name is different from the one set into the controller:   This request will return 200 OK without any exception: ![immagine](https://user-images.githubusercontent.com/12503478/94290292-494acd80-ff5a-11ea-8d43-35610888b6a5.png)  This instead is processed partially (one file has the right name): ![immagine](https://user-images.githubusercontent.com/12503478/94290186-26b8b480-ff5a-11ea-9a75-13403bc8ffcd.png)  I don't know if this is supposed to translate into an exception, but from what I saw until now, if a parameter is required, then even if only one is missing then the request should be intercepted before entering into the method body.   In case this is normal, I will close the issue. Thanks!","closed","type: enhancement,","funder7","2020-09-25T16:13:01Z","2020-10-12T16:07:36Z"
"","24956","Index is not created in mongodb using spring-boot-data-mongodb with reactivestreams","**Affects:** 2.3.0.M4  The issue I'm facing is related to Index creation, both with annotation and code.  I've tried to use `@Index` and also  `@CompoundIndexes` in my `@Document` class. Neither of those created the expected indexs, either with unique false or true. After that, I've tried to create the index myself using:  ```java Document doc = new Document(); doc.put(""example"", 1); doc.put(""example2"", 1);  CompoundIndexDefinition index = new CompoundIndexDefinition(doc);  mongoOps   .indexOps(ExampleDoc.class)   .ensureIndex(index); ```  The result was the same, no index created other then id: ``` [     2,     {         ""_id"" : 1     },     ""_id_"",     ""test.exampleDoc"" ] ``` I've created the project using initializer, some relevant dependencies:  spring-aop-5.2.5.RELEASE.jar   spring-boot-data-mongodb-3.0.0.RC1 **mongodb-driver-reactivestreams-4.0.1.jar** **mongodb-driver-core-4.0.1.jar** Why do we need both?!","closed","for: external-project,","GoncaloPT","2020-04-22T13:34:27Z","2020-04-24T07:40:27Z"
"","25397","StreamingResponseBody OutputStream is instantly closed","**Affects:** 2.1.8-RELEASE  Hey  I've set up a ThreadPoolTaskExecutor to be able to stream a big bunch of images asynchronously.  While only testing the endpoint returning a ResponseEntity, I decided to just stream up some bytes from a string: `StreamingResponseBody body = outputStream -> {     outputStream.write(""Test"".getBytes()); };`  However, the outputStream.write fails with an exception that the outputStream is already closed: `java.io.IOException: Stream already closed`  The OutputStream implementation is [CompressingServletOutputStream](https://github.com/ziplet/ziplet/blob/master/src/main/java/com/github/ziplet/filter/compression/CompressingServletOutputStream.java)  This code snippet is only executed once, and using a debugger I can indeed see that the OutputStream has ""closed = true"" as soon as it is created.  I have a feeling this has to be a bug in some functionality - I just can't see where, or what causes the stream to close.","closed","for: external-project,","Peldan","2020-07-16T07:07:05Z","2020-07-20T08:05:41Z"
"","25048","Can't handle SockJsMessageDeliveryException","**Affects:** 2.1.3.RELEASE  Hi, I can't handle SockJsMessageDeliveryException in my Spring app. Spring boot version: 2.1.3.RELEASE  releated stackoverflow question  https://stackoverflow.com/questions/61204651/how-can-i-handle-sockjsmessagedeliveryexception-in-spring-app  I tried: ```java @MessageExceptionHandler({SockJsMessageDeliveryException.class}) public void handle(SockJsMessageDeliveryException e) {     log.error(""Handled websocket exception: "" + e.getClass().getSimpleName()); } ``` and also:  ```java public class SilentErrorSimpMessagingTemplate extends SimpMessagingTemplate {     private final SimpMessagingTemplate simpMessagingTemplate;      SilentErrorSimpMessagingTemplate(SimpMessagingTemplate simpMessagingTemplate) {         super(simpMessagingTemplate.getMessageChannel());         simpMessagingTemplate.setMessageConverter(new MappingJackson2MessageConverter());         this.simpMessagingTemplate = simpMessagingTemplate;     }      @Override     public void convertAndSendToUser(@NotNull String user, @NotNull String destination, @NotNull Object payload) throws MessagingException {         try {             simpMessagingTemplate.convertAndSendToUser(user, destination, payload);         } catch (SockJsMessageDeliveryException e) {             log.error(""Socket send error: "" + e.getClass().getSimpleName());         }     } } ```","closed","status: duplicate,","okraskat","2020-05-11T12:39:40Z","2020-05-18T13:13:25Z"
"","25103","ResponseBodyAdvice cannot change the selected HttpMessageConverter","**Affects:**  spring-webmvc-5.1.2.RELEASE   1、There is a controller's return type is String in the controllers。 2、Add the @ControllerAdvice to change the response type of all controllers。 3、The Spring-framework will chose the StringHttpMessageConverter to convert the response body，and got an error。 ```java //the error code: GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? 						(GenericHttpMessageConverter) converter : null); 				if (genericConverter != null ? 						((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : 						converter.canWrite(valueType, selectedMediaType)) {            //使用了StringHttpMessageConverter           //调用advice的相关方法，@ControllerAdvice 返回对象被修改。 					body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, 							(Class>) converter.getClass(), 							inputMessage, outputMessage); 					if (body != null) { 						Object theBody = body; 						LogFormatUtils.traceDebug(logger, traceOn -> 								""Writing ["" + LogFormatUtils.formatValue(theBody, traceOn) + ""]""); 						addContentDispositionHeader(inputMessage, outputMessage); 						if (genericConverter != null) { 							genericConverter.write(body, targetType, selectedMediaType, outputMessage); 						} ```   ```  error stack: java.lang.ClassCastException: classname cannot be cast to java.lang.String         at org.springframework.http.converter.StringHttpMessageConverter.getContentLength(StringHttpMessageConverter.java:43) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]         at org.springframework.http.converter.AbstractHttpMessageConverter.addDefaultHeaders(AbstractHttpMessageConverter.java:260) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]         at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:211) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:292) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:180) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] ```","closed","for: stackoverflow,","jiangwh","2020-05-19T11:23:32Z","2021-03-02T14:46:03Z"
"","25076","Jackson message converters and codecs do not respect character encoding in canRead/canWrite","**Affects:**  org.springframework:spring-web:5.1.15.RELEASE  --- XML webservices seem to be limited to unicode encodings. Using jackson-dataformat-xml 2.9.8 for a webservice which produces ""text/xml;charset=ISO-8859-1"" outputs utf-8.  The problem might be located in AbstractJackson2HttpMessageConverter: ```` ... protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {     MediaType contentType = outputMessage.getHeaders().getContentType();     JsonEncoding encoding = getJsonEncoding(contentType);     JsonGenerator generator = this.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding); ... ```` JsonEncoding only provides unicode. A workaround would be to override the whole method but it is quite lenghty.  I made a very small reproducer: https://github.com/saimonsez/spring-jackson-xml-encoding-problem","closed","type: bug,","saimonsez","2020-05-14T07:38:04Z","2020-08-06T03:38:55Z"
"","25380","Improve JavaDoc for ConfigurableApplicationContext.refresh()","**Affects:**  all versions  ConfigurableApplicationContext.refresh()： ``` 	/** 	 * Load or refresh the persistent representation of the configuration, 	 * which might an XML file, properties file, or relational database schema. 	 * As this is a startup method, it should destroy already created singletons 	 * if it fails, to avoid dangling resources. In other words, after invocation 	 * of that method, either all or no singletons at all should be instantiated. 	 * @throws BeansException if the bean factory could not be initialized 	 * @throws IllegalStateException if already initialized and multiple refresh 	 * attempts are not supported 	 */ 	void refresh() throws BeansException, IllegalStateException; ```  I found this ""which might an XML file"" weired, shouldn't it be ""which **might be** an XML file"" ?   ---","closed","in: core,","MorrisZ","2020-07-10T01:21:51Z","2020-07-10T13:42:07Z"
"","24843","Parameter binding in Spring MVC results in ConcurrentModificationException","**Affects:**  `spring-web` version is 5.1.6","closed","status: invalid,","sdd1989","2020-04-02T06:39:16Z","2020-04-22T11:10:32Z"
"","25613","Potential integer overflow in ExecutorConfigurationSupport.setAwaitTerminationSeconds(int) and AbstractResourceBasedMessageSource.setCacheSeconds(int)","**Affects:**  5.2.8.RELEASE There is **a small** bug in the class  `org.springframework.scheduling.concurrent.ExecutorConfigurationSupport` in the method : ```java  public void setAwaitTerminationSeconds(int awaitTerminationSeconds) { 		this.awaitTerminationMillis = awaitTerminationSeconds * 1000; } ```  When the input parameter `awaitTerminationSeconds` is bigger then `Integer.MAX_VALUE/1000` the value asigned to `long this.awaitTerminationMillis` can even be **negative** !  I recommend changing the `1000` to the `1000l` long version as below ```java  public void setAwaitTerminationSeconds(int awaitTerminationSeconds) { 		this.awaitTerminationMillis = awaitTerminationSeconds * 1000l; } ```","closed","in: core,","TomaszPierzchala","2020-08-19T14:01:22Z","2020-08-27T13:00:44Z"
"","25717","PropertiesLoaderSupport should ignore socket/connect exceptions as well","**Affects:**  5.2.3-RELEASE I am running on windows, trying to load properties from a shared network folder like _\\\\remotehost\sharedfolder\common.properties_, with `ignoreResourceNotFound` is set to `true`. If the property file is there, everything works, but in case the file is missing, loading fails with this somehow misleading exception:      java.net.ConnectException: Connection refused: connect 	at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method) ~[na:1.8.0_151] 	at java.net.DualStackPlainSocketImpl.socketConnect(Unknown Source) ~[na:1.8.0_151] 	at java.net.AbstractPlainSocketImpl.doConnect(Unknown Source) ~[na:1.8.0_151] 	at java.net.AbstractPlainSocketImpl.connectToAddress(Unknown Source) ~[na:1.8.0_151] 	at java.net.AbstractPlainSocketImpl.connect(Unknown Source) ~[na:1.8.0_151] 	at java.net.PlainSocketImpl.connect(Unknown Source) ~[na:1.8.0_151] 	at java.net.Socket.connect(Unknown Source) ~[na:1.8.0_151] 	at sun.net.ftp.impl.FtpClient.doConnect(Unknown Source) ~[na:1.8.0_151] 	at sun.net.ftp.impl.FtpClient.tryConnect(Unknown Source) ~[na:1.8.0_151] 	at sun.net.ftp.impl.FtpClient.connect(Unknown Source) ~[na:1.8.0_151] 	at sun.net.ftp.impl.FtpClient.connect(Unknown Source) ~[na:1.8.0_151] 	at sun.net.www.protocol.ftp.FtpURLConnection.connect(Unknown Source) ~[na:1.8.0_151] 	at sun.net.www.protocol.ftp.FtpURLConnection.getInputStream(Unknown Source) ~[na:1.8.0_151] 	at org.springframework.core.io.UrlResource.getInputStream(UrlResource.java:173) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.core.io.support.EncodedResource.getInputStream(EncodedResource.java:159) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.core.io.support.PropertiesLoaderUtils.fillProperties(PropertiesLoaderUtils.java:99) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE] 	at org.springframework.core.io.support.PropertiesLoaderSupport.loadProperties(PropertiesLoaderSupport.java:181) ~[spring-core-5.2.3.RELEASE.jar:5.2.3.RELEASE]  This error is very similar for example to this one in [bitbucket issue](https://community.atlassian.com/t5/Bitbucket-questions/Cannot-start-bitbucket-server-SpringMVC-dispatcher/qaq-p/1418379). My simplistic view is, that `ConnectException` could be ignored, but I am not sure, what this change could break.   If adding `ConnectException` to the ignore list is not possible, `PropertiesLoaderSupport` could be made more flexible so we could override its behaviour. Now, all the important fields like `locations` are not accessible to an ancestor class as well as `PropertiesLoaderUtils.fillProperties()` is not visible. If the loader would like to be super user friendly, it would also allow somehow to set timeout on `URLConnection` through `UrlResource.getInputStream()`.","closed","type: enhancement,","vinov","2020-09-07T06:57:36Z","2020-09-07T16:04:47Z"
"","25008","@Repository and custom scheduler switch mechanism problem when using reactor","**Affects:**  5.2.0.RELEASE  `org.springframework.aop.framework.ReflectiveMethodInvocation` will crash suddenly when `@Respository` is used on Bean and invocation of method is made on another scheduler. In this case switching to another scheduler is done by custom AOP mechanism:  [Link](https://github.com/marcinsobejko/spring-data-problem) to github project that shows this problem.  Run `com.sobejko.marcin.springdata.problem.ReactorAopTestServiceTest#test`","open","in: core,","marcinsobejko","2020-05-04T12:50:36Z","2021-11-10T12:04:21Z"
"","25672","Access-Control-Allow-Origin:""*"" added randomly","**Affects:**  2.3.3.RELEASE  I've been seeing this effect since last night when I added this filter: ``` class SecurityFilter : HttpFilter(){     override fun doFilter(request: HttpServletRequest, response: HttpServletResponse, chain: FilterChain) {         if(request.method!=RequestMethod.GET.name){             val token=request.getHeader(""Auth"")             if(token!=null && token==""---SOME_VALUE---"")                 super.doFilter(request, response, chain)             return         }         super.doFilter(request, response, chain)     } } ``` And added it as a bean in configuration class: ``` @Bean fun securityFilter(): FilterRegistrationBean{ 		val bean=FilterRegistrationBean() 		bean.filter= SecurityFilter() 		bean.order= Ordered.LOWEST_PRECEDENCE-100 //		bean.add 		bean.addUrlPatterns(""---SOME PATTERNS---"") 		return bean } ```  Before this I had these following CORS mappings: ``` @Bean fun corsConfigurer(): WebMvcConfigurer { 	return object : WebMvcConfigurer { 		override fun addCorsMappings(registry: CorsRegistry) { 			registry.addMapping(""/**"") 					.allowedMethods(""GET"", ""POST"", ""PUT"", ""DELETE"") 					.allowedOrigins(""*"") 					.allowedHeaders(""*"") 		} 	} } ```  1. After adding this filter I started getting responses with `No 'Access-Control-Allow-Origin' header is present on the requested resource.` I dug up further and tried to find some problem with the `SecurityFilter` but with no clue, I just refreshed it the page, and the error was gone. But after some time while testing it came up again. Digging up further I found that it's creating a pattern that when the site loads for the first time it doesn't find the `Access-Control-Allow-Origin` header and hence no response is fetched but after the first call it worked just fine.   2. That's not all as I am also using `spring-boot-starter-data-rest` and have also configured CORS for this as well: ``` override fun configureRepositoryRestConfiguration(config: RepositoryRestConfiguration) { 		config.corsRegistry 				.addMapping(""/**"") 				.allowedMethods(""GET"", ""POST"", ""PUT"", ""DELETE"") 				.allowedOrigins(""*"") 				.allowedHeaders(""*"") 	} ``` While the 1st resolves after the first invocation, the `RepositoryRestConfiguration` still doesn't apply and may/may not work (most of the time does not) as there is some race condition (either at the server startup/initialization or during invocation).   **EDIT** 1st is also working randomly I test it and it breaks upon server restarts and same can be seen with the 2nd as well.","closed","status: invalid,","Guneetgstar","2020-09-01T06:47:19Z","2020-09-01T07:43:54Z"
"","25178","WebFlux blocks when unmarshaling a Kotlin object that contains a map","**Affects:**  2.3.0.RELEASE  When passing a Kotlin data class with a property that has a type of `Map` to `ServerResponse.BodyBuilder#bodyValue` BlockHound detects blocking code in `org.springframework.http.codec.json.AbstractJackson2Encoder.canEncode`.   Example repo: https://github.com/lxdraw/webflux-blocking  Results in: ```2020-06-02 15:04:32.911 ERROR 43986 --- [ctor-http-nio-3] a.w.r.e.AbstractErrorWebExceptionHandler : [4e2762e3-1]  500 Server Error for HTTP GET ""/map""  reactor.blockhound.BlockingOperationError: Blocking call! java.io.RandomAccessFile#readBytes 	at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[na:na] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ HTTP GET ""/map"" [ExceptionHandlingWebHandler] Stack trace: 		at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[na:na] 		at java.base/java.io.RandomAccessFile.read(RandomAccessFile.java:406) ~[na:na] 		at java.base/java.io.RandomAccessFile.readFully(RandomAccessFile.java:470) ~[na:na] 		at java.base/java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1304) ~[na:na] 		at java.base/java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:998) ~[na:na] 		at java.base/java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:1013) ~[na:na] 		at java.base/java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:468) ~[na:na] 		at java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) ~[na:na] 		at java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:123) ~[na:na] 		at java.base/java.io.FilterInputStream.read(FilterInputStream.java:83) ~[na:na] 		at java.base/java.io.DataInputStream.readInt(DataInputStream.java:392) ~[na:na] 		at kotlin.reflect.jvm.internal.impl.metadata.builtins.BuiltInsBinaryVersion$Companion.readFrom(BuiltInsBinaryVersion.kt:29) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.builtins.BuiltInsPackageFragmentImpl$Companion.create(BuiltInsPackageFragmentImpl.kt:38) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.builtins.jvm.JvmBuiltInsPackageFragmentProvider.findPackage(JvmBuiltInsPackageFragmentProvider.kt:58) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.AbstractDeserializedPackageFragmentProvider$fragments$1.invoke(AbstractDeserializedPackageFragmentProvider.kt:34) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.AbstractDeserializedPackageFragmentProvider$fragments$1.invoke(AbstractDeserializedPackageFragmentProvider.kt:26) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$MapBasedMemoizedFunction.invoke(LockBasedStorageManager.java:512) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.AbstractDeserializedPackageFragmentProvider.getPackageFragments(AbstractDeserializedPackageFragmentProvider.kt:41) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.CompositePackageFragmentProvider.getPackageFragments(CompositePackageFragmentProvider.kt:31) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.CompositePackageFragmentProvider.getPackageFragments(CompositePackageFragmentProvider.kt:31) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.LazyPackageViewDescriptorImpl$fragments$2.invoke(LazyPackageViewDescriptorImpl.kt:37) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.LazyPackageViewDescriptorImpl$fragments$2.invoke(LazyPackageViewDescriptorImpl.kt:30) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedLazyValue.invoke(LockBasedStorageManager.java:355) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedNotNullLazyValue.invoke(LockBasedStorageManager.java:474) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.StorageKt.getValue(storage.kt:42) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.LazyPackageViewDescriptorImpl.getFragments(LazyPackageViewDescriptorImpl.kt) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.LazyPackageViewDescriptorImpl$memberScope$1.invoke(LazyPackageViewDescriptorImpl.kt:41) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.impl.LazyPackageViewDescriptorImpl$memberScope$1.invoke(LazyPackageViewDescriptorImpl.kt:30) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedLazyValue.invoke(LockBasedStorageManager.java:355) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedNotNullLazyValue.invoke(LockBasedStorageManager.java:474) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.resolve.scopes.LazyScopeAdapter.getWorkerScope(LazyScopeAdapter.kt:23) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.resolve.scopes.AbstractScopeAdapter.getContributedClassifier(AbstractScopeAdapter.kt:44) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.FindClassInModuleKt.findClassifierAcrossModuleDependencies(findClassInModule.kt:25) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.descriptors.FindClassInModuleKt.findClassAcrossModuleDependencies(findClassInModule.kt:40) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer.computeClassDescriptor(TypeDeserializer.kt:221) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer.access$computeClassDescriptor(TypeDeserializer.kt:23) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer$classDescriptors$1.invoke(TypeDeserializer.kt:32) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer$classDescriptors$1.invoke(TypeDeserializer.kt:23) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$MapBasedMemoizedFunction.invoke(LockBasedStorageManager.java:512) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer.typeConstructor(TypeDeserializer.kt:113) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer.simpleType(TypeDeserializer.kt:75) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.TypeDeserializer.type(TypeDeserializer.kt:63) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.MemberDeserializer.valueParameters(MemberDeserializer.kt:417) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.MemberDeserializer.loadConstructor(MemberDeserializer.kt:342) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor.computePrimaryConstructor(DeserializedClassDescriptor.kt:122) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor.access$computePrimaryConstructor(DeserializedClassDescriptor.kt:34) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor$primaryConstructor$1.invoke(DeserializedClassDescriptor.kt:65) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor$primaryConstructor$1.invoke(DeserializedClassDescriptor.kt:34) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedLazyValue.invoke(LockBasedStorageManager.java:355) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor.getUnsubstitutedPrimaryConstructor(DeserializedClassDescriptor.kt:126) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor.computeConstructors(DeserializedClassDescriptor.kt:129) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor.access$computeConstructors(DeserializedClassDescriptor.kt:34) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor$constructors$1.invoke(DeserializedClassDescriptor.kt:66) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor$constructors$1.invoke(DeserializedClassDescriptor.kt:34) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedLazyValue.invoke(LockBasedStorageManager.java:355) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.storage.LockBasedStorageManager$LockBasedNotNullLazyValue.invoke(LockBasedStorageManager.java:474) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.impl.serialization.deserialization.descriptors.DeserializedClassDescriptor.getConstructors(DeserializedClassDescriptor.kt:137) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.KClassImpl.getConstructorDescriptors(KClassImpl.kt:200) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.KClassImpl$Data$constructors$2.invoke(KClassImpl.kt:91) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.KClassImpl$Data$constructors$2.invoke(KClassImpl.kt:44) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:92) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:31) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.KClassImpl$Data.getConstructors(KClassImpl.kt) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.internal.KClassImpl.getConstructors(KClassImpl.kt:235) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at kotlin.reflect.jvm.ReflectJvmMapping.getKotlinFunction(ReflectJvmMapping.kt:144) ~[kotlin-reflect-1.3.72.jar:1.3.72-release-468 (1.3.72)] 		at com.fasterxml.jackson.module.kotlin.ReflectionCache.kotlinFromJava(ReflectionCache.kt:44) ~[jackson-module-kotlin-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.module.kotlin.KotlinNamesAnnotationIntrospector$hasCreatorAnnotation$1.invoke(KotlinNamesAnnotationIntrospector.kt:64) ~[jackson-module-kotlin-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.module.kotlin.KotlinNamesAnnotationIntrospector$hasCreatorAnnotation$1.invoke(KotlinNamesAnnotationIntrospector.kt:22) ~[jackson-module-kotlin-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.module.kotlin.ReflectionCache.checkConstructorIsCreatorAnnotated(ReflectionCache.kt:46) ~[jackson-module-kotlin-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.module.kotlin.KotlinNamesAnnotationIntrospector.hasCreatorAnnotation(KotlinNamesAnnotationIntrospector.kt:62) ~[jackson-module-kotlin-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.AnnotationIntrospector.findCreatorAnnotation(AnnotationIntrospector.java:1306) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair.findCreatorAnnotation(AnnotationIntrospectorPair.java:821) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair.findCreatorAnnotation(AnnotationIntrospectorPair.java:821) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector._addCreatorParam(POJOPropertiesCollector.java:525) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector._addCreators(POJOPropertiesCollector.java:492) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector.collectAll(POJOPropertiesCollector.java:327) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector.getJsonValueAccessor(POJOPropertiesCollector.java:203) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.introspect.BasicBeanDescription.findJsonValueAccessor(BasicBeanDescription.java:252) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.ser.BasicSerializerFactory.findSerializerByAnnotations(BasicSerializerFactory.java:396) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.ser.BeanSerializerFactory._createSerializer2(BeanSerializerFactory.java:216) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.createSerializer(BeanSerializerFactory.java:165) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.SerializerProvider._createUntypedSerializer(SerializerProvider.java:1474) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer(SerializerProvider.java:1422) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.SerializerProvider._findExplicitUntypedSerializer(SerializerProvider.java:1391) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.hasSerializerFor(DefaultSerializerProvider.java:260) ~[jackson-databind-2.11.0.jar:2.11.0] 		at com.fasterxml.jackson.databind.ObjectMapper.canSerialize(ObjectMapper.java:3225) ~[jackson-databind-2.11.0.jar:2.11.0] 		at org.springframework.http.codec.json.AbstractJackson2Encoder.canEncode(AbstractJackson2Encoder.java:107) ~[spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.http.codec.EncoderHttpMessageWriter.canWrite(EncoderHttpMessageWriter.java:107) ~[spring-web-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.function.BodyInserters.lambda$writeWithMessageWriters$9(BodyInserters.java:377) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:176) ~[na:na] 		at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1631) ~[na:na] 		at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) ~[na:na] 		at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) ~[na:na] 		at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) ~[na:na] 		at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) ~[na:na] 		at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150) ~[na:na] 		at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na] 		at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:543) ~[na:na] 		at org.springframework.web.reactive.function.BodyInserters.writeWithMessageWriters(BodyInserters.java:378) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.function.BodyInserters.lambda$fromValue$1(BodyInserters.java:98) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.function.server.DefaultEntityResponseBuilder$DefaultEntityResponse.writeToInternal(DefaultEntityResponseBuilder.java:233) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.function.server.DefaultServerResponseBuilder$AbstractServerResponse.writeTo(DefaultServerResponseBuilder.java:351) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.function.server.support.ServerResponseResultHandler.handleResult(ServerResponseResultHandler.java:94) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.DispatcherHandler.handleResult(DispatcherHandler.java:169) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at org.springframework.web.reactive.DispatcherHandler.lambda$handle$2(DispatcherHandler.java:147) ~[spring-webflux-5.2.6.RELEASE.jar:5.2.6.RELEASE] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1755) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2317) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2125) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1999) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Mono.subscribe(Mono.java:4218) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Operators.complete(Operators.java:135) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:274) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:851) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:421) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:211) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:161) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Mono.subscribe(Mono.java:4218) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:441) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:211) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:161) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.Mono.subscribe(Mono.java:4218) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.3.5.RELEASE.jar:3.3.5.RELEASE] 		at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64) ~[reactor-netty-0.9.7.RELEASE.jar:0.9.7.RELEASE] 		at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:514) ~[reactor-netty-0.9.7.RELEASE.jar:0.9.7.RELEASE] 		at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:262) ~[reactor-netty-0.9.7.RELEASE.jar:0.9.7.RELEASE] 		at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:465) ~[reactor-netty-0.9.7.RELEASE.jar:0.9.7.RELEASE] 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:96) ~[reactor-netty-0.9.7.RELEASE.jar:0.9.7.RELEASE] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:170) ~[reactor-netty-0.9.7.RELEASE.jar:0.9.7.RELEASE] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.49.Final.jar:4.1.49.Final] 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.49.Final.jar:4.1.49.Final] 		at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]```","open","in: kotlin,","lxdraw","2020-06-02T20:21:18Z","2022-01-19T10:53:36Z"
"","25472","Return application/json response to WebClient request as a Flux","**Affects:**  Spring Webflux 5.2.7.RELEASE ---  This relates to how `WebClient` handles traditional `application/json` responses. From what I've seen, the entire response is always parsed into a Java object in memory and exposed as a `Mono`.  A very common case in web APIs is that the JSON response consists of a few basic fields followed by a list of ""records"". Consider for example the following Elasticsearch response to a search request:  ``` {   ""took"" : 796,   ""timed_out"" : false,   ""_shards"" : {     ""total"" : 335,     ""successful"" : 335,     ""skipped"" : 0,     ""failed"" : 0   },   ""hits"" : {     ""total"" : 176806640,     ""max_score"" : 1.0,     ""hits"" : [       {           ...       },       {           ...       },       ....     ]   } } ```  It would be very useful to be able to get the ""hits"" elements as a `Flux` as this would enable streaming processing of that list instead of having the entire response loaded in memory at once.  The following StackOverflow questions seem to be looking for something like this: - https://stackoverflow.com/questions/54148326/spring-webclient-parse-stream-very-large-json - https://stackoverflow.com/questions/60154848/is-it-possible-to-stream-nested-json-list  Sort of related: - https://stackoverflow.com/questions/54680001/spring-webflux-flux-behavior-with-non-streaming-application-json (deals with the reverse: writing an `application/json` response in a streaming fashion  I recall (but am struggling to find it now, it's been a while) that Spring Batch had an item reader for reading XML where you could pass it the name of an element that contained a list of records and it would read those records as items. That's kind of what I'm looking for here, but obviously in a web instead of a batch context and for JSON, not XML.  Obviously, if you're in control of the server side, you can amend it to be able to return `application/stream+json` responses, but the reality is that there are thousands of APIs out there that can't do that yet (but still can return sizeable responses at times).  This is less about the truly reactive concerns like back pressure and more about handling data as a stream instead of as an in-memory list, to facilitate scalability.   It seems technically possible. Jackson has a low-level API that can do streaming deserialization and it couldn't be that hard to wrap a `Flux` layer around that that retrieves items on demand. I would be happy to look into writing something like that, but in case something like that already exists, I don't want to reinvent the wheel (and then maybe this becomes a documentation issue instead of an enhancement suggestion).  If this is not the right platform, let me know. Between StackOverflow and GitHub issues, this seemed the more appropriate.","closed","status: duplicate,","fransflippo","2020-07-24T11:06:51Z","2020-10-06T08:08:19Z"
"","25479","MimeType.checkParameters() high processing time","**Affects:**  Spring Boot 2.0.1 RELEASE, Spring Framework 5.0.5 RELEASE  **Issue Description:**  In a highly concurrent environment(Average 20K transaction per minute) it was observed that 100% of the processing time is being taken by `MimeType.checkParameters()`  Attached screenshot of the dynatrace   Wondering if this is something related to #25043 / #24886.   Any solution/suggestion would be helpful    ---","closed","status: invalid,","arajitsamanta","2020-07-27T22:11:33Z","2020-12-04T00:26:26Z"
"","25640","websocket stomp Failed to handle GenericMessage No header accessor","**Affects:**  org.springframework.boot:spring-boot-starter-websocket:jar:2.3.1.RELEASE org.springframework:spring-messaging:jar:5.2.7.RELEASE org.springframework:spring-websocket:jar:5.2.7.RELEASE  Getting exception ``` Exception in thread ""clientInboundChannel-4"" org.springframework.messaging.MessageDeliveryException: Failed to handle GenericMessage [payload=byte[0], headers={simpMessageType=MESSAGE, stompCommand=SEND, nativeHeaders={destination=[/queue/test]}, simpSessionAttributes={}, simpHeartbeat=[J@3e20fadf, opentracing.span=5dbdcde08b48bc8d:5dbdcde08b48bc8d:0:0 - /queue/test, id=367590c7-69c9-62ad-514f-14219165de8a, simpSessionId=22add5ae-a93c-bb44-bf2a-04b7529c73df, simpDestination=/queue/test, timestamp=1598333820847}] to org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask@61891fa8 in StompBrokerRelay[ReactorNettyTcpClient[reactor.netty.tcp.TcpClientDoOn@3daf0663]]; nested exception is java.lang.IllegalStateException: No header accessor (not using the SimpMessagingTemplate?): GenericMessage [payload=byte[0], headers={simpMessageType=MESSAGE, stompCommand=SEND, nativeHeaders={destination=[/queue/test]}, simpSessionAttributes={}, simpHeartbeat=[J@3e20fadf, opentracing.span=5dbdcde08b48bc8d:5dbdcde08b48bc8d:0:0 - /queue/test, id=367590c7-69c9-62ad-514f-14219165de8a, simpSessionId=22add5ae-a93c-bb44-bf2a-04b7529c73df, simpDestination=/queue/test, timestamp=1598333820847}], failedMessage=GenericMessage [payload=byte[0], headers={simpMessageType=MESSAGE, stompCommand=SEND, nativeHeaders={destination=[/queue/test]}, simpSessionAttributes={}, simpHeartbeat=[J@3e20fadf, opentracing.span=5dbdcde08b48bc8d:5dbdcde08b48bc8d:0:0 - /queue/test, id=367590c7-69c9-62ad-514f-14219165de8a, simpSessionId=22add5ae-a93c-bb44-bf2a-04b7529c73df, simpDestination=/queue/test, timestamp=1598333820847}]         at org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:153)         at io.opentracing.contrib.concurrent.TracedRunnable.run(TracedRunnable.java:30)         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)         at java.base/java.lang.Thread.run(Thread.java:834) Caused by: java.lang.IllegalStateException: No header accessor (not using the SimpMessagingTemplate?): GenericMessage [payload=byte[0], headers={simpMessageType=MESSAGE, stompCommand=SEND, nativeHeaders={destination=[/queue/test]}, simpSessionAttributes={}, simpHeartbeat=[J@3e20fadf, opentracing.span=5dbdcde08b48bc8d:5dbdcde08b48bc8d:0:0 - /queue/test, id=367590c7-69c9-62ad-514f-14219165de8a, simpSessionId=22add5ae-a93c-bb44-bf2a-04b7529c73df, simpDestination=/queue/test, timestamp=1598333820847}]         at org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.handleMessageInternal(StompBrokerRelayMessageHandler.java:499)         at org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler.handleMessage(AbstractBrokerMessageHandler.java:256)         at org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:144)         ... 4 more ```  stomp configured with  ``` @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {  	 	@Override 	public void configureMessageBroker(MessageBrokerRegistry config) {  		String rabbitMqHost = Environment.getProperty(""rabbitmq.host"", ""localhost""); 		int rabbitMqPort = Environment.getIntProperty(""rabbitmq.port"", 61613); 		String rabbitMqUsername = Environment.getProperty(""rabbitmq.username"", ""guest""); 		String rabbitMqPassword = Environment.getProperty(""rabbitmq.password"", ""guest""); 		 		config.setUserDestinationPrefix(""/user"") 			.setApplicationDestinationPrefixes(""/app"", ""/user"") 			.enableStompBrokerRelay(""/topic"", ""/queue"", ""/temp-queue/"") 			.setRelayHost(rabbitMqHost) 			.setRelayPort(rabbitMqPort) 			.setClientLogin(rabbitMqUsername) 			.setClientPasscode(rabbitMqPassword); 	}  	@Override 	public void registerStompEndpoints(StompEndpointRegistry registry) { 		registry     .addEndpoint(""/stomp"")     .setAllowedOrigins(""*"");   }     } ```  Client code  ``` const { Client } = require(""@stomp/stompjs"");  let client = new Client({   webSocketFactory: () => new WebSocket(`wss://server-address/stomp`),   debug: (msg) => {     console.log(new Date(), msg);   } });  client.onConnect = () => {   client.publish({     destination: ""/queue/test"",     headers: {}   }); };  client.activate();  ```","closed","for: external-project,","cameronbraid","2020-08-25T05:46:32Z","2020-09-21T19:23:36Z"
"","25309","AbstractBeanFactory#markBeanAsCreated might have some logical problems","**AbstractBeanFactory#markBeanAsCreated** is that  ``` 	protected void markBeanAsCreated(String beanName) { 		if (!this.alreadyCreated.contains(beanName)) { 			synchronized (this.mergedBeanDefinitions) { 				if (!this.alreadyCreated.contains(beanName)) { 					// Let the bean definition get re-merged now that we're actually creating 					// the bean... just in case some of its metadata changed in the meantime. 					clearMergedBeanDefinition(beanName); 					this.alreadyCreated.add(beanName); 				} 			} 		} 	} ``` I think **MergedBeanDefinitions** have no relationship to **alreadyCreated**,so I think I should change the code to look like this: ``` protected void markBeanAsCreated(String beanName) { 		synchronized (this.alreadyCreated) { 				if (!this.alreadyCreated.contains(beanName)) { 					// Let the bean definition get re-merged now that we're actually creating 					// the bean... just in case some of its metadata changed in the meantime. 					clearMergedBeanDefinition(beanName); 					this.alreadyCreated.add(beanName); 				} 			} 		 	} ``` If I understand correctly, I would like to submit a PR,Thanks.","closed","","lifejwang11","2020-06-24T06:01:27Z","2020-06-24T07:46:59Z"
"","25360","FAILURE: Build failed with an exception.","* What went wrong: A problem occurred configuring root project 'spring'. > Could not resolve all artifacts for configuration ':classpath'.    > Could not download xstream.jar (com.thoughtworks.xstream:xstream:1.4.10)       > Could not get resource 'https://plugins.gradle.org/m2/com/thoughtworks/xstream/xstream/1.4.10/xstream-1.4.10.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/a1587f35fa617513607c86ec9e6e4de5eb8acdf9a3a6d7f7458f8a8c40b00858?response-content-disposition=attachment%3Bfilename%3D%22xstream-1.4.10.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvYTE1ODdmMzVmYTYxNzUxMzYwN2M4NmVjOWU2ZTRkZTVlYjhhY2RmOWEzYTZkN2Y3NDU4ZjhhOGM0MGIwMDg1OD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMnhzdHJlYW0tMS40LjEwLmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjI2OX0sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=l7QnqIHJ1wqj3VX8aKCfKMcwLJAjZNr1ph7I7hykQT0TESUaxxUQARplYLV3bhty4vyx2EAdkfu-2qinR9Mjk3KFJzHWZ9~m8GjYZmzRwoio5TY8HRnsOWEjPjRweCJcc4JMGP0wm1eraH22Kzo8vVhupLwBg~9e3ZwjApts6ma8ucJj8Y9PYG5Pkkgt~qs5O3W2p2dKd-0RpfpzqhplKoIFFS5T97N-4GL867GEYz9VRvJgOjxZHNIUTYdaGBejaZ~qZOAsKkueMDdVg3ZhnTPUojylZ4Rp-CkpxLoOQaysMIXQ1PUP-RD6mFnMLZ1EIb1GTKxcXsI29GjX0Hsf1Q__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Connection reset    > Could not download kotlin-daemon-embeddable.jar (org.jetbrains.kotlin:kotlin-daemon-embeddable:1.3.70)       > Could not get resource 'https://plugins.gradle.org/m2/org/jetbrains/kotlin/kotlin-daemon-embeddable/1.3.70/kotlin-daemon-embeddable-1.3.70.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/ef443a83c57e59c9fa8945ddf74b357f27d822f709d681a837e1b248a1a1e3bf?response-content-disposition=attachment%3Bfilename%3D%22kotlin-daemon-embeddable-1.3.70.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZWY0NDNhODNjNTdlNTljOWZhODk0NWRkZjc0YjM1N2YyN2Q4MjJmNzA5ZDY4MWE4MzdlMWIyNDhhMWExZTNiZj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmtvdGxpbi1kYWVtb24tZW1iZWRkYWJsZS0xLjMuNzAuamFyJTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTk0MDMyMzA4fSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&Signature=q36~t0X08HQnPICrQQJ9Sg0w0Gjx31lP~cVHrQPhikiqkZpRIATbmT0ZQDNYwc3~fZfTiC3CrDxtNAf2OxkTO3Li6Lvg1v~0w9kV0lU6nrPAGhx2764FQHwSWu3wY8SILRUskyPV9mi6vKiH7EoeVwD2W~Kyd7Q-V0oB~TZjNAqUXz9BXEQ4hh4g6sQHEGklMhHmmsoBggxEhk8~4-o9YwO0v12wqsz-XiPK4Wsi2YomN~gLvau8wXU3~zQKy9l8bsV5xSfdx1m5sD9YdaR2aAEnRFI7URphStVODTm6g9j~c2qr1hBZy4vWuwW3BsX0P2qh2JuGMY0MHiv0ufMuhw__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download trove4j.jar (org.jetbrains.intellij.deps:trove4j:1.0.20181211)       > Could not get resource 'https://plugins.gradle.org/m2/org/jetbrains/intellij/deps/trove4j/1.0.20181211/trove4j-1.0.20181211.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/affb7c85a3c87bdcf69ff1dbb84de11f63dc931293934bc08cd7ab18de083601?response-content-disposition=attachment%3Bfilename%3D%22trove4j-1.0.20181211.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvYWZmYjdjODVhM2M4N2JkY2Y2OWZmMWRiYjg0ZGUxMWY2M2RjOTMxMjkzOTM0YmMwOGNkN2FiMThkZTA4MzYwMT9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMnRyb3ZlNGotMS4wLjIwMTgxMjExLmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjQ5N30sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=VYSpo6WyTNNgYmsUgY4NIxRXs~cmpuw~tSradOWYwgcUTLqp7iIvXL4bfkozXMjSVmutVGUOLh~5VxYKB5qXRTGvlkz3wLu6u9f5~E~72f8MOTwOEb5FXz78~ZehCvgHc9gpSeMes22wTBlHFjibWVtuwmFhIBXmAZwz0UV2PyjYJZfaZ~nQ0VaVG0~fPle0Mx1osfxk~Pf2HUMOEHArrNk0lZzdD7oI9urItZqsCqd5tm5f9xQDtjT72-tXNxvFA5Fyxwv55xmC-3eDQjmmaD7XrHqZye0RMGKWhimMaZuYsB0rrP62aFpAdxGGqPzjFuxwswb0hNfY2a7x-4LYvQ__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download kotlin-build-common.jar (org.jetbrains.kotlin:kotlin-build-common:1.3.70)       > Could not get resource 'https://plugins.gradle.org/m2/org/jetbrains/kotlin/kotlin-build-common/1.3.70/kotlin-build-common-1.3.70.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/221099f3aa22ec1e3ce1593a6778b27e54172c2ff5ef5e38e000ec967204e63a?response-content-disposition=attachment%3Bfilename%3D%22kotlin-build-common-1.3.70.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvMjIxMDk5ZjNhYTIyZWMxZTNjZTE1OTNhNjc3OGIyN2U1NDE3MmMyZmY1ZWY1ZTM4ZTAwMGVjOTY3MjA0ZTYzYT9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmtvdGxpbi1idWlsZC1jb21tb24tMS4zLjcwLmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjEyOX0sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=dBoprXA~P7FJZ-A5xayzWu2qLwOf6WAKHdPASIY7iWMpcNlik67KplVU7btwPGeXPfh07UyyTsO8ny5SI9fco6D2osrRwfaIxl~m7CerTzX13rrThNd13AbiMT5Roi4rnRluk8Qx74pnrc5H1E6LSYjl6cKv29MQZRJUC4Y-aQwA4f1RAQbD4aQtDY8~-9mhyZ2xGkRqT61wabFULeoJvBCDO~wzzZCfbDW7YOhRndjucnnuBCziTQYOMWgquOnbuVl4~cTx0dWirfQSAMLRT~W24M91Hetuog5WZG0RbBOzJYF3CSZ9t0kVFcUTQ8UA4s6lgBnDFedRkcPYiopQFA__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download kotlinx-coroutines-core.jar (org.jetbrains.kotlinx:kotlinx-coroutines-core:1.2.1)       > Could not get resource 'https://plugins.gradle.org/m2/org/jetbrains/kotlinx/kotlinx-coroutines-core/1.2.1/kotlinx-coroutines-core-1.2.1.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/7177ed4629704537e0252537629886f5409526ecd041d8d8e308e20624b14394?response-content-disposition=attachment%3Bfilename%3D%22kotlinx-coroutines-core-1.2.1.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvNzE3N2VkNDYyOTcwNDUzN2UwMjUyNTM3NjI5ODg2ZjU0MDk1MjZlY2QwNDFkOGQ4ZTMwOGUyMDYyNGIxNDM5ND9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmtvdGxpbngtY29yb3V0aW5lcy1jb3JlLTEuMi4xLmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjUwMH0sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=SaDrOrSsdMgSQdqfhJi4~CTSRk7gSFCUzqsABl69dezqX7FYAA7l0GZdK7qjP1SPCrQdF2QXwzPOYgwIs0WDwKgQ9nS1GDQkxY~sSpLatVD6aLnmhZACiF6GF0Q1BvaFv2auR3E3lq-ZRUtJbsMEooq2xxHVOdH4X56WIwfPUfZyb1HdoyYe8sj2oIM9De2Ax29vbUlb2sfIfWVEdKp2NsgQFhRE4z9hiCUb-V-X1tl6eQwY5ocPGyyh0CjZiYBprMR689Qbt67dqY3wy3xx2J~yFlVjnHwZzNAFSYGadbK~MCh3urhxt7O7ujMx0RMEAjwZZeLsVypH~ZKg99FWWw__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Connection reset    > Could not download guava.jar (com.google.guava:guava:27.0.1-jre)       > Could not get resource 'https://plugins.gradle.org/m2/com/google/guava/guava/27.0.1-jre/guava-27.0.1-jre.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/e1c814fd04492a27c38e0317eabeaa1b3e950ec8010239e400fe90ad6c9107b4?response-content-disposition=attachment%3Bfilename%3D%22guava-27.0.1-jre.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZTFjODE0ZmQwNDQ5MmEyN2MzOGUwMzE3ZWFiZWFhMWIzZTk1MGVjODAxMDIzOWU0MDBmZTkwYWQ2YzkxMDdiND9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmd1YXZhLTI3LjAuMS1qcmUuamFyJTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTk0MDMyMDQ2fSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&Signature=QI-W5PqMw3v-FSxIb5wCz6OG5AAwOSdrBXofqZNLomjJP9ju7-HOXjXo4kx29gutQaidFPgBMpxGjekeFgIMk5SUa3GtHqCqyDEBO9IyS06I9DoJgylw4yBbhGyQasUhWh8ZbO0E9y~Fp71d9HHDg0oL8nMCpdNto5xizZpxE5vs2cxJ65HREXn2Z2wuj1BGM2gOskjbqjg0eSGqQldn1GUh~fwA-zUqym0s1ec2i3H0lMZi9iuvvZUXoVBlJu~rYKRfuACd6jyIQNV~n-yec8Pq~D7CDh2JEefDTbKoXaUTTzFcx5J16YBQfw4qh-DiMe87jy8AHeDkHTIsGapyJA__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download picocli.jar (info.picocli:picocli:3.9.5)       > Could not get resource 'https://plugins.gradle.org/m2/info/picocli/picocli/3.9.5/picocli-3.9.5.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/1ed3dbde2fc5aa2d0a035dca9600055d844d2b426816124491aebe88116a5c4b?response-content-disposition=attachment%3Bfilename%3D%22picocli-3.9.5.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvMWVkM2RiZGUyZmM1YWEyZDBhMDM1ZGNhOTYwMDA1NWQ4NDRkMmI0MjY4MTYxMjQ0OTFhZWJlODgxMTZhNWM0Yj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMnBpY29jbGktMy45LjUuamFyJTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTk0MDMyMDYwfSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&Signature=dossx2yAWsVXvsiGtKUwthYfg9ZgPhv5S1MNeYANCtJmPmLUkakubFL3XwNTzEz44NswO05L20Aorgvvnd89ns~BobRiAqfhqpyhEhCDPORtn4B-HC-ZbTkHx9VIKZE7lobVNWjpq6QeMfvHcU7UDmYrRGrGc~z5R6KK350R2RKuEQtEWiXNPDLogpBTued9IBAyt6FMbHgukpcc~qBGU6dIBtegQgfg9etKxiu6N~wi5Pvk-L-esDk0ho2pLsmXEVaQETEQ0Ndi0hQsdPaReFqDEfPyvkKoSSma63ctiKmc0HFI5UiKqhqS6vb2tyckvxXxHDe72uIF8gV34Sj8Bg__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download antlr.jar (antlr:antlr:2.7.7)       > Could not get resource 'https://plugins.gradle.org/m2/antlr/antlr/2.7.7/antlr-2.7.7.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/83cd2cd674a217ade95a4bb83a8a14f351f48bd0?response-content-disposition=attachment%3Bfilename%3D%22antlr-2.7.7.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvODNjZDJjZDY3NGEyMTdhZGU5NWE0YmI4M2E4YTE0ZjM1MWY0OGJkMD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmFudGxyLTIuNy43LmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjQwNn0sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=AEpi6y3RrqXc1mWHQigWHdXzh8guiWK9gf5XZbKbNAxvmAGvYSRBFFdm7iv4fWQJEj2CtZkOnk3tc7iQ0qGPviOCS8cCbv4sJdjspvcjLwXqyoqcKykw-51~w2CVK5x4ELrLDHC2FVInNyCUWqqnd-rnXxyE42BDCnCRtgZ3pb4~9zW1joO1tfzY9CRCfTufrXmSD-1g596LD297L-TsZ19qJ~8v4AZdNwjuLClpLF6-LPxt4Rpl76NTgkw1UY9r4cPI0CbeNMeBVjN1XzuPwZLrvQC9-bGiao1CGRKz6A3M3qLQrfOrRTEhruaDR-Wj4h3CvMcZvCrY6vtkh~p0bA__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download antlr4-runtime.jar (org.antlr:antlr4-runtime:4.7.2)       > Could not get resource 'https://plugins.gradle.org/m2/org/antlr/antlr4-runtime/4.7.2/antlr4-runtime-4.7.2.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/4c518b87d4bdff8b44cd8cbc1af816e944b62a3fe5b80b781501cf1f4759bbc4?response-content-disposition=attachment%3Bfilename%3D%22antlr4-runtime-4.7.2.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvNGM1MThiODdkNGJkZmY4YjQ0Y2Q4Y2JjMWFmODE2ZTk0NGI2MmEzZmU1YjgwYjc4MTUwMWNmMWY0NzU5YmJjND9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmFudGxyNC1ydW50aW1lLTQuNy4yLmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjE2OX0sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=RvBNaUxp70xMwTsI4r2dAoTR55fu8yO4v3wDx-39bPmvwr7Pstk6qZInDQWmeWZEGM8QBg3jS7Z2127k00gC0QYW7a3crpwAn5Qg0reyLhTENGHyQd5g9kyTlVXDg8TClUuQbd7QJKJXKnmIX7WLUp8RltuUlmKyDtqfea0o2QVgHE~y8hc8ruPNKlLzfbGBAKWn1PC6PQ~joqpqBH2U51bUv7dWP1nbDk8hq4XtAowmftwm~Oa2p1ZpGPMnXtt-QL5h2VDXMivE285eE70Mv6m0c~vMSsabacWl6KRR-AMB8vHnNueO5HEe8VhUgENir-l1OCybzLudrgXH7urjrA__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Connection reset    > Could not download Saxon-HE.jar (net.sf.saxon:Saxon-HE:9.9.1-1)       > Could not get resource 'https://plugins.gradle.org/m2/net/sf/saxon/Saxon-HE/9.9.1-1/Saxon-HE-9.9.1-1.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/3a6a8f3900f456d269a0af1ac16b32e1153be68b59af9864e03306a6ac66b6bf?response-content-disposition=attachment%3Bfilename%3D%22Saxon-HE-9.9.1-1.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvM2E2YThmMzkwMGY0NTZkMjY5YTBhZjFhYzE2YjMyZTExNTNiZTY4YjU5YWY5ODY0ZTAzMzA2YTZhYzY2YjZiZj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMlNheG9uLUhFLTkuOS4xLTEuamFyJTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTk0MDMyMDU1fSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&Signature=gg1721RyEqRThZ~y6nOevjFIp6-YmmYXxHxJuiD3j7a718P1SOyn-lTTtHM7ZAnKVEq8NJkxOt0AIpnXuMr0XAesTPlXO0h1a-Kg2kTMJFYXRW7UEBpTDuSS0MGlgUuD6Lx6HYzbhyPnWAmuLxdRYviEgPIOmwUKMfBjNyymI~H1gfg7J11mho3KzJ2l2iPzpUFW8je9ONla6Il-GsrIO2szwwUCHYzuuoGQlABMKP-OizgDlmILpnr3n3JWwrG3NUc7yMV2nNdz1HcZJSyVNoeCoQ226nw58lNNFOfeceaGmySFVKrEHp8LCo2~NcLgwq7zL9kfYhQ7BB~xELbMJg__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download logback-classic.jar (ch.qos.logback:logback-classic:1.2.3)       > Could not get resource 'https://plugins.gradle.org/m2/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/fb53f8539e7fcb8f093a56e138112056ec1dc809ebb020b59d8a36a5ebac37e0?response-content-disposition=attachment%3Bfilename%3D%22logback-classic-1.2.3.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZmI1M2Y4NTM5ZTdmY2I4ZjA5M2E1NmUxMzgxMTIwNTZlYzFkYzgwOWViYjAyMGI1OWQ4YTM2YTVlYmFjMzdlMD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmxvZ2JhY2stY2xhc3NpYy0xLjIuMy5qYXIlMjIiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE1OTQwMzIyODh9LCJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMC4wLjAuMC8wIn19fV19&Signature=mj6L1Rz7tSnTJ4z2A9PVw5e5CDj1xIskzibejiNTyG4c7YqOWJYidaUVt~MDqQ2xutFfgPFFtIG8Auv8ShdckDNceUJ4I7spHgYQ~G9PJ~2k9Ov8sQQ9BhqEwDUycQjA~OLAwHq3yYNoKciN~IxCpHoCwVe-V38NzUx0pJU1F1~IfHpX6AvUsxuFG-dpqjEymjLni6VnoQPUSBBG8w60Xo9vEZPEk6cVOmU33tIsMTh5ddCH0sHQsrgc4Am4ZWdtHvKqNMw56zj3COr3eEom28VDLqW-kpeKfKocYWgMyAuL4B7FYU4l6DoF6A259IARsTQmP3rGwh7WwX-yMl9k8w__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Connection reset    > Could not download jackson-core.jar (com.fasterxml.jackson.core:jackson-core:2.9.9)       > Could not get resource 'https://plugins.gradle.org/m2/com/fasterxml/jackson/core/jackson-core/2.9.9/jackson-core-2.9.9.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/3083079be6088db2ed0a0c6ff92204e0aa48fa1de9db5b59c468f35acf882c2c?response-content-disposition=attachment%3Bfilename%3D%22jackson-core-2.9.9.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvMzA4MzA3OWJlNjA4OGRiMmVkMGEwYzZmZjkyMjA0ZTBhYTQ4ZmExZGU5ZGI1YjU5YzQ2OGYzNWFjZjg4MmMyYz9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmphY2tzb24tY29yZS0yLjkuOS5qYXIlMjIiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE1OTQwMzIzMDJ9LCJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMC4wLjAuMC8wIn19fV19&Signature=AF4ehRqGwLaEWK~fBuXoqDLZV1yA~qE3WPEOPLj4IaiO8EJUjJNQseO1pAjsqRISwvWqFpX4QeBd00xm-ex-HEpiXE51TBgiWZZ7QTSm1kS~cs4MgF--28RGYB~3I4vJnu0F~YO-J5tDfxcuXPP-lhVqzu3D0qDItbAdyPRHRTLDB3FslEEnElzV0afjpDSyj4xYnA-W1Ev8ThjWiVGsVXbisXw2UYQXnjMLXOXswIzedQjTA--Nto8Xvl5nRCTwrduak9gOCiWRceBnf4M71-YoHx5RTfWptb~wLGb5-Ev7Cv-Hg68c5u7uRLyTfCVxTYxzA7p~acJ58Rjt1QdVYg__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Connection reset    > Could not download commons-codec.jar (commons-codec:commons-codec:1.8)       > Could not get resource 'https://plugins.gradle.org/m2/commons-codec/commons-codec/1.8/commons-codec-1.8.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/af3be3f74d25fc5163b54f56a0d394b462dafafd?response-content-disposition=attachment%3Bfilename%3D%22commons-codec-1.8.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvYWYzYmUzZjc0ZDI1ZmM1MTYzYjU0ZjU2YTBkMzk0YjQ2MmRhZmFmZD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmNvbW1vbnMtY29kZWMtMS44LmphciUyMiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTU5NDAzMjU1OX0sIklwQWRkcmVzcyI6eyJBV1M6U291cmNlSXAiOiIwLjAuMC4wLzAifX19XX0_&Signature=WknuhasfnYGs235WsGwQ3vY-7cRknAqDbi5kbFolxxJOFkZ4B9HlSt~zKkqbnAKRe0GfISmEPwgKwiMT9nPjViX~XtL0zk1eioOPk7C4tPF1X1NEnAMh91Fv9BKaJN6RAEUXEerCitgZSv4rLvBYI1sR~deGPqrHydb~HlpVPfDH42nlxvfGtZDoUNKwccVKugvrbileCzgh53QrJn91fJSwM-e3MwUAV8RltNCCaVEclZh~WSUxPNNOr7Izrlj4j3o2WlM8PxB6WTxtTF06Ox6om8BC0Y~9gy1iFU8ZNGidQX3HIXAjx4~vqTMnaOhGlGk2l7iUZwWjLwPKlCcuuA__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download commons-collections.jar (commons-collections:commons-collections:3.2.2)       > Could not get resource 'https://plugins.gradle.org/m2/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/8ad72fe39fa8c91eaaf12aadb21e0c3661fe26d5?response-content-disposition=attachment%3Bfilename%3D%22commons-collections-3.2.2.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvOGFkNzJmZTM5ZmE4YzkxZWFhZjEyYWFkYjIxZTBjMzY2MWZlMjZkNT9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmNvbW1vbnMtY29sbGVjdGlvbnMtMy4yLjIuamFyJTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTk0MDMyMDA4fSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&Signature=Ve70DwRKreKmH38L3N-Tf~BmCDQnYfS18PlLI6KpWVf~jXm0vXluPpfTxhCcGbAKi4LRZd79azq3SnuxSPesIYetsXXFSLzcTbekolVgEIQrgKWyC23wvCGlAQuQPevcfhEWNZXTAgW98qtohappxN3L43AuANwRh42djj3-ORO0PI~seaV26DLNuEIEcMevjrq3y~BWM6YhQvmRiB6V2FC~ZKYkvApuW0-C4tG~KovbBa89eV3S~635CAJQJBG5PU6nF5dYUxVj4sFUu8gi3htgST8o3JeCmy6i4QPZFX0nCVwutmqaGwQT839AFzNhGC0sGRKTgQ8IxjmvBTHDcQ__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake    > Could not download logback-core.jar (ch.qos.logback:logback-core:1.2.3)       > Could not get resource 'https://plugins.gradle.org/m2/ch/qos/logback/logback-core/1.2.3/logback-core-1.2.3.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/5946d837fe6f960c02a53eda7a6926ecc3c758bbdd69aa453ee429f858217f22?response-content-disposition=attachment%3Bfilename%3D%22logback-core-1.2.3.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvNTk0NmQ4MzdmZTZmOTYwYzAyYTUzZWRhN2E2OTI2ZWNjM2M3NThiYmRkNjlhYTQ1M2VlNDI5Zjg1ODIxN2YyMj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmxvZ2JhY2stY29yZS0xLjIuMy5qYXIlMjIiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE1OTQwMzI0NjV9LCJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMC4wLjAuMC8wIn19fV19&Signature=qvuraPJpqYS~geQLKtyaun63D1mgR84t42vduFOvCg~h68LdMO~NPtEiPeCraSILKaOetS-56n09pPU5Qhp9FpsobbcHrAeNJLdmlTGlDPkRAFFknQYsPo8YDw7LC9xnJCMiNeFI8YW8Biunm9bo3yUp5wIMbFfQnR8e1d~i00h20L4bWimZo2MFQHWFDvX1gRxub3vY5XJBJrj4LzLMliAia7ntEvGJBR6mSmwdoCaBsczA~qwn7Q0roFjl3-GxASEJHxZ4S0LFz0ryif292HkEEdTeETyYT0fKhFXhiYRc7s2CVtGRG5X~JxiOVfm5-htmjCn1nH9HabFnChmuQw__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Connection reset    > Could not download commons-compress.jar (org.apache.commons:commons-compress:1.18)       > Could not get resource 'https://plugins.gradle.org/m2/org/apache/commons/commons-compress/1.18/commons-compress-1.18.jar'.          > Could not GET 'https://d29vzk4ow07wi7.cloudfront.net/5f2df1e467825e4cac5996d44890c4201c000b43c0b23cffc0782d28a0beb9b0?response-content-disposition=attachment%3Bfilename%3D%22commons-compress-1.18.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvNWYyZGYxZTQ2NzgyNWU0Y2FjNTk5NmQ0NDg5MGM0MjAxYzAwMGI0M2MwYjIzY2ZmYzA3ODJkMjhhMGJlYjliMD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmNvbW1vbnMtY29tcHJlc3MtMS4xOC5qYXIlMjIiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE1OTQwMzIyMDh9LCJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMC4wLjAuMC8wIn19fV19&Signature=daG5keLJl0X-HCe7DW5uK91D0rc0inlxF6g7bIvExmR~e~zSbDEOp6we1~5IVSB~7iW~7AebidSwviMA2~P98QcB1PI83gtnb9n4pEGvZq7iakWNdORuMASj9cf~QPbz2YQvNETZI~t0N-FO5WsRbVsr-ZZe3OcqUkxh1crlmSnNVgSvBUNVrCn4lB3iMagyAqnhsDqCiThN-rIXhPRdfMv9egB2mggc1V4gnUXofNmFw3Mgn~VCOjgVy80LAJ044YGsbimXEcPiYBG6UYcT79C490N3RRbouenng65K1S6~DC3nJpvbRpx8M9bAR17RPb64YK5IgWconixOy9cR2A__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA'.             > Received close_notify during handshake  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  CONFIGURE FAILED in 2m 24s","closed","status: invalid,","Sword-X","2020-07-06T10:43:17Z","2020-07-07T08:20:46Z"
"","25757","AbstractRequestLoggingFilter: split client info, conditional before/after","* New methods to configure each part of the client info logging * Session id is no longer logged by default when client info logging is enabled   The session id is sensitive information (similar to user credentials) * Methods to separately and conditional enable/disable before and after   logging","open","type: enhancement,","candrews","2020-09-11T19:21:50Z","2021-04-27T05:06:14Z"
"","25398","Upgrade to Jackson 2.11.2","* HttpHeaders can not be deserialized by jackson-databind:2.11.0 * https://github.com/FasterXML/jackson-databind/issues/2757","closed","type: dependency-upgrade,","dlsrb6342","2020-07-16T09:25:15Z","2020-08-03T18:26:18Z"
"","25298","DefaultSubscriptionRegistry: Reduced thread contention","* DestinationCache is now synchronized on multiple 'destination' locks   (previously a single shared lock) * DestinationCache keeps destinations without any subscriptions  (previously such destinations were recomputed over and over) * SessionSubscriptionRegistry is now a   'sessionId -> subscriptionId -> (destination,selector)' map   for faster lookups   (previously 'sessionId ->  destination -> set of (subscriptionId,selector)')  closes gh-24395","closed","type: enhancement,","trim09","2020-06-22T08:49:28Z","2020-07-22T11:18:52Z"
"","25635","Remove never use code in AbstractNestablePropertyAccessor","'if (propValue == null)' ,' isAutoGrowNestedPaths()' always returns false.  So remove the never accessable code, direct throw exception.","closed","in: core,","yilianhuaixiao","2020-08-24T02:58:24Z","2021-12-10T22:53:44Z"
"","25296","fixed issue 25244","#25244  fixed [issue 25244](https://github.com/spring-projects/spring-framework/issues/25244)  - Add a code path for no-args method - Add comments to make this code easy for others to understand（It took me a long time to understand it）","closed","","daimingzhi","2020-06-21T12:47:20Z","2022-02-18T19:06:54Z"
"","25312","Enhance HandlerMappingIntrospector to cache parsed patterns","#24945 added support for parsed `PathPattern`s but in order to integrate with this Spring Security has to parse its patterns in one of several ways depending on how many differently configured `PathPatternParser`'s are in use (see https://github.com/spring-projects/spring-security/issues/8691).  This ticket is to try and encapsulate the parsing and caching of patterns so that Spring Security does not need to be aware of those details and continue to use the same API passing String patterns as input. Internally Spring MVC would have to then to parse patterns lazily and build up the cache.","closed","type: enhancement,","rstoyanchev","2020-06-24T15:03:56Z","2020-07-06T12:32:49Z"
"","25063","Connection not closed after transaction commit","#### Short example  ```java @Service class ServiceA(private val serviceB: ServiceB) {    fun doA() {     serviceB.doB(..) // fast query     Thread.sleep(5000) // slow operation (e.g. external request call)   }  }  @Service class ServiceB {    @Transactional   fun doB(..) {     // some fast query to db   } } ```  #### Expected  1. start doB 2. acquire connection 3. start transaction 4. execute logic doB 5. commit or rollback transaction 6. closed connection (return to pool) 7. end doB  #### Actual  connection not closed after commit transaction As result ""Connection is not available, request timed out after""  [Example with test](https://github.com/DVMaslov/tx-test)","closed","status: invalid,","DVMaslov","2020-05-13T07:22:18Z","2021-04-27T11:33:45Z"
"","25061","Proposal to optimize PostProcessorRegistrationDelegate","### The code in PostProcessorRegistrationDelegate.registerBeanPostProcessors  ```java List priorityOrderedPostProcessors = new ArrayList(); List internalPostProcessors = new ArrayList(); List orderedPostProcessorNames = new ArrayList(); List nonOrderedPostProcessorNames = new ArrayList(); for (String ppName : postProcessorNames) {     if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);         priorityOrderedPostProcessors.add(pp);         if (pp instanceof MergedBeanDefinitionPostProcessor) {             internalPostProcessors.add(pp);         }     }     else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {         orderedPostProcessorNames.add(ppName);     }     else {         nonOrderedPostProcessorNames.add(ppName);     } }  // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);  // Next, register the BeanPostProcessors that implement Ordered. List orderedPostProcessors = new ArrayList(orderedPostProcessorNames.size()); for (String ppName : orderedPostProcessorNames) {     BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);     orderedPostProcessors.add(pp);     if (pp instanceof MergedBeanDefinitionPostProcessor) {         internalPostProcessors.add(pp);     } } sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); ``` I want to know how this code is designed，can i get the Ordered beans in the for loop and add them to the list, just like the way handler PriorityOrdered type.  So we can reduce more then one cycle.  ### My example is as follow:  ```java List priorityOrderedPostProcessors = new ArrayList(); List orderedPostProcessors = new ArrayList(); List nonOrderedPostProcessors = new ArrayList(); List internalPostProcessors = new ArrayList(); for (String ppName : postProcessorNames) {     BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);     if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {         priorityOrderedPostProcessors.add(pp);     }     else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {         orderedPostProcessors.add(pp);     }     else {         nonOrderedPostProcessors.add(pp);     }     if (pp instanceof MergedBeanDefinitionPostProcessor) {         internalPostProcessors.add(pp);     } }  // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);  // Next, register the BeanPostProcessors that implement Ordered. sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors);  // Now, register all regular BeanPostProcessors. registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);  // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); ```","closed","status: superseded,","yuanhaobin","2020-05-13T03:43:16Z","2020-12-30T17:00:00Z"
"","25213","Spring WebFlux ""ResourceLeakDetector:LEAK""","### Spring Boot Version spring-boot-starter-webflux:2.1.14.RELEASE spring-boot-starter-reactor-netty:2.1.14.RELEASE reactor-netty:0.8.18.RELEASE jdk 1.8.0_162  ### Problem Hi,    I am using jmeter to test the performance of a microservice, the test case is: + Running the application with `-Dio.netty.leakDetectionLevel=paranoid` . + Jmeter uses 50 threads to start performance testing. + **Force stop** jmeter in the testing. + Start the performance testing again.     An exception occurs: `io.netty.util.ResourceLeakDetector:LEAK: ByteBuf.release() was not called before it's garbage-collected`. When I remove the `subscribeOn`  in the code, no exception occurs.  ### Code + MyApplication ``` @SpringBootApplication @EnableWebFlux @Configuration public class MyApplication {     public static void main(String[] args) {         SpringApplication app = new SpringApplication(MyApplication.class);         app.run(args);     }      @Bean     public Scheduler requestScheduler() {         ExecutorService executorService =             new ThreadPoolExecutor(1024, 1024, 60, TimeUnit.SECONDS, new SynchronousQueue());         return Schedulers.fromExecutorService(executorService);     } } ```  + MyController ``` @RestController public class MyController {      @Autowired     @Qualifier(""requestScheduler"")     private Scheduler requestScheduler;      @RequestMapping(value = ""/test"")     public Mono process(@RequestBody String reqMsg, @RequestHeader HttpHeaders reqHttpHeaders,         ServerHttpRequest serverHttpRequest) {         return Mono.just(reqMsg).subscribeOn(requestScheduler).onErrorResume(e -> {             return Mono.just(e.getMessage());         }).flatMap(responseMsg -> {             return Mono.just(new ResponseEntity(responseMsg, HttpStatus.OK));         });     } } ```  ### Exception stack ``` 2020-06-09T15:57:00.976+0800|ERROR|pool-2-thread-1021|320|io.netty.util.ResourceLeakDetector:LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information. Recent access records:  Created at: 	io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:363) 	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187) 	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:178) 	io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115) 	org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:71) 	org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:39) 	org.springframework.core.codec.CharSequenceEncoder.lambda$encode$1(CharSequenceEncoder.java:85) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107) 	reactor.core.publisher.FluxJust$WeakScalarSubscription.request(FluxJust.java:99) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) 	reactor.core.publisher.MonoSingle$SingleSubscriber.request(MonoSingle.java:94) 	reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1993) 	reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1867) 	reactor.core.publisher.MonoSingle$SingleSubscriber.onSubscribe(MonoSingle.java:114) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) 	reactor.core.publisher.FluxJust.subscribe(FluxJust.java:70) 	reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63) 	reactor.core.publisher.MonoSingle.subscribe(MonoSingle.java:58) 	reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) 	reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) 	reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1623) 	reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) 	reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73) 	reactor.core.publisher.FluxSubscribeOnValue$ScheduledScalar.run(FluxSubscribeOnValue.java:178) 	reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:50) 	reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:27) 	java.util.concurrent.FutureTask.run(FutureTask.java:266) 	java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	java.lang.Thread.run(Thread.java:748) ```","closed","","xuep2006","2020-06-09T08:19:42Z","2022-01-08T20:43:20Z"
"","25329","As of Spring 5.2 AnnotationUtils.findAnnotation is not searching for nested annotations properly","### Problem  As of Spring 5.2 `AnnotationUtils.findAnnotation` is not searching for nested annotations properly.  Sample:  ``` @Deprecated @Retention(RetentionPolicy.RUNTIME) @Target(value = { ElementType.TYPE }) public @interface CustomAnnotation { }  @CustomAnnotation public class CustomType { } ```  In Spring 5.1.x the following code returns proper result:  ``` Deprecated annotation = AnnotationUtils.findAnnotation(CustomType.class, Deprecated.class); ```  but not in Spring 5.2.x.  ### Reproduce  1. Checkout: https://github.com/alexey-anufriev/spring-framework-annotation-utils-bug 2. Run `mvn clean test` to reproduce.","open","in: core,","alexey-anufriev","2020-06-29T13:30:51Z","2021-11-10T12:33:21Z"
"","25522","StaticListableBeanFactory.isSingleton() returns false for singleton beans","### Overview  `StaticListableBeanFactory.isSingleton()` returns `false` for all singleton beans other than singletons created by a `FactoryBean`.  ## Deliverables  - [x] Ensure `StaticListableBeanFactory.isSingleton()` returns `true` for all beans not created by a `FactoryBean`.","closed","in: core,","sbrannen","2020-08-04T11:27:09Z","2020-08-04T13:20:15Z"
"","24952","Reject ""/path/**/other"" patterns in PathPatternParser","### Issue: Created 2 mappings as following in the controller, code is in `Controller .java`of the attached [project](https://github.com/kaladhar-mummadi/demo-issue). ```java @GetMapping(""/foo/**"") public ResponseEntity getFoo() {}  @GetMapping(""/foo/**/bar"") public ResponseEntity getFooBar() {} ```  - In `webmvc` whenever request comes as `/foo/1/2/3/bar` (as far as last path segment  is `bar`) it maps to `getFooBar`. - If `bar` is not specified ast last path segment then it maps to `getFoo`. i.e all `foo/1`, `foo/1/2`, `foo/ab/cd`.... maps to `getFoo`. - The issue is in webflux, when I switch to `webflux` all mappings map to  `getFoo`. No matter if path consists of `bar` in the last path segment. - For eg. `/foo/ab/cd/bar` maps to `getFoo` instead of `getFooBar`.   > Uploaded the project here , to switch between `webflux` and `webmvc` please comment out appropriate starter dependency in `pom.xml`.  #### Repro project here : https://github.com/kaladhar-mummadi/demo-issue #### Notes: - Webmvc [AntPathMatcherTests](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java#L103) has tests like `/bla/**/bla`, which are not covered in  [PathPatternTests](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/test/java/org/springframework/web/util/pattern/PathPatternTests.java) of WebFlux.","closed","type: enhancement,","kaladhar-mummadi","2020-04-21T15:01:57Z","2020-06-04T09:08:48Z"
"","25113","Problem:SpringBoot2 Junit5, How to test @TransactionalEventListener annotated method?","### Hello Spring Team!  I have a problem: In my project, I need use `@TransactionalEventListener` to handle the Cached-Objects to synchronization，in my demo project, I found a problem: If your need use `@Transaction` in TestCase method, **you need to auto-rollback the testing data**! so you must be use` @Transaction`, but now, `@TransactionalEventListener` **it's not work**! OMG! I think so is a bug? WHY CANNOT USE `@Transactional` TO TESTING `@TransactionalEventListener` ? **Is this a reasonable situation?** ### Show my demo code: **DemoServiceImpl.java** ``` @Service public class DemoServiceImpl implements DemoService {      final ApplicationEventPublisher applicationEventPublisher;      public DemoServiceImpl(ApplicationEventPublisher applicationEventPublisher) {         this.applicationEventPublisher = applicationEventPublisher;     }      @Transactional     @Override     public void test() throws SQLException {         applicationEventPublisher.publishEvent(""Demo Test!"");         applicationEventPublisher.publishEvent(Integer.MAX_VALUE);         throw new SQLException(""Test exception"");     } } ``` **DemoEventReceiverComponentImpl.java** ``` @Service //@Component public class DemoEventReceiverComponentImpl implements DemoEventReceiverComponent {  //    @EventListener     @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, fallbackExecution = false)     public void onEvent(String data) {         System.out.println(data);     }      //    @EventListener     @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, fallbackExecution = false)     public void onEvent2(Integer data) {         System.out.println(data);     } } ``` **DemoServiceImplTest.java** ``` @SpringBootTest class DemoServiceImplTest {      @Autowired     DemoService demoService;      @Transactional  // Look at this!!! If you comment this line, onEvent*() it's to work!     @Test     void test1() throws SQLException {         demoService.test();     } } ``` [Crying] It took me two days to find out the problem. It was too confusing. I cant say why not? Is there any other solution?","closed","for: stackoverflow,","rocbin","2020-05-21T09:52:31Z","2020-05-30T09:25:09Z"
"","25442","SseEmitter (ResponseBodyEmitter) keeps collecting messages if not initialized","### Details  **Component:** spring-webmvc **Affects:** 5.2.7.RELEASE **Impact:** Memory leak  ### Description  The ResponseBodyEmitter instance is normally initialized by the framework upon returned by the RestController method. The messages that are passed in the meantime are collected in a LinkedHashSet.  When the connection is dropped by the client early enough then the **initialization will never be invoked**.  These instances keep collecting the messages with **no limitation**. To make matters worse, these instances are **not evicted when timeout** is reached.  This may result in OutOfMemoryError on the long run.  ### Steps to reproduce:  1. Start Server app in debug mode 2. Add breakpoint to org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler:129 //emitter.initialize(handler); 3. Start Client app 4. When breakpoint hit then stop Client app  ### Attachments  - [sse.zip](https://github.com/spring-projects/spring-framework/files/4952321/sse.zip) - [sse-with-timeout.log](https://github.com/spring-projects/spring-framework/files/4952325/sse-with-timeout.log)  ### Ideas  In my opinion this may be addressed by - limiting the time waiting for initialization - limiting the number of messages kept before initialization - a combination of the above - a custom handler for early send attempts","closed","type: bug,","kgcsabi","2020-07-21T08:56:04Z","2020-10-16T18:16:48Z"
"","25633","Allow early decoration of request and response in WebFlux","### Current behaviour  `WebHttpHandlerBuilder.build()` creates instance of `HttpWebHandlerAdapter` (https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/server/adapter/WebHttpHandlerBuilder.java#L356).  However, [HttpWebHandlerAdapter](https://github.com/spring-projects/spring-framework/blob/0f7ad1b5bf39dad9578324ac0a97bcfed0be4211/spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java#L241) allows to override some of it's methods (e.g. `createExchange`).  ### Proposed behaviour  Supply `HttpWebHandlerAdapterFactory` to `WebHttpHandlerBuilder.build` and create `HttpWebHandlerAdapter` via this factory. Naive approach could be as simple as:  ```java     public HttpHandler build() {          WebHandler decorated = new FilteringWebHandler(this.webHandler, this.filters);         decorated = new ExceptionHandlingWebHandler(decorated,  this.exceptionHandlers);          HttpWebHandlerAdapter adapted = httpHandlerCreator.apply(decorated);         ...         return adapted;     } ```  ### Motivation  Sometimes we need to decorate `ServerHttpResponse` and `ServerHttpRequest` (e.g. body logging/caching). Doing this inside a `WebFilter` is not sufficient in case of thrown exception flow. We have to do it ""earlier"" than `ExceptionHandlingWebHandler`","closed","type: enhancement,","fred84","2020-08-23T12:46:31Z","2021-02-05T10:55:58Z"
"","24975","Connection not closed in WebFlux when JVM fatal error is raised on parallel Scheduler","### Bug Description When there is an jvm exception occur on Schedulers.parallel or other async thread pool, the connection will not close after the sever already finish the request.  ### Example ```java @GetMapping(""test_exception"") public Mono handleEvent() { 	return Mono.just(true).subscribeOn(Schedulers.parallel()).map(x -> { 		throw new StackOverflowError(""test""); 	}); } ``` the server already throw exception ![image](https://user-images.githubusercontent.com/3929477/80300284-d9c78b00-87cd-11ea-89ec-5a80055cdc80.png) but not finish the connection ![image](https://user-images.githubusercontent.com/3929477/80300289-e4822000-87cd-11ea-8447-0f85c4b7a38f.png)  ### Probable Cause - I read the code, and found when the exception is fatal error, it will direct throw the exception in thread pool without cancel subscription - this is where the exception throw ![image](https://user-images.githubusercontent.com/3929477/80300348-83a71780-87ce-11ea-92e9-a071856e30e8.png) - then, it go to the onNextError reactor.core.publisher.Operators#onNextError(T, java.lang.Throwable, reactor.util.context.Context, org.reactivestreams.Subscription) ![image](https://user-images.githubusercontent.com/3929477/80300359-9588ba80-87ce-11ea-8004-8824eb4ea165.png) - just throw without cancel ![image](https://user-images.githubusercontent.com/3929477/80300362-9d485f00-87ce-11ea-9e7f-e74d60faf280.png) - then the reactor.core.scheduler.SchedulerTask#call catch the ex, but still not call onError to cancel subscribtion ![image](https://user-images.githubusercontent.com/3929477/80300380-c8cb4980-87ce-11ea-80ea-51a5f439788a.png)","closed","status: invalid,","czjxy881","2020-04-26T07:06:07Z","2020-05-18T13:17:35Z"
"","25186","Implement reliable invocation order for advice within an @Aspect","## Overview  The `AspectJPrecedenceComparator` was designed to mimic the precedence order enforced by the AspectJ compiler with regard to multiple 'after' methods defined within the same aspect whose pointcuts match the same joinpoint. Specifically, if an aspect declares multiple `@After`, `@AfterReturning`, or `@AfterThrowing` advice methods whose pointcuts match the same joinpoint, such 'after' advice methods should be invoked in the reverse order in which they are declared in the source code.  When the `AspectJPrecedenceComparator` was introduced in Spring Framework 2.0, it achieved its goal of mimicking the AspectJ compiler since the JDK at that time (i.e., Java 5) ensured that invocations of `Class#geDeclaredMethods()` returned an array of methods that matched the order of declaration in the source code. However, Java 7 removed this guarantee. Consequently, in Java 7 or higher, `AspectJPrecedenceComparator` no longer works as it is documented or as it was designed.  PR #24673 highlights a use case where `AspectJPrecedenceComparator` fails to assign the highest precedence to an `@After` advice method (declared last in the source code). Note that an `@After` advice method with a precedence higher than `@AfterReturning` and `@AfterThrowing` advice methods in the same aspect will effectively be invoked last due to the try-finally implementation in `AspectJAfterAdvice.invoke(MethodInvocation)` which invokes `proceed()` in the try-block and `invokeAdviceMethod()` in the finally-block.  ## Proposal  Since Spring cannot reliably determine the source code declaration order of such advice methods without using ASM to analyze the byte code, we have decided to implement reliable invocation order for 'after' advice methods declared within a single `@Aspect`.  ## Related Issues  - #24673 - #25205  ## Deliverables  - [x] Implement reliable invocation order for `@After`, `@AfterReturning`, and `@AfterThrowing` advice methods within a single `@Aspect` class, by ensuring that `@AfterReturning` and `@AfterThrowing` methods are always invoked before any `@After` methods within the same `@Aspect` class.","closed","type: enhancement,","sbrannen","2020-06-04T16:31:32Z","2020-06-08T13:08:08Z"
"","25030","Document ReactiveTransactionManager support","## Overview  Spring Framework 5.2 introduced reactive transaction management support but did not include any documentation on the feature set in the reference manual.  ## Deliverables  - [x] Document `ReactiveTransactionManager` support in reference manual - [x] Where feasible, replace mentions of `PlatformTransactionManager` with the `TransactionManager` marker interface, potentially pointing to discussions of `PlatformTransactionManager` and `ReactiveTransactionManager`    - [x] `data-access.adoc`    - [x] Javadoc for `@Transactional`, etc.    - [x] XSD documentation","closed","type: documentation,","sbrannen","2020-05-07T17:10:48Z","2020-05-10T14:09:21Z"
"","25152","Make use of custom types configurable in YamlProcessor","## Overview  Since SnakeYaml allows for custom types to be loaded when they are specified inside the YAML document, we should make it possible to configure the types that can be constructed.  ## Proposal  Provide a mechanism in `YamlProcessor` for configuring the supported custom types for the `Yaml` instance created in `org.springframework.beans.factory.config.YamlProcessor.createYaml()`.  For example, a new `void setSupportedCustomTypes(Class... types)` method could be added to `YamlProcessor`. If no supported types are configured, the `Yaml` instance would be created as it is currently, without any restrictions. If supported types have been configured, the `Yaml` instance would be created with restrictions in place. The [`TypeLimitedConstructor`](https://github.com/spring-projects/spring-boot/blob/a84b7bccf1d95b2e017be445f4cfcda438737d09/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/json/YamlJsonParser.java#L53-L69) recently introduced in Spring Boot can serve as inspiration for the latter.  ## Related Issues  - https://github.com/spring-projects/spring-boot/issues/21596","closed","type: enhancement,","sbrannen","2020-05-28T12:19:05Z","2022-04-11T08:17:17Z"
"","24861","Annotation searches potentially synthesize annotations unnecessarily","## Overview  Prior to Spring Framework 5.2, some of our annotation utilities would not _synthesize_ an annotation if it was already synthesized or not _synthesizable_.  It appears that we may have lost this functionality with the introduction of the new `MergedAnnotations` API. This issue is therefore labeled as a _potential_ regression.  ## Deliverables  - [x] Determine if annotations are synthesized unnecessarily and decide where to go from there.","closed","in: core,","sbrannen","2020-04-03T17:15:37Z","2020-04-23T17:12:31Z"
"","25334","Check for valid IPv6 host in UriComponentsBuilder.fromUriString","## Overview  PR #358 introduced a ""scheme but no host"" check in the `fromHttpUrl` method in `UriComponentsBuilder`, but a similar check was not added to `fromUriString`.  ## Deliverables  - [x] Introduce a ""scheme but no host"" check in `UriComponentsBuilder.fromUriString` to align with the functionality in `fromHttpUrl`.","closed","type: enhancement,","sbrannen","2020-06-29T15:35:10Z","2020-06-29T16:37:04Z"
"","24875","Deprecate rarely used bean definition variants","## Overview  For Spring Framework 5.3, we should consider deprecating rarely used bean definition variants.  ## Possible candidates for deprecation  Candidates listed here are up for discussion. No decisions have been made yet about the deprecation of the candidates.  #### Properties based  - `PropertiesBeanDefinitionReader` - `JdbcBeanDefinitionReader` - `GenericPropertiesContextLoader` - `ResourceBundleViewResolver` - `XmlViewResolver` (not property-based, but related to `ResourceBundleViewResolver`)","closed","in: core,","sbrannen","2020-04-07T15:22:30Z","2020-06-17T09:03:51Z"
"","25205","Improve invocation order for advice within an","## Overview  Due to tests implemented in conjunction with #25186, it has come to our attention that advice ordering within a single aspect configured via the `` XML configuration element may not be desirable and is at least not intuitive.  ## Related Issues  - #24673 - #25186   ## Deliverables  - Determine what changes (if any) should be made the advice sorting within a single `` element - Update documentation in the reference manual accordingly","open","type: enhancement,","sbrannen","2020-06-08T09:09:41Z","2020-10-13T12:58:17Z"
"","24992","Use same default ClassLoader in SpringFactoriesLoader","## Overview  Currently, the `loadFactoryNames()` and `loadFactories()` methods in `SpringFactoriesLoader` effectively use a different default `ClassLoader`.  This potentially results in two entries in the internal cache:  - one using the class loader for `SpringFactoriesLoader.class` when `loadFactories()` is invoked with a `null` `ClassLoader`. - one using the system class loader when `loadFactoryNames()` is invoked with a `null` `ClassLoader`.  # Deliverales  - Consistently use the `ClassLoader` for `SpringFactoriesLoader.class` as the default `ClassLoader`.","closed","type: enhancement,","sbrannen","2020-04-29T12:18:54Z","2020-04-29T12:47:43Z"
"","24865","Switch to googlecode theme for syntax highlighting in reference manual","## Overview  [`spring-doc-resources` 0.2.1](https://github.com/spring-io/spring-doc-resources/milestone/3) will include the `googlecode` theme for syntax highlighting in the reference manual.  Since the team has already agreed to switch to this theme, we should make the switch once `spring-doc-resources` 0.2.1 has been released.  ## Related Issues  - https://github.com/spring-io/spring-doc-resources/issues/25 - https://github.com/spring-io/spring-doc-resources/issues/40","closed","type: documentation,","sbrannen","2020-04-05T13:16:37Z","2020-04-28T10:26:34Z"
"","25144","Spring WebSocket can't send message to authenticated user when pass token in header","## I have push my code into github, and the eureka and mysql is mine, you can clone it and run it directly:  [auth-service](https://github.com/uyoaix/auth-service) [websocket-service](https://github.com/uyoaix/websocket-service) [vue-websocket-demo](https://github.com/uyoaix/vue-websocket-project)   # 1. scenes to be used  * When connect WebSocket is permitAll * Then Subscribe **/user/queue/userInfo** need user authenticated * After subscribe success, send to **/app/user/info** need authenticated(Because I need get userInfo ), and push message to  current user subscribe queue **/user/queue/userInfo**   # 2. What problem I encountered * Connect WebSocket success * Subscribe **/user/queue/userInfo**  success * Send to **/app/user/info** success * At last I cannot receive the message return from server.  ## 2.1 Details description after I trace the source code 1) when subscribe **/user/queue/userInfo** with the jwtToken in header, I get the jwtToken, then get Principle user object from auth server with jwtToken, then set user in StompHeaderAccessor. At last, the user subscribe lookupDestination is /queue/userInfo/user{sessionId} 2) Then send **/app/user/userInfo** with jwtToken in header, after handle the return value, the final send destination is /user/{Principle.getName()}/queue/userInfo.   the user never subscribe this queue: /user/{Principle.getName()}/queue/userInfo, and the message cannot send to user    # 3. What I do  ## 3.1 WebSocketConfig  ```java @Configuration @Order(Ordered.HIGHEST_PRECEDENCE + 99) @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {          @Autowired     private  CustomClientInboundChannelInterceptor customClientInboundChannelInterceptor;       @Override     public void configureClientInboundChannel(ChannelRegistration registration) {         registration.interceptors(customClientInboundChannelInterceptor);     }           @Override     public void registerStompEndpoints(StompEndpointRegistry registry) {         registry.addEndpoint(""/sockJs"").setAllowedOrigins(""*"").withSockJS();     }           @Override     public void configureMessageBroker(MessageBrokerRegistry config) {                  config.enableSimpleBroker(""/topic"", ""/queue"");         config.setApplicationDestinationPrefixes(""/app"",""/user"");     }  }  ``` ## 3.2 WebSocketSecurityConfig  ```java @Configuration public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {      @Override     protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {         messages                 .simpTypeMatchers(SimpMessageType.CONNECT, SimpMessageType.HEARTBEAT, SimpMessageType.UNSUBSCRIBE, SimpMessageType.DISCONNECT).permitAll()                 .simpDestMatchers(""/user/**"").authenticated()                 .simpSubscribeDestMatchers(""/user/**"").authenticated();      }      @Override     protected boolean sameOriginDisabled() {         return true;     }  } ```  ## 3.3 CustomClientInboundChannelInterceptor  > This Interceptor is according to the spring reference documentation:[websocket-stomp-authentication](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication)  ```java @Component public class CustomClientInboundChannelInterceptor implements ChannelInterceptor {      private final AuthServiceClient authServiceClient;      @Autowired     public CustomClientInboundChannelInterceptor(AuthServiceClient authServiceClient) {         this.authServiceClient = authServiceClient;     }      @Override     public Message preSend(Message message, MessageChannel channel) {         StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);         if (StompCommand.SUBSCRIBE.equals(accessor.getCommand()) ||                 StompCommand.SEND.equals(accessor.getCommand())         ) {             String jwtToken = accessor.getFirstNativeHeader(""Authorization"");             log.debug(""webSocket token is {}"", jwtToken);             if (!StringUtils.isEmpty(jwtToken)) {                  PassUser passUser = authServiceClient.userInfo(jwtToken);                 SecurityContextHolder.getContext().setAuthentication(passUser);                  accessor.setUser(passUser);                 // I try to remove above code : accessor.setUser(passUser);                 // Then SecurityContextChannelInterceptor line 123,                 // it will take user from message header with key ""simpUser""                 // so if I remove , the user will change to anonymous, and request will be AccessDeniedException             }         }         return message;     }  } ```  ## 3.3 Subscribe and Send from front-end js ```javascript        connectWebSocket() {             let socket = new SockJS(this.baseUrl+'/sockJs');             this.stompClient = Stomp.over(socket);                         this.stompClient.connect({}, function (frame) {               console.log('Connected: ' + frame)             });           }          subscribeLoginUserMessage(){            var headers = {                 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTA2OTk0MTYsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI0NzNjOTVlYy1iNjUwLTQ2OTUtOTVhMy00ODYzZjRjOWZjOGQiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.YH6yChvdATn1vMonbc0OhSgI_kTi3KeIzgCldypInLg'             };              this.stompClient.subscribe(""/user/queue/userInfo"", function (e) {               let data = JSON.parse(e.body)               console.log('login user p2p message response', data)              }, headers);         }         userInfo(){           let data = {}           var headers = {                 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTA2OTk0MTYsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI0NzNjOTVlYy1iNjUwLTQ2OTUtOTVhMy00ODYzZjRjOWZjOGQiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.YH6yChvdATn1vMonbc0OhSgI_kTi3KeIzgCldypInLg'             }            this.stompClient.send(""/app/user/info"", headers, JSON.stringify(data));         } ``` ## 3.4 Controller method which handle the send request ```java     @MessageMapping(""/user/info"")     @SendToUser(value = ""/queue/userInfo"", broadcast = false)     public String userInfo(@AuthenticationPrincipal PassUser passUser) {         log.info(""push user info""：passUser={}"", JsonUtil.toJsonString(passUser));         return JsonUtil.toJsonString(passUser);     } ```","closed","for: stackoverflow,","uyoaix","2020-05-27T18:09:10Z","2020-05-30T08:55:48Z"
"","25167","Spring WebSocket can't send message to authenticated user when pass token in header","## I have google searched so many  article and ask question on Stack overflow, but I still not resolve this problem, so I hope someone in yours could help me have a look. Thanks! I  have push my code into github, and the eureka and mysql is mine, you can clone it and run it directly:  [auth-service](https://github.com/uyoaix/auth-service) [websocket-service](https://github.com/uyoaix/websocket-service) [vue-websocket-demo](https://github.com/uyoaix/vue-websocket-project)  > Get the jwt access_toen 1. you can get directly use this request with post method: ``` http://120.27.218.194:8081/oauth/token?grant_type=password&client_id=test-client-id&client_secret=123456&scope=all&username=elvis%40gmail.com&password=elvis2020 ``` 2. use this one ``` eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTExODg4NDUsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI0OTlkYmQyMC1iMGFmLTQzNmItOWNiNS05YTU4NjdkNjQxOTQiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.UfN7GZikIFYp3j3htY-9OQ9XdCl0-gPNbAf6eZq3oBk ``` 3. clone the [auth-service](https://github.com/uyoaix/auth-service), run it in local and get one   # 1. scenes to be used  * When connect WebSocket is permitAll * Then Subscribe **/user/queue/userInfo** need user authenticated * After subscribe success, send to **/app/user/info** need authenticated(Because I need get userInfo ), and push message to  current user subscribe queue **/user/queue/userInfo**   # 2. What problem I encountered * Connect WebSocket success * Subscribe **/user/queue/userInfo**  success * Send to **/app/user/info** success * At last I cannot receive the message return from server.  ## 2.1 Details description after I trace the source code 1) when subscribe **/user/queue/userInfo** with the jwtToken in header, I get the jwtToken, then get Principle user object from auth server with jwtToken, then set user in StompHeaderAccessor. At last, the user subscribe lookupDestination is /queue/userInfo/user{sessionId} 2) Then send **/app/user/userInfo** with jwtToken in header, after handle the return value, the final send destination is /user/{Principle.getName()}/queue/userInfo.   the user never subscribe this queue: /user/{Principle.getName()}/queue/userInfo, and the message cannot send to user. the trace log : o.s.m.s.u.UserDestinationMessageHandler  : No active sessions for user destination: /user/1/queue/userInfo   # 3. Related Code  ## 3.1 WebSocketConfig  ```java @Configuration @Order(Ordered.HIGHEST_PRECEDENCE + 99) @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {          @Autowired     private  CustomClientInboundChannelInterceptor customClientInboundChannelInterceptor;       @Override     public void configureClientInboundChannel(ChannelRegistration registration) {         registration.interceptors(customClientInboundChannelInterceptor);     }           @Override     public void registerStompEndpoints(StompEndpointRegistry registry) {         registry.addEndpoint(""/sockJs"").setAllowedOrigins(""*"").withSockJS();     }           @Override     public void configureMessageBroker(MessageBrokerRegistry config) {                  config.enableSimpleBroker(""/topic"", ""/queue"");         config.setApplicationDestinationPrefixes(""/app"",""/user"");     }  }  ``` ## 3.2 WebSocketSecurityConfig  ```java @Configuration public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {      @Override     protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {         messages                 .simpTypeMatchers(SimpMessageType.CONNECT, SimpMessageType.HEARTBEAT, SimpMessageType.UNSUBSCRIBE, SimpMessageType.DISCONNECT).permitAll()                 .simpDestMatchers(""/user/**"").authenticated()                 .simpSubscribeDestMatchers(""/user/**"").authenticated();      }      @Override     protected boolean sameOriginDisabled() {         return true;     }  } ```  ## 3.3 CustomClientInboundChannelInterceptor  > This Interceptor is according to the spring reference documentation:[websocket-stomp-authentication](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-authentication)  ```java @Component public class CustomClientInboundChannelInterceptor implements ChannelInterceptor {      private final AuthServiceClient authServiceClient;      @Autowired     public CustomClientInboundChannelInterceptor(AuthServiceClient authServiceClient) {         this.authServiceClient = authServiceClient;     }      @Override     public Message preSend(Message message, MessageChannel channel) {         StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);         if (StompCommand.SUBSCRIBE.equals(accessor.getCommand()) ||                 StompCommand.SEND.equals(accessor.getCommand())         ) {             String jwtToken = accessor.getFirstNativeHeader(""Authorization"");             log.debug(""webSocket token is {}"", jwtToken);             if (!StringUtils.isEmpty(jwtToken)) {                  PassUser passUser = authServiceClient.userInfo(jwtToken);                 SecurityContextHolder.getContext().setAuthentication(passUser);                  accessor.setUser(passUser);                 // I try to remove above code : accessor.setUser(passUser);                 // Then SecurityContextChannelInterceptor line 123,                 // it will take user from message header with key ""simpUser""                 // so if I remove , the user will change to anonymous, and request will be AccessDeniedException             }         }         return message;     }  } ```  ## 3.3 Subscribe and Send from front-end js ```javascript        connectWebSocket() {             let socket = new SockJS(this.baseUrl+'/sockJs');             this.stompClient = Stomp.over(socket);                         this.stompClient.connect({}, function (frame) {               console.log('Connected: ' + frame)             });           }          subscribeLoginUserMessage(){            var headers = {                 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTA2OTk0MTYsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI0NzNjOTVlYy1iNjUwLTQ2OTUtOTVhMy00ODYzZjRjOWZjOGQiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.YH6yChvdATn1vMonbc0OhSgI_kTi3KeIzgCldypInLg'             };              this.stompClient.subscribe(""/user/queue/userInfo"", function (e) {               let data = JSON.parse(e.body)               console.log('login user p2p message response', data)              }, headers);         }         userInfo(){           let data = {}           var headers = {                 'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTA2OTk0MTYsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI0NzNjOTVlYy1iNjUwLTQ2OTUtOTVhMy00ODYzZjRjOWZjOGQiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.YH6yChvdATn1vMonbc0OhSgI_kTi3KeIzgCldypInLg'             }            this.stompClient.send(""/app/user/info"", headers, JSON.stringify(data));         } ``` ## 3.4 Controller method which handle the send request ```java     @MessageMapping(""/user/info"")     @SendToUser(value = ""/queue/userInfo"", broadcast = false)     public String userInfo(@AuthenticationPrincipal PassUser passUser) {         log.info(""push user info""：passUser={}"", JsonUtil.toJsonString(passUser));         return JsonUtil.toJsonString(passUser);     } ``` or ```java @MessageMapping(""/user/info"")     public void userInfo2(Principal passUser) {         log.info(""get user info：passUser={}"", JsonUtil.toJsonString(passUser));         simpMessagingTemplate.convertAndSendToUser(passUser.getName(), ""/queue/userInfo"", JsonUtil.toJsonString(passUser));     } ```  ## 3.5 Connect 、Subscribe、Send trace log ``` 2020-05-30 16:00:32.907 DEBUG 5503 --- [nio-8082-exec-7] o.s.w.s.s.t.h.DefaultSockJsService       : Processing transport request: GET http://127.0.0.1:8082/sockJs/info?t=1590825631897 2020-05-30 16:00:32.918 TRACE 5503 --- [nio-8082-exec-8] o.s.w.s.s.s.WebSocketHandlerMapping      : Mapped to HandlerExecutionChain with [org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler@171a6fd1] and 1 interceptors 2020-05-30 16:00:32.919 DEBUG 5503 --- [nio-8082-exec-8] o.s.w.s.s.t.h.DefaultSockJsService       : Processing transport request: GET http://127.0.0.1:8082/sockJs/624/s2bz5lbp/websocket 2020-05-30 16:00:32.920 TRACE 5503 --- [nio-8082-exec-8] o.s.w.s.s.s.DefaultHandshakeHandler      : Processing request http://127.0.0.1:8082/sockJs/624/s2bz5lbp/websocket with headers=[host:""127.0.0.1:8082"", connection:""Upgrade"", pragma:""no-cache"", cache-control:""no-cache"", user-agent:""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36"", upgrade:""websocket"", origin:""http://localhost:8080"", sec-websocket-version:""13"", accept-encoding:""gzip, deflate, br"", accept-language:""zh-CN,zh;q=0.9"", sec-websocket-key:""OM9hoc6/P6BkOGms4TiARg=="", sec-websocket-extensions:""permessage-deflate; client_max_window_bits""] 2020-05-30 16:00:32.920 TRACE 5503 --- [nio-8082-exec-8] o.s.w.s.s.s.DefaultHandshakeHandler      : Upgrading to WebSocket, subProtocol=null, extensions=[] 2020-05-30 16:00:32.924 DEBUG 5503 --- [nio-8082-exec-8] s.w.s.h.LoggingWebSocketHandlerDecorator : New WebSocketServerSockJsSession[id=s2bz5lbp] 2020-05-30 16:00:32.924 TRACE 5503 --- [nio-8082-exec-8] o.s.w.s.adapter.NativeWebSocketSession   : Sending TextMessage payload=[o], byteCount=1, last=true], StandardWebSocketSession[id=ec86194d-cc25-b73e-b5cc-3a5e123e946a, uri=ws://127.0.0.1:8082/sockJs/624/s2bz5lbp/websocket] 2020-05-30 16:00:32.925 TRACE 5503 --- [nio-8082-exec-8] s.w.s.s.t.s.WebSocketServerSockJsSession : Scheduled heartbeat in session s2bz5lbp 2020-05-30 16:00:32.927 TRACE 5503 --- [nio-8082-exec-9] s.w.s.h.LoggingWebSocketHandlerDecorator : Handling TextMessage payload=[CONNECT ac..], byteCount=56, last=true] in WebSocketServerSockJsSession[id=s2bz5lbp] 2020-05-30 16:00:32.928 TRACE 5503 --- [nio-8082-exec-9] o.s.messaging.simp.stomp.StompDecoder    : Decoded CONNECT {accept-version=[1.1,1.0], heart-beat=[10000,10000]} session=null 2020-05-30 16:00:32.928 TRACE 5503 --- [nio-8082-exec-9] o.s.w.s.m.StompSubProtocolHandler        : From client: CONNECT session=s2bz5lbp 2020-05-30 16:00:32.930 DEBUG 5503 --- [boundChannel-38] o.s.m.s.b.SimpleBrokerMessageHandler     : Processing CONNECT session=s2bz5lbp 2020-05-30 16:00:32.932 TRACE 5503 --- [tboundChannel-7] o.s.messaging.simp.stomp.StompEncoder    : Encoding STOMP CONNECTED, headers={version=[1.1], heart-beat=[0,0]} 2020-05-30 16:00:32.932 TRACE 5503 --- [tboundChannel-7] s.w.s.s.t.s.WebSocketServerSockJsSession : Cancelling heartbeat in session s2bz5lbp 2020-05-30 16:00:32.933 TRACE 5503 --- [tboundChannel-7] s.w.s.s.t.s.WebSocketServerSockJsSession : Preparing to write SockJsFrame content='a[""CONNECTED\nversion:1.1\nheart-beat:0,0\n\n\u0000""]' 2020-05-30 16:00:32.933 TRACE 5503 --- [tboundChannel-7] s.w.s.s.t.s.WebSocketServerSockJsSession : Writing SockJsFrame content='a[""CONNECTED\nversion:1.1\nheart-beat:0,0\n\n\u0000""]' 2020-05-30 16:00:32.933 TRACE 5503 --- [tboundChannel-7] o.s.w.s.adapter.NativeWebSocketSession   : Sending TextMessage payload=[a[""CONNECT..], byteCount=53, last=true], StandardWebSocketSession[id=ec86194d-cc25-b73e-b5cc-3a5e123e946a, uri=ws://127.0.0.1:8082/sockJs/624/s2bz5lbp/websocket] 2020-05-30 16:00:32.934 TRACE 5503 --- [tboundChannel-7] s.w.s.s.t.s.WebSocketServerSockJsSession : Scheduled heartbeat in session s2bz5lbp 2020-05-30 16:00:34.839 TRACE 5503 --- [nio-8082-exec-1] s.w.s.h.LoggingWebSocketHandlerDecorator : Handling TextMessage payload=[SUBSCRIBE ..], byteCount=346, last=true] in WebSocketServerSockJsSession[id=s2bz5lbp] 2020-05-30 16:00:34.839 TRACE 5503 --- [nio-8082-exec-1] o.s.messaging.simp.stomp.StompDecoder    : Decoded SUBSCRIBE {client-id=[my-client-id], Authorization=[Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTExNzIwMTUsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI4Y2JlNjBlMi05NjI0LTQ1YmQtOWJjZS0wZjk5ZDRkNGViNmUiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.jNWNuw3EXlm8nFPnmoJEZ0aWmpxfBM9j_CI-Pw2Ds64], id=[sub-0], destination=[/user/queue/userInfo]} session=null 2020-05-30 16:00:34.839 TRACE 5503 --- [nio-8082-exec-1] o.s.w.s.m.StompSubProtocolHandler        : From client: SUBSCRIBE /user/queue/userInfo id=sub-0 session=s2bz5lbp 2020-05-30 16:00:34.839 DEBUG 5503 --- [nio-8082-exec-1] .i.CustomClientInboundChannelInterceptor : webSocket token is Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTExNzIwMTUsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI4Y2JlNjBlMi05NjI0LTQ1YmQtOWJjZS0wZjk5ZDRkNGViNmUiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.jNWNuw3EXlm8nFPnmoJEZ0aWmpxfBM9j_CI-Pw2Ds64 2020-05-30 16:00:34.934 DEBUG 5503 --- [boundChannel-40] .WebSocketAnnotationMethodMessageHandler : Searching methods to handle SUBSCRIBE /user/queue/userInfo id=sub-0 session=s2bz5lbp, lookupDestination='/queue/userInfo' 2020-05-30 16:00:34.934 TRACE 5503 --- [boundChannel-42] o.s.m.s.u.UserDestinationMessageHandler  : Translated /user/queue/userInfo -> [/queue/userInfo-users2bz5lbp] 2020-05-30 16:00:34.934 DEBUG 5503 --- [boundChannel-40] .WebSocketAnnotationMethodMessageHandler : No matching message handler methods. 2020-05-30 16:00:34.934 DEBUG 5503 --- [boundChannel-42] o.s.m.s.b.SimpleBrokerMessageHandler     : Processing SUBSCRIBE destination=/queue/userInfo-users2bz5lbp subscriptionId=sub-0 session=s2bz5lbp user=1 payload=byte[0] 2020-05-30 16:00:38.122 TRACE 5503 --- [io-8082-exec-10] s.w.s.h.LoggingWebSocketHandlerDecorator : Handling TextMessage payload=[SEND clien..], byteCount=345, last=true] in WebSocketServerSockJsSession[id=s2bz5lbp] 2020-05-30 16:00:38.122 TRACE 5503 --- [io-8082-exec-10] o.s.messaging.simp.stomp.StompDecoder    : Decoded SEND {client-id=[my-client-id], Authorization=[Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTExNzIwMTUsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI4Y2JlNjBlMi05NjI0LTQ1YmQtOWJjZS0wZjk5ZDRkNGViNmUiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.jNWNuw3EXlm8nFPnmoJEZ0aWmpxfBM9j_CI-Pw2Ds64], destination=[/app/user/info], content-length=[2]} session=null 2020-05-30 16:00:38.123 TRACE 5503 --- [io-8082-exec-10] o.s.w.s.m.StompSubProtocolHandler        : From client: SEND /app/user/info session=s2bz5lbp 2020-05-30 16:00:38.123 DEBUG 5503 --- [io-8082-exec-10] .i.CustomClientInboundChannelInterceptor : webSocket token is Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTExNzIwMTUsInVzZXJfbmFtZSI6IjEiLCJqdGkiOiI4Y2JlNjBlMi05NjI0LTQ1YmQtOWJjZS0wZjk5ZDRkNGViNmUiLCJjbGllbnRfaWQiOiJ0ZXN0LWNsaWVudC1pZCIsInNjb3BlIjpbImFsbCJdfQ.jNWNuw3EXlm8nFPnmoJEZ0aWmpxfBM9j_CI-Pw2Ds64 2020-05-30 16:00:38.175 DEBUG 5503 --- [boundChannel-43] .WebSocketAnnotationMethodMessageHandler : Searching methods to handle SEND /app/user/info session=s2bz5lbp, lookupDestination='/user/info' 2020-05-30 16:00:38.177 TRACE 5503 --- [boundChannel-43] .WebSocketAnnotationMethodMessageHandler : Found 1 handler methods: [{[/user/info],messageType=[MESSAGE]}] 2020-05-30 16:00:38.179 DEBUG 5503 --- [boundChannel-43] .WebSocketAnnotationMethodMessageHandler : Invoking com.yufei.learn.websocket.controller.SockJsSimpleController#userInfo2[1 args] 2020-05-30 16:00:38.179 TRACE 5503 --- [boundChannel-43] o.s.messaging.handler.HandlerMethod      : Arguments: [com.yufei.learn.websocket.domain.PassUser@16d40e99] 2020-05-30 16:00:38.201  INFO 5503 --- [boundChannel-43] c.y.l.w.c.SockJsSimpleController         : get user info：passUser={""id"":1,""password"":""elvis2020"",""name"":""1"",""enabled"":true,""username"":""1"",""authorities"":[],""credentials"":""elvis2020"",""principal"":""1"",""authenticated"":true,""credentialsNonExpired"":true,""accountNonExpired"":true,""accountNonLocked"":true} 2020-05-30 16:00:38.202 TRACE 5503 --- [boundChannel-43] o.s.m.s.u.UserDestinationMessageHandler  : No active sessions for user destination: /user/1/queue/userInfo  ```","closed","","uyoaix","2020-05-30T07:55:50Z","2022-02-18T19:06:51Z"
"","25677","Insecure use UUID as request parameter","## Enviroment  I use OpenJDK 8 + Spring Boot + Gradle + GNU/Linux.   ## What is the problem?  When parsing the UUID from a parameter you can have a `NumberFormatException` if the user send a malformed id, like as `11111111-1111-1111-1111-111111111111x`. By example:  ```java @GetMapping(""/{id}"") public String test(@PathVariable(""id"") UUID id) { ```  The Spring says:  ``` org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.util.UUID'; nested exception is java.lang.NumberFormatException: For input string: ""111111111111x"" ```  Same problem with any non string type, like as Integer, i need use a regex validation for each mapping, like as:  ```java @GetMapping(""/{id:\d+}"") public String test(@PathVariable(""id"") Integer id) { ```  Or using UUID:  ```java @GetMapping(""/{id:^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$}"") public String test(@PathVariable(""id"") UUID id) { ```  ## What should be the proper execution?  Spring should not return uncontrollable errors directly, this can cause problems if the programmer does not perform all the proper checks on a layer above the controller.  If the controller requires a numeric type value as a parameter, then it should not be executed in the mapping, if the type casting fails then the function should not be executed and it should continue searching for the next controller.  I understand that the mapping is done at setup time and not run time, but this causes uncontrolled and unsolicited values to hit the controller.  Another possible solution is that when configuring the application (from Spring) and generating the route map, you should consider the `@PathVariable` type annotations and obtain the object type of the variable and apply a native filtering as an expression regular, in this way if my controller requires a value of type `Integer`, it should not be executed if a non-numeric `String` type data comes.  It would be a good idea for Spring to avoid incorrect type mapping instead of throwing an exception of type `MethodArgumentTypeMismatchException`.","open","in: web,","yhojann-cl","2020-09-02T13:02:05Z","2022-01-20T18:29:21Z"
"","25132","WebSphereUowTransactionManager causes exception for PROPAGATION_SUPPORTS when timeout is specified","## Context We're upgrading a legacy app from Spring 1.2.8 (yes, for real) to Spring 4.3.6, following best practices and settings things right as we move along. We have everything working up to here except for this bug which required investigation and for which this is the report. Tested on WebSphere 8.5.5 and 9.0. We can't move to Spring 5 yet because of a remaining dependence on Java 7, but I'd be expecting the same behavior from it after looking at the Spring code.  ## Details The app is using XML configuration with per-method transaction management declared like so:            [...]                       [...]                                       PROPAGATION_REQUIRED,timeout_60  Under Spring 4, this results at runtime in WebSphere throwing an exception:       java.lang.IllegalArgumentException: Invalid UOW type: 0          at com.ibm.ws.uow.UOWManagerImpl.setUOWTimeout(UOWManagerImpl.java:706)          at org.springframework.transaction.jta.WebSphereUowTransactionManager.execute(WebSphereUowTransactionManager.java:286)  ## Explanation After investigation, it turns out that Spring's `JtaTransactionManager` tries to use the WebSphere Local Transaction manager (`UOW_TYPE_LOCAL_TRANSACTION`) whenever possible. However, the WAS Local Transaction manager [does not support timeouts](https://www.ibm.com/support/knowledgecenter/SSAW57_9.0.5/com.ibm.websphere.javadoc.doc/web/spidocs/com/ibm/wsspi/uow/UOWManager.html#setUOWTimeout(int,%20int)).   Excerpt from IBM's javadoc:  > Throws: >    java.lang.IllegalArgumentException - Thrown if the specified type of UOW does not support timeout, e.g. UOW_TYPE_LOCAL_TRANSACTION.   ## Why it worked before The Spring 1.2 transaction management was exclusively using the Global Transaction manager, which accepts the declared timeout with no issue.  ## Workaround For now, we'll be using our own custom copy of  `WebSphereUowTransactionManager` that'll d avoid using `UOW_TYPE_LOCAL_TRANSACTION` whenever a timeout is specified for the transaction. Obviously, a baked-in fix would be preferable, I am willing to supply a PR to that effect, although it would be initially against the 4.3 branch.   We'll also be reviewing our declared timeouts for most operations but it is unlikely that we'll get rid of them all.","closed","type: bug,","fralalonde","2020-05-26T18:33:23Z","2020-06-10T09:15:37Z"
"","24971","Bean Name start with Nullable not support ??","## classes that start with Nullable is not support ?  Occasionally I use NullableXXX as a Service name   ```code import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service;  @Service public class NullableService {    @Autowired   DemoBean demoBean;    public void show() {     System.out.println(demoBean);   } } ``` I use spring version is 5.1.12.RELEASE\ 5.1.14.RELEASE \5.2.4.RELEASE  The Exception  like this: ` No qualifying bean of type xx.xxx.xxx.NullableService' available 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:351) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1126) 	at cn.cninfo.day04.App.main(App.java:13) `","closed","for: stackoverflow,","chenwei182729","2020-04-25T14:20:22Z","2020-04-26T09:51:51Z"
"","25743","Efficiency of beanfactory postprocessors execution","## Beanfactory postprocessors for different levels of execution, first get the name, then instantiate! I don't think it's necessary. It can be solved in one cycle!  ### Initial code ```java List orderedPostProcessorNames = new ArrayList(); List nonOrderedPostProcessorNames = new ArrayList();  else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {         orderedPostProcessorNames.add(ppName); }else {        nonOrderedPostProcessorNames.add(ppName); } ``` ### Modified code ```java List orderedPostProcessors = new ArrayList(); List nonOrderedPostProcessors = new ArrayList(); else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {        orderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else {        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } ```  **Please check the submission details for the specific code**  update method `org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List)`","closed","","huangfusuper","2020-09-09T01:07:26Z","2020-09-11T12:49:38Z"
"","25110","Avoid ClassCastException on IllegalArgumentException when invoking sync get cache method","## Avoid some exception cause ClassCastException  Let's take a look at ConcurrentMapCache.java  ```  	@Override 	@Nullable 	public  T get(Object key, Callable valueLoader) { 		return (T) fromStoreValue(this.store.computeIfAbsent(key, k -> { 			try { 				return toStoreValue(valueLoader.call()); 			} 			catch (Throwable ex) { 				throw new ValueRetrievalException(key, valueLoader, ex); 			} 		})); 	}  	@Override 	protected Object fromStoreValue(@Nullable Object storeValue) { 		if (storeValue != null && this.serialization != null) { 			try { 				return super.fromStoreValue(deserializeValue(this.serialization, storeValue)); 			} 			catch (Throwable ex) { 				throw new IllegalArgumentException(""Failed to deserialize cache value '"" + storeValue + ""'"", ex); 			} 		} 		else { 			return super.fromStoreValue(storeValue); 		}  	} ```  It will throw IllegalArgumentException when there is a problem with deserialization, but not ThrowableWrapper class type, when cast to ThrowableWrapper it will cause another exception (java.lang.ClassCastException: java.lang.IllegalArgumentException cannot be cast to org.springframework.cache.interceptor.CacheOperationInvoker$ThrowableWrapper)  So we need a wrap code on this.","closed","in: core,","WEIZIBIN","2020-05-20T02:12:03Z","2020-06-10T09:15:10Z"
"","24869","Align TransactionManagementConfigurer support in TestContext framework with production","## Affects: Spring Framework 4.3.0+  When `@Primary` support was added for `spring-test` in 677a321, the lookup was added before `TransactionManagementConfigurer` lookup and not after as it should have been, given that `TransactionManagementConfigurer` should take higher precedence. In fact maybe it should be the first check even before the `beansOfTypeIncludingAncestors` lookup as the configurer can construct a `TransactionManager` that is not a registered bean (a registered bean could be in the context that is not the one that the configurer will return).  ## Steps to reproduce  Configure a context with a `@Primary TransactionManager` and a `TransactionManagementConfigurer`.  ### Current result  Test uses the `@Primary` annotated bean.  ### Expected result  Test should use the bean provided by `TransactionManagementConfigurer`.","closed","type: enhancement,","friscoMad","2020-04-06T11:00:28Z","2020-05-11T12:05:36Z"
"","25029","PathEditor should interpret empty string as relative empty path","# Version information  Spring-boot version: 2.2.6.RELEASE  # Issue reproduction and actual result  I have some simple constructor-bound `ConfigurationProperties`:  ```java 	package com.example.demo; 	 	import java.nio.file.Path; 	import org.springframework.boot.context.properties.ConfigurationProperties; 	import org.springframework.boot.context.properties.ConstructorBinding; 	import org.springframework.boot.context.properties.bind.DefaultValue;  	@ConfigurationProperties 	@ConstructorBinding 	public class ConfigurationPropertiesWithPathProperty { 		private final Path somePathProperty;  		public ConfigurationPropertiesWithPathProperty(Path somePathProperty) { 			this.somePathProperty = somePathProperty; 		}  		public Path getSomePathProperty() { 			return somePathProperty; 		} 	} ```  This test, in which I try to bind an empty string, fails:  ```java 	package com.example.demo;  	import static org.assertj.core.api.Assertions.assertThat;  	import java.nio.file.Paths; 	import java.util.Collections; 	import java.util.HashMap; 	import java.util.Map; 	import org.junit.jupiter.api.Test; 	import org.springframework.boot.context.properties.bind.BindResult; 	import org.springframework.boot.context.properties.bind.Bindable; 	import org.springframework.boot.context.properties.bind.Binder; 	import org.springframework.boot.context.properties.source.MapConfigurationPropertySource;  	public class PropertiesTest {  		@Test 		void bindsEmptyToPathProperty() { 			Map properties = new HashMap(); 			properties.put(""some_path_property"", """"); 			Binder binder = new Binder(new MapConfigurationPropertySource(properties));  			BindResult bindResult = 					binder.bind("""", Bindable.of(ConfigurationPropertiesWithPathProperty.class));  			assertThat(bindResult.isBound()).isTrue(); 			assertThat(bindResult.get().getSomePathProperty()).isEqualTo(Paths.get("""")); 		} 	} ```  # Additional observations  When I add a `@DefaultValue` to the constructor property:  ```java 	public ConfigurationPropertiesWithPathProperty(@DefaultValue(""some_default"") Path somePathProperty) { 		this.somePathProperty = somePathProperty; 	} ```  The same test fails with an exception. The exception is the same as in spring-projects/spring-boot#21264, but it means that binding to the default value is attempted.  Note that the same issue occurs not only with constructor-bound properties, but java bean binding as well.  # Expected result  An empty string can be bound to a property of `java.nio.file.Path` type resulting in a relative empty path (equal to the result of `Paths.get("""")`).","open","in: core,","jannis-baratheon","2020-04-29T22:22:39Z","2020-05-07T17:21:40Z"
"","25490","ResponseEntity Exception Handling Issues","# Summary - When using `@ExceptionHandler` (or `@ControllerAdvice`), exceptions thrown while writing to a `StreamingResponseBody` are not handled correctly (or at least as I expect them to be...) when the request mapping returns `ResponseEntity` - Exception handling _does_ work as expected when the return type is _just_ `StreamingResponseBody` - It's possible my understanding of how these should work is incorrect, however I haven't seen any evidence yet to point to this  # Description - If a runtime exception occurs while writing to the `StreamingResponseBody` wrapped in a `ResponseEntity` the endpoint _does_ invoke the `@ExceptionHandler` but returns a `500` status with no response body no matter what - If the request mapping returns a `StreamingResponseBody` directly, error handling does work as expected, and the response code and response body are correct - While writing tests for this, I can't get the tests to return anything other than 200 status. While running tests, I also don't see the exception handlers getting invoked. I'm not sure if this is another bug or if my test setup is incorrect. If you hit the endpoints directly in the browser or via CURL, you do see the 500 status with no body. This is my first time using `StreamingResponseBody` so I apologize if I'm just doing things incorrectly - Sample project to reproduce: https://github.com/austinarbor/spring-boot-streaming-response-issue  # Misc - **Spring Boot**: 2.3.1 / 2.3.2 - **Spring Framework**: 5.2.8 - **Java Version**: 11  - [StackOverflow Question](https://stackoverflow.com/questions/63144516/spring-boot-exceptionhandler-with-responseentitystreamingresponsebody-does-no?noredirect=1#comment111687698_63144516)","closed","type: bug,","austinarbor","2020-07-29T21:03:24Z","2020-12-03T18:42:42Z"
"","25237","Cannot find the class under the target package","![Uploading image.png…](picture) idea cannot show target package, so when i run test case, it turns some errors, cannot find org.springframework.aop.target. how should i do","closed","for: stackoverflow,","wukong-yu","2020-06-11T07:28:33Z","2020-06-11T07:43:56Z"
"","25761","the type of the attribute ""configurationClasses""  of class ConfigurationClassParser is LinkedHashMap","![image](https://user-images.githubusercontent.com/6101029/92997739-ee6faa00-f547-11ea-98c6-786cf5efb044.png)  is it better to replace the ""LinkedHashMap"" with ""HashSet""?","closed","in: core,","lwbkfc","2020-09-12T14:34:25Z","2020-09-12T14:51:32Z"
"","25136","ReactorServerHttpRequest to use hostAddress() instead of parsing the ""Host"" header","![image](https://user-images.githubusercontent.com/19886532/82968562-2df9a100-a000-11ea-88c4-f4e0167f83c8.png) Why not just use the original hostaddress first?","closed","status: declined,","spurtAndy","2020-05-27T01:55:34Z","2020-06-17T09:12:05Z"
"","25841","Migrate to JUnit 5.","","closed","","gregturn","2020-09-29T20:29:07Z","2020-09-29T20:29:36Z"
"","25837","5.2.x","","closed","","Oyiersan","2020-09-29T08:59:36Z","2020-09-29T09:00:24Z"
"","25798","debug spring source","","closed","status: invalid,","gitkmw","2020-09-22T13:15:45Z","2020-09-22T13:20:49Z"
"","25779","Upgrade to Kotlin 1.4.10","","closed","type: dependency-upgrade,","snicoll","2020-09-16T12:11:34Z","2020-09-16T12:13:10Z"
"","25772","update from framework","","closed","","bozrahvice","2020-09-14T23:42:51Z","2020-09-14T23:43:18Z"
"","25764","S","","closed","","raydeth","2020-09-14T03:22:24Z","2020-09-14T09:17:21Z"
"","25758","首次提交","","closed","","satan12345","2020-09-12T02:17:06Z","2020-09-12T02:17:28Z"
"","25732","change to deque implementation","","closed","","wind57","2020-09-08T03:16:32Z","2022-02-18T19:06:27Z"
"","25731","Upgrade to Reactor Californium-SR21","","closed","type: dependency-upgrade,","rstoyanchev","2020-09-07T15:40:33Z","2020-09-14T21:25:25Z"
"","25730","Upgrade to Reactor Dysprosium-SR12","","closed","type: dependency-upgrade,","rstoyanchev","2020-09-07T15:38:42Z","2020-09-14T14:44:41Z"
"","25729","Upgrade to RSocket 1.1 M2","","closed","type: dependency-upgrade,","rstoyanchev","2020-09-07T15:35:40Z","2020-09-14T19:12:44Z"
"","25728","Upgrade to Reactor 2020 RC1","","closed","type: dependency-upgrade,","rstoyanchev","2020-09-07T15:34:04Z","2020-09-14T19:12:44Z"
"","25714","5.1.1","","closed","status: invalid,","smokedrinking","2020-09-06T07:40:28Z","2020-09-06T07:53:05Z"
"","25690","Backport UrlPathHelper optimizations","","closed","type: task,","rstoyanchev","2020-09-03T19:52:46Z","2020-09-07T20:46:17Z"
"","25684","Replace StringBuffer with StringBuilder where possible","","closed","in: core,","quaff","2020-09-03T07:14:41Z","2020-09-03T20:40:52Z"
"","25630","Fix typo in websocket.adoc","","closed","type: documentation,","OleksiiKlochko","2020-08-22T17:27:30Z","2020-08-22T20:56:55Z"
"","25617","Upgrade to Kotlin 1.4.0","","closed","type: dependency-upgrade,","snicoll","2020-08-20T08:58:18Z","2020-08-20T09:13:13Z"
"","25605","Expose readOnly information on transaction","","open","in: data,","eitan613","2020-08-17T21:20:13Z","2021-11-25T21:59:20Z"
"","25594","Optimize ObjectUtils.nullSafeHashCode() implementations","","open","in: core,","wind57","2020-08-15T19:17:43Z","2021-04-27T05:06:14Z"
"","25591","Optimize ObjectUtils.nullSafeToString() implementations","","open","in: core,","wind57","2020-08-15T02:49:01Z","2021-04-27T05:06:14Z"
"","25570","implemented issue #25553(Optimize single character equality checks)","","closed","","abhishek-abhi","2020-08-09T11:45:47Z","2022-02-18T19:06:23Z"
"","25567","removed unnecessary comment","","closed","status: declined,","abhishek-abhi","2020-08-07T20:31:28Z","2020-08-09T08:01:26Z"
"","25566","added private constructor as per the design","","closed","status: declined,","abhishek-abhi","2020-08-07T19:47:29Z","2020-08-09T07:59:58Z"
"","25558","fix for issue #25323 with test","","closed","","eitan613","2020-08-07T08:04:24Z","2022-02-18T19:06:23Z"
"","25540","Add necessary semicolons","","closed","status: invalid,","diguage","2020-08-06T02:56:16Z","2020-08-06T15:31:58Z"
"","25537","Fix comment syntax in xml examples","","closed","type: documentation,","diguage","2020-08-06T01:20:37Z","2020-08-06T07:13:29Z"
"","25495","Disable unwanted Kotlin Stdlib dependencies","","closed","","wilkinsona","2020-07-30T15:53:42Z","2020-07-30T16:40:24Z"
"","25478","BooleanComparator cleanup","","open","type: enhancement,","wind57","2020-07-27T16:33:08Z","2021-04-27T05:06:13Z"
"","25468","Spring-framework","","closed","status: invalid,","bfsong","2020-07-24T01:24:41Z","2020-07-24T05:25:31Z"
"","25450","Use StringBuilder instead of StringBuffer in tests","","closed","type: task,","XenoAmess","2020-07-21T15:54:18Z","2020-07-22T08:21:15Z"
"","25441","update from origin","","closed","","obobj","2020-07-21T07:58:34Z","2020-07-23T14:33:01Z"
"","25414","Alignment of CORS default values with 5.x","","closed","type: enhancement,","rstoyanchev","2020-07-18T04:23:50Z","2020-07-20T03:34:00Z"
"","25412","Upgrade to Reactor Californium-SR20","","closed","type: dependency-upgrade,","jhoeller","2020-07-17T16:17:03Z","2020-07-20T13:41:22Z"
"","25396","Fix typo in javadoc","","closed","in: web,","quaff","2020-07-16T01:17:24Z","2020-07-16T06:41:45Z"
"","25395","Fix typo","","closed","","quaff","2020-07-16T00:56:16Z","2020-07-16T06:39:22Z"
"","25376","Upgrade to Reactor Dysprosium-SR10","","closed","type: dependency-upgrade,","rstoyanchev","2020-07-09T08:05:13Z","2020-07-20T13:51:31Z"
"","25373","Upgrade to Reactor 2020.0.0-M2","","closed","type: dependency-upgrade,","rstoyanchev","2020-07-08T16:13:51Z","2020-08-10T17:52:42Z"
"","25351","Fix interface and class names in examples in core-aop doc","","closed","type: documentation,","MaksimKoniukhov","2020-07-01T07:50:34Z","2020-07-02T13:30:32Z"
"","25297","update .gitignore","","closed","","kennylam91","2020-06-22T08:32:55Z","2020-06-22T08:33:55Z"
"","25295","5.2.x","","closed","status: invalid,","sslm9527","2020-06-20T17:52:23Z","2020-06-21T07:52:06Z"
"","25266","Upgrade to nohttp 0.0.5","","closed","type: dependency-upgrade,","sbrannen","2020-06-17T12:32:59Z","2020-06-17T12:48:36Z"
"","25251","Fix syntax in validation examples","","closed","type: documentation,","wonwoo","2020-06-15T04:45:09Z","2020-06-15T13:00:13Z"
"","25211","Upgrade to Reactor Californium-SR19","","closed","type: dependency-upgrade,","jhoeller","2020-06-08T17:55:43Z","2020-06-10T17:54:58Z"
"","25210","Upgrade to Reactor Dysprosium-SR8","","closed","type: dependency-upgrade,","jhoeller","2020-06-08T17:53:50Z","2020-06-08T18:27:49Z"
"","25192","Fix obsolete link in Kotlin docs","","closed","type: documentation,","LinkedList","2020-06-05T11:45:17Z","2020-06-05T12:12:44Z"
"","25187","5.1.x","","closed","","goupan1996","2020-06-04T18:01:16Z","2020-06-04T18:43:14Z"
"","25137","Fix URI pattern example in webflux.adoc","","closed","type: documentation,","limo520","2020-05-27T02:30:57Z","2020-05-27T14:33:27Z"
"","25127","spring启动实例","","closed","status: invalid,","yanghuaiGit","2020-05-26T06:10:08Z","2020-05-26T07:13:38Z"
"","25085","Upgrade to Reactor 2020.0.0 M1","","closed","type: dependency-upgrade,","rstoyanchev","2020-05-15T13:50:25Z","2020-06-23T19:49:23Z"
"","25078","Upgrade to Dom4j 2.1.3 and Jaxen 1.2.0","","closed","type: dependency-upgrade,","ijliym","2020-05-14T11:01:03Z","2020-06-11T01:50:06Z"
"","25075","Polishing","","closed","","ijliym","2020-05-14T07:05:54Z","2020-08-13T13:37:11Z"
"","25060","Polishing","","closed","","ijliym","2020-05-13T02:41:27Z","2022-02-18T19:06:50Z"
"","25058","Include timeout unit in shutdown failure logging","","closed","type: enhancement,","wilkinsona","2020-05-12T15:38:55Z","2020-05-12T19:09:05Z"
"","25053","Upgrade to RSocket 1.0.0","","closed","type: task,","rstoyanchev","2020-05-12T08:12:01Z","2020-05-12T11:05:05Z"
"","25051","Fix typo in RmiSupportTests","","closed","type: task,","ijliym","2020-05-12T04:39:48Z","2020-05-12T12:19:24Z"
"","25041","加一些基本注释","","closed","","alexsun1024","2020-05-10T07:46:51Z","2020-05-10T08:50:24Z"
"","25040","Fix typo in core-beans.adoc","","closed","type: task,","stqp","2020-05-09T10:00:47Z","2020-05-09T12:06:51Z"
"","25021","Fix @Transactional syntax error in reference manual","","closed","type: task,","quaff","2020-05-07T00:40:14Z","2020-05-08T00:32:01Z"
"","24988","Polishing","","closed","status: declined,","ijliym","2020-04-28T10:12:31Z","2020-04-28T13:12:21Z"
"","24987","Polishing","","closed","status: duplicate,","ijliym","2020-04-28T09:18:57Z","2020-04-28T13:13:34Z"
"","24968","Fix typo in webmvc-functional.adoc","","closed","type: task,","ghost","2020-04-25T07:00:37Z","2020-04-25T07:24:23Z"
"","24912","5.2.5.release","","closed","status: invalid,","felixu1992","2020-04-16T02:25:28Z","2020-04-16T05:20:58Z"
"","24910","PR change for code guru","","closed","","mahalingamsivaprakasam","2020-04-15T19:09:10Z","2020-04-15T19:52:26Z"
"","24906","Fix typo in webflux-functional.adoc","","closed","type: task,","ghost","2020-04-14T11:05:26Z","2020-04-14T13:42:57Z"
"","24899","Closes #24894, don't close input stream after json parsing","","closed","","juzerali","2020-04-13T12:10:06Z","2020-04-14T14:12:43Z"
"","24893","Upgrade to Reactor Californium-SR18","","closed","type: dependency-upgrade,","snicoll","2020-04-10T11:42:33Z","2020-04-27T12:08:45Z"
"","24892","Upgrade to Reactor Dysprosium-SR7","","closed","type: dependency-upgrade,","snicoll","2020-04-10T11:41:43Z","2020-04-27T12:25:41Z"
"","24864","Use single String instead of String[] for varargs argument","","closed","type: task,","chenqimiao","2020-04-04T12:13:02Z","2020-04-05T06:35:40Z"
"","24841","Fix Javadoc in PathPattern","","closed","in: core,","gurpiarbassi","2020-04-01T21:07:34Z","2020-04-02T14:29:43Z"