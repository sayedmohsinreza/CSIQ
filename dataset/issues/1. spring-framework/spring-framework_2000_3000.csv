"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","26661","Merge pull request #1 from spring-projects/master","源码同步","closed","","ganyinglong","2021-03-11T06:40:19Z","2021-03-11T18:05:03Z"
"","26336","学习Spring源码","更新SpringFramework","closed","status: invalid,","liugq2016","2021-01-03T15:43:51Z","2021-01-03T15:47:29Z"
"","26042","Merge pull request #1 from spring-projects/master","更新spring-projects框架源码","closed","status: invalid,","ChovaVea","2020-11-07T01:13:24Z","2020-11-07T07:32:55Z"
"","26041","Merge pull request #1 from spring-projects/master","更新spring-projects框架源码","closed","","ChovaVea","2020-11-07T01:10:47Z","2020-11-07T01:11:39Z"
"","25929","Removes absolute URI check to support Unix Domain Socket URIs","With support coming for [Unix Domain Sockets from io.projectreactor.netty](https://projectreactor.io/docs/netty/1.0.0-RC2/reference/index.html#_unix_domain_sockets_4) URIs no longer need to be absolute.","closed","type: task,","hitchan","2020-10-17T17:06:55Z","2020-10-27T12:55:30Z"
"","25945","Deprecate `StringUtils.isEmpty(Object)` and replace remaining usage (e.g. with `ObjectUtils.isEmpty`)","With static imports code like this looks perfectly fine: ```         List data = ...          if (isEmpty(data)) { ```  But if the import has `StringUtils.isEmpty` the condition above will not work correctly for empty List introducing a hidden, difficult to spot bug.  If you are really keen on keeping this method it would be better to rename it to `isEmptyString` to at least make the error more obvious. (I believe this name also matches the method intention better than generic `isEmpty`.)  But with the #17710 in place I do not think `StringUtils.isEmpty(Object)` is still needed. And should probably be deprecated and eventually removed.","closed","type: enhancement,","sabi0","2020-10-21T09:05:36Z","2020-10-21T14:10:52Z"
"","26487","Add application/vnd.google.protobuf to ProtobufCodecSupport","While RSocket spec supports `application/vnd.google.protobuf` as a Well-known MIME Type, Protobuf Codec doesn't. As a result, Spring RSocket app that has `ProtobufDecoder` configured can not receive a payload with `application/vnd.google.protobuf` data mime type. https://github.com/rsocket/rsocket/blob/master/Extensions/WellKnownMimeTypes.md","closed","type: enhancement,","making","2021-02-01T13:55:53Z","2021-02-17T02:58:32Z"
"","26144","Introduce @ConfigurationForTest analogous to Spring Boot's @TestConfiguration","When writing tests, it is possible to make static inner classes annotated with Configuration, and have them automatically picked up.  However, if you both have the same package structure for your tests as the app, and employ classpath scanning in the app, if you now point your ContextConfiguration to a app Configuration that specify classpath scanning, these inner classes will also be picked up by the classpath scanning. This is unfortunate when you have multiple such tests in the same package, as all of them then will be picked up, not only the one for the current test.  Suggestion: Make a specific @ConfigurationForTest that will automatically be picked up by the test, but _not_ by the classpath scanning. And these should be picked up even if you specify a specific set of classes in the ContextConfiguration annotation, see comment in parenthesis in #26142..","open","status: feedback-provided,","stolsvik","2020-11-23T22:35:36Z","2020-11-24T20:07:47Z"
"","26141","Find all local @TestExecutionListeners annotations on a test class","When using TestExecutionListeners, I have multiple times ended up getting severely hampered by the fact that there can (evidently) only be one such annotation per test run - any more, and the latest supersedes the previous.  This is unfortunate as the TestExecutionListener can be used as a meta-annotation. I've tried to make some nice bespoke annotations that can be used in our shop that can be slapped on the test case - but that fails if the test also includes a \@TestExecutionListeners annotation - or a second bespoke annotation that also needs to add itself as a TestExecutionListener.  I don't quite see how this would fit into the existing annotation (as the two modes there - REPLACE_DEFAULTS and MERGE_WITH_DEFAULTS - might not be open for further extension?). Maybe a new AppendTestExecutionListeners?  See also #26142","closed","type: enhancement,","stolsvik","2020-11-23T22:10:42Z","2022-06-07T12:18:40Z"
"","25943","Add binding support to functional servlet and reactive stack","When using regular `@Controller` for both the Servlet as well as the Reactive stack there is support for data binding using `@ModelAttribute` and there is support for deserializing a request body with `@RequestBody`.   When using the functional approach in either the Servlet or Reactive stack deserializing is supported through the `body` methods of the respective `ServerRequest` interface/implementation. There is no direct support for data-binding. It currently requires, some work, to do data-binding in a method.   ```java public ServerResponse handle(ServerRequest request) {   MyObject instance = new MyObject();   ExtendedServletRequestDataBinder binder = new ExtendedServletRequestDataBinder(instance, ""myObject"");   binder.bind(request.servletRequest());   return ServerResponse.ok().render(""view"", instance).build();. } ``` Although this will work it requires more knowledge of the internal of data binding then one should need.   It would be nice if there would be a supporting `bind` method(s) to support binding to a type like   ```  T bind(Class bindType);  T bind(Class bindType, String objectName); ```  Which would reduce the code to something like this  ```java public ServerResponse handle(ServerRequest request) {   MyObject instance =request.bind(MyObject.class, ""myObject"");   return ServerResponse.ok().render(""view"", instance).build();. } ```  This could use the already available `WebDataBinder` implementations to do the binding (at least the reactive stack has a special `DataBinder` the functional servlet one needs to be created).","open","type: enhancement,","mdeinum","2020-10-21T06:51:45Z","2021-11-01T14:36:35Z"
"","26180","Connection reset exception triggers another SQLException in SingleConnectionDataSource","When using `SingleConnectionDataSource` with Oracle JDBC 19.3.0.0 driver, and if connection is externally closed causing `java.io.IOException: Connection reset by peer`, this triggers another exception in `JdbcTemplate#execute()`  catch clause while translating the former: ``` o.s.j.s.SQLErrorCodesFactory - Error while extracting database name - falling back to empty error codes org.springframework.jdbc.support.MetaDataAccessException: Could not get Connection for extracting meta-data; nested exception is org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: Connection was closed in SingleConnectionDataSource. Check that user code checks shouldClose() before closing Connections, or set 'suppressClose' to 'true' 	at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:345) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:373) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.SQLErrorCodesFactory.getErrorCodes(SQLErrorCodesFactory.java:215) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.setDataSource(SQLErrorCodeSQLExceptionTranslator.java:137) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.(SQLErrorCodeSQLExceptionTranslator.java:100) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.JdbcAccessor.getExceptionTranslator(JdbcAccessor.java:122) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1443) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:633) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:862) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:883) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:321) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] (...) Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: Connection was closed in SingleConnectionDataSource. Check that user code checks shouldClose() before closing Connections, or set 'suppressClose' to 'true' 	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:82) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:336) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	... 43 more Caused by: java.sql.SQLException: Connection was closed in SingleConnectionDataSource. Check that user code checks shouldClose() before closing Connections, or set 'suppressClose' to 'true' 	at org.springframework.jdbc.datasource.SingleConnectionDataSource.getConnection(SingleConnectionDataSource.java:167) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:158) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:116) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:79) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:336) ~[spring-jdbc-5.2.6.RELEASE.jar:5.2.6.RELEASE] 	... 43 more ``` Spring Framework: v5.2.6","open","in: data,","abysas","2020-11-30T21:06:58Z","2021-11-10T11:38:10Z"
"","26261","No originalFilename in MockMultipartFile now leads to add it just as part","When using `MockMultipartFile` with an empty `originalFilename` (`""""`), it now gets added to multi part requests just as a part, not as a file. When migrating from Spring Boot 2.3 to 2.4.1, this made my `MockMvc` test fail for a controller using a `@RequestPart MultipartFile` parameter causing a longer debugging session :-) It would be nice, if there had been a check (exception), that empty `originalFilename`s are no longer supported for  `MockMultipartFile`s.  If the nullability of the `originalFilename` in `MultipartFile` is intended, `org.springframework.web.multipart.support.StandardMultipartHttpServletRequest#parseRequest` seems to be broken as it recognizes parts without filename not as files, so that they don't match `MultipartFile` parameters.","closed","type: regression,","markusheiden","2020-12-12T12:48:36Z","2021-01-14T04:58:18Z"
"","26196","Close all ApplicationContexts in the TestContext framework after all tests have been executed","When using ```@SpringBootTest``` with JUnit Jupiter a pitest user had a problem when executing tests with pitest (see https://github.com/hcoles/pitest/issues/827). As far as my analysis brought me the cause is Spring Frameworks TestContext caching. Spring caches all application contexts loaded in a static variable and reused them among different tests and test classes (```TestContextManager```). Unfortunately Spring does not cleanup after all(!) tests have been run assuming the JVM will be terminated immediately after tests have been executed (which in turn triggers the automatic closing behavior for application contexts). This might hold for surefire or IDE starting those tests. But Pitest reuses the JVM instance for different test suite executions (multiple invocations of JUnit Jupiter's ```Launcher.execute()``` inside the same JVM) . Thus the cached application contexts stay there and interfere with future test runs.  On the other hand Testcontainers integrates with the JUnit Jupiter Engine and uses ClosableResource hook to cleanup containers afterwards.  I've created a JUnit extension cleaning up application contexts on shutdown as a proof of concept. See [SpringBootCleanup](https://github.com/StefanPenndorf/pitTestcontainers/blob/sprint-test-context-cleanup-poc/src/test/java/com/example/pitTestcontainers/pets/SpringBootCleanup.java) in the sample project originally provided by @jaguado-arima .  @DirtiesContext will have the same effect here and I didn't notice any differences in performance regarding this simple example. But I think it's a bad idea to add ```@DirtiesContext``` to all test classes only to be able to use pitest... if you're relying on application context caching to reduce overall testing time for a huge test suite adding ```@DirtiesContext``` to all tests for the sake of mutation testing will slow down test execution (Springs context cache has been implemented for a reason...).  @sbrannen  If you consider changing the behavior as suggested I can also provide a pull request implementing the necessary changes for ```SpringExtension```.","open","type: enhancement,","StefanPenndorf","2020-12-01T17:23:04Z","2022-08-02T07:27:12Z"
"","26669","WebFlux annotation Controller Mono empty unified response processing","When the Mono processing result is empty, add a unified response result. A single Mono can use ****IfEmpty to implement this logic. Api of function can use HandlerFilterFunction. I now use annotation @RequestMapping, how should I implement it, and add a unified response result. Thank you for your time!","closed","for: stackoverflow,","liuzhongkai","2021-03-12T06:41:06Z","2021-03-12T15:49:56Z"
"","26331","ExceptionHandlerMethodResolver is checking only the first level of cause","When the `ExceptionHandlerMethodResolver` cannot handle the high-level exception, it tries only the first level of `cause`. In cases when there is a long cause chain, it will miss the most nested exceptions.  My real situation is: `CompletionException` -> `feign.RetryableException` -> `UnknownHostException`  The handler does not reach the root cause: `UnknownHostException`.   In my opinion, the correct approach would be iterating all the exceptions until the end is reached.  https://github.com/spring-projects/spring-framework/blob/5c1176786c9f0d02aa3db00ba9c5dba19a526ac2/spring-web/src/main/java/org/springframework/web/method/annotation/ExceptionHandlerMethodResolver.java#L134-L139","closed","status: invalid,","dinhani","2020-12-31T19:51:34Z","2021-01-02T17:25:30Z"
"","26850","Update ForwardedHeaderTransformer.java","when set spring.webflux.base-path  and use Spring's support for handling forwarded headers. ForwardedHeaderTransformer should combine X-Forwarded-Prefix with base-path in #apply","closed","status: invalid,","Been24","2021-04-23T02:51:23Z","2021-05-07T08:47:39Z"
"","26828","InvalidPathException in log when running SpringBootTest with NIO Path property on Windows","When running following test, an InvalidPathException is logged with warn level. Test completes successfully, however the exception in log is quite misleading. ```java @SpringBootTest public class MockServletTest { 	@SpringBootApplication 	public static class TestContext { 		@Value(""C:\\tmp"") 		private Path path; 	} 	@Autowired 	private TestContext testContext; 	@Test 	public void testPath() { 		Assertions.assertEquals(Paths.get(""C:\\tmp""), testContext.path); 	} } ``` ``` WARN 17328 --- [           main] o.s.b.t.m.w.SpringBootMockServletContext : Could not get URL for resource src/main/webapp/C:/tmp  java.nio.file.InvalidPathException: Illegal char <:> at index 17: src\main\webapp\C:\tmp 	at sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182) ~[na:1.8.0_252] 	... 	at java.io.File.toPath(File.java:2234) ~[na:1.8.0_252] 	... 	at org.springframework.mock.web.MockServletContext.getResource(MockServletContext.java:332) ~[spring-test-5.3.6.jar:5.3.6] 	at org.springframework.boot.test.mock.web.SpringBootMockServletContext.getResource(SpringBootMockServletContext.java:90) [spring-boot-test-2.4.5.jar:2.4.5] 	at org.springframework.web.context.support.ServletContextResource.exists(ServletContextResource.java:104) [spring-web-5.3.6.jar:5.3.6] 	at org.springframework.beans.propertyeditors.PathEditor.setAsText(PathEditor.java:104) [spring-beans-5.3.6.jar:5.3.6] 	... ``` Test environment is spring boot 2.4.5 on Windows. The exception does not appear when running the application itself (i.e. outside of test)  Seems like this was already reported [in this issue](https://github.com/spring-projects/spring-framework/issues/23717) and specifically [this comment](https://github.com/spring-projects/spring-framework/issues/23717#issuecomment-553228597), but it is still there. As said above, it is not affecting test result (test passes), it's just unexpected to see the exception when checking test logs, so the fix would be a 'nice to have' feature.","closed","type: enhancement,","kascaks","2021-04-20T12:40:48Z","2021-05-11T13:50:41Z"
"","25935","spring-web async restful api not support executor with Callable","when returning with a Callable response in a controlller method, I find it will use default AsyncTaskExecutor with thread name prefix ""MvcAsync""。 I create a AsyncTaskExecutor, but find I can not be injected into WebAsyncTask with Callable way.  I think when creating a WebAsyncTask with Callable parameter, it should should get a bean with default executorName of type AsyncTaskExecutor.","closed","status: invalid,","yangelaboy","2020-10-19T10:45:08Z","2020-10-20T10:01:11Z"
"","26799","Support empty file uploads with HtmlUnit and MockMvc","When one uses HtmlUnit as a Web Client for tests, the `HtmlUnitRequestBuilder` can't cope with empty file input fields. It just tries to access the field instance and throws a `NullPointerException`.  [HtmlUnit produces an `KeyValuePair` with a `null`](https://github.com/HtmlUnit/htmlunit/blob/e0a9e1afe59680a7dbcfe96097d63b0dcfb83855/src/main/java/com/gargoylesoftware/htmlunit/html/HtmlFileInput.java#L105) file (so the `file` variable is explicitly set to `null`). However the [current implementation](https://github.com/spring-projects/spring-framework/blob/b73eb51cb1a2588f456f25598bdf8447ff59bf18/spring-test/src/main/java/org/springframework/test/web/servlet/htmlunit/HtmlUnitRequestBuilder.java#L376) in Spring doesn't cope well with that field being `null`, which results in a `NullPointerException` being thrown.  I guess an empty file input field should just be ignored, so maybe the best way to deal with it would be something along the lines of:  ```java if (pair.getFile() == null) continue; ```  because I don't think we should drop to the default handling of `request.addParameter(param.getName(), param.getValue());` a few lines later.  For reference, I think the problem was introduced in [this pull request](https://github.com/spring-projects/spring-framework/pull/24926) (1 year) where as HtmlUnit has this behavior probably longer (the last change on the line was 4 years before). Which is why I think it makes probably more sense to fix it here.","closed","type: bug,","tloist","2021-04-13T14:33:13Z","2021-05-07T14:40:43Z"
"","26230","Ability to correlate ByteBuf leak records to log messages for a specific request","When Netty's `ResourceLeakDetector` prints a report about leaked buffers, there is currently no way to match those to log messages for the request where the ByteBuf was created. We can use `ByteBuf#touch` with the log prefix for the request (based on the channel id) when debug logging is enabled, similar to what [Reactor Netty does](https://github.com/reactor/reactor-netty/blob/f6231fb0e41a3725e5b29e834e68af55dffb2117/reactor-netty-core/src/main/java/reactor/netty/channel/FluxReceive.java#L336-L345).","closed","type: enhancement,","rstoyanchev","2020-12-07T13:11:59Z","2020-12-07T23:02:56Z"
"","26681","Body recreation via getBodyFromServletRequestParameters for x-www-form-urlencoded POST is incorrect","When injecting the `@RequestBody` for `x-www-form-urlencoded` POST requests, Spring tries to recreate the original body payload via `javax.servlet.ServletRequest.getParameterMap()` in `org.springframework.http.server.ServletServerHttpRequest#getBodyFromServletRequestParameters`.  This operation is imperfect because there the URL encode operation does not entirely revert the previous decoding. An example is the `%2A` <-> `*` enconding/decoding. `%2A` is decoded into `*` but `getBodyFromServletRequestParameters` fails to transform it back into `%2A`, thus failing to produce the exact original payload. This is critical for for example, validating payload signatures, which require the exact same content that was used by the client that made the request.  Version: Spring Boot 5.2.3","open","in: web,","andredasilvapinto","2021-03-13T01:48:34Z","2021-11-10T12:28:01Z"
"","26581","fix initialization of spring-batch tables with datasource in auto-commit mode false","When initialize spring-batch tables with postgresql datasource in auto-commit mode false, the tables are not created in the database.  In ScriptUtils.executeSqlScript, after executing statement, there is not an explicit commit. So that, when postgresql datasource is in auto-commit mode false, transaction is not committed  I added an explicit commit after executing statement when auto-commit mode is false  - Fixes #27008","closed","status: declined,","nguyensach","2021-02-21T14:54:18Z","2021-10-13T17:31:14Z"
"","26587","Graceful way to handle checked exception for Cache operations","When in a spring boot application, Hazelcast is used as a distributed cache, there are some times that it is forgotten to be changed the serialVersionUID on the objects that are cached and this has as a result to have way a lot of exceptions and most probably alerts to go crazy from the error bellow.  ```    java.io.InvalidClassException: com.company.service.server.domain.SomeObject; local class incompatible: stream classdesc serialVersionUID = -5387655287348283785, local class serialVersionUID = -1803841624490656210 	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) 	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2002) 	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1849) 	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2159) 	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1666) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:502) 	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:460) 	at com.hazelcast.internal.serialization.impl.JavaDefaultSerializers$JavaSerializer.read(JavaDefaultSerializers.java:84) 	at com.hazelcast.internal.serialization.impl.JavaDefaultSerializers$JavaSerializer.read(JavaDefaultSerializers.java:77) 	at com.hazelcast.internal.serialization.impl.StreamSerializerAdapter.read(StreamSerializerAdapter.java:48) 	at com.hazelcast.internal.serialization.impl.AbstractSerializationService.toObject(AbstractSerializationService.java:187) 	at com.hazelcast.map.impl.proxy.MapProxySupport.toObject(MapProxySupport.java:1237) 	at com.hazelcast.map.impl.proxy.MapProxyImpl.get(MapProxyImpl.java:120) 	at com.hazelcast.spring.cache.HazelcastCache.lookup(HazelcastCache.java:162) 	at com.hazelcast.spring.cache.HazelcastCache.get(HazelcastCache.java:67) ``` I was trying to find a way to handle this better and centrally. So every time that something similar will happen we will just evict the incompatible object from cache through the code.  I found that spring boot provides an interface to override for error handing which is: org.springframework.cache.interceptor.CacheErrorHandler .  ```java package org.springframework.cache.interceptor;  import org.springframework.cache.Cache; import org.springframework.lang.Nullable;  public interface CacheErrorHandler {     void handleCacheGetError(RuntimeException var1, Cache var2, Object var3);      void handleCachePutError(RuntimeException var1, Cache var2, Object var3, @Nullable Object var4);      void handleCacheEvictError(RuntimeException var1, Cache var2, Object var3);      void handleCacheClearError(RuntimeException var1, Cache var2); }  ```  But this interface is only for handing runtime exceptions and not checked exceptions as the InvalidClassException is.   So I was curious why this CacheErrorHandler is so specific for runtime exceptions and not for all kind of exceptions. In that way, someone can choose how to handle them centrally and nicely.","closed","status: feedback-provided,","Pavlmits","2021-02-22T11:10:05Z","2021-02-22T16:31:20Z"
"","25895","@EnableCaching(mode= AdviceMode.ASPECTJ)  doesn't work for me","When I write a java @Aspect   ,It's work fine. but the  @EnableCaching does nothing, even no Exception is threw out      the pom:  ```      1.8     1.8     1.8     UTF-8     2.3.3.RELEASE     Hoxton.SR8    ```  the cache config :  ```java @Configuration @EnableCaching(mode= AdviceMode.ASPECTJ) @EnableLoadTimeWeaving() public class CacheConfig {    @Bean   public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {       RedisCacheConfiguration conf= ....        return rcm;   } } ```    the service method :  ```   @Cacheable(cacheNames = ""bargain:product"", key=""#id"" )   public User get(long id){    .....  } ```","open","in: core,","case0079","2020-10-11T19:04:33Z","2021-11-10T09:51:28Z"
"","26330","The response has a duplicate ""Content-Length"" header when get by range header","When I use Undertow as server , and make a range request, the response will have two ""Content-Length"" header.  ## request  > GET /inspection/api/v1/binary/1568 HTTP/1.1 > Host: inspection.lubansoft.net:58888 > Connection: keep-alive > Pragma: no-cache > Cache-Control: no-cache > User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 > Accept: */* > Accept-Encoding: identity > Accept-Language: zh-CN,zh;q=0.9 > Range: bytes=0-65535  ## response  > HTTP/1.1 206 Partial Content > Expires: 0 > Cache-Control: no-cache, no-store, max-age=0, must-revalidate > X-XSS-Protection: 1; mode=block > Pragma: no-cache > Content-Disposition: form-data; name=""attachment""; filename*=UTF-8''%E8%AF%84%E5%AE%9A%E8%A1%A810.3.2%20%E6%98%8E%E6%B4%9E%E6%B5%87%E7%AD%91%E5%88%86%E9%A1%B9%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F%E6%A3%80%E9%AA%8C%E8%AF%84%E5%AE%9A%E8%A1%A8%28SG%29.pdf > Accept-Ranges: bytes > Date: Mon, 21 Dec 2020 13:02:45 GMT > Connection: keep-alive > Content-Language: zh-CN > X-Frame-Options: SAMEORIGIN > ETag: ""10"" > Vary: Origin > Vary: Access-Control-Request-Method > Vary: Access-Control-Request-Headers > Last-Modified: Mon, 21 Dec 2020 06:02:31 GMT > Content-Range: bytes 196608-212611/212612 > X-Content-Type-Options: nosniff > Content-Length: 212612 > Content-Length: 16004 > Content-Type: application/pdf   in response header, Content-Length has two values , and chrome will have net::ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH error    `org.springframework.web.servlet.resource.ResourceHttpRequestHandler` actually writes the content-length twice. Once, with the entire content-length and then later on, if a partial-content response, with the range length.  Tomcat handles this just fine accepting the last content-length set as the authoritative content-length and writes it back to the client.  Undertow seems to assume all headers are multi-value and writes both content-length headers back to the client.","closed","type: bug,","lmtoo","2020-12-31T12:19:36Z","2021-01-06T19:51:59Z"
"","26391","add module","when I use source of spring-framework, the gradle build task pass though, but there was error like below whether I add a module what should I do    ![截屏2021-01-15 下午9 09 33](https://user-images.githubusercontent.com/47267802/104731158-4298ce00-5776-11eb-9bf3-aec323778f5d.png)  ![截屏2021-01-15 下午9 13 39](https://user-images.githubusercontent.com/47267802/104731414-9e635700-5776-11eb-9337-0d1edc0b36c2.png)","closed","for: stackoverflow,","JayisGH","2021-01-15T13:14:36Z","2021-01-15T13:31:17Z"
"","25865","Feature Request: support object mapping application/x-www-form-urlencoded requests in WebFlux","When handling a `application/x-www-form-urlencoded` request, the `FormHttpMessageReader `can only decode them to a `MultiValueMap`. It would be very useful to be able to decode, and ideally validate, requests like this:  ```     suspend fun export(request: ServerRequest): ServerResponse {         val exportRequest = request.awaitBody()         return ServerResponse.ok().bodyAndAwait(listOf(""someResult"").asFlow())     }  @Validated data class ExcelExportRequest(         @get:NotEmpty val cols: List,         @get:NotEmpty val ids: List ) ```  **Affects:** Spring Webflux 5.2.3","closed","type: enhancement,","MrBuddyCasino","2020-10-07T08:08:47Z","2020-12-07T10:08:33Z"
"","26011","Optimize AbstractBeanFactory.afterPrototypeCreation()","When curVal is of type Set, The instanceof judgment only needs to be performed once, And when the length of the Set is 1, Call method prototypesCurrentlyInCreation.remove() directly.","open","in: core,","hzmpay","2020-11-02T06:16:31Z","2021-11-11T09:32:03Z"
"","25906","AbstractBeanFactory.afterPrototypeCreation method optimization","When curVal is of type Set, The instanceof  judgment only needs to be performed once, And when the length of the Set is 1, Call method prototypesCurrentlyInCreation.remove() directly.","closed","","hzmpay","2020-10-13T08:12:27Z","2022-02-18T19:06:30Z"
"","26382","Cache busting issue when configured ContentVersionStrategy + CssLinkResourceTransformer","When configuring `ContentVersionStrategy` we are experiencing a problem when a `resource` referenced in a css file is modified (url with md5 hash changed) but the `css` file itself remains exactly the same (same md5 hash). We are not getting the last version as the application is rewritting the resource with the same hash (i.e: `style-8736f7fc00b943645acfcde4d1456233.css`) but the actual content is different (different hashes in the rewritten urls inside de css file).   Are we doing something _wrong_?  Is there a way to compute de md5 hash (`ContentVersionStrategy`) after content of the css has been transformed by the `CssLinkResourceTransformer`?","open","status: pending-design-work,","didiez","2021-01-13T11:38:33Z","2021-07-26T11:25:12Z"
"","26671","IllegalArgumentException on Spring Web with particular header.","When client request to spring web with header `Accept: application/xml, */*, */*, */*, */*, */*`, then spring web will meet excpetion and return `HTTP Status 500 – Internal Server Error`. This is a bug, and exception stack is  ```java.lang.IllegalArgumentException: Comparison method violates its general contract!         at java.util.TimSort.mergeLo(TimSort.java:777)         at java.util.TimSort.mergeAt(TimSort.java:514)         at java.util.TimSort.mergeCollapse(TimSort.java:441)         at java.util.TimSort.sort(TimSort.java:245)         at java.util.Arrays.sort(Arrays.java:1512)         at java.util.ArrayList.sort(ArrayList.java:1462)         at org.springframework.http.MediaType.sortBySpecificityAndQuality(MediaType.java:734)         at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:259)```  version Spring Web 5.2.13.RELEASE","closed","status: feedback-provided,","EdAndrew","2021-03-12T14:33:48Z","2021-04-02T15:38:00Z"
"","26670","Webfilter bypass for Mono.empty() in Spring Boot 2.4.1","When applying webfilter, I found that it cannot handle Mono.empty() returned from controllers The below codes (switchIfEmpty) make empty messages return to Mono.empty() directly ``` ## https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java  if (inputStream instanceof Mono) { 	return body 		.singleOrEmpty() 		.switchIfEmpty(Mono.defer(() -> { 			message.getHeaders().setContentLength(0); 			return message.setComplete().then(Mono.empty()); 		})) 		.flatMap(buffer -> { 			Hints.touchDataBuffer(buffer, hints, logger); 			message.getHeaders().setContentLength(buffer.readableByteCount()); 			return message.writeWith(Mono.just(buffer) 					.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)); 		}) 		.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release); } ``` As you know, webfilter can wrap or rewrite the message when controller returns body with data. In case of empty, a developer cannot wrap additional data through webfilter even if it is an empty because empty message is returned directly.  So, I think it would be better to create new function to handle message or to reuse writeWith regardless of value received from controller","closed","","timewizhan","2021-03-12T06:46:44Z","2021-03-30T16:38:05Z"
"","26694","@DirtiesContext not applied when class-level @EnabledIf evaluates to false","When a JUnit 5 test class is annotated with `@EnabledIf` and `@DirtiesContext` with `@EnabledIf`'s property `loadContext` set to `true`, if its expression evaluates to `false`, the context loaded through the annotation is not cleaned up afterwards.  If the expression evaluates to `true` and the tests are actually run, the context is cleaned up correctly.  A workaround is to put `@EnabledIf` on each test method, instead of the class.  I ran into this issue running Kafka container tests conditionally, when Kafka consumers were created through `@EnableAutoConfiguration` and were left over after the test was skipped. They were consuming messages of other tests that would run afterwards, breaking those tests.","closed","type: bug,","igorakkerman","2021-03-17T12:34:56Z","2021-03-19T15:51:54Z"
"","26271","Consistent type resolution handling for NullBean","When a `@Bean` factory returns `null`, a `NullBean` is registered in the context that's not meant to be considered when looking for a candidate by type (only a lookup by name would return it).  Unfortunately, that does not work in at least two cases:  * `org.springframework.beans.factory.config.AutowireCapableBeanFactory#resolveNamedBean` will return such `NullBean` for the type it has been defined against * `org.springframework.beans.factory.ListableBeanFactory#getBeanNamesForType(org.springframework.core.ResolvableType, boolean, boolean)` will do that (used by Spring Boot's `@ConditionalOnMissingBean`.  This was original raised in https://github.com/spring-projects/spring-boot/issues/24448 that contains a sample project.","closed","type: enhancement,","snicoll","2020-12-15T09:18:05Z","2020-12-16T21:29:23Z"
"","26818","org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#processProcedureColumns does not find functions in Postgres 11+","What:  without using SimpleJdbcCall.withoutProcedureColumnMetaDataAccess Postgres in version 11  uses an additional check for functions here: PgDatabaseMetaData.java:1041  This causes a `org.springframework.dao.InvalidDataAccessApiUsageException: Unable to determine the correct call signature - no procedure/function/signature for 'function_name'`  What should change:  org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider#processProcedureColumns should check if its a function or not and use the correct method","closed","status: invalid,","riba2101","2021-04-16T15:53:45Z","2021-04-27T11:38:49Z"
"","26195","Spring DMLC releasing worker tasks based upon a pure inactivity counter","What we need: Spring `DefaultMessageListenerContainer` releasing worker tasks based upon a pure inactivity counter. That is, the counter that counts how many times a ""null"" message has been received. For example, if the _receiveTimeout_ is set to 1 second and the (fictive, to be created) property _maxIdleReceivesPerTask_ is set to 60, the `DefaultMessageListenerContainer` would release the worker task after 60 times subsequently receiving a null value, and thus, be released 60 seconds after the last activity.  ""But this already exists"" : well, there is indeed _idleTaskExecutionLimit_ and the _maxMessagesPerTask_, but if my  understanding is correct, the _maxMessagesPerTask_ has the side effect that it also releases the task when *not* being idle. In those cases the task is immediately re-scheduled, but this is something we want to avoid. In our case we want to set _maxMessagesPerTask_ to ""-1"" but still let the worker task be released after a pre-configured amount of null messages have been received.  Is this change possible?","closed","status: superseded,","koen-serneels","2020-12-01T16:25:06Z","2021-01-26T11:05:44Z"
"","26035","WebFlux missing programmatic handling of MappingJacksonValue","WebFlux, using annotation routing, does not recognize and handle `MappingJacksonValue`.  See demo [here](https://github.com/jnfeinstein/spring-bugs/blob/spring-framework/src/main/kotlin/com/example/demo/DemoController.kt).","closed","type: enhancement,","jnfeinstein","2020-11-05T12:42:08Z","2020-11-06T20:49:30Z"
"","26819","Improve advice on response handling in an ExchangeFilterFunction","We've deprecated the `exchange()` method on `WebClient` but if the response is handled at a lower level, in the `ExchangeFilterFunction` chain, it can lead to similar issues, for example https://github.com/reactor/reactor-netty/issues/1603#issuecomment-821054580. This needs to be better emphasized in documentation..","closed","in: web,","rstoyanchev","2021-04-16T19:00:51Z","2021-04-21T16:28:53Z"
"","25889","Extensible invocation of TcpClient in ReactorNettyTcpClient","We would like to achieve something as basic as sending all Stomp sessions from a specific user to one Stomp relay, while other users may go to other Stomp relays. This should minimize I believe the traffic inside the Artemis cluster.  I know I can use `TcpClient#remoteAddress(Supplier...)` but this is not enough for what we try to achieve. We need to know the context of the incoming connection to know to which `remoteAddr` send that to. I mean, we need to gather the session id / user principals of the incoming session, to decide to which relay it should send that Connect request to.  I know I could extend `ReactorNettyTcpClient` and Override `connect(TcpConnectionHandler)` but then I need to reimplement myself the whole `ReactorNettyHandler` (as this one is private).  Ideally `ReactorNettyTcpClient` should internally allow some sort of `tcpClient resolver`, or at least it should, I think, use a getter for the `TcpClient` (so that I can override the getter myself).  Is this possible at all with the current code base? What would be then the correct way to achieve this?","closed","type: enhancement,","rupebac","2020-10-09T15:35:39Z","2020-10-20T07:20:23Z"
"","26118","Broken WebSocket subscription using simple message broker","We used WebSockets within Spring Boot 2.3.5 using a simple message broker. After the update to Spring Boot 2.4 / Spring Framework 5.3, we noticed that our web socket mechanism is not working anymore. We use the following web socket config:   ```java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {      public void configureMessageBroker(MessageBrokerRegistry config) {         config.enableSimpleBroker(""/topic"", ""/user"");         config.setApplicationDestinationPrefixes(""/app"");         config.setUserDestinationPrefix(""/user"");     }      public void registerStompEndpoints(StompEndpointRegistry registry) {         registry.addEndpoint(""/websocket"");         registry.addEndpoint(""/websocket"").setAllowedOrigins(""http://localhost:8080"").withSockJS();     }      @Bean(name = ""websocketLocaleResolver"")     public SessionLocaleResolver websocketLocaleResolver() {         SessionLocaleResolver websocketLocaleResolver = new SessionLocaleResolver();         websocketLocaleResolver.setDefaultLocale(Locale.GERMANY);          return websocketLocaleResolver;     }  } ```  A look at the `DefaultSubscriptionRegistry` shows that there changed a lot comparing to Spring Boot 2.3.5. We could nail down the issue because we saw that even though our web socket subscription was successful within the `DefaultSubscriptionRegistry`, the method `this.subscriptionRegistry.findSubscriptions(message)` within the `SimpleBrokerMessageHandler` always returns an empty map (in contrast to Spring Boot 2.3).  ```java protected void sendMessageToSubscribers(@Nullable String destination, Message message) { 		MultiValueMap subscriptions = this.subscriptionRegistry.findSubscriptions(message); ... ```  When rolling back to Spring 2.3.5, the same web socket business logic works fine with the old implementations of  `DefaultSubscriptionRegistry` and `SimpleBrokerMessageHandler`.  We also noticed that with Spring Boot 2.3.5 the `DestinationCache` returns a map including a `SessionId` and `SubscriptionId` (expected behavior). Using Spring Boot 2.4.0, the returned LinkedMultiValueMap sessionIdToSubscriptionIds is always empty.  ```java public LinkedMultiValueMap getSubscriptions(String destination) { 			LinkedMultiValueMap sessionIdToSubscriptionIds = this.destinationCache.get(destination); 			if (sessionIdToSubscriptionIds == null) { 				sessionIdToSubscriptionIds = this.destinationCache.computeIfAbsent(destination, _destination -> { 					LinkedMultiValueMap matches = computeMatchingSubscriptions(destination); 					// Update queue first, so that cacheSize <= queue.size( 					this.cacheEvictionPolicy.add(destination); 					this.cacheSize.incrementAndGet(); 					return matches; 				}); 				ensureCacheLimit(); 			} 			return sessionIdToSubscriptionIds; 		} ```","closed","in: messaging,","BenS89","2020-11-19T13:49:04Z","2021-01-18T13:03:40Z"
"","26067","Add cron expression documentation","We should add a section on the supported cron expressions, considering we have quite extensive support as of Spring 5.3.","closed","type: documentation,","poutsma","2020-11-11T09:15:02Z","2020-11-12T14:58:46Z"
"","26680","Add support for Oracle bind marker scheme using R2DBC","We now support Oracle's bind marker scheme that identifies dynamic parameters using names that are prefixed with a colon such as `:P0_myparam`.","closed","type: enhancement,","mp911de","2021-03-15T09:59:12Z","2021-03-15T12:42:51Z"
"","26796","Changelog generation fails as the milestone on GitHub for a release does not contain a `.RELEASE` suffix","We need to update that script to strip the `.RELEASE`  prefix if it is present  See https://ci.spring.io/teams/spring-framework/pipelines/spring-framework-5.2.x/jobs/create-github-release/builds/1#L6024f3e9:45 for a failure.","closed","type: task,","snicoll","2021-04-13T12:07:51Z","2021-05-11T14:21:32Z"
"","26372","X-Forwarded-For header is not acessible for Spring Boot app (2.3.4.RELEASE)","We have updated Spring framework to 5.2.9.RELEASE (from 5.1.5.RELEASE) and Sprint boot to 2.3.4.RELEASE (from 2.1.4.RELEASE). We use X-Forwarded-For for Security Audit logging of the Source IP (Client's IP). Now we are no longer able to access X-Forwarded-For header and this functionality seems to be broken.  Previous Version:  x-forwarded-for 10.206.135.122, 10.91.122.122 x-forwarded-proto http x-forwarded-host cp0704.x.y.z.net x-forwarded-port 8000 x-real-ip 10.91.122.122 content-length 384 x-request-id 9c7d4d3b35705dd905899f13adf973a8 x-original-uri /a/b/c/d?Override=true x-scheme https content-type application/json user-agent PostmanRuntime/7.26.8 accept */* cache-control no-cache postman-token ffbe2fa4-90f9-4ac5-bd2f-8853c33135c5 accept-encoding gzip, deflate, br   After Upgrade:  x-forwarded-proto http x-forwarded-host cp0704.x.y.z.net x-forwarded-port 8000 x-real-ip 10.91.122.122 content-length 384 x-request-id 6024ea0cf66249ad03b3cb33868c94a0 x-original-uri /a/b/c/d?Override=true x-scheme https content-type application/json user-agent PostmanRuntime/7.26.8 accept */* cache-control no-cache postman-token a8e82716-cdc1-4fb6-b0fc-8839eb72eb29","closed","for: stackoverflow,","abhisheksinghblr","2021-01-12T08:50:35Z","2021-01-22T11:32:42Z"
"","26660","Webflux error in Spring Boot 2.4.1: Error while acquiring from reactor.netty.internal.shaded.reactor.pool.SimpleDequePool@4e699e","We got the following error using the WebClient in a Spring Boot 2.4.1 application. It appears to be missing some information and it's hard to tell what's going on.  It only happened once in production and we haven't seen it in our tests.  message:  ``` Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.web.reactive.function.client.WebClientRequestException: Error while acquiring from reactor.netty.internal.shaded.reactor.pool.SimpleDequePool@4e699e; nested exception is java.io.IOException: Error while acquiring from reactor.netty.internal.shaded.reactor.pool.SimpleDequePool@4e699e] with root cause ```   stacktrace:   ``` java.io.IOException: Error while acquiring from reactor.netty.internal.shaded.reactor.pool.SimpleDequePool@4e699e 	at reactor.netty.resources.DefaultPooledConnectionProvider$DisposableAcquire.run(DefaultPooledConnectionProvider.java:239) 	at io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98) 	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:106) 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:832) ```  logger name: org.apache.catalina.core.ContainerBase.[Tomcat].[localhost].[/].[dispatcherServlet] thread name: http-nio-8085-exec-148   It seemed to come as a result of this code:  ```         Mono mono = webClient.get()             .uri(uriBuilder -> {                 uriBuilder.scheme(coreApiBaseUri.getScheme())                     .host(coreApiBaseUri.getHost())                     .port(coreApiBaseUri.getPort())                     .pathSegment(versionPath, ""projects"", ""{id}"", ""series"");                  return uriBuilder.build(projectId);             })             .headers(httpHeaders -> httpHeaders.addAll(incomingHeaders))             .exchangeToMono(clientResponse -> {                 HttpStatus httpStatus = clientResponse.statusCode();                 if (httpStatus.isError()) {                     if (httpStatus != HttpStatus.BAD_REQUEST) {                         log.warn(""Received status {} from core-api while getting series"", httpStatus);                     }                     return clientResponse.bodyToMono(ErrorDTO.class);                 }                 return clientResponse.bodyToMono(CoreApiSeriesDTO.class);             })             .timeout(Duration.ofMillis(1000))             .retryWhen(retryOnConnectionErrorsOr5xx(""Retrying getting series for project {}, attempt {}"", projectId));          Object dto = mono.block();         if (dto == null) {             throw new InternalException(String.format(""No/invalid result for project id %s"", projectId));         } ```          with helper code: ```     private Retry retryOnConnectionErrorsOr5xx(String logString, UUID logStringParam1) {         return Retry             .fixedDelay(3, Duration.ofSeconds(1L))             .filter(exception -> exception instanceof IOException                 || exception instanceof TimeoutException                 || exception instanceof WebClientResponseException                 && ((WebClientResponseException) exception).getStatusCode().is5xxServerError())             .doBeforeRetry(retrySignal -> {                 log.info(logString, logStringParam1, retrySignal.totalRetries());                 log.debug(""Exception in retry: "", retrySignal.failure());             });     } ```","open","status: feedback-provided,","Bas83","2021-03-11T06:03:53Z","2021-11-08T11:37:32Z"
"","26722","Reintroduce single-page HTML version of the reference manual","We get requests (and just got another one) for a single-page HTML version of the Spring Framework documentation. People want it so that they can search the whole thing with Ctrl-F. Since we have no other functionality that offers searching across the multiple document files, that seems like a reasonable approach.  My other concern is that we set the expectation of having a single-page HTML file in other projects that have multi-page output (both Batch and Boot having both multi- and single-page HTML). Readers may reasonably ask why we have that arrangement in those places and not in Framwork.","closed","status: declined,","Buzzardo","2021-03-24T18:54:29Z","2022-07-29T13:08:06Z"
"","26214","WebClient memory leak on DataBufferLimitException","We are using spring-webflux:5.3.1. When we hit data buffer limit and get DataBufferLimitException we see the following in the logs and in the monitoring shows us something that looks like a memory leak.  ``` 13:45:20.076 [reactor-http-nio-2] ERROR reactor.netty.channel.ChannelOperationsHandler - [id: 0x8ea65ae1, L:/127.0.0.1:53820 ! R:localhost/127.0.0.1:53819] Error was received while reading the incoming data. The connection will be closed. io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1 	at io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:74) 	at io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:138) 	at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:100) 	at io.netty.handler.codec.http.DefaultHttpContent.release(DefaultHttpContent.java:92) 	at io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88) 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:349) 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:381) 	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:656) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:832) ```  It's easy to simulate by decreasing maxInMemorySize  ``` val webClient = WebClient       .builder()       .codecs { configurer -> configurer.defaultCodecs().maxInMemorySize(20) }       .build()  webClient.get().uri(""http://localhost:${port()}"").retrieve().bodyToMono(String::class.java).block() ```","closed","in: web,","lukas-krecan","2020-12-04T12:53:04Z","2020-12-04T16:45:31Z"
"","26209","Support java8 optional retrieval and growing in SpEL","we are using SpEL to set some values to a DTO and i have grow null references set to true, and hoping SpEL has support to get and set optionals and also grow null references.   for below code snippet i get following error   ```java org.springframework.expression.spel.SpelEvaluationException: EL1010E: Property or field 'anotherDtoField' cannot be set on object of type 'java.util.Optional' - maybe not public or not writable? ```  when i try updating the optional in the sampleDto it works without any issues  ```java     spelExpressionParser.parseExpression(""#sampleDto.field1='abc'"").getValue(standardEvaluationContext); ```  it would be nice for Spring to take care of setting and getting from optional as any other java field.   ```java       @Test   public void testSpel(){     SpelExpressionParser spelExpressionParser = new SpelExpressionParser(new SpelParserConfiguration(true,true));     StandardEvaluationContext standardEvaluationContext = new StandardEvaluationContext();     SampleDto sampleDto = new SampleDto();     standardEvaluationContext.setVariable(""sampleDto"",sampleDto);     spelExpressionParser.parseExpression(""#sampleDto.field2.anotherDtoField='abc'"").getValue(standardEvaluationContext);     assertEquals(""abc"", sampleDto.getField1());   }    class SampleDto{     private Optional field1;     private Optional field2;     public Optional getField1() {       return field1;     }     public void setField1(Optional field1) {       this.field1 = field1;     }     public Optional getField2() {       return field2;     }     public void setField2(         Optional field2) {       this.field2 = field2;     }   }   class AnotherDto{     private String anotherDtoField;     public String getAnotherDtoField() {       return anotherDtoField;     }     public void setAnotherDtoField(String anotherDtoField) {       this.anotherDtoField = anotherDtoField;     }   } ```","open","in: core,","NaveenGurram","2020-12-03T16:59:50Z","2021-11-10T10:53:13Z"
"","26199","LoadTimeWeaver no longer weaves bean classes annotated with @Component","We are using a combination of XML and Annotation configuration in a Spring web application. After upgrading to Spring 5.3.1 (from Spring 4), some classes are not processed by the AspectJ Load Time Weaver. In our XML configuration we have:  ```xml   ```  But AspectJ weaving only works for a subset of all classes. In particular, it does not work for classes found by component-scan. If the same bean is declared in XML, it works as expected.  We have managed to condense it into a small sample application:  https://github.com/emillundstrm/springaspectjtest  Running `mvn jetty:run` you will find that there is no message about com.acme.spring.TestBean being woven.  However, if you remove the `@Component` annotation from TestBean and instead declare it in ApplicationContext.xml, this is logged:  ``` [WebAppClassLoader@58437801] debug weaving 'com.acme.spring.TestBean' [WebAppClassLoader@58437801] weaveinfo Join point 'method-execution(void com.acme.spring.TestBean.run())' in Type 'com.acme.spring.TestBean' (TestBean.java:11) advised by around advice from 'org.springframework.transaction.aspectj.AnnotationTransactionAspect' (AbstractTransactionAspect.aj:66) [WebAppClassLoader@58437801] debug generating class 'com.acme.spring.TestBean$AjcClosure1' ```  A workaround is using aspectjweaver.jar as `-javaagent`, but that is inconvenient if you don't control the JVM flags.","closed","in: core,","emillundstrm","2020-12-02T13:49:19Z","2021-04-14T13:24:24Z"
"","26394","NoSuchBeanDefinitionException and BeanCreationException when migrating application from spring framework 4.2.4.RELEASE to 5.2.4.RELEASE","We are migrating an application from JBoss EAP 6.4 to JBoss EAP 7.3.  Since compatible spring version for JBoss 7.3 is 5.2.4.RELEASE, we are migrating spring framework from 4.2.4.RELEASE to 5.2.4.RELEASE.  While migrating we are getting different exceptions like below.  ``` NoSuchBeanDefinitionException, BeanCreationException, .IllegalArgumentException: 'Could not find config file (input) named: xxx.properties' cannot be null. Please find below details. nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'xx' available         at org.wildfly.extension.undertow.deployment.UndertowDeploymentService$1.run(UndertowDeploymentService.java:81) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [rt.jar:1.8.0_271]         at java.util.concurrent.FutureTask.run(FutureTask.java:266) [rt.jar:1.8.0_271]         at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at java.lang.Thread.run(Thread.java:748) [rt.jar:1.8.0_271]         at org.jboss.threads.JBossThread.run(JBossThread.java:485) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001] Caused by: java.lang.RuntimeException: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xx' defined in class path resource [config/spring/xx.xml]: Cannot resolve reference to bean 'xx' while setting constructor argument; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'xx' available         at io.undertow.servlet.core.DeploymentManagerImpl.deploy(DeploymentManagerImpl.java:254) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentService.startContext(UndertowDeploymentService.java:96) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentService$1.run(UndertowDeploymentService.java:78) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         ... 8 more Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xx' defined in class path resource [config/spring/xx.xml]: Cannot resolve reference to bean 'xx' while setting constructor argument; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'xx' available         at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:342)         at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:113)         at org.springframework.beans.factory.support.ConstructorResolver.resolveConstructorArguments(ConstructorResolver.java:705)         at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:196)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)         at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879)         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878)         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550)         at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)         at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)         at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103)         at io.undertow.servlet.core.ApplicationListeners.contextInitialized(ApplicationListeners.java:187) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.DeploymentManagerImpl$1.call(DeploymentManagerImpl.java:217) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.DeploymentManagerImpl$1.call(DeploymentManagerImpl.java:186) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:42) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at org.wildfly.extension.undertow.security.SecurityContextThreadSetupAction.lambda$create$0(SecurityContextThreadSetupAction.java:105) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at io.undertow.servlet.core.DeploymentManagerImpl.deploy(DeploymentManagerImpl.java:252) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         ... 10 more Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'xx' available         at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:805)         at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1279)         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:297)         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)         at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:330)         ... 38 more ```  ----  ``` Constructor threw exception; nested exception is java.lang.IllegalArgumentException: 'Could not find config file (input) named: xx.properties' cannot be null         at org.wildfly.extension.undertow.deployment.UndertowDeploymentService$1.run(UndertowDeploymentService.java:81) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [rt.jar:1.8.0_271]         at java.util.concurrent.FutureTask.run(FutureTask.java:266) [rt.jar:1.8.0_271]         at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001]         at java.lang.Thread.run(Thread.java:748) [rt.jar:1.8.0_271]         at org.jboss.threads.JBossThread.run(JBossThread.java:485) [jboss-threads-2.3.3.Final-redhat-00001.jar:2.3.3.Final-redhat-00001] Caused by: java.lang.RuntimeException: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xx' defined in class path resource [config/spring/xx.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [xx]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: 'Could not find config file (input) named: xx.properties' cannot be null         at io.undertow.servlet.core.DeploymentManagerImpl.deploy(DeploymentManagerImpl.java:254) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentService.startContext(UndertowDeploymentService.java:96) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentService$1.run(UndertowDeploymentService.java:78) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         ... 8 more Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xx' defined in class path resource [config/spring/xx.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [xx]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: 'Could not find config file (input) named:xx.properties' cannot be null         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1320)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1214)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)         at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879)         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878)         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550)         at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)         at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)         at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103)         at io.undertow.servlet.core.ApplicationListeners.contextInitialized(ApplicationListeners.java:187) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.DeploymentManagerImpl$1.call(DeploymentManagerImpl.java:217) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.DeploymentManagerImpl$1.call(DeploymentManagerImpl.java:186) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:42) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         at org.wildfly.extension.undertow.security.SecurityContextThreadSetupAction.lambda$create$0(SecurityContextThreadSetupAction.java:105) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504) [wildfly-undertow-7.3.0.GA-redhat-00004.jar:7.3.0.GA-redhat-00004]         at io.undertow.servlet.core.DeploymentManagerImpl.deploy(DeploymentManagerImpl.java:252) [undertow-servlet-2.0.28.SP1-redhat-00001.jar:2.0.28.SP1-redhat-00001]         ... 10 more Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [xx]: Constructor threw exception; nested exception is java.lang.IllegalArgumentException: 'Could not find config file (input) named: xx.properties' cannot be null         at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:216)         at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:87)         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1312)         ... 34 more Caused by: java.lang.IllegalArgumentException: 'Could not find config file (input) named: xx.properties' cannot be null         . 		. 		.         at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) [rt.jar:1.8.0_271]         at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) [rt.jar:1.8.0_271]         at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) [rt.jar:1.8.0_271]         at java.lang.reflect.Constructor.newInstance(Constructor.java:423) [rt.jar:1.8.0_271]         at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:203)         ... 36 more ```","closed","status: feedback-provided,","AshwiniAJadhav","2021-01-17T15:23:38Z","2021-01-18T10:37:12Z"
"","26142","Find all local @ContextConfiguration annotations on a test class","Very similar to issue #26141, I find that ContextConfiguration should be able to _append_ to an existing ContextConfiguration. But this seems to not be possible.  This is unfortunate as the ContextConfiguration can be used as a meta-annotation. I've tried to make some nice bespoke annotations that can be used in our shop that can be slapped on the test case - but that fails if the test also includes a \@ContextConfiguration annotation - or a second bespoke annotation that also needs to add itself as a ContextConfiguration.  This ""only one"" seems like this also holds even if the first specifies initializers, and the other classes.  (What actually still works, though, is the feature where any inner static classes annotated with Configuration is automatically picked up without ContextConfiguration pointing to it: This still works if initializers is specified, but not if classes is specified. The latter seems strange; Would it not be nice if I could point to existing app Configuration classes using the @ContextConfiguration, and then include some test-specific Configuration classes as inner classes without having to also include those in the classes-list?)  Maybe a parameter ""append=true"" would suffice here?","closed","type: enhancement,","stolsvik","2020-11-23T22:15:28Z","2022-06-07T12:18:49Z"
"","26749","beanFactory.getBean(""self"") in FactoryBean.getObject(), get an unreasonable Exception","version: 5.2.12.RELEASE Expect: StackOverflowError or BeanCreationException But: java.lang.NoClassDefFoundError: Could not initialize class org.springframework.beans.factory.BeanCreationException  ```java @Configuration public class Test {     public static void main(String[] args) {         AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Test.class);         System.out.println(context.getBean(""aaa""));     }     @Component(""aaa"")     static class A implements FactoryBean, BeanFactoryAware {         private BeanFactory beanFactory;         @Override         public String getObject() throws Exception {             beanFactory.getBean(""aaa"");             return ""sss"";         }         @Override         public Class getObjectType() {             return String.class;         }         @Override         public void setBeanFactory(BeanFactory beanFactory) throws BeansException {             this.beanFactory = beanFactory;         }     } } ```","open","in: core,","zelsbamboo","2021-04-01T11:59:57Z","2021-11-12T14:16:49Z"
"","26629","Create a CI build and test using GitHub Actions.","Utilize GitHub's CI infrastructure to build and test your project on LTS versions of Java (8 & 11).","closed","status: invalid,","carldea","2021-03-02T17:34:09Z","2021-03-06T16:23:26Z"
"","26466","UriComponentsBuilder '{' '}' may not be encoded although invalid characters","Using the `UriComponentsBuilder`, the `{` and `}` characters can end up in the result if you are not careful (they are the only ones from the invalid printable ascii chars which do this, most probably because they are used for templates, like in `{city}`).  ```shell jshell> UriComponentsBuilder.fromUriString("" \""<>\\^`|][%{}"").encode().build().toUriString() $2 ==> ""%20%22%3C%3E%5C%5E%60%7C%5D%5B%25{}"" // {} not percent encoded at the end  jshell> UriComponentsBuilder.fromUriString("" \""<>\\^`|][%}{"").encode().build().toUriString() $3 ==> ""%20%22%3C%3E%5C%5E%60%7C%5D%5B%25%7D%7B"" // }{ correctly percent encoded at the end  ```   Using `toUri()` instead of `toUriString()` at least does check and throws an exception in the bad case.  ```shell  jshell> UriComponentsBuilder.fromUriString(""}{"").encode().build().toUri() $4 ==> %7D%7B  jshell> UriComponentsBuilder.fromUriString(""{}"").encode().build().toUri() |  Exception java.lang.IllegalStateException: Could not create URI object: Illegal character in path at index 0: {} ```  Using `toUri()` and removing `.encode()` actually makes it encode:  ```shell jshell> UriComponentsBuilder.fromUriString("" \""<>\\^`|][%{}"").encode().build().toUriString() $2 ==> ""%20%22%3C%3E%5C%5E%60%7C%5D%5B%25{}"" // As seen before, with .encode() and .toUriString(): {} not encoded  jshell> UriComponentsBuilder.fromUriString("" \""<>\\^`|][{}"").build().toUri(); $8 ==> %20%22%3C%3E%5C%5E%60%7C%5D%5B%7B%7D // without .encode() and with .toUri(): {} encoded !? ```   With `buildAndExand()`, things are a bit safer, but still there are cases where it lets unencoded chars through.  ```shell  jshell> UriComponentsBuilder.fromUriString(""{a}"").buildAndExpand().toUriString() |  Exception java.lang.IllegalArgumentException: Not enough variable values available to expand 'a' // a bit safer, expand detects the missing argument  jshell> UriComponentsBuilder.fromUriString(""{}"").buildAndExpand().toUriString() $29 ==> ""{}"" // empty brackets are neither encoded nor detected as errors. ```","closed","type: enhancement,","jonenst","2021-01-28T13:30:29Z","2021-02-15T13:49:20Z"
"","26631","Blockhound flags a blocking call when WebFlux serves a static resource","Using Spring Boot WebFlux 2.4.3, there are blocking calls, detected by BlockHound when properties are loaded during the call. Program was run with JDK 11 on Windows 10.  A simple program is attached. It contains a few static images, but when a unexisting image is requested, **BlockHound** detects a blocking call when the framework reads a properties file, to find the configuration for the error handling.  See the test class in the attached program.  [spring-reactor-webflux-blockhound properties.zip](https://github.com/spring-projects/spring-boot/files/6070917/spring-reactor-webflux-blockhound.properties.zip)","closed","type: enhancement,","JanVdloock","2021-03-02T18:31:41Z","2021-07-23T16:02:16Z"
"","26473","The different behaviours due throwing CancellationException using coRouter/RestController in Coroutines","Using Spring Boot 2.4.2  ```@SpringBootApplication class DemoApplication  fun main(args: Array) { 	runApplication(*args) }  @Configuration class Controller { 	@Bean 	fun router() = coRouter { 		GET(""/cancel"") { 			throw CancellationException() 		} 	} }  @RestController class RestController { 	@GetMapping(""/rest-cancel"") 	suspend fun restCancel() : Unit = throw CancellationException() } ```  It is a simple example to reproduce the strange behaviour  When I make a rest call to RestController by using curl I see that in my console: ``` time curl http://localhost:8080/rest-cancel                                                                                                                                                         12:27:21 {""timestamp"":""2021-01-29T09:28:22.932+00:00"",""path"":""/rest-cancel"",""status"":500,""error"":""Internal Server Error"",""message"":"""",""requestId"":""5ef37448-3""} ________________________________________________________ Executed in   22.69 millis    fish           external    usr time    3.35 millis  109.00 micros    3.24 millis    sys time    4.85 millis  739.00 micros    4.11 millis ``` And Spring has logged this exception. This behaviour that I've expected.  Okay, now I request endpoint handled by coRouter: ``` time curl http://localhost:8080/cancel ```  This request is ""in pending"", I don't get a response immediately and even after five minutes.  I've expected the same behaviour as @RestController provided.","open","in: web,","akrikheli","2021-01-29T09:43:06Z","2021-11-10T12:44:56Z"
"","26181","ClientAbortException handling discrepancy between exception and request handlers","Using Spring Boot 2.4.0 and Web MVC, when a client closes the connection before the server completes the response transmission, regular request handlers (e.g., `@GetMapping`) don't log any failures regarding the raised `ClientAbortException` by Tomcat. Whereas, in the case of a `@ExceptionHandler`, a `ClientAbortException` is logged. I think, the very same `ClientAbortException` needs to be suppressed, as is the case in regular request handlers.  Consider the following simple application:  ```java @SpringBootApplication public class MainApplication {      public static void main(String[] args) {         SpringApplication.run(MainApplication.class, args);     }      @RestController     public static class MainController {          private static final String RESPONSE_PAYLOAD;         static {             StringBuilder stringBuilder = new StringBuilder();             for (int i = 0; i < 1_000_000; i++) {                 stringBuilder.append(""foo bar baz "").append(i);             }             RESPONSE_PAYLOAD = stringBuilder.toString();         }          private static final class CustomError extends RuntimeException {}          @GetMapping(""/collapse"")         public String collapse() {             throw new CustomError();         }          @ExceptionHandler(CustomError.class)         public String handleException() {             return RESPONSE_PAYLOAD;         }          @GetMapping(""/work"")         public String work() {             return RESPONSE_PAYLOAD;         }      }  } ```  Note that both handlers (i.e., request and exception) return back the very same payload.  Below I use [toxiproxy](/Shopify/toxiproxy) to simulate the premature connection reset:  ``` # Start the toxiproxy server. $ toxiproxy-server INFO[0000] API HTTP server starting                      host=localhost port=8474 version=2.1.4 ...  # Create a new proxy to simulate the premature connection reset. $ toxiproxy-cli create connectionreset -l localhost:18080 -u localhost:8080 Created new proxy connectionreset  # Configure `connectionreset` proxy to only allow a single byte in downstream.  $ toxiproxy-cli toxic add connectionreset -t limit_data -a bytes=1 Added downstream limit_data toxic 'limit_data_downstream' on proxy 'connectionreset' ```  If I query `http://localhost:18080/work`, nothing gets logged to the server console. Whereas, querying `http://localhost:18080/collapse` causes the following failure in the server:  ``` 2020-11-26 11:12:54.440  WARN 10935 --- [nio-8080-exec-2] .m.m.a.ExceptionHandlerExceptionResolver : Failure in @ExceptionHandler com.vlkan.spring.MainApplication$MainController#handleException()  org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe 	at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:351) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.OutputBuffer.appendByteArray(OutputBuffer.java:746) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:675) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:386) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:364) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:233) ~[na:na] 	at java.base/sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:303) ~[na:na] 	at java.base/sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:281) ~[na:na] 	at java.base/sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125) ~[na:na] 	at java.base/sun.nio.cs.StreamEncoder.write(StreamEncoder.java:135) ~[na:na] 	at java.base/java.io.OutputStreamWriter.write(OutputStreamWriter.java:229) ~[na:na] 	at java.base/java.io.Writer.write(Writer.java:249) ~[na:na] 	at org.springframework.util.StreamUtils.copy(StreamUtils.java:147) ~[spring-core-5.3.1.jar:5.3.1] 	at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:126) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:44) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:227) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:280) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:181) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:78) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:124) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:421) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:75) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:141) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:80) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1321) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1132) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1078) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.lang.Thread.run(Thread.java:835) ~[na:na] Caused by: java.io.IOException: Broken pipe 	at java.base/sun.nio.ch.FileDispatcherImpl.write0(Native Method) ~[na:na] 	at java.base/sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47) ~[na:na] 	at java.base/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:113) ~[na:na] 	at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:79) ~[na:na] 	at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:50) ~[na:na] 	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:466) ~[na:na] 	at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:138) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:101) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:152) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1253) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:764) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketWrapperBase.writeBlocking(SocketWrapperBase.java:584) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:528) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.doWrite(Http11OutputBuffer.java:546) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.filters.IdentityOutputFilter.doWrite(IdentityOutputFilter.java:73) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.Response.doWrite(Response.java:601) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:339) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	... 66 common frames omitted  2020-11-26 11:12:54.443 ERROR 10935 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is com.vlkan.spring.MainApplication$MainController$CustomError] with root cause  com.vlkan.spring.MainApplication$MainController$CustomError: null 	at com.vlkan.spring.MainApplication$MainController.collapse(MainApplication.java:34) ~[classes/:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) ~[na:na] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:197) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:141) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:893) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:807) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1061) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.lang.Thread.run(Thread.java:835) ~[na:na] ```","open","status: feedback-provided,","vy","2020-11-26T10:32:30Z","2022-08-02T12:57:53Z"
"","26028","Use computeIfAbsent to simplify some code","Use computeIfAbsent to simplify some code, in addition, the content of some Javadoc has been adjusted.","open","type: enhancement,","hzmpay","2020-11-04T07:08:58Z","2021-04-27T05:06:15Z"
"","26012","Improve URI/query strings sanitization","Use `StringBuilder.deleteCharAt(int)` and `StringBuilder.delete(int, int)` to handle sanitization more effectively","closed","type: enhancement,","stsypanov","2020-11-02T11:37:12Z","2020-11-04T15:32:44Z"
"","26291","Update DefaultListableBeanFactory's determineHighestPriorityCandidate","Update method determineHighestPriorityCandidate of DefaultListableBeanFactory. Runs define the same priority, but highestPriority.","closed","","york-lee","2020-12-17T01:29:23Z","2022-02-18T19:05:34Z"
"","25953","update fork","update fork","closed","status: invalid,","xiaobaixie","2020-10-22T07:18:52Z","2020-10-22T07:49:05Z"
"","26353","Merge pull request #1 from spring-projects/master","update","closed","status: invalid,","alex6971","2021-01-07T05:08:35Z","2021-01-07T06:06:51Z"
"","26572","Merge pull request #1 from spring-projects/master","updata","closed","","liuhao0813","2021-02-19T23:05:14Z","2022-02-18T19:05:35Z"
"","26871","Add ApplicationEvent constructor for specifying timestamp","Unit testing listener behaviour where the time between events is important is a pain because it is impossible to specify the time of the event.  I don't think there is a way to expose this behaviour in only test code, but I can do so if someone points out how.  Lastly, if the constructor is intentionally left out, it might be good to document this.","closed","type: enhancement,","medwards","2021-04-28T10:48:56Z","2021-05-26T12:33:17Z"
"","26702","Root path resolution for java.nio.Path properties does not work on Linux anymore","Under Spring Boot 2.4.4 having a configuration class with a java.nio.Path field does not map correctly for a root filesystem on Linux if the spring-boot-web-starter is included.  Example application.properties value: my-config.workingPath=/my-working-path  When the above is run on linux with the web starter included, the path is set under the tomcat temp directory, or under the exploded WAR file directory if running on a different application server.  If the path is set to a value such as: c:\\temp\\my-working-path on a Windows machine, there is no issue with or without the web starter dependency.  Creating a ConfigurationPropertiesBinding converter seems to be picked up when running on Windows, but ignored on Linux.  Changing the properties class field from java.nio.Path to String and implementing a custom get method that returns Paths.get(s) works fine on windows and linxu both with and without the web starter included in the project.  Issue does not seem to exist prior to Spring Boot 2.4.4.","closed","in: core,","plc010","2021-03-18T17:55:08Z","2021-04-13T06:45:35Z"
"","26642","WriteResultPublisher does not pass cancel signals","Typically server side response writing shouldn't see cancellation since `ServletHttpHandlerAdapter`  doesn't do that. However it may occur for other reasons such as a `WebFilter` with a timeout operator on the outbound side. Even so in that case the timeout operator would also send an error signal downstream, which reaches `ServletHttpHandlerAdapter`  and completes the `AsyncContetx` and that in turn cancels writing. Nevertheless it is a good idea to support cancellation and to cancel writing immediately.  This was uncovered while investigating #26434.","closed","type: enhancement,","rstoyanchev","2021-03-04T19:08:51Z","2021-03-04T21:03:58Z"
"","25888","SockJsClient does not allow to set serverId","Trying to open sockjs connection using spring SockJsClient. My sockjs server is in production environment and uses serverId mapping. SockJsClient does not allow serverId and implicitly generates some random value (SockJsUrlInfo.getServerId). Allow some customization to pass serverId explicitly. I can't even extend SockJsClient because it does not contain any methods or constructors to override.","open","in: messaging,","OverDrone","2020-10-09T14:19:25Z","2021-11-10T12:30:40Z"
"","26683","Expose @JmsListener endpoint id to annotation-derived listener container (for transaction definition name)","Transaction name is always null when debug logging `@Transactional`` @JmsListener` methods.  This chunk of code in `AbstractPollingMessageListenerContainer `returns null for` getBeanName():`  ```                                 // Use bean name as default transaction name.                                 if (this.transactionDefinition.getName() == null) {                                                 String beanName = getBeanName();                                                 if (beanName != null) {                                                                 this.transactionDefinition.setName(beanName);                                                 }                                 } ```  It should be easy to support by setting the beanName from the endpoint passed into `createListenerContainer(JmsListenerEndpoint endpoint) {  ... }` in `AbstractJmsListenerContainerFactory`.","closed","type: enhancement,","zerocode","2021-03-15T14:18:51Z","2021-03-15T17:04:42Z"
"","26295","Update ReactiveAdapterRegistry to do classpath checks at class initialization","To improve GraalVM native image footprint and compatibility.","closed","type: enhancement,","sdeleuze","2020-12-18T11:11:37Z","2021-01-05T09:03:18Z"
"","26739","spring unexpected behavior because of interceptor exception","To figure out how spring dispatcher servlet works, I make some breakpoints and debug my spring project. However, I found some results are not what I excepted. Below are the code  ``` // controller code @RestController public class HelloController {    @RequestMapping(""/dev/test"")   public Map hello() {     Map result = new HashMap<>();     result.put(""key"", ""value"");     return result;   } } ```  ``` // interceptor public class MyInterceptor extends HandlerInterceptorAdapter {    @Override   public boolean preHandle(HttpServletRequest request, HttpServletResponse response,           Object handler) throws Exception {       return true;   }    @Override   public void postHandle(       HttpServletRequest request,       HttpServletResponse response,       Object handler,       ModelAndView modelAndView)       throws Exception {     System.out.println(""check here"");     throw new RuntimeException(""exception in myinterceptor""); // I intentionally throws exception here   } } ```  ``` // global exception handler @ControllerAdvice public class MyExceptionHandler {      @ResponseBody     @ExceptionHandler     public String handleException(Throwable throwable) {         System.out.println(""throwable is "" + throwable);         return ""aaa"";     } } ``` The result is `{""key"":""value""}aaa`  This is quite strange on the first look, but I can understand since controller successfully returns and may have written the {""key"":""value""} part into outputBuffer. When dispatcher servlet execute interceptor post handle, a RuntimeException is thrown, so myExceptionHandler is called. Exception handler returns aaa, and it is also written to the outputBuffer. I personally think the corrected result should only contains the aaa part, which means the outputBuffer (contents are {""key"":""value""}) should be cleared before aaa is written.  I wonder if the behavior is corrected or is this a bug. Thanks","closed","for: stackoverflow,","heifrank","2021-03-29T02:17:15Z","2021-03-29T10:16:20Z"
"","26282","Update OncePerRequestFilter.isAsyncDispatch to use HttpServletRequest.getDispatcherType()","To ensure that the OncePerRequestFilter works when the servlet API is used directly it would be nice to update `OncePerRequestFilter.isAsyncDispatch` to use `HttpServletRequest.getDispatcherType()`  ```java @Override protected boolean isAsyncDispatch(HttpServletRequest request) {     return request.getDispatcherType() == DispatcherType.ASYNC; } ```  See https://github.com/spring-projects/spring-security/issues/4211","closed","type: enhancement,","rwinch","2020-12-15T20:09:52Z","2021-02-24T20:57:28Z"
"","26807","Remove leftover Javadoc from WebClient","This redundant Javadoc is from commit 5f1e4ffc4f986469c9f665e681bb34e8a7dd09e8  See https://github.com/spring-projects/spring-framework/issues/24611","closed","type: documentation,","mustafau","2021-04-14T21:54:36Z","2021-04-15T10:17:38Z"
"","26260","Replace AtomicReference with AtomicBoolean in AbstractServerHttpResponse.writeWith()","This PR replaces `AtomicReference` with `AtomicBoolean` in `AbstractServerHttpResponse.writeWith()`.","closed","type: task,","izeye","2020-12-12T02:35:36Z","2020-12-12T10:05:37Z"
"","26586","Polish contribution","This PR polishes trivial stuff from bc71cc1a765ab33b0c70487959cc1976fedde0c2.","closed","in: core,","izeye","2021-02-22T04:20:32Z","2021-02-22T10:12:00Z"
"","26070","Polish Javadoc for InjectionMetadata.forElements()","This PR polishes `InjectionMetadata.forElements()` by removing an unnecessary branch and updating outdated Javadoc.","closed","in: core,","izeye","2020-11-11T13:15:57Z","2020-11-12T13:06:11Z"
"","26197","Polish ConfigurationClassPostProcessorTests","This PR polishes `ConfigurationClassPostProcessorTests` by complying JUnit Jupiter's convention and using AssertJ's `contains()`.","closed","in: core,","izeye","2020-12-02T01:02:56Z","2020-12-02T14:41:46Z"
"","25950","UriBuilder - Correct the treatment of Optional types.","This PR is an alternative to #25925 and all the discussion on that PR remains relevant.  This PR is an improvement because: 1. it retains the existing public API without alteration, and 2. it applies a consistent treatment even when an Optional is included amongst a list of arguments (varargs).  I have taken the liberty of updating the interface documentation.  It previously stated  `If no values are given, the resulting URI will contain the query parameter name only, ...`  I have complimented this by stating that   `If the only values given are {@code Optional} instances for which {@code isPresent()} returns {@code false} then the query parameter name will not be added.`  My justification is that calling the method with an explicit null (no parameters are given) is deliberately different from calling the method with one or more instances of Optional.empty.  Furthermore, please note that the current implementation is deficient when invoked with one or more Optionals as arguments, in that the text written to the URL is the .toString() of the Optional instance and not the .toString() of the value it contains; invoke queryParam(""name"", Optional.of(""value"")) and what is added to the URL is ""?name=Optional[value]"", not the expected ""?name=value"".  Something needs to be done, and I believe this PR (which omits the queryParam entirely if all passed values are Optional.empty) is the correct solution.","closed","status: superseded,","robinroos","2020-10-21T15:18:21Z","2020-10-21T17:04:28Z"
"","26684","Polish TestContextAnnotationsUtilsTests","This PR improves code by removing unnecessary conditional statements.","closed","type: task,","Rebwon","2021-03-16T02:42:29Z","2021-04-14T01:39:34Z"
"","26341","Fix implementation of isOpen() in ReactorNettyWebSocketSession","This PR fixes the error described in #26332.","closed","type: bug,","mattisonchao","2021-01-04T08:01:02Z","2021-01-04T16:15:20Z"
"","26538","Polish","This PR fixes some typos and polishes trivial stuff.","closed","type: task,","izeye","2021-02-11T03:42:06Z","2021-02-11T08:36:53Z"
"","26708","Polish","This PR fixes polishes trivial stuff.","closed","type: task,","Rebwon","2021-03-20T12:33:07Z","2021-04-14T01:39:13Z"
"","26682","Polish","This PR fixes polishes trivial stuff.","closed","type: task,","Rebwon","2021-03-15T12:34:54Z","2021-04-14T01:39:26Z"
"","26676","Remove duplicate word in Javadoc","This PR fixes polishes trivial stuff.","closed","type: task,","drgnchan","2021-03-14T14:58:05Z","2021-03-15T10:47:22Z"
"","26675","Polish","This PR fixes polishes trivial stuff.","closed","type: task,","Rebwon","2021-03-14T12:57:03Z","2021-04-14T01:39:55Z"
"","26673","Polish","This PR fixes polishes trivial stuff.","closed","type: task,","Rebwon","2021-03-13T12:35:27Z","2021-03-13T22:36:42Z"
"","26050","Fix wrong reference in UrlPathHelper.removeSemicolonContentInternal()","This PR fixes a wrong reference in `UrlPathHelper.removeSemicolonContentInternal()`.  This PR also changes to short-circuit when `slashIndex` is -1.","closed","type: bug,","izeye","2020-11-09T11:57:05Z","2020-11-09T12:11:53Z"
"","26446","Fix DelegatingWebMvcConfigurationTests.configurePathPatternParser()","This PR fixes a variable reference in `DelegatingWebMvcConfigurationTests.configurePathPatternParser()` as it seems to be a wrong reference.","closed","type: task,","izeye","2021-01-26T15:03:39Z","2021-01-26T23:27:39Z"
"","25999","Fix a broken Asciidoctor syntax in core-resources.adoc","This PR fixes a broken Asciidoctor syntax in the `core-resources.adoc` file.","closed","type: documentation,","izeye","2020-10-30T08:13:18Z","2020-10-30T08:37:23Z"
"","26592","Fix MockHttpServletRequest reference in Javadoc","This PR fixes `MockHttpServletRequest` reference in Javadoc.","closed","type: task,","izeye","2021-02-23T05:13:18Z","2021-02-23T09:57:57Z"
"","26100","Avoid char array creation in AbstractAspectJAdvice.isVariableName()","This PR changes to avoid `char` array creation in `AbstractAspectJAdvice.isVariableName()`.","closed","type: task,","izeye","2020-11-17T04:00:47Z","2020-11-17T07:53:35Z"
"","26385","Add a missing space in exception message from CorsConfiguration.validateAllowCredentials()","This PR adds a missing space in exception message from `CorsConfiguration.validateAllowCredentials()`.","closed","type: task,","izeye","2021-01-14T11:03:43Z","2021-01-14T12:31:59Z"
"","26755","Add `@since` tag to WebClient.ResponseSpec.awaitBodyOrNull()","This PR adds `@since` tag to `WebClient.ResponseSpec.awaitBodyOrNull()` that has been introduced in https://github.com/spring-projects/spring-framework/pull/26731.","closed","type: task,","izeye","2021-04-02T14:23:30Z","2021-04-02T22:53:45Z"
"","26016","Fix kotlin example code which does not compile","This kotlin code does not compile:  Overload resolution ambiguity. All these functions match.  default  RowsFetchSpec map(Function mappingFunction)   RowsFetchSpec map(BiFunction mappingFunction);","closed","type: documentation,","mindhaq","2020-11-02T17:15:43Z","2020-11-08T14:44:37Z"
"","26236","Refine ConfigurationClassPostProcessor behavior in native images","This issue intends to refine `ConfigurationClassPostProcessor` behavior in native images by skipping configuration classes enhancement instead of raising an error. See spring-projects-experimental/spring-graalvm-native#248 for more details.","closed","type: enhancement,","sdeleuze","2020-12-07T23:11:03Z","2020-12-09T08:58:19Z"
"","26636","Support global @MessageExceptionHandler via @ControllerAdvice in RSocket","This is specific to rSocket.  Add support for global **@MessageExceptionHandler** using **@ControllerAdvice**. Currently **@MessageExceptionHandler** needs to be part of same controller to handle issues.","closed","type: enhancement,","kitkars","2021-03-04T03:50:53Z","2021-03-15T10:00:52Z"
"","26849","@RequestPart name/attribute value is ignored","This is similar to the issue https://github.com/springfox/springfox/issues/2263.   ```     @PostMapping(value = ""/api/attachments/create"", consumes = MULTIPART_FORM_DATA_VALUE)     Response createAttachment(@RequestPart(value = ""file"") MultipartFile file); ```  I need to store an attachment received from one service to another service(My service is a mediator). So the problem is the attachment request received to my service with parameter name as **linked** but I need to send the request with name as **file**. Though I gave name/value as **file** it still uses the parameter name(**linked**) received from the request. I use spring feign client to make POST request. Whether the issue with feign or spring?","closed","status: invalid,","Hemaraj-Gajaraj","2021-04-22T21:05:46Z","2021-05-17T10:42:43Z"
"","26060","DataBufferUtils#join may release a DataBuffer more than necessary","This is based on investigation under https://github.com/reactor/reactor-netty/issues/1374.   In `DataBufferUtils#join` we use a custom List to collect buffers and check the total buffered size. When a buffer is added that hits the limit, an error is raised but this causes a double release of the current buffer because Reactor's `MonoCollect` discards both the item that was passed to the add method and all items in the list. That leads to a double decrease of the refCount when it should be decremented only once.","closed","type: bug,","rstoyanchev","2020-11-10T12:44:49Z","2021-01-20T02:03:20Z"
"","26232","DataBuffer Leak in Server Response","This is based on a report in Reactor Netty https://github.com/reactor/reactor-netty/issues/1408 where the last leak record is in `AbstractJackson2Encoder` with no further records in Reactor Netty, which indicates it gets dropped before it gets there:  ``` LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information. Recent access records:  #1: 	io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:616) 	io.netty.buffer.ByteBufOutputStream.write(ByteBufOutputStream.java:68) 	com.fasterxml.jackson.core.json.UTF8JsonGenerator._flushBuffer(UTF8JsonGenerator.java:2085) 	com.fasterxml.jackson.core.json.UTF8JsonGenerator.flush(UTF8JsonGenerator.java:1097) 	com.fasterxml.jackson.databind.ObjectWriter.writeValue(ObjectWriter.java:915) 	org.springframework.http.codec.json.AbstractJackson2Encoder.encodeValue(AbstractJackson2Encoder.java:174) 	org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$0(AbstractJackson2Encoder.java:122) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107) 	reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) 	reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1878) 	reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1752) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) 	reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) 	reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) 	reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) 	reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) 	reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) 	reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) 	reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) 	reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) 	reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) 	reactor.core.publisher.MonoFlatMap$FlatMapInner.onSubscribe(MonoFlatMap.java:230) 	reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) 	reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) 	reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 	reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) 	reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) 	reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) 	reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241) 	reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) 	reactor.core.publisher.MonoSingle$SingleSubscriber.onComplete(MonoSingle.java:171) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) 	reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) 	reactor.core.publisher.DrainUtils.postCompleteDrain(DrainUtils.java:131) 	reactor.core.publisher.DrainUtils.postComplete(DrainUtils.java:186) 	reactor.core.publisher.FluxMapSignal$FluxMapSignalSubscriber.onComplete(FluxMapSignal.java:213) 	reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) 	reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) 	reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:372) 	reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:196) 	reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:337) 	reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:333) 	reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:382) 	reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:522) 	reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:141) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) 	io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:323) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:297) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:427) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:328) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) 	java.lang.Thread.run(Thread.java:748) ```  The scenario is a simple write to the body of a server response: ```java @Component public class Handler {      private WebClient webClient;      public Handler(WebClient.Builder webClientBuilder) {         String url = UriComponentsBuilder.newInstance()                 .scheme(""http"")                 .host(""127.0.0.1"")                 .build()                 .toUriString();         webClient = webClientBuilder                 .baseUrl(url)                 .clientConnector(new ReactorClientHttpConnector(HttpClient.create()))                 .build();     }     public Mono handle(ServerRequest serverRequest) {         return query(serverRequest.path()).flatMap(jsonNode -> ServerResponse.ok().syncBody(jsonNode));     }     private Mono query(String path) {         return webClient.get()                 .uri(uriBuilder -> uriBuilder                         .port(8080)                         .path(path)                         .build())                 .retrieve()                 .bodyToMono(JsonNode.class)                 .flatMap(Mono::just);     } } ```  The use of `WebClient` is probably not key. The main point is that the client (JMeter tests) is set to timeout immediately at 1 ms which sets up a race between writing to the response and the client going away.  The full sample https://github.com/yinjianfei/webflux-leak-test.","closed","type: bug,","rstoyanchev","2020-12-07T13:21:45Z","2020-12-08T22:36:59Z"
"","26648","Simplify RSocket Metadata extraction","This is an enhancement request for rSocket Metadata strategy.  Can we simplify the current design as shown in this pseudo code.? I have used Person object for metadata just to explain. do not take that seriously.  ``` // create mimetype or metatdata key MimeType pMime1 = MimeType.from(""pKey1"", Person.class); MimeType pMime2 = MimeType.from(""pKey2"", Person.class);  // pass it with requester rSocketRequester            .metadata(new Person(""name1"", age), pMime1)            .metadata(new Person(""name2"", age), pMime2)   // access it on the responder side // find the value from metatdata based on the header key @MessageMapping public Mono method(@Header(""pKey1"") Person person){ } ```  Can we use **_Jackson2Cbor_** as default encoders/decoders for metadata?  Currently we need to provide our own encoders/decoders for any custom metadata mime type. Also currently looks like we can not pass 2 different objects same type.","closed","status: declined,","kitkars","2021-03-06T20:39:25Z","2021-09-07T14:40:58Z"
"","25914","Upgrade to Kotlin Coroutines 1.4.0-M1","This is a pre-requesite for #25007. Kotlin Coroutines 1.4.0 is expected before Spring Framework 5.3 release.","closed","type: dependency-upgrade,","sdeleuze","2020-10-13T13:17:59Z","2020-10-13T13:27:13Z"
"","26407","InMemoryWebSessionStore indirectly causing infinite loop inside tomcat-native OpenSSL under load","This is a fun one....  When load testing a new app using... * Spring Boot 2.4.2 * WebFlux 5.3.3 * Spring Security 5.4.2 * Tomcat 9.0.41 * tomcat-native 1.2.25 * APR 1.6.5 * OpenSSL 1.1.1f  ...CPU utilization will max out, and _stay maxed out even after the load test completes_.  When investigating, I found that threads in the global `boundedElastic` Scheduler are consuming the entire CPU, as seen in `top` (broken out by threads)...  ``` top - 17:56:42 up 12 min,  0 users,  load average: 0.61, 0.24, 0.15 Threads: 112 total,   3 running, 109 sleeping,   0 stopped,   0 zombie %Cpu(s): 53.8 us,  0.3 sy,  0.0 ni, 45.7 id,  0.0 wa,  0.0 hi,  0.1 si,  0.1 st MiB Mem :  11852.9 total,   8478.8 free,   1267.9 used,   2106.2 buff/cache MiB Swap:      0.0 total,      0.0 free,      0.0 used.  10278.6 avail Mem    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND   212 bogus     20   0 6635460 493008  18064 R  99.9   4.1   0:07.44 boundedElastic-  <--- CPU maxed out   170 bogus     20   0 6635460 493008  18064 R  99.7   4.1   0:21.02 boundedElastic-  <--- CPU maxed out    17 bogus     20   0 6635460 493008  18064 S   9.6   4.1   0:26.19 C2 CompilerThre   235 bogus     20   0 6635460 493008  18064 S   1.3   4.1   0:00.13 boundedElastic-    18 bogus     20   0 6635460 493008  18064 S   0.7   4.1   0:04.61 C1 CompilerThre   234 bogus     20   0 6635460 493008  18064 S   0.7   4.1   0:00.79 boundedElastic-    85 bogus     20   0    9416   2340   1468 R   0.7   0.0   0:00.43 top    36 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.39 https-openssl-n    47 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:01.70 https-openssl-n   166 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.77 parallel-4   167 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.15 https-openssl-n   175 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.11 https-openssl-n   179 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.09 https-openssl-n   184 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.11 https-openssl-n   192 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.09 https-openssl-n   204 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.09 https-openssl-n   210 bogus     20   0 6635460 493008  18064 S   0.3   4.1   0:00.10 https-openssl-n ... ```  Taking a [stackdump](https://github.com/spring-projects/spring-framework/files/5839097/stack.txt) of the process reveals the two threads are inside tomcat's `OpenSSLEngine`... (note that `nid=0xd4` correlates to `PID 212` above)  ``` ""boundedElastic-8"" #86 daemon prio=5 os_prio=0 cpu=128128.31ms elapsed=215.53s allocated=28746K defined_classes=1 tid=0x00007fee00035800 nid=0xd4 runnable  [0x00007fed91cbe000]    java.lang.Thread.State: RUNNABLE 	at org.apache.tomcat.util.net.openssl.OpenSSLEngine.unwrap(OpenSSLEngine.java:603) 	- locked <0x00000007576d7df8> (a org.apache.tomcat.util.net.openssl.OpenSSLEngine) 	at javax.net.ssl.SSLEngine.unwrap(java.base@11.0.9.1/SSLEngine.java:637) 	at org.apache.tomcat.util.net.SecureNioChannel.read(SecureNioChannel.java:617) 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.fillReadBuffer(NioEndpoint.java:1229) 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1141) 	at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:795) 	at org.apache.coyote.http11.Http11InputBuffer.available(Http11InputBuffer.java:675) 	at org.apache.coyote.http11.Http11Processor.available(Http11Processor.java:1201) 	at org.apache.coyote.AbstractProcessor.isReadyForRead(AbstractProcessor.java:838) 	at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:577) 	at org.apache.coyote.Request.action(Request.java:432) 	at org.apache.catalina.connector.InputBuffer.isReady(InputBuffer.java:305) 	at org.apache.catalina.connector.CoyoteInputStream.isReady(CoyoteInputStream.java:201) 	at org.springframework.http.server.reactive.ServletServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(ServletServerHttpRequest.java:295) 	at org.springframework.http.server.reactive.AbstractListenerReadPublisher.changeToDemandState(AbstractListenerReadPublisher.java:222) 	at org.springframework.http.server.reactive.AbstractListenerReadPublisher.access$1000(AbstractListenerReadPublisher.java:48) 	at org.springframework.http.server.reactive.AbstractListenerReadPublisher$State$2.request(AbstractListenerReadPublisher.java:333) 	at org.springframework.http.server.reactive.AbstractListenerReadPublisher$ReadSubscription.request(AbstractListenerReadPublisher.java:260) 	... ```  In a debug session, I discovered that an infinite loop is executing in [tomcat's `OpenSSLEngine.unwrap`](https://github.com/apache/tomcat/blob/75d7a2069bf4360bcd8b885c6b7387d70c9cb052/java/org/apache/tomcat/util/net/openssl/OpenSSLEngine.java#L569-L606) where: * pendingApp = 2 * idx = 1 * endOffset = 1 * capacity = 16384   I would have expected the OpenSSL I/O code to execute on one of the `https-openssl-nio-*` threads, not the `boundedElastic` Scheduler. Therefore, I started investigating _why_ this code was executing on the `boundedElastic` Scheduler.  After more debugging I narrowed it down to [`InMemoryWebSessionStore.createWebSession()`](https://github.com/spring-projects/spring-framework/blob/v5.3.3/spring-web/src/main/java/org/springframework/web/server/session/InMemoryWebSessionStore.java#L121). This is the only location in this particular app that uses the `boundedElastic` Scheduler.  The `WebSession` is being created because Spring Security's `WebSessionServerRequestCache` is being used, which persists requests in the `WebSession`.  If I disable the request cache (which removes the usage of `WebSession`, which removes the call to `InMemoryWebSessionStore.createWebSession()`, which removes usage of `boundedElastic`), then all I/O is performed on the `https-openssl-nio-*` threads, and the infinite loop does not occur.  I haven't fully investigated _why_ the infinite loop occurs, but I assume there is a threadsafety bug somewhere in tomcat's `OpenSSLEngine`.  (Either that or it was never intended to be used from multiple threads.)  Having said that, I don't think that the I/O should be occurring on the `boundedElastic` thread, so I did not investigate further.  In other words, in my opinion, using `InMemoryWebSessionStore` should not cause the OpenSSL I/O to occur on a `boundedElastic` thread.  I have attached a [simple application ](https://github.com/spring-projects/spring-framework/files/5839098/tomcat-ssl.zip) that can be used to reproduce the problem. After extracting, use `docker-compose up` to build and start a container with the spring boot app with the above configuration. Sending a lot of load (>= 2000 calls per second) to the `/echo` endpoint will reproduce the infinite loop. However, you can see OpenSSL I/O occurring on the `boundedElastic` threads with any amount of load.","closed","status: superseded,","philsttr","2021-01-19T23:07:35Z","2021-07-22T14:18:25Z"
"","26493","Ignore null Locale in MockHttpServletResponse","This is a follow-up to #26488.  Although the Javadoc for `javax.servlet.ServletResponse.setLocale(Locale)` does not state how a `null` value for the supplied `Locale` should be handled, both Tomcat and Jetty simply ignore a `null` value.  We will therefore do the same in `MockHttpServletResponse`.","closed","type: enhancement,","sbrannen","2021-02-02T09:55:34Z","2021-02-02T10:39:11Z"
"","26602","OncePerRequestFilter.isAsyncDispatch may return a NPE","This is a follow-up ticket for as request in #26282 where `OncePerRequestFilter.isAsyncDispatch` might NPE.  In our case we were using a silly mockito mock in a test which was testing the `MultiPartFilter` integration  ``` HttpServletRequest request = mock( HttpServletRequest.class ); HttpServletResponse response = mock( HttpServletResponse.class );  multipartFilter.doFilter( request, response, mock( FilterChain.class ) ); ```","closed","type: enhancement,","slyoldfox","2021-02-24T20:56:39Z","2021-02-25T18:29:49Z"
"","25921","SPR-17614 Fix SpEL inline collections with negative keys or values are not cached","This is a fix for https://github.com/spring-projects/spring-framework/issues/22146","open","type: enhancement,","SammyVimes","2020-10-16T10:00:07Z","2021-04-27T05:06:14Z"
"","26206","Allow passing Class to resolveMethodByExceptionType in ExceptionHandlerMethodResolver","This fits better to the return value of `java.lang.reflect.Method.getExceptionTypes` which only returns items of `Class` and not of `Class` (which I don't know why that's the case, but we should just cope with this)  A real world usage of `ExceptionHandlerMethodResolver#resolveMethodByExceptionType` is [here](https://github.com/qaware/openapi-generator-for-spring/blob/master/openapi-generator-for-spring-test/src/test/java/de/qaware/openapigeneratorforspring/test/app32/App32Configuration.java#L50).  This PR would remove this ugly uncheckedCast for users of `ExceptionHandlerMethodResolver`. Still the method `resolveMethodByExceptionType` throws `IllegalArgumentException` if anything else than Class is passed to the method.  I've also added some test cases to show that it works as expected.","closed","status: declined,","neiser","2020-12-03T12:13:19Z","2021-01-17T08:34:01Z"
"","25925","UriBuilder - Overload queryParam to accept Optional and add only if value is present","This addresses a use-case in which a REST endpoint (A) has received an optional query param (as type Optional) and is delegating through WebClient to another service (B), probably with a similar uri structure.  Rather than have service (A) interrogate the parameter and branch its execution flow, it can merely include it in the chain of .queryParam() invocations on UriBuilder.  The parameter will be added in the downstream call to service (B) only if a value is present.  Without this change:  ```         Function f = (b) -> {             b = b.path(""/eventdates"");             if(context.isPresent()) {                 b = b.queryParam(""context"", context);             }             b = b.queryParam(""limit"", 3);             return b.build();         };         WebClient.ResponseSpec body = service.get().uri(f).accept(MediaType.APPLICATION_JSON).retrieve(); ```  With this change (queryParam for ""context"" is passed an Optional):  ```         WebClient.ResponseSpec body = service.get().uri(b -> b.path(""/eventdates"").queryParam(""context"", context).queryParam(""limit"", 3).build()).accept(MediaType.APPLICATION_JSON).retrieve(); ```","closed","status: superseded,","robinroos","2020-10-16T15:02:47Z","2020-10-21T17:05:00Z"
"","26565","HandlerMapping for WebSocket Requests Only","There is an existing `WebSocketUrlHandlerMapping` in `spring-websocket` (none in `spring-webflux`). However currently it does nothing more than delegate `Llifecycle` methods to handlers. What would be useful is the ability to map WebSocket requests only. That avoids the need for a dedicated path or sub-path specifically for WebSocket requests and makes it possible for the same URL can be handled differently when it isn't a WebSocket request.","closed","type: enhancement,","rstoyanchev","2021-02-18T07:43:27Z","2021-02-19T12:08:23Z"
"","26687","Improve Docs on Testing Streaming Responses in Spring MVC","There is a section ""Streaming Responses"" under MockMvc and it does mention `WebTestClient` but it's not very clear on the fact it is possible to test with and without a running server. We also don't have a sample test to demonstrate it.","closed","type: enhancement,","rstoyanchev","2021-03-16T17:38:38Z","2021-03-16T17:56:41Z"
"","26802","Blocking call when loading a FreeMarker template","There is a blocking call detected by BlockHound when FreeMarker template is loaded Spring Boot WebFlux 2.4.4 application. Program was run with JDK 11 on Ubuntu 20.04.1.  I created a [sample project](https://github.com/pmendelski/spring-webflux-freemarker/tree/blockhound-error) that contains basic configuration with single FreeMarker template and two endpoints. When page is fetched Blockhound detects an error.   In most cases each template is loaded once and is stored in the FreeMarker cache, but what about a case when cache is deliberately disabled or templates are loaded from DB?","open","status: feedback-provided,","pmendelski","2021-04-13T21:17:23Z","2021-11-08T11:37:33Z"
"","26463","Support BASE64 file name encoding in ContentDisposition","There are web servers encode Content-Disposition filename part using BASE64 like - filename=""=?UTF-8?B?5pel5pys6KqeLmNzdg==?="" which translates to 日本語.csv.  But ContentDisposition.parse() is not aware of that format.","closed","type: enhancement,","yusuke","2021-01-28T02:52:55Z","2021-02-05T13:28:46Z"
"","26419","Two beanvalidation test packages look the same","There are two test packages . one is 'org.springframework.validation.beanvalidation2' in spring-context-support, another is 'org.springframework.validation.beanvalidation' in spring-context. Is there a special purpose?","closed","","limo520","2021-01-21T06:07:10Z","2021-01-21T10:00:56Z"
"","26101","Reduce overhead of char[] creation","There are more locations which could benefit from not using a toCharArray on a String, but rather use the charAt method from the String itself. This to prevent an additional copy of the char[] being created.","closed","type: enhancement,","mdeinum","2020-11-17T10:53:45Z","2020-11-17T10:57:10Z"
"","26483","Fix Javadoc formatting errors","There are many document formatting errors in the project, causing some tools to parse the source code incorrectly when reading it","closed","status: invalid,","zoain-it","2021-02-01T05:02:52Z","2021-02-01T09:48:21Z"
"","26864","Use asciidoc attributes in reference documentation","There are a number of places where links could use an attribute to rationalize what we use and make sure they are consistent.","open","type: documentation,","snicoll","2021-04-27T05:24:19Z","2021-11-11T10:30:32Z"
"","26797","Improve ref docs regarding @Bean method visibility constraints","There are 2 main approaches how to use `@Configuration` annotation:  1. When `proxyBeanMethods` attribute is `true` then a *CGLIB* proxy is created. In this case the visibility of a `@Bean` annotated method can be anything except `private`.  2. When `proxyBeanMethods` attribute is `false` then no *CGLIB* proxy is created. In this case the visibility of a `@Bean` annotated method can be anything including `private`.","closed","type: task,","hrybs","2021-04-13T13:33:21Z","2021-04-20T17:08:32Z"
"","26409","Introduce SPI to configure the SpEL Indexer","The SpEL indexer doesn't provide support for Jackson's `ArrayNode`, and it seems to be non-extensible; whereas, a Jackson `ObjectNode` can be operated on within a SpEL expression via `PropertyAccessor` support.","open","type: enhancement,","jackmiking","2021-01-20T09:11:59Z","2022-05-11T16:45:26Z"
"","26798","Allow for AbstractUrlHandlerMapping to add/remove handlers at runtime","The requirements is to be able to add and remove mappings for urls at runtime.  It is possible right now with the `AbstractHandlerMethodMapping` and its `registerMapping(T mapping, Object handler, Method method)` and `unregisterMapping(T mapping)` API.  It would be great if `AbstractUrlHandlerMapping` would make its `protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {` as `public` and also would introduce an `unregisterHalder(String urlPath)`.  Related Spring Integration issue: https://github.com/spring-projects/spring-integration/issues/3533.  Right I'm enforced to copy/paste a lot from Spring MVC to have a backward compatibility and implement a requested feature.  Thanks","open","in: web,","artembilan","2021-04-13T14:18:17Z","2021-11-10T12:44:56Z"
"","25907","Compatibility with Jackson 2.12","The recently released Jackson 2.12 RC1 allows us to refine our supported version range: As of Spring Framework 5.3 RC2, our Jackson integration and our related tests are officially compatible with Jackson 2.9 to 2.12 now. We're still building against Jackson 2.11.3, seeing whether Jackson 2.12 will go GA in time for our 5.3 GA.","closed","type: enhancement,","jhoeller","2020-10-13T08:56:06Z","2020-10-13T14:43:19Z"
"","26049","setTaskScheduler in StompBrokerRelayRegistration breaks chaining","The recently added `setTaskScheduler` returns `void` instead of `StompBrokerRelayRegistration` and so does `setTcpClient` which was added longer ago might be worth addressing.  Originally reported in https://github.com/spring-projects/spring-framework/issues/22822#issuecomment-723735475.","closed","type: bug,","rstoyanchev","2020-11-09T10:34:49Z","2020-11-09T12:34:16Z"
"","25927","Improve ResourceArrayPropertyEditor time complexity","The previous implementation uses ArrayList for storing resolved resources and ArrayList has O(n) time complexity for the contains operation. By switching to the HashSet for storing resolved resources we improve the time complexity of this operation to be O(1).","closed","in: core,","shevtsiv","2020-10-16T21:01:31Z","2020-12-04T09:45:46Z"
"","26780","Add handleErrorFrame callback for STOMP handler","The previous implementation invoke handleFrame no matter the frame is ""MESSAGE"" nor ""ERROR"".  This commit add a new callback ""handleErrorFrame"" to the handler to separate from the message frame handling.  Reason: 1. The error frame is created by server and not following bussiness message frame format. 2. Otherwise the handler can not tell if the frame is business message or it's an error message.","closed","status: declined,","ppshinebl","2021-04-09T10:37:46Z","2021-04-23T02:44:58Z"
"","26746","ByteBuf Leak Report with Server-Sent Event Response","The original report can in https://github.com/reactor/reactor-netty/issues/1546. The scenario is an SSE endpoint with a reactive repository (MongoDB) but the use of the repository is not related or at least a leak can be demonstrated without it.  Using a controller like this: ```java @GetMapping(path = ""/cars"", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux getCar() { 	return Flux.interval(Duration.ofMillis(50)) 			.map(aLong -> new Car(aLong, gen.location())) 			.onBackpressureDrop(); } ```  and a script like this: ``` for i in {1..100}; do ../../../tmp/wrk/wrk -t2 -c 100 -d 2s --latency http://localhost:8080/cars; done ```  I get a leak record that points to the `ServerSentEventHttpMessageWriter: ``` Recent access records:  Created at: 	io.netty.buffer.AbstractByteBufAllocator.compositeDirectBuffer(AbstractByteBufAllocator.java:223) 	io.netty.buffer.AbstractByteBufAllocator.compositeBuffer(AbstractByteBufAllocator.java:201) 	org.springframework.core.io.buffer.NettyDataBufferFactory.join(NettyDataBufferFactory.java:108) 	org.springframework.http.codec.ServerSentEventHttpMessageWriter.encodeEvent(ServerSentEventHttpMessageWriter.java:176) 	org.springframework.http.codec.ServerSentEventHttpMessageWriter.lambda$encode$0(ServerSentEventHttpMessageWriter.java:160) ```","closed","type: bug,","rstoyanchev","2021-03-30T17:55:14Z","2021-09-07T10:16:05Z"
"","26824","fix DateTimeFormat annotation description","The official documentation contains partial information about using of *@DateTimeFormat* annotation. According to JavaDocs and source code of *org.springframework.format.support.DefaultFormattingConversionService* class there is support for Joda-Time value types. https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/format/annotation/DateTimeFormat.html","closed","status: invalid,","hrybs","2021-04-19T12:50:15Z","2021-04-19T16:58:01Z"
"","26806","Remove unnecessary semicolon in BeanInfo example","The official documentation contains misleading using of java syntax. There is redundant semicolon **"";""** at the end of overridden method of anonymous class. As a result it looks like there is a mix of invocation of method or creation a new one. It complicates a lot of understanding the code.","closed","type: task,","hrybs","2021-04-14T16:16:21Z","2021-04-15T09:17:56Z"
"","26832","Fix formatting for PersonValidator Kotlin example in ref docs","The official documentation contains incorrect Kotlin code example (page 237 of pdf). As a result we have weird parameter `clazz: Class<>` instead of `clazz: Class<*>`. Also we have simple comment instead of JavaDoc comment.","closed","type: task,","hrybs","2021-04-20T15:37:39Z","2021-04-20T17:00:05Z"
"","26782","Update documentation for","The official documentation contains incorrect description on ``: 1) No *RequiredAnnotationBeanPostProcessor* is automatically registered.  According to source code of *AnnotationConfigBeanDefinitionParser* class we see that there is a using of  *AnnotationConfigUtils* class. Investigating the code of letter one we see that there is registration of 5 BeanPostProcessor and BeanFactoryPostProcessor classes. 2) There are 2 additional processor that are registered when using  aforementioned annotation 3) *AutowiredAnnotationBeanPostProcessor* also processes *@Lookup* annotation. 4) *CommonAnnotationBeanPostProcessor* also processes JAX-WS *@WebServiceRef* and EJB3 *@EJB* annotations","closed","type: documentation,","hrybs","2021-04-09T14:15:42Z","2021-04-09T14:56:04Z"
"","26812","Update FormatterRegistry interface in reference manual","The official documentation contains incorrect description of interface *org.springframework.format.FormatterRegistry*. Please check api [https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/format/FormatterRegistry.html](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/format/FormatterRegistry.html)","closed","type: task,","hrybs","2021-04-15T12:37:17Z","2021-04-15T16:45:19Z"
"","26816","Fix LocaleEditor description and formatting in reference manual","The official documentation contains incorrect description of *LocaleEditor* class (page 244 of pdf): 1) The language part is missing. The problem lies in incorrect formatting. 2) We can also use spaces as separators instead of underscores. We can see it from source code of *StringUtils* class.","closed","type: task,","hrybs","2021-04-16T09:10:36Z","2021-04-16T09:40:20Z"
"","26069","Missing error status handling for `toEntityFlux` methods in `WebClient`","The new `toEntityFlux` methods are not delegating to `handleBodyFlux` which takes care of error response handling.","closed","type: bug,","rstoyanchev","2020-11-11T12:07:15Z","2020-11-12T18:44:59Z"
"","26347","DefaultPartHttpMessageReader creates live resources that won't be shut down","The new `DefaultPartHttpMessageReader` creates a Reactor `Scheduler` via `Schedulers.newBoundedElastic` to use for temp file creation. This lead to the creation of a `boundedElastic-evictor` daemon thread that won't ever be shut down. The issue is further compounded by the way `CodecConfigurer` has always worked by creating new instances of default codecs.  `CodecConfigurer` will be improved via #26263 to cache instances of default codecs. Still the configurer may be created multiple times, and in any case the creation of an `DefaultPartHttpMessageReader` instance should be decoupled from the creation of live resources.","closed","type: bug,","rstoyanchev","2021-01-05T15:38:12Z","2021-01-08T13:34:21Z"
"","26173","Add overloaded send methods of client StompSession","The methods allow a post processor to post-process or modify the created message when sending.","closed","","topikachu","2020-11-29T05:33:16Z","2020-12-10T17:43:09Z"
"","26437","Documentation on http/2 support leads to 404","The link to `TLS requirements listed in the HTTP/2 specification` of the first chapter (https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support#tls-considerations) is currently redirecting to a 404.","closed","type: documentation,","Tcharl","2021-01-24T16:28:13Z","2021-01-24T16:53:00Z"
"","26874","Improve readability of MessageSourceSupport Javadoc","The Javadoc of  [org.springframework.context.support.MessageSourceSupport](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/MessageSourceSupport.html#setAlwaysUseMessageFormat-boolean-) class contains unreadable piece of text for method *setAlwaysUseMessageFormat(boolean)*. We need to replace """""" with `""''""`.","closed","type: task,","hrybs","2021-04-29T07:45:34Z","2021-04-29T15:51:35Z"
"","26303","Assertion error details lost in rethrow in assertWithDiagnostics","The issue is caused by `org.springframework.test.web.reactive.server.ExchangeResult.assertWithDiagnostics` which catches AssertionError, adds diagnostic information and throws a new AssertionError.   The trouble is, that if you use an assertion library in `WebTestClient.consumeWith` the assertion library throws an exception with details like `org.opentest4j.AssertionFailedError`. The details are used by IDEs when displaying difference between expected and actual value. By rethrowing generic AssertionError, the extra details are lost and the IDE has to use heuristics to guess the difference (for example like this [this](https://github.com/JetBrains/intellij-community/blob/19306e6d29182ef0d906e7f60054e0de11861da0/plugins/junit_rt/src/com/intellij/junit4/ExpectedPatterns.java#L25)).   To make it worse, if the IDE guesses wrong, it adds the debugging information from `assertWithDiagnostics` to the expected value in the difference view which is really confusing.  The best way would be to rethrow the AssertionFailedError with related detail but I understand that it would add complexity and may require reflection to not break the method when  opentest4j is not on the classpath","closed","type: enhancement,","lukas-krecan","2020-12-20T11:11:09Z","2021-01-06T21:56:37Z"
"","26600","Correctly set auto-growing array's element","The implementation of `AbstractNestablePropertyAccessor.processKeyedProperty` results in a `java.lang.IllegalArgumentException: array element type mismatch` when the property expression has more than one property key and the last key causes the array to grow automatically.   For example, given a property `int[][] multiArray = new int[2][2]` and property expression  `multiArray[1][3]`, the `processKeyedProperty` method creates a new array object and assigns it to `multiArray`; whereas, the new array object should be assigned to `multiArray[1]`.","closed","in: core,","nullzl","2021-02-24T03:38:42Z","2021-02-25T10:58:03Z"
"","26718","o.s.j.JndiObjectFactoryBean breaks Java Security Manager ear isolation","The following issue occurs with spring-boot-starter 2.4.4 - The Scenario is a WildFly 22 or later with Elytron Java Security Manager activated - There are three artifacts deployed: earpart.ear, springclient.war and warpart.war.  - All three are deployed in the same server. The wars are independent (not inside the ear). - The war files do contain a permissions.xml with all necessary grants, except permissions which rely on other artifacts content. [springclient.war permissions](https://github.com/boris-unckel/jsmshowcase/blob/main/springclient/src/main/webapp/META-INF/permissions.xml) and [warpart.war permissions](https://github.com/boris-unckel/jsmshowcase/blob/main/warpart/src/main/webapp/META-INF/permissions.xml). Clear expectation is that each artifact does only need it's own permissions. - The org.springframework.jndi.JndiObjectFactoryBean in springclient.war looks up a EJB3 bean in EAR earpart.ear. [service call](https://github.com/boris-unckel/jsmshowcase/blob/main/springclient/src/main/java/net/unckel/jsm/showcase/springclient/HelloController.java) and [EJB service provider](https://github.com/boris-unckel/jsmshowcase/blob/main/earpart/earpart-ejb/src/main/java/net/unckel/jsm/showcase/earpart/ejb/Greeter.java) - A remote method in the EJB3 is called which remotely reads a file. The springclient.war needs permissions for this reading: `2021-03-23 18:05:15,688 DEBUG [org.wildfly.security.access] (default task-1) Permission check failed (permission ""(""org.jboss.vfs.VirtualFilePermission"" ""/content/earpart.ear/earpart-ejb.jar/net/unckel/jsm/showcase/earpart/resources/file2.properties"" ""read"")"" in code source ""(vfs:/content/springclient.war/WEB-INF/lib/spring-aop-5.3.5.jar )"" of ""ModuleClassLoader for Module ""deployment.springclient.war"" from Service Module Loader"")`  - The same call out of warpart.war does not need any permission out of the remote call. [javax.ws.rs.core.Application based client](https://github.com/boris-unckel/jsmshowcase/blob/main/warpart/src/main/java/net/unckel/jsm/showcase/warpart/rs/GreeterWeb.java) - Negative effect: The more permissions the ear needs, the more permissions are derived to the war. Two loosely coupled artifacts start to be close coupled by their permissions. Isolation is broken by design.  I have prepared a HelloWorld showcase for the issue: [https://github.com/boris-unckel/jsmshowcase](https://github.com/boris-unckel/jsmshowcase) The readme explains what to build, deploy and test.  Expected behaviour: The proxy created and looked up by JndiObjectFactoryBean shall do the call successfully without need of permissions in the called EJB method in the same way as this is possible in a plain vanilla JavaEE war.","open","in: core,","boris-unckel","2021-03-23T20:53:37Z","2021-11-10T10:03:03Z"
"","25924","Extending the incoming Stomp sessionId as an attribute in TcpClient","The final idea is to be able to balance the load of the Stomp cluster, by grouping all sessions from the same user in the same Stomp Broker Relay server.  In order to achieve this, the very bare minimum is to gain access to the session Id at the TcpClient#doOnConnect callbacks, in order to customize from there the specific instance of the TcpClient#remoteAddress supplier.  Of course, passing on the whole StompHeaderAccessor from StompBrokerRelayMessageHandler#handleMessageInternal to ReactorNettyTcpClient may be better for my case, but it may perhaps make the average usages a bit more complicated.  I am very much open for suggestions or discussions on this matter.  This solves #25889 .","closed","status: superseded,","rupebac","2020-10-16T14:35:24Z","2020-10-19T20:44:15Z"
"","26763","Handle removal of query param when a single (null) value is sent to `replaceQueryParam`","The earlier definition of `replaceQueryParam(String name, Object... values)` didn't  remove the query param if the passed value is null. So, `replaceQueryParam(""param1"" , null)` would still lead to presence of queryparam `param1` in the URI.   So if value is null, one would need to write this piece of code: ` if(value== null) { replaceQueryParam(""param1""); } else { replaceQueryParam(""param1"", value); } `  Hence added a new definition of the function which takes in a single argument `Object value`.","open","in: web,","gdagitrep","2021-04-05T18:34:44Z","2021-11-08T11:57:06Z"
"","25942","WebSocketTransportRegistration: javadoc typo","The documentation written for the method `WebSocketTransportRegistration.setSendTimeLimit(int timeLimit)` mentions that, if no time limit is specified, a default value of 10 seconds is used; however, later on the exact default value employed is incorrectly typed as 10 * 10000 ms, which would result in 100 seconds instead. The javadoc has been updated in order to show the correct value in milliseconds (10 * 1000).","closed","type: task,","jacopo-salamina","2020-10-20T10:22:13Z","2021-08-19T11:35:41Z"
"","25992","DefaultWebClientBuilder copies references","The DefaultWebClientBuilder is copying references (e.g.defaul;tHeaders) to the built WebClient instance. This prevents reuse of the WebClient, as changing the content in the builder will also change the content in already created instances.   When the following snippet is used, both webClients will have the same defaultHeaders (i.e. X=second)  ``` WebClient.Builder builder = WebClient.builder(); WebClient first = builder.defaultHeaders(h -> h.set(""X"", ""first"")).build; WebClient second = builder.defaultHeaders(h -> h.set(""X"", ""second"")).build; ```  This can be experienced in Spring 5.2.8, but should be in the 5.3.0 as well. It can be worked around by cloning the builder before change.","closed","type: enhancement,","ujaehrig","2020-10-29T10:39:54Z","2020-10-30T07:31:33Z"
"","26071","NamedParameterJdbcTemplate.batchUpdate does not individually apply the SQL type from each SqlParameterSource argument","The class NamedParameterJdbcTemplate has following method: ```Java @Nonnull @Override public int[] batchUpdate(@Nonnull String sql, @Nonnull SqlParameterSource[] batchArgs) { // implementation } ```  The method signature suggests fine-grained control over the SQL type hints, so that these could be customised for each element in the array, however, this is not true.  As a matter of fact, only the SQL hints for the first element in the array are processed, they are then applied to all the elements in the batch by _PreparedStatementCreatorFactory_.  This can lead to exceptions within the JDBC driver, for example when using MySQL/MariaDB. Consider the following table definition and inserts:  ```SQL CREATE TABLE `names` ( `first_name` VARCHAR(30) NOT NULL, `nick_name` VARCHAR(30) NULL );  INSERT INTO `names`(`first_name`, `nick_name`) VALUES(:first_name, :nick_name); ```   Now consider this Java:  ```Java MapSqlParameterSource sqlParameterSource1 = new MapSqlParameterSource(); sqlParameterSource2.addValue(""first_name"", ""Jose"", Types.VARCHAR); sqlParameterSource2.addValue(""nick_name"", null, Types.NULL);  MapSqlParameterSource sqlParameterSource2 = new MapSqlParameterSource(); sqlParameterSource1.addValue(""first_name"", ""Silvio"", Types.VARCHAR); sqlParameterSource1.addValue(""nick_name"", ""Silv"", Types.VARCHAR);  SqlParameterSource[] batch = new SqlParameterSource[] {         sqlParameterSource1,         sqlParameterSource2 }; namedParameterJdbcTemplate.batchUpdate(sql, batch); ```  This will throw an exception in the MySQL driver because Types.NULL from the first element will be applied to the second element as well.  **Cannot convert class java.lang.String to SQL type requested due to com.mysql.cj.exceptions.WrongArgumentException - Conversion from java.lang.String to NULL is not supported.**","closed","type: regression,","silviomo","2020-11-11T17:01:23Z","2020-11-12T14:24:28Z"
"","26877","`CorsRegistration#combine` is a noop","The call to `CorsConfiguration::combine` returns a new configuration object, which is ignored.  https://github.com/spring-projects/spring-framework/blob/607d918340c7a3a0282e1722354c689359dac201/spring-webflux/src/main/java/org/springframework/web/reactive/config/CorsRegistration.java#L151-L154   https://github.com/spring-projects/spring-framework/blob/607d918340c7a3a0282e1722354c689359dac201/spring-web/src/main/java/org/springframework/web/cors/CorsConfiguration.java#L479-L501   **Affects:** 5.3  I was expecting the following to work: ```kotlin @Configuration class CorsGlobalConfiguration : WebFluxConfigurer {      override fun addCorsMappings(corsRegistry: CorsRegistry) {         val config = CorsConfiguration()         config.addAllowedOrigin(""http://localhost:3000"")         config.addAllowedMethod(""*"")         config.applyPermitDefaultValues()          corsRegistry.addMapping(""/api/**"").combine(config)     } } ``` This works: ```kotlin @Configuration class CorsGlobalConfiguration : WebFluxConfigurer {      override fun addCorsMappings(corsRegistry: CorsRegistry) {           corsRegistry.addMapping(""/api/**"")                 .allowedOrigins(""http://localhost:3000"")                 .allowedMethods(""*"")      } } ```  ---","closed","type: bug,","bertwin","2021-04-29T12:26:39Z","2021-05-05T20:04:10Z"
"","26873","Document feature to load `@ModelAttribute`  through type conversion from a request value","The behavior of `@ModelAttribute` in Web MVC and WebFlux is different.  Except for #26856, the HTTP GET parameter cannot be bound normally.  In WebFlux and Web MVC 5.3.4 :  ```java @RestController @SpringBootApplication public class MyApp  {      public static void main(String[] args) {         SpringApplication.run(MyApp.class);     }      @GetMapping(""/echo"")     public String echo(@ModelAttribute(""msg"") String msg) {         return msg;     } } ```  when I call http://localhost:8080/echo?msg=hello, I get `` for WebFlux but `hello` for Web MVC.","closed","in: web,","aoyvx","2021-04-29T05:33:55Z","2021-05-10T06:21:59Z"
"","26619","Local @CrossOrigin maxAge value should override global value","The attribute of **CrossOrigin** that be applied to method will override that be applied to class, like **origins**, but **maxAge** is different，so I think we would modify it","closed","type: bug,","GungnirLaevatain","2021-02-27T10:05:05Z","2021-06-17T05:09:22Z"
"","26288","Make set operator for MapSqlParameterSource accept nullable value","The addValue methods of MapSqlParameterSource explicitly allows null values (org.springframework.lang.Nullable), but you're not able to set it if you try to use the Kotlin extension methods.","closed","type: enhancement,","cadimmek","2020-12-16T17:47:45Z","2021-02-15T16:16:32Z"
"","26639","Reduce memory consumption of buildAdvisors","The `specificInterceptors` may equals PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS, So I think we can add a size judgment to reduce memory consumption .","closed","in: core,","chenqimiao","2021-03-04T09:00:28Z","2021-05-13T12:34:55Z"
"","25944","Change default http status for MethodArgumentNotValidException in ResponseEntityExceptionHandler","The `ResponseEntityExceptionHandler` currently handles a `MethodArgumentNotValidException` like this:  ``` else if (ex instanceof MethodArgumentNotValidException) {   HttpStatus status = HttpStatus.BAD_REQUEST;   return handleMethodArgumentNotValid((MethodArgumentNotValidException) ex, headers, status, request); } ```  This exception is ""thrown when validation on an argument annotated with @Valid fails"".  I think `HttpStatus.UNPROCESSABLE_ENTITY` is a more appropriate status to use because it more clearly shows that the problem is due to the semantics of the request, and not the syntax. Could this default be changed (happy to raise a PR if agreed)?","closed","status: declined,","rupert-madden-abbott","2020-10-21T07:24:53Z","2020-10-22T08:27:26Z"
"","26758","Update FactoryBean generic description in ref docs","The **FactoryBean** is a generic type and as a result has different method returns types from ones described in documentation.","closed","type: task,","hrybs","2021-04-04T10:08:27Z","2021-04-21T12:06:48Z"
"","25936","Wording changes. Fixed typo 'CorsConfiguraiton'","The 'Configuration' is misspelled.  t and the i are swapped `CorsConfiguraiton`","closed","type: task,","jupiterhub","2020-10-19T11:43:47Z","2020-10-19T13:17:24Z"
"","26167","Register bean definition dependencies when used via configuration class injected fields","Take the following two ways of declaring a bean definition manually.  ```java @Configuration class MyConfiguration {    private final MyRepository repository;    MyConfiguration(MyRepository repository) {     this.repository = repository;   }      @Bean MyService myService() {     return new MyService(repository);   } } ```  In this case, the implicit dependency from `MyService` to `MyRepository` is not taken into account on the `BeanDefinition` level which has consequences on the destruction order on container shutdown. The repository might already shut down so that destruction callbacks on `MyService` will not be able to use the repository anmore.  ```java @Configuration class MyConfiguration {    @Bean MyService myService(MyRepository repository) {     return new MyService(repository);   } }  In this case the dependency is properly transferred into the `BeanDefinition` arrangement and `MyService` is destructed before `MyRepository`.","closed","type: enhancement,","odrotbohm","2020-11-27T15:47:46Z","2020-11-27T17:01:05Z"
"","26212","Configure the ObjectMappers to Use for a Class by MediaType","Take the following `HttpMessageConverter` setup in a Spring Boot application:  * An `HMC` registered to handle the `application/hal+json` media type (via Spring HATEOAS). * The default `MappingJackson2HttpMessageConverter` registered to handle `application/json` and `application/*+json`.  An HTTP request with `Accept: application/prs.hal-forms+json, application/hal+json` header will produce a response with `Content-Type: application/prs.hal-forms+json` which I think is wrong. The returned content type should be `application/hal+json`.  Here's what happens: `AbstractMessageConverterMethodProcessor.writeWithMessageConverters(…)` iterates over all acceptable types, starting with `application/prs.hal-forms+json` and checks it for compatibility with the producible media types. The HAL `HMC` does not match but the default Jackson one matches due to the support of `application/*+json`.  In the next step, `getMostSpecificMediaType(…)` is called and that match turns from a wildcard match into a concrete match. I.e. the match is treated as if `application/prs.hal-forms+json` had been matched explicitly. The now following concrete match for the HAL `HMC` and `application/hal+json` ends up second in the line in `mediaTypesToUse`.  That ""upgrade"" in the match causes the subsequent `MediaType.sortBySpecificityAndQuality(mediaTypesToUse)` to be without effect on the ordering as the first, actually wildcard match, is treated as concrete. As a consequence, the fallback `HMC` gets used instead of the actual concrete match of `application/hal+json` and is not even able to render the object according to the media type specification.  I've prepared a reproducing example [here](https://github.com/spring-projects/spring-framework/files/5642530/content-negotiation-sample.zip).","closed","type: enhancement,","odrotbohm","2020-12-04T11:55:57Z","2021-02-19T08:12:41Z"
"","26052","Cannot be cast to class Publisher error with non suspending @Transactional functions","Such transactional function: ``` fun findMessages(): Flow { 	return fooRepository.findAll() } ```  Currently generates a `class kotlinx.coroutines.reactive.PublisherAsFlow cannot be cast to class org.reactivestreams.Publisher` error message.","closed","type: bug,","sdeleuze","2020-11-09T16:41:57Z","2020-11-09T16:48:33Z"
"","26157","Remove unused package-private class o.s.w.u.p.SubSequence","subj","closed","type: task,","stsypanov","2020-11-26T14:17:21Z","2020-11-28T21:07:58Z"
"","26064","Simplify AbstractAspectJAdvice.isVariableName()","Subj","closed","in: core,","stsypanov","2020-11-10T15:34:58Z","2020-11-10T20:10:31Z"
"","26026","StompSubProtocolHandler logs failed authentication with error stack trace","StompSubProtocolHandler logs every exception, including failed authentication errors from spring-security-messaging, with error stack trace. This fills logs with garbage. It also allows simple DOS attacks by attempting unauthorized connection to websocket until the server disk is full.  Solution - allow authentication exceptions (for spring-security-messaging, it seems to be AccessDeniedException) to be returned to client as errors without logging anything.","closed","type: enhancement,","icokk","2020-11-03T20:50:49Z","2020-11-06T08:37:48Z"
"","26784","War deployment in Tomcat - Content-Type response header differences with and without index.html","Steps:  - Created a simple Springboot 2.4.4 application with with War packaging with Spring Web dependency. - Added a simple index.html page in the src/main/resource/static/index.html.  ```                       Example       Encoding should be UTF-8   ``` - Built the .war file with bootWar - say example.war - Deployed the war to external Tomcat 9.x by dropping the .war file to webapps folder of Tomcat (running at localhost:8090) - In the browser access the application using the following URL:  http:// localhost:8090/example  **NOTE** This internally gets forwarded to index.html by Springboot.  The returned Content-Type response header is set to:  Content-Type: text/html;**charset=ISO-8859-1**  **NOTE** Debugging shows that the Tomcat code injects this charset based on a Locale-based map because the response from the application did not have the charset specified.  - Now access the application using the following URL:  http:// localhost:8090/example/**index.html**  The returned Content-Type response header is set to:  Content-Type: text/html  NOTE: The **charset=ISO-8859-1** is now missing.  - Now run the same app as a Springboot standalone app with embedded Tomcat.  - In the browser access the application using the following URL:  http:// localhost:8080/  The returned Content-Type response header is set to:  Content-Type: text/html;**charset=UTF-8**  - Now access the application using the following URL:  http:// localhost:8080/index.html  The returned Content-Type response header is set to:  Content-Type: text/html  NOTE: The **charset=UTF-8** is now missing.  Expected behavior:  The Content-Type header value should be consistent in all 4 cases - preferably with **charset=UTF-8**","open","status: feedback-provided,","sandipchitale","2021-04-07T20:18:07Z","2022-04-19T03:57:39Z"
"","26658","StatusAssertion value methods fail when used with custom status code","StatusAssertion value methods used for status assertions with custom matchers fail when returned status code is not one of states recognized by Spring Framework. Problem is that HttpStatus is retrieved and then converted back to integer instead of retrieving raw status directly.  Change will make behaviour consistent with isEqualTo method.","closed","type: bug,","MichalStehlikCz","2021-03-10T12:33:16Z","2021-03-11T15:02:01Z"
"","26729","Silently broken CGLIB proxy when methods or properties are final, causing null/zero to be returned","Started from https://github.com/spring-projects/spring-retry/issues/238  In org.springframework.cglib.proxy.Enhancer.getMethods(): `CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_FINAL));` If the method is final it is SILENTLY rejected from being proxied.  Shouldn't we warn someone who is implementing a proxy on top of a final class ?  I believe it is a contract break of making the proxy and should throw a `NotProxiableElementException(""The method or field is final."")`.  This issue is particularly severe in Kotlin where `final` is the default. This example is using Spring-Retry to generate the Proxy and demonstrate the issue.  ```kotlin import org.junit.Assert import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.retry.annotation.EnableRetry import org.springframework.retry.annotation.Retryable import org.springframework.stereotype.Component   private const val COUNT=1000  @SpringBootTest @EnableRetry class SpringOpenIssueTest {      @Autowired     private lateinit var bean: ChildBean      @Test     fun `proxies should work in kotlin with all-open plugin`(){         bean.assertOkayFromTheInside()         Assert.assertEquals(COUNT, bean.openCount)         Assert.assertEquals(COUNT, bean.closedCount) //java.lang.AssertionError: expected:<1000> but was:<0>     }  }  @Component //This class is automatically opened by all-open plugin class ChildBean : AbstractBean(){     @Retryable     fun assertOkayFromTheInside(){         Assert.assertEquals(COUNT, openCount)         Assert.assertEquals(COUNT, closedCount)     } }  //This class is open because abstract abstract class AbstractBean{     var closedCount = COUNT //This field is not automatically opened     open var openCount = COUNT } ```","open","in: core,","rpelissier","2021-03-25T18:53:17Z","2021-11-10T11:58:08Z"
"","26053","Unable get fileName from Resource when using WebClient. Content-Disposition header is ignored.","springBootVersion = '2.3.4.RELEASE'  I want to download file from server via WebClient and get body with filename, but Content-Disposition header is ignored.  `             webClient.get() // some code                     .retrieve()                     .toEntity(Resource::class.java) `  I think that is problem: https://github.com/spring-projects/spring-framework/blob/74f64c4e3b97cb419829cedcc6f703a78f9d0a5c/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultClientResponse.java#L93  Next code is ignored: https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java#L210  and: https://github.com/spring-projects/spring-framework/blob/7758ba3c7e4f21435ed927417eb3a13c37af5551/spring-web/src/main/java/org/springframework/http/codec/ResourceHttpMessageReader.java#L51","closed","status: duplicate,","dmkost","2020-11-09T16:50:16Z","2022-02-18T19:06:33Z"
"","26757","Spring Data Hadoop HBase - TableCallback incorrectly referencing HTableInterface instead of HTable","spring-data-hadoop-hbase 2.5.0 has an interface TableCallback with doInTable method.  The method takes one parameter table of type org.apache.hadoop.hbase.client.HTableInterface.  The issue is that org.apache.hadoop.hbase.client.HTableInterface is not longer present in org.apache.hbase:hbase-client.   org.apache.hadoop.hbase.client.HTableInterface was removed as from org.apache.hbase:hbase-client starting at version 2.0.0. Verified org.apache.hbase:hbase-client versions 2.3.3 and 2.4.2 and they just have HTable.  The reference documentation for Spring for Apache Hadoop shows code with HTable instead of HTableInterface.  See 7.1 Data Access Object(DAO) Support section for code example with HTable  The code I'm trying to execute is using the hbasetemplate.execute with the tablename and TableCallback.","closed","for: external-project,","shobson202","2021-04-02T19:07:02Z","2021-04-03T06:42:20Z"
"","25928","Unhelpful RuntimeException when javax.annotation-api.jar is missing from the classpath","spring-core-3.2.9.RELEASE.jar:  Due to use of @Nonnull in a method signature of a class parsed by springframework, when trying to run my application I get the following trace:  java.lang.RuntimeException: null 	at org.springframework.asm.MethodVisitor.visitTypeAnnotation(Unknown Source) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.asm.ClassReader.b(Unknown Source) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.asm.ClassReader.accept(Unknown Source) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.asm.ClassReader.accept(Unknown Source) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:64) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:80) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:102) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:76) ~[spring-core-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassUtils.checkConfigurationClassCandidate(ConfigurationClassUtils.java:71) ~[spring-context-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:255) ~[spring-context-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:225) ~[spring-context-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:630) ~[spring-context-3.2.9.RELEASE.jar:3.2.9.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:461) ~[spring-context-3.2.9.RELEASE.jar:3.2.9.RELEASE] ...  This is exceedingly unhelpful .. why not specify the missing class in the RuntimeException message, or at least set the cause of the RuntimeException to the (presumed) underlying ClassNotFoundException ?","closed","","dgrigglestone","2020-10-16T21:11:53Z","2022-02-18T19:06:31Z"
"","26205","ResolvableType.forClassWithGenerics gives wrong result","Spring version: 5.2.8.RELEASE.  Code:  ```java public class A {}  public class B extends A {}  public interface AService {}  public interface BService {}  public abstract class AbstractAService implements AService {}  @Component public class BServiceImpl extends AbstractAService implements BService {}  public class TempIT {      @Autowired     private AService autoService;      @Autowired     private ApplicationContext context;      @Test//PASSES     public void test_autowired() {         assertThat(autoService, is(notNullValue()));     }      @Test//FAILS     public void test_manual() {         AService manualService = null;         String[] beanNamesForType = context.getBeanNamesForType(ResolvableType.forClassWithGenerics(AService.class, A.class));         if (beanNamesForType.length != 0) {             manualService = (AService) context.getBean(beanNamesForType[0]);         }         assertThat(manualService, is(notNullValue()));     } } ```  So, the problem is, that when `AService` is auto wired everything works. However, when we try to get the same bean using `ResolvableType.forClassWithGenerics` we can't do it. I think this is a bug, but I am not a spring expert.","open","in: core,","PashaTurok","2020-12-03T11:16:04Z","2020-12-15T12:32:43Z"
"","26072","SimpleJdbcCall with namedBinding=true for Ms Sql Server","spring version: 5.0.8.RELEASE  I try to use setNamedBinding(true) on SimpleJdbcCall and get the generated statement in oracle syntax (call @P0 = proc_name Param1 => @P1, Param2=> @P2 ... )  I found this comment: https://github.com/spring-projects/spring-framework/issues/17398#issuecomment-453423378   Was it implemented for the MS SQL Server?","open","in: data,","iignateva","2020-11-11T17:08:44Z","2021-11-10T12:22:17Z"
"","26257","Provide API to Expose the Handling of PreFlight Requests in WebFlux","Spring MVC provides `HandlerMappingIntrospector` which exposes the `HandlerMapping`s CORS configuration through the `CorsConfigurationSource` interface. WebFlux allows users to register a `CorsConfigurationSource` through `AbstractHandlerMapping`, but does not provide a way for looking up the CORS configuration. This is important because in order for CORS to work with Spring Security the `CorsWebFilter` needs to be placed after the headers but before authorization. We want to inject headers, but preflight requests will not contain credentials in them so all authorization will be rejected.  It would be nice if WebFlux allowed for exposing the CORS configuration similar to how MVC does.","closed","type: enhancement,","rwinch","2020-12-10T21:32:04Z","2021-02-15T13:08:16Z"
"","26737","ResponseEntity Allows Body for 1xx, 204, 304 Statuses","Spring MVC allows constructing a ResponseEntity object with a body for HTTP statuses which do not allow one.  https://tools.ietf.org/html/rfc7230#section-3.3 > All 1xx (Informational), 204 (No Content), and 304 (Not Modified) responses do not include a message body.  This generates responses with a body, but no Content-Length header which fouls up some application servers, web servers (WebLogic for example).  For example, this should not be allowed: `return new ResponseEntity(""Deleted!"", HttpStatus.NO_CONTENT);`  This is acceptable: `return new ResponseEntity(HttpStatus.NO_CONTENT);`  And so is this: `return new ResponseEntity(""Deleted!"", HttpStatus.OK);`","closed","status: declined,","kev22257","2021-03-26T17:10:08Z","2021-05-26T09:11:38Z"
"","26344","Sending empty Flux to RSocket channel causes DecodingException: JSON decoding error: No content to map due to end-of-input","Spring Framework Version：5.3.2  Problem background: The application needs to send a result of a db query over RSocket channel. In some cases there are no elements in the result set and empty Flux is sent. This is normal from the business logic point of view.  I had a discussion about this problem with @OlegDokuka and he suggested to file the issue here (https://gitter.im/rsocket/rsocket-java?at=5fe36654ac9d8e7463c97042)  Application (server) entrypoint:  ```java     @MessageMapping(""objectChannel.{test}"")     Flux rsocketObjectChannel(@DestinationVariable String test, Flux flux) {         return flux                 .map(i -> i.plus(1, DAYS))                 .doOnNext(s -> System.out.println(""rsocketObjectChannel.next: "" + s))                 .doOnComplete(() -> System.out.println(""rsocketObjectChannel complete""));     } ```  Test (client) side:  ```java     @Test     void testEmptyObjectChannel() {         Flux data = Flux.empty();         Flux result = requester.route(""objectChannel.{test}"", ""route-var1"")                 .data(data)                 .retrieveFlux(Instant.class)                 .doOnComplete(() -> System.out.println(""testObjectChannel complete""));         StepVerifier                 .create(result)                 .verifyComplete();     } ```  Result:  ``` org.springframework.messaging.handler.invocation.MethodArgumentResolutionException: Could not resolve method parameter at index 1 in reactor.core.publisher.Flux com.gt.example.reactivedemo.RSocketServerHandler.rsocketObjectChannel(java.lang.String,reactor.core.publisher.Flux): Failed to read HTTP message; nested exception is org.springframework.core.codec.DecodingException: JSON decoding error: No content to map due to end-of-input; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: No content to map due to end-of-input  at [Source: (io.netty.buffer.ByteBufInputStream); line: -1, column: 0] 	at org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver.handleReadError(PayloadMethodArgumentResolver.java:266) ~[spring-messaging-5.3.2.jar:5.3.2] 	at org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver.lambda$decodeContent$2(PayloadMethodArgumentResolver.java:236) ~[spring-messaging-5.3.2.jar:5.3.2] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:94) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onError(FluxMap.java:132) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:112) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxSwitchOnFirst$SwitchOnFirstMain.tryOnNext(FluxSwitchOnFirst.java:363) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxSwitchOnFirst$AbstractSwitchOnFirstMain.drain(FluxSwitchOnFirst.java:297) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxSwitchOnFirst$AbstractSwitchOnFirstMain.request(FluxSwitchOnFirst.java:259) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:162) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.request(FluxPeek.java:137) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:162) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:162) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2154) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onSubscribe(FluxOnErrorResume.java:74) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:170) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxSwitchOnFirst$SwitchOnFirstMain.subscribe(FluxSwitchOnFirst.java:352) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.1.jar:3.4.1] 	at org.springframework.messaging.handler.invocation.reactive.ChannelSendOperator.subscribe(ChannelSendOperator.java:85) ~[spring-messaging-5.3.2.jar:5.3.2] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1784) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1784) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:251) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:336) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:180) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2346) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.request(MonoPeekTerminal.java:139) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:325) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onSubscribe(MonoPeekTerminal.java:152) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4046) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4046) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:208) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:80) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.Flux.subscribe(Flux.java:8147) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.core.publisher.FluxSwitchOnFirst$AbstractSwitchOnFirstMain.onNext(FluxSwitchOnFirst.java:157) ~[reactor-core-3.4.1.jar:3.4.1] 	at io.rsocket.core.RequestChannelResponderSubscriber.request(RequestChannelResponderSubscriber.java:241) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.FluxSwitchOnFirst$AbstractSwitchOnFirstMain.onSubscribe(FluxSwitchOnFirst.java:127) ~[reactor-core-3.4.1.jar:3.4.1] 	at io.rsocket.core.RequestChannelResponderSubscriber.subscribe(RequestChannelResponderSubscriber.java:164) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.1.jar:3.4.1] 	at io.rsocket.core.RSocketResponder.handleChannel(RSocketResponder.java:410) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.RSocketResponder.handleFrame(RSocketResponder.java:208) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:160) ~[reactor-core-3.4.1.jar:3.4.1] 	at io.rsocket.core.ClientServerInputMultiplexer$InternalDuplexConnection.onNext(ClientServerInputMultiplexer.java:248) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.ClientServerInputMultiplexer.onNext(ClientServerInputMultiplexer.java:129) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.ClientServerInputMultiplexer.onNext(ClientServerInputMultiplexer.java:48) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.SetupHandlingDuplexConnection.onNext(SetupHandlingDuplexConnection.java:118) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.SetupHandlingDuplexConnection.onNext(SetupHandlingDuplexConnection.java:19) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.1.jar:3.4.1] 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:265) ~[reactor-netty-core-1.0.2.jar:1.0.2] 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:371) ~[reactor-netty-core-1.0.2.jar:1.0.2] 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:381) ~[reactor-netty-core-1.0.2.jar:1.0.2] 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:544) ~[reactor-netty-http-1.0.2.jar:1.0.2] 	at reactor.netty.http.server.WebsocketServerOperations.onInboundNext(WebsocketServerOperations.java:161) ~[reactor-netty-http-1.0.2.jar:1.0.2] 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.2.jar:1.0.2] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311) ~[netty-codec-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432) ~[netty-codec-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.55.Final.jar:4.1.55.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.55.Final.jar:4.1.55.Final] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] Caused by: org.springframework.core.codec.DecodingException: JSON decoding error: No content to map due to end-of-input; nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: No content to map due to end-of-input  at [Source: (io.netty.buffer.ByteBufInputStream); line: -1, column: 0] 	at org.springframework.http.codec.json.AbstractJackson2Decoder.processException(AbstractJackson2Decoder.java:228) ~[spring-web-5.3.2.jar:5.3.2] 	at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:186) ~[spring-web-5.3.2.jar:5.3.2] 	at org.springframework.messaging.handler.annotation.reactive.PayloadMethodArgumentResolver.lambda$decodeContent$1(PayloadMethodArgumentResolver.java:235) ~[spring-messaging-5.3.2.jar:5.3.2] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) ~[reactor-core-3.4.1.jar:3.4.1] 	... 83 common frames omitted Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: No content to map due to end-of-input  at [Source: (io.netty.buffer.ByteBufInputStream); line: -1, column: 0] 	at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59) ~[jackson-databind-2.11.3.jar:2.11.3] 	at com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1468) ~[jackson-databind-2.11.3.jar:2.11.3] 	at com.fasterxml.jackson.databind.ObjectReader._initForReading(ObjectReader.java:360) ~[jackson-databind-2.11.3.jar:2.11.3] 	at com.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:2064) ~[jackson-databind-2.11.3.jar:2.11.3] 	at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1453) ~[jackson-databind-2.11.3.jar:2.11.3] 	at org.springframework.http.codec.json.AbstractJackson2Decoder.decode(AbstractJackson2Decoder.java:181) ~[spring-web-5.3.2.jar:5.3.2] 	... 85 common frames omitted ``` Expected behavior: Reactive pipeline on the server side does not fail with the exception above   For details, see https://github.com/MastaP/reactive-demo  RSocket handler: https://github.com/MastaP/reactive-demo/blob/master/src/main/java/com/gt/example/reactivedemo/RSocketServerHandler.java Tests: https://github.com/MastaP/reactive-demo/blob/master/src/test/java/com/gt/example/reactivedemo/BaseDemoTests.java","closed","type: bug,","MastaP","2021-01-04T14:41:03Z","2021-01-07T17:26:35Z"
"","26328","When default value is configured for property placeholder in @Value, subsequent embedded value resolvers are asked to resolve the default value instead of the original value","Spring Framework version is `5.2.5.RELEASE`.  ----  `org.springframework.beans.factory.support.AbstractBeanFactory#resolveEmbeddedValue`  ![image](https://user-images.githubusercontent.com/39358545/103391634-609ae780-4b55-11eb-8351-4166135b66e2.png)  ----  ### Example configuration  ```java @Value(""${server.servlet.context-path:/}"") ```  ### Current behavior  1. When there are multiple `embeddedValueResolvers` registered in the `AbstractBeanFactory` and the first resolver cannot resolve the supplied value, then return `/`. 2. The return value `/` is supplied as the argument for the next resolver's `resolveStringValue()` method, and even if the next resolver is configured to handle resolution of `server.servlet.context-path`, the final result is always `/`.","open","status: feedback-provided,","DS4XM","2020-12-31T03:00:47Z","2021-01-14T10:01:15Z"
"","26153","Notify that the JPA infrastructure is ready for use","Spring Framework supports a background setup of the JPA instructure in a separated thread. While the [current section of the documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#orm-jpa-setup-background) explains the impact in terms of proxying, it does not explicitly warn users they should not attempt to use the EMF during the context bootstrap phase.  Related to that, there is a need to get a callback once the infrastructure has fully initialised and the lock is released. Publishing an event and documenting how users can listen to it could be a nice alternative to what they're currently doing in `@PostConstuct` or other framework callbacks that are not recommended for this type of setup. If that's accepted, the event should be published either way so that users can rely on that if they chose to bootstrap the JPA infrastructure on the main thread.","open","in: data,","snicoll","2020-11-25T12:52:05Z","2021-11-12T14:15:41Z"
"","26555","Dependency on Servlet 4.0 in spring-test makes it challenging to have Servlet 3.1 at runtime","Spring Framework 5.x is documented as requiring only Servlet 3.1 (EE7). However, a recent change (commit f22e2ac578f6db8f988cbbee0af5f381a86fdd04 by @rstoyanchev, included in 5.3.4) introduces a reference to `javax.servlet.http.HttpServletMapping` into `MockHttpServletRequest`.  The referenced API is part of Servlet 4.0 (EE8) and is not present in Servlet 3.1.  It seems extremely unlikely that a dependency change to a new major version of the Servlet spec was intentionally introduced as part of a patch release of Spring Framework.  If I am not misunderstanding something here, it seems like this would need to be reverted.","closed","type: regression,","iay","2021-02-16T14:34:46Z","2021-02-19T12:08:24Z"
"","26690","MappedInterceptor in 5.3 does not support all AntPatternMatcher patterns","Spring Framework 5.3 (up to 5.3.5) `MappedInterceptor`'s constructor effectively prevents the use of any `PathMatcher`, including legacy `AntPathMatcher`, making it completely incompatible with all earlier versions. Here is why: 1. The `InterceptorRegistration#getInterceptor` tries to create `MappedInterceptor`, however it'll fail, due to 2.  ```java 	protected Object getInterceptor() {  		if (this.includePatterns == null && this.excludePatterns == null) { 			return this.interceptor; 		}  		MappedInterceptor mappedInterceptor = new MappedInterceptor( 				StringUtils.toStringArray(this.includePatterns), 				StringUtils.toStringArray(this.excludePatterns), 				this.interceptor);  		if (this.pathMatcher != null) { 			mappedInterceptor.setPathMatcher(this.pathMatcher); 		}  		return mappedInterceptor; 	}  ```  2. `MappedInterceptor`'s base constructor calls MappedInterceptor#initPatterns, which would use the default `PathPatternParser` and will fail for the Ant-like patterns and suffixes (old style) no matter whether set in `PathMatchConfigurer` or not: ```java 	public MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns, 			HandlerInterceptor interceptor, @Nullable PathPatternParser parser) {  		this.includePatterns = initPatterns(includePatterns, parser); 		this.excludePatterns = initPatterns(excludePatterns, parser); 		this.interceptor = interceptor; 	}  	@Nullable 	private static PathPattern[] initPatterns( 			@Nullable String[] patterns, @Nullable PathPatternParser parser) {  		if (ObjectUtils.isEmpty(patterns)) { 			return null; 		} 		parser = (parser != null ? parser : PathPatternParser.defaultInstance); 		return Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new); 	}  ```  The problem is that include/excludePatterns type have changed from String[] to PathPattern[]. As a possible solution to this could be having a chameleon PathPattern, i.e. NOOP PathPattern holding just the String underneath and having isNoop() to differentiate from the real ones, to be used in concert with the MappedInterceptor constructor with a PathMatcher parameter, and the rest of the MappedInterceptor code checking for isNoop() accordingly.  In addition, `MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns, HandlerInterceptor interceptor)` can be using such NOOP PathPattern  and be compatible with  `InterceptorRegistration#getInterceptor` and friends.  Unless there is a simple and obvious solution/config already, this is a major, showstopper bug.  Thanks much in advance, David","closed","type: regression,","protobufel2","2021-03-17T03:49:34Z","2021-03-22T23:12:24Z"
"","26428","Provide a way to modify RequestMappingInfo conditions","Spring Data Rest needs to take a `RequestMappingInfo` and modify the produces condition. It's currently not possible to do this because the [required constructor](https://github.com/spring-projects/spring-framework/blob/e537844a093d313595e20cc440506fe8b04bc7db/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfo.java#L154) is `private`.  I think that constructor either needs to be `public`, or we need some `with...` methods that return new instances with updated values (similar to [`addCustomCondition`](https://github.com/spring-projects/spring-framework/blob/e537844a093d313595e20cc440506fe8b04bc7db/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfo.java#L309).","closed","type: enhancement,","philwebb","2021-01-21T20:13:03Z","2021-01-26T22:09:40Z"
"","26021","Add support for as(Class) in DatabaseClient","Spring Data R2DBC's `DatabaseClient` provided a rich fluent API including functionality that allowed a convenient mapping of results into a particular type through `as(Class)`. During the migration of `DatabaseClient` we decided to drop that functionality to provide functionality that we knew how to provide from a Spring Framework perspective. Target object mapping in Spring Data used core Spring Data functionality that isn't available on the Spring Framework level.  We see a lot of demand for a method that is convenient to use from the caller side and that applies convention-based mapping of primitives  (Java primitives and R2DBC primitives) and data classes.  Right now, mapping requires a mapping function to be used through `map(BiFunction)`.","open","type: enhancement,","mp911de","2020-11-03T08:35:02Z","2021-11-01T11:37:50Z"
"","26265","Required request part 'file' is not present error with MockMvc multipart tests","Spring boot version: `2.4.1`  Test: ``` @Test @WithMockUser(roles = ""APP_OWNER"") void given_application_owner_then_applicationUpload_should_throw_403() throws Exception { 	MockMultipartFile file = new MockMultipartFile(""file"", ""some content"".getBytes()); 	mockMvc.perform( 			multipart(""/applications/actions/upload"").file(file).header(""Content-Type"", ""multipart/form-data"")) 			.andExpect(status().isForbidden()); } ```  Controller: ``` @PostMapping(value = ""/actions/upload"", 		consumes = { MediaType.MULTIPART_FORM_DATA_VALUE, ""multipart/form-data;charset=UTF-8"" }) @RolesAllowed(""ADMIN"") public List uploadApplications(@RequestParam(""file"") MultipartFile file) { 	// Do something here } ```  Expected result: `403` error Actual result: `400` ``` MockHttpServletResponse:            Status = 400     Error message = Required request part 'file' is not present           Headers = [X-Content-Type-Options:""nosniff"", X-XSS-Protection:""1; mode=block"", Cache-Control:""no-cache, no-store, max-age=0, must-revalidate"", Pragma:""no-cache"", Expires:""0"", X-Frame-Options:""DENY""]      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = [] ```  Same code is working as expected with spring-boot 2.4.0","closed","status: duplicate,","sudhirtumati","2020-12-13T05:46:14Z","2020-12-14T12:52:23Z"
"","26388","Update documentation with details on content negotiation and the order of converter registrations","Spring Boot version 2.4.0 Also testing in spring boot 1.3.2.RELEASE When the default content type is set to XML if a request comes in that allows a `""*/*""` response then a JSON response is returned.  **Clarification** - A header that **allows** a `""*/*""` response. For example `""Accept: text/html, */*""` but not the wildcard header itself, `""Accept:*/*""`. Note that this sentence wasn't in the initial ticket.  Workaround: Add in a `Jaxb2CollectionHttpMessageConverter` and a `Jaxb2RootElementHttpMessageConverter` as the first convertors.   Problems with the workaround.  This is undocumented behaviour checking the documentation of https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List- It doesn't say that the order of the convertors matter.  Either this should be documented ""Order of HttpConverters matters"" or there should be a different resolution strategy.  Therefore I'm concerned that the workaround may be less than stable.  It would be good to have an explicit favoured response type that is returned when there are equal priorities in content negotiation strategies.   A full application that uses this is posted to a related stackoverflow ticket https://stackoverflow.com/questions/65689179/how-do-you-configure-spring-boot-2-to-return-xml-by-default/65702088#65702088  I can send the file if required. Or zip up a project.","closed","in: web,","Athas1980","2021-01-14T14:13:40Z","2021-02-05T13:28:47Z"
"","26771","Add PrematureCloseException to WebFlux HttpWebHandlerAdapter","Spring Boot has had a PR raised to add `PrematureCloseException` to our `AbstractErrorWebExceptionHandler` (see https://github.com/spring-projects/spring-boot/pull/25886). Since these values are copied from `HttpWebHandlerAdapter` I want to raise the same issue for consideration in Framework before we merge the PR.","closed","status: invalid,","philwebb","2021-04-06T20:11:38Z","2021-04-08T12:35:44Z"
"","26712","Reactive AbstractErrorWebExceptionHandler#htmlEscape() may be blocking","Spring Boot 2.4.4 using WebFlux Spring Framework 5.3.5 Spring Cloud Gateway 3.0.2  ---  Blocking call detected by [Blockhound](https://github.com/reactor/BlockHound) when returning an error response to a browser. In particular, saw this happening when the browser sends a `GET /favicon.ico` request, resulting in a 404 whitelabel error page being rendered.  As a workaround for now, I've disabled the whitelabel error page by setting `server.error.whitelabel.enabled` to `false`.  The call to [`AbstractErrorWebExceptionHandler#htmlEscape()`](https://github.com/spring-projects/spring-boot/blob/v2.4.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/error/AbstractErrorWebExceptionHandler.java#L295) can trigger the initialisation of Spring Framework's static class [`HtmlUtils`](https://github.com/spring-projects/spring-framework/blob/v5.3.5/spring-web/src/main/java/org/springframework/web/util/HtmlUtils.java#L41). One of its static field - [`characterEntityReferences`](https://github.com/spring-projects/spring-framework/blob/v5.3.5/spring-web/src/main/java/org/springframework/web/util/HtmlUtils.java#L46) - is of type [`HtmlCharacterEntityReferences`](https://github.com/spring-projects/spring-framework/blob/v5.3.5/spring-web/src/main/java/org/springframework/web/util/HtmlCharacterEntityReferences.java) and its constructor [loads the file `HtmlCharacterEntityReferences.properties` in a blocking way](https://github.com/spring-projects/spring-framework/blob/v5.3.5/spring-web/src/main/java/org/springframework/web/util/HtmlCharacterEntityReferences.java#L75).  Full stacktrace: ``` reactor.blockhound.BlockingOperationError: Blocking call! java.io.RandomAccessFile#readBytes 	at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Assembly trace from producer [reactor.core.publisher.MonoFlatMap] : 	reactor.core.publisher.Mono.flatMap 	org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.handle(AbstractErrorWebExceptionHandler.java:326) Error has been observed at the following site(s): 	|_       Mono.flatMap ⇢ at org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.handle(AbstractErrorWebExceptionHandler.java:326) 	|_      Mono.doOnNext ⇢ at org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.handle(AbstractErrorWebExceptionHandler.java:327) 	|_       Mono.flatMap ⇢ at org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.handle(AbstractErrorWebExceptionHandler.java:328) 	|_                    ⇢ at org.springframework.web.server.handler.ExceptionHandlingWebHandler.lambda$handle$0(ExceptionHandlingWebHandler.java:77) 	|_ Mono.onErrorResume ⇢ at org.springframework.web.server.handler.ExceptionHandlingWebHandler.handle(ExceptionHandlingWebHandler.java:77) 	|_         Mono.error ⇢ at org.springframework.web.server.handler.ResponseStatusExceptionHandler.handle(ResponseStatusExceptionHandler.java:67) 	|_                    ⇢ at org.springframework.web.server.handler.ExceptionHandlingWebHandler.lambda$handle$0(ExceptionHandlingWebHandler.java:77) 	|_ Mono.onErrorResume ⇢ at org.springframework.web.server.handler.ExceptionHandlingWebHandler.handle(ExceptionHandlingWebHandler.java:77) 	|_   Mono.doOnSuccess ⇢ at org.springframework.web.server.adapter.HttpWebHandlerAdapter.handle(HttpWebHandlerAdapter.java:249) Stack trace: 		at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) 		at java.base/java.io.RandomAccessFile.read(RandomAccessFile.java:406) 		at java.base/java.io.RandomAccessFile.readFully(RandomAccessFile.java:470) 		at java.base/java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1318) 		at java.base/java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:1003) 		at java.base/java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:1018) 		at java.base/java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:468) 		at java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) 		at java.base/java.io.FilterInputStream.read(FilterInputStream.java:133) 		at java.base/java.io.FilterInputStream.read(FilterInputStream.java:107) 		at java.base/java.util.Properties$LineReader.readLine(Properties.java:502) 		at java.base/java.util.Properties.load0(Properties.java:418) 		at java.base/java.util.Properties.load(Properties.java:407) 		at org.springframework.web.util.HtmlCharacterEntityReferences.(HtmlCharacterEntityReferences.java:75) 		at org.springframework.web.util.HtmlUtils.(HtmlUtils.java:46) 		at org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.htmlEscape(AbstractErrorWebExceptionHandler.java:295) 		at org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.renderDefaultErrorView(AbstractErrorWebExceptionHandler.java:282) 		at org.springframework.boot.autoconfigure.web.reactive.error.DefaultErrorWebExceptionHandler.renderErrorView(DefaultErrorWebExceptionHandler.java:141) 		at org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.lambda$handle$0(AbstractErrorWebExceptionHandler.java:326) 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:125) 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) 		at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onNext(FluxConcatArray.java:177) 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2193) 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:2067) 		at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4099) 		at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:208) 		at reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:80) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4099) 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 		at reactor.core.publisher.Operators.error(Operators.java:197) 		at reactor.core.publisher.MonoError.subscribe(MonoError.java:52) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4099) 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 		at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) 		at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) 		at org.springframework.cloud.sleuth.instrument.web.TraceWebFilter$MonoWebFilterTrace$WebFilterTraceSubscriber.onError(TraceWebFilter.java:255) 		at reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onError(FluxDoFinally.java:136) 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:172) 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:172) 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2062) 		at reactor.core.publisher.Operators.error(Operators.java:197) 		at reactor.core.publisher.MonoError.subscribe(MonoError.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4099) 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:81) 		at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:102) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:366) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:218) 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:164) 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at org.springframework.cloud.sleuth.instrument.web.TraceWebFilter$MonoWebFilterTrace.subscribe(TraceWebFilter.java:170) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4099) 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:173) 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.netty.http.server.HttpServer$HttpServerHandle.onStateChange(HttpServer.java:915) 		at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:654) 		at reactor.netty.transport.ServerTransport$ChildObserver.onStateChange(ServerTransport.java:478) 		at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:526) 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:209) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","type: enhancement,","sguillope","2021-03-22T12:38:00Z","2021-03-24T11:31:55Z"
"","26057","FlightRecorderApplicationStartup exception on processing Http Request","Spring Boot 2.4.0-RC1 application with  1. applicationStartup(new FlightRecorderApplicationStartup()) 2. web mvc controller   starts ok, and I can see messages in JDK mission control. I can execute few requests manually in browser, and they work ok... But, when I do a load test with JMeter - i get exceptions:  ``` java.util.NoSuchElementException: null 	at java.base/java.util.ArrayDeque.getFirst(ArrayDeque.java:402) ~[na:na] 	at org.springframework.core.metrics.jfr.FlightRecorderApplicationStartup.start(FlightRecorderApplicationStartup.java:55) ~[spring-core-5.3.0.jar:5.3.0] 	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:160) ~[spring-context-5.3.0.jar:5.3.0] 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:426) ~[spring-context-5.3.0.jar:5.3.0] 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:383) ~[spring-context-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.FrameworkServlet.publishRequestHandledEvent(FrameworkServlet.java:1141) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1023) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] ```  Please find test application at: https://github.com/lvivJavaClub/jfr-demo/tree/issue_branch and very simple jmeter scenario https://github.com/lvivJavaClub/jfr-demo/blob/issue_branch/jfr_test_plan.jmx","closed","in: core,","ivan-shevtsov","2020-11-09T20:18:38Z","2020-12-03T14:44:11Z"
"","26149","@Validated occasionally throws ConstraintDeclarationException from Hibernate Validator on JDK 15","Spring Boot 2.2.6, Spring Cloud Greenwich.RELEASE (I have since realized that I should be using the Hoxton branch with 2.2.x, which I have upgraded to now)  Following the suggestion from https://stackoverflow.com/questions/57811421/how-to-validate-request-parameters-on-feign-client/61635351#61635351, I can successfully use a validated Feign interface like this:  ```java @Validated @FeignClient( name = ""gps-service"", path = ""${infrastructure.base-path.gps-service}"" ) public interface GpsClient {    @PostMapping( value = ""/files/gpslogs"" )    GpsLogFileResult triggerGpsLogFile( @RequestBody @Valid @NotNull GpsLogFileParameters parameters ); }  ```  That is, this works _most_ of the time. Very rarely, but then seemingly in bursts, the call to `triggerGpsLogFile` fails due to an exception like shown below. This application runs in a Kubernetes cluster and there are usually many thousands of calls to this method per day without the exception. Then one day, there are suddenly around 100 cases of the `ConstraintDeclarationException` within a time span of 10 minutes, only to be gone again afterwards.  ``` javax.validation.ConstraintDeclarationException: HV000152: Two methods defined in parallel types must not declare parameter constraints, if they are overridden by the same method, but methods $Proxy268#triggerGpsLogFile(GpsLogFileParameters) and GpsClient#triggerGpsLogFile(GpsLogFileParameters) both define parameter constraints. 	at org.hibernate.validator.internal.metadata.aggregated.rule.ParallelMethodsMustNotDefineParameterConstraints.apply(ParallelMethodsMustNotDefineParameterConstraints.java:23) 	at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.assertCorrectnessOfConfiguration(ExecutableMetaData.java:461) 	at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:377) 	at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) 	at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:204) 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:166) 	at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:265) 	at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:233) 	at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:105) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) 	at com.sun.proxy.$Proxy269.triggerGpsLogFile(Unknown Source) 	at com.acme.application.service.GpsService.triggerGpsLogFile(GpsService.java:227)  ```  `GpsService.triggerGpsLogFile()` makes the call to `GpsClient.triggerGpsLogFile()`.  Having read the [relevant Hibernate Validator documentation](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-method-constraints-inheritance-hierarchies) and the source code of `ParallelMethodsMustNotDefineParameterConstraints`, I understand that Bean Validation method parameter annotations on overridden/implementing methods may pose a problem.  And as @wilkinsona pointed out at https://github.com/spring-projects/spring-boot/issues/17000, `@Validated` is realized by dynamic proxies (which can also be seen in the stacktrace above). So I kind of see why this could be a problem. But then I don't understand why the vast majority of calls work correctly, also throwing a `ConstraintViolationException` (note: Violation <-> Declaration) if applicable.  I couldn't find any official documentation about using `@Validated` on a `@FeignClient`, maybe that's for a reason and what I'm doing is basically unsupported?","closed","in: core,","jo-ka","2020-11-24T19:33:15Z","2021-03-25T15:20:48Z"
"","26025","Add FullyQualifiedAnnotationBeanNameGenerator.INSTANCE","Spring 5.2.3 (b4c91e7dac91c6176a5412ed930d2c048cc5c42f) introduces the `FullyQualifiedAnnotationBeanNameGenerator`, but does not override/hide the static `INSTANCE` field from its parent, which seems confusing to me. Someone might access `FullyQualifiedAnnotationBeanNameGenerator.INSTANCE` and get a `AnnotationBeanNameGenerator` instead. Just like I did. 😅   This PR aims to solve that by adding a static `INSTANCE` field to `FullyQualifiedAnnotationBeanNameGenerator`, like its parent does too.","closed","in: core,","evpaassen","2020-11-03T17:14:12Z","2020-11-04T16:39:13Z"
"","26179","@EnableConfigurationProperties mark internal class happen exception","spring 5.1.9-RELEASE spring boot 2.1.7-RELEASE when i has internal class to register ,i use @EnableConfigurationProperties marks on class A and B  ,at this time  has  happen exception; i remove the class A  annotation;at this time started successful; the class B use @EnableConfigurationProperties registering  C,at this time B is also registered,the classB should b be registered at this time ? But when I move the two internal classes to the same level as a, both class A and class B have to be @EnableConfigurationProperties  annotated to complete the startup  [TestConfiguration.txt](https://github.com/spring-projects/spring-framework/files/5615267/TestConfiguration.txt)","closed","for: stackoverflow,","biuabiu","2020-11-30T10:17:30Z","2020-11-30T12:36:12Z"
"","26653","How to monitor `org.springframework.cache.interceptor.AbstractCacheInvoker#doEvict`?","Sorry to disturb you.  I wanna monitor `org.springframework.cache.interceptor.AbstractCacheInvoker#doEvict` and handle some extra logic in it, and then I see it in the code` org.springframework.cache.interceptor.CacheInterceptor `.   I try to customize the overlay behavior, just like[https://github.com/spring-projects/spring-framework/issues/22641](https://github.com/spring-projects/spring-framework/issues/22641).  `org.springframework.cache.annotation.ProxyCachingConfiguration`， It seems that this registered class is designed to not allow custom interceptor extensions.  Please help, do I have any other way now?","closed","for: stackoverflow,","dongfangding","2021-03-09T06:15:32Z","2021-03-09T07:06:36Z"
"","26241","Introduce @Secondary beans in ressemblence of @Primary beans.","Sometimes, one wants to be able to register a bean of a given type without breaking existing code, especially in multi-module projects. Assuming that a bean is already available:  ```java @Bean public SomeType someTypeBean() {   return new SomeType(); } ```  and used as in:  ```java @Bean public SomeOtherType someOtherTypeBean(SomeType val) {   return new SomeOtherType(val); } ```  I would like to being able to register a bean:  ```java @Bean @Secondary // mirrored behavior of @Primary public SomeType someNewTypeBean() {   return new SomeType(); } ```  without disturbing existing code. If the *someTypeBean* is missing, it should fallback to *someNewTypeBean*, this would also allow for much smoother migrations in the case of multiple profiles.","open","in: core,","raphw","2020-12-08T12:13:48Z","2021-11-10T11:58:07Z"
"","26557","ResultSet holdability into the View layer broken by Hibernate 5","Some time ago a fix was introduced for this: https://github.com/spring-projects/spring-framework/issues/16954 . It allows specifying that ResultSets should be held open beyond transaction commit. (Separate problem: there's no easy way to do this for JPATransactionManager, which makes usage with Spring Data hard). In the meantime, however, changes made in Hibernate 5 have re-broken this functionality. Hibernate now aggressively closes all JDBC resources on transaction commit, and the Hibernate maintainers have basically said that cursor holdability is evil and they're not interested in supporting it (https://discourse.hibernate.org/t/resultset-holdability-not-working-with-hibernate/1445/9)  As things stand, this makes it pretty much impossible (AFAICT) to build a fully streaming stack from database to MVC layer (using Open Session In View) - in particular a streaming REST API that returns a stream of JSON objects from a large dataset. It also renders HibernateTransactionManager.allowResultSetAccessAfterCompletion pointless because Hibernate closes the result set anyway, irrespective of the behaviour of the underlying JDBC driver.  It's not clear to me if there's a viable solution for any of this, but as a minimum it would be great if this was clearly documented as a limitation. I've spent hours wandering through issues, forum posts + SO answers getting conflicting information about this and it would be good to have a definitive statement of what is and isn't possible in this regard","open","type: documentation,","symposion","2021-02-17T09:54:10Z","2021-10-27T15:00:15Z"
"","26698","MimeType: Multipart Boundary value should allow `=`","Some HTTP clients use boundary value including `=` when sending multipart requests, like below: ``` Content-Type: multipart/form-data; boundary====1616056691487=== ```  It seems `=` is fine for boundary value per [RFC 2046 5.1.1](https://tools.ietf.org/html/rfc2046#section-5.1.1): ```    The only mandatory global parameter for the ""multipart"" media type is    the boundary parameter, which consists of 1 to 70 characters from a    set of characters known to be very robust through mail gateways, and    NOT ending with white space. (If a boundary delimiter line appears to    end with white space, the white space must be presumed to have been    added by a gateway, and must be deleted.)  It is formally specified    by the following BNF:       boundary := 0*69 bcharsnospace       bchars := bcharsnospace / "" ""       bcharsnospace := DIGIT / ALPHA / ""'"" / ""("" / "")"" /                       ""+"" / ""_"" / "","" / ""-"" / ""."" /                       ""/"" / "":"" / ""="" / ""?"" ```  But `org.springframework.util.MimeType` doesn't allow `=` characters, because it is considered as separator.  Spring should allow `=` characters for compatibility with such HTTP clients.  Edit: It used to work with Spring 4.X (Spring Boot 1.X)","closed","status: feedback-provided,","bekker","2021-03-18T10:56:15Z","2021-03-31T10:42:48Z"
"","26058","Solve duplicate registration of beans of type MergedBeanDefinitionPostProcessor.","Solve duplicate registration of beans of type MergedBeanDefinitionPostProcessor,although it is deleted and then added in the addBeanPostProcessor process, it is not necessary.","closed","in: core,","hzmpay","2020-11-10T03:24:28Z","2021-12-10T23:11:47Z"
"","25972","Solve duplicate registration of beans of type MergedBeanDefinitionPostProcessor.","Solve duplicate registration of beans of type MergedBeanDefinitionPostProcessor,although it is deleted and then added in the addBeanPostProcessor process, it is not necessary","closed","","hzmpay","2020-10-26T10:05:39Z","2022-02-18T19:06:32Z"
"","25877","Add limit for init SQL by InitSqlFilter","so we can skip some sql statements by regex pattern, such as: we do not want run delete/update/drop statements on production environment. just call ResourceDatabasePopulator.ignoreDeleteUpdateDrop to lock sqlIgnorePattern=^\\s*(delete|drop|update).+  sorry for my poor english...and someone please help me fix  the english javadocs!","open","in: data,","qxo","2020-10-07T16:28:31Z","2021-04-27T05:06:14Z"
"","26536","WebSocketMessageBrokerStats has null stats for stompSubProtocolHandler since 5.3.2","Since upgrading spring-websockets library to version 5.3.2 I've noticed the `WebSocketMessageBrokerStats` class no longer provides metrics for `stompSubProtocolHandler`. I think I've traced it down to different bean creation order between two library versions, in which the `webSocketMessageBrokerStats` bean is constructed before the `stompWebSocketHandlerMapping` which adds a `stompSubProtocolHandler` from adding a stomp endpoint.  ----  A quick summary of the difference:  Broken since Spring Boot 2.4.1 with websocket 5.3.2 Here's the call order I'm seeing in the new version: 1. Bean constructed: `WebSocketMessageBrokerConfigurationSupport#subProtocolWebSocketHandler` 2. Bean constructed: `WebSocketMessageBrokerConfigurationSupport#webSocketMessageBrokerStats`     - `subProtocolWebSocketHandler` bean at this stage has no `protocolHandlers` and no `defaultProtocolHandler`     - `WebSocketMessageBrokerStats#setSubProtocolWebSocketHandler` sets `stompSubProtocolHandler` to null 3. Bean constructed: `WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping`     - calls `WebSocketMessageBrokerConfigurationSupport#registerStompEndpoints`     - `registry.addEndpoint(...)` adds one `protocolHandler` to `webSocketHandler` 4. When trying to access `WebSocketMessageBrokerStats#getStompSubProtocolStatsInfo` `""null""` string is returned.   Was working in Spring Boot 2.4.0 with websocket 5.3.1 Call chain for the 'working' version where `webSocketMessageBrokerStats.stompSubProtocolStatsInfo` doesn't return null. 1. Bean constructed: `WebSocketMessageBrokerConfigurationSupport#subProtocolWebSocketHandler` 2. Bean constructed: `WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping`     - calls `WebSocketMessageBrokerConfigurationSupport#registerStompEndpoints`     - `registry.addEndpoint(...)` adds one `protocolHandler` to `webSocketHandler` 3. Bean constructed: `WebSocketMessageBrokerConfigurationSupport#webSocketMessageBrokerStats`     - `subProtocolWebSocketHandler` bean at this stage has one `protocolHandlers` and no `defaultProtocolHandler` 4. When trying to access `WebSocketMessageBrokerStats#getStompSubProtocolStatsInfo` `processed CONNECT(0)-CONNECTED(0)-DISCONNECT(0)` string is returned, which is expected.  ----  I also created a demo app for the issue here https://github.com/countableSet/spring-websocket-metrics-bug-demo  Just flip between spring boot versions `2.4.0` and `2.4.1` you should be able to see the issue in std.out.","open","in: web,","countableSet","2021-02-10T20:57:18Z","2021-11-10T11:43:10Z"
"","26171","Spring default characterEncoding","Since Spring 5.2 MediaType.APPLICATION_JSON_UTF8 is @Deprecated as described within MediaType class:  ```java /**  * A String equivalent of \{@link MediaType#APPLICATION_JSON_UTF8}.  * @deprecated as of 5.2 in favor of \{@link #APPLICATION_JSON_VALUE}  * since major browsers like Chrome  *   * now comply with the specification and interpret correctly UTF-8 special  * characters without requiring a \{@code charset=UTF-8} parameter.  */ @Deprecated public static final String APPLICATION_JSON_UTF8_VALUE = ""application/json;charset=UTF-8""; ```  So basically everyone should be using `MediaType.APPLICATION_JSON_VALUE` without (UTF8 information) instead. This is unfortunately in conflict with `MockHttpServletResponse`:  ```java private String characterEncoding = ""ISO-8859-1""; ```  So even thought UTF8 is expected by default, the testing environment is in violation with aboves:  ``` now comply with the specification and interpret correctly UTF-8 special ```  The tests which explicitly don't override this encoding will fail.","closed","in: web,","knyttl","2020-11-27T18:18:23Z","2020-11-30T16:13:03Z"
"","26569","DataClassRowMapper should not override Kotlin init properties","Since Kotlin data classes are already constructed with values we don't want to override all the properties later on again. Properties modified in the init { } block in a class would be reverted back to the value of the column again.  An example of this would be setting the default scale of a BigDecimal inside an init block. The init would be called and set the scale after constructing. However, after constructing the BeanPropertyRowMapper would override the BigDecimal again so the scale would be 0 again.  This commit fixes this issue for Kotlin data classes.","closed","type: bug,","dennie170","2021-02-18T15:22:11Z","2021-07-12T07:20:12Z"
"","26088","Null passed in required `@RequestParam` now fails","Since 5.3.1 version null, passed for required nullable parameter throws Exception ""is not present""  ```java @RequestMapping(""/findTree"") public void findTree(@RequestParam(""parentId"") Long parentId) {   if (parentId == null) {     //Root   } else {     //Is not root   } } ```  now, i send request `""/myurl/findTree?parentId=""`  Expected behavior  - parameter `parentId` passed to method as `null` Current behavior - exception within `AbstractNamedValueMethodArgumentResolver`","closed","in: web,","bostandyksoft","2020-11-13T06:29:14Z","2021-03-08T15:42:11Z"
"","26519","Simplify BeanUtils.findPrimaryConstructor()","Simplified code.","closed","in: core,","1993heqiang","2021-02-07T14:56:41Z","2021-02-09T12:45:29Z"
"","26348","Add Revved up by Gradle Enterprise badge to Readme","Similar to: https://github.com/spring-projects/spring-boot/pull/24640","closed","type: task,","runningcode","2021-01-05T16:25:37Z","2021-01-11T09:21:48Z"
"","26517","Autowiring shortcut fails with NoSuchBeanDefinitionException after removeBeanDefinition call","service start, then i call `BeanDefinitionRegistry:removeBeanDefinition` method, and the bean is `@Autowired(required = false)` for other bean, last i request api interface, throw exception for below:  ``` Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'testBean' available 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:816) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1288) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:277) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$ShortcutDependencyDescriptor.resolveShortcut(AutowiredAnnotationBeanPostProcessor.java:795) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1239) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1227) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.resolvedCachedArgument(AutowiredAnnotationBeanPostProcessor.java:601) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.access$000(AutowiredAnnotationBeanPostProcessor.java:131) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:631) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	... 82 more ```","closed","in: core,","liaomengge","2021-02-07T10:10:08Z","2021-02-14T16:59:08Z"
"","26868","LinkedCaseInsensitiveMap#putIfAbsent does not honor the case where the key is associated with a null value","Seems to be a bug that `LinkedCaseInsensitiveMap#putIfAbsent` does not honor the case where the key is associated with a `null` value.   Here is the javadoc inherited from `java.util.Map`.  > If the specified key is not already associated with a value (**or is mapped to null**) associates it with the given value and returns null, else returns the current value.  Here is the code showing the difference with the normal map:  ```java         Map normalMap = new HashMap<>();         Map caseInsensitiveMap = new LinkedCaseInsensitiveMap<>();         normalMap.put(""key"", null);         System.out.println(""normal map:"" + normalMap);         normalMap.putIfAbsent(""key"", ""value"");         System.out.println(""normal map:"" + normalMap);          caseInsensitiveMap.put(""key"", null);         System.out.println(""case insensitive map"" + caseInsensitiveMap);         caseInsensitiveMap.putIfAbsent(""key"", ""value"");         System.out.println(""case insensitive map"" + caseInsensitiveMap); ```  Output:  ``` normal map:{key=null} normal map:{key=value} case insensitive map{key=null} case insensitive map{key=null} ```  According to the javadoc it should return `null` and make the change, but the code only returns `null`. The line: `return this.targetMap.get(oldKey)`.  The implementation:  ```java         @Override 	@Nullable 	public V putIfAbsent(String key, @Nullable V value) { 		String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key); 		if (oldKey != null) { 			return this.targetMap.get(oldKey); 		} 		return this.targetMap.putIfAbsent(key, value); 	} ```  Spring version: 5.3.5","closed","in: core,","metaruslan","2021-04-27T12:02:57Z","2021-04-30T13:50:09Z"
"","26223","Add Hibernate Reactive support","See: http://hibernate.org/reactive/documentation/1.0/reference/html_single/  Change the current Hibernate/JPA support and make it is easy to expose an EntityManagerFactory to use Hibernate Reactive.  Currently, Hibernate Reactive supports Java 8 Completable Stage and Munity, see #26222. Also hope add Reactor API support to the EMFactory.","open","in: data,","hantsy","2020-12-06T08:18:11Z","2021-11-10T11:28:35Z"
"","26543","Upgrade to JUnit 4.13.2","See the [JUnit 4.13.2 release notes](https://github.com/junit-team/junit4/blob/HEAD/doc/ReleaseNotes4.13.2.md) for details.","closed","type: dependency-upgrade,","sbrannen","2021-02-13T18:26:59Z","2021-02-13T18:28:01Z"
"","26561","ResourceUrlProvider detects wrong set of handler mappings","See spring-projects/spring-boot#25113 for more context.  `ResourceUrlProvider` is listening on `ContextRefreshedEvent` to detect automatically instances of `SimpleUrlHandlerMapping` and use them for writing URLs to resources. Once handlers are detected the provider locks itself from further modifications.  With a parent/child context setup and under specific conditions due to ordering, the `ResourceUrlProvider` might receive a `ContextRefreshedEvent` from a child context first, thus detecting the wrong set of handlers and ignoring the expected `ContextRefreshedEvent` once all components are ready in the current context.  We must ensure that `ResourceUrlProvider` only considers events sent by the current context - this is a common pattern in other parts of Spring Framework.","closed","type: bug,","bclozel","2021-02-17T20:59:03Z","2021-02-22T14:53:07Z"
"","26433","AbstractBeanDefinition#equals handles propertyValues incorrectly","See line 1198: ObjectUtils.nullSafeEquals(this.propertyValues, that.propertyValues) Look at AbstractBeanDefinition#getPropertyValues, line 891, which treats, in effect a propertyValues of null as equivalent to en empty MutablePropertyValues object (i.e., a side-effect of getPropertyValues is to create an empty MutablePropertyValues object when propertyValues is null). Affects version 5.3.3","closed","in: core,","AnthonyYeracaris","2021-01-22T20:14:09Z","2021-02-14T16:59:07Z"
"","26081","Mention security consideration in ForwardedHeaderFilter javadoc","See https://github.com/spring-projects/spring-framework/pull/23582#issuecomment-725911525  We should elaborate about security considerations about Forwarded headers and proxies in the filter's Javadoc, just like in [""Forwarded"" section in the reference documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-forwarded-headers).","closed","type: documentation,","bclozel","2020-11-12T16:27:19Z","2020-12-03T14:41:10Z"
"","26337","Remove obsolete commandName attribute in spring-form.tld","See https://github.com/spring-projects/spring-framework/issues/20586#issuecomment-753641212 for details.","closed","type: bug,","sbrannen","2021-01-03T16:24:29Z","2021-01-03T16:50:21Z"
"","26461","Allow AbstractEnvironment to bypass active/default properties","See https://github.com/spring-projects/spring-boot/issues/24890#issuecomment-763273976 for more background.  Currently `AbstractEnvironment` has `doGetActiveProfiles()` and `doGetDefaultProfiles()` methods that will call `getProperty()` if there aren't any set values. In Spring Boot we call `setActiveProfiles(..)` and `setDefaultProfiles(...)` directly and we don't want property based resolution (even if the values set are an empty array).  We'd like a way to disable property based resolution.","closed","type: enhancement,","philwebb","2021-01-27T23:02:15Z","2021-02-15T15:30:35Z"
"","26775","ResourceHttpRequestHandler fails to resolve encoded paths when PathPattern is used","See https://github.com/spring-projects/spring-boot/issues/24805 and #26445   When working with the classic ant path matcher `ResourceHttpRequestHandler` will resolve resources in folders that have encoded characters. When switching to `PathPattern`, this fails.  The reason appears to a difference with the value stored in `HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE`. With the ant matcher [this line](https://github.com/spring-projects/spring-framework/blob/c5ac8e8ab62cf7a616d5316bc6ef6d5d5e461c10/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceHttpRequestHandler.java#L575) returns a path that's decoded. With the `PathPattern` it returns to original encoded form.  The attached application will replicate the issue. Calling `curl http://localhost:8080/nested-reserved-%21%23%24%25%26%28%29%2A%2B%2C%3A%3D%3F%40%5B%5D-meta-inf-resource.txt` will work if `ant-path-matcher` is set in the `application.yml` but fail when it's `path-pattern-parser`.  [app.zip](https://github.com/spring-projects/spring-framework/files/6274826/app.zip)","closed","type: bug,","philwebb","2021-04-07T22:15:23Z","2021-04-12T18:54:45Z"
"","26114","Add ResponseSpec#toEntityFlux overload that accepts BodyExtractor","See #26099.  Adds an overload to the `ResponseSpec` interface to allow interpreting the response as a `ResponseEntity>` using a `BodyExtractor, ? super ClientHttpResponse>` to decode the body.","closed","type: enhancement,","HaloFour","2020-11-18T15:24:29Z","2020-11-19T21:17:47Z"
"","26769","Groovy Dynamic Language fails compilation when using Ivy Grab","Script such as:  ```groovy @Grab('org.apache.httpcomponents:fluent-hc:4.5.13') import org.apache.http.client.fluent.Request  class GrabExample   }  ```  ivy is on the classpath.   ``` Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'grabExample': Could not determine scripted object type for GroovyScriptFactory: script source locator [file:/scripts/GrabExample.groovy]; nested exception is org.springframework.scripting.ScriptCompilationException: Could not compile URL [file:/scripts/GrabExample.groovy]; nested exception is org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed: GrabExample: 8: unable to resolve class org.apache.http.client.fluent.Request  @ line 8, column 1.    import org.apache.http.client.fluent.Request    ^  1 error  	at org.springframework.scripting.support.ScriptFactoryPostProcessor.postProcessBeforeInstantiation(ScriptFactoryPostProcessor.java:330) ~[spring-context-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1141) ~[spring-beans-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory.java:1114) ~[spring-beans-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:506) ~[spring-beans-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	... 23 common frames omitted Caused by: org.springframework.scripting.ScriptCompilationException: Could not compile URL [file:/scripts/GrabExample.groovy]; nested exception is org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed: GrabExample: 8: unable to resolve class org.apache.http.client.fluent.Request  @ line 8, column 1.    import org.apache.http.client.fluent.Request    ^  1 error  	at org.springframework.scripting.groovy.GroovyScriptFactory.getScriptedObjectType(GroovyScriptFactory.java:297) ~[spring-context-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	at org.springframework.scripting.support.ScriptFactoryPostProcessor.postProcessBeforeInstantiation(ScriptFactoryPostProcessor.java:323) ~[spring-context-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	... 26 common frames omitted Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed: GrabExample: 8: unable to resolve class org.apache.http.client.fluent.Request  @ line 8, column 1.    import org.apache.http.client.fluent.Request    ^  1 error  	at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:295) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at org.codehaus.groovy.control.CompilationUnit$ISourceUnitOperation.doPhaseOperation(CompilationUnit.java:914) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:627) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:389) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at groovy.lang.GroovyClassLoader.lambda$parseClass$3(GroovyClassLoader.java:332) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at org.codehaus.groovy.runtime.memoize.StampedCommonCache.compute(StampedCommonCache.java:163) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at org.codehaus.groovy.runtime.memoize.StampedCommonCache.getAndPut(StampedCommonCache.java:154) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:330) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:314) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:257) ~[CamundaScriptingDelegatesProcessEnginePlugin.jar:na] 	at org.springframework.scripting.groovy.GroovyScriptFactory.getScriptedObjectType(GroovyScriptFactory.java:278) ~[spring-context-5.2.7.RELEASE.jar!/:5.2.7.RELEASE] 	... 27 common frames omitted  ```  Appears to be related to how the scripts are ""detected"":  https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/scripting/support/ScriptFactoryPostProcessor.java#L271  https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/scripting/groovy/GroovyScriptFactory.java#L270","open","in: core,","StephenOTT","2021-04-06T16:46:44Z","2021-11-11T09:27:00Z"
"","26651","Update reference to deprecated CronSequenceGenerator","Scheduled#cron() was pointing to CronSequenceGenerator for an explanation of the cron string format. This class however is deprecated, and has been replaced with CronExpression. This PR updates the JavaDoc accordingly.","closed","type: documentation,","MichelTenVoorde","2021-03-08T22:46:36Z","2021-03-09T07:18:04Z"
"","25890","BrokerAvailabilityEvent without any relay node information?","Scenario: I am connecting to a cluster of Stomp relays (without external LB), one of the Stomp nodes goes offline and I therefore receive the right `BrokerAvailabilityEvent`, but from this, I can't see how to grab the specific `TcpConnectionHandler` instance that triggered the event. I mean, it is hidden. Without that, how am I supposed to know which node exactly went offline? My intention was to leave this node out of the candidates pool for some time (5min or so) before consider putting him back to make him a candidate on the `tcpClient#remoteAddress()`.  The whole thing I think is misconceived, it seems to be taking the relay port just from the `StompBrokerRelayRegistration`, without considering it may be chosen dynamically by the `TcpClient layer` underneath.  Am I missing something?","closed","in: messaging,","rupebac","2020-10-09T16:26:19Z","2020-10-20T11:51:14Z"
"","26310","MockMvcBuilders add a class builder","same behavior as `standaloneSetup` but it would be nice to be able to do `MockMvcBuilders.standaloneSetup(MyController.class)`, maybe the signature of the existing method could be changed to `` or the like (I still get super/extends confused for generics), and `Class`. To be honest, off the top of my head I'm not actually certain what I'm suggesting would work for an overload. I'd be ok with a different method too. My general motivation is to have the builder, or whatever resolve the controller with DI, although maybe because it's a builder that's not possible. an alternative might be to add  to  `@SpringJunitWebConfig( controllerClasses={ MyController.class })` and then you could not use the builder at all?","closed","in: web,","xenoterracide","2020-12-22T22:01:25Z","2021-10-04T08:49:02Z"
"","25922","Generate release notes automatically","Right now we're generating the release notes manually and publishing them as GitHub releases. The release pipeline should take care of that automatically.","closed","type: task,","bclozel","2020-10-16T12:31:16Z","2020-10-16T12:53:05Z"
"","26120","Resttemplate throws NPE with spring-boot-starter-log4j2 within tests","Resttemplate throws a NPE with dependency spring-boot-starter-log4j2 within tests calling RestTemplate construtor.  Repository for reproduce:  https://github.com/mnhock/resttemplate-bug  Simple call the RestConfigurationTest.  If you remove spring-boot-starter-log4j2 dependency from the pom it works.  The problem is that the init of the Logger depends on the SpringProperties as well but is initialized before the localProperties is initialized.  ``` 	private static final Log logger = LogFactory.getLog(SpringProperties.class); 	private static final Properties localProperties = new Properties(); ```  I think the problem exists with other files changed in #25151 as well.  Thanks, Martin","closed","in: core,","mnhock","2020-11-19T15:12:14Z","2020-11-20T05:47:56Z"
"","26857","Fix parameter bug of handler that Kotlin DSL defines as a parameter for the filterFunction.","Resolve #26838  This PR fixes following bug.  https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-webmvc/src/main/kotlin/org/springframework/web/servlet/function/RouterFunctionDsl.kt#L650-L655  https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-webflux/src/main/kotlin/org/springframework/web/reactive/function/server/CoRouterFunctionDsl.kt#L531-L539  1. Function `filterFunction` takes `serverRequest` and function `handler` as parameters. (I just named them.) 2. Function `handler` also takes `serverRequest` as parameter. 3. These DSLs define `handler`. 4. Function `handler`s that these DSLs defined  are now using mistakenly `filterFunction`'s `serverRequest`, not their own `serverRequest` parameters, which makes their own parameters meaningless.  This bug only exists in Kotlin DSL.   You can see java codes have no problem as follows.  https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-webmvc/src/main/java/org/springframework/web/servlet/function/HandlerFilterFunction.java#L46  https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/HandlerFilterFunction.java#L48  In java you can override filter something like  ```java ServerRequest newRequest = someOperation(request) return next.handle(newRequest) ```  but in Kotlin DSL, even if you write  ```kotlin filter { serverRequest, handlerFunction ->     val newServerRequest = someOperation(serverRequest)     handlerFunction(newServerRequest) } ``` handlerFunction will use original serverRequest, not the newServerRequest","closed","","ShindongLee","2021-04-24T13:38:36Z","2021-05-10T08:26:37Z"
"","25926","Spring Data JPA pollutes parent context with multiple SharedEntityManagerCreator beans","Reproducible with the latest Spring Data (Neumann-SR4) and Spring Framework 5.2.9. Not reproducible with the latest Spring Data (Neumann-SR4) and Spring Framework 5.2.5. Looks like a regression that was introduced by fixing https://github.com/spring-projects/spring-framework/issues/24852  The reproducer: https://github.com/iherasymenko/spring-data-jpa-child-context-pollution-reproducer.  Run all tests by executing `gradlew test` — one test will fail. Run `gradlew test --tests com.example.Config2Test` and then `gradlew test --tests com.example.ConfigTest` — both tests will succeed.","closed","for: external-project,","iherasymenko","2020-10-16T19:13:08Z","2020-10-20T19:12:44Z"
"","25940","CGLIB: proxy classes for shared classes cannot be registered if ""--illegal-access=deny"" is specified","Reproducible on JDK 11, 15 (presumably 9+) and the latest Spring Framework (5.2.9).  I put together a simple reproducer, which mimics the Tomcat setup where this issue can be observed.  The deployment configuration is as follows.  ``` -- lib      - spring libraries      - shared lib -- webapp1      - Configuration1.class that references a class with @Transactional annotation from the shared lib -- webapp2      - Configuration2.class that references a class with @Transactional annotation from the shared lib ```  - If the JVM is run with `--illegal-access=deny` and BOTH apps are deployed, the second app fails with the error. - If the JVM is run with `--illegal-access=deny` and just ONE app is deployed, everything works fine. - If the JVM is run with `--illegal-access=warn` (or simply without this argument) and either one app or both apps are deployed, everything works fine. - If the JVM is run without specifying `--illegal-access`, but the libraries are placed on the **module path**, the second app fails with the error.  The reproducer is [here](https://github.com/iherasymenko/spring-illegal-access-deny-reproducer). Run `gradlew runWithIllegalAccessDeny`, `gradlew runWithIllegalAccessWarn`, and `gradlew runOnModulePath` accordingly.  The error: ``` java.lang.LinkageError-->loader 'app' attempted duplicate class definition for com.example.SimpleService$$EnhancerBySpringCGLIB$$df04dc18. (com.example.SimpleService$$EnhancerBySpringCGLIB$$df04dc18 is in unnamed module of loader 'app')  	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:558) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:585) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:57) 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205) 	... 17 more  ```","open","in: web,","iherasymenko","2020-10-20T01:35:15Z","2022-02-01T10:46:36Z"
"","26091","@DynamicPropertySource is not supported via @NestedTestConfiguration semantics","Reproduced with Spring Framework 5.3.1 (via Spring Boot 2.4.0).  As initially described [here](https://jira.spring.io/browse/DATACMNS-1829) and [here](https://github.com/spring-projects/spring-boot/issues/23929#issuecomment-726701029), nested tests do not work with `@DynamicPropertySource`.  You can reproduce the issue with this sample Spring Data JPA (2.4.1) repository: https://github.com/fbiville/spring-data-jpa-nested (see README for reproduction one-liners).  As suggested by @wilkinsona [here](https://github.com/spring-projects/spring-boot/issues/23929#issuecomment-726711390),  replacing the annotation with `ApplicationContextInitializer` works.","closed","type: enhancement,","fbiville","2020-11-13T11:38:07Z","2020-11-15T20:06:33Z"
"","26022","Simplify AbstractBeanFactory.registerCustomEditors()","Remove unnecessary non-null check","closed","in: core,","hzmpay","2020-11-03T09:37:18Z","2020-11-03T13:54:03Z"
"","26823","Remove reference to Commons Collections in ColumnMapRowMapper Javadoc","Remove the reference to Commons Collections.","closed","type: task,","mdeinum","2021-04-19T05:26:17Z","2021-04-20T18:14:10Z"
"","26833","MockMvc's MVC_RESULT_ATTRIBUTE lost with HandlerMappingIntrospector and RouterFunctions in use","Related to https://github.com/spring-projects/spring-security-samples/issues/9  A contributor shared the following sample application: https://github.com/hantsy/spring-webmvc-auth0-sample  The tests result in a `NullPointerException` because the `MockMvc.MVC_RESULT_ATTRIBUTE` is missing.  ```java HandlerExecutionChain chain = super.getHandler(request); if (chain != null) { 	DefaultMvcResult mvcResult = getMvcResult(request); // returns null 	mvcResult.setHandler(chain.getHandler()); 	mvcResult.setInterceptors(chain.getInterceptors()); } return chain; ```  It gets removed due to the following arrangement:  * Spring Security's `CorsFilter` by default uses `HandlerMappingIntrospector` * `HandlerMappingIntrospector` uses `RequestAttributeChangeIgnoringWrapper` which ignores all but `PATH_ATTRIBUTE` * `RequestPredicates#restoreAttributes` attempts to restore the attributes to a previous state by clearing the attribute set and then re-adding each attribute one by one  Before `CorsFilter` runs, `MVC_RESULT_ATTRIBUTE` is present in the request. When `RequestPredicates#restoreAttributes` is run, it removes all attributes. Then, when it tries to add the original set back in, `RequestAttributeChangeIgnoringWrapper` only adds `PATH_ATTRIBUTE` back in.  For the specific sample, the tests can be repaired by removing the `CorsFilter` or by exposing a custom `CorsConfigurationSource` bean since either of those will prevent `RequestAttributeChangeIgnoringWrapper` from wrapping the request.  I was also able to fix the tests by adding the following to `RequestAttributeChangeIgnoringWrapper`:  ```java @Override public void removeAttribute(String name) { 	if (name.equals(ServletRequestPathUtils.PATH_ATTRIBUTE) || name.equals(UrlPathHelper.PATH_ATTRIBUTE)) { 		super.removeAttribute(name); 	} } ```  At least in this isolated case, it seems reasonable that if an attribute cannot be set, it also should not be able to be removed.","closed","type: bug,","jzheaux","2021-04-20T20:38:28Z","2021-04-26T16:18:07Z"
"","26148","Support declarative ContextCustomizer registration in the TestContext framework","Referring to issue #26141, #26142 and most specifically #26143, these are all stemming from attempts by me to create a type of `@EnableAcmeLibraryTest` annotation (with optional parameters) that you could slap on a test, and then have both the Spring context and the test instance processed to have the necessary test infrastructure given straight into your hands.  From #26143, @sbrannen pointed me in the direction of `ContextCustomizerFactory` with its `ContextCustomizer`. This actually seems to fully cover the needs of the first requirement, i.e. tailoring the Spring context _before_ it is refreshed _(the other need, tailoring the test instance, would have been covered by `TestExecutionListeners`, had it not been for #26141)_. **However**, the mechanism is a SPI-style tool, whereby you need to register such factories in a META-INF/spring.factories file on the classpath.  IMO, this is too opaque and ""too magic"" for my liking. With this I mean that you cannot anymore trust that the code in front of you actually fully represent what will happen - there are also code being ""wedged in"" from unrelated, seemingly ""magic"" places.  This SPI-style also makes it harder to use this functionality as a project-specific tool, i.e. ""just for these 87 tests in this specific project"", due to this being a different and unfamiliar style of coding outside of ""pure Java + Spring"", introducing opaque aspect-style cross-cutting concerns where some elements are introduced without explicit reference, from a rather different part of the project file tree.  By letting a `ContextCustomizer` be introduced declaratively by an annotation (possibly specifying the `ContextCustomizerFactory` to instantiate?), you would immediately fix this: As a user of the AcmeLibrary, to get the functionality you desire, you will have to explicitly annotate the test class with a AcmeLibrary-specific annotation making the use obvious, and by only following the code, you could fully understand what happens. Also, for project-specific usages, it would just be clean Java+Spring, no SPI-style META-INF cruft to handle.  It would obviously be a massive positive if it was possible to employ this functionality as a meta-annotation in such a way that the resulting `@EnableAcmeLibraryTest` could take annotation parameters which could be employed by the `ContextCustomizer[Factory]` to programmatically tailor how the Spring context should be customized. _(It should also be implemented in such a way that nothing prevents the `@EnableAcmeLibraryTest` to also employ a `@TestExecutionListener` to also tailor the test class instance.)_","open","type: enhancement,","stolsvik","2020-11-24T19:08:04Z","2022-06-07T12:13:43Z"
"","26867","Support Kotlin suspending functions in SpEL expressions","Referencing parameter names in SpEL expressions fails when using Kotlin suspending functions.  For example ```java @Cacheable(cacheNames = [""cache""], condition = ""#key.startsWith('hello')"") open suspend fun getConditionalCache(key: String): Any {     // … ```  Fails with: ``` EL1004E: Method call: Method startsWith(java.lang.String) cannot be found on type java.lang.Object[] org.springframework.expression.spel.SpelEvaluationException: EL1004E: Method call: Method startsWith(java.lang.String) cannot be found on type java.lang.Object[] 	at org.springframework.expression.spel.ast.MethodReference.findAccessorForMethod(MethodReference.java:226) 	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:135) 	at org.springframework.expression.spel.ast.MethodReference.access$000(MethodReference.java:55) 	at org.springframework.expression.spel.ast.MethodReference$MethodValueRef.getValue(MethodReference.java:387) 	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:117) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:308) 	at org.springframework.cache.interceptor.CacheOperationExpressionEvaluator.condition(CacheOperationExpressionEvaluator.java:108) 	at org.springframework.cache.interceptor.CacheAspectSupport$CacheOperationContext.isConditionPassing(CacheAspectSupport.java:763) 	at org.springframework.cache.interceptor.CacheAspectSupport.isConditionPassing(CacheAspectSupport.java:583) 	at org.springframework.cache.interceptor.CacheAspectSupport.findCachedItem(CacheAspectSupport.java:534) 	at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:402) 	at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:345) 	at org.springframework.cache.interceptor.CacheInterceptor.invoke(CacheInterceptor.java:64) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) ```  The type `java.lang.Object[]` comes from the suspending function, `getConditionalCache`, having an additional `Continuation` parameter that is implicitly passed to it when it is invoked.","open","in: kotlin,","eleftherias","2021-04-27T11:19:55Z","2022-01-19T10:48:48Z"
"","26319","Reduce redundant cycles in PostProcessorRegistrationDelegate","reduce redundant cycles in `org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List)`   ```java // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, 		// Ordered, and the rest. 		List priorityOrderedPostProcessors = new ArrayList<>(); 		List orderedPostProcessorNames = new ArrayList<>(); 		List nonOrderedPostProcessorNames = new ArrayList<>(); 		for (String ppName : postProcessorNames) { 			if (processedBeans.contains(ppName)) { 				// skip - already processed in first phase above 			} 			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); 			} 			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { 				orderedPostProcessorNames.add(ppName); 			} 			else { 				nonOrderedPostProcessorNames.add(ppName); 			} 		}  		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. 		sortPostProcessors(priorityOrderedPostProcessors, beanFactory); 		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);  		// Next, invoke the BeanFactoryPostProcessors that implement Ordered. 		List orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size()); 		for (String postProcessorName : orderedPostProcessorNames) { 			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); 		} 		sortPostProcessors(orderedPostProcessors, beanFactory); 		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);  		// Finally, invoke all other BeanFactoryPostProcessors. 		List nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size()); 		for (String postProcessorName : nonOrderedPostProcessorNames) { 			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); 		} 		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); ```  - I think the latter two cycles can be done ahead of time to avoid multiple cycles .    - `orderedPostProcessorNames`   - `nonOrderedPostProcessorNames`","closed","in: core,","huifer","2020-12-24T08:34:40Z","2020-12-30T14:45:32Z"
"","26203","Fix comments to match behaviour in Tokenizer#lexNumericLiteral","Real numbers must have leading digits. And SIGN should occur 0 or 1 time at EXPONENT_PART.","closed","","limo520","2020-12-03T07:54:17Z","2022-02-18T19:05:33Z"
"","25897","Close Body after reading","readWithMessageConverters opens a FileInputStream but does not ensure it closes after reading from it. Ensure the FileInputStream is closed.  Solves Issue: https://github.com/spring-projects/spring-framework/issues/25896","closed","status: superseded,","SenseiFisher","2020-10-12T11:18:56Z","2022-01-11T11:55:35Z"
"","26311","Improve MockMvc samples in reference to show where static imports come from","Reading https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#spring-mvc-test-server-performing-requests it is not obvious where `post(...)` and the like methods start from.  With the apache http-client on my classpath my IDE wants to suggest that they come from that `RequestBuilder`. I did ultimately find an example with the location on the javadoc, of course the [MockMvc javadoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html), which is not where I'd have looked for this.","closed","type: documentation,","xenoterracide","2020-12-22T22:24:48Z","2021-01-06T21:56:37Z"
"","26077","Avoid full singleton lock for getSingleton(beanName, singletonFactory)","Quick check for existing instance without full singleton lock.","closed","type: enhancement,","hzmpay","2020-11-12T06:50:16Z","2020-11-12T14:57:05Z"
"","26075","Avoid full singleton lock for getSingleton(beanName, singletonFactory)","Quick check for existing instance without full singleton lock","closed","","hzmpay","2020-11-12T03:05:22Z","2020-11-12T03:13:30Z"
"","26762","Added synchronization control on shared resources","Problem: The use of shared resources, like the system properties, may result in flaky test outcomes in the case of more than one execution thread or parallel execution.  Solution: The synchronization control allows the test planner to organize executions, assuring that a test that writes to a shared resource will be executed isolated.","open","in: core,","gvma","2021-04-05T14:23:39Z","2021-11-12T14:17:41Z"
"","26283","Functional Endpoints, unexpected path pattern matching with pathVariable","Problem : I have 2 functional endpoints  ```java @Bean public RouterFunction getById() {     return RouterFunctions.route(             GET(""/threads/{threadId}""),             request -> ServerResponse.ok().bodyValue(""/threads/{threadId}"")     ); } ```  ```java @Bean public RouterFunction getSomeEntity() {     return RouterFunctions.route(             GET(""/threads/some""),             request -> ServerResponse.ok().bodyValue(""/threads/some"")); } ```             When i make request with `GET /threads/some`    **Expected behavior** : handler from `getSomeEntity` router function bean will be invoked, response (/threads/some)    **Actual behavior** : handler from `getById` router function bean will be invoked,  response (/threads/{threadId})        so it is impossible to invoke handler function from `getSomeEntity()` bean, because always invokes `getById`.        also tried to unite this 2 functions into one `RouterFunction` bean, problem also reproduces        **NOTE**    if try to model same situation with `@RestController` and `@GetMapping`    pattern matching works as expected        spring boot version: 2.3.5 Release        from dependencies only   ```xml          org.springframework.boot         spring-boot-starter-webflux    ```","closed","in: web,","tka4ukalex","2020-12-15T21:26:53Z","2021-01-14T15:20:03Z"
"","26612","Throw Exception when two primary beans are present in one factory","Prior to this commit, the implementation of `DefaultListableBeanFactory.determinePrimaryCandidate()` did not throws `NoUniqueBeanDefinitionException` in the flowing two situations: * more than one primary bean in one ancestor factory.(test unit in `DefaultListableBeanFactoryTests.autowireBeanByTypeWithTwoPrimaryCandidatesInOneAncestor()`) * more than one local primary bean which implements `FactoryBean`.(test unit in `DefaultListableBeanFactoryTests.autowireBeanByTypeWithTwoPrimaryFactoryBeans()`)  This commit fix these issues by prefer primary bean in the youngest factory, and if the youngest factory has more than one primary bean thorws `NoUniqueBeanDefinitionException`.","open","in: core,","nullzl","2021-02-26T08:36:46Z","2021-04-27T05:06:15Z"
"","26107","Re-use the isVariableName method","Prior to this change the checks for isVariableName were duplicated in 2 different locations. The logic has been moved to a utility class to allow for re-use in those places and so that it benefits from any optimizations that are done.","closed","in: core,","mdeinum","2020-11-17T14:05:18Z","2020-11-17T14:58:55Z"
"","26732","Fix typo in web docs example","Polish webmvc/webflux docs example Did not work due to unnecessary space","closed","type: task,","HwangNara","2021-03-26T02:48:01Z","2021-03-29T15:38:45Z"
"","26578","Update ref docs regarding deprecated @Required annotation","Please select one of the following: - add Note to RequiredAnnotationBeanPostProcessor - since Required annotation is deprecated, use AutowiredAnnotationBeanPostProcessor to illustrate the example","closed","in: core,","alex-krav","2021-02-20T16:29:09Z","2021-02-23T15:22:28Z"
"","26810","Reduce log level in ExecutorConfigurationSupport.initialize","Please could the level of the logging within ExecutorConfigurationSupport.initialize be reduced to DEBUG?  Currently, this line is always logged at startup but I feel it doesn't convey very useful information and adds noise to the logs by default.  It is also hard to suppress when building on top of this in libraries. My end users often don't know (or care) what this means but I don't want to enforce logging configuration, or a logging implementation on them to hide it.  Happy to raise a PR if this change is agreed!","closed","type: enhancement,","rupert-madden-abbott","2021-04-15T09:47:53Z","2021-05-11T13:50:41Z"
"","26699","Only one connection receive subscriber allowed","originally opened https://github.com/spring-cloud/spring-cloud-sleuth/issues/1854 however it can reproduced without Spring Cloud Sleuth. Below you can find the original description by @violetagg   **Describe the bug** The exception below is observed when using `spring-cloud-sleuth`  ``` 2021-02-22 15:12:25.427 ERROR [,77249f740f448dff,77249f740f448dff] 18936 --- [ctor-http-nio-2] reactor.core.publisher.Operators         : Operator called default onErrorDropped  java.lang.IllegalStateException: Only one connection receive subscriber allowed. 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:180) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:144) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4046) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:392) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onError(FluxMapFuseable.java:140) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onError(FluxMapFuseable.java:140) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onError(FluxFilterFuseable.java:162) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.MonoCollect$CollectSubscriber.onError(MonoCollect.java:144) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onError(FluxMap.java:132) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.Operators.error(Operators.java:196) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:164) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onSubscribe(ScopePassingSpanSubscriber.java:67) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:168) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:144) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:387) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.web.client.TraceExchangeFilterFunction$TraceWebClientSubscriber.onNext(TraceWebClientBeanPostProcessor.java:220) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at org.springframework.cloud.sleuth.instrument.web.client.TraceExchangeFilterFunction$TraceWebClientSubscriber.onNext(TraceWebClientBeanPostProcessor.java:183) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onNext(MonoFlatMapMany.java:250) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2359) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.request(ScopePassingSpanSubscriber.java:74) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onSubscribeInner(MonoFlatMapMany.java:150) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onSubscribe(MonoFlatMapMany.java:245) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onSubscribe(ScopePassingSpanSubscriber.java:67) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] ```  the double subscription happens with `onError`:  ``` 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:180) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:144) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4046) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:392) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onError(ScopePassingSpanSubscriber.java:95) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] ```  and `onNext`  ``` 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:168) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:144) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:88) ~[spring-cloud-sleuth-instrumentation-3.0.1.jar:3.0.1] ```  The issue `Only one connection receive subscriber allowed.` is reported as part of the memory leak issue https://github.com/reactor/reactor-netty/issues/1513. However this exception is not related to the memory leak issue.  **Sample** In the example https://github.com/shj95/webflux-leak-test that is provided with https://github.com/reactor/reactor-netty/issues/1513, add a dependency `implementation 'org.springframework.cloud:spring-cloud-starter-sleuth:3.0.1'`, then use the provided `jmeter` script to reproduce it.","open","type: enhancement,","marcingrzejszczak","2021-03-18T11:40:49Z","2022-06-20T18:01:41Z"
"","26187","validation does not work correctly","org.springframework.boot:spring-boot-starter-validation:2.3.3.RELEASE org.springframework.boot:spring-boot-starter-web:2.3.3.RELEASE org.hibernate.validator:hibernate-validator:6.1.5.Final javax.validation:validation-api:2.0.1.Final  ## Description  When I try to validate a number on a requestbody and the client sends null, it is casted automatically and I receive a pojo with value 0 instead of returning an error.  ## Problems that arise  It's not possible to validate that an actual number is sent. It's not possible to distinguish between null and 0.  ## Example Controller/Dto: ``` import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import javax.validation.Valid; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull;  @RestController() @RequestMapping(""test"") public class JavaController {      @PostMapping(path = ""validation"")     public String test(@Valid @RequestBody OrderDto order) {         return ""Java Test works!"";     }  }  class OrderDto {     @NotNull long rewardId; } ```  JSON request: ``` { ""rewardId"": null } ```  What happens: null is automatically converted into 0 and validation doesn't throw an exception. Therefore the validation is not working in this case.  ## My interpretation what happens Validation occurs after the request was converted into the target structure (OrderDto). Because rewardId is not Optional it assigns 0 as value. Validation only runs after convertion and therefore can't properly validate the content.  ## Workarounds and why I don't like them One could use either: ``` class OrderDto1 {     @NotNull Long rewardId; // Mind the big L, object can be null } class OrderDto2 {     @Min(1) long rewardId; // Only if id can't be smaller 1 in every case } ``` Dto1: Now I have to deal with null values after validation even so validation makes sure it can't be null. The type should provide information for later use and not help with the earlier validation. This is especially annoying in Kotlin where you have a lot of Type safety and it helps a lot if the dto is already providing non null values. (in Kotlin Long instead of Long?) Dto2: 0 could be a valid input and we still want the type not to be nullable.   Can anyone provide me with an update regarding this issue?   Other sources I read regarding this issue: [Stackoverflow how to handle invalid number in javax validation](https://stackoverflow.com/questions/59643749/how-to-handle-invalid-number-in-javax-validation-for-spring-boot-rest-and-jackso#comment115070767_59643749)","open","in: web,","judos","2020-12-01T12:25:41Z","2021-11-08T11:46:10Z"
"","26575","Fix handling of ""file:"" paths to non-existent files on Windows","On Windows, for `setAsText`, if the text argument is a `file:` URL for a path that does not exist, `Paths.get(text)` is called where text is a `file:` URL, which doesn't work - the result is an `InvalidPathException`. The Windows part is important - this issue only manifests when running on Windows.  To fix this issue, also check that the resource isn't a file before calling `Paths.get()`. That way, resources that are files skip to the other branch.","closed","in: core,","candrews","2021-02-20T06:06:03Z","2021-02-25T16:55:55Z"
"","25920","Add support for SSE to WebMvc.fn","On Spring MVC with annotations, `ResponseBodyEmitter` return types (and its specialized variant `SseEmitter`) are used to emit streaming values. Currently WebMvc.fn has support for asynchronous single value but not for SSE. I am wondering if `ServerResponse.async(Object asyncResponse)` should be improved to support such use case.  Worth to notice, the emitter instance is designed to be passed to another component, see `ResponseBodyEmitter` Javadoc for more details.","closed","type: enhancement,","sdeleuze","2020-10-16T07:09:30Z","2020-12-02T14:19:36Z"
"","26836","Fix Kotlin code formatting for Inline Maps section of ref docs","Official documentation contains incorrect Kotlin code example (page 292 of pdf). There are `Map<*, >` instead of `Map<*, *>` and `Map<, *>` instead of `Map<*, *>`. The cause of this issue is incorrect formatting.","closed","type: task,","hrybs","2021-04-21T07:29:36Z","2021-04-21T09:15:16Z"
"","26108","Support allowedOriginPatterns in SockJS config","Now you can also add allowed origin patterns to the websocket CORS config.","closed","type: regression,","BenjaminFaal","2020-11-17T18:01:21Z","2020-11-18T21:21:44Z"
"","26654","Publish directly to Maven Central","Now that Bintray is being retired, we should publish our artifacts directly to Maven Central.","closed","type: task,","bclozel","2021-03-09T13:27:05Z","2021-03-09T14:34:29Z"
"","26111","Not possible to use allowedOrigins ""*"" in StompEndpointRegistry after upgrade to Spring Boot 2.4.0","Not sure if this should be filed under Spring Boot or Spring framework, but I put it here since Spring Boot Starter is in use.  After upgrading to use Spring Boot 2.4.0 from 2.3.x, it does not seem to be possible to use allowedOrigins = ""*"" in the StompEndpointRegistry. When connecting it results in the following Error:  ``` java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value ""*""since that cannot be set on the ""Access-Control-Allow-Origin"" response header. To allow credentials to a set of origins, list them explicitly or consider using ""allowedOriginPatterns"" instead. ``` However, allowedOriginPatterns i not something that is available on the StompEndpointRegistry, only allowedOrigins is available.     Code to reproduce     ```java package com.example.demo;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker; import org.springframework.web.socket.config.annotation.StompEndpointRegistry; import org.springframework.web.socket.config.annotation.StompWebSocketEndpointRegistration; import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;  @SpringBootApplication @EnableWebSocketMessageBroker public class DemoApplication implements WebSocketMessageBrokerConfigurer {  	public static void main(String[] args) { 		SpringApplication.run(DemoApplication.class, args); 	}  	@Override 	public void registerStompEndpoints(StompEndpointRegistry registry) { 		StompWebSocketEndpointRegistration registration = registry.addEndpoint(""/endpoint""); 		registration.setAllowedOrigins(""*""); 		registration.withSockJS(); 	} } ```  ```html             Title          ```  ```xml   	4.0.0 	 		org.springframework.boot 		spring-boot-starter-parent 		2.4.0 		  	 	com.example 	demo 	0.0.1-SNAPSHOT 	demo 	Demo project for Spring Boot  	 		11 	  	 		 			org.springframework.boot 			spring-boot-starter-websocket 		 	  	 		 			 				org.springframework.boot 				spring-boot-maven-plugin 			 		 	    ```    Start the server on port 8080 and host the host the html file on another port and open it in a browser.","closed","status: superseded,","opersson","2020-11-18T13:18:01Z","2021-02-23T12:44:53Z"
"","26570","Spring-test:5.3.4 - MockHttpServletRequest depends on javax.servlet-api:4.+","Not requesting a change more a concern regarding this patch release.  Following commit https://github.com/spring-projects/spring-framework/commit/f22e2ac578f6db8f988cbbee0af5f381a86fdd04 Changed MockHttpServletRequest to utilize HttpServletMapping internally.  HttpServletMapping is an interface provided by the latest servlet-api - javax.servlet-api:4.+  Our projects auto import patch releases, thus with the 5.3.4 release any project utilizing the MockHttpServletRequest resolved in a failed master build as the dependency to the latest servlet-api is not something we've imported as an explicit dependency.  Find it strange that this would be released as a patch version and not part of a minor.","closed","status: duplicate,","KevinMcT","2021-02-19T08:22:47Z","2021-04-27T11:38:18Z"
"","26485","Expose ChannelId in ReactorNettyWebsocketSession","Not a bug but proposal This ID is much more unique than WebSocketSession's own, is already part of public APIs available to Netty handlers and could be used, for example, to correlate log events happening at different levels in a Webflux app without resorting to reflective access","closed","type: enhancement,","bruto1","2021-02-01T09:29:58Z","2021-02-13T11:16:05Z"
"","26641","fix lazy inject of prototype","No need to invoke `doResolveDependency()` repeatedly since target is already created.","closed","status: invalid,","ShaoqiangLu","2021-03-04T17:42:20Z","2021-04-27T11:22:13Z"
"","26783","Update ref docs regarding RequiredAnnotationBeanPostProcessor registration","No *RequiredAnnotationBeanPostProcessor* is automatically registered. According to source code of *AnnotationConfigBeanDefinitionParser* class we see that there is a using of *AnnotationConfigUtils* class. Investigating the code of letter one we see that there is registration of 5 BeanPostProcessor and BeanFactoryPostProcessor classes.","closed","type: documentation,","hrybs","2021-04-09T14:45:20Z","2021-04-09T15:00:27Z"
"","26151","AbstractServerHttpRequest constructor breaks binary compatibility between 5.2.x and 5.3.x","Motivation:  The `AbstractServerHttpRequest` constructor signature has been changed by https://github.com/spring-projects/spring-framework/commit/3276f818519f9bde187c4ccb83653c21c2e0e7fb#diff-80d003153fc35acd9545fb81c726d9aa41dffc39c507c590e03e07a2450ed1bf. This change causes `NoSuchMethodError` when a Spring 5.3 run with a compiled class that extends 5.2.x version `AbstractServerHttpRequest`. ```java java.lang.NoSuchMethodError: org/springframework/http/server/reactive/AbstractServerHttpRequest.(Ljava/net/URI;Ljava/lang/String;Lorg/springframework/http/HttpHeaders;)V (loaded from file:/Users/wickedev/.gradle/caches/modules-2/files-2.1/org.springframework/spring-web/5.3.0-RC2/ce128df6b5debc37d8019a17773f8a31af7ffba8/spring-web-5.3.0-RC2.jar by jdk.internal.loader.ClassLoaders$AppClassLoader@62918e21) called from class com.linecorp.armeria.spring.web.reactive.ArmeriaServerHttpRequest (loaded from file:/Users/wickedev/.gradle/caches/modules-2/files-2.1/com.linecorp.armeria/armeria-spring-boot2-webflux-autoconfigure/1.0.0/a5b511b31f065caba67d35b7d081735e81277898/armeria-spring-boot2-webflux-autoconfigure-1.0.0.jar by jdk.internal.loader.ClassLoaders$AppClassLoader@62918e21). 	at com.linecorp.armeria.spring.web.reactive.ArmeriaServerHttpRequest.(ArmeriaServerHttpRequest.java:60) 	at com.linecorp.armeria.spring.web.reactive.ArmeriaHttpHandlerAdapter.handle(ArmeriaHttpHandlerAdapter.java:54) 	at com.linecorp.armeria.spring.web.reactive.ArmeriaReactiveWebServerFactory.lambda$configureService$5(ArmeriaReactiveWebServerFactory.java:243) 	at com.linecorp.armeria.spring.web.reactive.ArmeriaReactiveWebServerFactory$$Lambda$472/0000000000000000.serve(Unknown Source) ```  Suggestion:  Revive the removed constructor with a deprecation annotation. ```java public abstract class AbstractServerHttpRequest implements ServerHttpRequest {   	public AbstractServerHttpRequest(URI uri, @Nullable String contextPath, MultiValueMap headers) {         ...     }      @Deprecated 	public AbstractServerHttpRequest(URI uri, @Nullable String contextPath, HttpHeaders headers) {         this.uri = uri;         path = RequestPath.parse(uri, contextPath);         // Need to call `readOnlyHttpHeaders` with `HttpHeaders`         // HttpHeaders.readOnlyHttpHeaders(MultiValueMap) is added in 5.3.x         this.headers = HttpHeaders.readOnlyHttpHeaders(headers); 	} } ```  Related: https://github.com/line/armeria/issues/3131","closed","type: regression,","ikhoon","2020-11-25T03:56:50Z","2020-11-25T10:41:45Z"
"","26593","WebSocketHandlerRegistration is missing option for allowedOriginPatterns","Most other places in the WebSocket config were updated in #26108 except for this one. This was pointed out in https://github.com/spring-projects/spring-framework/issues/26111#issuecomment-784006237.","closed","type: enhancement,","rstoyanchev","2021-02-23T12:44:28Z","2021-03-16T12:17:47Z"
"","26324","Mocking MockMultipartFile no longer working in 5.3.2","Mocking a `MockMultipartFile` does not work in multipart request in spring-test 5.3.2 **Affects:** spring-test 5.3.2  See sample project [here](https://github.com/austinarbor/spring-framework-exception-handler-issue)  If you check out the test, you can see I am spying a `MockMultipartFile` to force it to throw an `IOException` on `getInputstream()` [here](https://github.com/austinarbor/spring-framework-exception-handler-issue/blob/main/src/test/java/dev/aga/controller/UploadControllerTest.java#L32)  This works fine in spring-test 5.3.1 but does not work in 5.3.2. I confirmed this by excluding spring-test from spring-boot-starter-test and directly importing spring-test 5.3.1, which resolves the issue.  Throwing a breakpoint in the controller method you can see that the `MockMultipartFile` is not a mock when on 5.3.2  Possibly caused by https://github.com/spring-projects/spring-framework/commit/d82cb15439c1c9d4100daabb275e0eb102a877bc as fix for https://github.com/spring-projects/spring-framework/issues/26166","closed","status: duplicate,","austinarbor","2020-12-29T06:54:39Z","2021-01-08T07:14:44Z"
"","26273","Refactor PostProcessorRegistrationDelegate","matchingBeans After getting the instance through the method, can we remove the filtering behavior of getting instance according to beanname","closed","in: core,","huifer","2020-12-15T09:53:27Z","2020-12-25T06:29:33Z"
"","26646","Fix bug in BeanUtils.copyProperties()","line 788  ```java if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) { 	readMethod.setAccessible(true); } Object value = readMethod.invoke(source); if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) { 	writeMethod.setAccessible(true); } ```  may be  ```java if (!Modifier.isPublic(readMethod.getModifiers())) { 	readMethod.setAccessible(true); } Object value = readMethod.invoke(source); if (!Modifier.isPublic(writeMethod.getModifiers())) { 	writeMethod.setAccessible(true); } ```","closed","in: core,","kafka009","2021-03-06T16:31:21Z","2021-03-24T11:28:03Z"
"","26309","Constructor injection in JUnit Jupiter test classes without @Autowired","Juni5 5 supports constructor injection, it would be nice if springs test harness supported it, so you could write spring tests in the same way you write other classes in both junit and spring core. note: I searched this repo and google and didn't find anything.","closed","status: duplicate,","xenoterracide","2020-12-22T21:51:31Z","2020-12-23T19:40:45Z"
"","26123","Jetty 10 Support","Jetty 10 includes major changes of its WebSocket API as well as other changes to fairly prominent API types (e.g. access to headers via `HttpFields`). For 5.3.x we need to support 9.4.x and 10.x side by side.","closed","type: enhancement,","rstoyanchev","2020-11-19T18:13:22Z","2021-01-21T20:22:45Z"
"","26604","Hundreds of reactor-http-nio-XXX threads being created when WebClient requests are made in parallel without pre-warming.","Ive discovered some strange behaviour where it appears WebClient + reactor-netty is creating up to hundreds of reactor-http-nio threads when we make parallel calls using WebClient, without performing any initial warmup. I've managed to reproduce this relatively easily with the following code where I submit tasks to an Executor service that uses the WebClient instance to call a remote service in parallel.  ```java import org.junit.jupiter.api.Test; import org.springframework.http.client.reactive.ReactorClientHttpConnector; import org.springframework.web.reactive.function.client.WebClient; import reactor.netty.http.client.HttpClient;  import java.util.concurrent.ExecutorCompletionService; import java.util.concurrent.Executors;  public class ParallelTest {      @Test     public void testBreakIt3() throws Exception {         final WebClient webClient = WebClient.builder()                 .baseUrl("""") // swap me                 .build();          final ExecutorCompletionService service = new ExecutorCompletionService(Executors.newFixedThreadPool(5));          final int iterations = 300;         for (int i = 0; i < iterations; i++) {             service.submit(() -> {                 webClient.get()                         .uri("""").   // swap me                         .exchange()                         .block();                 return null;             });         }          int success = 0;         int errors = 0;          for (int i = 0; i < iterations; i++) {             try {                 service.take().get();                 ++success;             } catch (Exception ex) {                 ++errors;             }         }          System.out.println(""Errors: "" + errors);         System.out.println(""Success:"" + success);     } } ```  When DEBUG logging is enabled, we see many high range numbered reactor netty threads, e.g  reactor-http-nio-45 reactor-http-nio-18  Attaching a profiler (Ive used Java Flight Recorder along with Intellij to inspect Java events), we notice many reactor-http-nio threads being started, well beyond the number we would expect based on our CPU.  If I change the above code to make a WebClient call before we enter the loop that makes many parallel calls, then we end up with a correct number of reactor threads (in this case, reactor-http-nio-1 through to reactor-http-nio-12).  If we use `warmup()` method, the problem goes away.  ```java         HttpClient httpClient = HttpClient.create();         httpClient.warmup().block();          final WebClient webClient = WebClient.builder()                 .baseUrl("""")                 .clientConnector(new ReactorClientHttpConnector(httpClient))                 .build(); ```  Tested using: - spring-webflux 5.3.4 - reactor-netty 1.0.3","closed","in: web,","gordz","2021-02-24T22:01:35Z","2021-03-29T12:13:04Z"
"","26674","Add HTTP request cookies to the WebSocket handshake info","It's quite difficult to access handshake cookies for now - we have to provide custom wrappers for handshake service and propagate them via `attributes` field.  P.S. maybe it also makes sense to provide the possibility of passing cookies via the websocket client explicitly. For now, the only possible way is to add them via HttpHeaders.","closed","type: enhancement,","sokomishalov","2021-03-14T08:54:17Z","2021-03-15T18:08:24Z"
"","25966","Validate that JUnit Jupiter test methods and lifecycle methods are not annotated with @Autowired","It would be nice to consider adding validation of `@Autowired` on tests. For example, a user may be trying to use parameter injection of their beans and accidentally place `@Autowired` on the method rather than on the parameters. For example the following:  ```java @Test @Autowired @WithMockUser void go(MessageService messageService) { 	assertThat(messageService).isNotNull(); 	assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull(); } ```  will be invoked when the test is autowired. It would fail because Spring Security's `TestExecutionListener` is not invoked until the time of test rather than injection. The failure looks something like this:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'example.demo.WithMockUserAutowiredMethodTest': Injection of autowired dependencies failed; nested exception is java.lang.AssertionError:  Expecting actual not to be null 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:405) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1420) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireBeanProperties(AbstractAutowireCapableBeanFactory.java:392) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:119) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) 	at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:98) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$5(ClassBasedTestDescriptor.java:341) 	... Caused by: java.lang.AssertionError:  Expecting actual not to be null 	at example.demo.WithMockUserAutowiredMethodTest.withMockUserWhenAutowiredMethodThenSecurityContextSetup(WithMockUserAutowiredMethodTest.java:23) ```  I think it would be nice to add validation around what methods are `@Autowired` to ensure they are not on methods that are also annotated with JUnit Jupiter methods to give users a more clear explanation as to what is wrong.  Related Discussion: https://github.com/spring-projects/spring-framework/issues/18629#issuecomment-453437519","closed","type: enhancement,","rwinch","2020-10-23T18:06:34Z","2020-11-10T14:31:06Z"
"","25963","Allow cache eviction for ConcurrentLruCache","It would be cool if the newly introduced `ConcurrentLruCache` allowed to wipe individual elements from the cache manually and maybe even reset it entirely.","closed","type: enhancement,","odrotbohm","2020-10-23T11:15:03Z","2020-10-24T21:49:20Z"
"","26451","Cookie handling with reactor netty does not conform to RFC 6265 when sending multiple cookies","It was already indicated in #24819.  It can be either handled as separate test (as suggested in issue) or it is possible to add multiple cookies to existing retrieve test.  #24819 was declined with reasoning that ``` assertThat(request.getHeaders().toMultimap().get(HttpHeaders.COOKIE)) 		.isEqualTo(Arrays.asList(""testkey=testvalue"", ""testkey2=testvalue2"")); ``` returns all cookies.  But in https://tools.ietf.org/html/rfc6265#section-5.4 RFC clearly states that  When the user agent generates an HTTP request, the user agent MUST NOT attach more than one Cookie header field.  WebClient using reactor netty attaches each cookie as separate cookie header which obviously not complies with RFC even though it passes the test if all cookie headers are joined","open","in: web,","MichalStehlikCz","2021-01-27T07:11:12Z","2022-04-12T15:56:25Z"
"","26266","Memory leak with CglibAopProxy$ProxyCallbackFilter","It seems that there is a memory leak with Spring Boot 2.4.1 on my Debian 10.5 with Java 11.0.1 when using `@PreAuthorize(""hasRole('ROLE')"")` annotation on controller's endpoint. As you can see in the first image, there is constant grow in old generation memory of G1 garbage collector when running tests. The grow stops at max heap size which is 512 MB. I prepared a [sample project](https://github.com/Pancor/leak) where you can reproduce the problem.      Memory usage 1    ![image](https://user-images.githubusercontent.com/24636767/102074708-75f9dd00-3e05-11eb-97ec-927ef3d27a80.png)        Memory usage 2    ![image](https://user-images.githubusercontent.com/24636767/102074755-88741680-3e05-11eb-81e6-8d0620f987d1.png)      After importing the project just run this command:  `./gradlew clean test`  Tests will fail because they assume that HTTP response will be 200, but it is 401, but it shouldn't matter. If you remove `@PreAuthorize` from [DummyController](https://github.com/Pancor/leak/blob/master/src/main/java/pl/pancordev/leak/controllers/DummyController.java) or `prePostEnabled = true` from [SecurityConfig](https://github.com/Pancor/leak/blob/master/src/main/java/pl/pancordev/leak/SecurityConfig.java) then memory usage seems to be ok.    Memory usage 3    ![image](https://user-images.githubusercontent.com/24636767/102076516-18b35b00-3e08-11eb-9d64-c4717c6737b0.png)        Memory usage 4    ![image](https://user-images.githubusercontent.com/24636767/102076541-236df000-3e08-11eb-98ab-ce1bb912493e.png)      The project uses dummy controller with one endpoint which has `@PreAuthorize(""hasRole('ROLE')"")` annotation. It has also basic `SecurityConfig` to enable `@PreAuthorize` annotation. Controller uses some dummy services to make sure that for each test Spring will recreate the context. I also set `spring.test.context.cache.maxSize=1` in [build.gradle](https://github.com/Pancor/leak/blob/master/build.gradle) to make sure that the grow of memory does not come from cache.  If you have any more questions about my configuration or anything else, let me know.","open","in: core,","Pancor","2020-12-14T11:40:00Z","2022-07-30T07:19:43Z"
"","26826","Configure StandardServletMultipartResolver to only support multipart/form-data","It seems that `StandardServletMultipartResolver` wraps `multipart/mixed` requests with `StandardMultipartHttpServletRequest` which fails in Jetty due to strict conformance to the spec.  I.e. `HttpServletRequest.getParts()` should only be called when the content type is `multipart/from-data` and not just any content type that starts with `multipart/`   Spring Framework Version: 5.2.9  Please see https://github.com/eclipse/jetty.project/issues/6196 for details. (exception and original request)","closed","type: enhancement,","aaronjwhiteside","2021-04-20T03:48:35Z","2021-07-12T21:20:11Z"
"","25987","SseEmitter: connection closed after first event","It seems like there is a regression introduced into `SseEmitter` in latest `5.2.10.RELEASE` (apparently https://github.com/spring-projects/spring-framework/issues/25442), it now returns to the client only first SSE event.   ### How to reproduce   ``` package com.example.sse.emmiter;  import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  import org.apache.commons.lang3.builder.EqualsBuilder; import org.apache.commons.lang3.builder.HashCodeBuilder; import org.apache.commons.lang3.builder.ToStringBuilder; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.servlet.mvc.method.annotation.SseEmitter; import org.springframework.web.servlet.mvc.method.annotation.SseEmitter.SseEventBuilder;  @SpringBootApplication public class SseEmitterRegressionApplication {     @RestController     @EnableAutoConfiguration     static class LibraryController {         @GetMapping(""/sse"")         public SseEmitter streamSseMvc() {             final SseEmitter emitter = new SseEmitter();             final ExecutorService sseMvcExecutor = Executors.newSingleThreadExecutor();                          sseMvcExecutor.execute(() -> {                 try {                     for (int eventId = 1; eventId <= 5; ++eventId) {                         SseEventBuilder event = SseEmitter.event()                             .id(Integer.toString(eventId))                             .data(new Book(""New Book #"" + eventId, ""Author #"" + eventId), MediaType.APPLICATION_JSON)                             .name(""book"");                         emitter.send(event);                         Thread.sleep(100);                     }                     emitter.complete();                 } catch (Exception ex) {                     emitter.completeWithError(ex);                 }             });                          return emitter;         }     }          static class Book {         private String title;         private String author;          public Book() {         }          public Book(final String title, final String author) {             this.setTitle(title);             this.setAuthor(author);         }          public String getTitle() {             return title;         }          public void setTitle(String title) {             this.title = title;         }          public String getAuthor() {             return author;         }          public void setAuthor(String author) {             this.author = author;         }                  @Override         public int hashCode() {             return HashCodeBuilder.reflectionHashCode(this);         }          @Override         public boolean equals(Object obj) {             return EqualsBuilder.reflectionEquals(this, obj);         }                  @Override         public String toString() {             return ToStringBuilder.reflectionToString(this);         }     }      public static void main(String[] args) {         SpringApplication.run(SseEmitterRegressionApplication.class, args);     } } ```  - using latest Spring Boot `2.3.4.RELEASE` and Spring Framework `5.2.9.RELEASE`  ``` $ curl http://localhost:8080/sse -iv  > GET /sse HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.71.1 > Accept: */* > * Mark bundle as not supporting multiuse < HTTP/1.1 200 < Content-Type: text/event-stream < Transfer-Encoding: chunked < Date: Wed, 28 Oct 2020 22:09:00 GMT < { [15 bytes data] 100   335    0   335    0     0    589      0 --:--:-- --:--:-- --:--:--   590HTTP/1.1 200  Content-Type: text/event-stream Transfer-Encoding: chunked Date: Wed, 28 Oct 2020 22:09:00 GMT  id:1 data:{""title"":""New Book #1"",""author"":""Author #1""} event:book  id:2 data:{""title"":""New Book #2"",""author"":""Author #2""} event:book  id:3 data:{""title"":""New Book #3"",""author"":""Author #3""} event:book  id:4 data:{""title"":""New Book #4"",""author"":""Author #4""} event:book  id:5 data:{""title"":""New Book #5"",""author"":""Author #5""} event:book ```  - using latest Spring Boot `2.3.4.RELEASE` and Spring Framework `5.2.10.RELEASE` (overriding with `5.2.10.RELEASE`)  ``` $ curl http://localhost:8080/sse -iv  > GET /sse HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.71.1 > Accept: */* > * Mark bundle as not supporting multiuse < HTTP/1.1 200 < Content-Type: text/event-stream < Transfer-Encoding: chunked < Date: Wed, 28 Oct 2020 22:10:33 GMT < { [15 bytes data] 100    54    0    54    0     0   2250      0 --:--:-- --:--:-- --:--:--  2250HTTP/1.1 200 Content-Type: text/event-stream Transfer-Encoding: chunked Date: Wed, 28 Oct 2020 22:10:33 GMT  id:1 data:{""title"":""New Book #1"",""author"":""Author #1""} ```  Reproducible all the time. Please advice if this is a regression or `SseEmitter` semantics has changed (would appreciate documentation pointers) or more details are needed, thank you.","closed","type: regression,","reta","2020-10-28T22:22:00Z","2020-10-30T18:43:53Z"
"","26534","RSocket support not linked from user guide index","It might be useful to indicate (if possible) where to find the docs for RSocket in the top-level index: https://docs.spring.io/spring-framework/docs/current/reference/html/","closed","type: documentation,","dsyer","2021-02-10T14:08:57Z","2021-02-11T08:34:46Z"
"","26450","Add Javadoc @since tag to TransactionSynchronizationUtils.unwrapResourceIfNecessary()","It has been changed to be `public` in 4a7a2258f9ad8771e9a8225f5a18db156372162a, but its Javadoc `@since` tag seems to be missed. This PR simply adds it.","closed","type: task,","izeye","2021-01-27T03:52:47Z","2021-01-27T10:54:21Z"
"","25983","JPA 2.1 @Procedure with multiple out parameters","Issue: call procedure with multiple out parameters.  @Procedure(procedureName = ""procedureName"" , outputParameterName = ""parma1"", outputParameterName = ""param2"") Map methodName();  I am getting below error: Caused by: java.lang.IllegalArgumentException: Type cannot be null         at org.hibernate.query.procedure.internal.ProcedureParameterImpl.setHibernateType(ProcedureParameterImpl.java:130)         at org.hibernate.query.procedure.internal.ProcedureParameterImpl.(ProcedureParameterImpl.java:88)         at org.hibernate.procedure.internal.ProcedureCallImpl.registerParameter(ProcedureCallImpl.java:290)         at org.hibernate.procedure.internal.ProcedureCallImpl.registerStoredProcedureParameter(ProcedureCallImpl.java:579)         at org.hibernate.procedure.internal.ProcedureCallImpl.registerStoredProcedureParameter(ProcedureCallImpl.java:70)         at org.springframework.data.jpa.repository.query.StoredProcedureJpaQuery.lambda$newAdhocStoredProcedureQuery$1(StoredProcedureJpaQuery.java:228)         at java.base/java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Streams.java:104)         at java.base/java.util.stream.IntPipeline$Head.forEach(IntPipeline.java:593)         at org.springframework.data.jpa.repository.query.StoredProcedureJpaQuery.newAdhocStoredProcedureQuery(StoredProcedureJpaQuery.java:219)         at org.springframework.data.jpa.repository.query.StoredProcedureJpaQuery.createStoredProcedure(StoredProcedureJpaQuery.java:179)         at org.springframework.data.jpa.repository.query.StoredProcedureJpaQuery.doCreateQuery(StoredProcedureJpaQuery.java:103)         at org.springframework.data.jpa.repository.query.StoredProcedureJpaQuery.createQuery(StoredProcedureJpaQuery.java:93)   **Affects:** \  ---","closed","","subesingh1981","2020-10-28T12:56:11Z","2022-02-18T19:06:32Z"
"","26440","IllegalAccess to Unnamed Module","Issue with Spring 5.3.3 ->  Main Class ``` /**  * @param args  */ public static void main(String[] args) {      ApplicationContext context = new AnnotationConfigApplicationContext(ConfigTest.class); } ```  ConfigTest.class (in the same package of Main Class) ``` @Configuration @PropertySource(""application.properties"") public class ConfigTest { 	     @Value(value = ""test.value"")     private String test;       /**       * @return the test       */      public String getTest() {           return test;      }   ``` application.properties file `test.value = this is a test!`  module-info.java ``` module ceschi.owm { 	requires spring.context; 	requires spring.beans;         exports it.ceschi.owm; }  ``` when I try to run it, the following error happen: ``` Exception in thread ""main"" org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalAccessException-->module ceschi.owm does not open it.ceschi.owm to unnamed module @25bfcafd 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:514) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:585) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419) 	at spring.context@5.3.3/org.springframework.context.annotation.ConfigurationClassEnhancer.createClass(ConfigurationClassEnhancer.java:137) 	at spring.context@5.3.3/org.springframework.context.annotation.ConfigurationClassEnhancer.enhance(ConfigurationClassEnhancer.java:109) 	at spring.context@5.3.3/org.springframework.context.annotation.ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurationClassPostProcessor.java:443) 	at spring.context@5.3.3/org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanFactory(ConfigurationClassPostProcessor.java:273) 	at spring.context@5.3.3/org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:299) 	at spring.context@5.3.3/org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:134) 	at spring.context@5.3.3/org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:751) 	at spring.context@5.3.3/org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:569) 	at spring.context@5.3.3/org.springframework.context.annotation.AnnotationConfigApplicationContext.(AnnotationConfigApplicationContext.java:93) 	at ceschi.owm/it.ceschi.owm.OWMMain.main(OWMMain.java:29) Caused by: java.lang.IllegalAccessException: module ceschi.owm does not open it.ceschi.owm to unnamed module @25bfcafd 	at java.base/java.lang.invoke.MethodHandles.privateLookupIn(MethodHandles.java:255) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:508) 	... 22 more ```  As for what the unnamed module can be, i don't know. I tried to open in module-info my module, but nothing changed. I even opened the module to all, to java.lang, java.base or to cglib. Running on Windows 10 with JDK 15.0.2 or OpenJDK 15.0.1, same issue. I also tried removing the @Value in the config Class, with no change. The only thing that work is changing `ApplicationContext context = new AnnotationConfigApplicationContext(ConfigTest.class);` to `ApplicationContext context = new AnnotationConfigApplicationContext();` or putting Maven dependency to Classpath and not to Modulepath.","open","in: core,","DarkCeschi","2021-01-25T10:26:13Z","2021-09-20T12:07:30Z"
"","26306","Issue with Feign Client GET request call with query PARAM having special characters are failing with below exception. IPV6 kubernates cluster","Issue with Feign client GET request call with query PARAM having special characters are failing with below exception  Spring version : 2.3.4.RELEASE Spring Cloud version : Hoxton.SR8 Java version : open jdk 11 Environment : Kubernates cluster environment with microservices. Cluster setup is with IPV6. All the communiation between microservices via IPV6.  ### Debugging details: Kubernates setup with two nodes where local eureka server is configured as discovery server.  Two microservices should be configured with IPV6. Configurations provided below. application.yml server: address: fe80::1126:88ba:243:2db0 port: 8003  eureka: client: serviceUrl: defaultZone: ${EUREKA_URI:http://[fe80::1126:88ba:243:2db0]:8761/eureka} instance: ip-address: fe80::1126:88ba:243:2db0 preferIpAddress: true  JVM arguments to make IPV6 use by application. -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=true   ### Test case schenario :  Request received from Frontend to one of the microservice say ""Service A"". Microservice Service A required information from Microservice Service B. To get the data from Microservice Service B, we are makign a Feign Client call from Microservice Service A. Request URL from Service A to Service B is: http://serviceB/api/v1/checkEmailUnique?email=sampleemail@gmail.com  When we make a call, java trace as   ### Step1 : BlockingLoadBalancerClient.reconstructURI(BlockingLoadBalancerClient.java:75) ```java @Override public URI reconstructURI(ServiceInstance serviceInstance, URI original) { 	return LoadBalancerUriTools.reconstructURI(serviceInstance, original); } ``` Here serviceInstance has information about the IP address (IPV6 : 240b:c0e0:202:5e2b:b424:2:0:4b4), port (8001) and service name (serviceB).  original : http://serviceB/api/v1/checkEmailUnique?email=sampleemail%40gmail.com  ### Step2 :  ```java /**  * Modifies the URI in order to redirect the request to a service instance of choice.  * @param serviceInstance the {@link ServiceInstance} to redirect the request to.  * @param original the {@link URI} from the original request  * @return the modified {@link URI}  */ public static URI reconstructURI(ServiceInstance serviceInstance, URI original) { 	if (serviceInstance == null) { 		throw new IllegalArgumentException(""Service Instance cannot be null.""); 	} 	return doReconstructURI(serviceInstance, original); } ```  ### Step3 :  ```java private static URI doReconstructURI(ServiceInstance serviceInstance, URI original) { 	String host = serviceInstance.getHost(); 	String scheme = Optional.ofNullable(serviceInstance.getScheme()) 			.orElse(computeScheme(original, serviceInstance)); 	int port = computePort(serviceInstance.getPort(), scheme);  	if (Objects.equals(host, original.getHost()) && port == original.getPort() 			&& Objects.equals(scheme, original.getScheme())) { 		return original; 	}  	boolean encoded = containsEncodedParts(original); 	return UriComponentsBuilder.fromUri(original).scheme(scheme).host(host).port(port) 			.build(encoded).toUri(); } ``` In above code, encoded value is requred as true because url is encloded. boolean encoded = containsEncodedParts(original);  ### Step 4 :  ```java public UriComponents build(boolean encoded) { 	return buildInternal(encoded ? 			EncodingHint.FULLY_ENCODED : 			this.encodeTemplate ? EncodingHint.ENCODE_TEMPLATE : EncodingHint.NONE); } ```  ### Step 5: EncodingHint.FULLY_ENCODED send  ```java private UriComponents buildInternal(EncodingHint hint) { 	UriComponents result; 	if (this.ssp != null) { 		result = new OpaqueUriComponents(this.scheme, this.ssp, this.fragment); 	} 	else { 		HierarchicalUriComponents uric = new HierarchicalUriComponents(this.scheme, this.fragment, 				this.userInfo, this.host, this.port, this.pathBuilder.build(), this.queryParams, 				hint == EncodingHint.FULLY_ENCODED);  		result = hint == EncodingHint.ENCODE_TEMPLATE ? uric.encodeTemplate(this.charset) : uric; 	} 	if (!this.uriVariables.isEmpty()) { 		result = result.expand(name -> this.uriVariables.getOrDefault(name, UriTemplateVariables.SKIP_VALUE)); 	} 	return result; } ```  ### Step 6: Because encoding value is true its calls a method verify()... below...  ```java HierarchicalUriComponents uric = new HierarchicalUriComponents(this.scheme, this.fragment, 				this.userInfo, this.host, this.port, this.pathBuilder.build(), this.queryParams, 				hint == EncodingHint.FULLY_ENCODED); 				  /**  * Package-private constructor. All arguments are optional, and can be {@code null}.  * @param scheme the scheme  * @param userInfo the user info  * @param host the host  * @param port the port  * @param path the path  * @param query the query parameters  * @param fragment the fragment  * @param encoded whether the components are already encoded  */ HierarchicalUriComponents(@Nullable String scheme, @Nullable String fragment, @Nullable String userInfo, 		@Nullable String host, @Nullable String port, @Nullable PathComponent path, 		@Nullable MultiValueMap query, boolean encoded) {  	super(scheme, fragment);  	this.userInfo = userInfo; 	this.host = host; 	this.port = port; 	this.path = path != null ? path : NULL_PATH_COMPONENT; 	this.queryParams = query != null ? CollectionUtils.unmodifiableMultiValueMap(query) : EMPTY_QUERY_PARAMS; 	this.encodeState = encoded ? EncodeState.FULLY_ENCODED : EncodeState.RAW;  	// Check for illegal characters.. 	if (encoded) { 		verify(); 	} } ```  ### Step 7: In verify method. verifyUriComponent(this.host, getHostType());  ```java /**  * Check if any of the URI components contain any illegal characters.  * @throws IllegalArgumentException if any component has illegal characters  */ private void verify() { 	verifyUriComponent(getScheme(), Type.SCHEME); 	verifyUriComponent(this.userInfo, Type.USER_INFO); 	verifyUriComponent(this.host, getHostType()); 	this.path.verify(); 	this.queryParams.forEach((key, values) -> { 		verifyUriComponent(key, Type.QUERY_PARAM); 		for (String value : values) { 			verifyUriComponent(value, Type.QUERY_PARAM); 		} 	}); 	verifyUriComponent(getFragment(), Type.FRAGMENT); } ``` ### Step 8: Here host IP is : 240b:c0e0:202:5e2b:b424:2:0:4b4 and this doesn't have ""["" hence its treated as IPV4 address.  ```java private Type getHostType() { 	return (this.host != null && this.host.startsWith(""["") ? Type.HOST_IPV6 : Type.HOST_IPV4); } ```  ### Step 9: verifyUriComponent method throws below exception....  verifyUriComponent(this.host, getHostType()); ```java private static void verifyUriComponent(@Nullable String source, Type type) { 	if (source == null) { 		return; 	} 	int length = source.length(); 	for (int i = 0; i < length; i++) { 		char ch = source.charAt(i); 		if (ch == '%') { 			if ((i + 2) < length) { 				char hex1 = source.charAt(i + 1); 				char hex2 = source.charAt(i + 2); 				int u = Character.digit(hex1, 16); 				int l = Character.digit(hex2, 16); 				if (u == -1 || l == -1) { 					throw new IllegalArgumentException(""Invalid encoded sequence \"""" + 							source.substring(i) + ""\""""); 				} 				i += 2; 			} 			else { 				throw new IllegalArgumentException(""Invalid encoded sequence \"""" + 						source.substring(i) + ""\""""); 			} 		} 		else if (!type.isAllowed(ch)) { 			throw new IllegalArgumentException(""Invalid character '"" + ch + ""' for "" + 					type.name() + "" in \"""" + source + ""\""""); 		} 	} } ```  ### Exception stack trace:  ``` 2020-12-18 08:50:53.488 DEBUG [,bf7c6d79a8c83a34,bf543439eefefbf5,true] 10 --- [r-management-24] c.f.TraceFeignBlockingLoadBalancerClient : Before send 2020-12-18 08:50:53.489 DEBUG [,bf7c6d79a8c83a34,bf543439eefefbf5,true] 10 --- [r-management-24] c.f.TraceFeignBlockingLoadBalancerClient : Exception thrown  java.lang.IllegalArgumentException: Invalid character ':' for HOST_IPV4 in ""240b:c0e0:202:5e2b:b424:2:0:4b4""         at org.springframework.web.util.HierarchicalUriComponents.verifyUriComponent(HierarchicalUriComponents.java:416)         at org.springframework.web.util.HierarchicalUriComponents.verify(HierarchicalUriComponents.java:379)         at org.springframework.web.util.HierarchicalUriComponents.(HierarchicalUriComponents.java:145)         at org.springframework.web.util.UriComponentsBuilder.buildInternal(UriComponentsBuilder.java:417)         at org.springframework.web.util.UriComponentsBuilder.build(UriComponentsBuilder.java:406)         at org.springframework.cloud.client.loadbalancer.LoadBalancerUriTools.doReconstructURI(LoadBalancerUriTools.java:111)         at org.springframework.cloud.client.loadbalancer.LoadBalancerUriTools.reconstructURI(LoadBalancerUriTools.java:95)         at org.springframework.cloud.loadbalancer.blocking.client.BlockingLoadBalancerClient.reconstructURI(BlockingLoadBalancerClient.java:75)         at org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient.execute(FeignBlockingLoadBalancerClient.java:73)         at org.springframework.cloud.sleuth.instrument.web.client.feign.TraceFeignBlockingLoadBalancerClient.execute(TraceFeignBlockingLoadBalancerClient.java:76)         at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:119)         at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:89)         at feign.hystrix.HystrixInvocationHandler$1.run(HystrixInvocationHandler.java:109)         at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:302)         at com.netflix.hystrix.HystrixCommand$2.call(HystrixCommand.java:298)         at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:46)         at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)         at rx.Observable.unsafeSubscribe(Observable.java:10327)         at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:51)         at rx.internal.operators.OnSubscribeDefer.call(OnSubscribeDefer.java:35)         at rx.Observable.unsafeSubscribe(Observable.java:10327)         at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)         at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)         at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)         at rx.Observable.unsafeSubscribe(Observable.java:10327)         at rx.internal.operators.OperatorSubscribeOn$SubscribeOnSubscriber.call(OperatorSubscribeOn.java:100)         at com.netflix.hystrix.strategy.concurrency.HystrixContexSchedulerAction$1.call(HystrixContexSchedulerAction.java:56)         at com.netflix.hystrix.strategy.concurrency.HystrixContexSchedulerAction$1.call(HystrixContexSchedulerAction.java:47)         at org.springframework.cloud.sleuth.instrument.async.TraceCallable.call(TraceCallable.java:71)         at com.netflix.hystrix.strategy.concurrency.HystrixContexSchedulerAction.call(HystrixContexSchedulerAction.java:69)         at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)         at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)         at java.base/java.util.concurrent.FutureTask.run(Unknown Source)         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)         at java.base/java.lang.Thread.run(Unknown Source) 2020-12-18 08:50:53.490 DEBUG [,bf7c6d79a8c83a34,bf7c6d79a8c83a34,true] 10 --- [nio-8003-exec-2] .m.m.a.ExceptionHandlerExceptionResolver : Using @ExceptionHandler com.mavenir.dep.accountmanagement.exception.CustomResponseEntityExceptionHandler#handleHystrixRuntimeException(HystrixRuntimeException, WebRequest) 2020-12-18 08:50:53.491 ERROR [,bf7c6d79a8c83a34,bf7c6d79a8c83a34,true] 10 --- [nio-8003-exec-2] a.e.CustomResponseEntityExceptionHandler : Hystrix Runtime Exception caused by : ```","closed","for: external-project,","vasureddys","2020-12-21T12:43:27Z","2021-01-18T09:05:33Z"
"","26430","Add unique number to WebFlux log prefix for Undertow server","Issue #22039 was created and fixed for the Netty server. The same problem exists for the Undertow reactive server.  UndertowServerHttpRequest.initId method should add an incrementing number to ensure that each new HTTP request gets assigned a unique log id.","closed","type: enhancement,","pdevalck","2021-01-22T08:10:44Z","2021-01-22T15:28:32Z"
"","26316","Optimize memory allocations in StringUtils#cleanPath","Investigating once again slow Spring Boot start times, I played around with Java Mission Control profiler and found out that `StringUtils#cleanPath` alone is responsible for 7% of all CPU time spent during setup of the application context. Looking at the implementation I was able to identify some potential hotspots (e.g. LinkedList). The application is currently using Spring Framework 5.1.10 and I was happy to find that some of these issues have already been fixed in more recent versions of Spring.  However there are still a few more opportunities to avoid memory allocations and copying of data:  * Set a sensible initial capacity for lists and string builders: optimize for the common cases. We will sometimes allocate a few bytes more than required, but at least we avoid re-allocating the backing array. For the StringBuilder we need to iterate the collection twice to calculate the capacity beforehand. But iterating is a lot cheaper compared to allocating memory two or more times. * Re-use strings instead of concatenating their parts again: an earlier optimization introduced short-circuiting for a common case. We have computed the return value already before splitting it, so return it directly. * Do not concatenate with the empty string: Future JDKs might alleviate this, but at least with Java 11, `return """" + somestring;` is slower than `return somestring;`. Obviously it is more expensive memory-wise due to the construction of the newly resulting string.  This PR relates to and builds on #24674, #25650, #25552, #25553, and others.","closed","type: enhancement,","knittl","2020-12-23T21:33:00Z","2021-10-13T20:08:46Z"
"","26063","Introduce and() methods in MethodFilter and FieldFilter for composite filters","Introducing `and()` default methods in the `MethodFilter` and `FieldFilter` functional interfaces in `ReflectionUtils` will simplify use cases that need to compose logic for such filters.","closed","type: enhancement,","sbrannen","2020-11-10T15:25:31Z","2020-11-10T17:01:19Z"
"","26822","Use String.startsWith() instead of String.substring() in PatternMatchUtils","Instead of allocating a new substring at each call we can use `String.startsWith()`","closed","type: enhancement,","stsypanov","2021-04-18T08:57:43Z","2021-04-21T11:59:17Z"
"","26509","Unable to mock HttpHeaders since Spring Framework 5.3","In unit test with mockito and Junit 5   with version Spring Boot 2.3.4 @Mock HttpHeaders works  ![image](https://user-images.githubusercontent.com/50639030/106818523-66995200-6646-11eb-905e-a3c722120ecf.png)   ![image](https://user-images.githubusercontent.com/50639030/106818448-4bc6dd80-6646-11eb-9bc3-6e9d22c6f5c1.png)  but in version 2.4.X this error appears, apparently Mock HttpHeaders is null or empty in this verification  ![image](https://user-images.githubusercontent.com/50639030/106819034-37371500-6647-11eb-9bff-dc2e418d93c8.png)   ![image](https://user-images.githubusercontent.com/50639030/106818702-a6603980-6646-11eb-92d3-29f92edfe4e8.png)  with version Spring Boot 2.3.4 this verification was like this and it worked  ![image](https://user-images.githubusercontent.com/50639030/106819493-e247ce80-6647-11eb-9108-fc2e432181a1.png)   please fix it in new versions, thank you very much.","closed","status: declined,","ERAGON-JCV","2021-02-03T23:00:25Z","2021-02-10T12:46:48Z"
"","26710","Client WS disconnect triggers server failure","In two Spring Boot 2.4.4 applications, the [session.disconnect()](https://github.com/spring-guides/gs-messaging-stomp-websocket/blob/master/complete/src/test/java/com/example/messagingstompwebsocket/GreetingIntegrationTests.java#L77) in the `gs-messaging-stomp-websocket` sample can trigger the exception below on the associated server when run as separate applications:  ``` 2021-03-21 12:34:59.943[0;39m [32mDEBUG[0;39m [35m12622[0;39m [2m---[0;39m [2m[boundChannel-31][0;39m [36ms.w.s.s.t.s.WebSocketServerSockJsSession[0;39m [2m:[0;39m Terminating connection after failure to send message to client  java.lang.IllegalStateException: Message will not be sent because the WebSocket session has been closed 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.writeMessagePart(WsRemoteEndpointImplBase.java:439) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlock(WsRemoteEndpointImplBase.java:311) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlock(WsRemoteEndpointImplBase.java:251) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendPartialString(WsRemoteEndpointImplBase.java:224) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendText(WsRemoteEndpointBasic.java:49) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.springframework.web.socket.adapter.standard.StandardWebSocketSession.sendTextMessage(StandardWebSocketSession.java:215) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.adapter.AbstractWebSocketSession.sendMessage(AbstractWebSocketSession.java:106) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.writeFrameInternal(WebSocketServerSockJsSession.java:224) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.writeFrame(AbstractSockJsSession.java:326) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.sendMessageInternal(WebSocketServerSockJsSession.java:213) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.sendMessage(AbstractSockJsSession.java:170) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator.tryFlushMessageBuffer(ConcurrentWebSocketSessionDecorator.java:190) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator.sendMessage(ConcurrentWebSocketSessionDecorator.java:163) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.sendToClient(StompSubProtocolHandler.java:494) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageToClient(StompSubProtocolHandler.java:481) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:366) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:144) ~[spring-messaging-5.3.5.jar:5.3.5] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]  [2m2021-03-21 12:34:59.945[0;39m [32mDEBUG[0;39m [35m12622[0;39m [2m---[0;39m [2m[boundChannel-31][0;39m [36mo.s.w.s.m.StompSubProtocolHandler       [0;39m [2m:[0;39m Failed to send WebSocket message to client in session 23326ba4647c4e33b5de83f443398b33  org.springframework.web.socket.sockjs.SockJsTransportFailureException: Failed to write SockJsFrame content='a[""ERROR\nmessage:Session closed.\ncontent-length:0\n\n\u0000""]'; nested exception is java.lang.IllegalStateException: Message will not be sent because the WebSocket session has been closed 	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.writeFrame(AbstractSockJsSession.java:343) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.sendMessageInternal(WebSocketServerSockJsSession.java:213) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.sendMessage(AbstractSockJsSession.java:170) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator.tryFlushMessageBuffer(ConcurrentWebSocketSessionDecorator.java:190) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator.sendMessage(ConcurrentWebSocketSessionDecorator.java:163) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.sendToClient(StompSubProtocolHandler.java:494) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageToClient(StompSubProtocolHandler.java:481) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:366) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:144) ~[spring-messaging-5.3.5.jar:5.3.5] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] Caused by: java.lang.IllegalStateException: Message will not be sent because the WebSocket session has been closed 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.writeMessagePart(WsRemoteEndpointImplBase.java:439) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlock(WsRemoteEndpointImplBase.java:311) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlock(WsRemoteEndpointImplBase.java:251) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendPartialString(WsRemoteEndpointImplBase.java:224) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendText(WsRemoteEndpointBasic.java:49) ~[tomcat-embed-websocket-9.0.44.jar:9.0.44] 	at org.springframework.web.socket.adapter.standard.StandardWebSocketSession.sendTextMessage(StandardWebSocketSession.java:215) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.adapter.AbstractWebSocketSession.sendMessage(AbstractWebSocketSession.java:106) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.writeFrameInternal(WebSocketServerSockJsSession.java:224) ~[spring-websocket-5.3.5.jar:5.3.5] 	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.writeFrame(AbstractSockJsSession.java:326) ~[spring-websocket-5.3.5.jar:5.3.5] 	... 11 common frames omitted ``` More often than not, I have to restart the server after a single apparently successful client run. Although this is sample code, the server-side should not become unstable from a quick client disconnect (or any other client action for that matter).  You can reproduce from [my repository](https://github.com/JanStureNielsen/websocket-samples/tree/spring-framework-issue-26710) or from the Spring Guides repository.","open","in: web,","JanStureNielsen","2021-03-21T18:49:22Z","2021-11-10T11:43:11Z"
"","25970","Wrong link in Spring framework tutorial","In the following document: src/docs/asciidoc/core/core-resources.adoc (compared against master (version 5.2.9.RELEASE))  The link in line 566: ""See the {api-spring-framework}/jca/context/SpringContextResourceAdapter.html[`ClassPathXmlApplicationContext`]"" should replaced with:  {api-spring-framework}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`]","closed","type: task,","eladAlfa","2020-10-25T23:07:57Z","2020-10-26T07:50:32Z"
"","26508","Get Serialized Names in Exception Handler","In the `ExceptionHandler` for `MethodArgumentNotValidExceptions` a way for getting the serialized names of the violated fields is missing. Using `MethodArgumentNotValidException.getBindingResult().getAllErrors()` ... `FieldError.getField()` the POJO's name is returned which is not acceptable for the response body in case of different serialized names (Example: `photoUrls` vs. `photo-urls`).  Code: ``` @JsonProperty(""photo-urls"") private List photoUrls; ```  In this case `photoUrls` is returned which is the wrong key for the client's request.","open","in: web,","dirweis","2021-02-04T11:02:24Z","2021-11-10T12:28:52Z"
"","26662","Add an MockMVC alwaysDo equivalent to WebTestClient","In Spring Cloud Contract we're generating tests for our users. Typically what is being used is the RestAssured library for sending out HTTP requests. RestAssured has a MockMVC and WebTestClient extensions. The users can't modify the generated tests - what they can do is to write code in the base class that the generated test extends.  With MockMVC I could do the following  ```java @ExtendWith(RestDocumentationExtension.class) public abstract class BeerRestBase { 	ProducerController producerController = new ProducerController(oldEnough()); 	StatsController statsController = new StatsController(statsService());  	private PersonCheckingService oldEnough() { 		return argument -> argument.age >= 20; 	}  	private StatsService statsService() { 		return name -> new Random().nextInt(); 	}  	@BeforeEach 	public void setup(RestDocumentationContextProvider provider, TestInfo testInfo) { 		RestAssuredMockMvc.mockMvc(MockMvcBuilders.standaloneSetup(this.producerController, this.statsController) 				.apply(documentationConfiguration(provider)) 				.alwaysDo(document(getClass().getSimpleName() + ""_"" + testInfo.getDisplayName())) 				.build()); 	} } ```  Notice the `.alwaysDo(document(getClass().getSimpleName() + ""_"" + testInfo.getDisplayName()))` part. We are running this assertion for each test method and each MockMVC call.  I'd like to achieve sth similar for `WebTestClient`.   I can write this:  ```java WebTestClient webTestClient = WebTestClient.bindToController(this.producerController, this.statsController).configureClient() 				.filter(documentationConfiguration(provider)) 				.build(); RestAssuredWebTestClient.webTestClient(webTestClient); ```  This is a fine way of hooking RestDocs to WebTestClient. I can't however make the global `consumeWith(...)` call like in the RestDocs snippet  ```java this.webTestClient.get().uri(""/"").accept(MediaType.APPLICATION_JSON)  		.exchange().expectStatus().isOk()  		.expectBody().consumeWith(document(""index""));  ```  It would be great to add sch a functionality.  cc @wilkinsona   Related issue:  https://github.com/spring-cloud-samples/spring-cloud-contract-samples/issues/106","closed","type: enhancement,","marcingrzejszczak","2021-03-11T09:47:38Z","2021-03-15T10:00:52Z"
"","26679","Exceptions for missing request values should expose information when they are missing after conversion","In Spring 5.3 it is possible that a `MissingServletRequestParameterException` is thrown although a _required_ parameter is _provided_ (and therefore _not missing_). The same holds for a required path variable - even it is provided a `MissingPathVariableException` may be thrown.  Moreover the `MissingServletRequestParameterException` triggers a response status 400 in contrast to the `MissingPathVariableException` which ends up in a response status 500.  The former happens due to the changes made in https://github.com/spring-projects/spring-framework/issues/23939: If a provided parameter (request parameter or path variable) is converted to `null` it is handled as a missing value, see  [AbstractNamedValueMethodArgumentResolver](https://github.com/spring-projects/spring-framework/blob/v5.3.4/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver.java#L136).  I would like to propose:  1. Adjust the response status. 2. Throw a different exception (e.g. `IllegalArgumentException`) if a required parameter (request parameter or path variable) is provided but _converted_ to `null`.  In a lengthy discussion with @rstoyanchev in https://github.com/spring-projects/spring-framework/issues/26088 (I thank his patience) I gave an example to explain that the current status is problematic:  1. two users load the same book entity via its id, let's say 42 2. one user deletes the book entity 3. the other user continues using URLs with the id 42  I attached a small spring boot app with several test cases ([github](https://github.com/drahkrub/spring_sandbox), [spring_sandbox-master.zip](https://github.com/spring-projects/spring-framework/files/6140112/spring_sandbox-master.zip)).  With  ``` @GetMapping(path = ""/rp/book"") public Book getBookByRequestParam(@RequestParam(""id"") Book book) {     ... ```  calling `/rp/book?id=42` leads to a `MissingServletRequestParameterException` which is also thrown if `/edit` is called without a parameter or with an empty parameter - these cases can not be distinguished in an elegant way, see the tests  * `noRequestParamThrowsMissingServletRequestParameterException` * `emptyRequestParamThrowsMissingServletRequestParameterException` * `idOfDeletedBookThrowsMissingServletRequestParameterException`  In contrast calling  ``` @GetMapping({""/pv/book/{id}""}) public Book getBookByPathVariable(@PathVariable(""id"") Book book) {     ... ```  with `/pv/book/42` ""only"" leads to a misleading `MissingPathVariableException`, but the method can not be called with no or an empty parameter (if `/pv/book` is not mapped to a different method it is handled by the `ResourceHttpRequestHandler`, see the test `missingValueNotHandledByController`).  But a conflicting case can be constructed this way:  ``` @GetMapping({""/cc/book"", ""/cc/book/{id}""}) public Book constructedCase(@PathVariable(""id"") Book book) {     ... ```  Here calling `/cc/book` and `/cc/book/42` both lead to a `MissingPathVariableException` - but as I said this is constructed resp. bad programming.","closed","type: enhancement,","drahkrub","2021-03-15T09:08:52Z","2021-04-26T11:00:00Z"
"","26017","Improve AdvisedSupport.getAdvisors()","In some scenarios `AdvisedSupport.updateAdvisorArray()` takes about 30% of `AdvisedSupport.addAdvisor()` (see attachment) and is pointless in fact, as the only place where we use `advisorArray` is `AdvisedSupport.getAdvisors()`. So we can rewrite the code to retrieve the array from the `advisors` list only when it is necessary instead of rewriting it on each addition or removal of advice.  This allows to simplify code and remove `advisorArray`. In order to reduce allocation rate I've also introduced `AdvisedSupport.getAdvisorCount()`.  ![Screenshot from 2020-11-02 09-43-52](https://user-images.githubusercontent.com/10835776/97843430-f18a4980-1cf1-11eb-916f-9494a3a40820.png)","closed","type: enhancement,","stsypanov","2020-11-02T21:24:15Z","2020-11-04T15:32:36Z"
"","26177","Optimize PostProcessorRegistrationDelegate's invokeBeanFactoryPostProcessors()","In PostProcessorRegistrationDelegate class ,the method invokeBeanFactoryPostProcessors, get postProcessorNames repeatedly, and it can need one traversal handle the PriorityOrdered and Ordered annotations， as following: ```	 	// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. 			String[] postProcessorNames = 					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 			for (String ppName : postProcessorNames) { 				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); 					processedBeans.add(ppName); 				} 			} 			sortPostProcessors(currentRegistryProcessors, beanFactory); 			registryProcessors.addAll(currentRegistryProcessors); 			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 			currentRegistryProcessors.clear();  			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. 			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 			for (String ppName : postProcessorNames) { 				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) { 					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); 					processedBeans.add(ppName); 				} 			} ```","closed","status: superseded,","zhuyuehui","2020-11-30T07:21:49Z","2020-12-30T14:47:02Z"
"","26458","Introduce SPI for automatic bean definition profile registration","In our project we created a starter which contains most general stuff, like database, feign clients and so on.  Now we want to configure this starter with different properties per stage.  Currently we created a file ""application-commons.yaml"" in our starter and include this ""profile"" at `spring.profiles.active`, but this does not really scale well if we create more starters, or more applications. We would have to keep in mind to add all the profiles to all the services.  With this PR we are able to implement an `AdditionalProfileLoader`, which returns the name of the starters ""profile"", and then add the class to the `spring.factories`: `org.springframework.core.io.support.AdditionalProfileLoader=com.example.AdditionalCommonProfile`  This PR relates to https://github.com/spring-projects/spring-boot/pull/25033 which adds the ability to load additional files like `commons.yaml`, `commons-local.yaml` and so on.","closed","status: declined,","raddatzk","2021-01-27T18:27:05Z","2021-01-28T20:17:28Z"
"","26815","Divide RAM usage by 5 for ResultSets from ColumnMapRowMapper","In our application, we heavily use procedures returning cursors/ResultSets. We found a big unjustified RAM usage causing problems in production.  It is caused by ColumnMapRowMapper: mapOfColumnValues is a LinkedCaseInsensitiveMap. The LinkedCaseInsensitiveMap of each row has a caseInsensitiveKeys map whose keys are key.toLowerCase(getLocale()). Here lies the problem: for each data row, all the column names are duplicated (lower-cased) in memory.  This is huge: we often go OutOfMemoryError in exports, or when a lot of concurrent users are reading ResultSets at the same time.  We found we could divide RAM by a factor of about 2,2 in our case, by just avoiding all these duplicate Strings.  And to go further, each mapped row has an HashMap. Out of curiosity, we replaced the HashMap with a simple Object[], using the LinkedCaseInsensitiveMap as a Map. Here again, we gained an additional factor of about 2,2 in RAM urage.  By using both optimizations, we have divided by about 5 the RAM usage of ResultSet mapped by Spring. This is a huge benefit for our users, experiencing no OutOfMemory anymore, and able to do more work in parallel. We think this solution is optimal: there is no more optimization that could be done do reduce memory further (while keeping the code readable and decoupled).  Here is the code we used. I let you inspect it. Do you like the solution? If yes, you can refactor it to your liking/coding-standards if needed before incorporating it:  ```java ...     // Only for us not to use our own Spring Jdbc version     @Bean     public JdbcTemplate jdbcTemplate(DataSource dataSource) {         return new RamEfficientJdbcTemplate(dataSource);     } }  public class RamEfficientJdbcTemplate extends JdbcTemplate {     public RamEfficientJdbcTemplate(DataSource dataSource) {         super(dataSource);     }     // Only for us not to use our own Spring Jdbc version: could be integrated into the main Spring Jdbc codebase:     protected RowMapper> getColumnMapRowMapper() {         return new RamEfficientColumnMapRowMapper();     } }  /**  * {@link RowMapper} implementation similar to {@link ColumnMapRowMapper} but in a memory-efficient way.  * There is no String duplication of all lower-cased column names in each row (halving the RAM usage) by sharing the  * keyIndices among all rows.  * And it avoids unnecessary Maps (also halving the remaining RAM usage) by using simple arrays for each row.  */ public class RamEfficientColumnMapRowMapper implements RowMapper> {      private Map keyIndices;      @Override     public Map mapRow(ResultSet resultSet, int rowNum) throws SQLException {         ResultSetMetaData metaData = resultSet.getMetaData();         int columnCount = metaData.getColumnCount();          buildKeyIndices(metaData, columnCount);         return toValuesMap(resultSet, columnCount);     }      private void buildKeyIndices(ResultSetMetaData metaData, int columnCount) throws SQLException {         if (keyIndices == null) {             keyIndices = new LinkedCaseInsensitiveMap<>(columnCount);             for (int index = 0; index < columnCount; index++) {                 int position = index + 1;                 String column = JdbcUtils.lookupColumnName(metaData, position);                 keyIndices.put(getColumnKey(column), index);             }         }     }      private Map toValuesMap(ResultSet resultSet, int columnCount) throws SQLException {         Object[] values = new Object[columnCount];         for (int index = 0; index < columnCount; index++) {             int position = index + 1;             values[index] = getColumnValue(resultSet, position);         }          return new RamEfficientMap<>(keyIndices, values);     }      protected String getColumnKey(String columnName) {         return columnName;     }      @Nullable     protected Object getColumnValue(ResultSet rs, int index) throws SQLException {         return JdbcUtils.getResultSetValue(rs, index);     }  }  public class RamEfficientMap implements Map {      private final Map keyIndices;     private final V[] values;      public RamEfficientMap(Map keyIndices, V[] values) {         if (keyIndices.size() != values.length) {             throw new IllegalArgumentException(""There are "" + keyIndices.size() + "" keys but "" + values.length + "" values"");         }          this.keyIndices = keyIndices;         this.values = values;     }      @Override     public int size() {         return values.length;     }      @Override     public boolean isEmpty() {         return false;     }      @Override     public boolean containsKey(Object key) {         return keyIndices.containsKey(key);     }      @Override     public boolean containsValue(Object searchedValue) {         for (V value : values) {             boolean areBothNull = searchedValue == null && value == null;             boolean areBothEqual = searchedValue != null && searchedValue.equals(value);             if (areBothNull || areBothEqual) {                 return true;             }         }         return false;     }      @Override     public V get(Object key) {         Integer index = keyIndices.get(key);         return index == null ? null : values[index];     }      @Override     public V put(K key, V value) {         return throwImmutableMap();     }      @Override     public V remove(Object key) {         return throwImmutableMap();     }      @Override     public void putAll(Map map) {         throwImmutableMap();     }      @Override     public void clear() {         throwImmutableMap();     }      @Override     public Set keySet() {         return unmodifiableSet(keyIndices.keySet());     }      @Override     public Collection values() {         return unmodifiableList(asList(values));     }      @Override     public Set> entrySet() {         return keyIndices.keySet().stream()                 .map(this::toEntry)                 .collect(toSet());     }      private Entry toEntry(K key) {         return new SimpleImmutableEntry<>(key, get(key));     }      private V throwImmutableMap() {         throw new UnsupportedOperationException(""The map is immutable"");     }  } ```","open","type: enhancement,","slaout","2021-04-15T12:15:07Z","2022-01-18T14:01:53Z"
"","26376","Avoid getting objects that have not completed initialization","in org.springframework.beans.factory.support.DefaultSingletonBeanRegistry  ```java @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { // Quick check for existing instance without full singleton lock Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { 	singletonObject = this.earlySingletonObjects.get(beanName); 	if (singletonObject == null && allowEarlyReference) { 		synchronized (this.singletonObjects) { 			// Consistent creation of early reference within full singleton lock 			singletonObject = this.singletonObjects.get(beanName); 			if (singletonObject == null) { 				singletonObject = this.earlySingletonObjects.get(beanName); 				if (singletonObject == null) { 					ObjectFactory singletonFactory = this.singletonFactories.get(beanName); 					if (singletonFactory != null) { 						singletonObject = singletonFactory.getObject(); 						this.earlySingletonObjects.put(beanName, singletonObject); 						this.singletonFactories.remove(beanName); 					} 				} 			} 		} 	} } return singletonObject; } ```  Unit test   ```java public class Father {  	private Son son;  	public Son getSon() { 		return son; 	}  	public void setSon(Son son) { 		this.son = son; 	} } ```  ```java public class Son {  	private Father father;  	private Mother mother;  	public Father getFather() { 		return father; 	}  	public void setFather(Father father) { 		this.father = father; 	}  	public Mother getMother() { 		return mother; 	}  	public void setMother(Mother mother) { 		this.mother = mother; 	} } ```  ```java public class Mother {  	public Mother() {  		// Simulation takes a long time、just for testing 		try { 			Thread.sleep(4 * 1000); 		} catch (InterruptedException e) { 			e.printStackTrace(); 		}  	} }  ```    ```java 	@Test 	public void testGetLazySingleton() throws InterruptedException { 		testGetSingleton(""father""); 	}  	@Test 	public void testGetNonLazySingleton() throws InterruptedException { 		testGetSingleton(""father-non-lazy""); 	}  	private void testGetSingleton(String fatherBeanName) throws InterruptedException {  		CountDownLatch countDownLatch = new CountDownLatch(2); 		AtomicInteger occurExceptionCount = new AtomicInteger(0); 		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); 		reader.loadBeanDefinitions(new ClassPathResource(""DefaultSingletonBeanRegistryTests.xml"", getClass()));  		// Just for testing, you should use a thread pool 		new Thread(() -> { 			Father father = beanFactory.getBean(fatherBeanName, Father.class); 			try { 				Assert.notNull(father, ""father Shouldn't be null""); 				Assert.notNull(father.getSon(), ""son Shouldn't be null""); 			} catch (Exception e) { 				occurExceptionCount.incrementAndGet(); 				System.out.println(Thread.currentThread().getName()); 				e.printStackTrace(); 			} 			countDownLatch.countDown(); 		}, ""first-thread"").start();  		Thread.sleep(1000);  		// Just for testing, you should use a thread pool 		new Thread(() -> { 			Father father = beanFactory.getBean(fatherBeanName, Father.class); 			try { 				Assert.notNull(father, ""father Shouldn't be null""); 				Assert.notNull(father.getSon(), ""son Shouldn't be null""); 			} catch (Exception e) { 				occurExceptionCount.incrementAndGet(); 				System.out.println(Thread.currentThread().getName()); 				e.printStackTrace(); 			} 			countDownLatch.countDown(); 		}, ""second-thread"").start();  		while (countDownLatch.getCount() != 0) {  		} 		Assert.isTrue(occurExceptionCount.get() == 0, ""Throwing an exception in the sub-thread that gets the bean""); 	} ```    ```xml   	 	 	 		 	 	 		 		 	    	 	 	 		 	 	 		 		 	  ```    console log  ```log second-thread java.lang.IllegalArgumentException: son Shouldn't be null ........... ........... ```  The code after my changes  ```java @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) {   // Quick check for existing instance without full singleton lock   Object singletonObject = this.singletonObjects.get(beanName);   if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { 	  synchronized (this.singletonObjects) { 		  singletonObject = this.singletonObjects.get(beanName); 		  if (singletonObject != null || !isSingletonCurrentlyInCreation(beanName)) { 			  return singletonObject; 		  } 		  singletonObject = this.earlySingletonObjects.get(beanName); 		  if (singletonObject == null && allowEarlyReference) { 			  ObjectFactory singletonFactory = this.singletonFactories.get(beanName); 			  if (singletonFactory != null) { 				  singletonObject = singletonFactory.getObject(); 				  this.earlySingletonObjects.put(beanName, singletonObject); 				  this.singletonFactories.remove(beanName); 			  } 		  } 	  }   }   return singletonObject; } ```","open","status: feedback-provided,","lijinxiong","2021-01-12T13:58:08Z","2021-11-21T07:55:57Z"
"","26454","Synchronized access to MockHttpServletResponse headers","In order to support MVC async methods while testing with MockMvc, synchronizes any access to MockHttpServletResponse HTTP headers. It avoids ConcurrentModificationException thrown when e.g. 2 different threads read and write the header's map.  Link to a project reproducing the issue [here](https://github.com/aplsup/spring-mockmvc-aync-repro) Related/similar to #23460","closed","status: invalid,","aplsup","2021-01-27T14:12:59Z","2021-01-27T14:30:20Z"
"","26169","Spring Websockets Broker relay supporting active/standby broker","In order to support Broker Cluster setups and according to [Connecting to a Broker]( https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-handle-broker-relay-configure) we need to configure a supplier of addresses, instead of a fixed host and port.   However if we have an **active/standby** setup or in other words High Availability (HA) and Failover cluster (example: https://activemq.apache.org/components/artemis/documentation/1.0.0/ha.html) where only one of the broker instances is active at any time, is this approach still applicable? How will the `ReactorNettyTcpClient` behave in case of a Broker cluster node failure in general? It is mentioned that the STOMP broker relay always connects, and reconnects as needed if connectivity is lost, to the same host and port. In case of multiple addresses or an active/passive setup, if the TCP connection fails then an attempt is made against the next available node in the list?   @rstoyanchev Adding to the above questions just to note that `AbstractWebSocketMessageBrokerConfigurer` is Deprecated since 4.0.1 so perhaps an update in the reference docs is needed along with a more thorough explanation on what can be supported out of the box VS the custom implementation needed in production environments where connecting to a cluster is usually expected.","closed","in: messaging,","kmandalas","2020-11-27T17:18:30Z","2021-02-03T15:17:16Z"
"","26281","Introduce computeAttribute() in AttributeAccessor","In order to simplify certain use cases, we should introduce `computeAttribute()` as a `default` method in the `AttributeAccessor` interface, analogous to `computeIfAbsent()` in `java.util.Map`.","closed","type: enhancement,","sbrannen","2020-12-15T15:33:25Z","2020-12-15T21:47:46Z"
"","26792","Upgrade to Kotlin 1.5.0","In order to be consistent with Spring Boot 2.5 which should use Kotlin 1.5, we intend to build Spring Framework 5.3.7 against Kotlin 1.5.0 while retaining Kotlin 1.3 compatibility.","closed","type: dependency-upgrade,","sdeleuze","2021-04-12T15:46:24Z","2021-05-03T15:48:36Z"
"","26227","Avoid CGLIB proxies in websocket/messaging configuration","In order to allow support in native executables and for consistency with the changes done in the whole Spring portfolio, websocket and messaging configurations should be switched to `@Configuration(proxyBeanMethods = false)` in order to not require CGLIB proxies.","closed","type: enhancement,","sdeleuze","2020-12-07T09:56:26Z","2020-12-09T08:58:56Z"
"","26133","new interface exposes inner response for testing","In my production setup, I use `ServerResponse.async`, and in tests, I need to access the wrapped   `CompletableFuture`. right now the only way to access is through reflection, and that depends on the field name remaining the same in the future.  This pull requests introduces interface `AsyncServerResponse` with access to inner `futureResponse`. and the class previously called AsyncServerResponse, is now `DefaultAsyncServerResponse`.  This is the same as with `EntityResponse`. that exposes the entity, of a `DefaultEntityResponse`.  I realize that a user of this interface can act upon the inner future response, but to get at it, the user will have to manually cast to `AsyncServerResponse` and by that, take responsibility for their actions.","closed","in: web,","alexfeigin","2020-11-23T10:44:58Z","2020-12-03T13:54:48Z"
"","26166","MockMvc ignores MultipartFile registrations when both files and parts are registered","In my code I am doing something like:  ``` mockMvc.multipart(DOCUMENTS, uuid) {       file(MockMultipartFile(""file"", ""test.txt"", ""text/plain"", ""Test"".toByteArray()))       part(MockPart(""data"", """"""{""node"":""node""}"""""".toByteArray())) } ```  which is supposed to create a request with both a part, named `data`, and a file, named `file`.   This was supported in Spring 5.2, but it is not supported anymore in Spring 5.3 since https://github.com/spring-projects/spring-framework/issues/25602  I am not sure if it was a ""wrong"" use case, not meant to be working, or if the fix introduced in the linked PR is a regression, since `TestDispatcherServlet` simply creates a `StandardMultipartHttpServletRequest` without copying the files over, as `MockMultipartHttpServletRequestBuilder` was originally doing.  https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/multipart/support/StandardMultipartHttpServletRequest.java#L95 simply copies the `parts`, but not the `files`","closed","type: regression,","ThanksForAllTheFish","2020-11-27T15:25:33Z","2020-12-03T18:42:42Z"
"","26422","Unwrap DataSource hidden behind InfrastructureProxy in SqlScriptsTestExecutionListener","in method `SqlScriptsTestExecutionListener.executeSqlScripts(...)`, around line 213, the following code resides:  ```java DataSource dataSourceFromTxMgr = getDataSourceFromTransactionManager(txMgr); // Ensure user configured an appropriate DataSource/TransactionManager pair. if (dataSource != null && dataSourceFromTxMgr != null && !dataSource.equals(dataSourceFromTxMgr)) {     throw new IllegalStateException(String.format(""Failed to execute SQL scripts for test context %s: "" +           ""the configured DataSource [%s] (named '%s') is not the one associated with "" +           ""transaction manager [%s] (named '%s')."", testContext, dataSource.getClass().getName(),            dsName, txMgr.getClass().getName(), tmName)); } ```  This seems to contradict the logic used in `DataSourceUtils` which handles such equality checks taking into account that a `DataSource` may be an implementation of `InfrastrutureProxy`.  We have a setup where the `DataSource` in the Spring context is directly the database `DataSource` (well, it is pooled), while the `DataSource` given to the `DataSourceTransactionManager` is a wrapped version. However, the wrapping class implements `InfrastructureProxy`, which ensures that all Spring JDBC stuff - which utilizes the `DataSourceUtils` class to fetch (and release) Connections - actually handles this perfectly: Even though e.g. the `JdbcTemplate` has gotten the ""plain"" `DataSource`, while, again, the TxMgr has the wrapped `DataSource`, when in a Spring managed Transaction, the `JdbcTemplate` ends up with Connections from the _wrapped_ `DataSource` (in the `DataSourceTransactionManager`) due to the logic wrt. `InfrastructureProxy` in `DataSourceUtils`.  However, this is not the case in `SqlScriptsTestExecutionListener`, due to the much plainer `.equals(..)` check being performed there. Basically, had the check not been there, it would have worked. Also, had the check taken into account the `InfrastructureProxy` logic, it would also have worked.  (And, due to the equality being checked is `dataSourceFromSpringContext.equals(dataSourceFromTxMgr)` - and not the other way around - I cannot hack this to work either. The only way around that would be to also wrap the `DataSource` in the Spring context too (to trick the `.equals(..)`) - in which case I could just as well put the same `DataSource` in Spring context as the one given to the `DataSourceTransactionManager`, which of course would fix this. However, the problem is that these two are handled in different code bases, and it is not always the situation that we want to do that wrapping of the `DataSource` given to the `DataSourceTransactionManager`.).","closed","type: enhancement,","stolsvik","2021-01-21T11:15:10Z","2021-01-24T13:15:31Z"
"","26579","Log level for SingleConnectionFactory.onException() callback should be WARN or ERROR","In current version log level  for SingleConnectionFactory.onException() callback is INFO.  https://github.com/spring-projects/spring-framework/blob/274db2f7a934c1558eee25809ceab3982ab73e1c/spring-jms/src/main/java/org/springframework/jms/connection/SingleConnectionFactory.java#L367  Maybe change the logging level to WARN or ERROR?","open","in: messaging,","Evgen1000end","2021-02-21T07:00:12Z","2021-11-10T11:41:09Z"
"","25938","Introduce RouterFunction attributes","In an issue discussion over at springdoc (see https://github.com/springdoc/springdoc-openapi/issues/891, it has shown useful to let router functions have attributes, so that each route can be assigned additional metadata.  This issue will add methods to `RouterFunction` to add individual as well groups of attributes, and introduce a similar mechanism in the `RouterFunctionBuilder`.","closed","type: enhancement,","poutsma","2020-10-19T12:45:57Z","2020-10-23T13:00:22Z"
"","25933","Spring-Aspects: @Configurable declare parents have non reproducible builds","In an attempt to make our builds reproducible, I noticed that this declare parents seem to apply in different orders, resulting in different bytecode. There are 3 declare parents (including the parent class) involved around @Configurable and seem to be applied in different orders. It seems to me since Interfaces can have static state with initialisers aspectJ cannot reorder them. Therefore the declare parents must be written in a way that the order is defined. The exact root cause is not quite clear to me, if someone could enlighten me, thank you.  Sample project here: https://github.com/ls-urs-keller/spring-aspects-reproducible-build Run `./test.sh` add the root of the project, it will repeat building the project until the resulting bytecode differs.  You should see something like:  ``` run 11 [INFO] Scanning for projects... [INFO] [INFO] ----------------------< org.example:aspectj-test >---------------------- [INFO] Building aspectj-test 1.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ aspectj-test --- [INFO] Deleting /project/target [INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ aspectj-test --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] skip non existing resourceDirectory /project/src/main/resources [INFO] [INFO] --- aspectj-maven-plugin:1.12.1:compile (ajc-compile) @ aspectj-test --- [INFO] Showing AJC message detail for messages of types: [error, warning, fail] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time:  10.303 s [INFO] Finished at: 2020-10-19T07:36:43Z [INFO] ------------------------------------------------------------------------ Binary files target/classes/com/example/Operation.class and classes/com/example/Operation.class differ diff -r target/classes/com/example/Operation.javap classes/com/example/Operation.javap 2c2 < public abstract class com.example.Operation implements java.io.Serializable,org.springframework.beans.factory.aspectj.AbstractInterfaceDrivenDependencyInjectionAspect$ConfigurableDeserializationSupport,org.springframework.beans.factory.aspectj.ConfigurableObject { --- > public abstract class com.example.Operation implements java.io.Serializable,org.springframework.beans.factory.aspectj.ConfigurableObject,org.springframework.beans.factory.aspectj.AbstractInterfaceDrivenDependencyInjectionAspect$ConfigurableDeserializationSupport {  ```","open","in: core,","ls-urs-keller","2020-10-19T07:45:49Z","2021-11-10T09:51:28Z"
"","26210","Subscriber context not propagated to WebSocketHandler for Tomcat websockets","In a WebFlux application that uses Tomcat as the webserver, the reactor subscriber context is not currently propagated from WebFilters down to WebSocketHandlers.   Therefore objects put into the subscriber context (such as the spring security context) by WebFilters are not available to WebSocketHandlers.  For comparison, when reactor-netty is used as the webserver, the reactor subscriber context _is_ propagated from WebFilters to WebSocketHandlers properly.  I have a WebSocketHandler that needs to access the spring security context.  Unfortunately, this is not currently possible when using tomcat as the webserver.   The disconnect occurs between `TomcatRequestUpgradeStrategy` and `StandardWebSocketHandlerAdapter`...  1. `TomcatRequestUpgradeStrategy.upgrade` constructs a `StandardWebSocketHandlerAdapter` and delegates to the container's websocket upgrade logic  (see [here](https://github.com/spring-projects/spring-framework/blob/8ac39a50feda71194e33a456c0f8207169a5a3a9/spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/TomcatRequestUpgradeStrategy.java#L140-L152)).  The context is lost at this point. 2. The container performs the websocket upgrade and calls into `StandardWebSocketHandlerAdapter.onOpen`. 3. `StandardWebSocketHandlerAdapter.onOpen` then delegates to `WebSocketHandler.handle` (see [here](https://github.com/spring-projects/spring-framework/blob/8ac39a50feda71194e33a456c0f8207169a5a3a9/spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/StandardWebSocketHandlerAdapter.java#L84-L86)).  I need access to items in the subscriber context within a`WebSocketHandler`, but the context is empty.  To propagate the context, I believe `TomcatRequestUpgradeStrategy.upgrade` could pass the active context to the `StandardWebSocketHandlerAdapter` upon construction (during step 1 above). Then `StandardWebSocketHandlerAdapter.onOpen` could pass the context to the handler stream (during step 3 above).","closed","type: enhancement,","philsttr","2020-12-03T20:22:13Z","2020-12-15T21:39:57Z"
"","26425","Fail early FactoryBean instantiation for LinkageError","In 0288878 to resolve gh-22409, a little bug was introduced: if there is LinkageError in FactoryBean instantiation, no first exception.  In JVM, if a class cannot be initialized, it acts like this: - at the first time, it will show the real reason and stack - then, only show ""NoClassDefFoundError: Could not initialize class xxx""","closed","type: enhancement,","liudongmiao","2021-01-21T18:51:52Z","2021-11-08T09:16:15Z"
"","26875","Use an import instead of FQCN in StaxEventXMLReader","In #1927, `handleDtd()` was modified but `handleDtd(Dtd dtd)` was not. I changed not to use FQCN in the latter method.","closed","type: task,","T45K","2021-04-29T10:35:19Z","2021-04-29T15:59:47Z"
"","26172","Update AbstractAutowireCapableBeanFactory.java","improve code quality","closed","in: core,","mymailmjj","2020-11-28T02:25:57Z","2021-12-10T23:10:06Z"
"","26345","Difficutly building source code in IntelliJ","Import the project into IDEA, and this is the result of Gradle's compilation.  - idea 2019.3 - jdk14 - spring-framework-5.3.2 - gradle-6.7.1  ``` exception during working with external system: java.lang.AssertionError 	at org.jetbrains.plugins.gradle.service.project.BaseGradleProjectResolverExtension.createModule(BaseGradleProjectResolverExtension.java:154) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.kotlin.idea.configuration.KotlinMPPGradleProjectResolver.createModule(KotlinMPPGradleProjectResolver.kt:67) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at com.android.tools.idea.gradle.project.sync.idea.AndroidGradleProjectResolver.createModule(AndroidGradleProjectResolver.java:165) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.kotlin.android.configure.KotlinAndroidMPPGradleProjectResolver.createModule(KotlinAndroidMPPGradleProjectResolver.kt:45) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.AbstractProjectResolverExtension.createModule(AbstractProjectResolverExtension.java:86) 	at org.jetbrains.plugins.gradle.service.project.TracedProjectResolverExtension.createModule(TracedProjectResolverExtension.java:45) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.doResolveProjectInfo(GradleProjectResolver.java:344) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.access$200(GradleProjectResolver.java:60) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver$ProjectConnectionDataNodeFunction.fun(GradleProjectResolver.java:725) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver$ProjectConnectionDataNodeFunction.fun(GradleProjectResolver.java:708) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.execute(GradleExecutionHelper.java:278) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.resolveProjectInfo(GradleProjectResolver.java:125) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.resolveProjectInfo(GradleProjectResolver.java:60) 	at com.intellij.openapi.externalSystem.service.remote.RemoteExternalSystemProjectResolverImpl.lambda$resolveProjectInfo$0(RemoteExternalSystemProjectResolverImpl.java:35) 	at com.intellij.openapi.externalSystem.service.remote.AbstractRemoteExternalSystemService.execute(AbstractRemoteExternalSystemService.java:57) 	at com.intellij.openapi.externalSystem.service.remote.RemoteExternalSystemProjectResolverImpl.resolveProjectInfo(RemoteExternalSystemProjectResolverImpl.java:35) 	at com.intellij.openapi.externalSystem.service.remote.wrapper.ExternalSystemProjectResolverWrapper.resolveProjectInfo(ExternalSystemProjectResolverWrapper.java:44) 	at com.intellij.openapi.externalSystem.service.internal.ExternalSystemResolveProjectTask.doExecute(ExternalSystemResolveProjectTask.java:100) 	at com.intellij.openapi.externalSystem.service.internal.AbstractExternalSystemTask.execute(AbstractExternalSystemTask.java:146) 	at com.intellij.openapi.externalSystem.service.internal.AbstractExternalSystemTask.execute(AbstractExternalSystemTask.java:132) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$3.executeImpl(ExternalSystemUtil.java:540) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$3.lambda$execute$1(ExternalSystemUtil.java:392) 	at com.intellij.openapi.project.DumbServiceImpl.suspendIndexingAndRun(DumbServiceImpl.java:150) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$3.execute(ExternalSystemUtil.java:392) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$5.run(ExternalSystemUtil.java:647) 	at com.intellij.openapi.progress.impl.CoreProgressManager$TaskRunnable.run(CoreProgressManager.java:888) 	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$2(CoreProgressManager.java:163) 	at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:585) 	at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:531) 	at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:59) 	at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:150) 	at com.intellij.openapi.progress.impl.CoreProgressManager$4.lambda$run$0(CoreProgressManager.java:402) 	at com.intellij.util.ConcurrencyUtil.runUnderThreadName(ConcurrencyUtil.java:221) 	at com.intellij.openapi.progress.impl.CoreProgressManager$4.run(CoreProgressManager.java:402) 	at com.intellij.openapi.application.impl.ApplicationImpl$1.run(ApplicationImpl.java:238) 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","status: feedback-provided,","yuyu414","2021-01-05T13:57:20Z","2021-04-27T11:25:50Z"
"","26730","Unable to add response headers in functional endpoint filters without deleting body","If you setup functional endpoints as described [in the documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn-handler-filter-function), like so:  ```kotlin val route = router {     ""/person"".nest {         GET(""/{id}"", handler::getPerson)         GET("""", handler::listPeople)         POST(""/person"", handler::createPerson)     } } ```  ... then you try to add a response header of `X-My-Response-Header` with a value of `foo` to these routes using `filter` or `after`, like so:  ```kotlin val route = router {     ""/person"".nest {         GET(""/{id}"", handler::getPerson)         GET("""", handler::listPeople)         POST(""/person"", handler::createPerson)         after { request, response -> ServerResponse.from(response).header(""X-My-Response-Header"", ""foo"").build() }     } } ```  ... you'll notice your header gets added, but your body is gone. This is because [`ServerResponse.from()`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html#from-org.springframework.web.reactive.function.server.ServerResponse-) doesn't copy the body, only the status code and responses. From [the docs](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html#from-org.springframework.web.reactive.function.server.ServerResponse-):  > Create a builder with the status code and headers of the given response.  So say you eschew immutability and you try to mutate it:  ```kotlin val route = router {     ""/person"".nest {         GET(""/{id}"", handler::getPerson)         GET("""", handler::listPeople)         POST(""/person"", handler::createPerson)         after { request, response -> response.headers().set(""X-My-Response-Header"", ""foo""); response }     } } ```  ... this will throw an exception. That's because `ServerResponse` is (rightly) immutable and uses [`ReadOnlyHttpHeaders`](https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE_to_5.1.5.RELEASE/Spring%20Framework%205.1.5.RELEASE/org/springframework/http/ReadOnlyHttpHeaders.html), and that implementation of `HttpHeaders` will (rightly) throw an exception if you attempt to modify it in any way.  The combination of these two limitations means you cannot add a response header in filters because: 1. You can't create a new `ServerResponse` with the new header and fetch the body of the previous `ServerResponses` intact (outside of [some extreme measures](https://stackoverflow.com/a/63164161/735679)). 2. You can't mutate the existing `ServerResponse` to have the new header.","closed","status: invalid,","carusology","2021-03-25T19:48:12Z","2021-04-01T08:48:17Z"
"","25981","@Nonnull annotation breaks ServletRequestMethodArgumentResolver for Principal","If you have something like:   ```java @GetMapping(""/foo"") public ResponseEntity method(@Nonnull Principal principal) {     return ResponseEntity.ok(""bar""); } ```  `ServletRequestMethodArgumentResolver` will fail to resolve the principal parameter because there's some annotation on it.   I think this is a regression introduced by #19779","closed","type: regression,","rcaspar","2020-10-28T10:48:21Z","2020-10-29T21:31:25Z"
"","26264","AntPathPatternMatcher hardcoded ""/"" separator in variables glob","If you don't use the default separator, ""/"" should not be special:  ``` jshell> new AntPathMatcher(""\0"").extractUriTemplateVariables(""tot{;}"", ""totoa""); $11 ==> {;=oa} ```  ``` jshell> new AntPathMatcher(""\0"").extractUriTemplateVariables(""tot{/}"", ""totoa""); |  Exception java.lang.IllegalStateException: Pattern ""tot{/}"" is not a match for ""totoa"" |        at AntPathMatcher.extractUriTemplateVariables (AntPathMatcher.java:516) |        at (#12:1) ``` Expected {/=oa}  note: the previous example is treated as an exact match: ``` jshell> new AntPathMatcher(""\0"").extractUriTemplateVariables(""tot{/}"", ""tot{/}""); $19 ==> {} ```   See https://github.com/spring-projects/spring-framework/blob/17e6cf1cc1b57bd65bfae8da8cddc8314a89408d/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java#L645 there are slashes hardcoded in there","open","in: core,","jonenst","2020-12-14T11:09:03Z","2021-11-10T12:15:45Z"
"","26384","Register new Synchronization (via TransactionSynchronizationManager.registerSynchronization) within afterCommit() does not work","If we register another synchronization within `registerSynchronization.afterCommit()`, the new sync do not take effect.    Another issue is that the result of `TransactionSynchronizationManager.isActualTransactionActive()` is still `True`, however, the trx should be completed during `afterCommit()`  ``` java     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {             @Override             public void afterCommit() {                 Log.info(""sync alive {}, trx alive {}"", TransactionSynchronizationManager.isSynchronizationActive(),                         TransactionSynchronizationManager.isActualTransactionActive());                  // XXX: could we check this, and not allow it?                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                     @Override                     public void afterCommit() {                         System.out.println(""Should never reach here"");  // XXX: Not work                     }                 });             }     }); ```  This is because it use a snapshot list of all registered syncs, not including the newly added one during executing `triggerAfterCommit()` within `AbstractPlatformTransactionManager.processCommit()`. The below show the related source code in spring framework.  ``` java         private void triggerAfterCommit(DefaultTransactionStatus status) { 		if (status.isNewSynchronization()) { 			if (status.isDebug()) { 				logger.trace(""Triggering afterCommit synchronization""); 			} 			TransactionSynchronizationUtils.triggerAfterCommit();    // <--- 1 		} 	}         public static void triggerAfterCommit() { 		invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());  // <---- 2 	}         /** 	 * Return an unmodifiable snapshot list of all registered synchronizations 	 * for the current thread. 	 * @return unmodifiable List of TransactionSynchronization instances 	 * @throws IllegalStateException if synchronization is not active 	 * @see TransactionSynchronization 	 */ 	public static List getSynchronizations() throws IllegalStateException { 		Set synchs = synchronizations.get(); 		if (synchs == null) { 			throw new IllegalStateException(""Transaction synchronization is not active""); 		} 		// Return unmodifiable snapshot, to avoid ConcurrentModificationExceptions 		// while iterating and invoking synchronization callbacks that in turn 		// might register further synchronizations. 		if (synchs.isEmpty()) { 			return Collections.emptyList(); 		} 		else { 			// Sort lazily here, not in registerSynchronization. 			List sortedSynchs = new ArrayList<>(synchs); 			AnnotationAwareOrderComparator.sort(sortedSynchs); 			return Collections.unmodifiableList(sortedSynchs);      // <------ 3 		} 	} ```  We expect that we could raise an exception for the second register inside `afterCommit()` or similar methods","open","in: data,","jackyfkc","2021-01-14T10:07:42Z","2021-11-10T12:13:43Z"
"","26720","MockMvcClientHttpRequestFactory swallows ServletResponse.errorMessage","If there was an error while processing a request, `MockHttpServletResponse.sendError(int status, String errorMessage)` only sets `this.errorMessage` and does not write to `this.content`. Conversely, MockMvcClientHttpRequestFactory only reads `servletResponse.content` and ignores the error message.  This results in error response bodies being swallowed in mockMVC tests which use `RestTemplate` with `MockMvcClientHttpRequestFactory`.  So, either MockHttpServletResponse.sendError() should write to the outputstream or MockMvcClientHttpRequestFactory should read something like ""errorMessage or if null the content byte array"".","open","in: test,","gnagy","2021-03-24T13:59:36Z","2021-11-10T11:50:24Z"
"","26700","Apply dynamic changes in ThreadPoolTaskExecutor before setting local value","If the ThreadPoolTaskExecutor is dynamically changed with an invalid value the state of the ThreadPoolTaskExecutor does no longer correctly represent the state of the underlying ThreadPoolExecutor","closed","type: enhancement,","filiphr","2021-03-18T15:26:43Z","2021-07-09T13:10:55Z"
"","26098","Simplify AstUtils.getPropertyAccessorsToTry()","If the `index` is always `list.length() - 1` we can drop it, as the object passed into `list.add()` is always the last one inserted.","closed","in: core,","stsypanov","2020-11-16T14:07:56Z","2020-11-19T15:27:11Z"
"","25882","main webserver path from UrlPathHelper","If my absolute path in `HttpServletRequest` is `http://localhost:8080/my-app/sub/servlet/path`, I would want to extract only `http://localhost:8080/` (means  schema + domain + port). I don't know the exact naming for this part combination.  There is `org.springframework.web.util.UrlPathHelper` for all sort of extracting parts of the url, but this is missing. Maybe (to complete the helper methods), you could add something similar:  ``` 	/** 	 * Example 	 * requestURL: http://localhost:8080/my-app/sub/servlet/path 	 * requestURI: /my-app/sub/servlet/path 	 * @return http://localhost:8080 	 */ 	public static String getWebserverPath(HttpServletRequest req) { 		return StringUtils.substringBefore(req.getRequestURL().toString(), req.getRequestURI()); 	} ```","closed","status: declined,","membersound","2020-10-08T09:01:41Z","2020-10-21T15:04:04Z"
"","26276","Translate PostgreSQL code 21000 (cardinality_violation)","If duplicate keys are used in a single upsert (`ON CONFLICT DO UPDATE`) statement, then postgres returns a cardinality violation error.  There are some options to translate it:  - `UncategorizedSQLException` (current)  - `DuplicateKeyException`  - `DataIntegrityViolationException`  - a new `CardinalityViolationException` somewhere in the inheritance tree  I'm currently overriding `sql-error-codes.xml` in order to return a `DuplicateKeyException`, as the user cause and exception handling are the same.","closed","type: enhancement,","OrangeDog","2020-12-15T11:55:04Z","2020-12-17T12:43:10Z"
"","26701","Append ""*/*"" To The defaultContentTypes List","If a default content type is set in the ContentNegotiationConfigurer, endpoints that don't return that type can return a 406.  I've attached a very simple example.  [demo.zip](https://github.com/spring-projects/spring-framework/files/6165595/demo.zip)  **Bug Explanation:** For an endpoint that produces some other content type (example in attached code is text/plain):  - Making a request without an Accept header will result in a 406 - Making a request with an Accept header of '\*/\*' will result in a 406 - Making a request with an Accept header of 'garbage/garbage,\*/\*' will result in 200  This behavior is wrong -- All of these should return a 200.  Setting a default content type should not cause endpoints to result in 406.  At a minimum, accept headers of 'garbage/garbage,\*/\*' and '\*/\*' should behave the same..  **Extra explanation** Why are we setting a default content type?  Because for nearly all endpoints, we want the returned content to be available as XML or JSON, and default to JSON if nothing else is specified.","open","type: enhancement,","cgroneman","2021-03-18T16:22:46Z","2021-03-24T17:38:19Z"
"","26605","Add more message when throw TypeMismatchException  in webMVC","If a client sends a request with parameter not matching the endpoints parameter type,there will throw TypeMismatchException . ``` @RestController public class DemoController {  	@GetMapping(""/test"") 	public String demo(Long id) {  		return ""success""; 	} ```   clients send requests to the ""/test?id=undefined"" .  error logs : ``` org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: ""undefined"" 	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:133) ~[spring-web-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]  ```  According to this log, I can't locate which requestMpping is the problem.  what I expecting in logs:  `at class DemoController.demo,Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: ""undefined""`","closed","","lutongzero","2021-02-25T07:14:54Z","2021-03-11T10:43:03Z"
"","26304","ClassCastException during websocket upgrade for mutated request","If a `WebFilter` mutates an inbound request, then the tomcat/jetty/undertow websocket request upgrade strategies throw a `ClassCastException`, which results in an HTTP 500 error being returned for the websocket upgrade request.  For example, consider the following simple filter that mutates a request...  ```java 	@Bean 	WebFilter webFilter() { 		return (exchange, chain) -> chain.filter(exchange.mutate() 				// Any mutation of the request will cause an exception during the websocket handshake 				.request(exchange.getRequest().mutate() 						.headers(headers -> headers.set(""ExampleHeader"", ""ExampleHeaderValue"")) 						.build()) 				.build()); 	} ```  And this simple websocket handler...  ```java 	@Bean 	HandlerMapping handlerMapping() { 		return new SimpleUrlHandlerMapping( 				Map.of(""/ws"", (WebSocketHandler) (session -> Mono.empty())), 				-1); 	} ```  When an request is made to the websocket endpoint, the websocket upgrade request will fail.   The server side receives this exception:  ``` 2020-12-20 12:21:49.203 ERROR 12488 --- [o-auto-1-exec-1] a.w.r.e.AbstractErrorWebExceptionHandler : [6a9e2e7a]  500 Server Error for HTTP GET ""/ws""  java.lang.ClassCastException: class org.springframework.http.server.reactive.TomcatHttpHandlerAdapter$TomcatServerHttpRequest cannot be cast to class javax.servlet.http.HttpServletRequest (org.springframework.http.server.reactive.TomcatHttpHandlerAdapter$TomcatServerHttpRequest and javax.servlet.http.HttpServletRequest are in unnamed module of loader 'app') 	at org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy.getNativeRequest(TomcatRequestUpgradeStrategy.java:159) ~[spring-webflux-5.3.2.jar:5.3.2] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ com.example.mutatedwebsocketupgradefailure.MutatedWebsocketUpgradeFailureApplication$$Lambda$747/0x0000000800436840 [DefaultWebFilterChain] 	|_ checkpoint ⇢ HTTP GET ""/ws"" [ExceptionHandlingWebHandler] Stack trace: 		at org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy.getNativeRequest(TomcatRequestUpgradeStrategy.java:159) ~[spring-webflux-5.3.2.jar:5.3.2] 		at org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy.upgrade(TomcatRequestUpgradeStrategy.java:134) ~[spring-webflux-5.3.2.jar:5.3.2] 		at org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService.lambda$handleRequest$1(HandshakeWebSocketService.java:235) ~[spring-webflux-5.3.2.jar:5.3.2] ```  The problem is that [`*RequestUpgradeStrategy.getNativeRequest`](https://github.com/spring-projects/spring-framework/blob/v5.3.2/spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/TomcatRequestUpgradeStrategy.java#L159) incorrectly assumes that `((AbstractServerHttpRequest) request).getNativeRequest()` returns an `HttpServletRequest`.  For mutated requests, the value returned will be the `ServerHttpRequest` before mutation, not a `HttpServletRequest`.  One naïve solution is to make the `*RequestUpgradeStrategy.getNativeRequest` methods recursively search through the mutated requests to find the real underlying native request....  ```java 	private static HttpServletRequest getNativeRequest(ServerHttpRequest request) { 		if (request instanceof AbstractServerHttpRequest) { 			Object nativeRequest = ((AbstractServerHttpRequest) request).getNativeRequest(); 			if (nativeRequest instanceof HttpServletRequest) { 				return (HttpServletRequest) nativeRequest; 			} else if (nativeRequest instanceof ServerHttpRequest) { 				return getNativeRequest((ServerHttpRequest) nativeRequest); 			} 			else { 				throw new IllegalArgumentException( 						""Couldn't find HttpServletRequest in "" + request.getClass().getName()); 			} 		} 		else if (request instanceof ServerHttpRequestDecorator) { 			return getNativeRequest(((ServerHttpRequestDecorator) request).getDelegate()); 		} 		else { 			throw new IllegalArgumentException( 					""Couldn't find HttpServletRequest in "" + request.getClass().getName()); 		} 	} ```  I only tested on tomcat, but from looking at the code, it probably affects tomcat, jetty, and undertow.  Also a similar recursive search might be needed for `getNativeResponse` (not sure?)  Here is an example application and unit test that demonstrates the problem: [mutated-websocket-upgrade-failure.zip](https://github.com/spring-projects/spring-framework/files/5721482/mutated-websocket-upgrade-failure.zip)","closed","type: bug,","philsttr","2020-12-20T20:50:52Z","2021-01-04T22:18:23Z"
"","25978","Support fetching request body of Webflux ExchangeFilterFunction.ofRequestProcessor","I've read the closed issue https://github.com/spring-projects/spring-framework/issues/24262 but did not get the reply.  The problem is that ExchangeFilterFunction.ofRequestProcessor ClientRequset.body is BodyInserter,   But I need to fetch the body as a String/JSON.  Basically, I managed to access the body using ClientHttpRequestDecorator, but headers are empty.  ``` public class SigningClientHttpRequestDecorator extends ClientHttpRequestDecorator {      public SigningClientHttpRequestDecorator(ClientHttpRequest delegate) {         super(delegate);     }      @Override     public Mono writeWith(Publisher body) {         Mono buffer = Mono.from(body);         return super.writeWith(buffer.doOnNext(dataBuffer -> {             try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {                 Channels.newChannel(baos).write(dataBuffer.asByteBuffer().asReadOnlyBuffer());                 Instant now = Instant.now();                 String encodedSign = SignUtil.signRequest(now, baos.toByteArray());                 super.getHeaders().set(""testHeader"", encodedSign);             } catch (Exception e) {                 e.printStackTrace();                 throw new BlackboxResponseFilterException(""Error applying filter to response"");             }         }));     } } ``` ``` public class SignClientHttpConnectorDecorator implements ClientHttpConnector {      private final ClientHttpConnector delegate;      public SignClientHttpConnectorDecorator(ClientHttpConnector delegate) {         this.delegate = delegate;     }      @Override     public Mono connect(HttpMethod httpMethod,                                             URI uri,                                             Function> callback) {         return this.delegate.connect(httpMethod, uri, clientHttpRequest -> callback.apply(new SigningClientHttpRequestDecorator(clientHttpRequest)));     } } ``` I am trying to set custom header, but super.getHeaders() returns empty result and they are read only, how can I set headers ? Here is how I set connector  ``` HttpClient client = HttpClient.create(); //do some ssl stuff with client ReactorClientHttpConnector connector = new ReactorClientHttpConnector(client);         return WebClient.builder().clientConnector(new SignClientHttpConnectorDecorator(connector)).build();  ```","closed","for: stackoverflow,","toxakktl","2020-10-27T10:58:27Z","2020-10-29T10:56:21Z"
"","26628","JdbcTemplate.queryFor*(...) methods use Statement instead of PreparedStatement","I've just checked JDBCTemplate and found out that all the ```queryFor...``` method without params use Statement instead of PreparedStatement. I think using PreparedStatement even if the query doesn't have any parameters still benefits if the query is being called multiple times. So is there any way to use ```queryFor...``` with PreparedStatement instead of Statement.","closed","status: invalid,","cdxf","2021-03-02T16:37:53Z","2021-03-03T12:19:37Z"
"","26190","@Modifing not supported by vavr integration","I'm working with **spring-boot 2.3.5.RELEASE** and **vavr 0.10.3** and I have this error when I try to invoke the method `disableEnabledCredentials()` defined in this way:  ``` public interface ICredentialDAO extends Repository {      @Modifying     @Query(""update Credential d set d.enabled = false where d.enabled = true"")     Try disableEnabledCredentials();      Option findByEnabled(boolean enabled);      Try save(Credential credential);  } ```  Error: ""Modifying queries can only use void or int/Integer as return type!""; nested exception is java.lang.IllegalArgumentException: Modifying queries can only use void or int/Integer as return type!  I know that vavr is supported by spring-data-jpa because I has using this features in other methods as `findByEnabled()` or `save()`.   The support by vavr should't include @Modifying allowing return of  Try or Try?  My pom includes: ```                2.3.5.RELEASE                                              org.springframework.boot                 spring-boot-dependencies                 ${spring-boot-dependencies.version}                 pom                 import                                                   org.springframework.boot             spring-boot-starter-web                                                   org.springframework.boot                     spring-boot-starter-tomcat                                                             org.springframework.boot             spring-boot-starter-undertow                               org.springframework.boot             spring-boot-starter-actuator                               org.springframework.boot             spring-boot-starter-data-jpa                               io.vavr             vavr             0.10.3          ```","closed","for: external-project,","jbochard","2020-12-01T15:28:55Z","2020-12-05T13:55:13Z"
"","26160","JSON query parameter fail to be handled in reactive WebClient","I'm using the reactive WebClient from spring-webflux (version 5.2.0) within code generated from an OpenAPI specification to fire HTTP requests against an API.  This API uses JSON in query parameters. When this query parameter gets expanded by UriComponents, the curly braces are erroneously interpreted as template placeholder, but no corresponding template variable can be found (obviously), leading to an IllegalArgumentException.  I prepared a piece of code to reproduce the issue:  ``` import java.util.*; import org.springframework.http.HttpMethod; import org.springframework.util.LinkedMultiValueMap; import org.springframework.util.MultiValueMap; import org.springframework.web.reactive.function.client.WebClient; import org.springframework.web.util.UriComponentsBuilder;  class Scratch { 	public static void main(String[] args) { 		final UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(""http://localhost:80/"").path(""/{id}/generate""); 		MultiValueMap params = new LinkedMultiValueMap<>(); 		params.add(""myjson"", ""{\""key\"":\""value\""}""); 		builder.queryParams(params); 		Map pathParams = new HashMap<>(); 		pathParams.put(""id"", 123L); 		WebClient.create() 				.method(HttpMethod.GET) 				.uri(builder.build(false).toUriString(), pathParams);  	} } ```  This leads to:  ``` Exception in thread ""main"" java.lang.IllegalArgumentException: Map has no value for '""key""' 	at org.springframework.web.util.UriComponents$MapTemplateVariables.getValue(UriComponents.java:345) 	at org.springframework.web.util.HierarchicalUriComponents$QueryUriTemplateVariables.getValue(HierarchicalUriComponents.java:1053) 	at org.springframework.web.util.UriComponents.expandUriComponent(UriComponents.java:262) 	at org.springframework.web.util.HierarchicalUriComponents.lambda$expandQueryParams$5(HierarchicalUriComponents.java:445) 	at java.base/java.util.Map.forEach(Map.java:661) 	at org.springframework.web.util.HierarchicalUriComponents.expandQueryParams(HierarchicalUriComponents.java:441) 	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:430) 	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:51) 	at org.springframework.web.util.UriComponents.expand(UriComponents.java:161) 	at org.springframework.web.util.DefaultUriBuilderFactory$DefaultUriBuilder.build(DefaultUriBuilderFactory.java:380) 	at org.springframework.web.util.DefaultUriBuilderFactory.expand(DefaultUriBuilderFactory.java:200) 	at org.springframework.web.reactive.function.client.DefaultWebClient$DefaultRequestBodyUriSpec.uri(DefaultWebClient.java:182) 	at org.springframework.web.reactive.function.client.DefaultWebClient$DefaultRequestBodyUriSpec.uri(DefaultWebClient.java:151) 	at Scratch.main(scratch_7.java:20) ```  I'd like to use the UriComponentsBuilder to handle all the encoding details, but I actually don't want it to do any expanding on query parameter values.","closed","","pravussum","2020-11-26T17:12:50Z","2020-12-31T16:31:58Z"
"","26500","RequestEntity throws UnsupportedOperationException when using URI template","I'm using Spring Web 5.3.3 with Boot 2.4.2.  When creating a `RequestEntity` by passing in a URI template, the concrete type created is a `UriTemplateRequestEntity`, which through its `super` chain sets `this.url = null`. Later, when the `RequestEntity` is passed to `RestTemplate#exchange(RequestEntity, Class)`, the template calls `RequestEntity#getUrl`. As `UriTemplateRequestEntity` does not override `getUrl`, this throws because `this.url == null`.  Expected use case: ```java var req = RequestEntity.get(""http://localhost/helloworld"").build(); var body = restTemplate.exchange(req, String.class); ```  It appears that what's happening is that the `UriTemplateRequestEntity`'s templating methods are bypassed in the simple `exchange` flow. While I'm sure that the expectation was that the style above would be used with URI variables, the fact that it throws an obscure exception is Surprising. Instead, I suggest that `UriTemplateRequestEntity`'s `getUrl` should be overridden, simply returning the string if it is untemplated and possibly throwing an informative exception if it can't be filled out.","closed","for: external-project,","chrylis","2021-02-03T07:17:09Z","2021-02-04T18:11:11Z"
"","26795","MvcUriComponentsBuilder does not resolve property placeholders","I'm using Spring Framework 5.3.4 with Spring Boot 2.4.3.  I have a controller declared in this way:  ```java @Controller @RequestMapping(""${saml.sp.controller-base-mapping}"") public class ServiceProviderController {   /... } ``` So, the property `saml.sp.controller-base-mapping` is externalized in `application.properties` file: if its value is `sp`, this should be equivalent to: `@RequestMapping(""sp"")`. And indeed Spring Web MVC handles this well.  However, if I then use `MvcUriComponentsBuilder` to retrieve the corresponding URL:  ```java MvcUriComponentsBuilder.fromController(ServiceProviderController.class).build().toURL(); ```  This returns a `UriComponents` of: `http://localhost:8081/${saml.sp.controller-base-mapping}`  First problem: I would have expected the externalized property to be already resolved (so to get `http://localhost:8081/sp`), because this should be an expansion mechanism that comes BEFORE path variable expansion.  Indeed (and here comes the second problem), if I try to do:  ```java MvcUriComponentsBuilder.fromController(ServiceProviderController.class).buildAndExpand(""sp""); ```  I then get a `UriComponents` of: `http://localhost:8081/$sp`  This is somewhat expected, since path variable expansion is another story and does not use the ""$"" marker.","open","type: enhancement,","mauromol","2021-04-13T11:09:53Z","2021-05-09T11:22:46Z"
"","26032","NamedParameterJdbcTemplate broken in Spring Boot 2.3.5","I'm using Spring Boot 2.3.5 release which looks to be on Spring Framework 5.2.10.  In NamedParameterJdbcTemplate, you have:  ``` 	private volatile ConcurrentLruCache parsedSqlCache = 			new ConcurrentLruCache<>(DEFAULT_CACHE_LIMIT, NamedParameterUtils::parseSqlStatement);  ```  Imported as `org.springframework.util.ConcurrentLruCache`  Eclipse shows that ConcurrentLruCache is now a private static class in MimeTypeUtils. This breaks a lot of stuff.","closed","status: waiting-for-feedback,","SledgeHammer01","2020-11-04T16:52:04Z","2022-02-18T19:06:33Z"
"","26655","Jaxb2XmlEncoder Support for Custom XML Media Types","I'm trying to use WebClient with custom media types and found that the Jaxb2XmlEncoder only supports application/xml and text/xml media. Is it possible to have it support ""*+xml"", and/or have a way to customize  the types it supports?   Jaxb2XmlDecoder supports ""*+xml"" and also exposes a constructor where we can provide our own media types, but for some reason the Encoder doesn't.   Thanks for having a look.","closed","type: bug,","jiantosca","2021-03-09T16:20:33Z","2021-03-10T20:41:38Z"
"","26829","RSocket (Kotlin) Fire and Forget - Missing 'rsocketResponse'","I'm trying to make example chat application and I'm getting strange error when using fire-and-forget from my ReactJs rsocket-websocket-client.  Error:  ``` java.lang.IllegalArgumentException: Missing 'rsocketResponse' 	at org.springframework.util.Assert.notNull(Assert.java:201) ~[spring-core-5.3.6.jar:5.3.6] 	at org.springframework.messaging.rsocket.annotation.support.RSocketPayloadReturnValueHandler.handleEncodedContent(RSocketPayloadReturnValueHandler.java:64) ~[spring-messaging-5.3.6.jar:5.3.6] 	at org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler.lambda$handleReturnValue$0(AbstractEncoderMethodReturnValueHandler.java:121) ~[spring-messaging-5.3.6.jar:5.3.6] 	at org.springframework.messaging.handler.invocation.reactive.ChannelSendOperator$WriteBarrier.onComplete(ChannelSendOperator.java:251) ~[spring-messaging-5.3.6.jar:5.3.6] 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:133) ~[reactor-core-3.4.5.jar:3.4.5] 	at kotlinx.coroutines.reactor.MonoCoroutine.onCompleted(Mono.kt:66) ~[kotlinx-coroutines-reactor-1.4.3.jar:na] 	at kotlinx.coroutines.AbstractCoroutine.onCompletionInternal(AbstractCoroutine.kt:104) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.JobSupport.tryFinalizeSimpleState(JobSupport.kt:294) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.JobSupport.tryMakeCompleting(JobSupport.kt:856) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core(JobSupport.kt:828) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.AbstractCoroutine.resumeWith(AbstractCoroutine.kt:111) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.debug.internal.DebugProbesImpl$CoroutineOwner.resumeWith(DebugProbesImpl.kt:461) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:46) ~[kotlin-stdlib-1.4.32.jar:1.4.32-release-371 (1.4.32)] 	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.EventLoop.processUnconfinedEvent(EventLoop.common.kt:69) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.internal.DispatchedContinuationKt.resumeCancellableWith(DispatchedContinuation.kt:357) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:30) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable$default(Cancellable.kt:27) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt:110) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt:158) ~[kotlinx-coroutines-core-jvm-1.4.3.jar:na] 	at kotlinx.coroutines.reactor.MonoKt$monoInternal$1.accept(Mono.kt:55) ~[kotlinx-coroutines-reactor-1.4.3.jar:na] 	at kotlinx.coroutines.reactor.MonoKt$monoInternal$1.accept(Mono.kt) ~[kotlinx-coroutines-reactor-1.4.3.jar:na] 	at reactor.core.publisher.MonoCreate.subscribe(MonoCreate.java:57) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.5.jar:3.4.5] 	at org.springframework.messaging.handler.invocation.reactive.ChannelSendOperator.subscribe(ChannelSendOperator.java:85) ~[spring-messaging-5.3.6.jar:5.3.6] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:251) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:336) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:180) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.request(MonoPeekTerminal.java:139) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:325) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onSubscribe(MonoPeekTerminal.java:152) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.5.jar:3.4.5] 	at io.rsocket.core.RSocketResponder.handleFireAndForget(RSocketResponder.java:313) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.RSocketResponder.handleFrame(RSocketResponder.java:197) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:160) ~[reactor-core-3.4.5.jar:3.4.5] 	at io.rsocket.core.ClientServerInputMultiplexer$InternalDuplexConnection.onNext(ClientServerInputMultiplexer.java:248) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.ClientServerInputMultiplexer.onNext(ClientServerInputMultiplexer.java:129) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.ClientServerInputMultiplexer.onNext(ClientServerInputMultiplexer.java:48) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.SetupHandlingDuplexConnection.onNext(SetupHandlingDuplexConnection.java:118) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.SetupHandlingDuplexConnection.onNext(SetupHandlingDuplexConnection.java:19) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.5.jar:3.4.5] 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:280) ~[reactor-netty-core-1.0.6.jar:1.0.6] 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:389) ~[reactor-netty-core-1.0.6.jar:1.0.6] 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:401) ~[reactor-netty-core-1.0.6.jar:1.0.6] 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:560) ~[reactor-netty-http-1.0.6.jar:1.0.6] 	at reactor.netty.http.server.WebsocketServerOperations.onInboundNext(WebsocketServerOperations.java:168) ~[reactor-netty-http-1.0.6.jar:1.0.6] 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.6.jar:1.0.6] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.63.Final.jar:4.1.63.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.63.Final.jar:4.1.63.Final] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] ```  Example app SpringBoot + ReactJs Client:  [rsocketsdemo.zip](https://github.com/spring-projects/spring-framework/files/6343712/rsocketsdemo.zip)  - Start SpringBoot - Client - npm install (for node modules) - Client - npm start - Client - write message and hit send button","closed","in: kotlin,","MichalJana","2021-04-20T13:07:14Z","2022-06-01T13:41:50Z"
"","26751","BEFORE_COMMIT @TransactionalEventListener is invoked without a transaction","I'm trying to isolate this in a test and it's impossible, it only happens in my CI and not always. I have a @TransactionalEventListener defined as this: ```java @Component @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS) class MyEventListener> implements Ordered, DomainEventListener {  	@Override 	@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT) 	@Transactional(propagation = Propagation.MANDATORY) 	public void onDomainEvent(DomainEvent event) {                 // Do some stuff 	}  	@Override 	public int getOrder() { 		return Integer.MIN_VALUE + 1; // Run before MyOtherEventListener 	} } ``` I defined it with `@Transactional(propagation = Propagation.MANDATORY)` just for safety, as it was my understanding that a BEFORE_COMMIT event listener would be invoked within a transaction always (before it's committed)... but sometimes I'm getting a `org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'` exception.  Is this stack-trace really possible? ``` org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory' 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:362) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:595) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:382) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) 	at com.mycompany.myproject.engine.stuff.rules.MyEventListener$$EnhancerBySpringCGLIB$$fb30fdcf.onDomainEvent() 	at com.mycompany.myproject.engine.stuff.rules.MyEventListener$$FastClassBySpringCGLIB$$d3f2b7f5.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:779) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:137) 	at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:124) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) 	at com.mycompany.myproject.engine.stuff.rules.MyEventListener$$EnhancerBySpringCGLIB$$e4fa4789.onDomainEvent() 	at jdk.internal.reflect.GeneratedMethodAccessor230.invoke(Unknown Source) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.context.event.ApplicationListenerMethodAdapter.doInvoke(ApplicationListenerMethodAdapter.java:312) 	at org.springframework.context.event.ApplicationListenerMethodAdapter.processEvent(ApplicationListenerMethodAdapter.java:197) 	at org.springframework.transaction.event.TransactionalApplicationListenerSynchronization.processEventWithCallbacks(TransactionalApplicationListenerSynchronization.java:80) 	at org.springframework.transaction.event.TransactionalApplicationListenerSynchronization.beforeCommit(TransactionalApplicationListenerSynchronization.java:59) 	at org.springframework.transaction.support.TransactionSynchronizationUtils.triggerBeforeCommit(TransactionSynchronizationUtils.java:98) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.triggerBeforeCommit(AbstractPlatformTransactionManager.java:919) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:727) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:711) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:654) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:407) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:89) 	at com.mycompany.myproject.engine.config.aop.CurrentRequestContextSetterInterceptor.perform(CurrentRequestContextSetterInterceptor.java:25) 	at jdk.internal.reflect.GeneratedMethodAccessor93.invoke(Unknown Source) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:634) 	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:624) 	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:72) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) 	at com.mycompany.myproject.engine.stuff.service.impl.ShipmentAssociationServiceImpl$$EnhancerBySpringCGLIB$$775411f6_2.associateToAsset() 	at com.mycompany.myproject.engine.stuff.service.impl.ShipmentAssociationServiceImpl$$FastClassBySpringCGLIB$$a5de39ae.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:779) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:137) 	at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:124) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) 	at com.mycompany.myproject.engine.stuff.service.impl.ShipmentAssociationServiceImpl$$EnhancerBySpringCGLIB$$13ee4004.associateToAsset() 	at com.mycompany.myproject.engine.stuff.grpc.ShipmentReadingGrpcTest.associateToAsset(ShipmentReadingGrpcTest.java:379) 	at com.mycompany.myproject.engine.stuff.grpc.ShipmentReadingGrpcTest.associateToAsset(ShipmentReadingGrpcTest.java:369) 	at com.mycompany.myproject.engine.stuff.grpc.ShipmentReadingGrpcTest.setupScenario(ShipmentReadingGrpcTest.java:101) 	at com.mycompany.myproject.engine.stuff.grpc.ShipmentReadingGrpcTest.find_byProvider(ShipmentReadingGrpcTest.java:157) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56) 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 	at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) 	at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) 	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) 	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) 	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27) 	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) 	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61) 	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:61) 	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) 	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329) 	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293) 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:54) 	at org.junit.rules.RunRules.evaluate(RunRules.java:20) 	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:413) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) 	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110) 	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58) 	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38) 	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:119) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 	at java.base/java.lang.Thread.run(Thread.java:834) ``` I have two separate postgresql (hikari) data-sources, one for quartz and other (main one) for my app's data. These app events only happen during transactions over my main data-source.","closed","","flozano","2021-04-01T18:36:49Z","2022-02-18T19:05:38Z"
"","26397","Spring Webflux, Server Sent Events & Firefox not working","I'm trying to get server sent events to work with Mozilla Firefox and Spring Boot 2.2.8.RELEASE. Given a Spring Boot webservice like      @GetMapping(path = ""/timestamps"", produces = MediaType.TEXT_EVENT_STREAM_VALUE)     public Flux timestamps() {         return Flux.interval(Duration.ofSeconds(1))                 .map(sequence -> LocalTime.now().toString());     } which works fine using Chrome browser or Edge (always latest versions). I can see an unfinished request in the network analyzer tab and every second a new timestamp is displayed.  However, when I use Firefox (84.0.2 or older), the request is also shown in the network tab but no response headers or streaming data is shown. When I terminate the Spring backend, Firefox pops up a dialog to save a file with the contents of the request, which fails, because the backend is already terminated.  It seems to me that there is some kind of flush() missing on the backend side.  Can anyone confirm or deny such behaviour with FF, Spring Webflux & SSE?","closed","status: invalid,","fjakop","2021-01-18T08:32:12Z","2021-01-18T14:29:55Z"
"","26528","Allow creation of Beans that cannot be autowired by type unless qualified","I'm seeing more and more problems with complex Spring / Spring Boot applications where beans created in some dependency interfere with the operation of either another dependency or our own code.  Dependencies like to declare Beans because it is convenient to inject them where needed in the dependency's own code.  However, some of these beans really shouldn't be public and available for general use.  By declaring a Bean, it becomes publicly available, even if given its own name or if it is declared with a Qualifier:       @Bean(""myName"") @MyQualifer      public MyBean myBean() { ... }  This bean can still be injected anywhere (when it is the only option) because Spring will match it by type:       @Autowired private MyBean bean1;  This is highly undesirable for types that are used commonly by multiple dependencies.  Some of the biggest offenders are `ObjectMapper`, `ThreadPoolTaskScheduler`, etc.  Beans like this often get configured in a specific way for a specific dependency and making them public (by simple declaring them) means that these beans can end up in completely unrelated parts of an application.  Spring's injection capabilities are very useful, even in libraries, but just like a library should be able to limit what API is publicly available, it should also be able to decide which of its beans are safe to use in external code (published) and which are not (kept private).  Qualifiers and Bean names are however insufficient due to Spring's matching by type -- a Bean intended for internal use only can still leak out and be used in external code.  I therefore suggest allowing Beans to be declared with restrictions on how it can be matched:       @Bean(value = ""myName"", name-must-match = true) public MyBean myBean() { ... }  Or:      @Bean(must-be-qualified = true) @MyQualifier public MyBean myBean() { ... }  The first declaration would require the wiring site to specify the bean name:      @Autowired @Qualifer(""myName"") private MyBean bean1;  The second would require:      @Autowired @MyQualfier private MyBean bean1;  This would NOT match:      @Autowired private MyBean myBean;  In this fashion, library authors can keep certain beans private to the library by keeping the Qualifier private or by using an obscure bean name (use at your own risk in external code).  The suggested names and even the entire mechanism are just for illustration.  I could imagine there being different annotations for this purpose: `@NamedBean` -- bean that must match by name to be considered for injection, and `@QualifiedBean` -- bean that must match all qualifiers to be considered.","open","in: core,","hjohn","2021-02-09T08:24:38Z","2022-06-08T10:30:43Z"
"","26415","Expected lookupPath in request attribute ""org.springframework.web.util.UrlPathHelper.PATH"" error with Spring Data REST","I'm not totally sure if this is a Spring MVC or Spring Data issue. I suspect it's a Spring MVC issue that's hard to replicate without Spring Data.  Whilst working on https://github.com/spring-projects/spring-boot/issues/24805 I've hit the following exception:  ``` org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.IllegalArgumentException: Expected lookupPath in request attribute ""org.springframework.web.util.UrlPathHelper.PATH"". 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:497) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) 	at org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:72) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:584) 	at org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:167) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:183) 	at smoketest.data.rest.SampleDataRestApplicationTests.testHome(SampleDataRestApplicationTests.java:58) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:84) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) Caused by: java.lang.IllegalArgumentException: Expected lookupPath in request attribute ""org.springframework.web.util.UrlPathHelper.PATH"". 	at org.springframework.util.Assert.notNull(Assert.java:201) 	at org.springframework.web.util.UrlPathHelper.getResolvedLookupPath(UrlPathHelper.java:214) 	at org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getMatchingCondition(PatternsRequestCondition.java:280) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfo.getMatchingCondition(RequestMappingInfo.java:399) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:108) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:66) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.addMatchingMappings(AbstractHandlerMethodMapping.java:423) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:389) 	at org.springframework.data.rest.webmvc.BasePathAwareHandlerMapping.lookupHandlerMethod(BasePathAwareHandlerMapping.java:99) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:364) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:123) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:66) 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:491) 	at org.springframework.data.rest.webmvc.config.DelegatingHandlerMapping$HandlerSelectionResult.from(DelegatingHandlerMapping.java:134) 	at org.springframework.data.rest.webmvc.config.DelegatingHandlerMapping.getHandlerInternal(DelegatingHandlerMapping.java:101) 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:491) 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1254) 	at org.springframework.test.web.servlet.TestDispatcherServlet.getHandler(TestDispatcherServlet.java:122) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1036) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	... 76 more ```  I think this is caused by a mix of `AbstractHandlerMapping` where some have a `PathPatternParser` and some do not.  Debugging the test I see that `AbstractHandlerMapping.initLookupPath` is called several times. The last call before the exception triggers a `request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE)` which causes `RequestMappingInfoHandlerMapping.getMatchingMapping` to fail.  Running `SampleDataRestApplicationTests.testHome` from https://github.com/philwebb/spring-boot/tree/gh-24805 will replicate the problem.","closed","for: external-project,","philwebb","2021-01-21T01:04:09Z","2021-01-21T20:57:42Z"
"","26417","code block displaying incorrectly in documentation for Restdocs","I'm not sure if this is the correct repository to report in, but the docs seem to have a display error on Creating API Documentation with Restdocs https://spring.io/guides/gs/testing-restdocs/ where it says > The following example shows what to add if you use Gradle:  the code block is empty.","closed","for: external-project,","CubeOfCheese","2021-01-21T03:51:18Z","2021-01-21T10:08:54Z"
"","25881","Functional bean registrations should perhaps have an explicit target type","I'm not super clear on the difference between `beanClass` and `targetType` in a `BeanDefinition`, but if I do this:  ```java context.registerBean(""foo"", Foo.class, () -> new Foo()); ```  I think it's pretty clear that the type of the bean is `Foo`. But Spring only sets the `beanClass` and not the `targetType`. It actually only hardly ever causes issues, but maybe the intent would be more clearly encapsulated if the bean definition was created with its target type already resolved?","closed","in: core,","dsyer","2020-10-08T07:10:24Z","2022-01-19T10:52:09Z"
"","26603","Bean proxying prevents MVC controller registration: AOP bug?","I'm having a difficult time determining the minimal reproduction of this problem, but I can describe the behavior in detail and am available for debugging:  I have an MVC controller written in Groovy that uses traits. This produces a class that implements several interfaces (including the trait itself and some Groovy synthetics), but none of these interfaces is directly relevant to MVC. One of them defines an `@Autowired(required = false)` setter that is not in use in this case:  ``` @RestController @RequestMapping(BASE_URL) class UsersController implements HasIdGenerator {   public static final String BASE_URL = '/users'    @PostMapping   ResponseEntity register(@RequestBody User newUser) {     // logic   } } ```  This controller is registered properly with `RequestMappingHandlerMapping`. However, when I add an annotation to `register` that triggers Spring AOP (specifically, in this case, a `@PreAuthorize` meta-annotation), the controller disappears from registration.  I've tracked down the immediate problem to `RequestMappingHandlerMapping#isHandler(Class)`. When the Spring Security AOP is active, the argument passed to this method is `com.sun.proxy.$Proxy123`, and then `AnnotatedElementUtils.hasAnnotation(beanType, Controller.class)` returns false because the annotation scanner ends up checking the proxy interface and its superinterfaces _but not the actual controller class where the controller methods are declared_. The result is that all methods that aren't part of an interface API disappear from Spring's visibility of the bean and thence from registration.  So far the logic underlying this failure case appears sound, but I can't figure out why it doesn't _usually_ break; that is, controllers work all the time with Spring Security annotations. I'm suspecting that it has something to do with the decisions of AOP application strategies, but this is getting farther into the infrastructure than I have intuition for. Removing the Groovy trait (and thus the interfaces involved, _but not the `GroovyObject` interface_), results in a CGLIB proxy properly exposing all of the controller methods.  **Update**: On further debugging, it appears that `ProxyProcessorSupport` _explicitly_ lists `groovy.lang.GroovyObject` as ""not a 'real' interface"" for purposes of determining whether a class ""looks JDK-proxyable"", and it's the addition of the extra interface by the trait that leads `#evaluateProxyInterfaces` to decide to use a JDK proxy.  The end result appears to be that adding a nontrivial interface to _any_ Spring MVC controller will silently disable its controller methods by means of hiding them from the annotation scan. It seems to me that either classes with `@Controller` (including a meta) should always be forced to CGLIB, or `#isHandler` should unwrap proxies (but since this would, I think, break the actual advice itself, that's probably not practical).","open","in: core,","chrylis","2021-02-24T21:06:17Z","2021-11-10T11:58:08Z"
"","26170","Allow customization of file extension to media type map for WebFlux static resources","I'd like the ability to easily customize the file extension -> media type map used for serving static resources in a WebFlux application.  Specifically, I'd like a simple method to be able to register a new mapping, or change an existing mapping.  Currently, [`ResourceWebHandler`](https://github.com/spring-projects/spring-framework/blob/56dbe06d9b885951922fcfe98aa514b355e031c5/spring-webflux/src/main/java/org/springframework/web/reactive/resource/ResourceWebHandler.java#L377) and [`ResourceHttpMessageWriter`](https://github.com/spring-projects/spring-framework/blob/56dbe06d9b885951922fcfe98aa514b355e031c5/spring-web/src/main/java/org/springframework/http/codec/ResourceHttpMessageWriter.java#L145) both call `MediaTypeFactory.getMediaType(resource)` to determine the media type of a resource.  [`MediaTypeFactory` loads its mappings from the `/org/springframework/http/mime.types` file on the classpath](https://github.com/spring-projects/spring-framework/blob/56dbe06d9b885951922fcfe98aa514b355e031c5/spring-web/src/main/java/org/springframework/http/MediaTypeFactory.java#L45-L87).  As far as I can tell, there is no easy way to customize these mappings in a WebFlux application.  (It looks like you could technically extend `ResourceHttpMessageWriter` to customizer the resolution of the media type, but most of what is needed is private, so it would basically require re-implementing most of the logic in `ResourceHttpMessageWriter`.  This is pretty heavyweight for just adding an additional mapping.)  For comparison, in a servlet-based application, the mappings can be easily customized via `ConfigurableServletWebServerFactory.setMimeMappings(MimeMappings mimeMappings)`.  (And FWIW, I need a mapping for `xsd`, and would also be happy if that was added to the defaults.)","closed","type: enhancement,","philsttr","2020-11-27T18:02:32Z","2020-11-30T17:32:13Z"
"","26443","Introduce getResources() method in ResourceLoader interface","I would like to suggest as new feature the possibility to add a `getResources()` method to the `ResourceLoader` interface, and if it accepted wildcards it would be even nicer. I assume there must be a rationale to prevent this, but just in case.  I don't understand why the out-of-the-box auto-configured `ResourceLoader` implementation is not prepared for these needs.  It seems to me, from my ignorance, that 90% of the apps would benefit from having a single central `ResourceLoader` that deals with all kinds of resources.   Currently I cannot have an `@Autowired` `ResourceLoader`, not even override it because I have to manually deal with concrete implementation `PathMatchingResourcePatternResolver`.  Thanks mates!","closed","type: enhancement,","nightswimmings","2021-01-26T08:46:32Z","2021-01-26T21:08:18Z"
"","26542","Add TimestampGenerator contract for generating timestamps","I would like to propose a new `TimestampGenerator` functional interface be added as a core utility. I feel this would be a great parallel to the existing [`IdGenerator`](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/IdGenerator.java) functional interface that already exists. The contract would look as follows:  ```Java @FunctionalInterface public interface TimestampGenerator {      long generateTimestamp(); } ```  For components that need to generate timestamps, a bean could easily be declared as follows:  ```Java @Configuration class TimestampConfiguration {      @Bean     TimestampGenerator timestampGenerator() {         return System::currentTimeMillis;     } } ```  This comes in handy when mocking dependencies in tests as relying on static methods for generating timestamps makes assertions difficult. In many of my projects I end up defining a similar interface so I would love to see it become part of the core framework.  A simple proof of concept can be seen [here](https://github.com/Gorlah/timestamp-generator/blob/main/src/main/java/com/gorlah/timestampgenerator/TimestampGeneratorApplication.java).","closed","type: enhancement,","erichaagdev","2021-02-13T15:19:14Z","2021-02-13T19:23:38Z"
"","26146","spring-jms and rabbitmq-jms problem","I would like to open, what we consider a bug.  We are using the Spring framework ""spring-jms"" with rabbitmq-jms component. Because we want to know when new messages are coming, we use ""DefaultMessageListenerContainer"" (DMLC), we have configured it like that:  	 		 		 		 		 		 				 	  And we have defined 4 or 5 such listener, each with different settings.  So we can send messages, we receive them, we handle them. Everything works without any problems.  The issue we are facing, is that in RabbitMQ we are using some Quorum Queues, and every 4-5 hours we get tons of ""segment"" files, and they are not cleaned up. And after a while our filesystem is full, and we need to do some clean up, by stopping the applications, etc...   After some digging, and opening a ticket to the RabbitMQ people ( https://github.com/rabbitmq/discussions/issues/164 ) we have discovered that we are using ""Channel.basicGet()"", and this is creating these tons of segment files. Clearly in our code we have zero reference to Channel.basicGet(), but by doing some debugging, we have found that, DMLC will call through the RabbitMQ-jms api the Channel.basicGet function nearly every seconds (or maybe a little bit more), which is not a good practice in rabbitMQ ( https://www.cloudamqp.com/blog/2020-07-14-rabbitmq-basic-consume-vs-rabbitmq-basic-get.html ).  Here is the sequence from DMLC to Channel.basicGet() : in Spring-jms:   - DMLC.AsyncMessageListenerInvoker.run()   - DMLC.AsyncMessageListenerInvoker.executeOngoingLoop()   - DMLC.AsyncMessageListenerInvoker.invokeListener()   - AbstractPollingMessageListenerContainer.receiveAndExecute()   - AbstractPollingMessageListenerContainer.doReceiveAndExecute()   - AbstractPollingMessageListenerContainer.receiveMessage()   - JmsDestinationAccessor.receiveFromConsumer()  The rest goes In RabbitMQ-jms:   - RMQMessageConsumer.receive(long)   - RMQMessageConsumer.receive(TimeTracker)   - DelayedReceiver.get()   - RMQMessageConsumer.getFromRabbitQueue()   - AutoRecoveringChannel.basicGet()  We are looking at how to replace the DMLC on our side, so we don't use indirectly the basicGet method of RabbitMQ, and try to implement the basic Consume method, which is recommended way by RabbitMQ.  So this is the bug. if we use DMLC to handle messages, then on the rabbitmq side, we are facing a filesystem issue (disk full). We were using the vanilla way to do it (https://spring.io/guides/gs/messaging-rabbitmq/ & https://spring.io/guides/gs/messaging-jms/).  One way to solve it, would be to have like a ""DefaultGETMessageListenerContainer"" which use in RabbitMQ the basicGet, as of today, it could be default ""DefaultMessageListenerContainer"". And another one called maybe ""DefaultConsumeMessageListenerContainer"", which will use in RabbitMQ the basicConsume method. Or maybe show an example, on how to do it with the other method, with the documentation.  But as it is now, the DMLC is not ready for production, and should not be used with RabbitMQ, this is what we learned during the previous weeks of investigation to find the problem...  Am I wrong in my assumption? Do you see how we could solve it? Is this a bug, or a ""feature""? Do we have missed some documentation somewhere that explain how to solve it?  Thank you for your help.  Regards, Alessandro","closed","status: invalid,","ptitvert","2020-11-24T14:13:14Z","2021-04-27T11:34:37Z"
"","26738","ScriptItemProcessor python implementation","I wanted to use a web scraping python script in my batch program but this is not feasible in Spring Batch. I want to request for this feature in a future Spring version. Python grows in popularity and using a python script with ScriptItemProcessor I think is becoming a necessity.","closed","for: external-project,","EdgardHernandezp","2021-03-26T20:33:43Z","2021-03-27T07:09:17Z"
"","26567","WebFlux multipart streaming not work","I want to upload files without saving to disk or memory.  Controller: ``` @RestController @RequestMapping(""api/v1/files"") public class FilesController {      @PostMapping     public Mono upload(@RequestPart FilePart filePart) throws IOException {         filePart.transferTo(Files.createTempFile(""test"", filePart.filename()));         return Mono.just(filePart.filename());     } } ```  Config: ``` @Configuration public class WebConfig implements WebFluxConfigurer {      @Override     public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {         DefaultPartHttpMessageReader partReader = new DefaultPartHttpMessageReader();         partReader.setStreaming(true);         configurer.defaultCodecs().multipartReader(new MultipartHttpMessageReader(partReader));     } } ```  Request: ``` curl --location --request POST 'http://localhost:8080/api/v1/files' --form 'file=@""/some_file.pdf""' ```  Full example: [streaming-multipart.zip](https://github.com/spring-projects/spring-framework/files/6002432/streaming-multipart.zip)","closed","status: invalid,","DVMaslov","2021-02-18T11:28:18Z","2022-03-15T20:02:39Z"
"","25891","Spring should call start/stop methods on application context when spring-test is used with junit","I use spring 5 with junit 5 and I think that star/stop methods on application context must be called, because otherwise it is not possible to use context event listeners that can be very useful within testing infrastructure. So, I suggest to call .start() before ALL tests and .stop() after ALL tests.","closed","status: declined,","PashaTurok","2020-10-09T17:12:19Z","2020-10-13T05:34:00Z"
"","26213","Thread leak in Spring WebSocketStompClient with integrated GlassFish Servlet container","I use `WebSocketStompClient` with `GlassFish` web socket contained called `Tyrus` in the next way:  ``` WebSocketStompClient client;  ClientManager clientManager = org.glassfish.tyrus.client.ClientManager.createClient();  clientManager.getProperties().put(     SELECTOR_THREAD_POOL_CONFIG,     defaultConfig().setPoolName(""ws-selector""));  clientManager.getProperties().put(     WORKER_THREAD_POOL_CONFIG,     defaultConfig().setPoolName(""ws-worker""));  client = new WebSocketStompClient(new StandardWebSocketClient(clientManager));  client.start();  sesion = client.connect(uri, handshakeHeaders(clusterSecret), connectHeaders(), sesHnd)     .get(10L, SECONDS); ```  and after successful Web socket connection I receive an error message with `400` code.  `org.gridgain.control.agent.ControlCenterAgent.AfterConnectedSessionHandler#handleTransportError` of `sesHnd` object is executed after this error, but `DefaultStompSession` argument does not have the `connection` object inside. This `connection` object has type `org.springframework.web.socket.messaging.WebSocketStompClient.WebSocketTcpConnectionHandlerAdapter` and it’s `stop` method crear all servlet container resources on `session.disconnect()` in the common way.  But in my case I can see that some resources stay not released. `Thread.getAllStackTraces()` returns some `ws-selector` and `ws-worker` threads, and I cannot find the way to release them.  Used `spring-core`, `spring-websocket`, `spring-messaging` and `spring-web 4.3.29.RELEASE`, and `tyrus-standalone-client` 1.17  https://stackoverflow.com/questions/65108531/thread-leak-in-spring-websocketstompclient-with-integrated-glassfish-servlet-con","open","status: feedback-provided,","vsisko","2020-12-04T11:58:55Z","2021-01-18T16:49:22Z"
"","26705","@Transactional support for coroutines in WebMVC + JDBC projects","I upgraded to Spring Boot 2.4 and Spring 5.3 in my Kotlin Web MVC project after seeing:  > Support for @Transactional suspending functions (Kotlin Coroutines)   This transactional support, though, is not working for me in my project where I'm using `jdbcTemplate` everywhere. Here's an example   An `@Controller` suspending endpoint:  ```kotlin @PostMapping(""/orders"") suspend fun saveOrder(@RequestBody orderRequest: OrderRequest): ResponseEntity{    val order = orderService.saveOrder(orderRequest)    // ... } ```  Service:  ```kotlin @Transactional  @Service OrderServiceImpl(): OrderService{    override suspend fun orderService(request: OrderRequest): Order{        // a mix of WebClient external service calls and calls to dao's that do coroutine jdbc in the `withContext(Dispatchers.IO)`    } } ```  In a simple test, my DB calls are not in the same physical transaction. After looking more closely at [at this issue](https://github.com/spring-projects/spring-framework/issues/22915), I will only get the `@Transactional` support if the determined `TransactionManager` is an instance of `ReactiveTransactionManager`  When debugging `TransactionAspectSupport.invokeWithinTransaction`, I always get back the `JdbcTransactionManager`. Is it not possible to use declarative transactions in Web MVC with coroutines as I've described? I had assumed this enhancement took to managing the `ThreadLocal` based reference to the open transaction and added it to the current `CoroutineContext` but that isn't the case for me.   If it's not possible, then what are the caveats around this `@Transactional` coroutine support? Must I be using Spring WebFlux? Is there a requirement around the return type?   If there's an enhancement to be made here, I'd be happy to take a stab at it once I better understand what the desired state of this is.","closed","status: declined,","mistahenry","2021-03-19T11:41:01Z","2021-04-09T12:41:39Z"
"","26872","Add optional path parameter to @Controller","I type `@RequestMapping` and `@Controller` before almost all my Controllers.  ```java @RequestMapping(""/clients"") @Controller class ClientsController { } ```  If you introduce a `path` attribute in `@Controller`,  this can be reduced to:  ```java @Controller(path=""/clients"") class ClientsController { } ```","closed","status: declined,","hansdesmet","2021-04-28T12:01:19Z","2021-04-29T10:44:23Z"
"","26185","CommonAnnotationBeanPostProcessor jakarta.annotation-api:2.0.0 support (@PostConstruct/Predestroy)","I tried to upgrade jakarta.annotation:jakarta.annotation-api from 1.3.5 to 2.0.0 The annotations moved from package javax.annotation to jakarta.annotation. After the Upgrade @PostConstruct and @PreDestroy are not working. Please let annotations from both packages work in CommonAnnotationBeanPostProcessor.","closed","type: enhancement,","qeepcologne","2020-12-01T10:25:14Z","2021-09-17T07:14:57Z"
"","26263","Lots of boundedElastic-evictor TIMED_WAITING threads related to form data requests","I send request to webflux demo server. use springboot version 2.4.1 , create  no quantity limit nuboundedElastic-evictor thread and always keep timed waiting status. ### test script ``ab -n 10000 -c 1000 -T ""application/x-www-form-urlencoded"" -p test.txt http://127.0.0.1:8080/router/rest/1`` ### controller code ``` @RestController @RequestMapping(""/router/rest"") public class BaseController {      @RequestMapping(""1"")     public Mono mono(){         return Mono.just(""111"");     } } ``` lots of boundedElastic-evictor TIMED_WAITING make memory up obvious.  ``` ""boundedElastic-evictor-9998"" #10042 daemon prio=5 os_prio=0 cpu=0.00ms elapsed=130.64s tid=0x0000023b82f71dc0 nid=0xe694 waiting on condition  [0x0000008cf91fe000]    java.lang.Thread.State: TIMED_WAITING (parking)         at jdk.internal.misc.Unsafe.park(java.base@15.0.1/Native Method)         - parking to wait for  <0x000000070aba6988> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)         at java.util.concurrent.locks.LockSupport.parkNanos(java.base@15.0.1/LockSupport.java:252) ```  ### finally Switching to version 2.3.7 resolved","closed","type: regression,","Justubborn","2020-12-13T04:40:44Z","2021-01-05T17:21:16Z"
"","26377","Avoid synchronization in AbstractAspectJAdvice#calculateArgumentBindings","I see `AbstractAspectJAdvice#calculateArgumentBindings` is synchronized, but if first time the Advice method calculates the argument binding, the next time it can return directly without lock, I think it can prevent some lock competition.   such as:  ```java public final void calculateArgumentBindings() {     // The simple case... nothing to bind.     if (this.argumentsIntrospected || this.parameterTypes.length == 0) { 	    return;     }     synchronized(this) {       if (this.argumentsIntrospected || this.parameterTypes.length == 0) {         return;       }       int numUnboundArgs = this.parameterTypes.length;       Class[] parameterTypes = this.aspectJAdviceMethod.getParameterTypes();       if (maybeBindJoinPoint(parameterTypes[0]) || maybeBindProceedingJoinPoint(parameterTypes[0])) {         numUnboundArgs--;       }       else if (maybeBindJoinPointStaticPart(parameterTypes[0])) {         numUnboundArgs--;       }              if (numUnboundArgs > 0) {       // need to bind arguments by name as returned from the pointcut match         bindArgumentsByName(numUnboundArgs);       }           this.argumentsIntrospected = true;     }		 } ```","closed","type: enhancement,","hnxy","2021-01-12T14:55:44Z","2022-07-13T15:12:39Z"
"","26201","Document autowiring of ServletRequest and other scoped proxy beans provided by WebApplicationContextUtils.registerWebApplicationScopes","I recently stumbled upon the fact that it's possible to autowire `HttpServletRequest` into singleton-scoped Spring beans, despite the object being specific to a particular web request, and not globally applicable.  From what I've been able to determine, this is a proxy object registered by [`WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, servletContext)`](https://github.com/spring-projects/spring-framework/blob/5328184f3a22ed3d848f6004c50c721597e4d564/spring-web/src/main/java/org/springframework/web/context/support/WebApplicationContextUtils.java#L183).  It is added by `spring-web` (and/or by `spring-boot`) to the bean factory by `AbstractRefreshableWebApplicationContext` (or its subclass overrides).  Looking at the source for `WebApplicationContextUtils`, it looks like the following objects are provided in this manner:  * `ServletRequest` * `ServletResponse` * `HttpSession` * `WebRequest` * `FacesContext` (if JSF present) * `ExternalContext` (if JSF present)  While handy, this behavior was somewhat surprising, since I didn't expect to be able to autowire in something that was inherently tied to a specific web request to a singleton bean that is shared across requests.  From what I have been able to tell (as discussed in [this Stack Overflow question](https://stackoverflow.com/questions/65100385/where-is-autowiring-of-httpservletrequest-into-arbitrary-spring-components-docum), this feature is not documented anywhere obvious.  The only documentation I've seen is the issue that added it (https://github.com/spring-projects/spring-framework/issues/9808#issuecomment-453333642) and the [release notes](https://github.com/spring-projects/spring-framework/releases/tag/v3.0.0.M4) when it was added:  > As of Spring 3.0 RC1, we generally inject proxies for request and session objects now. This has the advantage of working in singleton beans and serializable beans as well, and to always obtain the current session handle - even in case of invalidation between requests or between multiple calls within the same request.  It would be helpful if this feature were documented.  In particular, it would be nice to have documentation that these beans are available for autowiring and the situations when they are not available (e.g. when executing outside of the scope of a request).","open","in: core,","mjustin","2020-12-03T03:36:06Z","2021-11-10T11:58:07Z"
"","26854","@Transactional should treat UndeclaredThrowableException as a checked exception","I read [this blogpost](https://blog.pchudzik.com/201911/transactional-errors/) describing this problem: ```java @SneakyThrows @Transactional public void lombokSurprise() {     jdbcTemplate.execute(""insert into test_table values('lombok!')"");     throw new Exception(""Simple exception""); } ``` This code is supposed to commit the transaction but it does not. The problem is that Spring wraps checked exceptions that aren't declared in the signature within an [UndeclaredThrowableException](https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/UndeclaredThrowableException.html) over [here](https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L767) and from that point treats it as unchecked.   I think we should treat this one as a checked exception to preserve the promised behavior. I believe it's controlled here:  https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-tx/src/main/java/org/springframework/transaction/interceptor/DefaultTransactionAttribute.java#L171-L188  So, we could append `|| ex instanceof UndeclaredThrowableException` to solve it.  It will be a breaking change, but I think most people expect it to work that way anyway.","closed","status: declined,","Sam-Kruglov","2021-04-23T12:22:49Z","2021-04-27T16:40:57Z"
"","26355","Application built against Spring Framework 5.3 breaks deployment to Wildfly 9","I originally logged this against Spring Boot (https://github.com/spring-projects/spring-boot/issues/24686), but it seems that https://github.com/spring-projects/spring-framework/pull/25852 breaks deployment of a war file built against Spring Framework 5.3 (from Spring Boot 2.4) to Wildfly 9 running on JDK 8.  (We're currently unable to upgrade to a newer version of Wildfly.)","closed","in: core,","lordofthemoon","2021-01-07T15:10:50Z","2021-07-13T09:59:20Z"
"","26613","Add missing nullable annotation to ResponseEntity ok convenience method","I noticed that the convenience method ResponseEntity.ok which also takes a body and delegates it to ResponseEntity.body is missing the nullable annotation which let to a sonarqube warning in my codebase when passing a null value to this convenience method.","closed","type: enhancement,","kevin0x90","2021-02-26T15:52:10Z","2021-02-26T16:01:03Z"
"","25915","DataBufferUtils.CompositeMatcher causes poor performance when one or more matchers does not match","I noticed my CPU pegged for over a minute reading a 675K text resource when subscribing to a flux for a response in a test:  ```         val events = ClientResponse.create(HttpStatus.OK)             .body(eventsBody)             .build()             .bodyToFlow>() ```  When I hooked up YourKit all the time was being spent in `org.springframework.core.io.buffer.DataBufferUtils.KnuthMorrisPrattMatcher#match`:    After stepping in the debugger I noticed the problem - the default delimiter bytes are for DOS line endings and newlines and because `DataBufferUtils.CompositeMatcher` doesn't hold onto state indicating if a matcher previously failed to find a match, each time the newline delimiter is seen the entire input has to be scanned again.  The `StringDecoder` is created here: ``` ""scheduling-1@17393"" prio=5 tid=0xcd nid=NA runnable   java.lang.Thread.State: RUNNABLE 	  at org.springframework.core.codec.StringDecoder.(StringDecoder.java:79) 	  at org.springframework.core.codec.StringDecoder.textPlainOnly(StringDecoder.java:239) 	  at org.springframework.core.codec.StringDecoder.textPlainOnly(StringDecoder.java:229) 	  at org.springframework.http.codec.ServerSentEventHttpMessageReader.(ServerSentEventHttpMessageReader.java:58) 	  at org.springframework.http.codec.support.ClientDefaultCodecsImpl.extendObjectReaders(ClientDefaultCodecsImpl.java:103) 	  at org.springframework.http.codec.support.BaseDefaultCodecs.getObjectReaders(BaseDefaultCodecs.java:354) 	  at org.springframework.http.codec.support.BaseCodecConfigurer.getReaders(BaseCodecConfigurer.java:100) 	  at org.springframework.http.codec.support.DefaultClientCodecConfigurer.getReaders(DefaultClientCodecConfigurer.java:31) 	  at org.springframework.web.reactive.function.client.DefaultExchangeStrategiesBuilder$DefaultExchangeStrategies.(DefaultExchangeStrategiesBuilder.java:86) 	  at org.springframework.web.reactive.function.client.DefaultExchangeStrategiesBuilder.build(DefaultExchangeStrategiesBuilder.java:71) 	  at org.springframework.web.reactive.function.client.DefaultExchangeStrategiesBuilder.(DefaultExchangeStrategiesBuilder.java:42) 	  at org.springframework.web.reactive.function.client.ExchangeStrategies.withDefaults(ExchangeStrategies.java:67) 	  at org.springframework.web.reactive.function.client.DefaultWebClientBuilder.initExchangeStrategies(DefaultWebClientBuilder.java:287) 	  at org.springframework.web.reactive.function.client.DefaultWebClientBuilder.build(DefaultWebClientBuilder.java:260) 	  at org.springframework.web.reactive.function.client.WebClient.create(WebClient.java:150) ```  I've worked around for now by running the file through `unix2dos`.","closed","in: core,","DanielThomas","2020-10-14T05:04:29Z","2020-10-23T22:18:24Z"
"","26770","Spring 4 ReflectUtil not compatible with jdk16","I maintain a library that has a Spring integration.  We of course encourage users to run spring 5, but also run unit tests against spring4 to make sure we don't introduce regressions for users on old Spring.  As of jdk16, spring `4.3.30.RELEASE` no longer works: ``` Caused by: java.lang.IllegalStateException: Cannot load configuration class: org.jdbi.v3.spring4.TestPluginInstall$Config 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurationClassPostProcessor.java:404) 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanFactory(ConfigurationClassPostProcessor.java:249) 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:283) 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:127) 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:687) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:524) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:127) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:281) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:249) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116) 	... 33 more  Caused by: java.lang.ExceptionInInitializerError 	at org.springframework.context.annotation.ConfigurationClassEnhancer.newEnhancer(ConfigurationClassEnhancer.java:122) 	at org.springframework.context.annotation.ConfigurationClassEnhancer.enhance(ConfigurationClassEnhancer.java:110) 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurationClassPostProcessor.java:394)  Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @5d20b857 	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:357) 	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) 	at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) 	at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) 	at org.springframework.cglib.core.ReflectUtils$1.run(ReflectUtils.java:61) 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554) 	at org.springframework.cglib.core.ReflectUtils.(ReflectUtils.java:52) 	at org.springframework.cglib.core.KeyFactory$Generator.generateClass(KeyFactory.java:243) 	at org.springframework.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:25) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:329) 	... 59 more ```  If Spring 4 is still supported, maybe some of the recent `ReflectUtils` jdk 16 changes from Spring 5 could be backported.  Thanks!","closed","in: core,","stevenschlansker","2021-04-06T17:16:18Z","2021-04-06T17:36:54Z"
"","26840","Allow to set TTL (and other QoS-related settings) on a per-message (and/or per-send) basis with JmsTemplate","I know there are at least two other issues on this topic: - #9856 describes the requirement and the context precisely; however it is very old and was closed in a bulk update - #24144 was closed because the request was probably asking for this feature in the wrong way, i.e. by violating the (objectively confusing) JMS API  With this I'm asking if you could reconsider to improve `JmsTemplate` so that it's possible to do this, especially in light of the existence now of Spring Boot, which configures a `JmsTemplate` for you (so the workaround to create a new `JmsTemplate` instance on each message send makes things much more complex than they could be).  Use case: I'm using `JmsTemplate` to send notifications; these notifications should have different expiration times depending on their context, which has itself an expiration after which all related notifications become stale and useless.  To workaround this, apart from the option to create new `JmsTemplates` on each send operation, there's the possibility to use one of the `execute(...)` overloadings that takes a `ProducerCallback` parameter, however in this case you're completely left alone with regards to the message creation and actual sending process, which is not trivial (see `org.springframework.jms.core.JmsTemplate.doSend(Session, Destination, MessageCreator)` implementation).","open","status: feedback-provided,","mauromol","2021-04-21T12:14:39Z","2021-11-10T11:41:10Z"
"","26791","Add information about changed behaviour for resolving @AuthenticationPrincipal annotation","I just spend a few hours trying to figure out why my upgrade from Spring Boot 2.3.4 to 2.4.4 was not working.   I am using Keycloak for authentication and my rest controller use this construct:  ``` public ... methodName(@AuthenticationPrincipal KeycloakAuthenticationToken principal) { ```  This works in Spring Boot 2.3.4, but not in Spring Boot 2.4.4. The reason for this is that in Spring 5.3.1 a [bug on ServletRequestMethodArgumentResolver](https://github.com/spring-projects/spring-framework/issues/25981) was fixed.  Before the fix, the KeycloakAuthenticationToken was injected in the controller method via the `ServletRequestMethodArgumentResolver`. After the fix, the injection is supposed to be done by the `AuthenticationPrincipalArgumentResolver`, but that resolver always taken the principal of the authentication object. It does not check if the authentication object itself is also a principal as in the case of Keycloak.  The workaround is to remove the `@AuthenticationPrincipal` annotation (which I find a pity, the annotation made it clear that this argument was getting injected by the framework).  Maybe a note can be added to the release notes for this as others([1](https://github.com/spring-projects/spring-framework/issues/26117),[2](https://github.com/spring-projects/spring-framework/issues/26380)) have also had the issue?","closed","type: documentation,","wimdeblauwe","2021-04-12T14:17:05Z","2021-04-21T16:28:53Z"
"","26842","HttpStatus.resolve allocates HttpStatus.values() once per invocation","I just noticed looking at profiles of some reactor based benchmarks we run to measure Datadog tracer overhead that `HttpStatus.resolve` allocates an `HttpStatus[]` once per invocation, so once per response. In a very modest throughput benchmark (~600rps) this is allocating 1MB/s just to resolve the integer status code to the `HttpStatus` enum value.   I tracked the spring framework code down [here](https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-web/src/main/java/org/springframework/http/HttpStatus.java#L553).  This could be fixed by caching `HttpStatus.values()` in an array, which could be iterated over as many times as one likes without any further allocation.","closed","type: enhancement,","richardstartin","2021-04-21T21:42:06Z","2021-04-22T13:40:31Z"
"","25995","WebFlux: add option to ServerHttpSecurity to allow custom ServerAuthenticationConverter","I have to integrate form login based with recaptcha v3, so I also need recaptcha and action parameters to be extracted from the POST (to make the call to recaptcha service).  With current infrastructure it is necessary to do it manually (see snippet below), just add an option to `ServerHttpSecurity` to configure it and use it:  ```java AuthenticationWebFilter authenticationFilter = new AuthenticationWebFilter(this.authenticationManager); authenticationFilter.setRequiresAuthenticationMatcher(this.requiresAuthenticationMatcher); authenticationFilter.setAuthenticationFailureHandler(this.authenticationFailureHandler); HERE ===> authenticationFilter.setAuthenticationConverter(new ServerFormLoginAuthenticationConverter()); <=== HERE authenticationFilter.setAuthenticationSuccessHandler(this.authenticationSuccessHandler); authenticationFilter.setSecurityContextRepository(this.securityContextRepository); http.addFilterAt(authenticationFilter, SecurityWebFiltersOrder.FORM_LOGIN); ```  I use this snippet to change it (I have also a custom `ReactiveAuthenticationManager`):  ```kotlin     @Bean     fun securityWebFilterChain(             serverHttpSecurity: ServerHttpSecurity     ):  SecurityWebFilterChain = serverHttpSecurity             .formLogin()             ...             .build().apply {                 webFilters.filter {                     it is AuthenticationWebFilter                 }.toStream().forEach {                     it as AuthenticationWebFilter                     it.setServerAuthenticationConverter(RecaptchaV3ServerFormLoginAuthenticationConverter())                 }             }     }   ```","closed","for: external-project,","userquin","2020-10-29T15:21:34Z","2020-10-30T11:29:15Z"
"","26396","Webflux multipart file upload length 0 in then operator","I have tested following code in Spring boot version 2.3.7.RELEASE and 2.4.2 ```java @RestController public class DemoController {      @PostMapping(""/transferTo"")     Flux transferTo(@RequestPart(""fileParts"") Flux parts) {         return parts.concatMap(filePart -> createTempFile(filePart.filename())                 .flatMap(tempFile -> filePart.transferTo(tempFile)                         .then(Mono.just(""File length: "" + tempFile.toFile().length()))));     }      private Mono createTempFile(String suffix) {         return Mono.defer(() -> {             try {                 return Mono.just(Files.createTempFile(""MultipartIntegrationTests"", suffix));             } catch (IOException ex) {                 return Mono.error(ex);             }           })                 .subscribeOn(Schedulers.boundedElastic());     } } ```  Response on http://localhost:8080/transferTo  With **2.3.7.RELEASE** File length: 13 With **2.4.2** File length: 0  File gets uploaded in both versions but I am unable to get content in 2.4.2 version inside `.then()` operator.  Sample to reproduce the issue - https://github.com/anupam-contaque/webflux-multipart-demo","closed","status: invalid,","anupam-contaque","2021-01-18T06:01:17Z","2021-01-18T11:30:31Z"
"","26087","Add ""application/java-archive"" MediaType","I have found myself using this type in a few projects, so I figured I would throw a PR up for it.","closed","status: declined,","kashike","2020-11-13T00:53:21Z","2020-11-13T05:40:08Z"
"","26018","WebFlux: Compression over http2 not working (Netty)","I have configured `server.compression.enabled=true` for `text/html` mime types, that are generated with `freemarker` template. The rest of resources are compressed at built time (vite).  Testing over `http` works as expected while activating `http2` the compression just does not work.  Is this an error or I'm missing something?  ![imagen](https://user-images.githubusercontent.com/6311119/97922821-5a5adb80-1d5d-11eb-930a-aadef6d6d656.png)  ![imagen](https://user-images.githubusercontent.com/6311119/97922936-870ef300-1d5d-11eb-8843-22977206b020.png)","closed","for: external-project,","userquin","2020-11-02T21:56:23Z","2020-11-14T14:02:04Z"
"","25896","readWithMessageConverters doesn't close FileInputStream","I have an issue with readWithMessageConverters(HttpInputMessage inputMessage, ...) in AbstractMessageConverterMethodArgumentResolver class.  It seems like this method initialize a new FileInputStream on calling inputMessage.getBody(), then the FileInputStream is read by calling: 1. genericConverter.read(..., inputMessage); OR 2. ((HttpMessageConverter) converter).read(targetClass, inputMessage);  This FileInputStream is getting closed on calling genericConverter.read(..., inputMessage) (Jackson as a genericConverter). But on calling ((HttpMessageConverter) converter).read(targetClass, inputMessage); with a converter of type StringHttpMessageConverter the FileInputStream is not closed.  There is no decumentation on HttpMessageConverter that indicates the read method should close the FileInputStream.  So I guess the ""readWithMessageConverters"" method should ensure the FileInputStream is closed.","closed","status: superseded,","SenseiFisher","2020-10-12T10:14:08Z","2022-01-11T09:37:31Z"
"","26745","Spring Boot 2.4.* and Java 11","I have a spring boot java app that I trying to port to Java 11. Perhaps due to module system or usage of ""internal"" API my app fails to start. Here's a portion of the stack trace:  ```   .   ____          _            __ _ _  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.4.3)  2021-03-29T17:25:59.216+0000 ERROR [ ""main""] [o.s.b.SpringApplication@856 ] Application run failed java.lang.NoClassDefFoundError: jdk/internal/reflect/GeneratedConstructorAccessor34 	at java.base/jdk.internal.reflect.GeneratedConstructorAccessor34.newInstance(Unknown Source) 	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) 	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490) 	at java.base/java.lang.reflect.Proxy.newProxyInstance(Proxy.java:1022) 	at java.base/java.lang.reflect.Proxy.newProxyInstance(Proxy.java:1008) 	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:306) 	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:304) 	at java.base/java.security.AccessController.doPrivileged(Native Method) 	at java.base/sun.reflect.annotation.AnnotationParser.annotationForMap(AnnotationParser.java:304) 	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:294) 	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:121) 	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:73) 	at java.base/java.lang.Class.createAnnotationData(Class.java:3757) 	at java.base/java.lang.Class.annotationData(Class.java:3746) 	at java.base/java.lang.Class.getAnnotation(Class.java:3651) 	at java.base/java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:274) 	at java.base/java.lang.Class.isAnnotationPresent(Class.java:3661) 	at org.springframework.core.type.filter.AnnotationTypeFilter.(AnnotationTypeFilter.java:83) 	at org.springframework.core.type.filter.AnnotationTypeFilter.(AnnotationTypeFilter.java:61) 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:206) 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.(ClassPathBeanDefinitionScanner.java:166) 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.(ClassPathBeanDefinitionScanner.java:140) 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.(ClassPathBeanDefinitionScanner.java:113) 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.(ClassPathBeanDefinitionScanner.java:85) 	at org.springframework.context.annotation.AnnotationConfigApplicationContext.(AnnotationConfigApplicationContext.java:71) 	at org.springframework.boot.ApplicationContextFactory.lambda$static$0(ApplicationContextFactory.java:52) 	at org.springframework.boot.SpringApplication.createApplicationContext(SpringApplication.java:597) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:323) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1311) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1300) 	at com.intuit.platform.jsk.sample.Application.main(Application.java:10) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:107) 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) 	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ```","closed","status: invalid,","qcloop","2021-03-30T16:20:31Z","2021-04-06T06:46:39Z"
"","26516","Scheduled class ScheduledTaskRegistrar to implement the InitializingBean interface","I have a question：  Why does ScheduledTaskRegistrar implement Interface InitializingBean？  afterPropertiesSet methods of class ScheduledTaskRegistrar are not in the Spring bean life cycle,Instead, it uses event listening","closed","for: stackoverflow,","MentosL","2021-02-07T09:21:26Z","2021-02-08T13:09:22Z"
"","26354","How to set encoding when use MappingJackson2HttpMessageConverter","i have a code like below ```java HttpHeaders headers = new HttpHeaders(); headers.add(HttpHeaders.CONTENT_TYPE, ""application/json;charset=EUC-KR""); headers.add(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);  RestTemplate restTemplate = RestUtils.getRestTemplate(readTimeout); Map response = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(params, headers), Map.class).getBody(); ````   Recently i updated spring 4.3* to 5.3*. After then it fail's to send request. Because, MappingJackson2HttpMessageConverter enforce encoding like UTF**(unicode)  ```java @Override public boolean canWrite(Class clazz, @Nullable MediaType mediaType) {     if (!canWrite(mediaType)) {         return false;     }     if (mediaType != null && mediaType.getCharset() != null) {         Charset charset = mediaType.getCharset();         if (!ENCODINGS.containsKey(charset.name())) {             return false;         }     }     AtomicReference causeRef = new AtomicReference<>();     if (this.objectMapper.canSerialize(clazz, causeRef)) {         return true;     }     logWarningIfNecessary(clazz, causeRef.get());     return false; } ```` ```java package com.fasterxml.jackson.core;  /**  * Enumeration that defines legal encodings that can be used  * for JSON content, based on list of allowed encodings from  * JSON specification.  *  * Note: if application want to explicitly disregard Encoding  * limitations (to read in JSON encoded using an encoding not  * listed as allowed), they can use {@link java.io.Reader} /  * {@link java.io.Writer} instances as input  */ public enum JsonEncoding {     UTF8(""UTF-8"", false, 8), // N/A for big-endian, really         UTF16_BE(""UTF-16BE"", true, 16),         UTF16_LE(""UTF-16LE"", false, 16),         UTF32_BE(""UTF-32BE"", true, 32),         UTF32_LE(""UTF-32LE"", false, 32)         ; ....... ```  how can i use 'euc-kr' as charset instead.","closed","in: web,","Clapmin","2021-01-07T13:30:36Z","2021-01-07T14:18:52Z"
"","26834","AbstractListenerReadPublisher publishing onComplete signal before onNext during heavy load","I have a case where a WebFlux application needs to perform some blocking work.  Therefore, I use `.subscribeOn(aBoundedElasticScheduler)` in the stream.  When doing so, I've noticed that sometimes during heavy load, inbound requests are not fully read.  After doing a lot of debugging, I believe I've narrowed it down to `AbstractListenerReadPublisher` publishing an `onComplete` signal _before_ an `onNext` signal in some cases, leading to the `onNext` signal being dropped.  * spring-boot 2.4.5 * spring 5.3.6 * tomcat 9.0.45  Example logging for a request that is not fully read, since `AbstractListenerReadPublisher` sends the `onComplete` signal _before_ the `onNext` signal.  ``` 00:25:52,141 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2b683da6] UNSUBSCRIBED -> SUBSCRIBING 00:25:52,141 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2b683da6] SUBSCRIBING -> NO_DEMAND 00:25:52,142 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.request:262] - [2b683da6] request 1 00:25:52,142 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2b683da6] NO_DEMAND -> DEMAND 00:25:52,142 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.onDataAvailable:117] - [2b683da6] onDataAvailable 00:25:52,142 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2b683da6] DEMAND -> READING  // onDataAvailable callback comes in from tomcat  00:25:52,141 [tomcat-1] [_.s.h.s.r.AbstractListenerReadPublisher.onDataAvailable:117] - [2b683da6] onDataAvailable  // meanwhile, reading is still being performed on a boundedElastic thread  00:25:52,142 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.logBytesRead:263] - [2b683da6] Read 938 bytes  // onAllDataRead callback comes in from tomcat  00:25:52,143 [tomcat-1] [_.s.h.s.r.AbstractListenerReadPublisher.onAllDataRead:128] - [2b683da6] onAllDataRead [READING] 00:25:52,143 [tomcat-1] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2b683da6] READING -> COMPLETED  // AbstractListenerReadPublisher.State.onAllDataRead sends onComplete signal  00:25:52,143 [sync-185] [_.s.h.s.r.AbstractListenerReadPublisher.readAndPublish:198] - [2b683da6] Publishing DefaultDataBuffer  // AbstractListenerReadPublisher.readAndPublish sends onNext signal. // This signal is eventually dropped, since it occurs after the onComplete sent above ```  For comparison, here is an example of a working request:  ``` 00:25:52,135 [tomcat-1] [_.s.h.s.r.AbstractListenerReadPublisher.onDataAvailable:117] - [2af765a0] onDataAvailable 00:25:52,137 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] UNSUBSCRIBED -> SUBSCRIBING 00:25:52,138 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] SUBSCRIBING -> NO_DEMAND 00:25:52,138 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.request:262] - [2af765a0] request 1 00:25:52,138 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] NO_DEMAND -> DEMAND 00:25:52,139 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.onDataAvailable:117] - [2af765a0] onDataAvailable 00:25:52,139 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] DEMAND -> READING 00:25:52,139 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.logBytesRead:263] - [2af765a0] Read 938 bytes 00:25:52,139 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.readAndPublish:198] - [2af765a0] Publishing DefaultDataBuffer 00:25:52,139 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] READING -> NO_DEMAND 00:25:52,140 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.request:262] - [2af765a0] request 1 00:25:52,140 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] NO_DEMAND -> DEMAND 00:25:52,141 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.onAllDataRead:128] - [2af765a0] onAllDataRead [DEMAND] 00:25:52,141 [sync-193] [_.s.h.s.r.AbstractListenerReadPublisher.changeState:215] - [2af765a0] DEMAND -> COMPLETED 00:25:52,203 [tomcat-2] [_.s.h.s.r.AbstractListenerReadPublisher.onAllDataRead:128] - [2af765a0] onAllDataRead [COMPLETED] ```  This is a pretty complex app, and I haven't tried to isolate it down into a small reproducible app (yet).  @rstoyanchev, I know you've been in this code a lot recently for another issue I filed (#26407).  Do you have any ideas off of the top of your head before I dive in deeper?","closed","type: bug,","philsttr","2021-04-21T01:43:53Z","2021-05-04T08:53:07Z"
"","25892","Allows Jackson2 encoders to log Throwable reason for not being able to serialize or deserialize","I have a `@RestController` `@RequestBody` that Jackson *should* be able to deserialize, but it can't because I made an error in my serialization setup. All I get in my application's logs is > org.springframework.web.server.UnsupportedMediaTypeStatusException: 415 UNSUPPORTED_MEDIA_TYPE ""Content type 'application/json' not supported for bodyType=CLASS_NAME""  Meanwhile there's a very helpful `IllegalArgumentException` from within Jackson that gets swallowed. Jackson actually propagates the exception all the way up to `ObjectMapper#canDeserialize(JavaType)`, where it sees that you haven't asked for that exception and swallows it. If we instead called `ObjectMapper#canSerialize(Class, AtomicReference)`, the consumer could do something with the exception. And the same is true of `ObjectMapper#canDeserialize`.  This changes Jackson2Encoder and Jackson2Decoder to call the canSerialize/canDeserialize methods that propagate the Throwable. It adds a hook where users can receive that Throwable and act on it if they want.","closed","type: enhancement,","Anusien","2020-10-09T23:56:35Z","2020-11-02T17:30:16Z"
"","25959","Async Request couldn't log response body by OncePerRequestFilter","I hava a simple controller, it has two method, One is synchronous and the other is asynchronous  ``` @RestController class HelloController {     @PostMapping(""/msg"")     fun createMsg(@RequestBody maps: Map): Map {         println(maps)         return mapOf(""code"" to ""success"")     }      @PostMapping(""/async/msg"")     fun asyncCreateMsg(@RequestBody maps: Map) = GlobalScope.future{         println(maps)         mapOf(""code"" to ""success"")     } } ```  I write a filter to log request and response body  ``` @Component class ApplicationRequestFilter : OncePerRequestFilter() {       companion object {         private val logger = LoggerFactory.getLogger(this::class.java)     }          override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {         val currTime = System.currentTimeMillis()         val requestWrapper = ContentCachingRequestWrapper(request)         val responseWrapper = ContentCachingResponseWrapper(response)         filterChain.doFilter(requestWrapper, responseWrapper)         val requestBody = String(requestWrapper.contentAsByteArray, Charset.forName(request.characterEncoding))         val responseBody = String(responseWrapper.contentAsByteArray, StandardCharsets.UTF_8)         logger.info(""request body: $requestBody"")         logger.info(""response body: $responseBody "")         responseWrapper.copyBodyToResponse()     }      } ```  when I request `POST /msg` ,  `ApplicationRequestFilter ` can log request and response body, you can also receive `{""code"" : ""success""}` result but I request `POST /async/msg`, `ApplicationRequestFilter ` can log request body, couldn't log response body, you can't receive `{""code"" : ""success""}` result  I think this is caused by asynchronous requests, response body has been written by other thread?  somebody can help resolve this problem? ：）","closed","for: stackoverflow,","SouthLight-Lin","2020-10-23T03:17:30Z","2020-10-26T07:34:50Z"
"","26750","Add advice on Spring MVC path matching for 5.3 and above to the reference documentation","I had noticed that in org.springframework.web.util.UrlPathHelper#decodeAndCleanUriString special url will be processed. `uri = removeSemicolonContent(uri); 		uri = decodeRequestString(request, uri); 		uri = getSanitizedPath(uri); 		return uri;`  With this process, uri like /;/a/b/c will be changed to //a/b/c, and  /;/a%2fb/c will be changed to //a/b/c. This can be different in Filter(for example, jetty)，which will confuse the developer. Sometime may cause security bug.  I'd like to ask, is the any specification like rfc, servlet specification, or anything else. If any specification available, we can follow it .  Thanks!","closed","type: documentation,","ZH3FENG","2021-04-01T14:11:04Z","2021-04-26T16:21:54Z"
"","26644","ApplicationListenerMethodAdapter not remove when ApplicationContext close.","I found the Adapter for @ EventListener was not remove when ApplicationContext close. But the ApplicationListener removed normally. this will make some error.  the code for reproduce it: ```java public static void main(String[] args) {   AnnotationConfigApplicationContext parent = new AnnotationConfigApplicationContext(SomeBean.class);    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();   ctx.setParent(parent);   ctx.refresh();     parent.close();    ctx.close();    // will throw exception }  @Service public class SomeBean {   @EventListener(ContextClosedEvent.class)   public void shutdown() {     System.out.println(""context closed"");   } } ```  We'll see exception like: ```java java.lang.IllegalStateException: org.springframework.context.annotation.AnnotationConfigApplicationContext@3d3fcdb0 has been closed already 	at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1093) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108) 	at org.springframework.context.event.ApplicationListenerMethodAdapter.getTargetBean(ApplicationListenerMethodAdapter.java:332) 	at org.springframework.context.event.ApplicationListenerMethodAdapter.doInvoke(ApplicationListenerMethodAdapter.java:297) 	at org.springframework.context.event.ApplicationListenerMethodAdapter.processEvent(ApplicationListenerMethodAdapter.java:190) 	at org.springframework.context.event.ApplicationListenerMethodAdapter.onApplicationEvent(ApplicationListenerMethodAdapter.java:153) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) 	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:410) 	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361) 	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1013) 	at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:979) ```","open","in: core,","UzimakiNaruto","2021-03-05T01:41:57Z","2021-11-11T09:32:06Z"
"","26576","Code doesn't match between AbstractApplicationContext and ApplicationContextAwareProcessor","I found that it does not match between the following code.  https://github.com/spring-projects/spring-framework/blob/274db2f7a934c1558eee25809ceab3982ab73e1c/spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java#L692-L695  https://github.com/spring-projects/spring-framework/blob/274db2f7a934c1558eee25809ceab3982ab73e1c/spring-context/src/main/java/org/springframework/context/support/ApplicationContextAwareProcessor.java#L82-L85  Should the `ApplicationStartup` in the first code be changed to `ApplicationStartupAware`?","closed","in: core,","symblsng","2021-02-20T07:49:30Z","2021-02-23T10:47:14Z"
"","25861","java.lang.NoClassDefFoundError: org/jetbrains/kotlin/cli/common/PropertiesKt","I followed the prompts in ""import-into-idea.md"" to import into idea. When I execute ""./gradlew :spring-oxm:compileTestJava"", the prompt is as follows: Caused by: java.lang.NoClassDefFoundError: org/jetbrains/kotlin/cli/common/PropertiesKt.","closed","","canrili","2020-10-06T10:31:35Z","2020-10-07T08:41:32Z"
"","26398","The improvement of PostProcessorRegistrationDelegate.registerBeanPostProcessors()","I find that the code of `PostProcessorRegistrationDelegate.registerBeanPostProcessors()` is a little illogical and I can improve the code with one time of `for`  compared with the original code ### Here is the original code ````java               public static void registerBeanPostProcessors( 			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {  		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);  		// Register BeanPostProcessorChecker that logs an info message when 		// a bean is created during BeanPostProcessor instantiation, i.e. when 		// a bean is not eligible for getting processed by all BeanPostProcessors. 		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; 		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));  		// Separate between BeanPostProcessors that implement PriorityOrdered, 		// Ordered, and the rest. 		List priorityOrderedPostProcessors = new ArrayList<>(); 		List internalPostProcessors = new ArrayList<>(); 		List orderedPostProcessorNames = new ArrayList<>(); 		List nonOrderedPostProcessorNames = new ArrayList<>(); 		for (String ppName : postProcessorNames) { 			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 				priorityOrderedPostProcessors.add(pp); 				if (pp instanceof MergedBeanDefinitionPostProcessor) { 					internalPostProcessors.add(pp); 				} 			} 			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { 				orderedPostProcessorNames.add(ppName); 			} 			else { 				nonOrderedPostProcessorNames.add(ppName); 			} 		}  		// First, register the BeanPostProcessors that implement PriorityOrdered. 		sortPostProcessors(priorityOrderedPostProcessors, beanFactory); 		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);  		// Next, register the BeanPostProcessors that implement Ordered. 		List orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size()); 		for (String ppName : orderedPostProcessorNames) { 			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 			orderedPostProcessors.add(pp); 			if (pp instanceof MergedBeanDefinitionPostProcessor) { 				internalPostProcessors.add(pp); 			} 		} 		sortPostProcessors(orderedPostProcessors, beanFactory); 		registerBeanPostProcessors(beanFactory, orderedPostProcessors);  		// Now, register all regular BeanPostProcessors. 		List nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size()); 		for (String ppName : nonOrderedPostProcessorNames) { 			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 			nonOrderedPostProcessors.add(pp); 			if (pp instanceof MergedBeanDefinitionPostProcessor) { 				internalPostProcessors.add(pp); 			} 		} 		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);  		// Finally, re-register all internal BeanPostProcessors. 		sortPostProcessors(internalPostProcessors, beanFactory); 		registerBeanPostProcessors(beanFactory, internalPostProcessors);  		// Re-register post-processor for detecting inner beans as ApplicationListeners, 		// moving it to the end of the processor chain (for picking up proxies etc). 		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); 	} ```` and this is my opinion,  ````java                public static void registerBeanPostProcessors( 			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {  		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);  		// Register BeanPostProcessorChecker that logs an info message when 		// a bean is created during BeanPostProcessor instantiation, i.e. when 		// a bean is not eligible for getting processed by all BeanPostProcessors. 		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; 		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));  		// Separate between BeanPostProcessors that implement PriorityOrdered, 		// Ordered, and the rest. 		List priorityOrderedPostProcessors = new ArrayList<>(); 		List internalPostProcessors = new ArrayList<>(); 		List orderedPostProcessors = new ArrayList<>(); 		List nonOrderedPostProcessors = new ArrayList<>(); 		for (String ppName : postProcessorNames) { 			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 			if (pp instanceof MergedBeanDefinitionPostProcessor) { 				internalPostProcessors.add(pp); 			} 			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 				priorityOrderedPostProcessors.add(pp); 			} 			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { 				orderedPostProcessors.add(pp); 			} 			else { 				nonOrderedPostProcessors.add(pp); 			} 		}  		// First, register the BeanPostProcessors that implement PriorityOrdered. 		sortPostProcessors(priorityOrderedPostProcessors, beanFactory); 		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);  		// Next, register the BeanPostProcessors that implement Ordered. 		sortPostProcessors(orderedPostProcessors, beanFactory); 		registerBeanPostProcessors(beanFactory, orderedPostProcessors);  		// Now, register all regular BeanPostProcessors. 		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);  		// Finally, re-register all internal BeanPostProcessors. 		sortPostProcessors(internalPostProcessors, beanFactory); 		registerBeanPostProcessors(beanFactory, internalPostProcessors);  		// Re-register post-processor for detecting inner beans as ApplicationListeners, 		// moving it to the end of the processor chain (for picking up proxies etc). 		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); 	} ```` could I submit a merge request to the project?","closed","in: core,","Jirath-Liu","2021-01-18T12:17:09Z","2021-01-28T13:44:37Z"
"","26634","Optimize initialization size of temporary ArrayLists in ReflectionUtils","I feel that there is no need to specify the initial size for this ArrayList, just use the default initial size is enough.","closed","in: core,","chenqimiao","2021-03-03T11:55:00Z","2021-04-29T13:59:00Z"
"","26059","Provide possibility to configure base path for WebTestClient instance","I don't get why #26039 is closed, but I think my use case is valid. I use `WebTestClient` to write integration tests (using my own library based on spring-cloud-wiremock) to test servlet-based applications. There are no mocks at all and I'm not gonna use `MockMvc`, the sample is the following:  ``` @SpringBootTest(     webEnvironment = WebEnvironment.RANDOM_PORT,     classes = SampleApplicationTest.SampleApplication.class) @TestPropertySource(properties = ""server.servlet.context-path=/test"") class SampleApplicationTest {    @Autowired   private TestRestTemplate testRestTemplate;   @Autowired   private WebTestClient webTestClient;    @Test   void shouldReturnResources() {     var actual = testRestTemplate.getForEntity(""/resources"", String.class);     assertThat(actual.getStatusCode()).isEqualTo(OK);     assertThat(actual.getBody()).isEqualTo(""test-resource"");       webTestClient.get().uri(""/resources"").exchange()         // will fail with 404 cos context path is not configured         .expectStatus().isOk()         .expectBody(String.class).isEqualTo(""test-resource"");   }    @SpringBootApplication   static class SampleApplication {      static void main(String[] args) {       SpringApplication.run(SampleApplication.class, args);     }      @RestController     static class Controller {       @GetMapping(""/resources"")       String resources() {         return ""test-resource"";       }     }   } } ```  I'd like to have possibility to configure baseUrl for `WebTestClient`, so I can allow consumers of the library to use either `TestRestTemplate` or `WebTestClient` using the same url. Currently there is no way to customize base path for `WebTestClient`.","closed","status: duplicate,","20fps","2020-11-10T11:09:56Z","2020-11-10T11:59:18Z"
"","25941","spring webflux- header is null in webfilter","I developed a simple org.springframework.web.server.WebFilter, in a reactive application based on Spring Boot 2.3.4, to log the HTTP request header and response details.  The filter method is basically:  ``` public Mono filter(ServerWebExchange exchange, WebFilterChain chain) {   System.out.println(""Status="" + exchange.getRequest().getHeader());  //returns value   System.out.println(""Status="" + exchange.getRequest().getMethodValue());  //returns value         return chain.filter(exchange).doAfterTerminate(() -> {             System.out.println(""Status="" + exchange.getRequest().getHeader());  //returns null             System.out.println(""Status="" + exchange.getRequest().getMethodValue());   //returns null        }); } ```  For many REST controller methods the logged header is null and methodvalue also null after the controller method gets executed.   **Note**: I am able to get the value from exchange before **.doAfterTerminate** . **Note**: I dont have options to modify the controller code to return ResponseEntity<>.   Is there any way to fix this issue without changing the controller return type.?","closed","status: invalid,","Esakkimuthu991","2020-10-20T06:15:56Z","2020-10-20T08:10:32Z"
"","26346","Spring Security5 + WebFlux + JWT","I currently use Spring Zuul with spring security to dynamically release url and routing mycoservices.  So instead of adding -  `.antMatchers(""/api/AgendarCotacaoWSPort/**"").HasRole(""NAO_CORRENTISTA "")` I added in my class the function that loads the role belonging to the url with .withObjectPostProcessor to call my class that searches the database for the url.  My DynamicSecurity Class implements the `FilterInvocationSecurityMetadataSource` which gives me permission to add in the `Collection` the relevant url to that URL.  I am currently studying Spring Cloud Gateway with Spring WebFlux and have not found a way to do the same thing instead of adding  `.pathMatchers (""/login"").HasRole(""TEST"") ` for each service that I want to release effect the release so that it searches the database (Redis) and returns in the settings which is the role for that endpoint that it is trying to access.  Does anyone have any idea how I can do this in the new spring security model with webflux?   My Class SecurityConfig.java  ``` import javax.servlet.http.HttpServletResponse;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.security.config.annotation.ObjectPostProcessor; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.web.access.AccessDeniedHandler; import org.springframework.security.web.access.intercept.FilterSecurityInterceptor; import org.springframework.security.web.authentication.AuthenticationFailureHandler; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;  import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;    @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter {  	@Autowired 	private DynamicSecurity dynamicSecurity;   	 	@Autowired 	private UrlAccessDecisionManager accessDecisionManager; 	     @Autowired     private SessionInterceptorFilter sessionFilter;      @Bean     public JwtAuthenticationConfig jwtConfig() {         return new JwtAuthenticationConfig();     }      	 private static final String[] AUTH_WHITELIST = { 	            ""**/v2/api-docs"", 	            ""/swagger-resources"", 	            ""/swagger-resources/**"", 	            ""/swagger-ui.html"", 	            ""/configuration/ui"", 	            ""/configuration/security"", 	            ""/webjars/**"", 	            ""/brasilsegapi/**"", 	            ""/health"" 	    };  	  	    @Override 	    public void configure(WebSecurity web) throws Exception { 	        web.ignoring() 	                .antMatchers(""/login"") 	                .antMatchers(""/loginoauthbb/**"") 	                .antMatchers(""/oauth/**"") 	                .antMatchers(""/logoff"") 	                .antMatchers(""/health"") 	                .antMatchers(""**/healthcheck"") 	                .antMatchers(""/alterarsenha"") 	                .antMatchers(""/esquecisenha"") 	                .antMatchers(""/criarusuario"") 	                .antMatchers(""/alteraremail"") 	                .antMatchers(""/resetsenha"") 	                .antMatchers(""/actuator"") 	                .antMatchers(""/actuator/**"") 	                .antMatchers(AUTH_WHITELIST) 	                .antMatchers(""/api/ConsultarInformacoesOuvidoria/**"") 	                .antMatchers(""/api/ValidacaoProtocoloSirWSPort/**"") 	                .antMatchers(""/api/AgendamentoCotacaoWSPort/**"") 	                .antMatchers(""/api/ConsultarDadosAgile/**"") 	                .antMatchers(""/api/EnviarDadosFormulario/**"") 	                .antMatchers(""/api/sensoriamento-mobile/login/**"") 	                .antMatchers(""/swagger-ui.html"") 	                .antMatchers(""/favicon.ico"") 					.antMatchers(""/api/MobileInstitucionalWSPort/**"") 					.antMatchers(""/api/DadosClienteWSPort/**"") 			; 	    } 	  	       protected void configure(final HttpSecurity http) throws Exception {          http                 .cors().and()                 .csrf().disable()                 .authorizeRequests()                 .antMatchers(""/"").denyAll()                 .withObjectPostProcessor(new ObjectPostProcessor() {                 	public  O postProcess(                 			O fsi) {                 		fsi.setSecurityMetadataSource(dynamicSecurity);                 		fsi.setAccessDecisionManager(accessDecisionManager);                 		return fsi;                 	}                 })                 .and()                 .addFilterBefore(sessionFilter, UsernamePasswordAuthenticationFilter.class)                 .logout()                 .deleteCookies(""auth_code"", ""JSESSIONID"").invalidateHttpSession(true)                 .logoutSuccessHandler(logoutSuccessHandler())                 .and()                  .exceptionHandling().accessDeniedHandler(accessDeniedHandler())                 .and()                 .exceptionHandling().authenticationEntryPoint(                 (req, rsp, e) -> rsp.sendError(HttpServletResponse.SC_FORBIDDEN, e.getMessage()));      }       @Bean     public LogoutSuccessHandler logoutSuccessHandler() {         return new CustomLogoutSuccessHandler();     }      @Bean     public AuthenticationFailureHandler authenticationFailureHandler() {         return new CustomAuthenticationFailureHandler();     }      @Bean     public AccessDeniedHandler accessDeniedHandler() {         return new CustomAccessDeniedHandler();     }  }  ```  My Class DynamicSecurity  ``` import java.io.IOException; import java.util.Collection; import java.util.Optional; import java.util.stream.Collectors;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.access.ConfigAttribute; import org.springframework.security.web.FilterInvocation; import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource; import org.springframework.stereotype.Component;  @Component public class DynamicSecurity implements FilterInvocationSecurityMetadataSource {  	@Autowired 	RoleRepository roleRepository;  	@Override 	public Collection getAttributes(Object object) throws IllegalArgumentException { 		final HttpServletRequest request = ((FilterInvocation) object).getRequest(); 		final HttpServletResponse response = ((FilterInvocation) object).getResponse();  		String urlWithoutContextPath = request.getRequestURI().substring(request.getContextPath().length());  		Optional foundUrl = roleRepository.findByUri(urlWithoutContextPath); 		if (foundUrl.isPresent()) { 			System.out.println( 					foundUrl.get().getRolesAllowed().stream().map(this::configAttribute).collect(Collectors.toList()));  			return foundUrl.get().getRolesAllowed().stream().map(this::configAttribute).collect(Collectors.toList()); 		} else if (urlWithoutContextPath.equals(""/login"") || urlWithoutContextPath.equals(""/alterarsenha"") 				|| urlWithoutContextPath.equals(""/esquecisenha"") || urlWithoutContextPath.equals(""/health"")) {  			return null; 		} else {  			try { 				response.sendError(403, ""acesso negado""); 			} catch (IOException e) { 				e.printStackTrace(); 			} 		} 		return null; 	}  	@Override 	public boolean supports(Class clazz) { 		// TODO Auto-generated method stub 		return FilterInvocation.class.isAssignableFrom(clazz); 	}  	private ConfigAttribute configAttribute(Roles role) { 		return new ConfigAttribute() { 			private static final long serialVersionUID = -474661209383691172L;  			@Override 			public String getAttribute() { 				return role.getAuthority(); 			} 		}; 	}  	@Override 	public Collection getAllConfigAttributes() { 		// TODO Auto-generated method stub 		return null; 	} } ```","closed","for: stackoverflow,","littiele","2021-01-05T14:57:23Z","2021-01-05T15:11:12Z"
"","25887","Does Spring AOP support pertypewithin?","I can write like this.  ```java @Component @Aspect(""pertypewithin(com..*)"") @Scope(""prototype"") public class TimeAspect {       @Pointcut(""execution(* com.dngzs.spring.service..*.*(..))"")     public void time() {     }      @Before(""time()"")     public void before(JoinPoint joinpoint) {         System.out.println(""before："" + joinpoint);     } } ```  The [official document](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-instantiation-models) is written like this:  > Spring supports AspectJ’s `perthis` and `pertarget` instantiation models; `percflow`, `percflowbelow`, and `pertypewithin` are not currently supported.  Is my example wrong？","open","in: core,","dngzs","2020-10-09T13:11:41Z","2020-10-15T06:01:36Z"
"","26847","Automatically detect init and destroy @Sql scripts","I am writing in the context of the SQL script execution in integration tests.  Spring [documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-executing-sql) says about default script detection.  > **Default Script Detection** >  > If no SQL scripts or statements are specified, an attempt is made to detect a default script, depending on where @Sql is declared. If a default cannot be detected, an IllegalStateException is thrown. >  > - Class-level declaration: If the annotated test class is com.example.MyTest, the corresponding default script is classpath:com/example/MyTest.sql. >  > - Method-level declaration: If the annotated test method is named testMethod() and is defined in the class com.example.MyTest, the corresponding default script is classpath:com/example/MyTest.testMethod.sql.  This is an awesome feature. Since I am working with both create and destroy script (before- and after-test), it would be interesting to introduce a convention for post-method scripts  Today I have a project where I introduce `@Sql` for both scripts (note that I didn't know about the existing convention, so I used an underscore on my own)  ```java @Sql(value=""/com/acme/MyClass_myMethod_init.sql"") @Sql(value=""/com/acme/MyClass_myMethod_destroy.sql"", executionPhase = AFTER_TEST_METHOD) @Test public void myMethod() ```  It could be interesting that scripts named `MyClass.myMethod.after.sql` run after test, as well as scripts named `MyClass.myMethod.before.sql` (**and** `MyClass.myMethod.sql` to preserve backward compatibility) are run before.   I haven't tried anything else yet.","closed","type: enhancement,","djechelon","2021-04-22T12:42:35Z","2021-08-19T15:14:38Z"
"","26019","Autowiring does not work reliably in case of dynamically changing prototype bean class","I am using springboot 2.3.5.RELEASE, have one BeanFactory to load prototype beans implements one interface. One has a bean to be autowired, another doesn't have the bean.  ```     @Bean     @Scope(value = ""prototype"")     public DemoInterface getDemoBean( int i) {         switch ( i) {             case 1: return new DemoClassOne();             case 2:             default:                 return new DemoClassTwo();          }     } ```  ``` public class DemoClassOne extends AbstractDemoClass {     @Autowired     Bean2BeAutowired bean2BeAutowired; } ```  ``` public class DemoClassTwo extends AbstractDemoClass { } ```  If I load BeanOne first, the bean2BeAutowired works fine, but after I load another bean, then generate bean one, the bean2BeAutowired will be null.  ```     @Test     void contextLoads() {         DemoInterface a1 = ctx.getBean(DemoInterface.class, 1);         System.out.println( a1);         System.out.println( ""bean2BeAutowired is ok: ""+((DemoClassOne)a1).bean2BeAutowired);          DemoInterface a2 = ctx.getBean( DemoInterface.class, 2);         System.out.println( a2);          DemoInterface a3 = ctx.getBean( DemoInterface.class, 1);         // ctx.getAutowireCapableBeanFactory().autowireBean( a1);         System.out.println( a3);         System.out.println( ""bean2BeAutowired is null: ""+((DemoClassOne)a3).bean2BeAutowired);     } ``` The output is: ``` com.example.demo.DemoClassOne@7561db12 bean2BeAutowired is ok: com.example.demo.Bean2BeAutowired@3301500b com.example.demo.DemoClassTwo@15deb1dc com.example.demo.DemoClassOne@6e9c413e bean2BeAutowired is null: null ```  It means after I load bean2, the bean1 will not autowired bean2BeAutowired. The demo code is attached.  [demo.tar.gz](https://github.com/spring-projects/spring-boot/files/5478917/demo.tar.gz)","closed","in: core,","simonlei","2020-11-03T02:12:33Z","2020-11-04T15:53:27Z"
"","26571","Unable to use property placeholders in BeanPostProcessor","I am using Spring with a legacy Tomcat application (not Spring Boot) that comes with Spring Boot BOM 2.4.3.    In my `BeanPostProcessor` I have `@Value(""${spring.kafka.maximumRequestSize:15728640}"")`.  However, it does not appear to evaluate property placeholders correctly.  I have an [MVCE](https://github.com/trajano/spring-beanpostproc-mvce) that shows this.  The result is   ```         Caused by: org.springframework.beans.TypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: ""${spring.kafka.maximumRequestSize:15728640}""                 at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:79)                 at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1328)                 at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300)                 at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657)                 ... 57 more         Caused by: java.lang.NumberFormatException: For input string: ""${spring.kafka.maximumRequestSize:15728640}""                 at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)                 at java.base/java.lang.Integer.parseInt(Integer.java:638)                 at java.base/java.lang.Integer.valueOf(Integer.java:983)                 at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:211)                 at org.springframework.beans.propertyeditors.CustomNumberEditor.setAsText(CustomNumberEditor.java:115)                 at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:429)                 at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:402)                 at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:155)                 at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)                 ... 60 more ```  Related Stack Overflow question https://stackoverflow.com/questions/66278338/how-do-i-get-spel-expressions-to-work-in-a-beanpostprocessor-that-is-application?noredirect=1#comment117183151_66278338","closed","in: core,","trajano","2021-02-19T18:19:23Z","2021-02-22T15:50:22Z"
"","25949","CommonsRequestLoggingFilter log only before request","I am using CommonsRequestLoggingFilter to log incoming requests, but I am interested only in the start of the request and don`t want to log after request. I have extended logging filter to ignore logging after request like this: ``` public class CommonsRequestLoggingFilterIgnoringAfterRequest extends CommonsRequestLoggingFilter {      @Override     protected void afterRequest(HttpServletRequest request, String message) {         // do not log after request     } } ``` But it would be nice to introduce property like `boolean ignoreAfterRequest` which I could pass to out of the box request logging filter. Would it make sense to introduce it?","closed","status: declined,","OskarsPakers","2020-10-21T14:12:31Z","2020-10-29T10:22:44Z"
"","26672","Autowiring bean with generic type in service with bounded generic type result in NoSuchBeanDefinitionException","I am trying to autowire bean with generic type (for expample IService) in other service with bounded generic type (DependingServiceNotWorking). This resulted in throwing NoSuchBeanDefinitionException. For legacy issues in project where I found this issue, autowiring of DependingServiceNotWorking bean is manual by beanFactory.autowireBean(..).  Please see following repositories for reproduction: https://github.com/paloliska/autowiring-bug https://github.com/paloliska/autowiring-bug-boot  **Affects:** spring-boot 2.4.3, spring-core 5.2.9.RELEASE","closed","status: invalid,","paloliska","2021-03-12T20:21:40Z","2021-03-16T13:01:50Z"
"","26289","Problem with @Schedule with Quartz features in CronExpression","I am running with Spring Boot **v2.4.1** and Spring **v5.3.2**  With I try to run with `@Scheduled(cron = ""0 0 10 ? * TUE#1"")` **works fine**, as discussed in #22436.  But when I try to run with `@Scheduled(cron = ""0 0 10 ? * TUE#1,TUE#3,TUE#5"")` it gives the error below.  My code example is as follows: ```java import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled;  @SpringBootApplication @EnableScheduling public class TestScheduledApplication{     public static void main(String[] args) {         SpringApplication.run(TestScheduledApplication.class, args);     }     @Scheduled(cron = ""0 0 10 ? * TUE#1,TUE#3,TUE#5"")     public void testScheduled(){         System.out.println(""hello world"");     } } ``` Error: ``` Caused by: java.lang.IllegalStateException: Encountered invalid @Scheduled method 'testScheduled': For input string: ""2#1,2#3,2"" in cron expression ""0 0 10 ? * TUE#1,TUE#3,TUE#5"" 	at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.processScheduled(ScheduledAnnotationBeanPostProcessor.java:511) 	at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.lambda$null$1(ScheduledAnnotationBeanPostProcessor.java:374) 	at java.lang.Iterable.forEach(Iterable.java:75) 	at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.lambda$postProcessAfterInitialization$2(ScheduledAnnotationBeanPostProcessor.java:374) 	at java.util.LinkedHashMap.forEach(LinkedHashMap.java:684) 	at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.postProcessAfterInitialization(ScheduledAnnotationBeanPostProcessor.java:373) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:444) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:609) ```  Is this a real issue or is not suported at all?  PS: As workaround I'm creating 3 separated schedules:  `@Scheduled(cron = ""0 0 10 ? * TUE#1""), @Scheduled(cron = ""0 0 10 ? * TUE#3""), @Scheduled(cron = ""0 0 10 ? * TUE#5"")`","closed","type: enhancement,","alvaro-nogueira","2020-12-16T19:55:26Z","2021-01-07T13:33:50Z"
"","26727","@Valid occasionally throws ConstraintDeclarationException from Hibernate Validator on docker (JDK openjdk:16-jdk-alpine, Spring boot v2.2.7.RELEASE)","I am running the code inside Docker,  From openjdk:16-jdk-alpine Spring boot v2.2.7.RELEASE  I have an interface like this:  ` ``` @RequestMapping(value = ""/documents/{documentId}"",             produces = {""application/json""},             method = RequestMethod.GET)     ResponseEntity getDocument(             @PathVariable(""documentId"") Integer documentId,             @NotNull @Valid @RequestParam(value = ""sessionId"", required = true) String sessionId,             @RequestParam(value = ""userId"", required = true) @NotNull @Valid int userId)             throws IOException, UnauthorizedException, InstanceNotFoundException, TimeoutException; ````  The implementation looks like this:  ```` @Override     public ResponseEntity getDocument(Integer documentId, String sessionId, int userId) throws IOException, UnauthorizedException, InstanceNotFoundException, TimeoutException     { ````  After running the application for couple of days, I get this error:  ``` javax.validation.ConstraintDeclarationException: HV000152: Two methods defined in parallel types must not declare parameter constraints, if they are overridden by the same method, but method s DocumentsApiController#getDocument(Integer, Boolean, String, int) and DocumentsApi#getDocument(Integer, Boolean, String, int) both define parameter constraints.         at org.hibernate.validator.internal.metadata.aggregated.rule.ParallelMethodsMustNotDefineParameterConstraints.apply(ParallelMethodsMustNotDefineParameterConstraints.java:23) ~[hibern ate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.assertCorrectnessOfConfiguration(ExecutableMetaData.java:461) ~[hibernate-validator-6.0.19.Final.ja r!/:6.0.19.Final]         at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:377) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:213) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:175) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:265) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:233) ~[hibernate-validator-6.0.19.Final.jar!/:6.0.19.Final]         at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:105) ~[spring-context-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ~[spring-aop-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at mycompany.api.DocumentsApiController$$EnhancerBySpringCGLIB$$65989de9.getPage() ~[classes!/:0.0.1-SNAPSHOT]         at jdk.internal.reflect.GeneratedMethodAccessor84.invoke(Unknown Source) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]         at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2 .6.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5 .2.6.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6. RELEASE]         at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:109) ~[spring-boot-actuator-2.2.7.RELEASE.jar!/:2.2.7.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.6.RELEASE.jar!/:5.2.6.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na]         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na]         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.34.jar!/:9.0.34]         at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]  ```","open","in: web,","abmjunaed","2021-03-25T15:42:57Z","2021-11-08T11:41:48Z"
"","26178","Spring WebFlux body runs 2 times","I am not sure if I am doing something wrong here but the below code in Spring WebFlux runs 2 times. I am using Spring Boot 2.3.3.RELEASE and MongoDB as database.  There are 3 repositories called: sessionRepo, userRepo, requestRepo  ``` public Mono createUpdateUser(Request request) {   return sessionRepo     .findBySid(request.getId())     .log()     .flatMap(sessionInfo -> userRepo.findById(sessionInfo.getUid())             .log()             .map(quoteDocument -> {                  // other update user logic                 userRepo.save(user).subscribe();                 return success;             })             .onErrorReturn().defaultIfEmpty())     .switchIfEmpty(createNewUser(request))     .onErrorReturn());     } ```   ``` public Mono createNewUser(Request request){    return requestRepo.findById(request.getRequestInfo().getId())      .log()      .map(requestInfo -> {         // other create user logic         userRepo.save(user).subscribe();         return success;       })       .defaultIfEmpty()       .onErrorReturn(); }  ```  I have noticed most of my code runs 2 times. But all the API’s where I must create new ID’s like session-id and send it to the Front end it always sends the second one creating a duplicate in the database.  Even switchIfEmpty runs 2 times.","closed","for: stackoverflow,","prathambongale5","2020-11-30T09:46:06Z","2020-11-30T16:11:30Z"
"","25919","Cannot access spring repo: 401 , probably wrong permissions","I am not able to download from spring repo without error.  ```bash Download https://plugins.gradle.org/m2/org/jfrog/buildinfo/build-info-api/2.7.5/build-info-api-2.7.5.jar FAILURE: Build failed with an exception. * What went wrong: A problem occurred configuring root project 'api'. > Could not resolve all files for configuration ':classpath'.    > Could not download build-info-extractor-gradle.jar (org.jfrog.buildinfo:build-info-extractor-gradle:4.4.15)       > Could not get resource 'https://repo.spring.io/plugins-release/org/jfrog/buildinfo/build-info-extractor-gradle/4.4.15/build-info-extractor-gradle-4.4.15.jar'.          > Could not GET 'https://repo.spring.io/plugins-release/org/jfrog/buildinfo/build-info-extractor-gradle/4.4.15/build-info-extractor-gradle-4.4.15.jar'. Received status code 401 from server: Unauthorized    > Could not download build-info-client.jar (org.jfrog.buildinfo:build-info-client:2.7.5)       > Could not get resource 'https://repo.spring.io/plugins-release/org/jfrog/buildinfo/build-info-client/2.7.5/build-info-client-2.7.5.jar'.          > Could not GET 'https://repo.spring.io/plugins-release/org/jfrog/buildinfo/build-info-client/2.7.5/build-info-client-2.7.5.jar'. Received status code 401 from server: Unauthorized * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. ```  This is my `build.gradle`:  ```gradle buildscript {     repositories {         mavenCentral()          maven {             url ""https://repo.spring.io/plugins-release""         }         maven {             url ""https://plugins.gradle.org/m2/""         }          mavenLocal()     }      dependencies {         classpath(""org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"")         classpath(""se.transmode.gradle:gradle-docker:${gradleDockerVersion}"")         classpath(""org.springframework.build.gradle:propdeps-plugin:${propdepsPluginVersion}"")         classpath(""org.jfrog.buildinfo:build-info-extractor-gradle:${buildInfoExtractorGradleVersion}"")         classpath(""org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:${sonarqubeGradlePluginVersion}"")         classpath(""com.netflix.nebula:gradle-aggregate-javadocs-plugin:${nebulaAggregateJavadocsVersion}"")     } ```   I noticed the new error today, is this a mistake of configuration? The `.pom` is accessible without auth.","closed","status: invalid,","kopax","2020-10-15T13:21:45Z","2020-10-16T07:29:17Z"
"","26269","Cannot access spring repo: 401 repo.spring.io/libs-release 401 Unauthorized error","I am not able to download from spring repo without error.  `[INFO] Building chain-integrations 2.12-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- Downloading from spring-releases: https://repo.spring.io/libs-release/org/apache/httpcomponents/httpclient/4.5/httpclient-4.5.pom Downloading from spring-releases: https://repo.spring.io/libs-release/org/glassfish/jersey/media/jersey-media-json-jackson/2.7/jersey-media-json-jackson-2.7.pom Downloading from spring-releases: https://repo.spring.io/libs-release/org/ehcache/ehcache/3.1.3/ehcache-3.1.3.pom Downloading from spring-releases: https://repo.spring.io/libs-release/org/elasticsearch/elasticsearch/5.6.0/elasticsearch-5.6.0.pom Downloading from spring-releases: https://repo.spring.io/libs-release/org/elasticsearch/client/elasticsearch-rest-high-level-client/5.6.0/elasticsearch-rest-high-level-client-5.6.0.pom Downloading from spring-releases: https://repo.spring.io/libs-release/org/elasticsearch/client/elasticsearch-rest-client/5.6.0/elasticsearch-rest-client-5.6.0.pom [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time:  1.723 s [INFO] Finished at: 2020-12-14T16:15:18-05:00 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal on project chain-integrations: Could not resolve dependencies for project com.cisco.chain.enterprise:chain-integrations:jar:2.12-SNAPSHOT: Failed to collect dependencies at org.apache.httpcomponents:httpclient:jar:4.5: Failed to read artifact descriptor for org.apache.httpcomponents:httpclient:jar:4.5: Could not transfer artifact org.apache.httpcomponents:httpclient:pom:4.5 from/to spring-releases (https://repo.spring.io/libs-release): Authentication failed for https://repo.spring.io/libs-release/org/apache/httpcomponents/httpclient/4.5/httpclient-4.5.pom 401 Unauthorized -> [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. `   `` This is my pom.xml:  `		 		             spring-releases             Spring Releases             https://repo.spring.io/libs-release         `   **Affects:** \  ---","closed","status: invalid,","rajadas665","2020-12-14T21:36:28Z","2020-12-14T22:00:46Z"
"","26844","Is it possible to make parts of request mapping as optional using some regex pattern?","https://stackoverflow.com/questions/67190406/spring-boot-can-we-have-parts-of-request-mapping-as-optional-using-regex  All the details are mentioned in the stackoverflow question. If anything else is required, please let me know.  If this kind of functionality is supported by spring, please provide some examples for it.","closed","in: web,","hiteshchopra","2021-04-22T03:02:17Z","2021-05-09T15:00:04Z"
"","26820","Why does the same spring websocket client work in a desktop java application, but does not work on android?","https://stackoverflow.com/questions/67136427/why-does-the-same-spring-websocket-client-work-in-a-desktop-java-application-bu  What could be wrong?","open","in: web,","smirok","2021-04-17T14:44:58Z","2021-11-10T11:43:12Z"
"","26510","Upgrade to JUnit 5.7.1","https://junit.org/junit5/docs/5.7.1/release-notes/","closed","type: dependency-upgrade,","sbrannen","2021-02-04T20:38:14Z","2021-02-04T20:48:23Z"
"","26556","Fix build output directory for ref docs in CONTRIBUTING.md","https://github.com/spring-projects/spring-framework/blob/fd49c8f598a9ce33f7ce14ace31c86856819776b/gradle/docs.gradle#L150-L168 (`fd49c8f` is latest commit of master branch) As you can see, I think it should be `build/docs/ref-docs/html5` directory, not a `build/asciidoc/html5` directory.","closed","type: documentation,","cprayer","2021-02-16T17:07:53Z","2021-02-17T00:40:29Z"
"","26363","NullPointerException when trying to serialize a null MappingJacksonValue","https://github.com/spring-projects/spring-framework/blob/d159cb65915840b2dc2297ee6b40309b8aa5d2aa/spring-web/src/main/java/org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter.java#L267  In Branch 4.3.x, there is a null check for `value`. For whatever reason, 5.x doesn't have that check which results in a NullPointerException.","closed","type: enhancement,","DanielArseneault","2021-01-08T14:11:19Z","2021-01-27T17:15:49Z"
"","26715","@Transactional's noRollbackFor attribute ignored from caller's TransactionAttributeSource","https://github.com/spring-projects/spring-framework/blob/5b2ace57423148bc9fd6af864e4c7c1eb04d515b/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L341  Hi, I have two services:  ```java       class ServiceA {           @Autowired            public serviceB serviceB;                      @Transactional(propagation = Propagation.REQUIRES_NEW, noRollbackFor = {IllegalArgumentException.class})           public void methodA(){              ....              serviceB.methodB()           }      } ```  ```java      class ServiceB {          @Transactional(propagation = Propagation.REQUIRED)          public void methodB(){            ....            throw new IllegalArgumentException();          }      } ```  Unfortunately, my transaction is rolled back.  Can I change something in this behavior? Can we check to exist transaction info before checking this info by class and method?  Or is it correct at all?","closed","status: invalid,","kurenchuksergey","2021-03-23T09:55:33Z","2022-01-27T13:39:52Z"
"","26838","Fix Kotlin filter parameter bug in Router DSLs","https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-webmvc/src/main/kotlin/org/springframework/web/servlet/function/RouterFunctionDsl.kt#L650-L655  https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-webflux/src/main/kotlin/org/springframework/web/reactive/function/server/CoRouterFunctionDsl.kt#L531-L539  1. Function `filterFunction` takes `serverRequest` and function `handler` as parameters. (I just name it  second parameter of `filterFunction` as `handler`.) 2. Function `handler` also takes `serverRequest` as parameter. 3. These DSLs define `handler`. 4. Function `handler`s that these DSLs defined  are now using mistakenly `filterFunction`'s `serverRequest`, not their own `serverRequest` parameters, which makes their own parameters meaningless.  This bug only exists in Kotlin DSL.   You can see java codes have no problem as follows.  https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-webmvc/src/main/java/org/springframework/web/servlet/function/HandlerFilterFunction.java#L46  https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/HandlerFilterFunction.java#L48  In java you can override filter something like  ```java ServerRequest newRequest = someOperation(request) return next.handle(newRequest) ```  but in Kotlin DSL, even if you write  ```kotlin filter { serverRequest, handlerFunction ->     val newServerRequest = someOperation(serverRequest)     handlerFunction(newServerRequest) } ``` handlerFunction will use original serverRequest, not the newServerRequest","closed","type: bug,","ShindongLee","2021-04-21T08:58:12Z","2021-05-12T06:46:28Z"
"","26082","o.s.validation.FieldError includes rejectedValue in its toString method.","https://github.com/spring-projects/spring-framework/blob/5338d8b5e90acf43a919b8b1eb1803748a3f81c7/spring-context/src/main/java/org/springframework/validation/FieldError.java#L128  the `rejectedValue` is included in `FieldError#toString()` method, it follows that `MethodArgumentNotValidException` builds message text in `getMessage` method with each Error object.  https://github.com/spring-projects/spring-framework/blob/5338d8b5e90acf43a919b8b1eb1803748a3f81c7/spring-web/src/main/java/org/springframework/web/bind/MethodArgumentNotValidException.java#L67  Since `exception.getMessage()` is higly likely being logged, this might cause sensitive data leak.","closed","","zhongf","2020-11-12T17:04:58Z","2020-11-18T17:16:51Z"
"","26635","Add RouterFunctionMapping to Javadoc for WebMvcConfigurationSupport","https://github.com/spring-projects/spring-framework/blob/1ee9223348c81c903a1d53d3378032beb16c3cbe/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L543-L572  I update javadoc comment because RouterFunctionMapping was missing.","closed","type: task,","cprayer","2021-03-03T13:32:12Z","2021-03-03T13:49:25Z"
"","26162","Code optimization tips","https://github.com/spring-projects/spring-framework/blob/11f6c4e7ab6b63f363aca63230aef111f476484e/spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionParserDelegate.java#L420  StringUtils.tokenizeToStringArray() Methods internal maintenance a List,but new List again where this method is called.Would you like Optimize the code？","open","in: core,","jason-liu475","2020-11-27T08:17:30Z","2021-11-11T09:32:04Z"
"","26859","Can't execute normally？","https://github.com/spring-projects/spring-framework/blob/01e50fb60ad0d82f96fe4df6054ed6029e2f6a12/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java#L561","closed","for: stackoverflow,","zoujinxing","2021-04-25T10:54:06Z","2021-04-25T13:47:09Z"
"","26714","Upgrade to Objenesis 3.2","https://github.com/easymock/objenesis/releases/tag/3.2","closed","type: dependency-upgrade,","jhoeller","2021-03-22T22:01:39Z","2021-03-22T22:12:55Z"
"","26805","fix : fix invalid annotation on reference doc","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factorybeans-annotations At first example of 1.10.5. Defining Bean Metadata within Components, `@Component` should be `@Configuration`.","closed","status: declined,","e406hsy","2021-04-14T14:22:40Z","2021-04-15T07:24:23Z"
"","26186","Wrong documentation for CachePut","https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/CachePut.html **unless** _Unlike condition(), this expression is evaluated after the method has been called and can therefore refer to the result._  It is false. Condition is evaluated after the method has been called too and can refer to the result. I suppose it is the copy-paste from @Cacheable documentation.","closed","in: core,","streambuf","2020-12-01T10:35:14Z","2021-01-20T13:09:32Z"
"","26728","Docs missing Dynamic Language Support Refreshable: Refresh does not work with  beans","https://docs.spring.io/spring-framework/docs/5.0.20.RELEASE/spring-framework-reference/languages.html#dynamic-language-beans-concepts  Docs should indicate that `refresh-check-delay` does not work with  beans  Happy to make the update, but cannot find the source for the docs page.","closed","in: core,","StephenOTT","2021-03-25T18:12:39Z","2021-12-02T10:30:43Z"
"","25967","WebFlux: how to add an Http2 server push to static content?","How can I make a server push with webflux (Netty for example)?  I know how to do with Spring MVC using PushBuilder (Servlet 4.0).","open","status: blocked,","userquin","2020-10-24T18:37:35Z","2021-11-08T11:37:31Z"
"","26270","Is there a method add a describe parameter for acuator's mapping","Hope RequestMapping add a property RequestMapping#describe for describe method or class, then we can use describe like this: ```     /**      * THIS IS A DESCRIBE FOR CURRENT METHOD      * @return      */     @GetMapping(value = ""/lastTime"", describe = ""THIS IS A DESCRIBE FOR CURRENT METHOD"")     public Response lastTime() {         return new Response<>().success(requirementService.lastTime());     } ```  in  @DeleteMapping @GetMapping @PutMapping @PostMapping @PatchMapping .  When we use actuator: http://user-api-service.sra.svc.cluster.local:30501/user/api/actuator/mappings , hope got describe in contexts['user - api - service - 1'].mappings.dispatcherServlets.dispatcherServlet[0].details.requestMappingConditions.describe  (or put it in details.handlerMethod) like this: ``` {     contexts: {         bootstrap: {             mappings: {                 dispatcherServlets: {},                 servletFilters: [],                 servlets: []             }         },         user - api - service - 1: {             mappings: {                 dispatcherServlets: {                     dispatcherServlet: [{                             handler: ""com.ueh.user.api.controller.OrgController#getById(Long)"",                             predicate: ""{GET /org/{id}}"",                             details: {                                 handlerMethod: {                                     className: ""com.ueh.user.api.controller.OrgController"",                                     name: ""getById"",                                     descriptor: ""(Ljava/lang/Long;)Lcom/ueh/common/utils/system/response/Response;""                                 },                                 requestMappingConditions: {                                     consumes: [],                                     headers: [],                                     methods: [                                         ""GET""                                     ],                                     params: [],                                     patterns: [                                         ""/org/{id}""                                     ],                                     produces: [], 				    describe: 'THIS IS A DESCRIBE FOR CURRENT METHOD'                                 }                             }                         }                     ]                 },                 servletFilters: [                 ],                 servlets: [             ]             },             parentId: ""user-api-service-1""         }     } } ``` then we can use this api do many thins such as export to swagger/judge dynamic permissions and so on    Of course, if actuator can supply a annotations (@AcutatorMappings)for this purpose, thats very nice: ```     /**      * THIS IS A DESCRIBE FOR CURRENT METHOD      * @return      */     @AcutatorMappings(""describe"" = ""THIS IS A DESCRIBE FOR CURRENT METHOD"")     @GetMapping(value = ""/lastTime"")     public Response lastTime() {         return new Response<>().success(requirementService.lastTime());     } ```","closed","","imic07","2020-12-15T03:53:45Z","2021-01-29T14:32:18Z"
"","26275","MockMvc and Multiple Files","Hiya,  I'm not sure if it is a regression from the correction of #26166 but in version 5.3.2 using the method `file` of `MockMultipartHttpServletRequestBuilder` to attach multiple `MockMultipartFile` seems to generate a request with only the last file.  This ends up generating a `MissingServletRequestParameterException` in a web controller configured with multiple `@RequestParam` for each `MultipartFile` in its method signature.  Note: My dependency to this framework is from Spring boot version 2.4.1 Switching back to Spring boot 2.3.7.RELEASE which relies on Spring Framework 5.2.12.RELEASE solve the issue.  Best regards","closed","status: duplicate,","asa-git","2020-12-15T11:40:04Z","2020-12-15T12:30:06Z"
"","26255","Upgrade to Hibernate Validator 6.2","Hibernate Validator 6.2 is in the release candidate stage now, probably GA in time for our 5.3.3 release.","closed","type: dependency-upgrade,","jhoeller","2020-12-10T14:58:51Z","2021-01-12T08:26:55Z"
"","26876","Fix syntax for RequestEntity headers example in ref docs","Hi. There is an additional parenthesis in reference document about spring integration - RestTempate Headers part","closed","type: task,","kihyuk-sung","2021-04-29T11:44:57Z","2021-04-29T15:35:15Z"
"","26350","Spring Data Rest Documentation Issue","Hi, this is my first ever issue so I hope I don't screw it up :)  In the Spring Data Rest [documentation](https://docs.spring.io/spring-data/rest/docs/current/reference/html/#repository-resources.methods) it says:  `For details on how to tweak the default method exposure or dedicated HTTP methods individually see`  It doesn't have a link and seems to be missing part of the sentence. Hope I'm not missing anything and love the Spring Framework, thanks!!","closed","for: external-project,","elishagreenwald","2021-01-05T20:46:23Z","2021-01-06T07:11:32Z"
"","26560","javax.servlet.api version requirement changed for release 5.3.4?","Hi, I have a series of webmvc tests that began failing since I applied the latest 5.3.4 patch. It looks like there is a classDefNotFoundError which points at a servlet 4.0 class HttpServletMapping. Does spring-test / spring-webmvc now require the Servlet 4.0 classes upon 5.3.4 upgrade?  ```java   @Test   public void testHandleRequest() throws Exception {     mockMvc.perform(post(""/myURL"")).andExpect(status().is(HttpStatus.OK.value())).andExpect(view().name(""myView""));   } ```  ==>  ``` java.lang.NoClassDefFoundError: javax/servlet/http/HttpServletMapping 	at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:206) 	at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) 	at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:138) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$6(ClassBasedTestDescriptor.java:350) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.executeAndMaskThrowable(ClassBasedTestDescriptor.java:355) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$7(ClassBasedTestDescriptor.java:350) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) 	at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742) 	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestInstancePostProcessors(ClassBasedTestDescriptor.java:349) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$instantiateAndPostProcessTestInstance$4(ClassBasedTestDescriptor.java:270) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:269) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$2(ClassBasedTestDescriptor.java:259) 	at java.util.Optional.orElseGet(Optional.java:267) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$3(ClassBasedTestDescriptor.java:258) 	at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:31) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:101) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:100) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:111) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:111) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:79) 	at java.util.ArrayList.forEach(ArrayList.java:1259) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.util.ArrayList.forEach(ArrayList.java:1259) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:84) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) Caused by: java.lang.ClassNotFoundException: javax.servlet.http.HttpServletMapping 	at java.net.URLClassLoader.findClass(URLClassLoader.java:382) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:418) 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:351) 	... 68 more ```","closed","status: duplicate,","JohnZ1385","2021-02-17T17:26:25Z","2021-02-19T10:50:47Z"
"","26285","Property resolution for multiple profiles","Hi, I asked a [question on StackOverflow](https://stackoverflow.com/questions/60333056/property-resolving-for-multiple-spring-profiles-yaml-configuration), but got no reply, so I'm trying here.  Is it specified somewhere, that when I define multiple profiles, the property resolution will be done in order of specified profiles?  Thanks!","closed","for: stackoverflow,","Betlista","2020-12-16T08:40:53Z","2020-12-16T09:55:17Z"
"","26129","Reference manual contains broken links to XSD schema sections","Hi, in spring core documentation version 5.3.1  file: core-appendix.adoc line 667: ""If you are not familiar with Spring's current XML configuration extensions that come with the standard Spring distribution, you should first read the appendix entitled <>.""  unfortunately the  appendix.html link leads nowhere.","closed","type: task,","eladAlfa","2020-11-22T15:41:09Z","2020-11-23T13:52:13Z"
"","26431","AbstractRoutingDataSource - Object instead of DataSource interface","Hi, https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html#setTargetDataSources-java.util.Map-  it accepts Map but why is the second type an Object? Should not it be an interface DataSource? The method determineTargetDataSource map to this type anyway and cast exceptions may be throws if someone passes some other object.  Questions are:  1. Is it save to assign Map to Map 2. Why to accept argument with raw Object type rather then DataSource","closed","","Drezir","2021-01-22T13:19:22Z","2021-01-22T13:46:07Z"
"","26253","Random SpelEvaluationException with T() operator - EL1005E: Type cannot be found","Hi,     we are experiencing such a strange behavior using `SPEL T()` operator to get references to custom enums or types in our thymeleaf templates: everything goes straight till we get random failures in resolving our custom types. ""_random_"" means that same expression sometimes get parsed properly and sometimes don't. It looks like failures occur only in asynch context (`StreamingResponseBody`'s callbacks and `@‌Asynch` annotated methods)  Same issue submitted to [the Thymeleaf team](https://github.com/thymeleaf/thymeleaf-spring/issues/244)  ``` org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: ""myVar == T(my.custom.TypeEnum).VALUE)"" (template: ""myTemplate"" - line xx, col yy)         at org.thymeleaf.spring4.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:290) ~[thymeleaf-spring4-3.0.11.RELEASE.jar:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]         at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]  ...         at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:592) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]         at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]         at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1059) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]         at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1048) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] ...         at org.springframework.aop.interceptor.AsyncExecutionInterceptor$1.call(AsyncExecutionInterceptor.java:115) [spring-aop-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_201] Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1005E: Type cannot be found 'my.custom.TypeEnum'         at org.springframework.expression.spel.support.StandardTypeLocator.findType(StandardTypeLocator.java:115) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ExpressionState.findType(ExpressionState.java:154) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.TypeReference.getValueInternal(TypeReference.java:64) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:52) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:88) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:43) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:32) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:169) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.OpAnd.getBooleanValue(OpAnd.java:56) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.OpAnd.getValueInternal(OpAnd.java:51) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:169) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.Ternary.getValueInternal(Ternary.java:51) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:119) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:327) ~[spring-expression-4.3.29.RELEASE.jar:4.3.29.RELEASE]         at org.thymeleaf.spring4.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring4-3.0.11.RELEASE.jar:3.0.11.RELEASE]         ... 53 more ``` see [full stack trace](https://github.com/spring-projects/spring-framework/files/5671804/stacktrace.txt)   - Environment   - java 1.8.0_201-b09   - tomcat 8.5.39   - thymeleaf-3.0.11.RELEASE.jar   - thymeleaf-spring4-3.0.11.RELEASE.jar   - spring-aop-4.3.29.RELEASE.jar   - spring-aspects-4.3.29.RELEASE.jar   - spring-beans-4.3.29.RELEASE.jar   - spring-context-4.3.29.RELEASE.jar   - spring-context-support-4.3.29.RELEASE.jar   - spring-core-4.3.29.RELEASE.jar   - spring-expression-4.3.29.RELEASE.jar   - spring-jdbc-4.3.29.RELEASE.jar   - spring-jms-4.3.29.RELEASE.jar   - spring-messaging-4.3.29.RELEASE.jar   - spring-orm-4.3.29.RELEASE.jar   - spring-security-acl-4.2.19.RELEASE.jar   - spring-security-config-4.2.19.RELEASE.jar   - spring-security-core-4.2.19.RELEASE.jar   - spring-security-oauth-2.4.0.RELEASE.jar   - spring-security-openid-4.2.19.RELEASE.jar   - spring-security-taglibs-4.2.19.RELEASE.jar   - spring-security-web-4.2.19.RELEASE.jar   - spring-tx-4.3.29.RELEASE.jar   - spring-web-4.3.29.RELEASE.jar   - spring-webmvc-4.3.29.RELEASE.jar","open","in: web,","jjpianta","2020-12-10T10:06:18Z","2022-05-17T07:49:52Z"
"","26787","Avoid exceptions when evaluating validation hints","Hi,  we noticed in one of our loadtests that a substantial amount of ""hidden"" `NoSuchMethodException`s is being thrown when using `@javax.validation.Valid` on controller methods. ``` @PostMapping(""test"") public void test(@RequestBody @Valid @NotNull TestRequest request) {      // Some code } ```  This is caused by calling `AnnotationUtils.getValue()` on this annotation, which has no such property. This PR bypasses the annotation utility call. I also took the freedom to refactor this logic into a common place in `ValidationUtils` to avoid copy-paste throughout the different modules.  An isolated JMH benchmark shows the following results when dealing with `@Valid`: ``` Benchmark                                         Mode  Cnt     Score     Error   Units MyBenchmark.testNew                               avgt   10     6,253 ±   0,312   ns/op MyBenchmark.testOld                               avgt   10  1761,995 ±  92,262   ns/op ```  As a workaround you can use `org.springframework.validation.annotation.Validated` of course, but I would prefer not to have such a drawback when using `javax.validation.Valid`.  Let me know what you think.  Cheers, Christoph","closed","type: enhancement,","dreis2211","2021-04-11T07:56:33Z","2021-04-22T09:27:04Z"
"","26664","WebSocket upgrade request rejected when behind a load balancer","Hi,  We have a Spring (5.3.3) application with a SockJS setup, deployed as follows:  [Browser / SockJS client] -> [Traefik load balancer] -> [Spring / Undertow / SockJS Server]  With this setup, Spring rejects the WebSocket upgrade requests as violating the Single Origin Policy. Here is my understanding of how it happens.  1. The browser / SockJS client issues the request to the load balancer    with an url akin: `wss://my-website.com/api/notifications/008/sispjx3j/websocket`    The Origin header is set to: `Origin: https://my-website.com`. 2. The load balancer forwards the request to the Spring application,    and doing so adds the following request headers:      `X-Forwarded-Host: my-website.com`      `X-Forwarded-Port: 443`      `X-Forwarded-Proto: wss` 3. Undertow's `ProxyPeerAddressHandler` class (enabled by the Spring Boot    autoconfiguration) reads the `X-Forwarded-*` headers and applies them to the    request to make it as if the browser requested the Spring application directly. 4. Spring's `DefaultCorsProcessor` (enabled by the SockJS configuration)    notices the `Origin` header in the request and validates it.    The request is misidentified as cross origin because the request scheme    in the Origin header is `https` while the request scheme in `HttpServletRequest`    is `wss`. The request is rejected because as the application is configured to    only allow same origin requests, the set of allowed origins is empty.         It is not clear to me which component is at fault with this issue.","open","in: web,","bgK","2021-03-11T10:10:17Z","2021-11-10T11:43:11Z"
"","26625","WebSocket vs RSocket","Hi,  This is a question.   I use Webflux. I have a requirement for websocket!  What does spring recommend? RSocket? Is it production ready? Or Webflux websocket?   Thanks.","closed","for: stackoverflow,","kitkars","2021-03-02T01:42:51Z","2021-03-02T05:11:35Z"
"","26845","Custom conversionService converter not working","Hi,  I've got a problem with custom string to date converter using 4.3.30 spring-framework. Converter is not applying when field comes in HTTP request and default object converter has been used instead which leads to datatype mismatch while conversion.  This is description of conversion bean in XML:   ```xml                                                                                 ```  And this is implementation of converter:  ```java public class StringToDateConverter implements Converter {       DateFormatSafeUtils dateFormat = new DateFormatSafeUtils(""yyyy-MM-dd HH:mm:ss"");       @Override       public Date convert(String source) {           try {               Date date = dateFormat.parse(source);               return date;           } catch (ParseException e) {               throw new IllegalArgumentException(""Invalid date value '"" + source + ""'"");           }       }   } ```  When an HTTP request comes with data in string, Spring tries to apply datetimeformat with string to date formatter instead of my `StringToDateConverter`.  The weirdest thing is that converter worked fine with 4.1.6.RELEASE of spring-framework.  Best regards, Dash","open","status: feedback-provided,","alqa-dash","2021-04-22T07:02:42Z","2021-04-23T06:50:57Z"
"","26318","Switch to PathPatternParser for Spring MVC breaks welcome page auto configuration","Hi,  I'm developing a Spring MVC app using Spring Boot 2.4.1.  I add the following configurations to `application.properties` in order to switch path matching strategy to the new `PathPatternParser`: ``` spring.mvc.pathmatch.matching-strategy=path_pattern_parser ``` But after that access to the root path (/) won't be redirected to `/index.html`. Access the full path `http://xxxxx/index.html` is OK. If switching back to `AntPathMatcher`, redirect works normally.  PS: I set `spring.web.resources.static-locations` to a local directory which contains static resources.","closed","type: bug,","samotoo","2020-12-23T10:07:52Z","2021-01-06T21:56:36Z"
"","26713","Spring Cache support for Async Caffeine","Hi,  I'm currently using Caffeine with Spring Caffeine cache support implementation. I want to know is there any support for Async LoadingCache support on the spring cache? or if I want async caching do I want to move out with `AsyncLoadingCache` without spring caffeine cache support;?  PS: I'm using spring-webflux","closed","for: stackoverflow,","namila007","2021-03-22T15:01:55Z","2021-03-22T17:19:28Z"
"","26476","Introduce @PreCheck annotation for intercepting handler method invocations","Hi,  I would like to have a custom controller annotation that can check things before getting into the code. Something like `PreAuthorize` from `org.springframework.security.access.prepost` but which can take a custom Exception in parameter not just `AccessDeniedException`  The goal is to make all the check in the annotation to avoid having checks in the controller code. This would avoid code like   ```java @ResponseStatus(HttpStatus.OK) public ResponseType doSomething(InputType input) {     if (!service.canHandleInput(input)) {         throw new Exception(MyCustomException);     }     return service.doRealWork(); } ``` And to replace it by something like   ```java @ResponseStatus(HttpStatus.OK) @PreCheck(""@service.canHandleInput(input)"", MyCustomException) public ResponseType doSomething(InputType input) {     return service.doRealWork(); } ```  Is there something like that already existing ?  If not and if you think it is a good idea I would be willing to work on it.  Thank you !","closed","status: declined,","RobotScribe","2021-01-29T17:45:05Z","2021-02-01T13:59:16Z"
"","26564","Duplicate class definition for CGLIB proxy when running multiple Jetty instances in parallel","Hi,  I have a spring web app with tests which start a jetty web server. The code looks something like:  ```java // import org.eclipse.jetty.server.* // import org.eclipse.jetty.webapp.*         final Server server = new Server(port);          final WebAppContext context = new WebAppContext();         context.setContextPath(contextPath);         context.setResourceBase(new File(""src/main/webapp"").getAbsolutePath());         context.setDescriptor(new File(""src/main/webapp/WEB-INF/web.xml"").getAbsolutePath());         context.setParentLoaderPriority(true);         context.setServer(server);         server.setHandler(context);         server.start         // Interact with server and so spring as well here.         server.stop/join/destroy ```  This all works well, except for when I enable parallel testing. With parallel testing (so multiple jetty servers may be running at a time and so spring will be called under the the web server at the same time) enabled I start to get attempted duplicate class definitions:  ``` Caused by: java.lang.LinkageError: loader 'app' attempted duplicate class definition for com.AccountV1ApiCalls$$FastClassBySpringCGLIB$$6bb614f1. (com.AccountV1ApiCalls$$FastClassBySpringCGLIB$$6bb614f1 is in unnamed module of loader 'app') 	at java.lang.ClassLoader.defineClass1(Native Method) ~[?:?] 	at java.lang.ClassLoader.defineClass(ClassLoader.java:1017) ~[?:?] 	at jdk.internal.reflect.GeneratedMethodAccessor101.invoke(Unknown Source) ~[?:?] 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?] 	at java.lang.reflect.Method.invoke(Method.java:566) ~[?:?] 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:523) ~[spring-core-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	... 108 more ```  I can't imagine that it is expected that spring would be thread-unsafe.","closed","in: core,","LukeButters","2021-02-17T21:43:21Z","2021-03-31T03:42:18Z"
"","26817","org.springframework.web.servlet.mvc.method.annotation.ReactiveTypeHandler does not handle vendor-specific application/x-ndjson media types","Hi,  At one point, the handler iterates over ReactiveTypeHandler#JSON_STREAMING_MEDIA_TYPES which contains two values: MediaType.APPLICATION_NDJSON and MediaType.APPLICATION_STREAM_JSON.  If a controller uses a custom vendor-specific ""produces"" streaming type such as application/vnd.myname.v1+x-ndjson (for API versioning for example), it won't ""match"" within the loop and the handler will not use a JsonEmitterSubscriber as expected.  Shouldn't ReactiveTypeHandler#JSON_STREAMING_MEDIA_TYPES contain the generic media type: application/*+x-ndjson so that it ""includes"" custom vendor-specific streaming type.  Thank you.","open","in: web,","nlescure-pictet","2021-04-16T14:13:18Z","2021-11-10T12:31:07Z"
"","26610","Header content-type not enforcing charset","Hi,  after upgrading from Spring boot 2.3.1.RELEASE to 2.4.2 it seems the value for the `content-type` header isn't fully validated.  -  openjdk version ""11.0.9.1"" 2020-11-04  - Kotlin version 1.4.30  Example: ``` @RestController @RequestMapping(     produces = [""application/vnd.api+json;charset=utf-8""],     consumes = [""application/vnd.api+json;charset=utf-8""] ) class Controller(...) { @ResponseStatus(HttpStatus.CREATED)     @PostMapping(""/some_path"")     fun doSomething(         @Valid @RequestBody request: JsonApiRequest     ): Clazz2 { } ```  **Behavior on Spring 2.3.1-RELEASE:** Request with header `Content-Type : application/vnd.api+json;charset=utf-8` is allowed :white_check_mark: Request with header `Content-Type : application/vnd.api+json;charset=utf-16` rejected with `415` status :white_check_mark: Request with header `Content-Type : application/vnd.api+json;charset=test`rejected with `415` status :white_check_mark:  **Behavior on Spring 2.4.2:** Request with header `Content-Type : application/vnd.api+json;charset=utf-8` is allowed :white_check_mark: Request with header `Content-Type : application/vnd.api+json;charset=utf-16` isn't rejected with `415` status and results in an expcetion being thrown :x: ``` org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Unrecognized token '笊': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false'); nested exception is com.fasterxml.jackson.core.JsonParseException: Unrecognized token '笊': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')  at [Source: (InputStreamReader); line: 1, column: 2] ``` Request with header `Content-Type : application/vnd.api+json;charset=test`rejected with `415` status :white_check_mark:  Additionall info: Request with header `Content-Type : application/vnd.api+json` (without specifying the charset) get's allowed (I'm assuming it's defaulting to `utf-8`) with both versions. I would expect the request to be rejected in this case.","closed","in: web,","sasa-fajkovic","2021-02-25T17:57:12Z","2021-03-16T14:48:02Z"
"","26609","Header content-type not enforcing charset","Hi,  after upgrading from Spring boot 2.3.1.RELEASE to 2.4.2 it seems the value for the `content-type` header isn't fully validated.  -  openjdk version ""11.0.9.1"" 2020-11-04  - Kotlin version 1.4.30  Example: ``` @RestController @RequestMapping(     produces = [""application/vnd.api+json;charset=utf-8""],     consumes = [""application/vnd.api+json;charset=utf-8""] ) class Controller(...) { @ResponseStatus(HttpStatus.CREATED)     @PostMapping(""/some_path"")     fun doSomething(         @Valid @RequestBody request: JsonApiRequest     ): Clazz2 { } ```  **Behavior on Spring 2.3.1-RELEASE:** Request with header `Content-Type : application/vnd.api+json;charset=utf-8` is allowed :white_check_mark: Request with header `Content-Type : application/vnd.api+json;charset=utf-16` rejected with `415` status :white_check_mark: Request with header `Content-Type : application/vnd.api+json;charset=test`rejected with `415` status :white_check_mark:  **Behavior on Spring 2.4.2:** Request with header `Content-Type : application/vnd.api+json;charset=utf-8` is allowed :white_check_mark: Request with header `Content-Type : application/vnd.api+json;charset=utf-16` isn't rejected with `415` status and results in an expcetion being thrown :x: ``` org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Unrecognized token '笊': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false'); nested exception is com.fasterxml.jackson.core.JsonParseException: Unrecognized token '笊': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')  at [Source: (InputStreamReader); line: 1, column: 2] ``` Request with header `Content-Type : application/vnd.api+json;charset=test`rejected with `415` status :white_check_mark:  Additionall info: Request with header `Content-Type : application/vnd.api+json` (without specifying the charset) get's allowed (I'm assuming it's defaulting to `utf-8`) with both versions. I would expect the request to be rejected in this case.","closed","status: duplicate,","sasa-fajkovic","2021-02-25T17:53:08Z","2021-02-26T18:55:04Z"
"","26014","Support for PostgreSQL 11 procedure call syntax","Hi,  A while back the Posgre Java driver had a breaking change for procedure calls: https://github.com/pgjdbc/pgjdbc/issues/1413  this is still unfortunately not addressed in: spring-jdbc:5.2.10.RELEASE  CallMetaDataContext.java:649  didnt find a ticket for this,  BR","closed","type: enhancement,","riba2101","2020-11-02T16:23:34Z","2020-11-05T11:47:14Z"
"","26821","CVE-2018-1199 CVE-2018-1257 CVE-2018-1272 CVE-2020-5421 commits","Hi,  (Apologizes if this isn't the right channel, I checked https://spring.io/security-policy but that appears to be reserved for new vulnerabilities.)  I'm part of the Debian LTS (Long Term Support) Team and I'm reviewing the security issues that affect the versions of Spring Framework shipped by Debian, so as to determine if they are vulnerable, and fix them for Debian users.  I could not find the patches/commits related to [CVE-2018-1199](https://pivotal.io/security/cve-2018-1199), [CVE-2018-1257](https://pivotal.io/security/cve-2018-1257), [CVE-2018-1272](https://pivotal.io/security/cve-2018-1272) and [CVE-2020-5421](https://tanzu.vmware.com/security/cve-2020-5421) (including through perusing the Git history).  Would it be possible to share this information? If this is not meant to be public, could you send it privately at beuc@debian.org?  Regards,","closed","status: declined,","Beuc","2021-04-17T17:12:23Z","2021-04-19T13:11:37Z"
"","26258","UriComponentsBuilder fromUriString cannot parse File URI","Hi!  I thinl I found a exception after update to spring-boot 2.4.0, 2.4.1.  A cannot parse a file uri using UriTemplateHandler. Before, in 2.3.x, I could do it.  A test example is:  ```  @Test     public void verify() throws MalformedURLException {         final UriTemplateHandler uriTemplateHandler;          DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory();         uriFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT);  // for backwards compatibility..         uriTemplateHandler = uriFactory;          URL url = uriTemplateHandler.expand(file.toURI().toString(), Collections.emptyMap()).toURL();          assertThat(url.toString()).isEqualTo(file.toURI().toString());     } ```  file  is a File object with value (toString()): /tmp/junit5116856254058695014/arquivo.txt Sorry If I made some mistake.  Thanks","closed","type: regression,","mvpcortes","2020-12-11T15:19:10Z","2020-12-17T14:54:33Z"
"","26054","AbstractMessageConverterMethodProcessor ignores altered response type via ResponseBodyAdvice when selecting supported HttpMessageConverters","Hi Spring team. Via WebMvcConfigurer#configureMessageConverters I included StringHttpMessageConverter (for reference: to avoid Springdoc OAS3 responses to get treated by Jackson).   Now, in my case I have a ResponseBodyAdvice defined which alters the return type of all operations by wrapping responses. This breaks my application as it seems that AbstractMessageConverterMethodProcessor only looks at the type of the actual target operation to decide which HttpMessageConverter supports said return type.   If the original operation response is of type object, nothing breaks as an object is simply wrapped by the ResponseBodyAdvice in another object (type remains object). But if the response is a string, the string is wrapped in an object by the ResponseBodyAdvice so the actual target type changes from object to string. However, the StringHttpMessageConverter still remains selected as a supported converter because this selection was based on the result type of the operation (string, namely) and does not look at the response type of the ResponseBodyAdvice. This ultimately results in a ClassCastException as AbstractMessageConverterMethodProcessor feeds the Object to StringHttpMessageConverter.  To me the expected behavior would be that AbstractMessageConverterMethodProcessor takes the (potentially) altered return type of a ResponseBodyAdvice into account to decide which HttpMessageConverters are supported. Do you agree?","closed","in: web,","koen-serneels","2020-11-09T17:57:04Z","2020-11-10T17:33:50Z"
"","26296","Spring data DomainClassConverter broken with Spring 5.3 in case of missing entity","Hi Spring team,  I think that I've found an issue migrating a project from Spring 5.2 to 5.3.  Indeed I'm using the [DomainClassConverter](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#core.web.basic.domain-class-converter) provided by the Spring Data team and there's a change in the way missing entities are handled.  With Spring 5.2 a missing entity was nicely handled and a 404 HTTP response was sent. To me, that's the expected behavior.  But with Spring 5.3 it returns a 500 HTTP code with a `MissingPathVariableException`. I think that this new behavior comes from [this commit](https://github.com/spring-projects/spring-framework/commit/50b954240291d7e4302a679694b83db7096ff254).  I can share more details if needed. Have a nice day :)","closed","in: web,","clemstoquart","2020-12-18T11:24:03Z","2021-01-11T18:05:16Z"
"","26740","Typo in RequestBodyAdviceAdapter Javadoc","Hi Guys  The javadoc said RequestBodyAdviceAdapter  is A convenient starting point for implementing **ResponseBodyAdvice**, I think the correct one should be **RequestBodyAdvice** ``` /**  * A convenient starting point for implementing  * {@link org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice  * ResponseBodyAdvice} with default method implementations.  *  * Sub-classes are required to implement {@link #supports} to return true  * depending on when the advice applies.  *  * @author Rossen Stoyanchev  * @since 4.2  */ ```","closed","type: task,","laiyubin","2021-03-29T04:00:45Z","2021-03-29T16:59:48Z"
"","26716","Autowiring HttpServletResponse in the request flow to set a header","Hi Colleagues,  I wanted confirm on one particular flow. If there is a spring controller for REST and we auto-wire HttpServletResponse along the flow in any of the underlying classes. I mean not in @Controller, but any other @Service class. Still would it be RequestScoped?  Please help.","closed","for: stackoverflow,","githubsree","2021-03-23T13:42:32Z","2021-03-23T14:44:13Z"
"","26756","How to mock @Resource ?  . Scenario is using @Resource for preventing @Cacheable to be bypassed when called from another method of the same bean [Using Spring AOP].","Hey everyone,  I have a scenario where I have @Cacheable annotation in the Service Layer. One method of this class is calling other one with the latter having both having @Cacheable annotation on it.  Since I am  using Spring AOP therefore whenever  `createSphereClientA`  calls `createSphereClientB` , the @Cacheable is ignored because there is no proxy . I read here [https://stackoverflow.com/questions/16899604/spring-cache-cacheable-not-working-while-calling-from-another-method-of-the-s/48867068#48867068](url)  and used `@Resource` as I'm using Springboot 2.2.5.  I don't want to use AspectJ because it's happening only for one class.     ``` @Service public class CacheableSphereClientFactoryImpl implements SphereClientFactory {      /**      * 1. Self-autowired reference to proxified bean of this class.      */     @Resource     private SphereClientFactory self;      @Autowired 	public CacheableSphereClientFactoryImpl(CacheablePolicyDao cacheablePolicyDao, UserCustomPolicyDao userCustomPolicyDao, 									 UserAPI userAPI, PolicyMessages policyMessages, 									PolicyRepository policyRepository, 									 Validator validator) { 		this.cacheablePolicyDao = cacheablePolicyDao; 		this.userCustomPolicyDao = userCustomPolicyDao; 		this.userAPI = userAPI; 		this.policyMessages = policyMessages; 		this.policyRepository = policyRepository; 		this.validator = validator; 	}      @Override     @Cacheable(sync = true)     public SphereClient createSphereClientA(@Nonnull TenantConfig tenantConfig) {         // 2. call cached method using self-bean         return self.createSphereClient(tenantConfig.getSphereClientConfig());     }      @Override     @Cacheable(sync = true)     public SphereClient createSphereClientB(@Nonnull SphereClientConfig clientConfig) {         return userAPI.createSphereClient(clientConfig);     }     ......... //Some more methods }  ```  The code is working perfectly fine!. Now I 'm struggling with writing JUnit for the `createSphereClientA`  function. I am not able to Mock  `SphereClientFactory` .  I'm using  ```        Mockito Version : 3.3.0        PowerMock Version : 2.0.5 ```  I tried various ways like using  the below one & running with `MockitoJUnitRunner`  ``` @Mock  SphereClientFactory self ```  Or `PowerMocking`  the object and running on `PowerMockRunner` but nothing works :(.   Everytime I am getting NullPointerException because SphereClientFactory is actually never mocked with both the approaches.  Anyone has any clue how can I do this ?  Also does the above solution will produce cyclic dependency?","closed","for: stackoverflow,","parul7802","2021-04-02T19:00:12Z","2021-04-03T06:43:34Z"
"","26870","Upgrade to Gradle 7.2","Here is tasks I can remember - [x] upgrade gradle wrapper - [x] replace removed configration `compile` `runtime` `testCompile` `testRuntime` - [x] use convention plugin to [organize build logic for subprojects](https://docs.gradle.org/current/userguide/sharing_build_logic_between_subprojects.html)","closed","type: task,","quaff","2021-04-28T08:07:37Z","2021-09-14T11:24:47Z"
"","26293","Prototype-scoped bean cannot be registered via lambda expression","Here is my code： ```java @SpringBootApplication public abstract class DIApp {     public static void main(String[] args) {         SpringApplication.run(DIApp.class);     }           @Bean     @Scope(""prototype"")     public HelloService helloService(){         return new HelloService() {             @Override             public void print(String name) {                 System.out.println(""hello:""+name);             }         };     }      @Bean     CommandLineRunner run2(){         return args -> {             for (int i = 0; i < 5; i++) {                 HelloService service = helloService();                 service.print(""prototype@""+service);             }         };     }  } ``` it works fine. for every call, a new HelloService instance is created. but, after i changing HelloService bean to lamda style, it's not ok: ```java     @Bean     @Scope(""prototype"")     public HelloService helloService(){         return name -> System.out.println(""hello:""+name);     } ``` Does lamda not surpport prototype scope?","closed","for: stackoverflow,","hhfdna","2020-12-17T06:58:06Z","2020-12-21T14:31:25Z"
"","26370","StandardMultipartHttpServletRequest does not strip file path properly","Hello,My Name is tkswifty.I found the issue in the latest code of master branch here: [https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/multipart/support/StandardMultipartHttpServletRequest.java](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/multipart/support/StandardMultipartHttpServletRequest.java) I assume it applies to the latest 5.3.2 version. Springboot will use StandardServletMultipartResolver to deal with the multipart request.if Spring is running on a root privilege computer and if attacker provides a filename  like ""../../../../../../../../../var/spool/cron/root""，parseRequest method will return ""../../../../../../../../../var/spool/cron/root"" which is a unreasonable file name. and then if application use this filename，critical path traversal issue can happen.","closed","","tkswifty","2021-01-12T03:37:15Z","2021-01-12T21:24:56Z"
"","26811","Access to the cachedSessions in CachingConnectionFactory","Hello, it seems the `org.springframework.jms.connection.CachingConnectionFactory` class uses the `cachedSessions` property to manage the sessions in the connection factory.  This is a private property and it has not any getter method to obtain the value. In order to instrument `CachingConnectionFactory` it could be useful to access this property or, at least, its size. Could a public method be added in the `CachingConnectionFactory` class to return the `cachedSessions` value (or its size)?  Thanks for your time!","closed","type: enhancement,","sanorcdel","2021-04-15T11:14:17Z","2021-05-11T13:50:42Z"
"","26665","Improve performance of ASM's ClassReader.readStream()","Hello, `ClassReader.readStream()` can be reworked to improve its performance and reduce memory consumption. Currently there are two major problems about it:  - we always allocate a buffer of the same size which is often several times bigger than actual amount of data being read from `InputStream` - we always return of copy of `byte[]` underlying in `ByteArrayOutputStream`  Using `InputStream.available()` we can pre-size the buffer in vast majority of cases and even when the whole data is not read within one iteration (for large `InputStreams`) we allocate as much memory as required.   Another optimization is about checking whether it was only one read from `InputStream`, and in this case the buffer itself can be returned instead of calling `ByteArrayOutputStream.toByteArray()`.  I've used this benchmark available [here](https://github.com/stsypanov/spring-boot-benchmark) to check impact of the patch for start-up of simple Spring Boot application:  ```java @State(Scope.Thread) @BenchmarkMode(Mode.SingleShotTime) @OutputTimeUnit(TimeUnit.MILLISECONDS) @Fork(jvmArgsAppend = {""-Xms2g"", ""-Xmx2g""}) public class SpringBootApplicationBenchmark {      private ConfigurableApplicationContext context;      @Benchmark     public Object startUp() {         return context = SpringApplication.run(BenchmarkApplication.class);     }      @TearDown(Level.Invocation)     public void close() {         context.close();     } } ```  and got the following results:  ``` original  Benchmark                                                   Mode  Cnt         Score       Error   Units SpringBootApplicationBenchmark.startUp                        ss  200       718.760 ±    20.549   ms/op SpringBootApplicationBenchmark.startUp:·gc.alloc.rate         ss  200        38.895 ±     0.620  MB/sec SpringBootApplicationBenchmark.startUp:·gc.alloc.rate.norm    ss  200  49776228.720 ± 19919.815    B/op SpringBootApplicationBenchmark.startUp:·gc.count              ss  200           ≈ 0              counts  patched  Benchmark                                                   Mode  Cnt         Score       Error   Units SpringBootApplicationBenchmark.startUp                        ss  200       614.820 ±     7.031   ms/op SpringBootApplicationBenchmark.startUp:·gc.alloc.rate         ss  200        41.678 ±     0.240  MB/sec SpringBootApplicationBenchmark.startUp:·gc.alloc.rate.norm    ss  200  49003403.920 ± 21786.877    B/op SpringBootApplicationBenchmark.startUp:·gc.count              ss  200           ≈ 0              counts ```","closed","for: external-project,","stsypanov","2021-03-11T11:00:06Z","2021-11-09T21:10:38Z"
"","27008","DatabasePopulatorUtils.execute should commit if the current Connection has auto-commit set to false","Hello,   I would like to submit an issue. I am facing a problem with creation of spring-batch tables when you use a datasource in `auto-commit mode => false;`  My project is using spring-boot@2.2.7 and postgresql.  Here is my configuration :  ```yaml spring:   batch:     initialize-schema: always  spring:   datasource:     type: com.zaxxer.hikari.HikariDataSource     hikari:       poolName: Hikari       auto-commit: false ```	    I have checked the `BatchDataSourceInitializer` class which is the subclass of `AbstractDataSourceInitializer`. It appears that the code at line 65 `DatabasePopulatorUtils.execute(populator, this.dataSource);` is responsible for running the sql script of spring-batch tables, with spring-jdbc, but the transaction is never committed. And consequently, my tables are never created in my database.  If I switch the configuration of my datasource, ie `auto-commit: true`, everything is working fine.  I was expecting my spring-batch tables be created (initialize-schema => always) even if my datasource is not in auto-commit mode. It's not so easy and not very intuitive, at first sight, to discover why the tables are not created. We first think about a misconfiguration relative to spring-batch but nothing related to datasource configuration.  What do you think about that ?  Thanks for your help.","closed","type: enhancement,","sixrandanes","2021-02-16T23:20:18Z","2022-01-29T12:26:09Z"
"","26711","External entity fields fully returned only in the first entity that has a reference to it","Hello, I implemented a backend with Spring that exports functionality and data through REST APIs to a front end developed with angular. After I replace the reference to an external entity in a certain entity, if I send a GET to retrieve the updated entity, the REST server returns only the foreign key value instead of all the fields of the external reference. By replacing the original reference, the REST server returns the entire object. Through debugging I noticed that the find method of the JPA repository correctly returns all the fields of the external entity, but builds the response only with the key as you can see from the sniffed packet with wireshark.  ![Cattura1](https://user-images.githubusercontent.com/40201749/111972366-aedcd880-8afd-11eb-8907-fdda20318eae.JPG) ![Cattura2](https://user-images.githubusercontent.com/40201749/111972372-b0a69c00-8afd-11eb-9521-3dc9d8008e84.JPG)","closed","status: feedback-provided,","cicciob95","2021-03-22T10:03:31Z","2022-02-18T19:05:37Z"
"","26208","Passing attributes from WebClient to underlying HTTP library","Hello,  We are trying to enable communication logging (low level HTTP logging) for requests and responses processed with WebClient. There is a good tutorial on how to approach the simplest case which I've followed to get the initial results - [Link to balendung](https://www.baeldung.com/spring-log-webclient-calls#1-logging-with-jetty-httpclient).  However, HTTP logging in our company is a bit more complex simply just calling SLF4J. In certain cases we need to provide extra context paired to request/response, so that other tooling can correctly process those logs (some internal IDs). We've identified the `attributes` feature as potentially the cleanest way to pass additional context to the underlying library, seeing how they are present on WebClient API as well as both netty and jetty libraries. However, it seems that the attributes are not copied from WebClient model to the Netty/Jetty model.  As a workaround, we are currently wrapping the Request/Response spec to add additional behaviour on WebClient side.  So the question is - are attributes the right way of solving cases like this and how would one go about adding support for copying attributes from WebClient request to underyling library request?  I've found no relevant discussions and this seems to be a useful enhancement.","open","type: enhancement,","tstavinoha","2020-12-03T15:23:45Z","2021-11-24T16:17:23Z"
"","26488","Ignore null header value in MockHttpServletResponse","Hello,  I've faced an issue recently working with `MockHttpServletResponse`. The thing is when I have conditional (value can be null) headers in my controller, and I want to test them using `MockMvc` it fails, because `MockHttpServletResponse` checks if header value in response is `null`.  Below is what I am trying to do:  ```java     @GetMapping(""/example"")     public ResponseEntity example() {         String nullableHeaderValue = conditionalHeaderValue();         return ResponseEntity.ok()                 .header(""Some-header"", nullableHeaderValue)                 .body(""Hi"");     } ```  So the intention is to send header if its value is present and it works as expected.  But when I test it with `MockMvc` it throws an `IllegalArgumentException` due to this check in `MockHttpServletResponse`:  ```java 	private void doAddHeaderValue(String name, Object value, boolean replace) { 		HeaderValueHolder header = this.headers.get(name); 		Assert.notNull(value, ""Header value must not be null""); 		if (header == null) { 			header = new HeaderValueHolder(); 			this.headers.put(name, header); 		} 		if (replace) { 			header.setValue(value); 		} 		else { 			header.addValue(value); 		} 	} ```  I know that as workaround instead of nullability of value of header I can put headers themselves conditionally, but the thing is that spec of `HttpServletResponse` allows me to have nullable header values, while `MockHttpServletResponse` does not, and this behavior is surprising to say the least.","closed","type: enhancement,","imaxvell","2021-02-01T14:23:19Z","2021-02-02T11:10:23Z"
"","26252","Defensively handle loadClass null result in BeanUtils.findEditorByConvention (against misbehaving ClassLoader impl such as in the GWT JettyLauncher)","Hello,  I'm working on the migration of an application using Java and the Spring framework. The migration is a big step, the libs versions are moving as follows :   - Java JDK1.6 to JDK11   - Spring Framework 3.2.0 to 5.3.1   - Spring Integration 3.0.0 to 5.4.1   - Spring Security 3.1.0 to 5.4.2  I spent some times on the compiling issues but now I'm stuck when starting the application.  The application configuration is most of all xml beans configuration (and spring integration messaging configuration). When starting and creating the beans, application always fails with the same NullPointerException.  **Example 1 :**  A simple jdbc initialize with two scripts like this :   ```          	     	       ```  Leads to this NPE :  ```      org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.jdbc.datasource.init.DataSourceInitializer#0': Cannot create inner bean '(inner bean)#62794322' of type [org.springframework.jdbc.datasource.init.CompositeDatabasePopulator] while setting bean property 'databasePopulator'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#62794322': Cannot create inner bean '(inner bean)#6a35384f' of type [org.springframework.jdbc.datasource.init.ResourceDatabasePopulator] while setting bean property 'populators' with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#6a35384f': Cannot create inner bean '(inner bean)#f5677960' of type [org.springframework.jdbc.config.SortedResourcesFactoryBean] while setting bean property 'scripts'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#f5677960': Unexpected exception during bean creation; nested exception is java.lang.NullPointerException     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:389)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:134)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1691)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1436)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)     	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)     	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$237/000000000000000000.getObject(Unknown Source)     	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)     	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)     	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)     	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944)     	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:925)     	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:588)     	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)     	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)     	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103)     	at org.eclipse.jetty.server.handler.ContextHandler.callContextInitialized(ContextHandler.java:930)     	at org.eclipse.jetty.servlet.ServletContextHandler.callContextInitialized(ServletContextHandler.java:553)     	at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:889)     	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:356)     	at org.eclipse.jetty.webapp.WebAppContext.startWebapp(WebAppContext.java:1445)     	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1409)     	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:822)     	at org.eclipse.jetty.servlet.ServletContextHandler.doStart(ServletContextHandler.java:275)     	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:524)     	at com.google.gwt.dev.shell.jetty.JettyLauncher$WebAppContextWithReload.doStart(JettyLauncher.java:550)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110)     	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:100)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169)     	at org.eclipse.jetty.server.Server.start(Server.java:407)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110)     	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:100)     	at org.eclipse.jetty.server.Server.doStart(Server.java:371)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at com.google.gwt.dev.shell.jetty.JettyLauncher.start(JettyLauncher.java:760)     	at com.google.gwt.dev.DevMode.doStartUpServer(DevMode.java:636)     	at com.google.gwt.dev.DevModeBase.startUp(DevModeBase.java:898)     	at com.google.gwt.dev.DevModeBase.run(DevModeBase.java:705)     	at com.google.gwt.dev.DevMode.main(DevMode.java:432)     Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#62794322': Cannot create inner bean '(inner bean)#6a35384f' of type [org.springframework.jdbc.datasource.init.ResourceDatabasePopulator] while setting bean property 'populators' with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#6a35384f': Cannot create inner bean '(inner bean)#f5677960' of type [org.springframework.jdbc.config.SortedResourcesFactoryBean] while setting bean property 'scripts'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#f5677960': Unexpected exception during bean creation; nested exception is java.lang.NullPointerException     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:389)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:134)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveManagedList(BeanDefinitionValueResolver.java:428)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:173)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1691)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1436)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:374)     	... 42 more     Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#6a35384f': Cannot create inner bean '(inner bean)#f5677960' of type [org.springframework.jdbc.config.SortedResourcesFactoryBean] while setting bean property 'scripts'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#f5677960': Unexpected exception during bean creation; nested exception is java.lang.NullPointerException     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:389)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:134)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1691)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1436)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:374)     	... 50 more     Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#f5677960': Unexpected exception during bean creation; nested exception is java.lang.NullPointerException     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:544)     	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:374)     	... 56 more     Caused by: java.lang.NullPointerException     	at java.base/java.lang.Class.isAssignableFrom(Native Method)     	at org.springframework.beans.BeanUtils.findEditorByConvention(BeanUtils.java:566)     	at org.springframework.beans.TypeConverterDelegate.findDefaultEditor(TypeConverterDelegate.java:337)     	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:153)     	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)     	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53)     	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:759)     	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1356)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1206)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:571)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)     	... 57 more  ```  If I comment this part out, to understand and see where it leads, it comes to the Spring Integration beans part.  **Example 2 :**  A simple logging-chanel-adapter is leading to the same NPE  ```                     	              	          		     	         		          	            ```  Stack :  ```      org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.integration.handler.LoggingHandler#0': Unexpected exception during bean creation; nested exception is java.lang.NullPointerException     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:544)     	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)     	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$237/000000000000000000.getObject(Unknown Source)     	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)     	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)     	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)     	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944)     	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:925)     	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:588)     	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)     	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)     	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103)     	at org.eclipse.jetty.server.handler.ContextHandler.callContextInitialized(ContextHandler.java:930)     	at org.eclipse.jetty.servlet.ServletContextHandler.callContextInitialized(ServletContextHandler.java:553)     	at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:889)     	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:356)     	at org.eclipse.jetty.webapp.WebAppContext.startWebapp(WebAppContext.java:1445)     	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1409)     	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:822)     	at org.eclipse.jetty.servlet.ServletContextHandler.doStart(ServletContextHandler.java:275)     	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:524)     	at com.google.gwt.dev.shell.jetty.JettyLauncher$WebAppContextWithReload.doStart(JettyLauncher.java:550)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110)     	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:100)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169)     	at org.eclipse.jetty.server.Server.start(Server.java:407)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110)     	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:100)     	at org.eclipse.jetty.server.Server.doStart(Server.java:371)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at com.google.gwt.dev.shell.jetty.JettyLauncher.start(JettyLauncher.java:760)     	at com.google.gwt.dev.DevMode.doStartUpServer(DevMode.java:636)     	at com.google.gwt.dev.DevModeBase.startUp(DevModeBase.java:898)     	at com.google.gwt.dev.DevModeBase.run(DevModeBase.java:705)     	at com.google.gwt.dev.DevMode.main(DevMode.java:432)     Caused by: java.lang.NullPointerException     	at java.base/java.lang.Class.isAssignableFrom(Native Method)     	at org.springframework.beans.BeanUtils.findEditorByConvention(BeanUtils.java:566)     	at org.springframework.beans.TypeConverterDelegate.findDefaultEditor(TypeConverterDelegate.java:337)     	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:153)     	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)     	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53)     	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:759)     	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1356)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1206)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:571)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)     	... 37 more  ```  **Example 3 :**  Again if I comment it out, with an inbound-channel-adapter  ```                		                    		          		     			     		          	    	     	    	     	             				     			     	    	          		     			     		          		     		     			                 		     			     			     		            ```  Stack :  ```      org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'pid-loadPlansChannel.adapter.source': Initialization of bean failed; nested exception is java.lang.NullPointerException     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:617)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)     	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)     	at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$237/000000000000000000.getObject(Unknown Source)     	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)     	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)     	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)     	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:925)     	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:925)     	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:588)     	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)     	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)     	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:103)     	at org.eclipse.jetty.server.handler.ContextHandler.callContextInitialized(ContextHandler.java:930)     	at org.eclipse.jetty.servlet.ServletContextHandler.callContextInitialized(ServletContextHandler.java:553)     	at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:889)     	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:356)     	at org.eclipse.jetty.webapp.WebAppContext.startWebapp(WebAppContext.java:1445)     	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1409)     	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:822)     	at org.eclipse.jetty.servlet.ServletContextHandler.doStart(ServletContextHandler.java:275)     	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:524)     	at com.google.gwt.dev.shell.jetty.JettyLauncher$WebAppContextWithReload.doStart(JettyLauncher.java:550)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110)     	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:100)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:169)     	at org.eclipse.jetty.server.Server.start(Server.java:407)     	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:110)     	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:100)     	at org.eclipse.jetty.server.Server.doStart(Server.java:371)     	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:72)     	at com.google.gwt.dev.shell.jetty.JettyLauncher.start(JettyLauncher.java:760)     	at com.google.gwt.dev.DevMode.doStartUpServer(DevMode.java:636)     	at com.google.gwt.dev.DevModeBase.startUp(DevModeBase.java:898)     	at com.google.gwt.dev.DevModeBase.run(DevModeBase.java:705)     	at com.google.gwt.dev.DevMode.main(DevMode.java:432)     Caused by: java.lang.NullPointerException     	at java.base/java.lang.Class.isAssignableFrom(Native Method)     	at org.springframework.beans.BeanUtils.findEditorByConvention(BeanUtils.java:566)     	at org.springframework.beans.TypeConverterDelegate.findDefaultEditor(TypeConverterDelegate.java:337)     	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:153)     	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:98)     	at org.springframework.beans.TypeConverterDelegate.convertToTypedArray(TypeConverterDelegate.java:455)     	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:172)     	at org.springframework.beans.AbstractNestablePropertyAccessor.convertIfNecessary(AbstractNestablePropertyAccessor.java:588)     	at org.springframework.beans.AbstractNestablePropertyAccessor.convertForProperty(AbstractNestablePropertyAccessor.java:607)     	at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:219)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.convertForProperty(AbstractAutowireCapableBeanFactory.java:1740)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1696)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1436)     	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)     	... 38 more  ```  All those examples were working well before migration. I can't see something common between those examples or something obvious that could lead to this same NPE each time (and there are many others if I keep going). There is something I don't understand, I'm missing out on something.  Any idea ? Thanks for help","closed","type: enhancement,","axeldufo","2020-12-10T09:44:47Z","2020-12-11T13:20:58Z"
"","25952","@Component not picked up by @ComponentScan if it has the same simple name as the main class","Hello,  I have accidentally named my worker `@Component` class same as my main application class with `@SpringBootApplication` and `@ComponentScan` annotations. I have correct structure by documentation because my main class is in root package and other classes are in sub-packages.  Seems like my `@Component` class is not being picked up by component scanning. It is in different package so I think this should work.   Spring version = 2.3.4.RELEASE. Build tool = Gradle 6.6.1  Thanks.","open","in: core,","Drezir","2020-10-21T16:01:33Z","2021-12-15T20:32:17Z"
"","26329","How to change property source location in spring 5.3.1?","Hello,  I have a problem with changing the config file location in spring 5.3.1.  This is how my `StandardSpringConfiguration` looks like:   ```java @Configuration @Retention(RUNTIME) @PropertySource(""classpath:someprops.properties"") @PropertySource(value=""file:${config.location:.}/someprops.properties"", ignoreResourceNotFound=true) @ComponentScan(basePackages = ""some.package"") public @interface StandardSpringConfiguration { } ```  Everything worked fine with spring 5.1.6.RELEASE. The issues started when I switched to spring 5.3.1.  In the past I could change the location of the prop like this:  ```shell  java -jar -Dconfig.location=/somepath/resources  someJar.jar --command --option AA ```  After changing the spring version the `-Dconfig.location` is ignored and it will use the default prop file. I tried to get the value of config.location and print it and it prints the correct path introduced in the terminal. Got the value like this:  ```java @Value(""${config.location}"") String configLocation ```  Changing a single value from the prop file still works. For exapmle this will work:  ```shell java -jar -Ddb_user=SOME_USER  someJar.jar --command --option AA ```  Has anyone encountered such issues with more recent versions of spring?","closed","in: core,","dinicolae","2020-12-31T10:07:22Z","2021-01-16T15:37:18Z"
"","26159","JPMS (Jigsaw) full support for use with jlink/jpackage","Hello,  Currently Spring use ""Automatic modules"" to support JPMS but it prevents the use of jlink and jpackage tools. So, do you plan to fully support JPMS in a near future? Already on the roadmap?  Best regards","closed","status: duplicate,","treilhes","2020-11-26T16:08:35Z","2020-11-26T16:52:08Z"
"","26023","Expose toEntityFlux methods in WebClient.ResponseSpec","Hello!  I have  a simple application that acts as a proxy between a client and a server It receives a client request and passes it over to the server, then passes the server response back to the client There is no need to process the request/response body, or buffer them in memory Here is my current code:  ```kotlin webClient    .method(request.method)    .uri(request.path)    .headers { it.addAll(request.headers().asHttpHeaders()) }    .body(request.bodyToFlux())    .exchangeToMono { response ->       ServerResponse          .status(response.statusCode())          .headers { it.addAll(response.headers().asHttpHeaders()) }          .body(response.bodyToFlux())    } ```  After upgrading to WebFlux 5.3.0 I had to replace the `.exchange()` method with `.exchangeToMono()`. This new method in turn calls `.releaseIfNotConsumed()`, and apparently passing the body as a `Flux` is not consuming it, so my client always gets a response with an empty body.  What is the proper way to address my use case?  P.S. I created an issue here due to [this request](https://github.com/spring-projects/spring-framework/issues/25751#issuecomment-720988345)","closed","type: enhancement,","mplain","2020-11-03T10:09:59Z","2020-11-16T18:02:23Z"
"","26597","How to migrate a test suite from Spring Framework to Spring Boot?","Hello SF Developers  Just being curious - is there an official guide or best practices about how to migrate all the Test classes from Spring Framework to Spring Boot? The latter has some specific set of annotations and settings (`@SpringBootTest`). Therefore - consider a SF project with more 500 of Test classes and later it has green light to be migrated to SB. How migrate the complete set of test classes with the minor impact or refactoring?  * For example If my memory does not fail me, I remember that from the _Spring Integration_ project, the module `spring-messaging` was moved to _Spring Framework_.  * Or perhaps - Would be created a new special annotation to be shared between these 2 projects? (SF=SB) - _Really the reason to create this post_ - therefore the testing classes are totally agnostic in what framework would be running  Thanks for your understanding","closed","for: stackoverflow,","manueljordan","2021-02-23T16:43:59Z","2021-02-23T19:45:55Z"
"","25863","Spring Data Mongo Db + AWS Document DB","Hello I am trying to connect to AWS Document DB via spring boot data mongo.  The application stops with the below exception [ec2-user@ip-172-24-52-7 ~]$ java -jar -Dspring.profiles.active=dev ptl-pas-worklist-app-0.0.4-WITHMONGO.jar    .   ____          _            __ _ _  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.3.4.RELEASE)  2020-10-06 13:46:43.081  INFO 20689 --- [           main] c.p.p.w.PtlPasWorklistAppApplication     : Starting PtlPasWorklistAppApplication on ip-172-24-52-7.idexxi.com with PID 20689 (/home/ec2-user/ptl-pas-worklist-app-0.0.4-WITHMONGO.jar started by ec2-user in /home/ec2-user) 2020-10-06 13:46:43.104  INFO 20689 --- [           main] c.p.p.w.PtlPasWorklistAppApplication     : The following profiles are active: dev 2020-10-06 13:46:45.120  INFO 20689 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data MongoDB repositories in DEFAULT mode. 2020-10-06 13:46:45.136  INFO 20689 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 9ms. Found 0 MongoDB repository interfaces. 2020-10-06 13:46:46.960  INFO 20689 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http) 2020-10-06 13:46:46.990  INFO 20689 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2020-10-06 13:46:46.996  INFO 20689 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.38] 2020-10-06 13:46:47.157  INFO 20689 --- [           main] o.a.c.c.C.[.[localhost].[/worklist]      : Initializing Spring embedded WebApplicationContext 2020-10-06 13:46:47.158  INFO 20689 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3753 ms 2020-10-06 13:46:48.261  INFO 20689 --- [           main] com.ptl.pas.worklist.config.MongoConfig  : Connection String ...mongodb://ptl_pas_db:ptl_pas_db_secret@ptl-pas-db-cluster.cluster-chqqqxubezzt.eu-central-1.docdb.amazonaws.com:27017 2020-10-06 13:46:48.449  INFO 20689 --- [           main] org.mongodb.driver.cluster               : Cluster created with settings {hosts=[ptl-pas-db-cluster.cluster-chqqqxubezzt.eu-central-1.docdb.amazonaws.com:27017], mode=SINGLE, requiredClusterType=UNKNOWN, serverSelectionTimeout='30000 ms'} 2020-10-06 13:46:49.530  INFO 20689 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor' 2020-10-06 13:46:50.141  INFO 20689 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 2 endpoint(s) beneath base path '/actuator' 2020-10-06 13:46:50.257  INFO 20689 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path '/worklist' 2020-10-06 13:46:50.287  INFO 20689 --- [           main] c.p.p.w.PtlPasWorklistAppApplication     : Started PtlPasWorklistAppApplication in 9.818 seconds (JVM running for 10.895) 2020-10-06 13:46:58.767  INFO 20689 --- [onaws.com:27017] org.mongodb.driver.cluster               : Exception in monitor thread while connecting to server ptl-pas-db-cluster.cluster-chqqqxubezzt.eu-central-1.docdb.amazonaws.com:27017  com.mongodb.MongoSocketReadTimeoutException: Timeout while receiving message 	at com.mongodb.internal.connection.InternalStreamConnection.translateReadException(InternalStreamConnection.java:562) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnection.receiveMessage(InternalStreamConnection.java:447) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnection.receiveCommandMessageResponse(InternalStreamConnection.java:298) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnection.sendAndReceive(InternalStreamConnection.java:258) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.CommandHelper.sendAndReceive(CommandHelper.java:83) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.CommandHelper.executeCommand(CommandHelper.java:33) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnectionInitializer.initializeConnectionDescription(InternalStreamConnectionInitializer.java:103) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnectionInitializer.initialize(InternalStreamConnectionInitializer.java:60) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:128) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:117) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_265] Caused by: java.net.SocketTimeoutException: Read timed out 	at java.net.SocketInputStream.socketRead0(Native Method) ~[na:1.8.0_265] 	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) ~[na:1.8.0_265] 	at java.net.SocketInputStream.read(SocketInputStream.java:171) ~[na:1.8.0_265] 	at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[na:1.8.0_265] 	at com.mongodb.internal.connection.SocketStream.read(SocketStream.java:109) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnection.receiveResponseBuffers(InternalStreamConnection.java:579) ~[mongodb-driver-core-4.0.5.jar!/:na] 	at com.mongodb.internal.connection.InternalStreamConnection.receiveMessage(InternalStreamConnection.java:444) ~[mongodb-driver-core-4.0.5.jar!/:na]  ![image](https://user-images.githubusercontent.com/15156365/95210553-e96ee500-07eb-11eb-823e-9774e035cd33.png)","closed","for: stackoverflow,","ajaytechworkshop","2020-10-06T13:56:45Z","2020-10-06T13:59:36Z"
"","26267","Provide a way to customize ResponseBodyEmitter's earlySendAttempts behaviour","Hello everyone,  I'm having a small feature request in a endpoint using a SseEmitter, with an implementation looking like so: ```java     @GetMapping(""/poll"")     public SseEmitter poll() {         var sseEmitter = myService.registerAndStartPolling();          myService.getOrderedListOfSomething()                 .forEach(something -> sseEmitter.send(something));          return sseEmitter;     } ``` In which I create a `SseEmitter` in order to start polling early, but where I still need to emit a few early values. However, I would like these early values to be ultimately emitted before the ones retrieved in the early polling. In my case this could be achieved easily by comparing a certain value (the creation date time).   `ResponseBodyEmitter`'s `earlySendAttempts` is however a first-come-first-emitted Set by default. In my case, I could replace it with a `TreeSet` for instance, or use an overridable `preProcessEarlySendAttempts(Set earlySendAttempts)` that would be called in `ResponseBodyEmitter#initialize`","closed","status: declined,","celcius112","2020-12-14T14:15:07Z","2021-01-20T17:05:21Z"
"","26093","EntityManagerFactory startup failure in deferred mode is only available on first use","Hello everyone! Recently I observed a strange behavior while starting a simple project with Spring-boot + Hibernate that confuse me a lot.  I wrote a simple JPA entity and tried to start the project, but no entity wrote to a database. After long time searching why I accidentally had seen that the app after around 1-2 minute of correct working shut down with exit code 0 and the answer of my question appeared in a console:  **nested exception is org.hibernate.MappingException: Could not instantiate id generator [entity-name=null]** But why the app keeps silent before that moment and doesn`t show me any information about entity creation process? I think this is not trivial and confusing.  My application.properties for reproduction  ``` spring.session.store-type=jdbc spring.datasource.driver-class-name=org.postgresql.Driver spring.jpa.database-platform=org.hibernate.dialect.PostgreSQL10Dialect spring.datasource.url= jdbc:postgresql://localhost:5432/*** spring.datasource.username=*** spring.datasource.password=*** spring.jpa.properties.hibernate.default_schema=demo spring.jpa.generate-ddl=true spring.jpa.hibernate.ddl-auto=create ```  And a simple JPA entity with error: ``` @Entity public class Item {     @Id     public Long id;      @ElementCollection     @CollectionTable(name = ""IMAGE"")     @Column(name = ""FILENAME"")     @CollectionId(             columns = @Column(name = ""IMAGE_ID""),             type = @Type(type = ""long""),             generator = ""SEQUENCE"" <<<<< NOT CORRECT     )     protected List images = new ArrayList<>(); } ``` Now if you try to start a project then you will not see any error message for almost a one or two minutes and you doesn`t get what the problem. When you fix the error the entity writes to DB without problems  Srping-boot version: v2.3.5.RELEASE","closed","type: enhancement,","DredderGun","2020-11-13T12:08:02Z","2020-11-13T16:54:12Z"
"","26268","Default value for configuration in application.yml is parsed even when defined env variable is there","Hello all, used spring boot: 2.2.1.RELEASE Problem: When defining application.yml properties I want to use something like: property: ${FOO:someFallbackWithEnv_${BAR}}  someOtherProperty: ${property}  With `@ConfigurationProperties` it works as expected but with injection via `@Value` or in application.yml (someOtherProperty) it fails with ""could not resolve BAR"". I think it is not expected as FOO was defined as env variable so the other part should not be processed at all IMO.","open","in: core,","FrancoCorleone","2020-12-14T13:16:58Z","2021-11-11T09:32:05Z"
"","26352","Webflux and ServerResponse with generic type","Hello  I suggest an enhancement about types of `ServerResponse` for Spring Boot Webflux and Kotlin  All routes have to same response type like   `fun post(request: ServerRequest): Mono`  But it's better to have    `fun post(request: ServerRequest): Mono>`  Any plan about it ?","closed","status: invalid,","mmaryo","2021-01-06T13:09:57Z","2021-01-14T12:47:31Z"
"","26110","An error response wasn't written because the response had been committed","Greetings! Came across the following stack in the log:  ``` 2020/10/20-20:20:44.926-0,JAVA,0,level=WARN,pid=11448,threadId=79,thread=webflux-selector-http-6,logger=com.example.webflux.GlobalExceptionHandler,message='[567b6e06-1142474] Request processing failed: HTTP GET ""/static/auth/bundled/vendors~index.css?hash=efe52b3a171d61573126""',exception=reactor.netty.ReactorNetty$InternalNettyException: java.nio.channels.ClosedChannelException Caused by: java.nio.channels.ClosedChannelException 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannel$AbstractUnsafe.newClosedChannelException(AbstractChannel.java:957) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:865) 	at io.netty.transport@4.1.45.Final/io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:715) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:707) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:790) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:700) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:695) 	at io.netty.transport@4.1.45.Final/io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.write(CombinedChannelDuplexHandler.java:521) 	at io.netty.codec@4.1.45.Final/io.netty.handler.codec.MessageToMessageEncoder.writePromiseCombiner(MessageToMessageEncoder.java:137) 	at io.netty.codec@4.1.45.Final/io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:119) 	at io.netty.transport@4.1.45.Final/io.netty.channel.CombinedChannelDuplexHandler.write(CombinedChannelDuplexHandler.java:346) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:715) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:707) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:790) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:700) 	at reactor.netty@0.9.4.RELEASE/reactor.netty.http.server.HttpTrafficHandler.write(HttpTrafficHandler.java:274) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:715) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:762) 	at io.netty.transport@4.1.45.Final/io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1089) 	at io.netty.common@4.1.45.Final/io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) 	at io.netty.common@4.1.45.Final/io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) 	at io.netty.transport@4.1.45.Final/io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497) 	at io.netty.common@4.1.45.Final/io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.common@4.1.45.Final/io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at java.base/java.lang.Thread.run(Thread.java:834)  2020/10/20-20:20:44.928-0,JAVA,0,level=ERROR,pid=11448,threadId=79,thread=webflux-selector-http-6,logger=org.springframework.web.server.adapter.HttpWebHandlerAdapter,message='[567b6e06-1142474] Error [java.lang.UnsupportedOperationException] for HTTP GET ""/static/auth/bundled/vendors~index.css?hash=efe52b3a171d61573126"", but ServerHttpResponse already committed (200 OK)' ```  Should HttpWebHandlerAdapter#isDisconnectedClientError(Throwable) treat «reactor.netty.ReactorNetty$InternalNettyException: java.nio.channels.ClosedChannelException» similarly to the other exceptions from DISCONNECTED_CLIENT_EXCEPTIONS?","closed","","evgenyvsmirnov","2020-11-18T08:03:17Z","2021-01-18T14:39:04Z"
"","26368","Upgrade to Gradle 6.8","Gradle 6.8 has been [released](https://docs.gradle.org/6.8/release-notes.html).","closed","type: task,","sbrannen","2021-01-11T12:12:50Z","2021-01-12T09:42:57Z"
"","25918","Upgrade to Gradle 6.7","Gradle 6.7 has been [released](https://docs.gradle.org/6.7/release-notes.html) with support for building with Java 15.","closed","type: dependency-upgrade,","sbrannen","2020-10-15T11:43:23Z","2020-10-15T12:00:35Z"
"","26078","Spring Boot REST App. You can't link bean with service in MVC controller.","Good afternoon! I'm new to Java please be patient. I want to get a list of entities via REST, but I can't link bean with service in MVC controller. Below is my code.  Repository ``` public interface CustomerRepository extends JpaRepository {} ```  Service interface ``` public interface CustomerService {     Page getAll(Pageable pageable); } ```  Implementation of service interface ``` @Service @RequiredArgsConstructor public class CustomerServiceImpl implements CustomerService {     private final CustomerRepository customerRepository;     private final CustomerMapper customerMapper;      @Override     @Transactional     public Page getAll(Pageable pageable) {         List dbCustomers = customerRepository.findAll();         List listCustomers = null;          dbCustomers.forEach(dbCustomer -> {             listCustomers.add(customerMapper.toRsDto(dbCustomer));         });          Page rsCustomers = new PageImpl(listCustomers);          return rsCustomers;     } } ```   REST Controller ``` @RestController @RequiredArgsConstructor @RequestMapping(""/customers"") @Api(tags = ""customers"", value = ""Customres"") public class CustomersController {     private CustomerService customerService;      @GetMapping     @ApiOperation(tags = ""customers"", value = ""Get all"")     public Page getAll(Pageable pageable) {         if (isNull(customerService)) {             System.out.println(""Not linked bean?"");         }         return customerService.getAll(pageable);     } } ```  This code compiles, but when I call the curl controller I get a message that bin autocoupling has not happened and the object variable points to null.  Curl command ``` curl -X GET ""http://localhost:8080/customers?pageNumber=1&pageSize=5"" -H ""accept: */*"" -H 'authorization: Basic YWRtaW46YWRtaW4=' ```  Message from the servlet container ``` 2020-11-12 14:30:19.958  INFO 7836 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 5 ms Not linked bean? 2020-11-12 14:30:20.407 ERROR 7836 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause  java.lang.NullPointerException: null 	at .rest.CustomersController.getAll(CustomersController.java:31) ~[classes/:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilterInternal(BasicAuthenticationFilter.java:204) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:52) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:216) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) ~[spring-security-web-5.3.5.RELEASE.jar:5.3.5.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.keycloak.adapters.tomcat.AbstractAuthenticatedActionsValve.invoke(AbstractAuthenticatedActionsValve.java:67) ~[spring-boot-container-bundle-10.0.2.jar:10.0.2] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.keycloak.adapters.tomcat.AbstractKeycloakAuthenticatorValve.invoke(AbstractKeycloakAuthenticatorValve.java:181) ~[spring-boot-container-bundle-10.0.2.jar:10.0.2] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na] ```  Where is my mistake? Thanks to everyone who replies to this post!","closed","for: stackoverflow,","sergey-prosvirnin","2020-11-12T12:17:08Z","2020-11-12T13:04:36Z"
"","25958","The Page findAllByNsiClass(NsiClass nsiClass, Pageable pageable) method stopped working","Good afternoon!  Suddenly, the method that just worked yesterday stopped working.  ```java @GetMapping(         name = ""searchNsi"",         value = ""/search/{nsiClassId}"",         produces = ""application/json"")     public ResponseEntity> searchNsi(             @Parameter(description = ""Идентификатор класса НСИ"", required = true,                     example = ""\""0577334f-532a-4ef2-8df3-16d545f24db5\"""")             @Validated @PathVariable(""nsiClassId"") NsiClass nsiClass,             @Validated @RequestParam(required = false, name = ""filter"", defaultValue = """") List filter,             @Validated @RequestParam(required = false, name = ""sorting"", defaultValue = """") List sorting,             @Validated @RequestParam(required = false, name = ""offset"", defaultValue = ""0"") Integer offset,             @Validated @RequestParam(required = false, name = ""size"", defaultValue = ""1000"") Integer size) throws NsiException {         var page = nsiService.listNsi(nsiClass, filter, sorting, offset, size);         return ResponseEntity.ok().body(page); ```  page - always returns empty.  The following warning appeared in the console:  ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (file:/C:/Users/pavel/.m2/repository/org/springframework/spring-core/5.2.9.RELEASE/spring-core-5.2.9.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release``` ```  HELP!!!!!","closed","for: stackoverflow,","Pavel-Shulepov","2020-10-23T02:52:21Z","2020-10-23T09:23:10Z"
"","26856","`@ModelAttribute(binding=false)` is not honored with WebFlux","Given...  ```java public class User {     private String name;      public String getName() {         return this.name;     }      public void setName(String name) {         this.name = name;     } } ```  And...  ```java @RestController public class DemoController {      @GetMapping(""/hello"")     public Mono hello(@ModelAttribute(binding = false) User user) {         return Mono.just(user.getName());     } } ```  ... when I call http://localhost:8080/hello?name=xxxx , I get `""xxxx""` for WebFlux but `""""` for Web MVC.","closed","type: bug,","johnyannj","2021-04-24T03:52:54Z","2021-05-03T17:28:03Z"
"","26029","SpEL doesn't work nicely with records","Given the following `record` and trying to read the `accountId` property in a Thymeleaf template (well actually any property will fail).   ```java public record Account(Long accountId, String description) {} ```  Then in Thymeleaf trying to read the `accountId` with the following  ```html Link to account ```  fails with an exception  ``` org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: ""class path resource [templates/accountList.html]"") 	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1394) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1139) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1078) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.0.jar:5.3.0] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:115) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:81) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:105) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:218) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.0.jar:5.3.0] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.0.jar:5.3.0] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) ~[spring-security-web-5.4.1.jar:5.4.1] 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.3.0.jar:5.3.0] 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.3.0.jar:5.3.0] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.0.jar:5.3.0] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.0.jar:5.3.0] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.0.jar:5.3.0] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.0.jar:5.3.0] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.0.jar:5.3.0] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.0.jar:5.3.0] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] Caused by: org.attoparser.ParseException: Exception evaluating SpringEL expression: ""account.accountId"" (template: ""accountList"" - line 26, col 66) 	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	... 86 common frames omitted Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: ""account.accountId"" (template: ""accountList"" - line 26, col 66) 	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:290) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.LinkExpression.resolveParameters(LinkExpression.java:337) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.LinkExpression.executeLinkExpression(LinkExpression.java:283) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:85) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.CloseElementTag.beHandled(CloseElementTag.java:139) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.Model.process(Model.java:282) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.Model.process(Model.java:290) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.GatheringModelProcessable.process(GatheringModelProcessable.java:78) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleCloseElement(ProcessorTemplateHandler.java:1640) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleCloseElementEnd(TemplateHandlerAdapterMarkupHandler.java:388) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:322) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleCloseElementEnd(OutputExpressionInlinePreProcessorHandler.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleCloseElementEnd(InlinedOutputExpressionMarkupHandler.java:164) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	at org.attoparser.HtmlElement.handleCloseElementEnd(HtmlElement.java:169) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.attoparser.HtmlMarkupHandler.handleCloseElementEnd(HtmlMarkupHandler.java:412) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.attoparser.MarkupEventProcessorHandler.handleCloseElementEnd(MarkupEventProcessorHandler.java:473) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.attoparser.ParsingElementMarkupUtil.parseCloseElement(ParsingElementMarkupUtil.java:201) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:725) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE] 	... 88 common frames omitted Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'accountId' cannot be found on object of type 'biz.deinum.tutorial.bank.AccountDetails' - maybe not public or not valid? 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.3.0.jar:5.3.0] 	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE] 	... 129 common frames omitted ```  I hoped that with implementing #24391 this would also transparently work for SpEL expression, which apparently isn't the case.   ### Current workaround  ```html Link to account ```  Changing the template to use the the `accountId()` method instead of the property makes it work. Nonetheless, it would be nice if this would just work(TM).   Spring Version: 5.3.0.RELEASE Spring Boot: 2.4.0.RC1 JDK: 15.0.1 (AdoptOpenJdk)","closed","type: enhancement,","mdeinum","2020-11-04T07:51:21Z","2020-11-04T15:53:28Z"
"","26853","java.lang.NoSuchMethodError: org.springframework.util.Assert.isTrue(ZLjava/util/function/Supplier;)V","Getting this Error   ``` Caused by: java.lang.NoSuchMethodError: org.springframework.util.Assert.isTrue(ZLjava/util/function/Supplier;)V 	at org.springframework.data.mapping.model.BasicPersistentEntity.getPropertyAccessor(BasicPersistentEntity.java:427) 	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:276) 	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:253) 	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:202) 	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:198) 	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:86) 	at org.springframework.data.mongodb.core.MongoTemplate$ReadDocumentCallback.doWith(MongoTemplate.java:2775) 	at org.springframework.data.mongodb.core.MongoTemplate.executeFindMultiInternal(MongoTemplate.java:2439) 	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:2235) 	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:2218) 	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:774) 	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:760) 	at com.tarento.framework.util.AppConfiguration.propertiesReload(AppConfiguration.java:448) 	at com.tarento.framework.util.AppConfiguration.afterPropertiesSet(AppConfiguration.java:166) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1642) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1579) 	... 199 more ```  I am currently using spring version 4.2.9. RELEASE and spring data mongodb 2.0.3.RELEASE","closed","status: invalid,","Shreevas-Karanth","2021-04-23T07:39:04Z","2021-04-23T09:46:16Z"
"","26607","Issue got on server","getting the following exception on server, when using webflux  happened for 7 api calls (request-response)  encountered the issue 14 times within 2 minutes  these were thrown twice for the same api request-response exchange, the turnaround frame of this one was 150ms ``` > {   ""exceptionTraceHeirarchy"": {},   ""exceptionMeta"": {     ""className"": ""reactor.netty.ReactorNetty$InternalNettyException"",     ""message"": ""java.nio.channels.ClosedChannelException"",     ""cause"": {       ""stackTrace"": [         {           ""methodName"": ""newClosedChannelException"",           ""fileName"": ""AbstractChannel.java"",           ""lineNumber"": 955,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannel$AbstractUnsafe""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannel.java"",           ""lineNumber"": 863,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannel$AbstractUnsafe""         },         {           ""methodName"": ""write"",           ""fileName"": ""DefaultChannelPipeline.java"",           ""lineNumber"": 1378,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.DefaultChannelPipeline$HeadContext""         },         {           ""methodName"": ""invokeWrite0"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 716,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""invokeWrite"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 708,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 791,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 701,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""LoggingHandler.java"",           ""lineNumber"": 249,           ""nativeMethod"": false,           ""className"": ""io.netty.handler.logging.LoggingHandler""         },         {           ""methodName"": ""invokeWrite0"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 716,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""invokeWrite"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 708,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 791,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 701,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""CombinedChannelDuplexHandler.java"",           ""lineNumber"": 528,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""MessageToMessageEncoder.java"",           ""lineNumber"": 112,           ""nativeMethod"": false,           ""className"": ""io.netty.handler.codec.MessageToMessageEncoder""         },         {           ""methodName"": ""write"",           ""fileName"": ""CombinedChannelDuplexHandler.java"",           ""lineNumber"": 348,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.CombinedChannelDuplexHandler""         },         {           ""methodName"": ""invokeWrite0"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 716,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""invokeWrite"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 708,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 791,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 701,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""HttpTrafficHandler.java"",           ""lineNumber"": 232,           ""nativeMethod"": false,           ""className"": ""reactor.netty.http.server.HttpTrafficHandler""         },         {           ""methodName"": ""invokeWrite0"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 716,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""invokeWrite"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 708,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""access$1700"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 56,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 1102,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask""         },         {           ""methodName"": ""write"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 1149,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask""         },         {           ""methodName"": ""run"",           ""fileName"": ""AbstractChannelHandlerContext.java"",           ""lineNumber"": 1073,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask""         },         {           ""methodName"": ""safeExecute"",           ""fileName"": ""AbstractEventExecutor.java"",           ""lineNumber"": 163,           ""nativeMethod"": false,           ""className"": ""io.netty.util.concurrent.AbstractEventExecutor""         },         {           ""methodName"": ""runAllTasks"",           ""fileName"": ""SingleThreadEventExecutor.java"",           ""lineNumber"": 416,           ""nativeMethod"": false,           ""className"": ""io.netty.util.concurrent.SingleThreadEventExecutor""         },         {           ""methodName"": ""run"",           ""fileName"": ""EpollEventLoop.java"",           ""lineNumber"": 331,           ""nativeMethod"": false,           ""className"": ""io.netty.channel.epoll.EpollEventLoop""         },         {           ""methodName"": ""run"",           ""fileName"": ""SingleThreadEventExecutor.java"",           ""lineNumber"": 918,           ""nativeMethod"": false,           ""className"": ""io.netty.util.concurrent.SingleThreadEventExecutor$5""         },         {           ""methodName"": ""run"",           ""fileName"": ""ThreadExecutorMap.java"",           ""lineNumber"": 74,           ""nativeMethod"": false,           ""className"": ""io.netty.util.internal.ThreadExecutorMap$2""         },         {           ""methodName"": ""run"",           ""fileName"": ""FastThreadLocalRunnable.java"",           ""lineNumber"": 30,           ""nativeMethod"": false,           ""className"": ""io.netty.util.concurrent.FastThreadLocalRunnable""         },         {           ""moduleName"": ""java.base"",           ""moduleVersion"": ""15.0.2"",           ""methodName"": ""run"",           ""fileName"": ""Thread.java"",           ""lineNumber"": 832,           ""nativeMethod"": false,           ""className"": ""java.lang.Thread""         }       ],       ""suppressed"": []     }   } } ``` but the request-response transition details were as follows ``` > { ""signalType"": {     ""declaringClass"": ""reactor.core.publisher.SignalType"",     ""name"": ""ON_COMPLETE"",     ""ordinal"": 6,     ""clazz"": ""reactor.core.publisher.SignalType"",     ""hashCode"": 70220229,     ""toString"": ""onComplete""   },  ""events"": {     ""Begin"": {       ""value"": NumberLong(      1614251699546      ),       ""unit"": ""MilliSecond""     },     ""End"": {       ""value"": NumberLong(      1614251699696      ),       ""unit"": ""MilliSecond""     },     ""Frame"": {       ""value"": NumberLong(      150518814      ),       ""unit"": ""NanoSecond""     }   }, ""serverHttpRequest"": { ""_id"": ""af109c76"", ""method"": {       ""declaringClass"": ""org.springframework.http.HttpMethod"",       ""name"": ""GET"",       ""ordinal"": 0,       ""clazz"": ""org.springframework.http.HttpMethod"",       ""hashCode"": 1493586489,       ""toString"": ""GET""     },     ""methodValue"": ""GET"" }, ""path"": {     ""contextPath"": {       ""elements"": [],       ""value"": """",       ""clazz"": ""org.springframework.http.server.DefaultPathContainer"",       ""hashCode"": 0,       ""toString"": """"     },     ""pathWithinApplication"": {       ""elements"": [         {           ""value"": ""/"",           ""clazz"": ""org.springframework.http.server.DefaultPathContainer$$Lambda$841/0x0000000801358440"",           ""hashCode"": 1401830440,           ""toString"": ""org.springframework.http.server.DefaultPathContainer$$Lambda$841/0x0000000801358440@538e3c28""         },         {           ""value"": ""xyz"",           ""clazz"": ""org.springframework.http.server.DefaultPathContainer$DefaultPathSegment"",           ""hashCode"": -173788331,           ""toString"": ""[value='xyz']""         }       ],       ""value"": ""/xyz"",       ""clazz"": ""org.springframework.http.server.DefaultPathContainer"",       ""hashCode"": 775197828,       ""toString"": ""/xyz""     },     ""elements"": [       {         ""value"": ""/"",         ""clazz"": ""org.springframework.http.server.DefaultPathContainer$$Lambda$841/0x0000000801358440"",         ""hashCode"": 1401830440,         ""toString"": ""org.springframework.http.server.DefaultPathContainer$$Lambda$841/0x0000000801358440@538e3c28""       },       {         ""value"": ""xyz"",         ""clazz"": ""org.springframework.http.server.DefaultPathContainer$DefaultPathSegment"",         ""hashCode"": -173788331,         ""toString"": ""[value='xyz']""       }     ],     ""value"": ""/xyz"",     ""clazz"": ""org.springframework.http.server.DefaultRequestPath"",     ""hashCode"": -1583998968,     ""toString"": ""/xyz""   }, ""serverHttpResponse"": {     ""cookies"": {       ""size"": 0,       ""isEmpty"": true,       ""clazz"": ""org.springframework.util.CollectionUtils$MultiValueMapAdapter"",       ""hashCode"": 0,       ""toString"": ""{}""     },     ""headers"": {       ""acceptLanguage"": [],       ""acceptLanguageAsLocales"": [],       ""accessControlAllowCredentials"": false,       ""accessControlAllowHeaders"": [],       ""accessControlExposeHeaders"": [],       ""accessControlMaxAge"": NumberLong(      -1      ),       ""accessControlRequestHeaders"": [],       ""connection"": [],       ""contentDisposition"": {         ""type"": """",         ""clazz"": ""org.springframework.http.ContentDisposition"",         ""hashCode"": 0,         ""toString"": """"       },       ""contentLength"": NumberLong(      120515      ),       ""contentType"": {         ""charset"": {           ""aliases"": [             ""unicode-1-1-utf-8"",             ""UTF8""           ],           ""canEncode"": true,           ""displayName"": ""UTF-8"",           ""isRegistered"": true,           ""name"": ""UTF-8"",           ""clazz"": ""sun.nio.cs.UTF_8"",           ""hashCode"": 81070450,           ""toString"": ""UTF-8""         },         ""parameters"": {           ""charset"": ""UTF-8""         },         ""qualityValue"": 1.0,         ""type"": ""application"",         ""subtype"": ""json"",         ""isConcrete"": true,         ""isWildcardType"": false,         ""isWildcardSubtype"": false,         ""removeQualityValue"": {           ""charset"": {             ""aliases"": [               ""unicode-1-1-utf-8"",               ""UTF8""             ],             ""canEncode"": true,             ""displayName"": ""UTF-8"",             ""isRegistered"": true,             ""name"": ""UTF-8"",             ""clazz"": ""sun.nio.cs.UTF_8"",             ""hashCode"": 81070450,             ""toString"": ""UTF-8""           },           ""parameters"": {             ""charset"": ""UTF-8""           },           ""qualityValue"": 1.0,           ""type"": ""application"",           ""subtype"": ""json"",           ""isConcrete"": true,           ""isWildcardType"": false,           ""isWildcardSubtype"": false,           ""clazz"": ""org.springframework.http.MediaType"",           ""hashCode"": -224654938,           ""toString"": ""application/json;charset=UTF-8""         },         ""clazz"": ""org.springframework.http.MediaType"",         ""hashCode"": -224654938,         ""toString"": ""application/json;charset=UTF-8""       },       ""date"": NumberLong(      -1      ),       ""expires"": NumberLong(      -1      ),       ""ifMatch"": [],       ""ifModifiedSince"": NumberLong(      -1      ),       ""ifNoneMatch"": [],       ""ifUnmodifiedSince"": NumberLong(      -1      ),       ""lastModified"": NumberLong(      -1      ),       ""vary"": [],       ""size"": 2,       ""isEmpty"": false,       ""mapVsList"": {         ""Content-Length"": [           ""120515""         ],         ""Content-Type"": [           ""application/json;charset=UTF-8""         ]       },       ""clazz"": ""org.springframework.http.ReadOnlyHttpHeaders"",       ""hashCode"": 373937919,       ""toString"": ""[Content-Type:\""application/json;charset=UTF-8\"", Content-Length:\""120515\""]""     },     ""statusCode"": {       ""value"": 200,       ""reasonPhrase"": ""OK"",       ""is1xxInformational"": false,       ""is2xxSuccessful"": true,       ""is3xxRedirection"": false,       ""is4xxClientError"": false,       ""is5xxServerError"": false,       ""isError"": false,       ""series"": {         ""value"": 2,         ""declaringClass"": ""org.springframework.http.HttpStatus$Series"",         ""name"": ""SUCCESSFUL"",         ""ordinal"": 1,         ""clazz"": ""org.springframework.http.HttpStatus$Series"",         ""hashCode"": 2089181889,         ""toString"": ""SUCCESSFUL""       },       ""declaringClass"": ""org.springframework.http.HttpStatus"",       ""name"": ""OK"",       ""ordinal"": 4,       ""clazz"": ""org.springframework.http.HttpStatus"",       ""hashCode"": 2123877965,       ""toString"": ""200 OK""     },     ""committedFlag"": true,     ""clazz"": ""org.springframework.http.server.reactive.ReactorServerHttpResponse"",     ""hashCode"": 2095929933,     ""toString"": ""org.springframework.http.server.reactive.ReactorServerHttpResponse@7ced5a4d""   }, } ``` using the following dependencies to be precise ``` > `` 		 			org.springframework.boot 			spring-boot-starter-data-mongodb-reactive 		 		 			org.springframework.boot 			spring-boot-starter-data-mongodb 		 		 			org.springframework.boot 			spring-boot-starter-data-jpa 		 		 			org.springframework.boot 			spring-boot-starter-thymeleaf 		 		 			org.springframework.boot 			spring-boot-starter-webflux 		 		 			org.springframework.boot 			spring-boot-starter-log4j2 		 		 			org.springframework.boot 			spring-boot-starter-mail 		 		 			org.springframework 			spring-context-support 		 		 			org.springframework.data 			spring-data-mongodb 		 		 			org.springframework.data 			spring-data-redis 		 		 			org.springframework.boot 			spring-boot-devtools 			runtime 		 		`` 		 			org.springframework.boot 			spring-boot-starter-test 			test 		 		`` 		 			com.github.TurquoiseSpace 			spring-webflux-http-interceptor 			${turquoise.space.version} 		 ```","closed","","matcdac","2021-02-25T12:52:29Z","2021-03-01T10:19:52Z"
"","26362","ADD getForEntity, postForEntity Overloading function using ParameterizedTypeReference","GetForEntity, PostForEntity Overloading function using ParameterizedTypeReference  There's needs for usage-free to use ParameterizedTypeReference on any RequestEntity function.  ISSUE : https://github.com/spring-projects/spring-framework/issues/26360 MAKE : GetForEntity, PostForEntity Overloading function using ParameterizedTypeReference","closed","status: declined,","Hubtwork","2021-01-08T11:07:12Z","2021-01-08T12:24:22Z"
"","26003","get update from master","get update from master","closed","status: invalid,","dragon-zhang","2020-10-31T02:54:04Z","2020-10-31T10:12:07Z"
"","26439","Support of jakarta.xml.bind-api v3.0.0","From jakarta.xml.bind-api **v3.0.0,** the namespace has been changed to `jakarta.xml.bind.*` instead of `javax.xml.bind` The last working version is jakarta.xml.bind-api **v2.7.8**  The org.springframework.http.codec.support.BaseDefaultCodecs file hardcoded `javax.xml.bind` namespace with  `jaxb2Present = ClassUtils.isPresent(""javax.xml.bind.Binder"", classLoader);` So it's not working for the newer version of jakarta.xml.bind-api.  Would the support be considered to add in any near future release? Thanks!   **Affects:** \<5.3.2>  ---","closed","status: duplicate,","drz0910","2021-01-25T10:13:04Z","2021-01-25T10:21:23Z"
"","26381","Allow MockRestServiceServer to validate requests but actually obtain response via HTTP call","For the cases when using MockRestServiceServer on an integration test, I think we could benefit having some options to make it bypass certain requests that are available in the local environment (acting like a Spy rather than a Stub).  For instance, imagine that we are executing an Integration Test on an app with an endpoint that internally performs 3 requests:   - 1 request to another endpoint of the same app (architecture considerations aside)   - 1 request to an external endpoint that is being already mocked with a docker container according to the testing @Profile   - 1 request to a third-party endpoint that we want to mock  If we autoconfigure MockRestServiceServer and RestTemplate with the simplest setup, we will end up with the requirement of  mocking all requests. Thus, it would be nice to allow certain requests bypassing the expectation or at least the need for a mocked response and let them pass through as real calls.  By doing   `mockRestServiceServer.expect(requestTo(call)); `  with no response definition, one would expect mockRestServiceServer to account the expectation but let the request pass through, but it fails instead complaining that no mocked response has been defined.  At least, IMO this should be the default behaviour when the application (not the test) performs a request against itself (localhost/127.0.0.0), or even more accurately, against a Controller of the same app  My need is described here: https://stackoverflow.com/questions/65693954/is-it-possible-to-make-some-of-my-springboottest-app-requests-to-bypass-spy-in","open","type: enhancement,","nightswimmings","2021-01-13T11:10:46Z","2021-05-04T13:46:58Z"
"","26525","ConversionService is confused by interface extending Converter","For some custom infrastructure, I'm trying to leverage the `GenericConversionService` by creating specialized subinterfaces of `Converter` and wiring up my consuming service by type:  ```java interface IdExtractor extends Converter {}  interface GenericResource {   String getId();    class Extractor implements IdExtractor {     @Override String convert(GenericResource s) { return s.getId(); }   } } ```  This, however, produces a conversion-time error saying that the service could not determine the generic types: ""does the class parameterize those types?""  This appears to be because the service does not introspect through the subinterface, but the types are in fact strongly bound.","open","in: core,","chrylis","2021-02-09T02:51:59Z","2021-11-11T09:32:06Z"
"","26333","5.0.x","for learning","closed","status: invalid,","anglezhang","2021-01-02T16:04:21Z","2021-01-02T16:34:42Z"
"","26659","Migrate CI to concourse","For consistency, let's migrate our `5.2.x` build to Concourse as well.","closed","type: task,","snicoll","2021-03-10T13:21:48Z","2021-03-10T14:11:51Z"
"","26380","@AuthenticationPrincipal resolves to null when spring security is also included","Followup to #26117.  When using boot 2.4.1 with managed spring and spring security dependencies @AuthenticationPrincipal is no longer bound.  Brief debugging appears to indicate that AuthenticationPrincipalArgumentResolver 'supports' the argument and resolves it to null before PrincipalMethodArgumentResolver has a chance to resolve it.    Sample project:  https://github.com/krm1312/spring-auth-principal.  Toggle boot version in pom.xml to see difference.","closed","status: invalid,","krm1312","2021-01-12T22:23:39Z","2021-01-14T20:59:20Z"
"","26502","Expose HttpHandler Decoration as a bean","Follows the development that has been done for https://github.com/spring-projects/spring-framework/issues/25633.  Having the `httpHandlerDecorator` as a bean allows easier integration with Spring Boot, see [`HttpHandlerAutoConfiguration`](https://github.com/spring-projects/spring-boot/blob/v2.4.2/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/HttpHandlerAutoConfiguration.java#L65).  I wasn't sure what version to put in `@since` Javadoc tags.  Let me know what you think.","closed","type: enhancement,","sp00m","2021-02-03T10:00:31Z","2022-02-09T17:12:30Z"
"","26307","Early support for JDK 17","Following up on #24872, early support for Java 17 bytecode is available in ASM master now, which we're upgrading our fork to.","closed","type: enhancement,","jhoeller","2020-12-21T18:32:24Z","2020-12-21T18:34:31Z"
"","26287","Make use of abortOnRequest in Jetty Reactive HttpClient","Following https://github.com/jetty-project/jetty-reactive-httpclient/issues/22#issuecomment-737929481, the Jetty Reactive HttpClient provides an option to abort the request on cancellation. This is something we can enable in our connector.","closed","type: enhancement,","rstoyanchev","2020-12-16T17:18:15Z","2020-12-17T17:34:57Z"
"","25930","Sending an event as part of the EMF lock triggers a deadlock","Follow-up of #25799. With that fix in place, we still get a deadlock unfortunately.  ``` main@1"" prio=5 tid=0x1 nid=NA waiting   java.lang.Thread.State: WAITING 	 blocks task-1@6178 	  at jdk.internal.misc.Unsafe.park(Unsafe.java:-1) 	  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:194) 	  at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:447) 	  at java.util.concurrent.FutureTask.get(FutureTask.java:190) 	  at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.getNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:560) 	  at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:516) 	  at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:731) 	  at com.sun.proxy.$Proxy77.getStatistics(Unknown Source:-1) 	  at io.micrometer.core.instrument.binder.jpa.HibernateMetrics.(HibernateMetrics.java:110) 	  at org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa.HibernateMetricsAutoConfiguration.bindEntityManagerFactoryToRegistry(HibernateMetricsAutoConfiguration.java:68) 	  at org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa.HibernateMetricsAutoConfiguration.lambda$bindEntityManagerFactoriesToRegistry$0(HibernateMetricsAutoConfiguration.java:60) 	  at org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa.HibernateMetricsAutoConfiguration$$Lambda$936.1374688565.accept(Unknown Source:-1) 	  at java.util.LinkedHashMap.forEach(LinkedHashMap.java:684) 	  at org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa.HibernateMetricsAutoConfiguration.bindEntityManagerFactoriesToRegistry(HibernateMetricsAutoConfiguration.java:60) 	  at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1) 	  at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	  at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	  at java.lang.reflect.Method.invoke(Method.java:566) 	  at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:755) 	  at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:130) 	  at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1415) 	  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608) 	  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531) 	  at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	  at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$302.1818449913.getObject(Unknown Source:-1) 	  at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	  - locked <0x258f> (a java.util.concurrent.ConcurrentHashMap) 	  at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	  at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	  at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) 	  at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:925) 	  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:588) 	  - locked <0x2590> (a java.lang.Object) 	  at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:144) ```  With the following state for `task1`, the thread that was created to initialise the JPA infrastructure, and the DB:  ``` ""task-1@6178"" prio=5 tid=0x25 nid=NA waiting for monitor entry   java.lang.Thread.State: BLOCKED 	 waiting for main@1 to release lock on <0x258f> (a java.util.concurrent.ConcurrentHashMap) 	  at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:217) 	  at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	  at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:213) 	  at org.springframework.context.event.AbstractApplicationEventMulticaster.retrieveApplicationListeners(AbstractApplicationEventMulticaster.java:247) 	  at org.springframework.context.event.AbstractApplicationEventMulticaster.getApplicationListeners(AbstractApplicationEventMulticaster.java:204) 	  at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:155) 	  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:426) 	  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:383) 	  at org.springframework.boot.autoconfigure.orm.jpa.DataSourceInitializedPublisher.publishEventIfRequired(DataSourceInitializedPublisher.java:99) 	  at org.springframework.boot.autoconfigure.orm.jpa.DataSourceInitializedPublisher.access$100(DataSourceInitializedPublisher.java:50) 	  at org.springframework.boot.autoconfigure.orm.jpa.DataSourceInitializedPublisher$DataSourceSchemaCreatedPublisher.postProcessEntityManagerFactory(DataSourceInitializedPublisher.java:197) 	  at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:430) 	  at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$$Lambda$779.356347252.call(Unknown Source:-1) 	  at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) 	  at java.util.concurrent.FutureTask.run(FutureTask.java:-1) 	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	  at java.lang.Thread.run(Thread.java:834) ```  There is a sample that reproduces the problem in https://github.com/spring-projects/spring-boot/issues/23735","closed","","snicoll","2020-10-18T06:57:42Z","2021-02-15T09:04:04Z"
"","26869","Avoid memory leak when PropertyComparator is reused","Fixing memoryleak, PropertyComparator was remembering the value it compared in the past.","closed","type: enhancement,","FlorianKirmaier","2021-04-27T12:56:57Z","2021-04-30T13:11:49Z"
"","26272","Fix UriComponentsBuilder validation of file URI #26258","Fixes gh #26258","closed","status: superseded,","encircled","2020-12-15T09:31:58Z","2020-12-17T14:55:51Z"
"","26393","Add support for java.util.Optional to GenericHttpMessageConverter #24498","Fixes #24498  Added unboxing of  `java.util.Optional`  to `AbstractHttpMessageConverter` and `AbstractGenericHttpMessageConverter`. If the object is not unboxed, the underlying message converter receives an instance of `java.util.Optional`, which was causing an issue described in the #24498 in case of Jackson converter. It will also allow to use `Optional<*>` in other message converters without explicitly registering a type converter.","open","type: enhancement,","encircled","2021-01-16T13:09:38Z","2022-06-20T21:02:04Z"
"","26512","Fixed grammar in ResponseEntity documentation","Fixed some grammatical mistakes or instances that were somewhat more difficult to read clearly in the ResponseEntity javadoc comments.  I have checked for issues mentioning this file, but if I have missed anything that already covers this, just let me know.","closed","type: task,","ascopes","2021-02-05T13:11:09Z","2021-02-05T13:31:31Z"
"","26343","fix issue 26317","fix 【@ExceptionHandler methods not invokable if matched on exception's cause level > 1 】 the cause is: ExceptionHandlerMethodResolver#resolveMethodByThrowable Find a Method to handle the given Throwable only find Exception.cause twice   it will not affect the order of looking up for exception handler methods (1.local exception handler method,2.global exception handler method) it only affects ExceptionHandlerMethodResolver.resolveMethod that what we what  hope to adopt","closed","status: invalid,","dongbaibai","2021-01-04T13:04:33Z","2022-06-09T06:49:05Z"
"","26527","Use beans xmlns instead of DTD, so IDEA can process XML files","fix xmlns.So that IDEA will know the bean","closed","status: invalid,","xhd731568849","2021-02-09T08:17:20Z","2021-02-09T14:06:21Z"
"","26254","Fix typo in Javadoc for AbstractJdbcCall","Fix typo in Javadoc for AbstractJdbcCall","closed","type: task,","Alexscari7","2020-12-10T14:42:34Z","2020-12-12T09:42:37Z"
"","26776","Fix javadoc link syntax","Fix the javadoc `@link` syntax should in curly braces.  ![image](https://user-images.githubusercontent.com/6624567/114013600-ab3da580-98a2-11eb-978b-4b0e69ce6416.png)  ![image](https://user-images.githubusercontent.com/6624567/114013697-cc05fb00-98a2-11eb-8376-9023782e5c07.png)","closed","type: documentation,","KENNYSOFT","2021-04-08T10:44:26Z","2021-04-08T12:25:45Z"
"","26217","Fix punctuation typo in javadoc for ResponseExtractor","Fix punctuation typo in javadoc for ResponseExtractor.","closed","type: task,","VonUniGE","2020-12-04T15:41:34Z","2020-12-04T16:19:00Z"
"","26471","Avoid unnecessary wrapping for SqlParameterValue","Fix https://github.com/spring-projects/spring-framework/issues/26467","closed","type: regression,","quaff","2021-01-29T02:39:38Z","2021-02-15T11:01:01Z"
"","26830","Daylight saving time issue in CronExpression","Expressions set on the exact hour of a daylight saving time (such as `""0 10 2 * * *""` in timezone Central Europe) result in a `null` value being return for `next`, when passing a time before the turnover (for instance, 01:09:00).  This issue seems to be caused by the fix for #26744.  /cc @sbrannen","closed","in: core,","poutsma","2021-04-20T14:23:25Z","2021-04-21T10:08:38Z"
"","26622","Fix @EventListener example in reference manual","Example code will throw an exception.","closed","type: task,","alex-krav","2021-03-01T15:56:03Z","2021-03-01T19:25:45Z"
"","26788","Fix lazy inject for prototype","Everytime a method of a lazy injected prototype bean is invoked, Spring will instantiate the bean once again. No need to invoke `doResolveDependency()` repeatedly since target is already created.","open","in: core,","ShaoqiangLu","2021-04-11T12:56:38Z","2021-11-11T09:50:26Z"
"","26668","Unable to remove Transfer Encoding : chunked using WebClient","Even after setting content length using the API webclient.contentLength() chunk encoding is not getting disabled.","closed","in: web,","vaibsgharge","2021-03-12T06:30:25Z","2021-03-29T13:53:05Z"
"","26484","Fix Javadoc in StandardServletAsyncWebRequest","Escape < and > correctly.","closed","type: task,","limo520","2021-02-01T08:06:10Z","2021-02-01T08:27:41Z"
"","26848","webflux-sourcecode-help will repesponse.writeflush  cause memory leak?","Environment: linux java: java8 spring: spring-boot-starter-webflux 2.3.2.RELEASE  reactor-netty I was using write response in this way,  **Will there be a memory leak**?  ```java     public Mono filter(ServerWebExchange exchange, WebFilterChain webFilterChain) {        // here is io thread         return webFilterChain.filter(exchange).then(Mono.defer(() -> {             // here is business thread              // business code             result = outputstream             DataBuffer dataBuffer;             try {                 dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes(""UTF-8""));             } catch (UnsupportedEncodingException e) {                 throw new SystemException(""write-error"",e);             }             return response.writeWith(Mono.just(dataBuffer));         }));     } ``` For there was used by netty and netty's pooled buffer should be created and be released in the same thread or there will be a memory leak.  To avoid the leak, I study the source code  ``` 	public final Mono writeWith(Publisher body) { 		// For Mono we can avoid ChannelSendOperator and Reactor Netty is more optimized for Mono. 		// We must resolve value first however, for a chance to handle potential error. 		if (body instanceof Mono) { 			return ((Mono) body) 					.flatMap(buffer -> doCommit(() -> 							writeWithInternal(Mono.fromCallable(() -> buffer) 									.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)))) 					.doOnError(t -> getHeaders().clearContentHeaders()); 		} 		else { 			return new ChannelSendOperator<>(body, inner -> doCommit(() -> writeWithInternal(inner))) 					.doOnError(t -> getHeaders().clearContentHeaders()); 		} ``` **would you tell me when the doOnDiscard will work and the thread of DataBufferUtils::release is the same as bufferFactory.wrap?**","closed","for: stackoverflow,","taojiaenx","2021-04-22T18:59:10Z","2021-04-30T03:39:10Z"
"","26248","A question about spring mvc ArgumentResolver","Environment:  - Spring Version 5.2.6  - JDK1.8  Question:   The parameters from the front end **POST** request are like this`{""data"": {""a"": 1, ""b"": ""hello""}}`.   I hope the following two methods can be used to automatically bind parameters.  1. Map hello(Integer a, String b){} 2. Map hello(ParamVo vo){}  > The ParamVo like this `class ParamVo{ Integer a; String b; }`  To do this，We need to take the **data** from the JSON object and assign values to the method parameters. My approach:  1. I declare a annotation like this `@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @RestController public @interface DataRestController { }`  2. I declare a class implement by HandlerMethodArgumentResolver,like this: `public class DataRestControllerArgumentResolver implements HandlerMethodArgumentResolver {     @Override     public boolean supportsParameter(MethodParameter parameter) {         return parameter.getDeclaringClass().getAnnotation(DataRestController.class) != null;     } }`  The purpose of doing this is to realize my purpose in the method **resolveargument**, and take the **data** from the JSON object for parameter binding.Because spring MVC can only directly take data from JSON object for binding. But unfortunately, When my controller method Usage 1 like this `Map hello(Integer a, String b){}`. The class **RequestParamMethodArgumentResolver**  managed parameter resolution.Spring MVC will not use my custom class **DataRestControllerArgumentResolver** .  So what should I do?  I think a solution, The `RequestMappingHandlerAdapter#getDefaultArgumentResolvers`, use an ordered list and load the customer's `HandlerMethodArgumentResolver` first.","closed","for: stackoverflow,","hunjipo","2020-12-10T05:35:16Z","2020-12-10T17:53:50Z"
"","26215","ReactiveElasticsearchOperations does not have option to include request_cache path param in search request","Elastic search provides an option to add a path param to any search queries  called _request_cache=true which enables it to cache any incoming queries and its results.  The SearchRequest class provides a way to add this param using the .requestCache(Boolean.TRUE) method. But the RequestFactory.java present in Spring DATA that converts a NativeSearchQuery into SearchRequest doesn't support this argument.  Thus this parameter cannot be added to any request for search using ReactiveElasticSearchOperations","closed","for: external-project,","oindrilabarik14","2020-12-04T12:59:38Z","2020-12-04T13:11:10Z"
"","26855","Use HttpMethod enum constants instead of strings in DispatcherServlet","doDispatch method of Dispatcher servlet class uses hard coded strings, such as ""GET"" and ""HEAD"". so, I replaced it with HttpMethod enum.","closed","type: task,","BryceYangS","2021-04-24T00:04:33Z","2021-05-04T11:14:23Z"
"","26395","Use java 11 style with var when use val style for Kotlin","Documentation  uses old java 8 style and for code samples and at same time uses Kotlin val style.  Here is an example  Java  (now) `ApplicationContext context = new ClassPathXmlApplicationContext(""services.xml"", ""daos.xml"");` Kotlin(now) `val context = ClassPathXmlApplicationContext(""services.xml"", ""daos.xml"")`  Please, use Java 11 style so java section should be: `var  context = new ClassPathXmlApplicationContext(""services.xml"", ""daos.xml""); `","closed","status: declined,","yilativs","2021-01-17T19:56:02Z","2021-01-18T08:30:52Z"
"","26754","Event source not working with CORS","Do you think the limitation of SockJS EventSource on ""same origin"" is still relevant?  https://github.com/spring-projects/spring-framework/blob/58e40d1aa2c23f6d9c41d4289f5b5debc10868f6/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/TransportType.java#L45  I have the feeling this is reflecting the old lack of cors in event source specification, but the spec has been improved since :  https://www.w3.org/TR/eventsource/  But once again, this is my very first time ""playing"" with SSE. Another point of view can help before working on any PR.","closed","","kbuntrock","2021-04-02T10:04:37Z","2021-04-20T19:10:27Z"
"","26814","HandlerMappingIntrospector does not work with PathPattern backed HandlerMappings","Discovered whilst working on https://github.com/spring-projects/spring-boot/issues/24645. Running [`CorsSampleActuatorApplicationTests.preflightRequestToEndpointShouldReturnOk` from this branch](https://github.com/philwebb/spring-boot/tree/gh-24645) should replicate the problem.  This issue is a quite subtle and hard to replicate. I've found it to cause problems for `CorsFilter` as well as `MvcRequestMatcher` in Spring Security. It appears that `HandlerMappingIntrospector` can fail to find mappings if they are configured with a `PathPattern`.  In `AbstractHandlerMapping.initLookupPath` there's the following branch:  ```java if (usesPathPatterns()) { 	request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE); 	RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request); 	String lookupPath = requestPath.pathWithinApplication().value(); 	return UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath); } else { 	return getUrlPathHelper().resolveAndCacheLookupPath(request); } ```  This means that `ServletRequestPathUtils.getParsedRequestPath(request)` is called when a `PathPattern` is set. That code will fail if `request.getAttribute(PATH_ATTRIBUTE)` is `null`.  Usually `HandlerMappers` are only called from the `DispatcherServlet` which has the following logic:  ``` RequestPath previousRequestPath = null; if (this.parseRequestPath) { 	previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE); 	ServletRequestPathUtils.parseAndCache(request); } ```  The problem is that `HandlerMappingIntrospector` is designed to be called from a `Filter` which means that it can be executed before the `DisatcherServlet` runs.","closed","type: bug,","philwebb","2021-04-16T00:33:25Z","2021-04-16T18:56:36Z"
"","26441","Difficulty building source code in IntelliJ","Difficulty building source code in IntelliJ  Env: OS: win10(10.0.18363.1316 showed by cmd) jdk: jdk11.0.10(AdoptOpenJDK) gradle: 6.7.1 idea: 2020.2 build was based on  commit: e4dc863ad09ed942430c4775623eda2867d9800d  I have followed this https://github.com/spring-projects/spring-framework/wiki/Build-from-Source#before-you-start 1.Problem presentation （annotation from jdk.jfr in FlightRecorderStartupEvent.java was not exist） ![image](https://user-images.githubusercontent.com/24730191/105704375-ae82ef80-5f49-11eb-81ae-5edc775f895b.png) 2.using jdk ![image](https://user-images.githubusercontent.com/24730191/105704424-be9acf00-5f49-11eb-9c79-46d74395ab07.png) 3.gradle setting ![image](https://user-images.githubusercontent.com/24730191/105704455-c9edfa80-5f49-11eb-86aa-b4b67dee787a.png) 4.my JAVA_HOME ![image](https://user-images.githubusercontent.com/24730191/105704538-ed18aa00-5f49-11eb-8650-7b9594470eb3.png)  am i using wrong jdk setting? Why can't I run my demo.Hope to get a reply","closed","status: invalid,","DA1Y1","2021-01-25T12:18:48Z","2021-01-26T11:09:41Z"
"","26432","DefaultResponseErrorHandler should check #read return value","DefaultResponseErrorHandler calls Reader#read without checking its return value. It assumes that Reader#read fills as much of the buffer as possible however the API contract makes no such guarantees.","closed","status: feedback-provided,","marschall","2021-01-22T17:24:47Z","2021-01-25T13:40:32Z"
"","26480","URL and HTTP method in rest client exception message","Dear team,  This is a followup of a discussion in a past PR: https://github.com/spring-projects/spring-framework/pull/1956  The rest client exception contains a preview of the body, which is great, and it helps a lot to quickly diagnose errors.  Now, the stacktrace looks like this: ``` Caused by: org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 Server Error: [no body] 	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:101) 	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:238) 	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:147) ```  I'd like to add the HTTP method and URL to the error, so that the stacktrace looks like this: ``` Caused by: org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 Server Error after GET http://localhost:49709/status/server : [no body] 	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:101) 	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:238) 	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:147) ```  Thank you!","closed","type: enhancement,","jerzykrlk","2021-01-31T12:58:01Z","2021-02-25T10:31:59Z"
"","26837","The Bug of DeferredImportSelectorHandler !","Dear Spring Boot Team:         I think the handle method has a bug , the deferredImportSelectors can not be null forever !  My version is  2.3.3.RELEASE .  ```java private class DeferredImportSelectorHandler {      @Nullable     private List deferredImportSelectors = new ArrayList<>();      public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {         DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);         // This can not be null forever !         if (this.deferredImportSelectors == null) {             DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();             handler.register(holder);             handler.processGroupImports();         }else {             this.deferredImportSelectors.add(holder);         }     } } ```","closed","","zongf0504","2021-04-21T07:26:04Z","2021-04-21T08:00:02Z"
"","26445","Support for servletPath prefix with PathPatternParser in Spring MVC","Currently, when parsed patterns are configured for use, we create a `RequestPath` by parsing the `requestURI` without having to decode it first which avoids issues with encoded reserved characters. For `pathWithinApplication()` we take into account the `contextPath` but not the `servletPath`. It is a challenge to work with the `servletPath` because it is decoded and somewhat normalized and that makes it difficult to use to do a sub-string match against the `requestURI` in order to determine the remaining path.  This is okay for the needs of the default Servlet mapping `""/""` which is the most common way to configure the DispatcherServlet but in some cases there is a  need to run two Servlets side by side.   The goal of this issue is to add support for allow the DispatcherServlet to be mapped by prefix, so it can run side by side with another Servlet, and still be able to enable use of parsed patterns. We can do this by checking that the `HttpServletMapping` is `MappingMatch.PATH` (Servlet 4.0+), re-encoding the servletPath in order to make it comparable to the `requestURI`, and then exposing a `RequestPath` that omits `contextPath` and the `servletPath` from the `pathWithinApplication()`.","closed","type: enhancement,","rstoyanchev","2021-01-26T12:17:16Z","2021-01-26T17:31:12Z"
"","26373","Can we manage thread pool in webclient when sending a request?","Currently, I'm migrating RestTemplate to webClient. In RestTemplate have coroutineDispatcher to manage thread pool of app. ``` val coroutineDispatcher = ThreadPoolExecutor(         0,         1,         1L,         TimeUnit.HOURS,         LinkedBlockingQueue(), )         .asCoroutineDispatcher() ``` When I send an HTTP request, I found out that it's created all thread that my pc has. But the app's requirement spec needs a config like the coroutineDispatcher above, and I cannot find a way to configure it on webClient.","closed","for: stackoverflow,","bastayanfa","2021-01-12T09:05:06Z","2021-01-15T14:16:01Z"
"","26721","Refactor model attribute construction into reusable code","Currently, both MVC's `ModelAttributeMethodProcessor` and WebFlux's `ModelAttributeMethodArgumentResolver` share similar (though not identical) code for instantiating beans from request parameters:   * MVC's [`ModelAttributeMethodProcessor::constructAttribute`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/method/annotation/ModelAttributeMethodProcessor.java#L237-L319) * WebFlux's [`ModelAttributeMethodArgumentResolver::constructAttribute`](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ModelAttributeMethodArgumentResolver.java#L210-L251)  We should try to refactor this code into something usable from both MVC and WebFlux, and which can also be used from WebMvc.fn and WebFlux.fn in the future.","open","type: enhancement,","poutsma","2021-03-24T15:09:27Z","2021-11-01T14:36:26Z"
"","26438","Add support of websocket scope for non-STOMP endpoints.","Currently there is no way for Spring's implementation of websocket endpoints to track session or provide appropriate websocket scope. Existing solution (WebSocketMessageBrokerConfigurer) takes into account only STOMP protocol which is defenitely not enough.","open","in: web,","mahairod","2021-01-24T09:40:45Z","2021-11-10T11:43:10Z"
"","26553","Initialize beans with coroutine context","Currently there are a few ways to initialize beans, but i did not find a way to initialize a class that require a coroutine context.  For example we can take the following class: ```kotlin class FooService private constructor(...) {   companion object {     suspend fun create(...): FooService {       return FooService(...)     }   } } ```  To initialize this service as a bean, it can not be marked as a `@Component` and should be registered as a `@Bean`. It would be great if the following was possible:  Register `@Bean` with a suspend function. e.g. ```kotlin @Configuration class FooConfiguration {   @Bean   suspend fun fooService(...) {     return FooService.create(...)   } } ```  Add bean using `BeanDefinitionDsl`. e.g. ```kotlin coBeans {   bean {     FooService.create(...)   } }.initialize(applicationContext) ```  This also leads to other places where a coroutine context would be helpful, or if the infrastructure would be based on callbacks / futures. For example in my project we have a use-case where we use the `beans` dsl to register beans triggered from a `ApplicationListener`. It would be great if `onApplicationEvent` could also have a suspend version so the `coBeans` dsl could be used from there as well.  Currently the only way i could find to overcome this is using `runBlocking` in those places, which is not recommended and can cause problems.","open","in: core,","tomfi","2021-02-16T07:36:51Z","2021-11-11T09:32:06Z"
"","26643","RSocket - lack of error status codes from responder to requester","Currently RSocket requester receives only **_ApplicationErrorException_** when server throws say IllegalArugmentException or any custom exception.   Now there is no way to clearly communicate the error to the requester!  Can you provide any workaround / add support?","closed","for: external-project,","kitkars","2021-03-04T22:27:54Z","2021-03-05T14:43:08Z"
"","26427","Provide better lifecyle for WebMvcConfigurer.configurePathMatch","Currently `WebMvcConfigurer.configurePathMatch(...)` is called as a side-effect of `WebMvcConfigurationSupport.getPathMatchConfigurer()`. This makes it quite hard to use in `@Bean` method since it's hard to tell if the `@Bean` method or the `configurePathMatch(...)` method will be called first.  You can see an example of this in Spring Data Rest where the [restHandlerMapping](https://github.com/spring-projects/spring-data-rest/blob/5ccf13927886fe001949e3cdc0ae4a0c4c135c4b/spring-data-rest-webmvc/src/main/java/org/springframework/data/rest/webmvc/config/RepositoryRestMvcConfiguration.java#L640) bean would ideally have a `PatternParser` on the delegates before the `afterPropertiesSet()` method is called. The current solution of overriding `configurePathMatch` and calling `setPatternParser` directly is brittle because the parser is needed before `afterPropertiesSet()` is called. This leads to issues such as #26415  It's possible to work-around the issue by adding `@DependsOn(""mvcPathMatcher"")` which will indirectly trigger the `WebMvcConfigurationSupport.getPathMatchConfigurer()` method, but this isn't ideal.  I wonder if we could make `PathMatchConfigurer` or the `PatternParser` a `@Bean` so that it can be injected directly if it's needed?","closed","type: enhancement,","philwebb","2021-01-21T20:08:06Z","2021-02-05T12:34:55Z"
"","26649","Make use of Reactor Netty API for request id","Currently `ReactorServerHttpRequest` sets the request id based on the Netty channel id and it also adds an integer that's incremented for each request to ensure a unique request id when connections are re-used for multiple requests. The request id is used for the log prefix to correlate messages.   This happens to align with Reactor Netty that also uses the channel id, but also the remote and local address. After https://github.com/reactor/reactor-netty/pull/1530, Reactor Netty now provides an API for the request id it uses. It has a couple of advantages. One, the number appended to the connection id, is a local counter of requests on the connection, and not global one across all requests. Second, it offers the longer version with the local/remote address and connection status.  We can take advantage of this new API when Reactor Netty 1.0.5 or higher is on the classpath. It will help to remove an `AtomicInteger`. For the longer version of the request id, we could perhaps use that when logging is as DEBUG level.","closed","type: enhancement,","rstoyanchev","2021-03-08T12:19:36Z","2021-03-08T21:07:38Z"
"","26462","Allow AbstractEnvironment subclasses to use custom ConfigurablePropertyResolver and MutablePropertySources","Currently `AbstractEnvironment` directly creates a `MutablePropertySources` and `PropertySourcesPropertyResolver`. It would be helpful to use factory methods so that subclasses can use different implementations.","closed","type: enhancement,","philwebb","2021-01-27T23:36:58Z","2021-02-15T15:54:04Z"
"","26121","Fail MethodFilter.and() immediately when null is passed","Current when one passes `null` into `MethodFilter.and()` probable NPE is deferred making it less convenient to detect the reason. I think we should check incoming param immediately.","closed","in: core,","stsypanov","2020-11-19T15:41:05Z","2020-11-26T14:17:52Z"
"","26313","CronExpression cannot parse combination of step values","CronExpression throws IllegalArgumentException when you use following expression: ```java new CronExpression.parse(""* 5,10-30/2 * * * *"") ```  ``` java.lang.IllegalArgumentException: For input string: ""5,10"" '5,10-30/2' in cron expression ""* 5,10-30/2 * * * *"" 	at org.springframework.scheduling.support.CronExpression.parse(CronExpression.java:201) 	at org.jetbrains.kotlin.idea.scratch.generated.ScratchFileRunnerGenerated$ScratchFileRunnerGenerated.generated_get_instance_res0(tmp.kt:11) 	at org.jetbrains.kotlin.idea.scratch.generated.ScratchFileRunnerGenerated.main(tmp.kt:20) Caused by: java.lang.IllegalArgumentException: For input string: ""5,10"" '5,10-30/2' 	at org.springframework.scheduling.support.BitsCronField.parseField(BitsCronField.java:150) 	at org.springframework.scheduling.support.BitsCronField.parseMinutes(BitsCronField.java:75) 	at org.springframework.scheduling.support.CronField.parseMinutes(CronField.java:66) 	at org.springframework.scheduling.support.CronExpression.parse(CronExpression.java:191) 	... 2 more Caused by: java.lang.NumberFormatException: For input string: ""5,10"" 	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) 	at java.base/java.lang.Integer.parseInt(Integer.java:652) 	at java.base/java.lang.Integer.parseInt(Integer.java:770) 	at org.springframework.scheduling.support.BitsCronField.parseRange(BitsCronField.java:165) 	at org.springframework.scheduling.support.BitsCronField.parseField(BitsCronField.java:135) 	... 5 more ```  CronSequenceGenerator is able to parse the same expression. ```java new CronSequenceGenerator(""* 5,10-30/2 * * * *"") ```  **Affects:** 5.3","closed","in: core,","m15o","2020-12-23T05:12:10Z","2021-01-04T15:49:04Z"
"","26731","awaitBodyOrNull function to handle empty body","Created awaitBodyOrNull function to handle empty body  `suspend inline fun  WebClient.ResponseSpec.awaitBody() : T ` does not handle nullable body  `suspend fun WebClient.ResponseSpec.awaitBodilessEntity()` ignores body completely even when the content-length is above zero","closed","type: enhancement,","ValentinShakhov","2021-03-25T21:37:01Z","2021-04-01T15:09:53Z"
"","26403","Introduce public defineClass variant for SmartClassLoader implementations","Considering some scenarios raised in #22814, it seems that Boot's `RestartClassLoader` is commonly the target of a newly defined proxy class there, with the original class living in the system class loader (either because of early loading or simply because it is a JDK library class). In such a scenario, we have to fall back to a `ClassLoader`-specific `defineClass` call - which we traditionally do through a reflective call to the protected `defineClass` method, triggering an illegal access warning on JDK 9+ (and not working at all anymore with illegal access being denied, forcing us to fall back to defining the proxy class in the same class loader as the original class, i.e. the system class loader, since this is the only thing JDK 9's ´Lookup.defineClass` can do).  While we cannot generally solve the problem for arbitrary nested class loader scenarios, we can introduce a public hook for class loader implementations that we control. By extending the `SmartClassLoader` interface to not only identify reloadable classes (its traditional purpose) but to also allow for flexible class definitions through a new `publicDefineClass` method, Boot's `RestartClassLoader` can implement it with a simple delegation to its ClassLoader-inherited protected `defineClass` method:  ``` 	@Override 	public Class publicDefineClass(String name, byte[] b, @Nullable ProtectionDomain protectionDomain) { 		return defineClass(name, b, 0, b.length, protectionDomain); 	} ```  Since we cannot detect the `SmartClassLoader` interface at the CGLIB implementation level (for dependency reasons), we could instead simply detect the `publicDefineClass` method by convention in CGLIB's `ReflectUtils`. Any `ClassLoader` implementation with such a method signature can therefore comply with that convention, without introducing a dependency on `spring-core`.","closed","type: enhancement,","jhoeller","2021-01-19T10:21:51Z","2021-01-19T11:04:11Z"
"","26387","Throwing SkipException should not fail the test with TestNG","Consider below example: Example uses following dependencies: spring-test:5.3.3 spring-context:5.3.3 spring-core:5.3.3 testng:7.3.0  ```java package com;  import com.SkipTest.SkipTestConfig; import com.SkipTest.SkipTestListener; import org.springframework.context.annotation.Configuration; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.testng.AbstractTestNGSpringContextTests; import org.testng.IInvokedMethod; import org.testng.IInvokedMethodListener; import org.testng.ITestResult; import org.testng.SkipException; import org.testng.annotations.Listeners; import org.testng.annotations.Test;  @ContextConfiguration(classes = SkipTestConfig.class) @Listeners(SkipTestListener.class) public class SkipTest extends AbstractTestNGSpringContextTests {      @Test     public void shouldNotBeExecuted() {         System.out.println(""EXECUTED"");     }      @Configuration     public static class SkipTestConfig {      }      public static class SkipTestListener implements IInvokedMethodListener {         @Override         public void beforeInvocation(IInvokedMethod iInvokedMethod, ITestResult iTestResult) {             throw new SkipException(""skip"");         }          @Override         public void afterInvocation(IInvokedMethod iInvokedMethod, ITestResult iTestResult) {             System.out.println(iTestResult.getStatus());         }     } } ```  When `extends AbstractTestNGSpringContextTests` is added then test fails because throwing `SkipException` in listener method is treated as any other exception. When `extends AbstractTestNGSpringContextTests` is removed, then `shouldNotBeExecuted` is skipped as expected.  Use case: My system level tests use TestNG listener mechanism to perform several actions, one of which is deciding if given system test can be executed. If test should not be executed then we mark it as skipped and throw `SkipException`. This worked flawlessly for TestNG versions 6.+ for version 7.+ it does not, and the issue seems to be in `AbstractTestNGSpringContextTests`.","closed","for: external-project,","klubi","2021-01-14T11:11:33Z","2021-01-15T08:26:03Z"
"","26779","Allow spring-expression to be more easily repackaged for embedding in third-party JARs","Compiled expressions don't work when you use https://imperceptiblethoughts.com/shadow/configuration/relocation/. This would allow the compiled expression to be relocated correctly.","closed","type: enhancement,","BFergerson","2021-04-08T21:15:46Z","2021-04-09T15:55:38Z"
"","26390","CronExpression skips a temporal when last day of the month and `*` expression is used","Combining `last day of the month` with `*` may cause a temporal to be skipped depending on the seed time.  ```java var everyHourLastDayOfTheMonth = CronExpression.parse(""0 0 * L * *""); System.out.println(everyHourLastDayOfTheMonth.next(OffsetDateTime.parse(""2021-01-30T00:00:00Z""))); System.out.println(everyHourLastDayOfTheMonth.next(OffsetDateTime.parse(""2021-01-30T23:00:00Z""))); ```  Actual: ``` 2021-01-31T01:00Z 2021-01-31T00:00Z ```  Expected: ``` 2021-01-31T00:00Z 2021-01-31T00:00Z ```  **Affects:** 5.3.3","closed","in: core,","m15o","2021-01-15T09:00:45Z","2021-01-19T14:19:27Z"
"","26126","Delegate to AopUtils.invokeJoinpointUsingReflection from AbstractAspectJAdvice","Code can be reused to make the code more concise.","closed","in: core,","polarbear567","2020-11-20T06:08:08Z","2020-11-20T11:39:56Z"
"","26478","add indexAccessor for SpEL.","closes gh-26409.","open","status: feedback-provided,","jackmiking","2021-01-30T09:24:55Z","2021-04-27T05:06:15Z"
"","26442","Introduce 'idleReceivesPerTaskLimit' in DefaultMessageListenerContainer","Closes GH-26195","closed","type: enhancement,","koen-serneels","2021-01-25T21:18:22Z","2021-03-16T09:30:09Z"
"","26513","Added ResponseEntity.created(void) method","Closes gh-25068","closed","status: declined,","sachingorade","2021-02-05T22:58:20Z","2021-02-08T14:20:17Z"
"","26366","Make ExceptionHandler invokable when matching deeply nested cause","Closes #26317","closed","status: superseded,","rod2j","2021-01-11T00:48:47Z","2021-04-27T11:37:06Z"
"","26752","Ensure that the ExposeInvocationInterceptor is first in the interceptor chain","check the ExposeInvocationInterceptor is front in the interceptor chain issue #26743","open","in: core,","wisty","2021-04-02T02:12:46Z","2021-06-07T12:14:02Z"
"","26862","Fix aspect autodetection description","Chapter *5. Aspect Oriented Programming with Spring*, section *5.4.2. Declaring an Aspect* of official documentation contains incomplete description of aspect autodetection. We need to add **@Bean** factory method to description.","closed","type: task,","hrybs","2021-04-26T19:54:41Z","2021-04-28T13:38:04Z"
"","26852","Fix SpEL selection description in ref docs","Chapter *4. Spring Expression Language(SpEL)*, section *4.3.16. Collection Selection* of official documentation contains incomplete description of SpEL collection selection. We need to add array to description.","closed","type: task,","hrybs","2021-04-23T07:18:52Z","2021-04-28T13:47:31Z"
"","26846","Improve documentation for SpEL constructor support","Chapter *4 Spring Expression Language (SpEL)*, section *4.3.9. Constructors* of official documentation contains incorrect description of default behavior. According to source code of *org.springframework.expression.spel.support.StandardEvaluationContext* there is a use of *org.springframework.expression.spel.support.StandardTypeLocator* class. According to the source code of letter class the core package '*java.lang*' is registered by default.","closed","type: task,","hrybs","2021-04-22T07:12:43Z","2021-04-22T17:02:13Z"
"","26865","Fix MessageSource doc description","Chapter *1. The IoC Container*, section *1.15.1. Internationalization using MessageSource* contains incorrect description of *MessageSource* implementation classes. There are 3 base classes but not 2.","closed","type: task,","hrybs","2021-04-27T10:15:49Z","2021-04-28T10:04:01Z"
"","26773","Fix @Scope documentation in ref docs","Chapter *1. The IoC Container*, section *1.12.3. Using the @Bean Annotation*, paragraph *Specifying Bean Scope* of official documentation contains incorrect description of **@Scope** annotation.  The default value of *proxyMode* attribute is not *ScopedProxyMode.NO* but is *ScopedProxyMode.DEFAULT* which has absolutely different behaviour.","closed","type: task,","hrybs","2021-04-07T15:41:07Z","2021-04-29T16:09:01Z"
"","26647","Support for dynamic interceptor during setup in RSocket","Can we add the support to decide the interceptor to be added at run time for requester/responder during @ConnectMapping.?","closed","for: external-project,","kitkars","2021-03-06T18:18:18Z","2021-03-30T14:29:34Z"
"","26706","Treat RowSet column labels as case-insensitive","CachedRowSetImpl doesn't allow for column label use (SPR-7506).  Looking up values by labels in RowSet is supported by ResultSetWrappingSqlRowSet, with fallback to wrapped ResultSet if nothing found. Unfortunately it works in case-sensitive manner (HashMap).  Assume there is a table: CREATE TABLE T(col int)  And code: SqlRowSet srs = jdbcTemplate.queryForRowSet(query); if ( srs.next() ) srs.getInt(""col""); // do smth with value  Queries: 1. select col from T -- ok, column name here, and column name == column label 2. select 0 as col from T -- ok, column label, cache in ResultSetWrappingSqlRowSet handle this 3. select 0 as Col from T -- error, column name != column label, + cache miss  3.1. column name != column label 3.2. code in ResultSetWrappingSqlRowSet can't find column by label, because ""col"" != ""Col"" 3.3. wrapped ResultSet (RowSet, CachedRowSetImpl) can't find column by name, because there is no column name  This commit change column-label treatment to case-insensitive.","closed","status: declined,","navol","2021-03-19T16:13:27Z","2021-11-30T16:21:13Z"
"","26490","CORS Headers Added to Pre-Flight Request on Ambiguous Match Even Without @CrossOrigin","By default CORS support is disabled but in case of multipe valid method mappings, Spring just adds CORS Headers to preflight requests with allowed origin *!   In AbstractHandlerMethodMapping.lookupHandlerMethod():410 there is a check, whether a mapping has more than one matches. If its a perfect match, everything is fine here. But in the case, that there a multiple mappings EVERY preflight requests will be handled by PREFLIGHT_AMBIGUOUS_MATCH.  ``` 		if (!matches.isEmpty()) { 			Match bestMatch = matches.get(0); 			if (matches.size() > 1) { 				Comparator comparator = new MatchComparator(getMappingComparator(request)); 				matches.sort(comparator); 				bestMatch = matches.get(0); 				if (logger.isTraceEnabled()) { 					logger.trace(matches.size() + "" matching mappings: "" + matches); 				} 				if (CorsUtils.isPreFlightRequest(request)) { 					return PREFLIGHT_AMBIGUOUS_MATCH; 				} [..] ``` https://github.com/spring-projects/spring-framework/blob/c82a4450949287c7d426aa53fe198de2968be312/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java#L410  Just a few lines later, the cors configurations will be gathered and for this special handler, the CORS-configuration will allow everything to everyone. https://github.com/spring-projects/spring-framework/blob/c82a4450949287c7d426aa53fe198de2968be312/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java#L477  You can simply check this behavior by making a brand new Spring Boot application with Spring Web without any changes. Just send an OPTIONS request to `/error`. `BasicErrorController` has two mappings for this path and voila.  ``` curl -v -H ""Origin: http://any.origin"" -H ""Access-Control-Request-Method: GET"" -X OPTIONS http://localhost:8080/error *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > OPTIONS /error HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.55.1 > Accept: */* > Origin: http://any.origin > Access-Control-Request-Method: GET > < HTTP/1.1 200 < Vary: Origin < Vary: Access-Control-Request-Method < Vary: Access-Control-Request-Headers < Access-Control-Allow-Origin: http://any.origin < Access-Control-Allow-Methods: GET < Access-Control-Allow-Credentials: true < Allow: GET, HEAD, POST, PUT, DELETE, OPTIONS, PATCH < Content-Length: 0 < Date: Mon, 01 Feb 2021 22:46:36 GMT < * Connection #0 to host localhost left intact ```  All in all: I don't want my app to respond with CORS-headers at all, as I do not have any CORS configuration, but unfortunately Spring just adds those headers to my responses.","closed","type: bug,","AlexErmer","2021-02-01T22:47:54Z","2021-02-03T12:13:42Z"
"","26627","Support UTF-16 and UTF-32 in Jackson HttpMessageConverters","Besides UTF-8, Jackson supports UTF-16 and UTF-32, but because neither are present in Jackson's `JsonEncoding` enum, we treat them like any other encoding, and convert them using an `InputStreamReader`. This should be fixed.","closed","type: enhancement,","poutsma","2021-03-02T13:38:39Z","2021-03-02T13:48:16Z"
"","26001","Support multiple aliases via @AliasFor #25857","Before time ,one annotation attribute only supports one alias ,you can only do like this:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test1 {         String test1() default ""test1"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test2 {         String test2() default ""test2"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test1     @Test2     public @interface Test3 {          @AliasFor(annotation = Test1.class, attribute = ""test1"")         String test3() default ""test3"";          @AliasFor(annotation = Test2.class, attribute = ""test2"")         String test4() default ""test4"";     } ```  But now ,you can do this more easily:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test1     @Test2     public @interface Test3 {          @AliasFor(annotation = Test1.class, attribute = ""test1"")         @AliasFor(annotation = Test2.class, attribute = ""test2"")         String test3() default ""test3"";     } ```  Moreover, the mutual aliasing of different attributes in the same annotation can break the original limitation (although this kind of use scenario is less):  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test4 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test"";          @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test"";     } ```  Combine examples above, you can use @AliasFors like this:  ```java     @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface Test5 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test1"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test1"";          @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test1"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test5     public @interface Test6 {          @AliasFor(""test2"")         @AliasFor(""test3"")         String test1() default ""test2"";          @AliasFor(""test1"")         @AliasFor(""test3"")         String test2() default ""test2"";          @AliasFor(annotation = Test5.class)         @AliasFor(""test1"")         @AliasFor(""test2"")         String test3() default ""test2"";     }      @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @Test6     public @interface Test7 {          @AliasFor(annotation = Test6.class)         String test3() default ""test3"";     }      @Test7(test3 = ""override the method"")     public static class Element4 {     }      @Test     public void test3() {         Test5 test5 = AnnotatedElementUtils.getMergedAnnotation(Element4.class, Test5.class);         Test6 test6 = AnnotatedElementUtils.getMergedAnnotation(Element4.class, Test6.class);         System.out.println(test5.toString());         System.out.println(test6.toString());         assertEquals(""override the method"", test6.test1());         assertEquals(""override the method"", test6.test2());         assertEquals(""override the method"", test6.test3());         assertEquals(""override the method"", test5.test1());         assertEquals(""override the method"", test5.test2());         assertEquals(""override the method"", test5.test3());     } ```  For more details, please read `org.springframework.core.annotation.AlisforsTests`.  I have submitted the code earlier this month (attached link: https://github.com/spring-projects/spring-framework/pull/25857). I'd like to ask you masters, when is this feature expected to be available online?","closed","type: enhancement,","dragon-zhang","2020-10-30T08:47:17Z","2020-11-02T09:37:30Z"
"","26794","Close jar files after opening a connection","Before this PR jar files that were accessed via a URLResource, would stay opened indefinitely, and thus prevent the file from being modified. This PR fixes this by closing the JarURLConnection that is opened when calling `exists()`, `contentLength()` or `lastModified()` on `Resource`.","closed","type: enhancement,","f-cramer","2021-04-13T11:07:50Z","2022-06-21T21:59:02Z"
"","26224","Release a version to Jakarta EE 9","Before the Spring framework moving to the Jakarta EE 9/10 stack. I hope Spring can consider releasing a Jakarta EE 9.0 version alongside the Jakarta EE 8.0 release(eg. a Maven artifact classifier **jakartaee9** or a specific version number) at the same time. There are several projects that used [Eclipse Transformer tooling](https://projects.eclipse.org/projects/technology.transformer) to convert the existing work to Jakarta EE 9 automatically, such as Apache TomEE, WildFly 22.0.0 Jakarta EE preview.","closed","status: duplicate,","hantsy","2020-12-06T08:38:55Z","2021-06-01T14:45:22Z"
"","26240","remove not necessary judge and fields","Because of the method of getReaderContext().error() will throw BeanDefinitionParsingException, and the following code will not be executed if an exception is thrown,So I think maybe can remove valid flag and judge.","closed","in: core,","xichaodong","2020-12-08T10:34:55Z","2021-12-10T23:13:56Z"
"","26065","Message converters list allows null elements","Because of concurrent threads processing to add custom converter at the same time into the existing message converters list,it is leading to the issue ""message converters doesn't contain null elements"".","closed","","hariprasad-tallapalli","2020-11-10T15:43:56Z","2020-11-12T11:17:49Z"
"","26809","Remove leftover Javadoc from WebClient","Backport of gh-26807","closed","type: backport,","spring-projects-issues","2021-04-15T07:57:12Z","2021-05-11T15:37:54Z"
"","26697","@DirtiesContext not applied when class-level @EnabledIf evaluates to false","Backport of gh-26694","closed","type: backport,","spring-projects-issues","2021-03-18T09:30:18Z","2021-03-18T13:36:08Z"
"","26666","StatusAssertion value methods fail when used with custom status code","Backport of gh-26658","closed","type: backport,","spring-projects-issues","2021-03-11T15:02:01Z","2021-03-12T09:51:40Z"
"","26620","Local @CrossOrigin maxAge value should override global value","Backport of gh-26619","closed","type: backport,","spring-projects-issues","2021-02-28T09:48:51Z","2021-03-02T13:36:29Z"
"","26624","ServerHttpRequest content-type cannot be mutated","Backport of gh-26615","closed","status: invalid,","spring-projects-issues","2021-03-01T20:01:05Z","2021-03-01T20:10:11Z"
"","26614","Add missing nullable annotation to ResponseEntity ok convenience method","Backport of gh-26613","closed","type: backport,","spring-projects-issues","2021-02-26T16:01:03Z","2021-02-26T16:42:35Z"
"","26606","Correctly set auto-growing array's element","Backport of gh-26600","closed","type: backport,","spring-projects-issues","2021-02-25T10:29:21Z","2021-02-25T10:56:11Z"
"","26589","Fix handling of ""file:"" paths to non-existent files on Windows","Backport of gh-26575","closed","type: backport,","spring-projects-issues","2021-02-22T11:19:55Z","2021-02-25T18:12:59Z"
"","26588","ClassLoader.getResource can throw IllegalArgumentException","Backport of gh-26574","closed","type: backport,","spring-projects-issues","2021-02-22T11:19:12Z","2021-02-25T18:12:59Z"
"","26562","ResourceUrlProvider detects wrong set of handler mappings","Backport of gh-26561","closed","type: backport,","spring-projects-issues","2021-02-17T20:59:17Z","2021-02-22T14:53:14Z"
"","26559","Support cookies with Expires attribute but no Max-Age attribute in MockHttpServletResponse","Backport of gh-26558","closed","type: backport,","spring-projects-issues","2021-02-17T12:41:51Z","2021-02-17T15:34:04Z"
"","26518","Autowiring shortcut fails with NoSuchBeanDefinitionException after removeBeanDefinition call","Backport of gh-26517","closed","type: backport,","spring-projects-issues","2021-02-07T10:48:02Z","2021-02-14T17:52:27Z"
"","26523","StringDecoder fails to strip windows newlines across source buffers","Backport of gh-26511","closed","type: backport,","spring-projects-issues","2021-02-08T14:15:42Z","2021-02-09T13:40:39Z"
"","26506","Inconsistency between source code and reference manual for StoredProcedure","Backport of gh-26505","closed","type: backport,","spring-projects-issues","2021-02-04T10:13:05Z","2021-02-04T10:13:06Z"
"","26499","Inefficient reflection operations for destroy method determination","Backport of gh-26498","closed","type: backport,","spring-projects-issues","2021-02-02T20:40:46Z","2021-02-14T17:52:27Z"
"","26496","Missing CORS Headers for Static Resources in WebFlux","Backport of gh-26495","closed","type: backport,","spring-projects-issues","2021-02-02T16:13:14Z","2021-02-02T20:35:19Z"
"","26494","Document the ""SpringProperties mechanism"" mentioned in the testing chapter","Backport of gh-26492","closed","type: backport,","spring-projects-issues","2021-02-02T12:52:44Z","2021-02-02T12:52:46Z"
"","26503","SimpleJdbcInsert (sporadically) does not insert all columns","Backport of gh-26486","closed","type: backport,","spring-projects-issues","2021-02-03T17:49:31Z","2021-02-04T09:36:30Z"
"","26547","Avoid unnecessary wrapping for SqlParameterValue","Backport of gh-26471","closed","type: backport,","jhoeller","2021-02-15T11:00:31Z","2021-02-15T11:02:04Z"
"","26475","DefaultHandlerExceptionResolver handling of media type exception on Tomcat 7+","Backport of gh-26470","closed","type: backport,","spring-projects-issues","2021-01-29T16:34:12Z","2021-01-29T20:54:18Z"
"","26465","No way to affect response when unhandled exceptions thrown from ForwardedHeaderTransformer","Backport of gh-26459","closed","type: backport,","spring-projects-issues","2021-01-28T10:23:40Z","2021-01-29T20:54:18Z"
"","26455","UriComponentsBuilder documentation error for HTTP request encoding","Backport of gh-26453","closed","type: backport,","spring-projects-issues","2021-01-27T14:18:30Z","2021-01-27T14:19:00Z"
"","26452","Websocket extensions not working","Backport of gh-26449","closed","type: backport,","spring-projects-issues","2021-01-27T12:53:46Z","2021-01-29T20:54:18Z"
"","26435","AbstractBeanDefinition#equals handles propertyValues incorrectly","Backport of gh-26433","closed","type: backport,","spring-projects-issues","2021-01-23T11:29:28Z","2021-02-14T17:52:27Z"
"","26426","Fail early FactoryBean instantiation for LinkageError","Backport of gh-26425","closed","type: backport,","spring-projects-issues","2021-01-21T19:03:55Z","2021-02-14T17:52:27Z"
"","26424","Close mapping streams after the ValidatorFactory has been built in LocalValidatorFactoryBean","Backport of gh-26418","closed","type: backport,","spring-projects-issues","2021-01-21T15:04:22Z","2021-02-14T17:52:27Z"
"","26420","Simple URL Mapping not working with PathPatternParser when Servlet context path is used","Backport of gh-26411","closed","status: invalid,","spring-projects-issues","2021-01-21T09:15:19Z","2021-01-21T09:23:03Z"
"","26338","Remove obsolete commandName attribute in spring-form.tld","Backport of gh-26337","closed","type: backport,","spring-projects-issues","2021-01-03T16:26:03Z","2021-01-03T16:50:44Z"
"","26277","NettyHeadersAdapter.add() accepts @Nullable value but throws NullPointerException","Backport of gh-26274","closed","type: backport,","spring-projects-issues","2020-12-15T12:26:56Z","2020-12-17T10:12:36Z"
"","26256","Defensively handle loadClass null result in BeanUtils.findEditorByConvention (against misbehaving ClassLoader impl such as in the GWT JettyLauncher)","Backport of gh-26252","closed","type: backport,","spring-projects-issues","2020-12-10T15:20:41Z","2020-12-10T15:30:21Z"
"","26245","Remove duplicate ""property"" in PropertyCacheKey.toString()","Backport of gh-26237","closed","type: backport,","spring-projects-issues","2020-12-08T13:51:12Z","2020-12-08T14:21:20Z"
"","26244","Remove duplicate ""property"" in PropertyCacheKey.toString()","Backport of gh-26237","closed","type: backport,","spring-projects-issues","2020-12-08T13:51:05Z","2020-12-08T14:13:14Z"
"","26243","Remove duplicate ""property"" in PropertyCacheKey.toString()","Backport of gh-26237","closed","type: backport,","spring-projects-issues","2020-12-08T13:50:55Z","2020-12-08T14:07:45Z"
"","26242","Remove duplicate ""property"" in PropertyCacheKey.toString()","Backport of gh-26237","closed","type: backport,","spring-projects-issues","2020-12-08T13:50:45Z","2020-12-08T14:04:40Z"
"","26235","DataBuffer Leak in Server Response","Backport of gh-26232","closed","type: backport,","spring-projects-issues","2020-12-07T23:05:56Z","2020-12-08T22:17:59Z"
"","26234","DataBuffer Leak in Server Response","Backport of gh-26232","closed","type: backport,","spring-projects-issues","2020-12-07T23:05:44Z","2020-12-08T22:01:41Z"
"","26231","Ability to correlate ByteBuf leak records to log messages for a specific request","Backport of gh-26230","closed","type: backport,","spring-projects-issues","2020-12-07T13:12:23Z","2020-12-07T23:02:42Z"
"","26204","Clarify intended advice execution behavior in Spring version 5.2.7+","Backport of gh-26202","closed","type: backport,","spring-projects-issues","2020-12-03T08:22:42Z","2020-12-07T21:15:10Z"
"","26584","LoadTimeWeaver no longer weaves bean classes annotated with @Component","Backport of gh-26199","closed","type: backport,","spring-projects-issues","2021-02-21T18:27:48Z","2021-02-22T09:38:41Z"
"","26404","Wrong documentation for CachePut","Backport of gh-26186","closed","type: backport,","spring-projects-issues","2021-01-19T10:58:20Z","2021-01-20T13:09:38Z"
"","26184","GenericConversionService$Converters.getMatchableConverters throws ConcurrentModificationException on Java 9+","Backport of gh-26183","closed","type: backport,","spring-projects-issues","2020-12-01T08:30:05Z","2020-12-02T11:36:10Z"
"","26194","ContentCachingResponseWrapper should not add “Content-Length” when “Transfer-Encoding” is present","Backport of gh-26182","closed","type: backport,","spring-projects-issues","2020-12-01T16:10:03Z","2020-12-01T20:29:48Z"
"","26193","ContentCachingResponseWrapper should not add “Content-Length” when “Transfer-Encoding” is present","Backport of gh-26182","closed","type: backport,","spring-projects-issues","2020-12-01T16:09:52Z","2020-12-01T18:33:52Z"
"","26192","ContentCachingResponseWrapper should not add “Content-Length” when “Transfer-Encoding” is present","Backport of gh-26182","closed","type: backport,","spring-projects-issues","2020-12-01T16:09:43Z","2020-12-01T18:24:02Z"
"","26191","ContentCachingResponseWrapper should not add “Content-Length” when “Transfer-Encoding” is present","Backport of gh-26182","closed","type: backport,","spring-projects-issues","2020-12-01T16:09:34Z","2020-12-01T18:08:10Z"
"","26168","Register bean definition dependencies when used via configuration class injected fields","Backport of gh-26167","closed","type: backport,","spring-projects-issues","2020-11-27T17:01:05Z","2020-11-27T21:03:24Z"
"","26158","ConcurrentModificationException in NativeMessageHeaderAccessor#copyHeaders","Backport of gh-26155","closed","type: backport,","spring-projects-issues","2020-11-26T15:54:22Z","2020-11-26T22:05:19Z"
"","26138","DateTimeFormat ISO.DATE_TIME javadoc contains misleading default note","Backport of gh-26134","closed","type: backport,","spring-projects-issues","2020-11-23T12:50:11Z","2020-11-26T15:12:47Z"
"","26137","DateTimeFormat ISO.DATE_TIME javadoc contains misleading default note","Backport of gh-26134","closed","type: backport,","spring-projects-issues","2020-11-23T12:50:06Z","2020-11-26T15:02:53Z"
"","26136","DateTimeFormat ISO.DATE_TIME javadoc contains misleading default note","Backport of gh-26134","closed","type: backport,","spring-projects-issues","2020-11-23T12:49:08Z","2020-11-26T14:47:21Z"
"","26135","DateTimeFormat ISO.DATE_TIME javadoc contains misleading default note","Backport of gh-26134","closed","type: backport,","spring-projects-issues","2020-11-23T12:49:00Z","2020-11-26T14:42:51Z"
"","26139","Reference manual contains broken links to XSD schema sections","Backport of gh-26129","closed","type: backport,","spring-projects-issues","2020-11-23T13:52:13Z","2020-11-23T13:54:46Z"
"","26128","MimeType is no longer actually serializable","Backport of gh-26127","closed","type: backport,","spring-projects-issues","2020-11-20T17:19:17Z","2020-11-20T17:59:12Z"
"","26116","Wildcard is a valid Access-Control-Expose-Headers value","Backport of gh-26113","closed","type: backport,","spring-projects-issues","2020-11-19T09:24:54Z","2020-11-19T10:21:45Z"
"","26115","Wildcard is a valid Access-Control-Expose-Headers value","Backport of gh-26113","closed","type: backport,","spring-projects-issues","2020-11-19T09:24:34Z","2020-11-19T09:49:23Z"
"","26106","PathMatchingResourcePatternResolver fails to resolve resources from JAR located in path with '#' on JDK 11+","Backport of gh-26104","closed","type: backport,","spring-projects-issues","2020-11-17T13:04:21Z","2020-11-17T15:24:45Z"
"","26105","PathMatchingResourcePatternResolver fails to resolve resources from JAR located in path with '#' on JDK 11+","Backport of gh-26104","closed","type: backport,","spring-projects-issues","2020-11-17T13:03:57Z","2020-11-17T15:17:22Z"
"","26095","EntityManagerFactory startup failure in deferred mode is only available on first use","Backport of gh-26093","closed","type: backport,","spring-projects-issues","2020-11-13T15:44:37Z","2020-11-13T17:08:40Z"
"","26094","EntityManagerFactory startup failure in deferred mode is only available on first use","Backport of gh-26093","closed","type: backport,","spring-projects-issues","2020-11-13T15:31:40Z","2020-11-13T17:00:12Z"
"","26086","UrlPathHelper#removeJsessionid doesn't remove the jsessionid from the URL","Backport of gh-26079","closed","type: backport,","spring-projects-issues","2020-11-12T21:07:48Z","2020-11-16T12:34:35Z"
"","26085","UrlPathHelper#removeJsessionid doesn't remove the jsessionid from the URL","Backport of gh-26079","closed","type: backport,","spring-projects-issues","2020-11-12T21:07:33Z","2020-11-16T12:29:29Z"
"","26084","UrlPathHelper#removeJsessionid doesn't remove the jsessionid from the URL","Backport of gh-26079","closed","type: backport,","spring-projects-issues","2020-11-12T21:06:59Z","2020-11-16T11:29:36Z"
"","26083","UrlPathHelper#removeJsessionid doesn't remove the jsessionid from the URL","Backport of gh-26079","closed","type: backport,","spring-projects-issues","2020-11-12T21:06:42Z","2020-11-16T11:21:45Z"
"","26074","NamedParameterJdbcTemplate.batchUpdate does not individually apply the SQL type from each SqlParameterSource argument","Backport of gh-26071","closed","type: backport,","spring-projects-issues","2020-11-11T22:09:54Z","2020-11-12T13:29:25Z"
"","26073","NamedParameterJdbcTemplate.batchUpdate does not individually apply the SQL type from each SqlParameterSource argument","Backport of gh-26071","closed","type: backport,","spring-projects-issues","2020-11-11T22:09:29Z","2020-11-12T13:20:07Z"
"","26061","DataBufferUtils#join may release a DataBuffer more than necessary","Backport of gh-26060","closed","type: backport,","spring-projects-issues","2020-11-10T12:56:27Z","2020-11-10T20:24:03Z"
"","26036","MergedAnnotationCollectors.toAnnotationSet() should not create intermediate ArrayList","Backport of gh-26031","closed","type: backport,","spring-projects-issues","2020-11-05T18:27:35Z","2020-11-08T14:34:03Z"
"","26038","StompSubProtocolHandler logs failed authentication with error stack trace","Backport of gh-26026","closed","type: backport,","spring-projects-issues","2020-11-05T18:41:29Z","2020-11-05T21:55:30Z"
"","26037","StompSubProtocolHandler logs failed authentication with error stack trace","Backport of gh-26026","closed","type: backport,","spring-projects-issues","2020-11-05T18:40:18Z","2020-11-05T21:55:42Z"
"","26027","Add FullyQualifiedAnnotationBeanNameGenerator.INSTANCE","Backport of gh-26025","closed","type: backport,","spring-projects-issues","2020-11-03T21:56:33Z","2020-11-05T17:21:29Z"
"","26020","Autowiring does not work reliably in case of dynamically changing prototype bean class","Backport of gh-26019","closed","type: backport,","spring-projects-issues","2020-11-03T08:26:32Z","2020-11-05T17:21:29Z"
"","26015","DefaultSimpUserRegistry prevents event from being published if original SimpMessageHeaderAccessor cannot be found","Backport of gh-26010","closed","type: backport,","spring-projects-issues","2020-11-02T16:43:13Z","2020-11-02T17:42:25Z"
"","26013","DefaultSimpUserRegistry prevents event from being published if original SimpMessageHeaderAccessor cannot be found","Backport of gh-26010","closed","type: backport,","spring-projects-issues","2020-11-02T11:57:01Z","2020-11-02T17:37:10Z"
"","26009","Order of profiles in tests is not preserved","Backport of gh-26004","closed","type: backport,","spring-projects-issues","2020-10-31T10:30:02Z","2020-11-03T09:05:46Z"
"","26008","Order of profiles in tests is not preserved","Backport of gh-26004","closed","type: backport,","spring-projects-issues","2020-10-31T10:29:54Z","2020-11-02T22:23:22Z"
"","26000","Fix a broken Asciidoctor syntax in core-resources.adoc","Backport of gh-25999","closed","type: backport,","spring-projects-issues","2020-10-30T08:32:16Z","2020-11-05T17:05:19Z"
"","25993","DefaultWebClientBuilder copies references","Backport of gh-25992","closed","type: backport,","spring-projects-issues","2020-10-29T12:27:52Z","2020-10-29T14:26:46Z"
"","25989","SseEmitter: connection closed after first event","Backport of gh-25987","closed","type: backport,","spring-projects-issues","2020-10-29T09:16:11Z","2020-10-30T18:42:46Z"
"","26007","Inefficient request handling inside ServletRequestDataBinder","Backport of gh-25986","closed","type: backport,","spring-projects-issues","2020-10-31T09:51:23Z","2020-11-05T18:06:30Z"
"","26006","Inefficient request handling inside ServletRequestDataBinder","Backport of gh-25986","closed","type: backport,","spring-projects-issues","2020-10-31T09:51:15Z","2020-11-05T17:55:13Z"
"","26005","Inefficient request handling inside ServletRequestDataBinder","Backport of gh-25986","closed","type: backport,","spring-projects-issues","2020-10-31T09:51:06Z","2020-11-05T17:51:10Z"
"","25990","Inefficient request handling inside ServletRequestDataBinder","Backport of gh-25986","closed","type: backport,","spring-projects-issues","2020-10-29T09:33:17Z","2020-11-05T17:21:29Z"
"","25979","Incorrect http response for a request using the Range header for pre-compressed resources","Backport of gh-25976","closed","type: backport,","spring-projects-issues","2020-10-27T11:18:08Z","2020-10-27T12:06:41Z"
"","25974","@ActiveProfiles with same profiles but different order results in duplicate ApplicationContext","Backport of gh-25973","closed","type: backport,","spring-projects-issues","2020-10-26T10:13:41Z","2020-10-26T12:18:01Z"
"","25962","LinkedMultiValueMap downstream issue with MultiValueMapAdapter package private base class","Backport of gh-25960","closed","type: backport,","spring-projects-issues","2020-10-23T10:47:24Z","2020-10-26T10:37:08Z"
"","25961","LinkedMultiValueMap downstream issue with MultiValueMapAdapter package private base class","Backport of gh-25960","closed","type: backport,","spring-projects-issues","2020-10-23T10:47:17Z","2020-10-26T10:34:32Z"
"","25904","Avoid creation of unused logger instance in AbstractMediaTypeExpression","Backport of gh-25901","closed","type: backport,","spring-projects-issues","2020-10-12T20:37:51Z","2020-10-12T23:23:30Z"
"","25903","Avoid creation of unused logger instance in AbstractMediaTypeExpression","Backport of gh-25901","closed","type: backport,","spring-projects-issues","2020-10-12T20:37:44Z","2020-10-12T23:02:04Z"
"","25902","Avoid creation of unused logger instance in AbstractMediaTypeExpression","Backport of gh-25901","closed","type: backport,","spring-projects-issues","2020-10-12T20:37:35Z","2020-10-12T22:38:20Z"
"","25869","jsessionid breaks request mappings when removeSemicolonContent is turned off","Backport of gh-25864","closed","type: backport,","spring-projects-issues","2020-10-07T11:15:50Z","2020-10-13T16:04:48Z"
"","25868","jsessionid breaks request mappings when removeSemicolonContent is turned off","Backport of gh-25864","closed","type: backport,","spring-projects-issues","2020-10-07T11:15:42Z","2020-10-13T15:55:44Z"
"","25867","jsessionid breaks request mappings when removeSemicolonContent is turned off","Backport of gh-25864","closed","type: backport,","spring-projects-issues","2020-10-07T10:39:01Z","2020-10-13T15:32:32Z"
"","25862","Native Hibernate 5 bootstrapping with JTA transaction manager requires hibernate.transaction.coordinator_class=jta to be set","Backport of gh-25858","closed","type: backport,","spring-projects-issues","2020-10-06T13:17:54Z","2020-10-06T15:54:31Z"
"","25894","Cannot test @RequestPart multipart controllers with Servlet MockPart","Backport of gh-25829","closed","type: backport,","spring-projects-issues","2020-10-10T14:22:53Z","2020-10-12T17:26:48Z"
"","25923","Optimize String argument resolution in MessageTag","Backport of gh-25809","closed","type: backport,","spring-projects-issues","2020-10-16T13:45:53Z","2020-10-16T13:53:47Z"
"","25870","ClassCastException when wiring bean using method injection (NullBean instead of 'null')","Backport of gh-25806","closed","type: backport,","spring-projects-issues","2020-10-07T11:19:19Z","2020-10-07T12:37:34Z"
"","25875","Construct StringWriter instances with appropriate initial size","Backport of gh-25789","closed","type: backport,","spring-projects-issues","2020-10-07T12:26:06Z","2020-10-07T13:06:36Z"
"","25874","Construct StringWriter instances with appropriate initial size","Backport of gh-25789","closed","type: backport,","spring-projects-issues","2020-10-07T12:25:57Z","2020-10-07T12:37:34Z"
"","25871","Incorrect example in javadocs of Assert.notNull(object, messageSupplier)","Backport of gh-25774","closed","type: backport,","spring-projects-issues","2020-10-07T11:21:23Z","2020-10-07T12:37:34Z"
"","25873","Wrong type inference in Kotlin while overriding RequestMappingHandlerMapping#getMappingForMethod","Backport of gh-25657","closed","type: backport,","spring-projects-issues","2020-10-07T12:20:53Z","2020-10-07T12:37:34Z"
"","26102","Document that @Transactional does not propagate to new threads","Backport of gh-25439","closed","type: backport,","spring-projects-issues","2020-11-17T11:43:33Z","2020-11-17T15:17:22Z"
"","26839","Spring AOP should not apply UndeclaredThrowableException to checked exceptions from Kotlin methods","Backport of gh-23844","closed","type: backport,","spring-projects-issues","2021-04-21T09:13:55Z","2021-05-11T15:47:07Z"
"","26300","Enhance http.CacheControl with setters","Attempting to generate the following Cache-Control header `Cache-Control: no-store, max-age=0` as illustrated [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#Examples) but unable to do so with `org.springframework.http.CacheControl` which is the required arg in `org.springframework.web.servlet.mvc.WebContentInterceptor#addCacheMapping`. Would be nice to allow setters with a comment that suggests using builder functionality if unsure.","closed","","cwjenkins","2020-12-19T02:40:47Z","2021-02-05T15:27:19Z"
"","26379","Support for RSocket per-stream data MIME type extension","At present there can be only one data MIME for the every request/stream on the connection. This is negotiated in the SETUP frame. The [Stream Data MIME Types Metadata Extension](https://github.com/rsocket/rsocket/blob/master/Extensions/PerStreamDataMimeTypesDefinition.md) defines a way to declare the data MIME type for a specific request/stream. This includes a MIME type for the request input and an ""acceptable"" MIME type for the response.","open","type: enhancement,","rstoyanchev","2021-01-12T15:29:31Z","2021-02-11T14:03:16Z"
"","26621","Message and stream level data  and accept  mime","At present there can be only one data MIME for the every request/stream on the connection,  Supporting content-type and accept header like http in this pr. Implementation of  issue #26379   Class MimeTypeMetadataCodec will be delete once  rsocket-java v1.1.1 release","open","in: messaging,","rudy2steiner","2021-02-28T14:29:44Z","2021-11-10T09:11:31Z"
"","26524","Memory leakage in Webflux, Socktes are not closing even if i use retrieve method","As you can see i am using retrieve() but still  connections are not closing.  ####Code which is causing this issue ```java WebClient webClient = WebClient.create(""http://192.168.101.8:8066"");     public Mono getCityById(Integer id){         return webClient.get()         .uri(""/cities/"" + id)         .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)         .retrieve()         .bodyToMono(City.class);     } ``` ### total socktes opened by this api on a docker ``` / # lsof -p 1 | grep socket | wc -l 4 / # lsof -p 1 | grep socket | wc -l 6 / # lsof -p 1 | grep socket | wc -l 5 ``` It is creating 2 port/connections for one request then closing only one. I am not sure why","closed","status: invalid,","j-arpit","2021-02-08T15:50:39Z","2021-02-09T10:19:10Z"
"","25901","Avoid creation of unused logger instance in AbstractMediaTypeExpression","As revealed by #25900, the logger instance in `AbstractMediaTypeExpression` is entirely unused. Since this is a non-public internal base class in both MVC and WebFlux, we can drop the unused logger field completely even in the backport branches.","closed","type: enhancement,","jhoeller","2020-10-12T20:37:23Z","2020-10-12T22:30:02Z"
"","26765","Spring 5.3.x is it a GA version?","As per Maven central repository spring 5.3.x jar are not released    As spring framework tells link: https://spring.io/blog/2020/10/27/spring-framework-5-3-goes-ga     spring 5.3.x jars are stable but we try to upgrade it in out project it throws BeanObjectCreation, illigaleObjectException.  Project technology java11.x jboss7.3 current spring 4.6.   Please guide us which jars are  stable to use in our project","closed","for: stackoverflow,","baswarajk1","2021-04-06T09:57:48Z","2021-04-06T16:21:19Z"
"","26677","Centralize copyright management with one cron job","As far as I have seen, basically any PR opened always uses the following line of code on changed files: ```java  * Copyright 20XY-2021 the original author or authors. ``` I think it is unnecessary and error prone to do that manually for each file on its own. There are for example files in the projects, where the copyright only ranges from `2014-2017`, meaning they were not updated at all in those 4 years since, which seems unintended when other files claim copyright until `2021`.  All that work should be easily automatable by simply defining **one** cron job that is run annually, i.e. on Jan 01 of each year (`1 1 1 1 *` in cron terminology), using sed on all project files (of course, that requires a UNIX inspired OS like a Linux distro). The cron job could even, if configured correctly, directly commit the changes and push them on GitHub.","closed","","delvh","2021-03-14T22:55:27Z","2021-03-30T07:25:57Z"
"","25975","Refine CancellationException handling in Coroutines endpoints","As demonstrated in https://github.com/sdeleuze/spring-boot-coroutines-demo, in annotated controller throwing a `CancellationException` result in a 5xx error. Since `CancellationException` means ""normal cancellation of a coroutine"", is it the expected behavior?  In functional controller, with such handler function:  ```kotlin suspend fun cancel(request: ServerRequest): ServerResponse { 	throw CancellationException() } ```  The related web endpoint never returns, that's unexpected and not consistent with the annotated variant (cc @poutsma). We should probably fix this, see https://github.com/sdeleuze/spring-boot-coroutines-demo/blob/master/src/test/kotlin/com/example/CoroutinesApplicationTests.kt#L63-L67 for a repro.","open","type: bug,","sdeleuze","2020-10-26T11:00:17Z","2020-12-07T10:46:51Z"
"","26228","Will interface""Cache"" support ""put"" with TTL ?","as cache without ttl may cause dos problem (depends on developer )  and sometimes may want cache keys invalid after a period of time, i suggest that interface ""Cache"" should support ""put"" with TTL , like  `void put(Object key, @Nullable Object value, Duration ttl);`","closed","status: declined,","VikkeyJiang","2020-12-07T10:04:07Z","2020-12-07T10:07:54Z"
"","26222","Add Smallrye Mutiny support","As an additional Reactive Streams implementer to the existing Reactor, Rxjava2/3.   https://smallrye.io/smallrye-mutiny/","closed","status: superseded,","hantsy","2020-12-06T08:17:56Z","2021-08-28T13:45:57Z"
"","26423","Make it easy to run both Spring Messaging and RSocket-RPC simultaneously","As a user of [rsocket-rpc-java](https://github.com/rsocket/rsocket-rpc-java) in [Liiklus](https://github.com/bsideup/liiklus), I would like to be able to reuse Spring {Framework,Boot}'s RSocket support, and be able to handle `rsocket-rpc` requests while having some routes (as per [RSocket's Routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)) defined as Spring Messaging's handlers.  Expectation: 1. I create an instance of `RSocketRPCRouteHandler` that `rsocket-rpc` generated for me 2. I register it to _some_ registry of `RouteHandler`s 3. While handling RSocket requests, Spring's RSocket support delegates to _some_ abstraction that uses registered `RouteHandler`s to decide which one should handle the request  This all is very similar to the HTTP support & Servlets API, where a `Servlet` can be added next to Spring Framework's `DispatcherServlet` and handle a subset of requests.","closed","for: external-project,","bsideup","2021-01-21T14:15:12Z","2021-01-22T12:12:25Z"
"","26371","Prevent kotlinx.serialization usage on collection of interfaces","As a refinement of #26298, we should disable out of the box open polymorphic serialization for collections using something like:  ``` // Pseudocode, not tested fun hasPolymorphism(serializer: KSerializer<*>): Boolean = hasPolymorphism(serializer.descriptor) fun hasPolymorphism(descriptor: SerialDescriptor): Boolean {     if (descriptor.kind == PolymorphicKind.OPEN.INSTANCE) return true     for (i in 0 until descriptor.elementsCount) {         // TODO circuit breaker for recursive types         if (hasPolymorphism(descriptor.getElementDescriptor(i)) return true     }    return false } ```","closed","","sdeleuze","2021-01-12T08:08:47Z","2021-02-15T13:52:40Z"
"","25883","Add kotlinx.serialization JSON support to Spring Messaging (RSocket)","As a follow-up of #25771, kotlinx.serialization JSON support should be added to Spring Messaging to be usable with RSocket.","closed","","sdeleuze","2020-10-08T12:56:47Z","2020-10-26T19:13:40Z"
"","26456","Introduce getBytes() method in Resource API","As a feature request, would it make sense to extend Resource interface to allow a getBytes[] method so one does not have to deal with inputstreams, closing them etc... I mean from conceptual point of view, a resource is an abstraction of a byte content (even if a particular implementation is not handling physically that byte content), and as so it could make sense to de-encapsulate it easily.  If someone needs the content it just autowires it in a fancy semantical way like @Value Resource, and then can parse it easily with a new convenient String(resource.getBytes()), for instance, instead of having to stream it","closed","type: enhancement,","nightswimmings","2021-01-27T16:37:06Z","2021-01-28T09:49:04Z"
"","26760","Groovy Dynamic Language based beans that are Controllers require proxy-target-class=""true"" but causes refresh-check-delay to fail","Appears to be a continuation of  https://github.com/spring-projects/spring-framework/issues/14886  Consider a endpoint in a  groovy file such as:  ```groovy import org.springframework.stereotype.Controller import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController  import javax.servlet.http.HttpServletRequest  @RestController class TestController {     @GetMapping(value = ""/test"")     String handler(HttpServletRequest request) {         return ""success""     } } ```  and using a beans config file such as:  ```                       ```  In order for the controller to get registered the beans seems to require the `proxy-target-class=""true""` configuration.  But when you use the proxy-target-class configuration this breaks the ability to refresh the bean.","open","in: core,","StephenOTT","2021-04-04T23:39:37Z","2021-11-11T09:26:59Z"
"","26401","Improve inline documentation for PostProcessorRegistrationDelegate","Apologize for the request before #26399  I fix the comment here so that people will understand the code here and won't  submit the wrong change [declined PRs involving proposed changes to PostProcessorRegistrationDelegate](https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22)","closed","type: task,","Jirath-Liu","2021-01-19T01:00:46Z","2021-01-22T12:35:40Z"
"","26292","AopContext.currentProxy() Incorrect get proxy object","AopContext.currentProxy() Incorrect get proxy object  The returned object is inconsistent with this  spring版本：5.1.13.release jdk：1.8  springboot：2.1.13.release  `try {             System.out.println(""=========================================>"" + this.toString());             System.out.println(""=========================================>"" + AopContext.currentProxy());             return (T)AopContext.currentProxy();         }catch (IllegalStateException e){             return (T)this;         }`  system logs： =========================================>OrderItemNode{orderItemId='BD22425420121615000607329', coordinate=0.0.0.3, stepType=COMMON, stepId='BusiDet', status=DEALING, orderItemFieldBitmap=5377687649, parentId='BP22929120121615000607317'} CommonNode{fsmInsId='null', contKey='null'} =========================================>OrderItemNode{orderItemId='OI22425420121710000607900', coordinate=0.0.0.3.1, stepType=WORK_ORDER, stepId='SMS', status=SUBMITTING, orderItemFieldBitmap=1082982432, parentId='BD22425420121615000607329'}","open","in: core,","shenwuwu","2020-12-17T02:40:37Z","2021-11-11T09:32:05Z"
"","26004","Order of profiles in tests is not preserved","Annotation `@ActiveProfiles` doesn't preserve the order of defined profiles in tests in spring boot 2.3.5.RELEASE I have defined two profiles  (europe and belgium) and marked test class with `@ActiveProfiles({""europe"", ""belgium""})` Profiles have been loaded in alphabetical order instead of defined in the annotation.  I wrote test for that case. It fails due to unexpected behavior ![ffffffff](https://user-images.githubusercontent.com/22240319/97767651-b6372180-1b1d-11eb-902a-4b2c486512c9.png)  Log from context startup during test execution `2020-10-31 02:00:03.091  INFO 15818 --- [           main] c.e.d.DemoProfilesApplicationTests       : The following profiles are active: belgium,europe`  In spring boot 2.3.4.RELEASE same test pass","closed","type: regression,","tomasz0801","2020-10-31T01:08:52Z","2020-11-02T17:19:17Z"
"","26759","Support 'Accept-Patch' header in MVC and WebFlux","An API providing a `PATCH` endpoint should ensure two things:  1 - When the `PATCH` endpoint is sent a body with an unsupported media type, the response should include an `Accept-Patch` header, advertising the correct media type. This is specified in [RFC5789, Section 2.2](https://tools.ietf.org/html/rfc5789#section-2.2):  >  Unsupported patch document:  Can be specified using a 415       (Unsupported Media Type) response when the client sends a patch       document format that the server does not support for the resource       identified by the Request-URI.  Such a response SHOULD include an       Accept-Patch response header as described in Section 3.1 to notify       the client what patch document media types are supported.  2 - The `OPTIONS` endpoint should advertise the accepted request media types through its `Accept-Patch` header. This is stated in [RFC5789, Section 3](https://tools.ietf.org/html/rfc5789#section-3):  > Accept-Patch SHOULD appear in the OPTIONS response for any resource    that supports the use of the PATCH method.  The presence of the    Accept-Patch header in response to any method is an implicit    indication that PATCH is allowed on the resource identified by the    Request-URI.  The presence of a specific patch document format in    this header indicates that that specific format is allowed on the    resource identified by the Request-URI.  It would be great if this would happen by default. Currently, Spring MVC doesn't add the header for either `PATCH` or `OPTIONS`, so I had to add this myself:  ```kotlin const val ACCEPT_PATCH_HEADER = ""Accept-Patch"" const val APPLICATION_MERGE_PATCH_JSON_VALUE = ""application/merge-patch+json""  // if used with a wrong media type, provide the Accept-Patch header with the error response // as suggested by RFC 5789 ""PATCH Method for HTTP"" https://tools.ietf.org/html/rfc5789#section-2.2 @PatchMapping(""/{id}"") @ResponseStatus(UNSUPPORTED_MEDIA_TYPE) fun patchBadMediaType(response: HttpServletResponse) {     response.addHeader(ACCEPT_PATCH_HEADER, APPLICATION_MERGE_PATCH_JSON_VALUE) }  // advertise the Accept-Patch header as additional information // as suggested by RFC 5789 ""PATCH Method for HTTP"" https://tools.ietf.org/html/rfc5789#section-3 @RequestMapping(""/{id}"", method = [RequestMethod.OPTIONS]) fun optionsForId(response: HttpServletResponse) {     response.setHeader(ALLOW, ""GET, HEAD, POST, PUT, OPTIONS, PATCH"")     response.addHeader(ACCEPT_PATCH_HEADER, APPLICATION_MERGE_PATCH_JSON_VALUE) } ```  Note that I had to set the `Allow` header values manually, which would only be added correctly if I hadn't implemented the method myself. I might create an own issue for this.","closed","type: enhancement,","igorakkerman","2021-04-04T20:42:51Z","2021-04-10T19:34:46Z"
"","26504","Fall back on awaitToBodylessEntity when awaitBody is used with Unit","allow WebClient.ResponseSpec.awaitBody() to be used in combination with Type ""Unit""","closed","type: enhancement,","gaerfield","2021-02-03T21:11:12Z","2021-02-15T16:47:57Z"
"","26375","Add import capabilities to ResourceDatabasePopulator","Allow to reference/import additional sql scripts inside an sql script with something like PostgreSQL psql ""\i"" command.  This allows for more granularity/reuse of multiple sql scripts.  For example:  **agents.sql**  ```sql -- insert agents INSERT INTO AGENTS VALUES ('A007', 'Ramasundar', 'Bangalore'); INSERT INTO AGENTS VALUES ('A003', 'Alex ', 'London'); INSERT INTO AGENTS VALUES ('A008', 'Alford', 'New York'); ```  **customers.sql**  ```sql -- Import agents.sql \i agents.sql  -- insert customers with references to agents INSERT INTO CUSTOMER VALUES ('C00013', 'Holmes', 'London', 'A003'); INSERT INTO CUSTOMER VALUES ('C00001', 'Micheal', 'New York', 'A008'); INSERT INTO CUSTOMER VALUES ('C00020', 'Albert', 'New York', 'A008'); INSERT INTO CUSTOMER VALUES ('C00025', 'Ravindran', 'Bangalore', 'A007'); ```  Then you could populate your test database referencing only **customers.sql** that imports **agents.sql** (that could be referenced/imported in other scripts too).  Basically the suggested change should be:  - Add property to **ResourceDatabasePopulator**: `private String importPrefix = ScriptUtils.DEFAULT_IMPORT_PREFIX;` - Add constant to **ScriptUtils**: `public static final String DEFAULT_IMPORT_PREFIX = ""\\\\i"";` - Refactor **splitSqlScript** from **ScriptUtils** so when a new line with **importPrefix** is found the referenced script is read and parsed (could be a ""relative path"" or support spring resource prefixes...)","open","type: enhancement,","rubensa","2021-01-12T12:52:57Z","2022-03-03T04:13:15Z"
"","26835","When allowCredentials is true, allowedOrigins cannot contain the special value ""*""","After upgrading to use Spring Boot 2.4.5 from 2.3.x, it does not seem to be possible to use allowedOrigins = ""*"" in the StompEndpointRegistry. When connecting it results in the following Error:  ![image](https://user-images.githubusercontent.com/6472032/115486079-7c530680-a288-11eb-8f1d-89e753ffc41c.png)   my config: ![image](https://user-images.githubusercontent.com/6472032/115486134-97257b00-a288-11eb-8224-ed6a60c6d6c2.png)","closed","","zhangran2616","2021-04-21T02:01:14Z","2021-04-21T06:50:20Z"
"","26563","After Spring upgrade from 5.2.x to 5.3.x - No mapping for GET /","After upgrading the same project stops working. Fails to load and the log shows `Message=No mapping for GET /`  Please let me know what all details would be required to investigate it. I have a sample project available to showcase this error message.","closed","status: invalid,","hth","2021-02-17T21:40:21Z","2021-02-23T09:40:31Z"
"","25994","Fixing contextPath when mutating ServerHttpRequest introduced issue with RewritePath filter","After upgrading from SpringBoot 2.3.1.RELEASE to 2.3.2.RELEASE I've faced issue connected with this commit: https://github.com/spring-projects/spring-framework/commit/c4326cb0f5673b6e0e8dae912a0cb35a47916551  When using RewritePath filter in Spring Cloud Gateway:  `- RewritePath=/service1(?/?.*), /service2$\{segment}`  Im getting: `java.lang.IllegalArgumentException: Invalid contextPath '/service1': must match the start of requestPath: '/service2/offer' 	at org.springframework.http.server.DefaultRequestPath.validateContextPath(DefaultRequestPath.java:82) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ org.springframework.web.cors.reactive.CorsWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ pl.fru.gateway.GatewayApplication$$Lambda$647/0x0000000801083040 [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.cloud.sleuth.instrument.web.TraceWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ HTTP GET ""/service1/offer?parameter=xyz"" [ExceptionHandlingWebHandler] Stack trace: 		at org.springframework.http.server.DefaultRequestPath.validateContextPath(DefaultRequestPath.java:82) 		at org.springframework.http.server.DefaultRequestPath.initContextPath(DefaultRequestPath.java:57) 		at org.springframework.http.server.DefaultRequestPath.(DefaultRequestPath.java:42) 		at org.springframework.http.server.RequestPath.parse(RequestPath.java:60) 		at org.springframework.http.server.reactive.AbstractServerHttpRequest.(AbstractServerHttpRequest.java:81) 		at org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder$MutatedServerHttpRequest.(DefaultServerHttpRequestBuilder.java:197) 		at org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder.build(DefaultServerHttpRequestBuilder.java:136) 		at org.springframework.cloud.gateway.filter.factory.RewritePathGatewayFilterFactory$1.filter(RewritePathGatewayFilterFactory.java:71) 		at org.springframework.cloud.gateway.filter.OrderedGatewayFilter.filter(OrderedGatewayFilter.java:44) 		at org.springframework.cloud.gateway.handler.FilteringWebHandler$DefaultGatewayFilterChain.lambda$filter$0(FilteringWebHandler.java:118) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4213) 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4213) 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:274) 		at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:851) 		at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:90) 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:274) 		at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:851) 		at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:90) 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73) 		at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:173) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782) 		at reactor.core.publisher.MonoFilterWhen$MonoFilterWhenMain.innerResult(MonoFilterWhen.java:193) 		at reactor.core.publisher.MonoFilterWhen$FilterWhenInner.onNext(MonoFilterWhen.java:260) 		at reactor.core.publisher.MonoFilterWhen$FilterWhenInner.onNext(MonoFilterWhen.java:228) 		at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:90) 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2344) 		at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.request(ScopePassingSpanSubscriber.java:76) 		at reactor.core.publisher.MonoFilterWhen$FilterWhenInner.onSubscribe(MonoFilterWhen.java:249) 		at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onSubscribe(ScopePassingSpanSubscriber.java:69) 		at reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:191) 		at reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4198) 		at reactor.core.publisher.MonoFilterWhen$MonoFilterWhenMain.onNext(MonoFilterWhen.java:150) 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2344) 		at reactor.core.publisher.MonoFilterWhen$MonoFilterWhenMain.onSubscribe(MonoFilterWhen.java:103) 		at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4213) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:441) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onNext(FluxConcatMap.java:243) 		at reactor.core.publisher.FluxDematerialize$DematerializeSubscriber.onNext(FluxDematerialize.java:91) 		at reactor.core.publisher.FluxDematerialize$DematerializeSubscriber.onNext(FluxDematerialize.java:38) 		at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:267) 		at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:225) 		at reactor.core.publisher.FluxDematerialize$DematerializeSubscriber.request(FluxDematerialize.java:120) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:228) 		at reactor.core.publisher.FluxDematerialize$DematerializeSubscriber.onSubscribe(FluxDematerialize.java:70) 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:161) 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) 		at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) 		at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:54) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4213) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:441) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:211) 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:161) 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at org.springframework.cloud.sleuth.instrument.web.TraceWebFilter$MonoWebFilterTrace.subscribe(TraceWebFilter.java:165) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4213) 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 		at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:65) 		at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:518) 		at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:272) 		at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:462) 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:96) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:172) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 		at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795) 		at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:475) 		at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378) 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.base/java.lang.Thread.run(Thread.java:832)`  Probably because of mentioned commit both became incompatible.","closed","for: external-project,","nefsir","2020-10-29T13:26:39Z","2020-10-29T14:31:44Z"
"","26531","BeanUtils does not copy properties with generics from a Proxy since 5.3.0","After upgrading from spring boot 2.3.8 to 2.4.2 our following test case fails: [CopyPropertiesTest](https://github.com/dzhw/metadatamanagement/blob/development/src/test/java/eu/dzhw/fdz/metadatamanagement/searchmanagement/service/CopyPropertiesTest.java)   Basically it loads a spring data projection from MongoDB and tries to copy all of its properties with Spring's `BeanUtils.copyProperties` into another bean. For some reason ""collection""-properties are not copied anymore after the upgrade.","closed","in: core,","rreitmann","2021-02-08T13:44:03Z","2021-02-11T19:14:02Z"
"","26090","Spring EntityManager proxy is incompatible with Hibernate Search <5.11.6 (FullTextEntityManager instantiation fails with ClassCastException)","After upgrading from 2.3.5.RELEASE to 2.4.0 instantiating a `FullTextEntityManager` (hibernate search) from an injected `EntityManager` is not possible anymore. The same code worked in the past and is derived from the [official documentation](https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#_indexing) or [baeldung](https://www.baeldung.com/hibernate-search#building-the-lucene-index).  Code to reproduce: https://github.com/knoobie/spring-2-4-entitymanager  How to check:  - run the test; test fails on service#load - you can verify that it worked, if you just change the version to 2.3.5.RELEASE again and start the test (it doesn't fail)  Stacktrace:  ```log java.lang.ClassCastException: com.sun.proxy.$Proxy98 cannot be cast to org.hibernate.engine.spi.SessionImplementor  	at org.hibernate.search.impl.FullTextSessionImpl.(FullTextSessionImpl.java:62) 	at org.hibernate.search.impl.ImplementationFactory.createFullTextSession(ImplementationFactory.java:35) 	at org.hibernate.search.Search.getFullTextSession(Search.java:45) 	at org.hibernate.search.jpa.Search.getFullTextEntityManager(Search.java:49) 	at com.example.demo.search.MyService.load(MyService.java:51) 	at com.example.demo.search.MyService$$FastClassBySpringCGLIB$$195495fd.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:371) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:134) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) 	at com.example.demo.search.MyService$$EnhancerBySpringCGLIB$$9e31f121.load() 	at com.example.demo.DemoApplicationTests.contextLoads(DemoApplicationTests.java:20) ```","closed","type: documentation,","knoobie","2020-11-13T07:39:21Z","2022-07-14T11:01:54Z"
"","26696","RestTemplate.exchange meet NPE","After the version was released, i found that the service had problems.  When i restart the service, ths service is normal.  Too strange....  ```java java.lang.NullPointerException: null 	at org.springframework.web.client.RestTemplate$AcceptHeaderRequestCallback.doWithRequest(RestTemplate.java:774) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.client.RestTemplate$HttpEntityRequestCallback.doWithRequest(RestTemplate.java:838) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:659) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:637) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:558) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at com.epoch.console.util.HttpClientUtils.getDataToProduct(HttpClientUtils.java:215) ~[com.epoch.console-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at com.epoch.sso.service.imp.MobileService.getWxOpenId(MobileService.java:174) ~[com.epoch.sso-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at com.epoch.sso.service.imp.MobileService.getOpenId(MobileService.java:131) ~[com.epoch.sso-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at com.epoch.console.web.controller.MobileTripartiteController.getToken(MobileTripartiteController.java:66) ~[classes/:?] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_45] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_45] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_45] 	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_45] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:854) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:765) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652) ~[servlet-api.jar:?] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) ~[spring-webmvc-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[servlet-api.jar:?] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) ~[tomcat-websocket.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at com.epoch.console.service.filter.XSSSecurityFilter.doFilterInternal(XSSSecurityFilter.java:30) ~[com.epoch.console-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at com.epoch.console.service.filter.AbstractGenericFilter.doFilter(AbstractGenericFilter.java:95) ~[com.epoch.console-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at com.epoch.console.service.filter.PermissionFilter.doFilterInternal(PermissionFilter.java:40) ~[com.epoch.console-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at com.epoch.console.service.filter.AbstractGenericFilter.doFilter(AbstractGenericFilter.java:95) ~[com.epoch.console-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at com.epoch.console.web.filter.LoginFilter.doFilterInternal(LoginFilter.java:67) ~[classes/:?] 	at com.epoch.console.service.filter.AbstractGenericFilter.doFilter(AbstractGenericFilter.java:95) ~[com.epoch.console-hotfix.21.0125-ECS.V11.0.20201105.01release.jar:?] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.25.RELEASE.jar:4.3.25.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[catalina.jar:8.5.61] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:544) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) ~[catalina.jar:8.5.61] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) ~[catalina.jar:8.5.61] 	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:690) ~[catalina.jar:8.5.61] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[catalina.jar:8.5.61] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[catalina.jar:8.5.61] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:616) ~[tomcat-coyote.jar:8.5.61] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-coyote.jar:8.5.61] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:831) ~[tomcat-coyote.jar:8.5.61] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1634) ~[tomcat-coyote.jar:8.5.61] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-coyote.jar:8.5.61] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[?:1.8.0_45] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[?:1.8.0_45] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-util.jar:8.5.61] 	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_45] ```","closed","","poiyyq","2021-03-18T08:06:25Z","2021-04-02T14:58:02Z"
"","26546","IllegalArgumentException due to lack of a cached lookupPath","After the changes to support parsed `PathPattern` in #24945, various components such as `MappedInterceptor`, `UrlBasedCorsConfigurationSource` and others expect to find a pre-resolved, cached lookupPath via  `ServletRequestPathUtils.getCachedPath`. This is done for sub-classes for `AbstratHandlerMethodMapping` and `AbstractUrlHandlerMapping` but others that extend directly from `AbstractHandlerMapping` would need to call `initLookupPath` in order for `MappedInterceptor` and others to find the lookupPath.   This is the case with `FlowHandlerMapping` in Spring Web Flow, reported in [SWF-1744](https://jira.spring.io/browse/SWF-1744), which does not need the lookupPath itself but nevertheless that still breaks auxiliary components like `MappedInterceptor`. We can address this in `AbstractHandlerMapping#getHandlerExecution` to ensure the presence of a cached lookupPath if not already added by sub-classed in `getHandlerInternal`.","closed","type: bug,","rstoyanchev","2021-02-15T10:16:36Z","2021-02-22T15:48:15Z"
"","26308","ClassNotFoundException: ExchangeFunction when using WebTestClient with Spring MVC","After reading release notes for Spring Framework 5.3 and the [Reference Documentation](https://docs.spring.io/spring-framework/docs/5.3.1/reference/html/testing.html#webtestclient) I wanted to use WebTestClient in a Spring MVC application, but it fails with:  ``` Injection of autowired dependencies failed; nested exception is java.lang.NoClassDefFoundError: org/springframework/web/reactive/function/client/ExchangeFunction  Caused by: java.lang.NoClassDefFoundError: org/springframework/web/reactive/function/client/ExchangeFunction 	at org.springframework.test.web.reactive.server.DefaultWebTestClientBuilder.build(DefaultWebTestClientBuilder.java:268) 	at com.example.mvcwebtestclient.GreetingControllerTest.create(GreetingControllerTest.java:23) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ```  ## Reproducing build.gradle ```gradle dependencies { 	implementation(platform(""org.springframework.boot:spring-boot-dependencies:2.4.1"")) 	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive' 	implementation 'org.springframework.boot:spring-boot-starter-web' 	testImplementation 'org.springframework.boot:spring-boot-starter-test' 	testImplementation 'io.projectreactor:reactor-test' } ```  GreetingController.java ```java @RestController @RequestMapping(""/greetings"") public class GreetingController {      @GetMapping     public Flux findAll() {         return Flux.just(""Hello"", ""world!"");     } } ```  GreetingControllerTest.java ```java @SpringBootTest class GreetingControllerTest {      private WebTestClient client;      @Autowired     public void create(WebApplicationContext context) {         client = MockMvcWebTestClient.bindToApplicationContext(context)                 .configureClient()                 .build();     }      @Test     public void findsAll() {         client.get().uri(""/greetings"")                 .exchange()                 .expectStatus().isOk();     } } ```  ## Workaround  Add webflux dependency: ```gradle implementation 'org.springframework.boot:spring-boot-starter-webflux' ```  I think it's a bug in code or at least a bug in documentation. The documentation does not mention in any place that you need WebFlux to test your MVC applications. This is an idea that looks absurd at first sight, so if it is really the case, it should be explicitly explained that you really need to do it.","closed","type: enhancement,","pkubowicz","2020-12-22T14:05:53Z","2021-01-06T21:56:36Z"
"","26140","Projects can no longer be imported into Eclipse IDE","After changes to the Gradle build in recent months, projects in the Spring Framework can no longer be imported into Eclipse IDE.  For example, there are issues with JMH sources as well as test fixtures.","closed","type: task,","sbrannen","2020-11-23T16:19:05Z","2020-11-23T16:25:34Z"
"","26183","GenericConversionService$Converters.getMatchableConverters throws ConcurrentModificationException on Java 9+","Affects: spring-boot 2.3.2 and higher  Since this commit https://github.com/spring-projects/spring-framework/commit/550f13e8ed678447a61872b4f9ff96d918003102#diff-00728bf33ef5ae1a833bdd47f5095b4bb377206328c288ad2290e9d89ba0d3d4 we get intermittent  `ConcurrentModificationException` from `GenericConversionService$Converters.getMatchableConverters(GenericConversionService.java:522)` during start:  ```java ERROR 2020-11-30 18:26:00.296 [AcxSpringBoot-56.starting][c1a00a] - Application run failed [SpringApplication] java.util.ConcurrentModificationException: null   at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134)   at org.springframework.core.convert.support.GenericConversionService$Converters.getMatchableConverters(GenericConversionService.java:522)   at org.springframework.core.convert.support.GenericConversionService$Converters.add(GenericConversionService.java:515)   at org.springframework.core.convert.support.GenericConversionService.addConverter(GenericConversionService.java:105)   at org.springframework.core.convert.support.GenericConversionService.addConverter(GenericConversionService.java:99)   at org.springframework.security.config.crypto.RsaKeyConversionServicePostProcessor.postProcessBeanFactory(RsaKeyConversionServicePostProcessor.java:72)   at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:291)   at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:182)   at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:707)   at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:533)   at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:143)   at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758)   at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750)   at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)   at org.springframework.boot.SpringApplication.run(SpringApplication.java:315)   at com.wamas.acx4.mfs.core.server.remote.rest.AcxSpringAppForRest.start(AcxSpringAppForRest.java:97)   at com.wamas.acx4.mfs.core.server.remote.rest.AcxSpringDaemon.onStart(AcxSpringDaemon.java:57)   at com.wamas.acx4.mfs.core.etc.executor.AcxRunnable.lambda$onStartInternal$2(AcxRunnable.java:318)   at com.wamas.acx4.mfs.core.decorator.internal.InternalDecorateWith.execWithNewContextAndTransaction(InternalDecorateWith.java:183)   at com.wamas.acx4.mfs.core.decorator.Decorate.exec(Decorate.java:840)   at com.wamas.acx4.mfs.core.etc.executor.AcxRunnable.onStartInternal(AcxRunnable.java:318)   at com.wamas.acx4.mfs.core.server.platform.daemon.ServiceDaemon.onStartInternal(ServiceDaemon.java:96)   at com.wamas.acx4.mfs.core.etc.executor.AcxRunnable.run(AcxRunnable.java:181)   at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)   at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)   at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)   at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)   at java.base/java.lang.Thread.run(Thread.java:834) ```  Since Java 9 `java.util.HashMap.computeIfAbsent` shows this behavior.  See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html#computeIfAbsent(K,java.util.function.Function)","closed","in: core,","HelJani","2020-12-01T06:28:29Z","2020-12-02T12:27:48Z"
"","26156","Circular dependency problem","Affects: Spring Framework  < 5.3.1  There are @Async and @Transactional annotations in the same class, and the class depends on itself. There will be a problem org.springframework.beans.factory.BeanCurrentlyInCreationException  example: ![image](https://user-images.githubusercontent.com/38159229/100346701-3bc7c780-301f-11eb-89e3-f13fd6addcae.png)  I think it is caused by the following code：  in      AbstractAdvisingBeanPostProcessor          @Override 	public Object postProcessAfterInitialization(Object bean, String beanName) { 		if (this.advisor == null || bean instanceof AopInfrastructureBean) { 			// Ignore AOP infrastructure such as scoped proxies. 			return bean; 		}                  		if (bean instanceof Advised) { 			Advised advised = (Advised) bean; 			if (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) { 				// Add our local Advisor to the existing proxy's Advisor chain... 				if (this.beforeExistingAdvisors) { 					advised.addAdvisor(0, this.advisor); 				} 				else { 					advised.addAdvisor(this.advisor); 				} 				return bean; 			} 		}                 // I think there is a problem here, there is a problem with this judgment 		if (isEligible(bean, beanName)) { 			ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName); 			if (!proxyFactory.isProxyTargetClass()) { 				evaluateProxyInterfaces(bean.getClass(), proxyFactory); 			} 			proxyFactory.addAdvisor(this.advisor); 			customizeProxyFactory(proxyFactory); 			return proxyFactory.getProxy(getProxyClassLoader()); 		}  		// No proxy needed. 		return bean; 	}  My solution is as follows:        in AbstractBeanFactoryAwareAdvisingPostProcessor       @Nullable      protected ConfigurableListableBeanFactory beanFactory;           in AbstractAdvisingBeanPostProcessor         @Override        public Object postProcessAfterInitialization(Object bean, String beanName) {         if (this.advisor == null || bean instanceof AopInfrastructureBean) {             // Ignore AOP infrastructure such as scoped proxies.             return bean;         }          if (bean instanceof Advised) {             Advised advised = (Advised) bean;             if (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {                 // Add our local Advisor to the existing proxy's Advisor chain...                 if (this.beforeExistingAdvisors) {                     advised.addAdvisor(0, this.advisor);                 }                 else {                     advised.addAdvisor(this.advisor);                 }                 return bean;             }         }          if (isEligible(bean, beanName)) {             // The changes are as follows             DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) this.beanFactory;             Object singleton = defaultListableBeanFactory.getSingleton(beanName);             if (singleton instanceof Advised) {                 Advised advised = (Advised) singleton;                 if (!advised.isFrozen()) {                      // Add our local Advisor to the existing proxy's Advisor chain...                     if (this.beforeExistingAdvisors) {                         advised.addAdvisor(0, this.advisor);                     }                     else {                         advised.addAdvisor(this.advisor);                     }                     return bean;                  }             } else {                  ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);                 if (!proxyFactory.isProxyTargetClass()) {                     evaluateProxyInterfaces(bean.getClass(), proxyFactory);                 }                 proxyFactory.addAdvisor(this.advisor);                 customizeProxyFactory(proxyFactory);                 return proxyFactory.getProxy(getProxyClassLoader());             }          }          // No proxy needed.         return bean;     }","open","in: core,","ypdaic","2020-11-26T12:56:34Z","2021-11-10T10:03:02Z"
"","26772","Suggestion way to handle both exceptions from HandlerFunction and non-path exception in Spring MVC","Affects: Spring 5.3.5  I'm using Spring MVC framework with functional controller (HandlerFunction, HandlerFunctionFilter, are landed on Spring 5.2). While using it, I encountered problem with global exception capture. If I use onError for handling exception, I still need to use `@ControllerAdvice` and `@ErrorException` for non-path exceptions (`AccessDeniedException`,`NotFoundHandlerException`, ...). This is inconsistency. After some research, I decide to use `mappedHandlerClasses`  of `ExceptionHandlerExceptionResolver` to handle exception in functional controller. However, when enable setting mappedHandlerClasses, `ExceptionHandlerExceptionResolver` cannot handle non-path exceptions (`AccessDeniedException`,`NotFoundHandlerException`, ...).  In my opinion, `ExceptionHandlerExceptionResolver` should capture both `HandlerMethod` (annotation controller) and `HandlerFunction` (functional controller) in Spring MVC. Or another suggestion, it's `mappedHandlerClasses` should not effect to  capability of handling `HandlerMethod` of `ExceptionHandlerExceptionResolver`.  Or is there any clever way to resolve this issue? Currently, I work around by creating another `ExceptionHandlerExceptionResolver` with `mappedHandlerClasses` for function controller exception handler, beside original `ExceptionHandlerExceptionResolver`.","open","status: feedback-provided,","haupv1m","2021-04-07T12:04:58Z","2021-11-08T11:37:32Z"
"","26097","MockHttpServletRequest getParameter(String name) can not get string value parts","Affects: 5.3.1  as [servlet3.0](https://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1605531282_73debc7c1e2429d7619f6e1493dfb09e) says: For parts with form-data as the Content-Disposition, but without a filename, the string value of the part will also be available via the getParameter / getParameterValues methods on HttpServletRequest, using the name of the part.  but when use MockHttpServletRequest ,I can't not get parameter which i filled by MockPart.And there is not association between parameters and parts in MockHttpServletRequest","closed","in: web,","polarisGitHub","2020-11-16T13:08:11Z","2020-12-01T11:55:22Z"
"","25997","Potentially concurrent and memory leak","Affects: all up to 5.3.1-SNAPSHOT  I found some suspicious pattern of the Java code which can lead to concurrent race condition and memory leak. I confirm problematic software pattern in other software, outside of Spring. In Spring-Framework source code I found the same concurrent pattern in places e.g. CacheAspectSupport, AbstractAdvisingBeanPostProcessor, AdvisedSupport, AsyncExecutionInterceptor etc.  Also in other place of Spring-Framework source code it's correctly implemented.   Also I'd like to mention that I'm application developer not framework developer and I don't know internal Spring implementation. I known sounds unlikely. I hope I'm wrong.   I will provide more details via e-mail security@pivotal.io  Kindly regards","open","in: core,","MarcinNowak-codes","2020-10-29T20:31:35Z","2021-11-11T09:32:03Z"
"","26501","MockPart in request is not recieved in RequestPart in controller","Affects version: 5.3.3 Related to: #26261  I have a controller method that accepts `multipart/form-data` requests with 2 parameters: a file and a `@RequestPart String label`. Previously in my tests I was creating a `MockPart` for the label and it was working fine: `new MockPart(""label"", ""mainImage"".getBytes(UTF_8))`.  With the latest changes in 5.3.3 the `MockPart` is converted to a request parameter instead of a multipart boundary and I don't receive anything for the `RequestPart` in the controller thus breaking the tests.  Why is it necessary to convert MockParts to parameters in a multipart request? I'm not sure if this is strictly related to the value being a parameter of if there is another underlying issue. I thought that I should receive the value by using either `RequestPart` or `RequestParam` just using different converters.","closed","type: bug,","LickIt","2021-02-03T09:58:59Z","2021-02-04T18:14:25Z"
"","26119","Update default for favorPathExtension to match Javadoc and as intended for 5.3","Affected Version: `Spring Web 5.3.1`.  Deprecation note on [ContentNegotiationManagerFactoryBean:setFavorPathExtension(boolean)](https://github.com/spring-projects/spring-framework/blob/6a0377b1a257a10ddc5735472094e649c14e2572/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java#L164-L177) is misleading.  https://github.com/spring-projects/spring-framework/blob/6a0377b1a257a10ddc5735472094e649c14e2572/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java#L164-L177  It states that `As there is no replacement for this method, in 5.2.x it is necessary to set it to {@code false}. In 5.3 the default changes to {@code false} and use of this property becomes unnecessary.`  But the default value of `favorPathExtension` still is `true`.  https://github.com/spring-projects/spring-framework/blob/6a0377b1a257a10ddc5735472094e649c14e2572/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java#L111  If the property is not used, path extension will be favored indicating that a call to `setFavorPathExtension(false)` is still necessary, contrary to the deprecation note.","closed","type: bug,","mwftapi","2020-11-19T14:54:48Z","2020-11-24T17:40:01Z"
"","26813","Easier policy setters for ThreadPoolTaskScheduler.","Added an easier way to set ExecuteExistingDelayedTasksAfterShutdown and ContinueExistingPeriodicTasksAfterShutdown policies. This closes an existing issue: https://github.com/spring-projects/spring-framework/issues/26719""","closed","","Aelykto","2021-04-15T21:00:56Z","2022-02-18T19:05:38Z"
"","26725","Add reverse methed in MethodMatchers and ClassFilters","Add reverse methed in MethodMatchers and ClassFilters.  Add support for MethodMatchers and ClassFilters to reverse the given MethodMatcher and ClassFilter. It is convenient in some complex conditions,Or is there another way to do it?Thanks.","open","in: core,","Jinhui-Z","2021-03-25T07:10:26Z","2022-07-21T05:47:44Z"
"","26339","Add null check for ExceptionHandlerMethodResolvers","Add null check to avoid subsequent locking and map operations","closed","type: enhancement,","liaozan","2021-01-03T18:54:56Z","2021-01-08T21:54:43Z"
"","25951","Support Optional for query parameters in UriBuilder and UriComponentsBuilder","Add a method optionalQueryParam(String, Optional) to the UriBuilder interface.  The implementation adds the query parameter contained by the optional to the URL.  If the optional is empty then no action is taken; specifically the query parameter name is not added to the URL.  This PR replaces #25925 and #25950.","closed","type: enhancement,","robinroos","2020-10-21T16:36:46Z","2020-10-23T17:30:00Z"
"","26558","Support cookies with Expires attribute but no Max-Age attribute in MockHttpServletResponse","According to the spec it is allowed to have cookies that only use the `Expires` attribute (even though it's really old style).  `MockHttpServletResponse` didn't previously support that properly.  So, added a testcase and made it work.","closed","type: enhancement,","koosg","2021-02-17T12:06:06Z","2021-02-17T15:35:14Z"
"","26753","Update Javadoc on CORS in spring-websocket","According to the documentation, the iframe fallback is useful for transports with no native cross-domain communication.  See : https://github.com/spring-projects/spring-framework/blob/58e40d1aa2c23f6d9c41d4289f5b5debc10868f6/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/support/AbstractSockJsService.java#L146  But when configuring my app for allowing a specific origin, and when my client request the Iframe, this bloc of code prevent me from getting it : https://github.com/spring-projects/spring-framework/blob/58e40d1aa2c23f6d9c41d4289f5b5debc10868f6/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/support/AbstractSockJsService.java#L407  This bloc of code seems to say I could bypass it by setting `""*""` in allowOrigins. But it then conflicts with the ""Access-Control-Allow-Credentials"" set to true, which is forbidden for the `""*""` regex.  https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/web.html#websocket-fallback-sockjs-overview)  I have the feeling there is a contradiction here. For some transport, I need and iframe when I want to do cross-domain communication. But the very same process of providing an iframe is restricted if I want to access it cross-domain.  Is this code outdated and need an update? Or am I missing a point? If option one, I can work on the PR.","closed","in: web,","kbuntrock","2021-04-02T08:58:00Z","2021-04-13T16:43:57Z"
"","26507","Exception handling support for ""problem details"" rfc7807","According to **RFC-7807** (see https://tools.ietf.org/html/rfc7807) it would be useful to provide an `invalid-params` field in case of `400 Bad Request` errors. This field is supposed to contain ALL violated parameters, no matter which `Exception` type is caught by the `ExceptionHandler` annotated methods.  Since in case of multiple violations it is possible that `Exceptions` of different types occur (e.g. `ConstraintViolationException` and `MethodArgumentTypeMismatchException` from one request), those `Exception` objects must be available in the `ExceptionHandler`.  A solution would be a resolver for a `List` of `Exceptions`.","closed","type: enhancement,","dirweis","2021-02-04T10:23:38Z","2021-07-05T10:57:59Z"
"","26825","Remove reference to Joda Time support in @DateTimeFormat Javadoc","According to #25736 and to be compatible with official documentation it would be great to remove mention of Joda Time support.","closed","type: task,","hrybs","2021-04-19T17:41:49Z","2021-04-20T16:54:40Z"
"","26800","WebFlux not compatible with New Relic Agent due to Memory Issues","A spring Boot 2.4.2, and Cloud 2020.0.2, microservice using WebFlux and New Relic, after a period of time:  * Heap memory usage gets higher and higher * All memory is moved to the Old Gen * Garbage Collector takes a lot of CPU (due to full GC required to clean Old Gen) and application becomes unresponsive  The issue does not happen when New Relic is not included, no memory issues. These New Relic agent versions were tested and all presented the same issue over time: 5.8.0, 5.14.0 and 6.4.2  We can replicate this without fail via load testing over time.  Eventually the service crashes, a Heap Dump was retrieved moments before the crash and analyzed using the Eclipse Memory Analyzer, and 260mb were being used by New Relic.  Image shows Old gen over time. ![image2021-4-13_15-17-17](https://user-images.githubusercontent.com/46800333/114652162-a789a300-9d28-11eb-90a1-2071aa8c6799.png)  We can provide whatever further details are needed to resolve.","closed","for: external-project,","khorn-infomedia","2021-04-14T03:55:13Z","2021-04-14T08:17:31Z"
"","26250","Propagation.REQUIRES_NEW May cause all connections to be occupied","A method that opens a transaction calls another method that starts a new transaction，if all connections are exhausted before the last new transaction method is executed,then all threads in the process will block，this process will fail.  Pseudo code：  ``` @Transactional methodA(){     // All the threads that started the transaction were executed here, but the connection was exhausted.     // The latter method execution will get a new connection,but it will never get it.     @Transactional(propagation=Propagation.REQUIRES_NEW)     methodB(){     } } ```","open","in: data,","wlizhi","2020-12-10T08:32:04Z","2022-02-03T07:50:46Z"
"","26386","Return 415 for form data via @RequestBody in WebFlux","A `@RestController` like  ``` @RestController  public class DemoController {      @PostMapping      public Map getAttributes(@RequestBody Body body, ServerWebExchange serverWebExchange) {          return serverWebExchange.getAttribute(body.getAttribute());      }  } ```  is expected to handle requests with content type _application/json_. When the client request has a content type _x-www-form-urlencoded_, I would expect that the server returns _415 Unsupported Media Type_ or another client error. Instead Spring throws _java.lang.IllegalStateException: In a WebFlux application, form data is accessed via ServerWebExchange.getFormData()._  A sample application with failing test can be found here: https://github.com/huberchrigu/spring-reactive-wrong-content-type","closed","type: enhancement,","huberchrigu","2021-01-14T11:04:02Z","2021-01-14T21:25:15Z"
"","26530","Enforce standard Java types in YamlProcessor","`spring-beans` ships a `YamlProcessor` that's used as a base class by `YamlMapFactoryBean` and `YamlPropertiesFactoryBean`. These implementations have a clear use case: mapping application-internal Yaml documents for configuration or infrastructure purposes.  Since this use case rarely requires extended types support from the underlying library, and since we're offering ways to list custom types (since #25152), we'll restrict to java standard types only by default. This simplifies the setup and focuses the abstract class on the core use cases.  Developers can leverage #25152 to allow custom types like this:  ```java YamlMapFactoryBean factory = new YamlMapFactoryBean(); factory.setResources(resource); // Allow constructors for custom types User and Book factory.setSupportedTypes(User.class, Book.class); Map map = factory.getObject(); ```","closed","type: enhancement,","bclozel","2021-02-09T14:00:07Z","2021-02-09T14:07:10Z"
"","26033","Upgrade SpelCompiler bytecode level to 1.8 and optimize for concurrent access","`SpelCompiler` still uses bytecode level 1.5 and does not consistently guard against concurrent class loading. Let's revisit this for 5.3.1, in preparation for the long-lived 5.3.x line.","closed","type: enhancement,","jhoeller","2020-11-05T11:43:22Z","2020-11-05T16:45:47Z"
"","26472","Question about ResourceBundleMessageSource's cachedBundleMessageFormats","`ResourceBundleMessageSource`'s `cachedBundleMessageFormats` cache is declared as:  `Map>>`  But `ResourceBundle` already contains a `Locale` property. So why not declare it as the following?  `Map>`","open","in: core,","huanghaiheart","2021-01-29T09:17:03Z","2021-01-29T14:31:36Z"
"","26808","Support parse Illegal character in query at `ReactorServerHttpRequest`","`ReactorHttpHandlerAdapter` ![image](https://user-images.githubusercontent.com/4693441/114832316-f30f8000-9e00-11eb-89d8-233a489fa362.png)  I need to pass the original Query to the Upstream use `SpringCloudGateway`.  The URI is `http://localhost:8080/test-like-this?a={{bbb}}`.   I can't encode Query for some reason such as not supported by third-party companies.  ** Webflux can't pause this query too. **   ``` java @GetMapping(""/test-like-this"") public String string(HttpServerRequest httpServerRequest){   return httpServerRequest.params().toString(); } ```  Should we support it? Or other workarounds?  Tomcat's solution. https://stackoverflow.com/questions/41053653/tomcat-8-is-not-able-to-handle-get-request-with-in-query-parameters/44005213#44005213","closed","status: declined,","a1vin-tian","2021-04-15T07:53:18Z","2021-04-19T08:41:45Z"
"","26031","MergedAnnotationCollectors.toAnnotationSet() should not create intermediate ArrayList","`MergedAnnotationCollectors.toAnnotationSet()` currently creates an intermediate `ArrayList` for storing the results prior to creating a `LinkedHashSet` in the finishing step. The creation of the intermediate list is unnecessary and can be avoided.","closed","type: enhancement,","sbrannen","2020-11-04T13:12:33Z","2020-11-05T18:27:35Z"
"","26122","Simplify XMLEventStreamWriter.writeEndElement()","`List.get(i)` and `List.remove(i)` could be merged into `List.remove(i)` if the instance is not modified between them.","closed","in: core,","stsypanov","2020-11-19T15:42:17Z","2021-06-02T09:32:13Z"
"","26656","Ensure ClientResponse logPrefix Contains the Connection Id When Available","`ClientRequest` exposes a `logPrefix`, controlled via a request attribute or otherwise set to an identity hash by default. The `logPrefix` is passed to and exposed in the `ClientResponse` but and it helps to correlate request and response logging, However, it is not connected to the underlying connection id and logging from the underlying HTTP client.  `ClientHttpResponse` can expose an `id` similar to `ServerHttpRequest` which can be based on the connection id when available. This can then be appended to the existing `logPrefix` such that once a response is obtained, subsequent logging will also include the underlying a connection id.","closed","type: enhancement,","rstoyanchev","2021-03-09T18:12:47Z","2021-03-10T20:41:38Z"
"","26574","ClassLoader.getResource can throw IllegalArgumentException","`ClassLoader.getResource` can throw `IllegalArgumentException` if a malformed URL is provided to it.  According to its javadoc, `resolveURL` should return null if not resolvable, so catch the `IllegalArgumentException` and return null.  Example stack trace produced by `new org.springframework.core.io.DefaultResourceLoader().getResource(""C:/users/candrews/example"").exists()` ``` java.lang.IllegalArgumentException: name         at java.base/jdk.internal.loader.URLClassPath$Loader.findResource(URLClassPath.java:600)         at java.base/jdk.internal.loader.URLClassPath.findResource(URLClassPath.java:291)         at java.base/java.net.URLClassLoader$2.run(URLClassLoader.java:655)         at java.base/java.net.URLClassLoader$2.run(URLClassLoader.java:653)         at java.base/java.security.AccessController.doPrivileged(Native Method)         at java.base/java.net.URLClassLoader.findResource(URLClassLoader.java:652)         at org.springframework.boot.loader.LaunchedURLClassLoader.findResource(LaunchedURLClassLoader.java:100)         at java.base/java.lang.ClassLoader.getResource(ClassLoader.java:1401)         at org.springframework.core.io.ClassPathResource.resolveURL(ClassPathResource.java:155)         at org.springframework.core.io.ClassPathResource.exists(ClassPathResource.java:142) ```","closed","in: core,","candrews","2021-02-20T05:35:44Z","2021-02-25T16:55:24Z"
"","26645","Fix test context bootstrapper inheritance override","`BootstrapWith` as a meta override should be considered on the test class and all ancestors, not just the direct test class.  ----  It is common to use a base test class such as: ``` @SpringBootTest public abstract class BaseTest { } ``` Annotating this `BaseTest` with `@BootstrapWith(XXX)` should not make tests extending this class fail with a `java.lang.IllegalStateException: Configuration error: found multiple declarations of @BootstrapWith` but instead properly use the `@BootstrapWith` as an override of the bootstrap provided as meta by `@SpringBootTest`.","open","in: test,","antoinemeyer","2021-03-06T15:11:02Z","2021-11-12T14:15:59Z"
"","26594","Introduce RowMapper with automatic binding to fields","`BeanPropertyRowMapper` requires setters being present. Which is fine if you have some.  But if you only have a simple dto class for some reason, and want to make use of the mapper, it requires to create setters just for that.  It would be nice if we could have some `DirectFieldRowMapper` additionally, similar to: https://gist.github.com/stianl/6629122#file-directfieldrowmapper  Spring already allows direct field mapping for mvc with `DataBinder.initDirectFieldAccess()`. So why not providing a direct mapper also for jdbc beans, that can simply operate on `public` fields?","open","type: enhancement,","membersound","2021-02-23T15:37:54Z","2021-02-23T16:59:50Z"
"","26034","Optimize locking in AspectJProxyFactory for concurrent aspect instantiation","`AspectJProxyFactory` traditionally uses double-checked locking for accessing singleton aspect instances, applying a full lock for creating a new aspect instance. The latter can be reduced to a segment lock in `ConcurrentHashMap` through the use of `computeIfAbsent`, which is sensible here since the mapping function is self-contained and does not delegate to an SPI.","closed","type: enhancement,","jhoeller","2020-11-05T12:01:45Z","2020-11-05T12:12:25Z"
"","25980","Cached value is not of required type for Kotlin Boolean","`AbstractValueAdaptingCache.get` checks whether the requested type matches with the value type in the cache. This fails for Kotlin `Boolean` value type. The usage is as follows:  Cache spec: `maximumSize=100,expireAfterWrite=5s` ``` myCache.putIfAbsent(uuid, true) // uuid is a string myCache.get(uuid, Boolean::class.java) ```  The type in `AbstractValueAdaptingCache.get` shows up as `boolean`, which seems to be the problem, but is correct according to [Kotlin docs](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/). > On the JVM, non-nullable values of this type are represented as values of the primitive type boolean.  I'm not aware of a way to use `myCache.get` with a nullable `Boolean` type that'd then be translated to Java `Boolean` wrapper type. `Boolean?::class.java` isn't valid Kotlin code.  Spring Boot 2.3.4.RELEASE, Spring 5.2.9.RELEASE, Caffeine cache 2.8.6.","closed","in: core,","asarkar","2020-10-28T00:07:03Z","2020-10-28T17:58:58Z"
"","26657","AOP java.lang.IllegalArgumentException: object is not an instance of declaring class","```java @Transactional     @Override     public TaskInfo saveTaskInfo(SaveTaskInfo save) {          Task entity = Task.builder()                 .id(save.getId())                 .name(save.getName())                 .projectId(save.projectId())                 .projectVersion(save.versionId())                 .targetId(save.executeTarget())                 .type(save.getType())                 .strategyId(save.strategyId())                 .time(save.time())                 .range(save.range())                 .cycle(save.cycle())                 .retest(Convert.toInt(save.isRetest()))                 .parameters(save.getParameters())                 .build();          saveOrUpdate(entity);          return get(entity.getId());     } ``` ```java @AfterReturning(value = ""execution(* com.dbapp.dipper.service.TaskService.saveTaskInfo(..))"",             returning = ""result"")     @Async     public void saveTaskAfter(JoinPoint joinPoint, Object result) {         String methodName = joinPoint.getSignature().getName();         Object[] params = joinPoint.getArgs();         TaskInfo task = (TaskInfo) result;          if (Cycle.NOW == Cycle.valueOf(task.getExecute().getCycle())) {             taskScanService.execute(task.getId());         }          System.out.println(""saveTaskAfter runing.."");     } ``` ```java org.springframework.aop.AopInvocationException: Mismatch on arguments to advice method [public void com.dbapp.dipper.job.ScanJobScheduling.saveTaskAfter(org.aspectj.lang.JoinPoint,java.lang.Object)]; pointcut expression [org.aspectj.weaver.internal.tools.PointcutExpressionImpl@7a9c6ee8]; nested exception is java.lang.IllegalArgumentException: object is not an instance of declaring class 	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:649) 	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:626) 	at org.springframework.aop.aspectj.AspectJAfterReturningAdvice.afterReturning(AspectJAfterReturningAdvice.java:66) 	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:56) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:367) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) 	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) 	at com.dbapp.dipper.service.impl.TaskServiceImpl$$EnhancerBySpringCGLIB$$9bcd0779.saveTaskInfo() 	at com.dbapp.dipper.controller.TaskController.taskUpdate(TaskController.java:43) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920) ```","closed","","799452017","2021-03-10T08:14:34Z","2022-02-18T19:05:37Z"
"","25984","How do I close the websocket connection?","```java @Slf4j @Configuration public class WebSocketConnectListener implements ApplicationListener {     @Override     public void onApplicationEvent(SessionConnectEvent event) {         StompHeaderAccessor wrap = StompHeaderAccessor.wrap(event.getMessage());         String jwtToken = wrap.getFirstNativeHeader(""Authorization"");         // check jwtToken...         // if this check fails, I want to close the websocket connection, but I don't know how to close it?     } } ```  I want an example of closing a WebSocket connection. Thank you in advance for your answers.","closed","status: duplicate,","13554599576","2020-10-28T13:44:43Z","2020-10-28T13:55:45Z"
"","26526","Proposal to introduce a method that can get all instances in the JVM (including instances created by spring-framework)","```java @Scope(""singleton"") @Component public class Instance{     ...... }  @Component public class TestService{     @Resource     private Instance instance;     private Instance instance2=new Instance(); } ```  the native method declared :  ```java public static synchronized native  LinkedList getInstances(Class klass); ```  and call the native method above like this:  ```java LinkedList list = getInstances(Instance.class); System.out.println(list.size()); ```  finally, you get a list of two elements.  If I provide a method that can get all instances in the JVM (including instances created by spring-framework), is this method meaningful ?","closed","type: enhancement,","dragon-zhang","2021-02-09T07:33:30Z","2021-02-16T14:59:48Z"
"","26743","Binding error with AspectJ @Around advice","```java @Aspect @Component @Order(Ordered.HIGHEST_PRECEDENCE) public class TestTwoAop {  	@Around(""@annotation(aopAnnoTwo)"") 	public Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint, 			AopAnnoTwo aopAnnoTwo) throws Throwable { 		return proceedingJoinPoint.proceed(); 	} } ```  ``` Error ""java.lang.IllegalStateException: Required to bind 2 arguments, but only bound 1 ```  the userAttributes of  Class ReflectiveMethodInvocation  null value ,cause JoinPointMatch is null   then I set order sort  another value.Do not have any `RuntimeException`.","closed","status: superseded,","wisty","2021-03-30T07:52:32Z","2021-04-06T08:52:26Z"
"","25982","MockHttpServletResponse.addCookie does not override cookie with the same name","```java     private MockHttpServletResponse response = new MockHttpServletResponse();      @Test     public void removeAuthCookiesTest() {         JwtToken jwtToken = JwtUtils.generateToken(USER_ID);         addAuthCookies(response, jwtToken);          Assert.assertEquals(response.getCookie(COOKIE_KEY_ACCESS).getValue(), jwtToken.getAccess());         Assert.assertEquals(response.getCookie(COOKIE_KEY_REFRESH).getValue(), jwtToken.getRefresh());          removeAuthCookies(response);          Assert.assertNull(response.getCookie(COOKIE_KEY_ACCESS).getValue());         Assert.assertNull(response.getCookie(COOKIE_KEY_REFRESH).getValue());     }       public static void addAuthCookies(HttpServletResponse response, JwtToken jwtToken) {         response.addCookie(getCookie(COOKIE_KEY_ACCESS, jwtToken.getAccess(), cookieLifeTime));         response.addCookie(getCookie(COOKIE_KEY_REFRESH, jwtToken.getRefresh(), cookieLifeTime));     }      public static void removeAuthCookies(HttpServletResponse response) {         response.addCookie(getCookie(COOKIE_KEY_ACCESS, null, 0));         response.addCookie(getCookie(COOKIE_KEY_REFRESH, null, 0));     } ```  Before invocation of method `removeAuthCookies` I have a response with two cookies   ``` name = ""access"", value = ""value1"";  name = ""refresh"", value = ""value2"" ```  After invocation i expected a response with two cookies   ``` name = ""access"", value = null;  name = ""refresh"", value = null ```  but actual result is response with 4 cookies  ``` name = ""access"", value = ""value1"";  name = ""refresh"", value = ""value2""; name = ""access"", value = null;  name = ""refresh"", value = null ```","closed","in: web,","chernikov321","2020-10-28T10:54:07Z","2020-11-02T11:31:27Z"
"","26742","HttpMediaTypeNotAcceptableException exception missing when using ContentNegotiationConfigurer","``` spring-boot-stater-parent.2.4.3 Test OK spring-boot-stater-parent.2.4.4 Test fails ```  I have a test that worked in `2.4.3`, but fails since `2.4.4.`. Thus I assume there has been a change, but I don't know where.  It certainly has to do with `ContentNegotiationConfigurer` when setting a custom `parameterName(""_format"")` and using `defaultContentType(MediaType.APPLICATION_JSON)`.  I was  not able to locate the change that introduced this. Neither am I sure if the former or later outcome is the correct one. But I think the `HttpMediaTypeNotAcceptableException` should not be swallowed (like now in 2.4.4.)  ``` @Configuration public class ContentNegotiationConfiguration implements WebMvcConfigurer { 	@Override 	public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { 		configurer 			.favorParameter(true) 			.parameterName(""_format"") 			.defaultContentType(MediaType.APPLICATION_JSON); 	} }  @SpringBootTest @AutoConfigureMockMvc public class SpringBasicErrorControllerTest { 	@Autowired 	private MockMvc mvc;  	//test for '/error' servlet handler 	@Test 	public void testMediaTypeNotSupported() throws Exception { 		MvcResult rsp = mvc.perform(MockMvcRequestBuilders.get(""/error?_format=test"") 				.requestAttr(RequestDispatcher.ERROR_STATUS_CODE, 501)) 				.andReturn();                  //fails for 2.4.4 (ex is null) 		assertTrue(rsp.getResolvedException() instanceof HttpMediaTypeNotAcceptableException); 	} } ```","open","status: feedback-provided,","membersound","2021-03-29T12:59:33Z","2021-11-10T11:49:56Z"
"","26010","DefaultSimpUserRegistry prevents event from being published if original SimpMessageHeaderAccessor cannot be found","``` 2020-11-02 11:21:46.962 [clientOutboundChannel-3] ERROR  --- o.s.w.s.m.StompSubProtocolHandler.publishEvent(StompSubProtocolHandler.java:385) --- Error publishing SessionConnectedEvent[GenericMessage [payload=byte[0], headers={simpMessageType=CONNECT_ACK, spanTraceId=ae48556ad02db145, spanId=05a96dc7755e5b87, spanParentSpanId=525b2016120994a8, nativeHeaders={spanTraceId=[ae48556ad02db145], spanId=[05a96dc7755e5b87], spanParentSpanId=[525b2016120994a8], spanSampled=[1]}, simpConnectMessage=GenericMessage [payload=byte[0], headers={simpMessageType=CONNECT, simpSessionAttributes={sessionId=4A8F1D6A86E7679007D70E332BEFAE84}, simpHeartbeat=[J@25b0d6a7, spanTraceId=ae48556ad02db145, spanId=ae48556ad02db145, stompCommand=CONNECT, nativeHeaders={accept-version=[1.1,1.0], heart-beat=[10000,10000], spanTraceId=[ae48556ad02db145], spanId=[ae48556ad02db145], spanSampled=[1]}, spanSampled=1, simpSessionId=42vqpveq}], id=cc73a69b-fdc9-979e-c6f5-c325d63842a7, spanSampled=1, simpSessionId=42vqpveq}]] java.lang.IllegalStateException: No SimpMessageHeaderAccessor 	at org.springframework.util.Assert.state(Assert.java:73) ~[spring-core-5.1.7.RELEASE.jar:5.1.7.RELEASE] 	at org.springframework.web.socket.messaging.DefaultSimpUserRegistry.onApplicationEvent(DefaultSimpUserRegistry.java:90) ~[spring-websocket-5.1.7.RELEASE.jar:5.1.7.RELEASE] 	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE] ``` ![image](https://user-images.githubusercontent.com/48820729/97827017-040a8000-1cfe-11eb-8730-2acbdc725d7d.png)","closed","type: enhancement,","kissings","2020-11-02T03:24:56Z","2020-11-02T17:27:09Z"
"","26414","WebMvcConfigurationSupport.beanNameHandlerMapping does not set PathPatternParser","[WebMvcConfigurationSupport.beanNameHandlerMapping](https://github.com/spring-projects/spring-framework/blob/584dabbb3980dbed5272f79a61aa996d390e528c/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L511) creates a `BeanNameUrlHandlerMapping` instance but does not call `setPatternParser`.  Other mappings in the class have the following code:  ```java PathPatternParser patternParser = getPathMatchConfigurer().getPatternParser(); if (patternParser != null) {     mapping.setPatternParser(patternParser); } ```","closed","type: bug,","philwebb","2021-01-21T00:53:00Z","2021-01-22T15:28:31Z"
"","26413","Use lambda form of Assert.notNull in UrlPathHelper","[UrlPathHelper.getResolvedLookupPath](https://github.com/spring-projects/spring-framework/blob/584dabbb3980dbed5272f79a61aa996d390e528c/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java#L214) is called a lot and it constructs a new message String each time. We should switch to use the lamba call instead.","closed","status: invalid,","philwebb","2021-01-20T23:29:13Z","2021-01-21T16:51:01Z"
"","26113","Wildcard is a valid Access-Control-Expose-Headers value","[This check](https://github.com/spring-projects/spring-framework/blob/0e4e25d227dedd1a3ecddc4e40c263f190ca1c2b/spring-web/src/main/java/org/springframework/web/cors/CorsConfiguration.java#L337) is dated.  Wildcard is a valid configuration according to [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) and [spec](https://fetch.spec.whatwg.org/#http-new-header-syntax).","closed","type: enhancement,","jnfeinstein","2020-11-18T14:52:12Z","2020-11-19T13:46:25Z"
"","26274","NettyHeadersAdapter.add() accepts @Nullable value but throws NullPointerException","[NettyHeadersAdapter.add()](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/client/reactive/NettyHeadersAdapter.java#L58) accepts `@Nullable` header value, but then calls `io.netty.handler.codec.http.HttpHeaders` method `add`, the implementation of which (`DefaultHttpHeaders` -> `DefaultHeaders`) throws a NullPointerException if the value is null  I would expect a method accepting a `@Nullable` value not to throw NPE  Perhaps an `if (value != null)` check should be implemented in `NettyHeadersAdapter.add()` before calling `HttpHeaders.add()` ?  Context: I have a `WebFilter` that adds the `x-request-id` header from the request to the response This issue is not easy to predict in testing, because with `SpringBootTest.WebEnvironment.MOCK`, `ServerWebExcahnge.request.headers` returns a `MultiValueMapAdapter` instead of `NettyHeadersAdapter `, which is indeed null-safe. So I only got NPE when the app was deployed to the server, not in tests","closed","type: bug,","mplain","2020-12-15T10:48:05Z","2020-12-17T10:12:19Z"
"","26692","@Autowired can working in BeanPostProcessor","[https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html) I read the doc about @autowired ,found that the doc saying ""Not supported in BeanPostProcessor or BeanFactoryPostProcessor"". But i found that @Autowired can not working in  BeanFactoryPostProcessor ,**but it can working in BeanPostProcessor .**","open","in: core,","maoqingcode","2021-03-17T10:43:01Z","2021-11-10T11:58:08Z"
"","26406","WebFlux handling MappingJacksonValue doesn't work for Flux","[FluxMappingJacksonValue.zip](https://github.com/spring-projects/spring-framework/files/5837142/FluxMappingJacksonValue.zip) **Affects:** \5.3.3  --- When trying to filter Rest Controller Flux output using MappingJacksonValue, you receive an exception instead of filtered JSON. ``` org.springframework.core.codec.CodecException: Type definition error: [simple type, class com.example.Example]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot resolve PropertyFilter with id 'columns'; no FilterProvider configured (through reference chain: java.util.ArrayList[0]->org.springframework.http.converter.json.MappingJacksonValue[""value""]) ```  If you collect the Flux to Mono, and apply MappingJacksonValue to it - it works as expected.   Minimal project for reproducing the issue, with tests, is attached.","closed","status: declined,","webcentric-andrija","2021-01-19T16:10:37Z","2021-01-20T16:01:28Z"
"","26320","Revisit ConcurrentLruCache implementation","[ConcurrentLruCache](https://github.com/spring-projects/spring-framework/blob/885f6dbab94712fa76545276058a62216e17881e/spring-core/src/main/java/org/springframework/util/ConcurrentLruCache.java) was extracted from `MimeTypeUtils` for use in `NamedParameterJdbcTemplate` to improve its concurrent performance (#24197). Unfortunately, the original logic using a  synchronized, bounded `LinkedHashMap` is faster than this new one. If the cache reaches capacity then this change introduced in 5.3.0 only exacerbates the problem.  `ConcurrentLruCache` is implemented as a combination of a read/write lock, `ConcurrentHashMap`, and `ConcurrentLinkedDeque`. If the cache is under capacity then it performs only the map read, which makes it incredibly fast. However once it has reached capacity then it maintains the LRU eviction order by removing and adding the key to the queue, which provides access order. Thus, the tail is the MRU key and searching is an O(n) scan. This is performed under the read lock for exclusive access on a cache write, which would evict an entry. I am not sure if the read/write lock is necessary and it might be replaced with an exclusive lock on the write path only though perhaps was added only for pragmatic concerns as a failsafe.  This design has many problems that leads to poor performance: 1. The O(n) scan of the queue assumes a small cache if being accessed frequently.  2. A read/write lock is more expensive than an exclusive lock, often built on top of one, because it has to manage more complex state. This type of lock is reasonable when the critical section is very expensive, e.g. I/O, but is a poor choice for short, fast critical sections. 3. As LRU reorders the key to the tail of the queue on every access, that becomes a single point of contention. This means that fundamentally the performance will be limited by how fast entries can be appended to the tail, and is made worse with contention and bus traffic when using a lock-free algorithm.  Caches typically follow a Zipfian distribution (power-law), hence hot and cold entries. In a JMH benchmark with that distribution and a full cache, I observed **~270,000 reads/s** with 8 threads on a 4-core SMT laptop. In comparison, a synchronized LinkedHashMap in LRU order performs at **10-11M reads/s**, a 40x speedup. If #24197 is an observed bottleneck, then that problem still exists and was likely made worse.  The approach that I use in my caches (ConcurrentLinkedHashMap, Guava, Caffeine) is to amortize the lock penalty. Instead of trying to make LRU thread-safe, the work is enqueued into a buffer and replayed under the lock in batches. This allows readers to be penalized for the cost of appending to the buffer, where multiple buffers spreads out these writes to avoid contention. The replay is a simple tryLock that, if acquired, drains the buffer to apply the cheap LRU reordering operations. That approach can easily raise the throughput to **100M+ reads/s**.  For a simple cache to embed, you might consider including [ConcurrentLinkedHashMap](https://github.com/ben-manes/concurrentlinkedhashmap). That was used broadly during its lifetime and small enough to often be copied elsewhere. Groovy enhanced their [copy](https://github.com/apache/groovy/tree/master/src/main/java/org/apache/groovy/util/concurrent/concurrentlinkedhashmap) to support Java 8 compute methods, so that may be an attractive option, which was subsequently embedded by micronaut for similar use-cases. I can't speak to the Groovy variant, but the original has proven to be robust and easily hackable so there should be a low maintenance burden if either is used. Embedding avoids the dependency and a lot of projects, like mssql-jdbc, seem to have preferred doing that.","open","type: enhancement,","ben-manes","2020-12-27T22:09:44Z","2021-11-24T20:07:20Z"
"","26103","@rstoyanchev : RequestDispatcher forward not working with OncePerRequestFilter with Spring boot 2.3.* version but working fine till 2.2.10","@rstoyanchev  Don't you think it's a kind of hack we are having in the code?  What if we make it somehow configurable for the dispatcher types??  _Originally posted by @hakuna16 in https://github.com/spring-projects/spring-framework/issues/25816#issuecomment-728882509_","closed","status: duplicate,","hakuna16","2020-11-17T12:03:54Z","2020-11-17T17:09:44Z"
"","26632","JDBC DataSource decoration capability","@marcingrzejszczak @shakuzen and myself had discussions about providing better observability support for our users. One part of this effort is the ability of decorating DataSources so that other Spring components (e.g.: Sleuth) or the users themselves can build on top of this feature and have better insights to their DB integration.  At the moment, Spring Cloud Sleuth does not support JDBC instrumentation out of the box. We would like to use this decoration feature to instrument JDBC using third party libraries like P6Spy or Datasource Proxy. They can work with the default tracer (Brave) implementation of Sleuth so from the high-level perspective the JDBC instrumentation could look like: - Spring Framework: provides the ability to add decorators to JDBC DataSources _(the issue is about this decoration capability)_ - Spring Boot: provides auto-configuration so that JDBC DataSources are decorated if there are decorators available - Spring Cloud Sleuth: provides decorators and auto-configuration for JDBC proxy libraries like P6Spy/Datasource Proxy   The benefit for the users is getting distributed tracing out-of-the-box for JDBC using Sleuth and the ability to decorate their datasources however they want without the need to add Sleuth.  There is a connected issue: https://github.com/spring-projects/spring-boot/issues/25032 and an existing project, [spring-boot-data-source-decorator](https://github.com/gavlyukovskiy/spring-boot-data-source-decorator), maintained by @gavlyukovskiy. One way to provide better observability support is merging different parts of spring-boot-data-source-decorator into the various Spring projects (for Spring Framework, this would mean the decorator part).","open","in: data,","jonatan-ivanov","2021-03-02T21:06:57Z","2021-11-10T11:38:10Z"
"","25976","Incorrect http response for a request using the Range header for pre-compressed resources","**What happened:** I use serving pre-compressed resources (spring.resources.chain.compressed), index.html is also compressed. I found that Facebook Sharing Debugger (https://developers.facebook.com/tools/debug/) doesn't work for my website.  The Facebook Crawler (https://developers.facebook.com/docs/sharing/webmasters/crawler) sends the following request: ```json ""request"" : {   ""method"" : ""GET"",   ""uri"" : ""https://example.com"",   ""headers"" : {     ""host"" : [ ""example.com"" ],     ""range"" : [ ""bytes=0-524287"" ],     ""x-forwarded-for"" : [ ""0.0.0.0"" ],     ""accept-encoding"" : [ ""deflate, gzip"" ],     ""accept"" : [ ""*/*"" ],     ""user-agent"" : [ ""facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php)"" ]   },   ""remoteAddress"" : null },  ``` Spring boot serves pre-compressed file (index.html.gz), response has the following headers: ```json ""response"" : {   ""status"" : 206,   ""headers"" : {     ""Accept-Ranges"" : [ ""bytes"" ],     ""Content-Range"" : [ ""bytes 0-177/178"" ],     ""Connection"" : [ ""close"" ],     ""Vary"" : [ ""Origin"", ""Access-Control-Request-Method"", ""Access-Control-Request-Headers"" ],     ""Last-Modified"" : [ ""Sun, 25 Oct 2020 20:36:37 GMT"" ],     ""Content-Length"" : [ ""178"" ],     ""Content-Language"" : [ ""en-US"" ],     ""Date"" : [ ""Sun, 25 Oct 2020 20:36:46 GMT"" ],     ""Content-Type"" : [ ""text/html;charset=UTF-8"" ]   } }, ```  In the above scenario server serves a pre-compressed resource, but does not inform about used compression.  **What you expected to happen:** The following headers are included in the response: ```java Vary: Accept-Encoding Content-Encoding: gzip ```  **How to reproduce it:** Reproduction-steps code: https://github.com/180254/spring-boot-issue-23830  _[n] means ""terminal number n""_ [1] $ `mvn clean package` [1] $ `java -jar target/demo-0.0.1-SNAPSHOT.jar` [2] $ `curl -v -H ""Accept-Encoding: gzip""  -H ""Range: bytes=0-1000"" -H ""Connection: close"" -A ""facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php)"" ""http://localhost:8080/"" -o outputfile`  Pay attention to the request&response headers in the curl log and/or visit http://localhost:8080/actuator/httptrace to see http trace.  Check if compression was requested, check if information about compression exist in response. Check if ""outputfile"" contains compressed or uncompressed data.  Reproducing initial problem: Use example above, run it at any public address and use Facebook Sharing Debugger. Facebook Sharing Debugger uses the compressed bytes as a final response. There is no info from server the data should be uncompressed beforehand.  **Anything else we need to know?:** I tried to use the following embedded servers: Tomcat, Jetty, Undertow. There is the same problem for each of them.  **Environment:** Spring Boot 2.3.4.RELEASE Apache Tomcat/9.0.38 Apache Maven 3.6.3 Java version: 11.0.9, vendor: AdoptOpenJDK, runtime: /usr/lib/jvm/adoptopenjdk-11-hotspot-amd64","closed","type: bug,","180254","2020-10-25T22:10:50Z","2020-10-27T11:29:17Z"
"","26717","Custom annotations not working in upgrading from 2.0.8 to spring 2.3.4","Issue is similar to https://stackoverflow.com/questions/60184960/componentscan-does-not-find-own-custom-annotations-after-update-from-spring-boot where the custom annotation is not being read by MetadataReaderFactory in class reader. For previous versions, the annotation was being read by the class reader.  **Affects** : spring-framework 5.2.9,  Is it a known issue or the later versions of spring have fixed it? I tried using 5.3.3 spring framework but the class reader doesnt read the annotation still. Please note that we do not have any Retention policy specified earlier, do we need to add retention policy as runtime to our annotation to make it work? Issue doesnt occur in 5.0.12  ---","closed","status: duplicate,","nandwaniS","2021-03-23T18:08:24Z","2021-03-24T08:43:13Z"
"","26741","webflux sometime slow","i have a service, which invoke a external service and do a query from db, and a insert operation to db,  in normal times， the response is fast,  avg time is about 200ms(the magor cost is invoke external service), and the service is not busy（about ten thousand per day）,although there is no request in time, it always appear slow request, i have deploy the pinpoint, but it can't show any useful information ![image](https://user-images.githubusercontent.com/5616997/112796827-1c0fe100-909d-11eb-9801-ee4ea8fbcee6.png) pinpoint result ![image](https://user-images.githubusercontent.com/5616997/112798755-f33d1b00-909f-11eb-967e-b8497a012933.png) and my server log is ![image](https://user-images.githubusercontent.com/5616997/112798962-4b741d00-90a0-11eb-9580-fa96954513c9.png)  pinpoint's other request is heath check ![image](https://user-images.githubusercontent.com/5616997/112799167-93933f80-90a0-11eb-877e-ab523908d247.png)  my code is here ![image](https://user-images.githubusercontent.com/5616997/112799238-adcd1d80-90a0-11eb-95aa-2acdf022b070.png) wxOauthManager.getOauthResp is a async request to external service  ![image](https://user-images.githubusercontent.com/5616997/112799366-d35a2700-90a0-11eb-9bcd-61bf6cbbf658.png) ![image](https://user-images.githubusercontent.com/5616997/112799987-a5291700-90a1-11eb-9b46-cc8cacade1c7.png) loginService.getOauthLoginUser is a db query, done in 3ms redis op is async use lettuce, final i log the request, it wrap an event post to application event listener, and async execute it **Affects:** \ spring version: 5.3.3 ---","closed","for: stackoverflow,","cjdxhjj","2021-03-29T07:13:54Z","2021-04-02T07:21:17Z"
"","26585","BridgeMethodResolver#isBridgeMethodFor return incorrect result for kotlin code in certain circumstance","**Affects:** v5.3.4 ---   In kotlin, non-nullable Int is compiled to java primitive type int, this cause the condition `candidateParameter.equals(genericParameter.toClass()` always evaluates to `false`. so `org.springframework.core.BridgeMethodResolver#findBridgedMethod` fails to find the correct bridge method.  ![screenshot1](https://user-images.githubusercontent.com/16322831/108648713-e2c0e000-74f6-11eb-9e64-7aba5467c832.png)  ```kotlin import org.springframework.stereotype.Repository import org.springframework.transaction.annotation.Transactional  interface GenericInterface {     fun delete(id: ID) }  abstract class AbstractGenericClass : GenericInterface {     override fun delete(id: ID) {     } }  @Repository class GenericRepository : AbstractGenericClass() {     @Transactional     override fun delete(             id: Int     ) {         error(""gotcha"")     } } ```  the above ""GenericRepository"" is compiled to  ```java @Repository @Metadata(    mv = {1, 4, 0},    bv = {1, 0, 3},    k = 1,    d1 = {""\u0000\u0018\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0010\b\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0002\b\u0002\b\u0017\u0018\u00002\b\u0012\u0004\u0012\u00020\u00020\u0001B\u0005¢\u0006\u0002\u0010\u0003J\u0010\u0010\u0004\u001a\u00020\u00052\u0006\u0010\u0006\u001a\u00020\u0002H\u0017¨\u0006\u0007""},    d2 = {""Lcom/cpvsn/crud/demo/feat/generic/GenericRepository;"", ""Lcom/cpvsn/crud/demo/feat/generic/AbstractGenericClass;"", """", ""()V"", ""delete"", """", ""id"", ""crud-kit.crud-kit-demo.main""} ) public class GenericRepository extends AbstractGenericClass {    @Transactional    public void delete(int id) {       String var2 = ""gotcha"";       boolean var3 = false;       throw (Throwable)(new IllegalStateException(var2.toString()));    }     // $FF: synthetic method    // $FF: bridge method    public void delete(Object var1) {       this.delete(((Number)var1).intValue());    } }  ```  Due to this issue, the `@Transactional` on `delete(id: Int)` method have no effects at all. I'm not sure if this project is expected to be compatible with Kotlin code. If it is, then this is a bug, I think I can try to submit a PR to fix it.","closed","in: core,","noob9527","2021-02-22T02:24:10Z","2021-04-01T14:15:39Z"
"","26793","Fix Javadoc in AcceptHeaderLocaleResolver","**Affects:** spring-webmvc 5.1.6.RELEASE  ---  org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver.setDefaultLocale, line 74  ```java // ... // By default this is not set in which case when there is ""Accept-Language"" header  // ... public void setDefaultLocale(@Nullable Locale defaultLocale) { ... } ``` I think it means ""when there is ***no*** 'Accept-Language' header"".","closed","type: task,","m1stake","2021-04-13T09:10:32Z","2021-04-13T09:37:53Z"
"","26550","TransactionAspectSupport: perform a commit on mono cancelation","**Affects:** spring-tx 5.2.8.RELEASE  ---   Actually, The TransactionAspectSupport commit the transaction on a mono cancel. This can happen on a timeout on an HTTP call.  This is problematic if the treatment perform multiple insertions, If we have two tables `customer` and `address` and the following treatment:     - insert the customer    - insert the address  If the mono is canceled between the two operations, the commit is performed on a partial transaction.  This is not an intuitive behavior for a transaction.   Can we update the transaction behaviour to perform a rollback in case of cancel?","closed","status: duplicate,","deblockt","2021-02-15T13:47:49Z","2021-02-15T13:52:37Z"
"","26789","CronExpression.parse should recognize Scheduled.CRON_DISABLED","**Affects:** spring-context:5.3.4  ---   Hi...  IMHO   ````Java  org.springframework.scheduling.support.CronExpression.parse(    org.springframework.scheduling.annotation.Scheduled.CRON_DISABLED); ```` should not throw java.lang.IllegalArgumentException.","closed","status: feedback-provided,","schapsl","2021-04-12T09:26:58Z","2021-04-12T14:01:06Z"
"","26744","Scheduling a task that runs once a day results in March 28 being skipped","**Affects:** Spring Framework 5.3.1  ---  **Problem**: Scheduled task marked with the annotation `@Scheduled(cron = """"0 0 9 * * *"""", zone = ""Europe/Amsterdam"")` did not run on March 28  **Expected behaviour**: The scheduled task should have run on March 28  **How to reproduce**: The bug seems to be related to the class `CronExpression` introduced in version 5.3 ``` ZonedDateTime current = ZonedDateTime.of(LocalDateTime.parse(""2021-03-27T09:00:00""), ZoneId.of(""Europe/Amsterdam"")); CronExpression cronExpression = CronExpression.parse(""0 0 9 * * *""); ZonedDateTime next = cronExpression.next(current); ``` In this case the value returned by `cronExpression.next()` is `2021-03-29T09:00:00` instead of the expected `2021-03-28T09:00:00`","closed","in: core,","AlexCovizzi","2021-03-30T08:49:23Z","2022-02-11T13:18:07Z"
"","26591","@Transactional rollback instead of commit with reactive transactions","**Affects:** Spring Boot v2.4.3, Spring v5.3.4  ---   `@Transactional` annotation rollback transaction instead of commit it.   I have the following method: ``` java @Transactional public Publisher doSomething() {       final Mono result = myRepo.getById()            .flatMap(result -> myRepo.save().thenReturn(result));       return result; } ```  If I call this methods like that:  ``` java Mono.from(service.doSomething()) ```  The transaction is rollbacked instead of committed.   If think that is due to this PR https://github.com/spring-projects/spring-framework/pull/25256/files  what I understand, I that:    1. the transaction annotation transform my Mono to a Flux    2. the `Mono.from(service.doSomething()).then()` transform the Flux to a Mono    3. So When the flux return it's first value the `Mono.from` cancel the transaction Flux and so it's rollbacked  I have a work around by removing the Mono.from, but I'm afraid of other possible issues","closed","status: invalid,","deblockt","2021-02-22T17:34:07Z","2021-02-23T11:42:36Z"
"","26774","Properties resolving in incorrect order during test when using @ActiveProfiles and properties file in dependent jar","**Affects:** Spring Boot 2.4.4  ---   Minimum viable reproducible example can be found here https://github.com/alextadams88/spring-issue-26774  I am running a @SpringBootTest with @ActiveProfiles to define which profile to use during the test. I have a property in the profile specified by @ActiveProfiles which is set to `false`.   Simultaneously, I have a jar in my dependency tree which includes an application.yml file. In this application.yml file, the same property is set to `true`. I am finding that, when running the test, Spring is using the property from the `application.yml` file in the jar (""true""), rather than the property from the profile defined in my @ActiveProfiles (""false"").   Per the documentation in https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config, this is not the expected behavior:   > Config data files are considered in the following order: >  > 1.Application properties packaged inside your jar (application.properties and YAML variants). > 2.Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants). > 3.Application properties outside of your packaged jar (application.properties and YAML variants). > 4.Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants).  I should expect that my properties defined in @ActiveProfiles would fall under 1, and the configuration file in the dependency jar to fall under 3, so the property in my @ActiveProfile should be used.  Test class:  ![image](https://user-images.githubusercontent.com/28212242/113940400-62ff8400-97cb-11eb-843d-935acc84a32e.png)  My file application-it.yml contains the property `data-warehouse:   enabled: false`     My classpath contains a jar file kafka-producer-1.0.9-rc.1e827024.jar, which contains application.yml with the property  `data-warehouse:   enabled: false`  When debugging, I find that the property with the incorrect value is being used:  ![image](https://user-images.githubusercontent.com/28212242/113940301-3d727a80-97cb-11eb-9f96-61d808862c7c.png)  The origin for this property is from the kafka-producer-1.0.9-rc.1e827024.jar file:  ![image](https://user-images.githubusercontent.com/28212242/113939552-254e2b80-97ca-11eb-9273-40d3e0ef1899.png)  However, I do see that my application-it.yml file is indeed being picked up, simply just not prioritized:  ![image](https://user-images.githubusercontent.com/28212242/113939680-49117180-97ca-11eb-9694-e382246457f7.png)  I am unsure if the order of the property sources in this list is an indication of the resolution order, but if so, this demonstrates that the wrong resolution order is being used.   Minimum viable reproducible example can be found here https://github.com/alextadams88/spring-issue-26774  EDIT: After playing around with my minimum example for a bit, it is revealed that the issue disappears if the configuration in the dependent library is moved out of the ""resources/config/"" folder, and directly into the ""resources/"" folder. Looking through the documentation a bit more, I find the following:  > Spring Boot will automatically find and load application.properties and application.yaml files from the following locations when your application starts: > 1. The classpath root > 2. The classpath /config package > 3. The current directory > 4. The /config subdirectory in the current directory > 5. Immediate child directories of the /config subdirectory  > The list is ordered by precedence (with values from lower items overriding earlier ones). Documents from the loaded files are added as PropertySources to the Spring Environment.  As my configuration is the in the /config package, this explains the issue. Closing this ticket.","closed","status: invalid,","alextadams88","2021-04-07T21:56:49Z","2021-04-08T06:30:08Z"
"","26858","Support MySQL safe updates mode in MySQLMaxValueIncrementer","**Affects:** all  ---   Hi~    I found a small problem while using Spring Batch. I , it would be better that spring-jdbc's `MySQLMaxValueIncrementer`  supports [MYSQL safe_update_mode (or safe mode)](https://dev.mysql.com/doc/refman/8.0/en/mysql-tips.html#safe-updates)  ## Mysql safe_update Mode First if we have a MySQL database instance with global option: ```sql SET global sql_safe_updates=1 ``` Then the 'Incrementer' will fail: ``` Exception in thread ""main"" org.springframework.dao.DataAccessResourceFailureException:  Could not increment value for tab_sequence sequence table;  nested exception is java.sql.SQLException:  You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.  	at org.springframework.jdbc.support.incrementer.MySQLMaxValueIncrementer.getNextKey(MySQLMaxValueIncrementer.java:148) 	at org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer.nextIntValue(AbstractDataFieldMaxValueIncrementer.java:123) ```  ## Code from spring-jdbc https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-jdbc/src/main/java/org/springframework/jdbc/support/incrementer/MySQLMaxValueIncrementer.java#L143-L144  As [Mysql Reference](https://dev.mysql.com/doc/refman/8.0/en/mysql-tips.html#safe-updates) says: > Enabling sql_safe_updates causes UPDATE and DELETE statements to produce an error if they do not specify a key constraint in the WHERE clause, or provide a LIMIT clause, or both.  ## Solution  If we add `limit 1`, then this statement will success. ```java stmt.executeUpdate(""update "" + getIncrementerName() + "" set "" + columnName + "" = last_insert_id("" + columnName + "" + "" + getCacheSize() + "") limit 1""); ```  or turn off sql_safe_updates (may be ignored by some dba middleware ) ```java stmt.execute(""SET sql_safe_updates=0;""); stmt.executeUpdate(""update "" + getIncrementerName() + "" set "" + columnName + "" = last_insert_id("" + columnName + "" + "" + getCacheSize() + "")""); ``` or  ```java stmt.executeUpdate(""update "" + getIncrementerName() + "" set "" + columnName + "" = last_insert_id("" + columnName + "" + "" + getCacheSize() + "") where id >=0 ""); ```  ## Spring Batch Here are some schema in Spring Batch project.  https://github.com/spring-projects/spring-batch/blob/master/spring-batch-core/src/main/resources/org/springframework/batch/core/schema-mysql.sql  for example ```SQL CREATE TABLE BATCH_STEP_EXECUTION_SEQ ( 	ID BIGINT NOT NULL, 	UNIQUE_KEY CHAR(1) NOT NULL, 	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY) ) ENGINE=InnoDB;  ``` The `ID` column neither is a primary key, nor a indexed column. The safe_update_mode will raise an exception.  ## Appendix A quick test code: ```java @SpringBootApplication public class JdbcSafemodeApplication {  	@Bean 	public JdbcTemplate JdbcTemplate(DataSource dataSource) { 		return new JdbcTemplate(dataSource); 	}  	@Bean 	public MySQLMaxValueIncrementer incrementer(DataSource dataSource) { 		return new MySQLMaxValueIncrementer(dataSource, ""tab_sequence"", ""value""); 	}  	public static void main(String[] args) { 		ConfigurableApplicationContext context = SpringApplication.run(JdbcSafemodeApplication.class, args); 		JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);  //		jdbcTemplate.execute(""insert into tab_sequence values(0);"");  //		MySQLMaxValueIncrementer incrementer = context.getBean(MySQLMaxValueIncrementer.class); //		int i = incrementer.nextIntValue();  		jdbcTemplate.execute(""SET sql_safe_updates=0;""); 		jdbcTemplate.execute(""update tab_sequence set value = 3;""); 	} } ```","closed","type: enhancement,","slankka","2021-04-24T15:08:10Z","2021-04-29T13:39:31Z"
"","26459","No way to affect response when unhandled exceptions thrown from ForwardedHeaderTransformer","**Affects:** \spring-web:5.2.12  ---   We are running a service behind a reverse proxy and have set *server.forward-headers-strategy=framework*. This then registers a *ForwardedHeaderTransformer* bean. When an exception is thrown from that class it bubbles up the stack and the connection is eventually closed without modifying/sending a response at all. The net result is that the reverse proxy never gets a response and will treat it as a 502 Bad Gateway which is less than ideal.   The exception we are seeing is being thrown in the *ForwardedHeaderTransformer.apply(ServerHttpRequest request)* method when the *UriCompenentsBuilder.build(true)* is called. Ultimately, the URI was not properly encoded which is how we discovered the issue. We are fixing our end to better ensure it is encoded correctly when we build the URI to have the user follow, but obviously we can't prevent users from sending bad request in the first place. Also, any unhandled exception that could go wrong in the *ForwardedHeaderTransformer* or a developer's custom implementation would still result in the connection being closed without an opportunity to write a response. Looking at how this is called from *HttpWebHandlerAdapter.handle(ServerHttpRequest request, ServerHttpResponse response)*, it seems the expectation is that nothing could ever go wrong in applying the transformer.  The preference would be that we could handle the exception, log it and then return a proper response code with a message indicating that the URI was malformed. I would think this could be achieved by throwing an exception such as *ResponseStatusException*, or a custom exception with the *@ResponseStatus* annotation present. This was attempted with no affect. Again, with how the exception handling is the only option is the exception is bubbled up until eventually the connection/channel is closed without modifying the response in *HttpServerHandle.onStateChanged(Connection connection, State newState)*. Alternatively, the *ServerHttpResponse* could be exposed to the transformer but I could see that not being a great idea from a design perspective.","closed","type: enhancement,","kkroner8451","2021-01-27T20:22:48Z","2021-01-28T20:46:07Z"
"","26841","@NotNull annotation is not enforced for @RequestParam when parameter is passed as an empty value","**Affects:** \Spring Boot v2.3.9.RELEASE, Spring v5.2.13.RELEASE ---  When annotating a parameter of type Long of a controller with @NotNull for a @Get method and passing the parameter as empty value, the parameter is received as null.  ``` @RestController @RequestMapping(""testController1"") public class TestController {      @GetMapping(""testMethod1"")     public Long testMethod(@RequestParam @NotNull Long param1) {         assertNotNull(param1);         return param1;     }  } ```  Getting 400 when requesting http://localhost:8082/testController1/testMethod1 Getting 200 when requesting http://localhost:8082/testController1/testMethod1?param1=555 Getting 500 when requesting http://localhost:8082/testController1/testMethod1?param1=¶m2=bla  Expecting to 400 for the last case too.","closed","in: web,","selalerercapitolis","2021-04-21T14:34:14Z","2022-06-22T08:56:43Z"
"","26623","ContentCachingRequestWrapper changes order of parameters","**Affects:** \5.3.3  ---   When a POST request is made using application/x-www-form-urlencoded and I convert the body to a String, the order of the request parameters is changed because the body is created by `ContentCachingRequestWrapper.writeRequestParametersToCachedContent` rather than the original body. This causes me to be unable to validate requests of this type using a HMAC of the requested content.","closed","","mjaggard","2021-03-01T17:08:56Z","2022-02-18T19:05:36Z"
"","26652","Using @JsonView on RestController method does not seem to use Jackson Mix-Ins","**Affects:** \<5.3.3>  Hi here is my issue: I think I have found a behavior that might not be as expected regarding the use of @JsonView on a controller method. The behavior does not match the bare ` mapper.writerWithView(View.class).writeValueAsString(obj)` one might expect (?).  I am facing issue when using a controller method defined as such: ```java @RestController @RequestMapping(""/api/v1/resources"") class MyController {      @GetMapping     @JsonView(Views.Base.class)     Page list(@ModelAttribute ListParams params, @PageableDefault Pageable paging) {         return service.list(params, paging);     } } ``` Of course `Page` is given as empty object because none of its fields are marked with the `@JsonView(Views.Base.class)`. So I created a Mix-in interface like follows: ```java @JsonView(Views.Base.class) interface PageMixInView extends Page {} ``` and added it using ```java @Configuration public class JacksonConfiguration {      @Bean     Jackson2ObjectMapperBuilderCustomizer addPageViewMixIn() {         return builder -> {             builder.mixIn(Page.class, PageViewMixIn.class);         };     } } ```  I have implemented the following tests to demonstrate that it works:  ```java public class MixInDebuggingTest {     @Nested     class UnitTest {         @Test         void shouldSucceedWithMixIn() throws JsonProcessingException {             ObjectMapper mapper = new ObjectMapper();             mapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);             mapper.addMixIn(Page.class, PageViewMixIn.class);              Page page = generateTestData();             String jsonStr = mapper                     .writerWithView(Views.Base.class)                     .withDefaultPrettyPrinter()                     .writeValueAsString(page);             assertThat(jsonStr, hasJsonPath(""$.content[0].value"", is(""1"")));             assertThat(jsonStr, hasJsonPath(""$.content[1].value"", is(""2"")));             assertThat(jsonStr, hasJsonPath(""$.content[2].value"", is(""3"")));             assertThat(jsonStr, hasJsonPath(""$.totalPages"", is(1)));             assertThat(jsonStr, hasJsonPath(""$.totalElements"", is(3)));             assertThat(jsonStr, hasJsonPath(""$.last"", is(true)));             assertThat(jsonStr, hasJsonPath(""$.size"", is(10)));             assertThat(jsonStr, hasJsonPath(""$.number"", is(0)));             assertThat(jsonStr, hasJsonPath(""$.numberOfElements"", is(3)));             assertThat(jsonStr, hasJsonPath(""$.first"", is(true)));             assertThat(jsonStr, hasJsonPath(""$.empty"", is(false)));         }          @Test         void shouldFailWithoutMixIn() throws JsonProcessingException {             ObjectMapper mapper = new ObjectMapper();             mapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);              Page page = generateTestData();             String jsonStr = mapper                     .writerWithView(Views.Base.class)                     .withDefaultPrettyPrinter()                     .writeValueAsString(page);             assertThat(jsonStr, not(hasJsonPath(""$.content[0].value"")));             assertThat(jsonStr, not(hasJsonPath(""$.content[1].value"")));             assertThat(jsonStr, not(hasJsonPath(""$.content[2].value"")));             assertThat(jsonStr, not(hasJsonPath(""$.totalPages"")));             assertThat(jsonStr, not(hasJsonPath(""$.totalElements"")));             assertThat(jsonStr, not(hasJsonPath(""$.last"")));             assertThat(jsonStr, not(hasJsonPath(""$.size"")));             assertThat(jsonStr, not(hasJsonPath(""$.number"")));             assertThat(jsonStr, not(hasJsonPath(""$.numberOfElements"")));             assertThat(jsonStr, not(hasJsonPath(""$.first"")));             assertThat(jsonStr, not(hasJsonPath(""$.empty"")));         }     }      @Nested     @SpringBootTest     class IntegrationTest{         @Autowired         ObjectMapper mapper;         @Test         void shouldBeUsingMixin() throws JsonProcessingException {             Page page = generateTestData();             String jsonStr = mapper                     .writerWithView(Views.Base.class)                     .withDefaultPrettyPrinter()                     .writeValueAsString(page);              assertThat(jsonStr, hasJsonPath(""$.content[0].value"", is(""1"")));             assertThat(jsonStr, hasJsonPath(""$.content[1].value"", is(""2"")));             assertThat(jsonStr, hasJsonPath(""$.content[2].value"", is(""3"")));             assertThat(jsonStr, hasJsonPath(""$.totalPages"", is(1)));             assertThat(jsonStr, hasJsonPath(""$.totalElements"", is(3)));             assertThat(jsonStr, hasJsonPath(""$.last"", is(true)));             assertThat(jsonStr, hasJsonPath(""$.size"", is(10)));             assertThat(jsonStr, hasJsonPath(""$.number"", is(0)));             assertThat(jsonStr, hasJsonPath(""$.numberOfElements"", is(3)));             assertThat(jsonStr, hasJsonPath(""$.first"", is(true)));             assertThat(jsonStr, hasJsonPath(""$.empty"", is(false)));         }     }          @FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)     @RequiredArgsConstructor(staticName = ""of"")     @JsonView(Views.Base.class)     @Getter     public static class Obj {         String value;     }      private Page generateTestData() {         return new PageImpl<>(                 Arrays.asList(Obj.of(""1""), Obj.of(""2""), Obj.of(""3"")),                 PageRequest.of(0, 10), 3);     } } ``` **All the tests written above work**.  But MockMVC tests and testing manually by `cURL`ing my api do not work. Here is an example on how I test it: ```java @SpringBootTest @AutoConfigureMockMvc class ApiIntegrationTest {         @Autowired MockMvc mockMvc;                  @Test         void testDefaultBehaviour() throws Exception {             mockMvc.perform(get(""/api/v1/resources""))                     .andExpect(status().isOk())                     .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))                     .andExpect(contentIsValidPagedResponseOfResources());         }                  private ResultMatcher contentIsValidPagedResponseOfCredentials() {             return ResultMatcher.matchAll(                     jsonPath(""$.content[*].value"").value(Every.everyItem(Is.isA(String.class))));         } } ``` This last tests **fails**. And the body is an empty json object `{}`, response code is 200. It fails on the jsonPath conditions.","closed","status: feedback-reminder,","le-doude","2021-03-09T04:38:57Z","2022-02-18T19:05:36Z"
"","26803","Question regarding `AspectJExpressionPointcut#matches(Method, Class, boolean)`","**Affects:** \<4.3.9.RELEASE>   There is some comments In source code of the function (`org.springframework.aop.aspectj.AspectJExpressionPointcut#matches(java.lang.reflect.Method, java.lang.Class, boolean)`),  ```java // A match test returned maybe - if there are any subtype sensitive variables // involved in the test (this, target, at_this, at_target, at_annotation) then // we say this is not a match as in Spring there will never be a different // runtime subtype. ```  Is this mean that if there is no subtype sensitive variables involved in the test (this, target, at_this, at_target, at_annotation) then *you* say it is match. I think this will be a big risk while judging wheather method match aspect. I have meet the problem before: https://stackoverflow.com/questions/67070980/i-want-to-make-a-aspect-which-will-take-effect-when-i-add-a-annotation-on-the-ty  so i read the source code and locate to the function `org.springframework.aop.aspectj.AspectJExpressionPointcut#matches(java.lang.reflect.Method, java.lang.Class, boolean)`.  just tell me something about this ,thanks a lot.","closed","","SammyXue","2021-04-14T10:57:00Z","2022-02-18T19:05:38Z"
"","26724","mvcweb  ServletServerHttpResponse:getFirst  in tomcat bug","**Affects:** \ webmvc  5.3.3 first:      response.setHeader(""Content-Type"",""application/json""); in Filter. after:  ServletServerHttpResponse:getFirst() can't not get Header when headername is  ""Content-Type"".  because， when  response.setHeader(""Content-Type"",""application/json"") ，tomcat response have not add Content-Type to header, it's only set contentType,so  ServletServerHttpResponse:getFirst() can't not get Header when headername is  ""Content-Type""  tomcat setHeader code: @Override     public void setHeader(String name, String value) {          if (name == null || name.length() == 0 || value == null) {             return;         }          if (isCommitted()) {             return;         }          // Ignore any call from an included servlet         if (included) {             return;         }          char cc=name.charAt(0);         if (cc=='C' || cc=='c') {             if (checkSpecialHeader(name, value)) {                 return;             }         }          getCoyoteResponse().setHeader(name, value);     }    issue fix code:            if value is null from super.getFirst,then to servletResponse.getContentType();               @Override 		@Nullable 		public String getFirst(String headerName) { 			if (headerName.equalsIgnoreCase(CONTENT_TYPE)) { 				// Content-Type is written as an override so check super first 				String value = super.getFirst(headerName); 				if (value == null) { 					value = servletResponse.getContentType(); 				}  				return (value != null ? value : servletResponse.getHeader(headerName)); 			} 			else { 				String value = servletResponse.getHeader(headerName); 				return (value != null ? value : super.getFirst(headerName)); 			} 		}   ---","open","in: web,","ldkjdk","2021-03-25T06:50:54Z","2021-11-08T11:41:48Z"
"","26790","Make sure file storage directory exists before usage in DefaultPartHttpMessageReader","**Affects:** \ 5.3.4 ---  when i upload a file, it throw an exception  ``` java.io.UncheckedIOException: Could not create temp file in /tmp/spring-multipart 	at org.springframework.http.codec.multipart.PartGenerator$CreateFileState.createFileState(PartGenerator.java:588) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ com.nxin.passport.application.support.filter.FormDataParserFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ com.nxin.passport.application.support.filter.UrlRewriteFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ HTTP POST ""/user/uploadPhoto"" [ExceptionHandlingWebHandler] Stack trace: 		at org.springframework.http.codec.multipart.PartGenerator$CreateFileState.createFileState(PartGenerator.java:588) 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1789) 		at reactor.core.publisher.MonoCacheTime.subscribeOrReturn(MonoCacheTime.java:142) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4031) 		at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:126) 		at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84) 		at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37) 		at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 		at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) 		at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 		at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 		at java.base/java.lang.Thread.run(Thread.java:834) Caused by: java.nio.file.NoSuchFileException: /tmp/spring-multipart/8497015949572241043.multipart 	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92) 	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111) 	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116) 	at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215) 	at java.base/java.nio.file.Files.newByteChannel(Files.java:370) 	at java.base/java.nio.file.Files.createFile(Files.java:647) 	at java.base/java.nio.file.TempFileHelper.create(TempFileHelper.java:137) 	at java.base/java.nio.file.TempFileHelper.createTempFile(TempFileHelper.java:160) 	at java.base/java.nio.file.Files.createTempFile(Files.java:867) 	at org.springframework.http.codec.multipart.PartGenerator$CreateFileState.createFileState(PartGenerator.java:580) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1789) 	at reactor.core.publisher.MonoCacheTime.subscribeOrReturn(MonoCacheTime.java:142) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4031) 	at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:126) 	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84) 	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.lang.Thread.run(Thread.java:834) ```  i found DefaultPartHttpMessageReader has a fileStorageDirectory property control the upload temp directory, it init as system temp dir, in linux, it is /tmp/spring-multipart, but os may sometimes remove the files in /tmp, when the spring-multipart is remove, then the upload action will fail, because the directory only init once at startup,   ![image](https://user-images.githubusercontent.com/5616997/114377903-be5db780-9bb9-11eb-9819-e9d286cc2553.png)  i have found the way to customize the path, ![image](https://user-images.githubusercontent.com/5616997/114378082-eea55600-9bb9-11eb-8897-c8acd652ce4a.png)  but it did not invoke in any place  ![image](https://user-images.githubusercontent.com/5616997/114378217-14325f80-9bba-11eb-8a03-82a24c9b6cee.png)  please provide some way to config the path, so i can set a other place to store the tepm data to avoid the issure, the spring mvc config way is below  ![image](https://user-images.githubusercontent.com/5616997/114378476-5360b080-9bba-11eb-89ea-b3f9cd63454e.png)  can you provide a similarity one in webflux?","closed","type: enhancement,","cjdxhjj","2021-04-12T10:10:49Z","2021-04-12T15:29:25Z"
"","26801","webflux cpu useage is slow grow","**Affects:** \ 2.3.4 ---  link to https://github.com/spring-projects/spring-framework/issues/26741  my app sometimes very slow, even though there is almost very few request, so i watch my app use jprofile, after a long time monitor， i have found the cpu usage is very strange， it alway grow when it reach the 100% usage, and down to 0 again and again.  ![image](https://user-images.githubusercontent.com/5616997/114674881-42d74400-9d3a-11eb-9048-c08acb725571.png)  ![image](https://user-images.githubusercontent.com/5616997/114675010-60a4a900-9d3a-11eb-882a-de24c6bd8c60.png)  ![image](https://user-images.githubusercontent.com/5616997/114675115-7c0fb400-9d3a-11eb-865e-46fc6b70122f.png)  ![image](https://user-images.githubusercontent.com/5616997/114675170-87fb7600-9d3a-11eb-992f-3cf1d9020fc3.png)  mem usage ![image](https://user-images.githubusercontent.com/5616997/114675451-d27cf280-9d3a-11eb-8303-c072b6453905.png)   ![image](https://user-images.githubusercontent.com/5616997/114675537-ede7fd80-9d3a-11eb-858d-5db7857877e0.png)  it report that the cpu usage from 0 to 100 is more often after time elapse。  is there any suggest for me?","closed","for: stackoverflow,","cjdxhjj","2021-04-14T08:05:49Z","2021-04-14T10:24:07Z"
"","26514","@Cacheable or @CacheEvict invalid","**Affects:** \ ---  @Cacheable @CacheEvict invalid  ``` @service pubic class TestService {    @Cacheable(cacheNames =""user"",key = ""#userId"")   public User fetchUserById(Long userid) {        return new User();   }    public User fetchCurrentUser() {       return fetchUserById(124L);   }  }  ```  `@Cacheable` is valid, when I invoke `fetchUserById(Long userid)`. `@Cacheable` is invalid, when I invoke `fetchCurrentUser()`.","closed","for: stackoverflow,","panpengfei21","2021-02-06T00:15:56Z","2021-02-06T07:49:28Z"
"","26843","spring-web 5.3.0 FORM submit will cause thread leak","**Affects:** \  Looks like FORM request will cause a thread leak. (/prox//task/ ） In spring-web-5.3.0.jar In DefaultServerWebExchange.java: 	@SuppressWarnings(""unchecked"") 	private static Mono> initFormData(ServerHttpRequest request, 			ServerCodecConfigurer configurer, String logPrefix) {  		try { 			MediaType contentType = request.getHeaders().getContentType(); 			if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(contentType)) { 				return ((HttpMessageReader>) configurer.getReaders().stream() 						.filter(reader -> reader.canRead(FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED)) 						.findFirst() 						.orElseThrow(() -> new IllegalStateException(""No form data HttpMessageReader.""))) 						.readMono(FORM_DATA_TYPE, request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix)) 						.switchIfEmpty(EMPTY_FORM_DATA) 						.cache(); 			} 		} 		catch (InvalidMediaTypeException ex) { 			// Ignore 		} 		return EMPTY_FORM_DATA; 	} when remove those lines, no thread leak occured。  would someone else found the same issue?  ---","closed","status: feedback-provided,","Leedoo","2021-04-22T02:30:45Z","2021-04-28T08:32:52Z"
"","26723","Both @Autowried and @Resource cannot be injected","**Affects:** \  ---  Hello. My project A split out project B, project B introduced part of project A module, and then added B to A to start, and then the following error message appeared.  `org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'kaasPropertyAttrDaoService' is expected to be of type 'com.koalii.kaas.system.service.KaasPropertyAttrDaoService' but was actually of type 'com.koalii.kaas.system.service.KaasPropertyAttrDaoService'`  But in my Application class into the 'KaasPropertyAttrDaoService, can print the object. ` ------   ------ com.koalii.kaas.system.service.KaasPropertyAttrDaoService@6c61bea0`","closed","for: stackoverflow,","puyongqqq","2021-03-25T02:23:16Z","2021-03-26T06:04:36Z"
"","26573","servlert-api-2.5 jar包下的javax.servlet下缺少类","**Affects:** \  ---  ![屏幕截图 2021-02-20 102122](https://user-images.githubusercontent.com/62466008/108580264-bd509c80-7365-11eb-96fe-d28ac0e8b158.png)  在idea上下了源代码就显示DispatcherType类显红，","closed","for: stackoverflow,","1403786495","2021-02-20T02:27:01Z","2021-02-20T09:25:14Z"
"","26479","[Sequence generate]","**Affects:** \  ---   Yesterday, my project generate sequence is sequence in database Today, it generate table for sequence Does any update about generate sequence?","closed","status: invalid,","letanloc1998","2021-01-30T15:14:09Z","2021-01-31T13:30:46Z"
"","26537","What is TransientDataAccessResourceException? I am not understand.","**Affects:** \  ---","closed","for: stackoverflow,","fatiemah","2021-02-11T03:17:37Z","2021-02-11T08:00:05Z"
"","26831","webmvc.fn onError doesn't work with CompletableFuture","**Affects:** 5.3.6  webmvc.fn `onError` doesn't work with `CompletableFuture`. Error handler predicates are never called. Take a look at the code below. error1 scenario shows the problem: application should return an error response with ""error"" body, returns Whitelabel Error Page instead. error2 scenario works fine.  ```java package com.example.demo;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.http.HttpStatus; import org.springframework.web.servlet.function.RouterFunction; import org.springframework.web.servlet.function.ServerResponse;  import java.util.concurrent.CompletableFuture;  import static org.springframework.web.servlet.function.RouterFunctions.route;  @SpringBootApplication public class DemoApplication {      public static void main(String[] args) {         SpringApplication.run(DemoApplication.class, args);     }      @Bean     public RouterFunction routes() {         return route()             .GET(""error1"", request -> {                 CompletableFuture result = CompletableFuture.supplyAsync(                     () -> {                         throwRuntimeException();                         return ""test"";                     }                 );                 return ServerResponse.ok().body(result);             })             .GET(""error2"", request -> {                 throwRuntimeException();                 CompletableFuture result = CompletableFuture.supplyAsync(                     () -> ""test""                 );                 return ServerResponse.ok().body(result);             })             .onError(RuntimeException.class, (throwable, request) ->                 ServerResponse                     .status(HttpStatus.INTERNAL_SERVER_ERROR)                     .body(""error"")             )             .build();     }      private void throwRuntimeException() {         throw new RuntimeException();     }   }   ```   ---","closed","type: bug,","PiotrDudkiewicz-TomTom","2021-04-20T14:56:45Z","2021-04-30T09:47:40Z"
"","26866","Provide control over fallback charset to use in WebClientResponseException","**Affects:** 5.3.6  ---   Web client should throw an WebClientResponseException when http response status is 4xx, which is created by `clientResponse.createException()`, if the error response is JSON string, the media type should be `application/json`, that should decode http response body using UTF-8 encoding by default, but current using ISO-8859-1 for all media types. it causes body field in the generated exception contains malformed characters.  https://github.com/spring-projects/spring-framework/blob/e4a5d2aaa59266b294e155c4fd80b9ef3e852330/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultClientResponse.java#L209-L213","closed","type: bug,","j3r0lin","2021-04-27T10:25:18Z","2021-05-11T15:00:41Z"
"","26663","Blocking calls detected by Blockhound when using bean validation","**Affects:** 5.3.4 Blockhound detects a blocking call inside bean validation. Stacktrace below: ``` reactor.blockhound.BlockingOperationError: Blocking call! java.io.RandomAccessFile#readBytes 	at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[na:na] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ HTTP POST ""/"" [ExceptionHandlingWebHandler] Stack trace: 		at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[na:na] 		at java.base/java.io.RandomAccessFile.read(RandomAccessFile.java:407) ~[na:na] 		at java.base/java.io.RandomAccessFile.readFully(RandomAccessFile.java:471) ~[na:na] 		at java.base/java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1310) ~[na:na] 		at java.base/java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:995) ~[na:na] 		at java.base/java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:1010) ~[na:na] 		at java.base/java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:468) ~[na:na] 		at java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) ~[na:na] 		at java.base/java.io.InputStream.readNBytes(InputStream.java:490) ~[na:na] 		at java.base/java.util.jar.JarFile.getBytes(JarFile.java:807) ~[na:na] 		at java.base/java.util.jar.JarFile.checkForSpecialAttributes(JarFile.java:1007) ~[na:na] 		at java.base/java.util.jar.JarFile.isMultiRelease(JarFile.java:390) ~[na:na] 		at java.base/java.util.jar.JarFile.getEntry(JarFile.java:509) ~[na:na] 		at java.base/sun.net.www.protocol.jar.URLJarFile.getEntry(URLJarFile.java:131) ~[na:na] 		at java.base/sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:135) ~[na:na] 		at java.base/sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:175) ~[na:na] 		at java.base/java.util.ResourceBundle$Control$1.run(ResourceBundle.java:3227) ~[na:na] 		at java.base/java.util.ResourceBundle$Control$1.run(ResourceBundle.java:3216) ~[na:na] 		at java.base/java.security.AccessController.doPrivileged(Native Method) ~[na:na] 		at java.base/java.util.ResourceBundle$Control.newBundle(ResourceBundle.java:3215) ~[na:na] 		at java.base/java.util.ResourceBundle.loadBundle(ResourceBundle.java:1994) ~[na:na] 		at java.base/java.util.ResourceBundle.findBundle(ResourceBundle.java:1776) ~[na:na] 		at java.base/java.util.ResourceBundle.findBundle(ResourceBundle.java:1728) ~[na:na] 		at java.base/java.util.ResourceBundle.findBundle(ResourceBundle.java:1728) ~[na:na] 		at java.base/java.util.ResourceBundle.getBundleImpl(ResourceBundle.java:1662) ~[na:na] 		at java.base/java.util.ResourceBundle.getBundleImpl(ResourceBundle.java:1593) ~[na:na] 		at java.base/java.util.ResourceBundle.getBundle(ResourceBundle.java:1284) ~[na:na] 		at org.hibernate.validator.resourceloading.PlatformResourceBundleLocator.loadBundle(PlatformResourceBundleLocator.java:234) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.resourceloading.PlatformResourceBundleLocator.doGetResourceBundle(PlatformResourceBundleLocator.java:199) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.resourceloading.PlatformResourceBundleLocator.getResourceBundle(PlatformResourceBundleLocator.java:183) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator.resolveMessage(AbstractMessageInterpolator.java:450) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator.lambda$interpolateMessage$0(AbstractMessageInterpolator.java:399) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na] 		at org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator.interpolateMessage(AbstractMessageInterpolator.java:399) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator.interpolate(AbstractMessageInterpolator.java:355) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.springframework.validation.beanvalidation.LocaleContextMessageInterpolator.interpolate(LocaleContextMessageInterpolator.java:51) ~[spring-context-5.3.4.jar:5.3.4] 		at org.hibernate.validator.internal.engine.validationcontext.AbstractValidationContext.interpolate(AbstractValidationContext.java:313) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.validationcontext.AbstractValidationContext.addConstraintFailure(AbstractValidationContext.java:230) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.constraintvalidation.ConstraintTree.validateConstraints(ConstraintTree.java:79) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.metadata.core.MetaConstraint.doValidateConstraint(MetaConstraint.java:130) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.metadata.core.MetaConstraint.validateConstraint(MetaConstraint.java:123) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.ValidatorImpl.validateMetaConstraint(ValidatorImpl.java:555) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.ValidatorImpl.validateConstraintsForSingleDefaultGroupElement(ValidatorImpl.java:518) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.ValidatorImpl.validateConstraintsForDefaultGroup(ValidatorImpl.java:488) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.ValidatorImpl.validateConstraintsForCurrentGroup(ValidatorImpl.java:450) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.ValidatorImpl.validateInContext(ValidatorImpl.java:400) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.hibernate.validator.internal.engine.ValidatorImpl.validate(ValidatorImpl.java:172) ~[hibernate-validator-6.1.7.Final.jar:6.1.7.Final] 		at org.springframework.validation.beanvalidation.SpringValidatorAdapter.validate(SpringValidatorAdapter.java:117) ~[spring-context-5.3.4.jar:5.3.4] 		at org.springframework.boot.autoconfigure.validation.ValidatorAdapter.validate(ValidatorAdapter.java:70) ~[spring-boot-autoconfigure-2.4.3.jar:2.4.3] 		at org.springframework.validation.DataBinder.validate(DataBinder.java:892) ~[spring-context-5.3.4.jar:5.3.4] 		at org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver.validate(AbstractMessageReaderArgumentResolver.java:257) ~[spring-webflux-5.3.4.jar:5.3.4] 		at org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver.lambda$readBody$5(AbstractMessageReaderArgumentResolver.java:197) ~[spring-webflux-5.3.4.jar:5.3.4] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:184) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:295) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:159) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:259) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) ~[reactor-core-3.4.3.jar:3.4.3] 		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:389) ~[reactor-netty-core-1.0.4.jar:1.0.4] 		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:396) ~[reactor-netty-core-1.0.4.jar:1.0.4] 		at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:555) ~[reactor-netty-http-1.0.4.jar:1.0.4] 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.4.jar:1.0.4] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:253) ~[reactor-netty-http-1.0.4.jar:1.0.4] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.59.Final.jar:4.1.59.Final] 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.59.Final.jar:4.1.59.Final] 		at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]  ``` ---","open","in: web,","vlatrovkin","2021-03-11T10:10:06Z","2021-11-08T11:37:32Z"
"","26583","MultipartBodyBuilder doesn't set filename in ContentDisposition when associated to FilePart","**Affects:** 5.3.4  When I create a `MultiValueMap` with a `MultipartBodyBuilder`, the `filename` associated to the `FilePart` I use is not set in the `ContentDisposition`. This was the case in the version Spring Frameworks 5.3.3 and previous.   The commit including this modification is this one: https://github.com/spring-projects/spring-framework/commit/e537844a093d313595e20cc440506fe8b04bc7db by @poutsma.   To make it work, I have to call the `filename` method on the `PartBuilder` manually, like this:  ```kotlin val body = MultipartBodyBuilder().apply {     part(""file"", filePart).filename(filePart.filename()) } .build() ```  The main problem caused is webClient is not treating data provided as a file due to the lack of `filename` in the `ContentDisposition`, especially in the case  `PartGenerator` case, where the `filename` is used as criteria to distinguish `formField` or `file`: https://github.com/spring-projects/spring-framework/blob/dfb7ca733ad309b35040e0027fb7a2f10f3a196a/spring-web/src/main/java/org/springframework/http/codec/multipart/PartGenerator.java#L140  I could provide a PR to add this micro-modification, but I would like this to be validated before ""implementation"", because I can't decide if this behaviour modification have been made on purpose or if this is just a bug.","closed","status: declined,","davinkevin","2021-02-21T17:12:01Z","2021-02-25T19:07:37Z"
"","26736","Support UTF-8 in DefaultPartHttpMessageReader","**Affects:** 5.3.4  After upgrading to Spring boot v2.4.3 and Spring v5.3.4. We noticed that when uploading files via Webflux, the filenames containing accentuated characters (i.e é,à...) end up as a jumbled mess in the destination.  I believe this is due to the fact that Spring now uses **DefaultPartHttpMessageReader that uses ISO_8859_1** (default encoding for multipart/from-data) to read the Part instead of **SynchronossPartHttpMessageReader that defaulted to UTF-8** in case no character encoding was specified .  I have added [nio-multipart-parser](https://github.com/synchronoss/nio-multipart) as a dependency and configured my app as follows :  `    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) { 		SynchronossPartHttpMessageReader partReader = new SynchronossPartHttpMessageReader(); 		MultipartHttpMessageReader multiPartReader = new MultipartHttpMessageReader(partReader); 		configurer.defaultCodecs().multipartReader(multiPartReader); 		configurer.defaultCodecs().jackson2JsonEncoder(new Jackson2JsonEncoder(objectMapper)); 		configurer.defaultCodecs().maxInMemorySize(8 * 1024 * 1024); 	}`  With this configuration the UTF-8 characters are correctly read once again. But we really want to benefit from the new Streaming Mode that comes with DefaultPartHttpMessageReader.  Can DefaultPartHttpMessageReader offer the possibility of overriding the default character encoding ?  I thank you in advance for your reply. ---","closed","type: bug,","saad14092","2021-03-26T16:59:43Z","2021-03-30T09:30:35Z"
"","26704","WebTestClient doesn't set up Request scope","**Affects:** 5.3.3  ---  When I run a test using `WebTestClient.bindToController(myController).build();` I also have to call `RequestContextHolder.setRequestAttributes(attributes, true);` in order to have a request scope available for my application to use. This should be done automatically.","open","status: feedback-provided,","mjaggard","2021-03-19T11:34:18Z","2021-11-08T11:37:32Z"
"","26522","Cannot inject with qualifier into wildcard collection","**Affects:** 5.3.3  ---   Injecting by qualifier doesn't work when target collection is declared as `List`, which is how Kotlin translates `List`.  Reproducer: ```java package example;  import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Component;  import java.util.List;  @Configuration @ComponentScan public class ExampleApplication {     public static void main(String[] args) {         new AnnotationConfigApplicationContext(ExampleApplication.class);     } }  @Component @Qualifier(""EXAMPLE"") class Foo {}  @Component class Bar {     public Bar(         @Qualifier(""EXAMPLE"") List good,         @Qualifier(""EXAMPLE"") List bad     ) {         System.out.println(""Good "" + good);         System.out.println(""Bad: "" + bad);     } } ```  Output: ``` Good [example.Foo@5552768b] Bad: [] ```","closed","in: core,","hban","2021-02-08T09:03:22Z","2022-07-07T03:43:04Z"
"","26521","RSocketRequester delays REQUEST_CHANNEL until first payload","**Affects:** 5.3.3  ---   I'm trying to use RSocket to have two-way streaming between client and server, with server (sometimes) being the first to start sending data. The problem I have is that Spring/RSocket will delay establishing REQUEST_CHANNEL until it has a first payload to sent to server, but I would like it to establish that immediately on subscribe.  Here's a short reproducer. Client subscribes, and than sends initial data with 2 seconds delay. The server handler only gets called after that delay.  ```java package example;  import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.messaging.handler.annotation.MessageMapping; import org.springframework.messaging.rsocket.RSocketRequester; import org.springframework.stereotype.Controller; import reactor.core.publisher.Flux;  import java.net.URI; import java.time.Duration;  @SpringBootApplication public class ExampleApplication {     private static final Logger log = LoggerFactory.getLogger(ExampleApplication.class);      public static void main(String[] args) {         ConfigurableApplicationContext ctx = SpringApplication.run(ExampleApplication.class, args);         RSocketRequester requester = ctx.getBean(RSocketRequester.Builder.class)             .websocket(URI.create(""ws://localhost:8080/rsocket""));          requester.route(""example"")             .data(                 Flux.just(""A"", ""B"")                     .doOnSubscribe(subscription -> log.info(""Client subscribed""))                     .delayElements(Duration.ofSeconds(2))                     .doOnNext(value -> log.info(""Client sending {}"", value))             )             .retrieveFlux(String.class)             .blockLast();          requester.rsocketClient().dispose();         ctx.close();     } }  @Controller class ExampleController {     private static final Logger log = LoggerFactory.getLogger(ExampleController.class);      @MessageMapping(""example"")     Flux example(Flux requests) {         // This should've be logged immediately after ""Client subscribed"", and before ""Client sending""         log.info(""Server received request"");         return requests             .doOnNext(value -> log.info(""Server received {}"", value))             .thenMany(Flux.empty());     } } ```  ```yaml spring:   rsocket:     server:       transport: websocket       mapping-path: /rsocket ``` As a workaround, I'm having client send some dummy data immediately, which server than ignores.","closed","status: declined,","hban","2021-02-08T08:48:42Z","2021-02-09T11:20:54Z"
"","26734","Multiple MessageSource beans not working","**Affects:** 5.3.3  ---  Trying to wrap the default `MessageSource` bean into my custom implementation using: ```     @Bean     @Primary     public MessageSource wrapMessageSource( MessageSource messageSource ) {         return new MyMessageSourceWrapper( messageSource );     } ```  This has no effect because spring is hardwired to get bean with name `MESSAGE_SOURCE_BEAN_NAME`: https://github.com/spring-projects/spring-framework/blob/610de3ae786812f332b71a7453a67afd39834a03/spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java#L771-L772  The `@Primary` bean should be used.","closed","status: declined,","cdalexndr","2021-03-26T11:45:47Z","2021-03-26T12:15:26Z"
"","26695","String-transaction Reactive - error on beforeCommit don't rollback transaction","**Affects:** 5.2.8-RELEASE  ---   It seem that if there are an exception throw by a `TransactionSynchronization.beforeCommit` the transaction is not rollbacked. - If the reactive method return a `Publisher` the transaction is commit - If the reactive method return a `Mono` a rollback is perform but it failed with this error `org.springframework.transaction.IllegalTransactionStateException: Transaction is already completed - do not call commit or rollback more than once per transaction`     I have read the `AbstractReactiveTransactionManager.java` and it seem that there are no exception managed on the `beforeCommit` call.   https://github.com/spring-projects/spring-framework/blob/4982b5fcb9a2ca49edda697918557bdb76e3d282/spring-tx/src/main/java/org/springframework/transaction/reactive/AbstractReactiveTransactionManager.java#L437-L449  It's strange that the `onErrorResume` is called on a `Mono.empty()` instead of the result of the multiple `.then()`  Waiting a better solution, I manage the error on my `beforeCommit` method, and rollback in case of exception","closed","","deblockt","2021-03-17T17:17:46Z","2021-04-02T15:23:01Z"
"","26686","WebClient::toEntity does not support java.util.Optional","**Affects:** 5.2.13.RELEASE / Boot 2.3.9  **What is wrong** Using `java.util.Optional` (either as a class or `ParameterizedTypeReference`) in `toEntity()` of `WebClient` does not return an `Optional.empty()` but `null` when a given http response body is missing.  **How it should work** Empty http response bodies should create an `Optional.empty()` instead of a `null` value.  **Research** I dug into the WebClients logic and noticed that an empty Mono is not processed with the resolved `HttpMessageDecoder` (in my case, Jackson), e.g. in `AbstractJackson2Decoder.decodeToMono` and later hardcodes to `null` in `WebClientUtils.mapToEntity` via some... interesting magic strings :)  **Example**  ``` // given an endpoint is reachable that will return no value as a body: Optional result = webClient.method(method).uri(uri).retrieve().toEntity(Optional.class).block(); // result is null, not Optional.empty ```","open","status: feedback-provided,","roookeee","2021-03-16T12:01:29Z","2021-11-08T11:17:43Z"
"","26482","waitForTasksToCompleteOnShutdown has no effect on tasks created with @Scheduled annotation","**Affects:** 2.4.2 (and likely several previous releases)  **Steps to reproduce:**  1. create a Spring Boot App with Spring Initializr 2. `@EnableScheduling` at application class 3. create `@Scheduled` method  with `Thread.sleep(60000)` 4. set `spring.task.scheduling.shutdown.await-termination=true` in application.properties 5. start the application 6. shutdown the application as soon as it is up  **Expected Behavior** The task should not be interrupted, since `spring.task.scheduling.shutdown.await-termination` sets `waitForTasksToCompleteOnShutdown` to `true` on the TaskScheduler.   **Actual Behavior** The task is interrupted the InterruptetException is logged.   **More Details**  - When I manually schedule a task by something like `scheduler.scheduleWithFixedDelay()`, everything works as expected. - Debugging shows, that my `@Scheduled` task is interrupted by `ScheduledAnnotationBeanPostProcessor.destroy()` - I also noticed, that this might be intentionally. At least it was in 2016. See for instance https://github.com/spring-projects/spring-framework/issues/19633. -  However, it is at least very surprising, that waitForTasksToCompleteOnShutdown has not the excpected effect on tasks that are created in the somehow ""most prominent way"", the `@Scheduled`-Annotation. So IMHO it should either be fixed or documented. - Moreover, the behavior is inconsistent with `@Async` : if I create an `@Async` method and let it sleep for 60000ms while having `spring.task.execution.shutdown.await-termination=true` ,  everythinq works as expected: The async task is not interrupted on shutdown.  Note: When I say ""shutdown"" I mean to stop the application in Spring Tool Suite. In the log I see ""Application shutdown requested."", so I assume I am testing an orderly shutdown here and not some corner case.","open","in: core,","stefanocke","2021-01-31T17:37:09Z","2021-11-10T12:03:14Z"
"","26315","Malformed Content-Type Header in Response","**Affects:**2.X  --- Spring Web produces a malformed Content-Type Response-Header when negotiated Content-Type matches the last element of the media-range part of the Accept-Header.  The issue can be reproduced with https://github.com/spring-guides/gs-serving-web-content :  ``` curl -v http://localhost:8080/greeting -H ""Accept: text/xml,application/xml,application/xhtml+xml,text/html; q=0.9"" > /dev/null  > GET /greeting HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.64.1 > Accept: text/xml,application/xml,application/xhtml+xml,text/html; q=0.9 >  < HTTP/1.1 200  < Content-Type: text/html; q=0.9;charset=UTF-8 < Content-Language: de-DE < Transfer-Encoding: chunked ```  The Content-Type contains a weight wich is not allowed according to https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html. The same request with ""text/html"" moved to any other position except the last one produces a correct result:  ``` curl -v http://localhost:8080/greeting -H ""Accept: text/xml,application/xml,text/html,application/xhtml+xml; q=0.9"" > /dev/null  > GET /greeting HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.64.1 > Accept: text/xml,application/xml,text/html,application/xhtml+xml; q=0.9 >  < HTTP/1.1 200  < Content-Type: text/html;charset=UTF-8 < Content-Language: de-DE < Transfer-Encoding: chunked ```  Browsers seem to handle the malformed header gracefully, but I am running a Spring Application with Server Side Includes behind an Nginx and the response is not scanned for SSIs because of the malformed Content-Type header.","closed","type: bug,","bstenersen","2020-12-23T09:46:43Z","2021-01-14T13:56:35Z"
"","26163","cannot resolve `ServerRequest::pathVariable` in nested `RequestPredicate`","**Affects:** v5.3.1  ---   cannot resolve `ServerRequest::pathVariable` in nested `RequestPredicate`.  example using Spring Initializer created Project using Spring Boot 2.4.0  ```kotlin package com.example.demo  import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.function.ServerRequest import org.springframework.web.servlet.function.ServerResponse import org.springframework.web.servlet.function.router  @SpringBootApplication class DemoApplication  fun main(args: Array) {     runApplication(*args) }   @Configuration class DemoRouter {     @Bean     fun route() = router {         val handle: (ServerRequest) -> ServerResponse = {             ServerResponse.ok().body(mapOf(""id"" to it.pathVariable(""id"")))         }         GET(""/person1/{id}"", {             true         }, handle)         GET(""/person2/{id}"", {             it.pathVariable(""id"")             true         }, handle)         ""person3"".nest {             GET(""/{id}"", {                 true             }, handle)         }         ""person4"".nest {             GET(""/{id}"", {                 it.pathVariable(""id"")                 true             }, handle)         }     } } ```  only nest and access to pathVariable  in `RequestPredicate` occurs error.  ``` GET http://localhost:8080/person4/1  HTTP/1.1 500  Content-Type: application/json Transfer-Encoding: chunked Date: Fri, 27 Nov 2020 11:33:12 GMT Connection: close  {   ""timestamp"": ""2020-11-27T11:33:12.870+00:00"",   ""status"": 500,   ""error"": ""Internal Server Error"",   ""message"": """",   ""path"": ""/person4/1"" }  Response code: 500; Time: 155ms; Content length: 123 bytes  ```  ``` java.lang.IllegalArgumentException: No path variable with name ""id"" available 	at org.springframework.web.servlet.function.ServerRequest.pathVariable(ServerRequest.java:225) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.function.RequestPredicates$SubPathServerRequestWrapper.pathVariable(RequestPredicates.java:1045) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at com.example.demo.DemoRouter$route$1$4$1.test(DemoApplication.kt:40) ~[main/:na] 	at org.springframework.web.servlet.function.RequestPredicates$AndRequestPredicate.test(RequestPredicates.java:773) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.function.RouterFunctions$DefaultRouterFunction.route(RouterFunctions.java:993) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.function.RouterFunctionBuilder$BuiltRouterFunction.route(RouterFunctionBuilder.java:392) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.function.RouterFunctions$DefaultNestedRouterFunction.lambda$route$0(RouterFunctions.java:1036) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at java.base/java.util.Optional.map(Optional.java:265) ~[na:na] 	at org.springframework.web.servlet.function.RouterFunctions$DefaultNestedRouterFunction.route(RouterFunctions.java:1028) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.function.RouterFunctionBuilder$BuiltRouterFunction.route(RouterFunctionBuilder.java:392) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.function.support.RouterFunctionMapping.getHandlerInternal(RouterFunctionMapping.java:193) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:491) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1255) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1037) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.1.jar:5.3.1] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na] ```  If change the Spring Boot version to 2.3.6.RELEASE, that is Spring WebMVC 5.2.11RELEASE, is works.  It seems to be affected from following commit. https://github.com/spring-projects/spring-framework/commit/54e6103defb99c067f3f4d5a6054aa24a29a379e#diff-cc2b40f2447feaaec96bd736d40378d2883c72eab4791c873d7244a135fbe1bdR998-R1007  the commit to use `request.attribute` in `SubPathServerRequestWrapper`  , but the previous commit will use `attribute` in `SubPathServerRequestWrapper`.","closed","type: bug,","nise-nabe","2020-11-27T11:44:41Z","2020-12-01T10:26:48Z"
"","26046","Multipart request with content length (WebFlux)","**Affects:** spring-webflux:5.2.10  If I try to send http-multipart request with precalculation content length - webclient will generated incorrect request.  For example  ```java     public Mono sendMultipartWithLength() throws URISyntaxException {         var length = length();          return client.post()                 .uri(""http://localhost:8080/with/multipart"")                 .contentLength(length)                 .contentType(MediaType.MULTIPART_FORM_DATA)                 .bodyValue(files())                 .retrieve()                 .bodyToMono(String.class);     }      private MultiValueMap> files() throws URISyntaxException {         MultipartBodyBuilder builder = new MultipartBodyBuilder();         builder.part(""file1"", new FileSystemResource(getFileFromResource(""1.txt"")));         builder.part(""file2"", new FileSystemResource(getFileFromResource(""2.txt"")));         builder.part(""file3"", new FileSystemResource(getFileFromResource(""3.txt"")));           return builder.build();     }      private long length() throws URISyntaxException {         long length = getFileFromResource(""1.txt"").length();         length += getFileFromResource(""2.txt"").length();         length += getFileFromResource(""3.txt"").length();          log.info(""Content length {}"", length);          return length;     } ```  See http-request: section ""MIME Multipart Media Encapsulation, Type: multipart/form-data, ..."" contains only 2 files and part of the file 3 (in section ""Hypertext Transfer Protocol"").    Is this a bug or is there a correct way to set the content-length?  Full example https://github.com/romus/client-multipart","closed","status: invalid,","romus","2020-11-08T15:36:05Z","2020-11-10T12:55:08Z"
"","26131","Initialize Webclient via defaultRequest callback based on Reactor Context","**Affects:** spring-webflux  Please consider moving creation ClientRequest during creating exchange() of Webclients inside Mono.defer() operator: `Mono.defer( () -> exchangeFunction.exchange(createClientRequest())`   to allow modify with not empty reactive context in `webclientBuilder.defaultRequest(Consumer> defaultRequest)` in real just before request style     ---","closed","","tka4ukalex","2020-11-23T00:59:50Z","2020-12-07T08:50:19Z"
"","25968","CSRF workflow: header X-XSRF-TOKEN and Cookie XSRF-TOKEN both set with any identical value triggers API instead of returning 403 Forbidden","**Affects:** spring-boot-dependencies 2.3.4.RELEASE  --- I agree that Cookie `XSRF-TOKEN` is set by the server and is not meant to be set on the client side, but...  ### Functional description I would expect that when I set any wrong identical value on client side for both header `X-XSRF-TOKEN` and Cookie `XSRF-TOKEN` then API would not be reached and that instead Spring would return `403 Forbidden`, because the value is different from the CSRF token stored for current session on the server side.  Here I can reach the endpoint if I set both header `X-XSRF-TOKEN` and Cookie `XSRF-TOKEN` to `whatever-value` using Postman:  ![image](https://user-images.githubusercontent.com/1971480/97093423-17598380-164c-11eb-9943-abbdd3c2b804.png)  You see on the left of screenshot behind Postman `Sending request...` that the only value that should trigger the endpoint is `ab87abbd-0596-4fcc-93b7-3d31aca6b44a`.  ### Configuration  I'm testing CSRF with this kind of setting: ```java @Override protected void configure(HttpSecurity http) throws Exception {     http     .csrf()         .requireCsrfProtectionMatcher(             new AndRequestMatcher(                 CsrfFilter.DEFAULT_CSRF_MATCHER,                  new RegexRequestMatcher("".*greeting-csrf.*"", null)             )         )         .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())     .and()         .sessionManagement()         .sessionCreationPolicy(SessionCreationPolicy.STATELESS)     ; } [...] @RequestMapping(     method = { RequestMethod.GET, RequestMethod.POST },     path = ""/greeting-csrf"",     consumes = { MediaType.APPLICATION_FORM_URLENCODED_VALUE, MediaType.TEXT_PLAIN_VALUE } ) public Greeting greetingCsrf(HttpServletRequest request) throws IOException { ... } ``` Nominal workflow is that on the first connection I get the value `ab87...b44a` from Cookie `XSRF-TOKEN` coming from the server. Then I set header `X-XSRF-TOKEN` or parameter `_csrf` to value `ab87...b44a`, and Spring triggers correctly the endpoint. And if I put any other value then Spring returns correctly `403 Forbidden`.  But setting Cookie `XSRF-TOKEN` on the client with any identical value to header `X-XSRF-TOKEN` appears to trigger the endpoint too.","closed","status: invalid,","ron190","2020-10-24T21:24:24Z","2020-10-25T10:47:11Z"
"","26099","Add toEntityFlux with BodyExtractor to WebClient.ResponseSpec","**Affects:** Spring WebFlux 5.3.1  ---  I started a conversation over on https://github.com/spring-projects/spring-framework/issues/26023#issuecomment-727119896 but it feels more appropriate to open a new issue.  If the plan is to remove the `WebClient#exchange` method entirely (as described [here](https://github.com/spring-projects/spring-framework/issues/25751)) how can we solve for those cases that aren't currently solved for using the alternative methods?  I have two scenarios in my case base which seem to require `WebClient#exchange`:  The first scenario is a series of endpoints which more or less act as a proxy to an upstream service.  We use `Flux` to stream the raw data to/from the client.  In this case `retrieve().entityToFlux(DataBuffer.class)` looks like it comes close to satisfying this use case, but I don't see a way with `ResponseSpec` to disable the default status code handling entirely, which is what I need.  The second scenario are some endpoints where we make an upstream service request and get back a large JSON response containing an array nested in a root object, e.g.:  ```json {     ""response"": {         ""entities"": [ ]     } } ```  We're currently using `exchange` with a custom `BodyExtractor>` which can scan into the JSON response to the array and stream the individual elements which we return in a `ResponseEntity>` so that we can also return the response headers and status code.  We then flow this `Flux` back to the controller where it is mapped to transform each entity and stream it down to the client.  See #24951 for more details.  I've not fully evaluated where we're using `exchange` and whether or not they all fit into these two cases so I might be missing some scenarios.","closed","status: superseded,","HaloFour","2020-11-16T19:09:10Z","2020-11-18T16:10:28Z"
"","26369","Slow prototype bean creation when migrating spring-boot 2.3.5 -> 2.4.1","**Affects:** Spring Framework 5.3.2  ---   I have a project (console based, environment=NONE, only base spring boot starter) with a lot of prototype bean creations at application runtime (not startup), ~15k of beans. I have one interface and near 150 different implemantions of it marked with  ```java @Component @Primary @Scope(""prototype"") ```  `@Configuration` has `@Bean`-method, some kind of object provider, which get bean of *concrete* class (not interface):  ```java @Configuration @RequiredArgsConstructor public class DiagnosticConfiguration {    private final ApplicationContext applicationContext;    @Bean   @Scope(""prototype"")   public  T diagnostic(Class clazz) {     return applicationContext.getBean(clazz);   }  } ```  On spring boot 2.3.5 15000 of `diagnostic` calls take 12 seconds. On spring boot 2.4.1 - more than **75** seconds. no changes to application code or configs, just dependency bump.  On flame graph I discovered problem (synchonized issue) at CommonAnnotationBeanPostprocessor.findResourceMetadata https://postimg.cc/3ywf5B6Q  Comparison of: 2.3.5: https://postimg.cc/HVdnQYLn 2.4.1: https://postimg.cc/KKw4LtKh  Looks like all bean creations on 2.3.5 took metadata from cache, while all creations at 2.4.1 have ""cache miss"" and are forced to recreate metadata.  I've asked about this at spring-boot gitter and was redirected here by @wilkinsona.  P.S. I'll try to provide some demo-project, need some time to reproduce it.","closed","in: core,","nixel2007","2021-01-11T12:28:17Z","2021-03-15T22:42:31Z"
"","26434","Response writing fails to complete with WebFlux on Tomcat","**Affects:** \v5.3.3  The symptom of this issue is similar to previous issue https://github.com/spring-projects/spring-framework/issues/23096 (response handling never completes) though the underlying cause is different.  I've reproduced this issue with the small demo spring-boot project which uses WebFlux on Tomcat, seen here: https://github.com/danielra/webflux_race_investigation The project can be built with `./gradlew clean build` and then run via `./start.sh`. To reproduce the problem I've been successful using wrk (https://github.com/wg/wrk) to throw some load at the service, stop and then throw some more etc.. For example: ``` for i in {1..100}; do   ./wrk -t 2 -c 1000 -d 10s --latency --timeout 9s --script ./myPost.lua http://localhost:8080/post; done ``` Where ./myPost.lua looks like: ``` wrk.method = ""POST"" wrk.body   = ""[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]"" wrk.headers[""Content-Type""] = ""application/json"" ``` (I don't think this being a POST request really ended up being relevant, but I started here because I was trying to start the more isolated repro somewhere somewhat similar to the real system that was experiencing the problem.)  This will result in a lot of trace level logging under a `logs` directory in the demo project. This can be searched through to find any occurrences like: ``` find . -name \*.gz -print0 | xargs -0 zgrep ""Response timeout"" ``` And then another search for the logPrefix found in resulting log entries can be performed to gain more context on the processing for the relevant request.  This is an example set of log entries for a repro case (with irrelevant line prefixes ommitted): ``` 12:31:47,007 INFO c.e.d.f.DemoWebFilter [http-nio-8080-exec-368] [33d6780] Incoming request observed. 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] UNSUBSCRIBED -> SUBSCRIBING 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] 9223372036854775807 requested 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] SUBSCRIBING -> DEMAND 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] onDataAvailable 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] DEMAND -> READING 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] Read 8092 bytes 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] Publishing data read 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] Read 8192 bytes 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] Publishing data read 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] Read 4067 bytes 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] Publishing data read 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] No more data to read 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] READING -> DEMAND 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] onAllDataRead 12:31:47,007 TRACE _.s.h.s.r.AbstractListenerReadPublisher [http-nio-8080-exec-368] [33d6780] DEMAND -> COMPLETED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [parallel-2] [33d6780] UNSUBSCRIBED -> REQUESTED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [parallel-2] [33d6780] Received onNext publisher 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [parallel-2] [33d6780] REQUESTED -> RECEIVED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] UNSUBSCRIBED -> REQUESTED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] Item to write 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] REQUESTED -> RECEIVED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] onWritePossible 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] RECEIVED -> WRITING 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] Wrote 12931 of 12931 bytes 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] WRITING -> REQUESTED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] No more items to write 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] REQUESTED -> RECEIVED 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [parallel-2] [33d6780] isWritePossible: false 12:31:47,780 TRACE _.s.h.s.r.WriteResultPublisher [parallel-2] [33d6780] UNSUBSCRIBED subscribe: org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor$State$WriteResultSubscriber@7a996bbf 12:31:47,780 TRACE _.s.h.s.r.WriteResultPublisher [parallel-2] [33d6780] SUBSCRIBING request: 9223372036854775807 12:31:47,780 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [parallel-2] [33d6780] Received onComplete 12:31:47,780 TRACE _.s.h.s.r.WriteResultPublisher [parallel-2] [33d6780] UNSUBSCRIBED subscribe: reactor.core.publisher.MonoNext$NextSubscriber@53a4d00d 12:31:47,780 TRACE _.s.h.s.r.WriteResultPublisher [parallel-2] [33d6780] SUBSCRIBING request: 9223372036854775807 12:31:47,781 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [http-nio-8080-exec-348] [33d6780] onWritePossible 12:31:47,781 TRACE _.s.h.s.r.AbstractListenerWriteProcessor [http-nio-8080-exec-348] [33d6780] RECEIVED -> COMPLETED 12:31:47,781 TRACE _.s.h.s.r.WriteResultPublisher [http-nio-8080-exec-348] [33d6780] SUBSCRIBED publishComplete 12:31:47,781 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [http-nio-8080-exec-348] [33d6780] RECEIVED writeComplete 12:31:47,781 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [http-nio-8080-exec-348] [33d6780] Flush attempt 12:31:47,781 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [http-nio-8080-exec-348] [33d6780] RECEIVED flushingFailed 12:31:59,588 TRACE _.s.h.s.r.AbstractListenerReadPublisher [parallel-4] [33d6780] Cancellation 12:31:59,588 TRACE _.s.h.s.r.WriteResultPublisher [parallel-4] [33d6780] SUBSCRIBED cancel 12:31:59,588 ERROR c.e.d.f.DemoWebFilter [parallel-4] [33d6780] Response timeout after 12581 milliseconds for null request with uri 'http://localhost:8080/post'. Response status code was already committed: '200 OK'.                                                                                                                                                                                                               12:31:59,588 TRACE o.s.h.s.r.ServletHttpHandlerAdapter [parallel-4] [33d6780] Handling completed ```  Here the line `12:31:47,781 TRACE _.s.h.s.r.AbstractListenerWriteFlushProcessor [http-nio-8080-exec-348] [33d6780] RECEIVED flushingFailed` comes from a modification I made locally to the spring-framework to add an additional trace log line here: https://github.com/spring-projects/spring-framework/blob/v5.3.3/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerWriteFlushProcessor.java#L194-L195 like so: ``` if (rsWriteFlushLogger.isTraceEnabled()) {             rsWriteFlushLogger.trace(this.logPrefix + this.state + "" flushingFailed"", t); } ``` For reference, the relevant Throwable logged at these lines in these reproductions with this demo project looks like:  ``` org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe         at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:309) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:272) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:118) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.springframework.http.server.reactive.ServletServerHttpResponse.flush(ServletServerHttpResponse.java:198) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.ServletServerHttpResponse.access$500(ServletServerHttpResponse.java:50) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseBodyFlushProcessor.flush(ServletServerHttpResponse.java:316) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor$State$3.writeComplete(AbstractListenerWriteFlushProcessor.java:291) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor$State$WriteResultSubscriber.onComplete(AbstractListenerWriteFlushProcessor.java:437) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.WriteResultPublisher$State.publishComplete(WriteResultPublisher.java:256) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.WriteResultPublisher.publishComplete(WriteResultPublisher.java:84) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.AbstractListenerWriteProcessor.changeStateToComplete(AbstractListenerWriteProcessor.java:280) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.AbstractListenerWriteProcessor.access$300(AbstractListenerWriteProcessor.java:46) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.AbstractListenerWriteProcessor$State$3.onWritePossible(AbstractListenerWriteProcessor.java:368) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.AbstractListenerWriteProcessor.onWritePossible(AbstractListenerWriteProcessor.java:153) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseBodyWriteListener.onWritePossible(ServletServerHttpResponse.java:270) ~[spring-web-5.3.3.jar!/:5.3.3]         at org.apache.coyote.Response.onWritePossible(Response.java:762) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:188) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:241) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_282]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_282]         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at java.lang.Thread.run(Thread.java:748) [?:1.8.0_282] Caused by: java.io.IOException: Broken pipe         at sun.nio.ch.FileDispatcherImpl.write0(Native Method) ~[?:1.8.0_282]         at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47) ~[?:1.8.0_282]         at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93) ~[?:1.8.0_282]         at sun.nio.ch.IOUtil.write(IOUtil.java:65) ~[?:1.8.0_282]         at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:470) ~[?:1.8.0_282]         at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:138) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1269) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:764) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.tomcat.util.net.SocketWrapperBase.flushNonBlocking(SocketWrapperBase.java:735) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:709) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:572) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.http11.filters.IdentityOutputFilter.flush(IdentityOutputFilter.java:117) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:220) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:1195) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:402) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.coyote.Response.action(Response.java:209) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:305) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41]         ... 25 more ``` And _appears to me_ to be a result of the client hanging up the connection before response handling is complete on the server.  After this flushingFailed log line, we can see a relatively large (~12 second) gap in time before the next log line which was triggered by the response timeout being triggered which is setup in the DemoWebFilter in the demo project here: https://github.com/danielra/webflux_race_investigation/blob/main/src/main/java/com/example/demo/filter/DemoWebFilter.java#L38 And only after this timeout does `ServletHttpHandlerAdapter` log a line indicating that handling is complete.  I note that the `flushingFailed` method where I added the extra log line above has a comment which reads:  > Invoked when an error happens while flushing. Sub-classes may choose    to ignore this if they know the underlying API will provide an error    notification in a container thread.    Defaults to no-op.   Based on this description and the observed behavior, it _seems_ to me that perhaps a notification of the error was expected elsewhere, but it was never actually received so handling of the response is never completed (without a timeout present). I don't know enough yet to say whether that was due to a bug in the code that should have emitted the error notification or on the listening side - or if there should actually be a real non-no-op operation implemented of flushingFailed in the relevant subclass in the Tomcat case. However, my expectation is that regardless of when a client hangs up the connection the server should proceed with completing response handling.  Please let me know if any additional information would be helpful. Thank you for your time!  ---","closed","type: bug,","danielra","2021-01-23T03:05:18Z","2022-04-22T17:12:55Z"
"","26449","Websocket extensions not working","**Affects:** \5.3.3  --- In spring, one can add an undertow websocket extension by:   ``` @Bean     public WebServerFactoryCustomizer deploymentCustomizer() {         return factory -> {             UndertowDeploymentInfoCustomizer customizer = deploymentInfo -> {                  WebSocketDeploymentInfo webSocketDeploymentInfo = new WebSocketDeploymentInfo();                 webSocketDeploymentInfo.addExtension(new PerMessageDeflateHandshake());                 deploymentInfo.addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, webSocketDeploymentInfo);             };             factory.addDeploymentInfoCustomizers(customizer);          };     } ```  But that extension does not work when processing requests. I have found that spring wraps extensions in org.springframework.web.socket.server.standard.AbstractStandardUpgradeStrategy.getInstalledExtensions(...)  ``` protected List getInstalledExtensions(WebSocketContainer container) { 		List result = new ArrayList<>(); 		for (Extension extension : container.getInstalledExtensions()) { 			result.add(new StandardToWebSocketExtensionAdapter(extension)); 		} 		return result; 	} ```  which breaks the extension matching in   org.springframework.web.socket.server.support.filterRequestedExtensions(...)  ``` protected List filterRequestedExtensions(ServerHttpRequest request, 			List requestedExtensions, List supportedExtensions) {  		List result = new ArrayList<>(requestedExtensions.size()); 		for (WebSocketExtension extension : requestedExtensions) { 			if (supportedExtensions.contains(extension)) { 				result.add(extension); 			} 		} 		return result; 	} ```  I have been unable to find a workaround for this, and I am not sure what an appropriate fix would be.","closed","type: bug,","piotrblasiak","2021-01-26T20:04:39Z","2021-01-28T10:10:20Z"
"","25878","The problem with RequestParam/DateTimeFormat and LocalDateTime","**Affects:** \5.1.6 I have the following code ```java @GetMapping(""/somepath"") public String getNextDayOfMonth(     @RequestParam(value = ""target_date"", required = true)     @DateTimeFormat(iso = DateTimeFormat.ISO.DATE)     LocalDate targetDate ) {     return targetDate.plusDays(1).getDayOfMonth(); } ``` But when I execute this handler with path like `/sompath?target_date=`, I get NullPointerException, because my variable `target_date` is null, but I define `required=true` and DateTimeFormat annotation. I thought, if I set DateTimeFormat property and execute this mapping with invalid date string (empty in my case), I will get client exception (4xx codes) instead of server exception (5xx, cause NPE it is server side exception).  I'm suspect, that problem in this line of code: https://github.com/spring-projects/spring-framework/blob/d05803aa04383a3b4b2dc1db2591f9fec1a156a2/spring-context/src/main/java/org/springframework/format/support/FormattingConversionService.java#L211-L214  and think, that passing empty string for date - it's client error  ---","closed","in: web,","AndrewBystrov","2020-10-07T16:29:09Z","2020-10-11T09:02:35Z"
"","25934","If a bean has @RefreshScope annotation and implements SmartLifecycle, SmartLifecycle failure","**Affects:** \<5.2.6.RELEASE>  --- If a Bean has the @RereshScope annotation and implements the SmartLife interface, the SmartLife interface lifecycle method will not be invoked after the Spring container is started  Bean: @Slf4j @Component @RefreshScope public class NectorInvoker implements SmartLifecycle  start method: @Override     public void start() {         if (this.running.compareAndSet(false, true)) {             nectorClient.start();         }    }  As mentioned above, the start method will not be called","closed","status: declined,","flangely","2020-10-19T09:39:45Z","2020-11-13T02:15:20Z"
"","26392","Custom ImportBeanDefinitionRegistrar with CustomClassLoader failed","**Affects:** \<5.2.11.RELEASE>  ---  For enhancements, provide context and describe the problem. Some of my java lib not imported by maven, and I want to load it by CustomClassLoader, and scan java lib class to register spring bean.   I found to implements ImportBeanDefinitionRegistrar and @Import it will good for me. some code like this: ```java    @Configuration(proxyBeanMethods = false)     static class PluginBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {           @Override         public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {            ClassLoader pluginClassLoader = Plugin.getPluginClassLoader();           //scanner           ClassPathBeanDefinitionScanner scanner =                   new PluginClassPathBeanDefinitionScanner(registry, true, applicationContext.getEnvironment(),                           new DefaultResourceLoader(pluginClassLoader));           BeanDefinition bd = BeanDefinitionBuilder.genericBeanDefinition(Plugin.getPluginClass()).getBeanDefinition();              Set basePackages = new LinkedHashSet<>();           basePackages.add(ClassUtils.getPackageName(Plugin.getPluginClass()));              scanner.addExcludeFilter(new AssignableTypeFilter(TypeExcludeFilter.class));           scanner.addExcludeFilter(new AssignableTypeFilter(AutoConfigurationExcludeFilter.class));           scanner.addExcludeFilter(new AnnotationTypeFilter(SpringBootApplication.class));              scanner.scan(StringUtils.toStringArray(basePackages));         }     } ``` and PluginClassPathBeanDefinitionScanner will load class Resource into BeanDefinition ```java public class PluginClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner {      @SneakyThrows     @Override     public int scan(String... basePackages) {         int beanCountAtScanStart = this.getRegistry().getBeanDefinitionCount();          Set scanBds = doScan(basePackages);         loadBeanResource(scanBds);          return (this.getRegistry().getBeanDefinitionCount() - beanCountAtScanStart);     }      private void loadBeanResource(Set bdhs) throws IOException {         for (BeanDefinitionHolder bdh : bdhs) {             BeanDefinition bd = bdh.getBeanDefinition();             if (bd instanceof AbstractBeanDefinition) {                 //load class by this resource loader                 MetadataReader meta = this.getMetadataReaderFactory().getMetadataReader(Objects.requireNonNull(bd.getBeanClassName()));                 ((AbstractBeanDefinition) bd).setResource(meta.getResource());             }         }     } } ``` unfortunately SpringContext `org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set)` will parse those loaded BeanDefinitions with SpringContext `org.springframework.context.annotation.ConfigurationClassParser#metadataReaderFactory` and absolutely ClassNotFound Exception.  What if: * first use BeanDefinition Resource or BeanClass if it is not null * or load resource or bean class by SpringContext ResourceLoad(or MetadataReaderFactory)  If there are another way to solve my problem, please let me know, thanks!!!","closed","","haibingzhao","2021-01-16T02:15:22Z","2022-02-18T19:05:35Z"
"","26182","ContentCachingResponseWrapper should not add “Content-Length” when “Transfer-Encoding” is present","**Affects:** \<4.3.21>  ---   I'm using **ContentCachingResponseWrapper** to read response information in a inherited `OncePerRequestFilter.doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)` level.  At the end I'm calling **ContentCachingResponseWrapper.copyBodyToResponse()** to copy response body.  When my API returns **ResponseEntity** with custom body type,  I'm getting following Parse Error; **Parse Error: The response headers can't include ""Content-Length"" with chunked encoding**  This happens when I use **Spring Cloud OpenFeign** web client to do the API call. So in the OpenFeign GET response includes **""transfer-encoding""** in the headers and then when I call ContentCachingResponseWrapper.copyBodyToResponse() it is adding **""Content-Length""** to the headers.  _My code is as follows;_  _OncePerRequestFilter overriden method;_  ``` @Override     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)         throws ServletException, IOException     {         ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request);         ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);          try         {             if (ocpHttpTraceService.isLoggingPropertyEnabled(TracingConstants.BODY, TraceType.INBOUND))             {                 filterChain.doFilter(requestWrapper, responseWrapper);             }             else             {                 filterChain.doFilter(request, response);             }              System.out.println(getRequestBody(requestWrapper));             System.out.println(getResponseBody(responseWrapper));         }         finally         {             responseWrapper.copyBodyToResponse();         }     } ```","closed","type: enhancement,","KasunAbey","2020-12-01T03:43:43Z","2020-12-02T02:38:22Z"
"","25960","LinkedMultiValueMap downstream issue with MultiValueMapAdapter package private base class","**Affects:** \> 5.2.9.RELEASE    ---   Hi spring team,  i've run into an issue that is caused by a recent change in the MultiValueMap class hierarchy.  The changes introduced in the commits bec89db added a new private class [MultiValueMapAdapter](https://github.com/spring-projects/spring-framework/blob/bec89dba4c6051eb7e1df4ac46ff0e2d23b07583/spring-core/src/main/java/org/springframework/util/MultiValueMapAdapter.java) and [LinkedMultiValueMap](https://github.com/spring-projects/spring-framework/blob/bec89dba4c6051eb7e1df4ac46ff0e2d23b07583/spring-core/src/main/java/org/springframework/util/LinkedMultiValueMap.java) now inherits form this class.  **Background on how LinkedMultiValueMap is implicitly used:** We cache specific spring mvc controller responses, some controller methods declare the following  ````java @MatrixVariable(pathVar = ""filter"") Map> filters ```` Internally spring creates LinkedMultiValueMap instances for those filters.  **The new class hierarchy change caused the following downstream issue:** We are using a distributed hazelcast cache cluster, this cluster holds objects that contain LinkedMultiValueMap objects. The hazelcast nodes do not have the spring jar on the classpath, we use the [User code deployment](https://docs.hazelcast.org/docs/latest/manual/html-single/#configuring-user-code-deployment) feature that deploys specific java classes to the cluster to support storing those Map instances.   Our config looked like this: ````xml                                        org.springframework.util.MultiValueMap             org.springframework.util.LinkedMultiValueMap               ````  With the change i've added the new class: ````xml    org.springframework.util.MultiValueMapAdapter ````  Now we are getting the following exception: ```` java.lang.IllegalAccessError: class org.springframework.util.LinkedMultiValueMap cannot access its superclass org.springframework.util.MultiValueMapAdapter ````  The exception is thrown in the code deployment execution, reason being that the new parent class MultiValueMapAdapter has package private access.   **Temporary fix**: I was able to solve the issue by re declaring the MultiValueMapAdapter class in my project code with public access.  This probably only works because of the class loader execution order.     **Request**: The simplest solution would be to make the MultiValueMapAdapter class public. I totally understand that the class is not public for a reason, but to respect backwards compatibility i would only suggest that this should be considered. I just want to mention the problem in case someone else runs into the same issue.   Another solution on our side would be adding the spring-core.jar to the hazelcast cluster classpath, but this would force us to make a custom build/config for the hazelcast nodes.  If there is another solution i would appreciate to get any input on this.","closed","in: core,","michaelhaessig","2020-10-23T10:06:57Z","2020-10-26T11:01:11Z"
"","26096","StandardMultipartHttpServletRequest MaxUploadSizeExceededException maxUploadSize always -1?","**Affects:** \ 5.1.5 ---   The default file upload uses StandardServletMultipartResolver. When the file upload exceeds the size, why the maxUploadSize of MaxUploadSizeExceededException is always -1, but the exception can be captured in CommonsMultipartResolver and the file size can be correctly assigned  Cause the problem, using StandardServletMultipartResolver, the external can not catch the exception correctly to get the file size exceeding  ```  StandardMultipartHttpServletRequest protected void handleParseFailure(Throwable ex) { 		String msg = ex.getMessage(); 		if (msg != null && msg.contains(""size"") && msg.contains(""exceed"")) { 			throw new MaxUploadSizeExceededException(-1, ex); 		} 		throw new MultipartException(""Failed to parse multipart servlet request"", ex); 	}  CommonsMultipartResolver   protected MultipartParsingResult parseRequest(HttpServletRequest request) throws MultipartException {         String encoding = this.determineEncoding(request);         FileUpload fileUpload = this.prepareFileUpload(encoding);          try {             List fileItems = ((ServletFileUpload)fileUpload).parseRequest(request);             return this.parseFileItems(fileItems, encoding);         } catch (SizeLimitExceededException var5) {             throw new MaxUploadSizeExceededException(fileUpload.getSizeMax(), var5);         } catch (FileSizeLimitExceededException var6) {             throw new MaxUploadSizeExceededException(fileUpload.getFileSizeMax(), var6);         } catch (FileUploadException var7) {             throw new MultipartException(""Failed to parse multipart servlet request"", var7);         }     } ```","closed","","tofdragon","2020-11-16T02:42:18Z","2020-11-17T01:35:59Z"
"","26130","Print helpful information in RSocket MetadataExtractor","**Affects:** \  When i try to add extra metadata by RSocketRequester.MetadataSpec#metadata method and don't know i should add  a EntryExtractor. I have no way to get the metadata on server side. And then I found out DefaultMetadataExtractor#extractEntry only can handle WellKnownMimeType.MESSAGE_RSOCKET_ROUTING if we don't register a EntryExtractor for other type mime metadata. A warn or debug level  log should be print  if you ignore some of metadata, which can benefit for debugging.","closed","type: enhancement,","rudy2steiner","2020-11-22T16:58:05Z","2020-11-24T04:30:50Z"
"","26174","Spring messaging support hints on client and server side for RSocket","**Affects:** \  --- To my knowledge,  for RSocket request, the hints on client and server side are both an empty map.     Even I add a metadata into header by RSocketRequester.RequestSpec#metadata, there is no way for me to use the metadata on server side.  To support hints on client and server side  will in favor of user to pass encode/decode context.   And I'll pull a request if any one expect this change.For how to implement it, we could discuss on below.   On RSocket client, in DefaultRequestSpec#encodeData method uses an empty hints to call encoder: ``` private  DataBuffer encodeData(T value, ResolvableType elementType, @Nullable Encoder encoder) { 			if (encoder == null) { 				elementType = ResolvableType.forInstance(value); 				encoder = strategies.encoder(elementType, dataMimeType); 			} 			return ((Encoder) encoder).encodeValue( 					value, bufferFactory(), elementType, dataMimeType, EMPTY_HINTS); 		} ```   On RSocket server side, in PayloadMethodArgumentResolver#decodeContent method uses an empty hints to call decoder: ``` private Mono decodeContent(MethodParameter parameter, Message message, 			boolean isContentRequired, Flux content, MimeType mimeType) {  		ResolvableType targetType = ResolvableType.forMethodParameter(parameter); 		Class resolvedType = targetType.resolve(); 		ReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null); 		ResolvableType elementType = (adapter != null ? targetType.getGeneric() : targetType); 		isContentRequired = isContentRequired || (adapter != null && !adapter.supportsEmpty()); 		Consumer validator = getValidator(message, parameter);  		Map hints = Collections.emptyMap();  		for (Decoder decoder : this.decoders) { 			if (decoder.canDecode(elementType, mimeType)) { 				if (adapter != null && adapter.isMultiValue()) { 					Flux flux = content 							.map(buffer -> decoder.decode(buffer, elementType, mimeType, hints)) 							.onErrorResume(ex -> Flux.error(handleReadError(parameter, message, ex))); 					if (isContentRequired) { 						flux = flux.switchIfEmpty(Flux.error(() -> handleMissingBody(parameter, message))); 					} 					if (validator != null) { 						flux = flux.doOnNext(validator); 					} 					return Mono.just(adapter.fromPublisher(flux)); 				} 				else { 					// Single-value (with or without reactive type wrapper) 					Mono mono = content.next() 							.map(buffer -> decoder.decode(buffer, elementType, mimeType, hints)) 							.onErrorResume(ex -> Mono.error(handleReadError(parameter, message, ex))); 					if (isContentRequired) { 						mono = mono.switchIfEmpty(Mono.error(() -> handleMissingBody(parameter, message))); 					} 					if (validator != null) { 						mono = mono.doOnNext(validator); 					} 					return (adapter != null ? Mono.just(adapter.fromPublisher(mono)) : Mono.from(mono)); 				} 			} 		}  		return Mono.error(new MethodArgumentResolutionException( 				message, parameter, ""Cannot decode to ["" + targetType + ""]"" + message)); 	}   ```","closed","type: enhancement,","rudy2steiner","2020-11-29T15:20:08Z","2021-01-11T11:13:03Z"
"","26359","# Spring Webflux  not releasing memory .Heap Memory is not coming down for spring webflux application","**Affects:** \  ---   1. We  new to Spring webflux with netty  . We have built application with spring webflux ,but heap memory is not coming down ,it always incremental . We have applied all GC algorithms ,and we verified code also  everything looks good . We observed on call  subscription() method ,webflux is creating threads  in back end and that memory is not visible to JVM .Can any please help why this issue with webflx. 2. We have applied the property of io.netty.allocator.useCacheForAllThreads=false ,But no use  3. Our system configurations spring-boot-starter-webflux :2.3.0 M3 ,r2dbc-mssql 0.8.3 (using sql server in back end),apache kafka .  Please help us to find out the root cause for the problem","closed","","dineshkumardidugu","2021-01-08T09:09:19Z","2021-01-27T16:39:48Z"
"","26229","JmsTemplate/CachingConnectionFactory doesn't reset sessions if the underlying connection was physically closed - resetConnection is also not refreshing JMS session","**Affects:** \  ---    Hi , The issue is similar to https://github.com/spring-projects/spring-framework/issues/22031  We are also facing the same issue with the combination JmsTemplate/CachingConnectionFactory. The stacktrace: ``` org.springframework.jms.IllegalStateException: JMSCC0020: This session is closed.; nested exception is com.ibm.msg.client.jms.DetailedIllegalStateException: JMSCC0020: This session is closed. An application called a method that must not be used after the session is closed. Ensure that the session is not closed before calling the method. for queue : queue:////>>  	at com.chase.ccb.caf.core.service.api.io.jms.DefaultMessageListener.onMessage(DefaultMessageListener.java:86) 	at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:761) 	at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:699) 	at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:674) 	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:318) 	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:257) 	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1189) 	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1179) 	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1076) 	at java.lang.Thread.run(Thread.java:748) ```   we added the fix by explicitly calling CachingConnectionFactory#resetConnection in the catch block and retried sending the message When the exception ""org.springframework.jms.IllegalStateException: JMSCC0020 This session is closed"" occurred. But still the same exception occurred again  The issue of ""org.springframework.jms.IllegalStateException: JMSCC0020 This session is closed."" is occurring only intermittently  Spring JMS version is 5.2.7 IBM MQ 7.5.0.8 Spring-boot is 2.2.8.  there was an exception when it tried to close the connection: so, the connection was not closed and in the retry of sending message closed session was used and failed again. ``` stack_trace: com.ibm.msg.client.wmq.v6.jms.internal.ConfigEnvironment$1: MQJMS2000: failed to close MQ queue. at com.ibm.msg.client.wmq.v6.jms.internal.ConfigEnvironment.newException(ConfigEnvironment.java:379) at com.ibm.msg.client.wmq.v6.jms.internal.MQMessageConsumer.closeQ(MQMessageConsumer.java:1135) at com.ibm.msg.client.wmq.v6.jms.internal.MQMessageConsumer.close(MQMessageConsumer.java:1069) at com.ibm.msg.client.jms.internal.JmsMessageConsumerImpl.close(JmsMessageConsumerImpl.java:266) at com.ibm.msg.client.jms.internal.JmsSessionImpl.close(JmsSessionImpl.java:390) at com.ibm.msg.client.jms.internal.JmsConnectionImpl.close(JmsConnectionImpl.java:305) at com.ibm.mq.jms.MQConnection.close(MQConnection.java:98) at org.springframework.jms.connection.SingleConnectionFactory.closeConnection(SingleConnectionFactory.java:501) at org.springframework.jms.connection.SingleConnectionFactory.resetConnection(SingleConnectionFactory.java:389) at org.springframework.jms.connection.CachingConnectionFactory.resetConnection(CachingConnectionFactory.java:205) at org.springframework.jms.connection.SingleConnectionFactory.onException(SingleConnectionFactory.java:367) at org.springframework.jms.connection.SingleConnectionFactory$AggregatedExceptionListener.onException(SingleConnectionFactory.java:721) at com.ibm.msg.client.jms.internal.JmsProviderExceptionListener.run(JmsProviderExceptionListener.java:427) at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.runTask(WorkQueueItem.java:214) at com.ibm.msg.client.commonservices.workqueue.SimpleWorkQueueItem.runItem(SimpleWorkQueueItem.java:105) at com.ibm.msg.client.commonservices.workqueue.WorkQueueItem.run(WorkQueueItem.java:231) at com.ibm.msg.client.commonservices.workqueue.WorkQueueManager.runWorkQueueItem(WorkQueueManager.java:303) at com.ibm.msg.client.commonservices.j2se.workqueue.WorkQueueManagerImplementation$ThreadPoolWorker.run(WorkQueueManagerImplementation.java:1241) Caused by: com.ibm.mq.MQException: Message catalog not found, completion=2, reason=2009 at com.ibm.msg.client.wmq.v6.base.internal.MQManagedObject.close(MQManagedObject.java:207) at com.ibm.msg.client.wmq.v6.base.internal.MQQueue.close(MQQueue.java:360) at com.ibm.msg.client.wmq.v6.jms.internal.MQMessageConsumer.closeQ(MQMessageConsumer.java:1127) ... 16 common frames omitted ```  Could you please help on this  Thanks","open","in: messaging,","ranganath2334","2020-12-07T10:50:58Z","2021-11-10T11:41:09Z"
"","26259","@request","**Affects:** \  ---","closed","","mballem","2020-12-11T19:22:00Z","2020-12-11T21:21:54Z"
"","26411","Simple URL Mapping not working with PathPatternParser when Servlet context path is used","**Affects:** 5.3.3  ---  when I use `matching-strategy=path_pattern_parser` instead of `matching-strategy=ant_path_matcher` my application is not able to resolve resources anymore.  I created this sample project here https://github.com/BigMichi1/spring-web-resource where you can see how  the resource mapping is added: https://github.com/BigMichi1/spring-web-resource/blob/main/src/main/java/com/example/demo/CustomConfig.java  this works quite well until the `path_patter_parser` is used.  as one observation I had, was that when I remove `server.servlet.context-path=/hello` both strategies are working, but when setting the context path only the ant path matcher works","closed","type: bug,","BigMichi1","2021-01-20T18:37:25Z","2021-01-21T09:23:10Z"
"","26298","kotlinx.serialization should not be used for Java interfaces implemented by Java classes","**Affects:** 5.3.2  --- Having both Jackson and kotlinx.serialization in the classpath, kotlinx.serialization will try to deserialize Java interfaces implemented by Java classes resulting in the following exception:  ``` org.springframework.http.converter.HttpMessageNotReadableException: Could not read JSON: Polymorphic serializer was not found for missing class discriminator ('null') ... nested exception is kotlinx.serialization.json.internal.JsonDecodingException: Polymorphic serializer was not found for missing class discriminator ('null') ```  The issue comes from the `KotlinSerializationJsonHttpMessageConverter.candRead()` method that returns true when the Type is a Java interface.  In case of Java concrete implementations, this method should return false and let Jackson handle the conversion.","closed","type: bug,","mickael-coquer","2020-12-18T17:09:17Z","2021-01-13T07:07:44Z"
"","26299","MultipartFile.getOriginalFilename() documentation should warn user not to use it as destination file name","**Affects:** 5.3.2  ---   The javadoc for method [`org.springframework.web.multipart.MultipartFile.getOriginalFilename()`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/multipart/MultipartFile.html#getOriginalFilename--) should contain a big warning that the file name is client-controlled and **must not** be used as part of the destination file name on the local disk.  An adversary can easily specify a malicious file name ([cURL examples](https://superuser.com/a/149335)) and stripping off the directory name (as done by `CommonsMultipartFile`, see also #26207) is not enough (and might be disabled). For example the file name `..` could cause issues as well when the code handling file uploads is supposed to replace an existing file, but in this case might actually end up deleting the parent directory. Similarly file names reserved under Windows could also cause issues.  It would therefore be best to advise the user not to use the file name (not even in combination with another string) as destination file name, but instead generate a random one and store the original file name somewhere else (if necessary).  Related OWASP links (ideally also link to them from the documentation): - [File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html#filename-sanitization) - [Unrestricted File Upload Vulnerability](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)","closed","in: web,","Marcono1234","2020-12-18T21:35:26Z","2021-01-06T21:56:37Z"
"","26147","Refine kotlinx.serialization support","**Affects:** 5.3.1 ---   # Bug  I'm using the kotlinx-serialization library. The library is properly set up, jackson is excluded from dependencies, and returning a class annotated with `@Serializable` works correctly.  I'm trying to return a simple Kotlin list from a controller. When accessing the route the server displays this error and nothing is returned: ```kotlin import kotlinx.serialization.encodeToString import kotlinx.serialization.json.Json import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController  @RestController class Controller {     @GetMapping(""/"")     fun notworking() = listOf(1, 2, 3) } ```  ## Error message  ``` 2020-11-24 17:28:51.929  WARN 189362 --- [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotWritableException: No converter found for return value of type: class java.util.Arrays$ArrayList] 2020-11-24 17:28:51.945  WARN 189362 --- [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotWritableException: No converter found for return value of type: class java.util.LinkedHashMap] ```  ## What I expected  I expected the list to be serialized properly like this:  ```json [1,2,3] ```  # Workarounds  Those three workarounds work:  ```kotlin     @Serializable     data class Wrapper(val content: List)     @GetMapping(""/"")     fun working() = Wrapper(listOf(1, 2, 3)) ```  ```kotlin     @GetMapping(""/"", produces = [""application/json""])     fun working() = Json.encodeToString(listOf(1, 2, 3)) ```  ```kotlin     @GetMapping(""/working"")     fun working() = Json.encodeToJsonElement(listOf(1, 2, 3)) ```","closed","type: bug,","Ersikan","2020-11-24T16:31:00Z","2020-12-18T17:12:14Z"
"","26216","Wrong HttpServletMapping used on INCLUDE in UrlPathHelper.skipServletPathDetermination","**Affects:** 5.3.1  In `UrlPathHelper.skipServletPathDetermination()` the servlet mapping from the request is used. But if the request is processing an include then the mapping in the request is for the original path. The servlet mapping for the include is in the request attribute `RequestDispatcher.INCLUDE_MAPPING` (""javax.servlet.include.mapping"").  So that method uses the wrong servlet mapping and therefore in some cases return the wrong result. And I'm guessing the same goes for when there's a forward, but that I haven't verified. Then the servlet mapping is in `RequestDispatcher.FORWARD_MAPPING`.  Or is this an issue with the container? In my case I use tomcat 9.0.39.","closed","type: bug,","bergander","2020-12-04T14:22:10Z","2020-12-08T09:29:43Z"
"","26207","Filename path is stripped for CommonsMultipartFile but not for StandardMultipartFile","**Affects:** 5.3.1  ---  `MultipartFile#getOriginalFilename` says in the Javadoc:  > This may contain path information depending on the browser used,  but it typically will not with any other than Opera.  But for CommonsMultipartFile (one of the two provided implementations of the `MultiPartFile` interface) there is actually a config option `setPreserveFilename()` which controls whether the path will be stripped away or not. `StandardMultipartFile` doesn't do that and doesn't have the config option. But actually the path stripping is done by Spring code, not Apache Commons code, see   I would suggest to use the path stripping code also for `StandardMultipartFile`, or would there be any reason not to?","closed","status: declined,","jhyot","2020-12-03T12:41:27Z","2021-01-20T11:09:59Z"
"","26124","Spring r2dbc ColumnMapRowMapper wrong mapping when using MySQL driver","**Affects:** 5.3.1  ---  ```kotlin var collectList = r2dbcEntityTemplate.databaseClient.sql(""""""             select * from pending_message         """""".trimIndent()) //                .map(EntityRowMapper(PendingMessage::class.java,r2dbcConverter))                 .fetch()                 .all()                 .collectList().block() ``` When I use `DatabaseClient`, the `fetch` method is mapped incorrectly.  For example:  the order of returned field values is: a -> a, b -> b, c -> c, d -> d, But the final map obtained is: c -> a, a -> b, d -> c, b -> d.","closed","for: external-project,","wangxing-git","2020-11-20T02:03:28Z","2021-09-15T11:08:22Z"
"","26164","ResponseStatusExceptionHandler should respond with the message of exception to clients","**Affects:** 5.3.1  --- **Motivation** We have an internal website for our administrators, and if our website sends an illegal request to the server, the server should respond with both the status code and the error details so that we can know what happens. But ResponseStatusExceptionHandler just sends the status code to clients currently.  ![image](https://user-images.githubusercontent.com/44962329/100446667-29ff2680-30ea-11eb-83d2-06e9f46854ed.png)   **Solution** Allow developers to choose whether to respond with the error message to clients.","closed","in: web,","JamesChenX","2020-11-27T11:54:11Z","2020-12-01T09:34:30Z"
"","26048","Spring frameworh 5.3.0 does not find beans in external jars.","**Affects:** 5.3.0  --- I have 2 beans:  1. the first one (`org.xxx.spring.multi.ExternalAPIOperation`) is in SubSpring module and  2. the second (`org.xxx.spring.multi.InternalAPIOperation`) is in MainSpring module.    An application is in MainSpring.   **Problem**  The bean from SubSpring module (`org.xxx.spring.multi.ExternalAPIOperation`) is not included into the context.   Steps to reproduce   1. Build an attached project. 2. Go to MainSpring module. 3. Run  java -cp target/mainspring-1.0-SNAPSHOT.jar;../SubSpring/target/subspring-1.0-SNAPSHOT.jar org.xxx.spring.multi.Application 4. Output ``` APIOperation classes: org.xxx.spring.multi.InternalAPIOperation org.xxx.spring.multi.ExternalAPIOperation APIOperation beans: org.xxx.spring.multi.InternalAPIOperation ``` 5. Expected output ``` APIOperation classes: org.xxx.spring.multi.InternalAPIOperation org.xxx.spring.multi.ExternalAPIOperation APIOperation beans: org.xxx.spring.multi.InternalAPIOperation org.xxx.spring.multi.ExternalAPIOperation ```   [TestSpringMulti.zip](https://github.com/spring-projects/spring-framework/files/5508697/TestSpringMulti.zip)","closed","status: duplicate,","iusaspb","2020-11-09T08:39:41Z","2020-11-09T10:39:57Z"
"","25910","Optimize Jackson resource management in codecs","**Affects:** 5.2.9.RELEASE  --- `Jackson2JsonEncoder` does not release `BufferRecycler` resources (i.e. does not close JsonGenerator and does not release ByteArrayBuilder which use jackson BufferRecycler)   Benchmark https://github.com/robotmrv/jackson-encoder-jmh shows that resources release  could improve performance especially for small Json objects (SMALL case execution time reduction: `(7568-836)/7568*100%` = `89%` , and allocations reduction by `(18912 - 904)/18912 * 100%` = `95%` ). ``` Benchmark                                                              (size)    Mode      Cnt         Score       Error   Units EncoderBenchmark.standard                                               SMALL  sample  1242327      7568.757 ±   504.091   ns/op EncoderBenchmark.standard:standard·p0.00                                SMALL  sample               1200.000               ns/op EncoderBenchmark.standard:standard·p0.50                                SMALL  sample               4200.000               ns/op EncoderBenchmark.standard:standard·p0.90                                SMALL  sample               5200.000               ns/op EncoderBenchmark.standard:standard·p0.95                                SMALL  sample               5496.000               ns/op EncoderBenchmark.standard:standard·p0.99                                SMALL  sample              17600.000               ns/op EncoderBenchmark.standard:standard·p0.999                               SMALL  sample             656752.640               ns/op EncoderBenchmark.standard:standard·p0.9999                              SMALL  sample            5092737.024               ns/op EncoderBenchmark.standard:standard·p1.00                                SMALL  sample           63635456.000               ns/op EncoderBenchmark.standard:·gc.alloc.rate                                SMALL  sample        3     16876.982 ± 15567.406  MB/sec EncoderBenchmark.standard:·gc.alloc.rate.norm                           SMALL  sample        3     18912.820 ±     1.751    B/op EncoderBenchmark.standard:·gc.churn.PS_Eden_Space                       SMALL  sample        3     16984.177 ± 20148.650  MB/sec EncoderBenchmark.standard:·gc.churn.PS_Eden_Space.norm                  SMALL  sample        3     19025.003 ±  7094.976    B/op EncoderBenchmark.standard:·gc.churn.PS_Survivor_Space                   SMALL  sample        3         0.276 ±     0.487  MB/sec EncoderBenchmark.standard:·gc.churn.PS_Survivor_Space.norm              SMALL  sample        3         0.309 ±     0.257    B/op EncoderBenchmark.standard:·gc.count                                     SMALL  sample        3       123.000              counts EncoderBenchmark.standard:·gc.time                                      SMALL  sample        3        88.000                  ms EncoderBenchmark.standard                                              MEDIUM  sample  1168448      6943.506 ±   221.997   ns/op EncoderBenchmark.standard:standard·p0.00                               MEDIUM  sample               3000.000               ns/op EncoderBenchmark.standard:standard·p0.50                               MEDIUM  sample               5096.000               ns/op EncoderBenchmark.standard:standard·p0.90                               MEDIUM  sample               6096.000               ns/op EncoderBenchmark.standard:standard·p0.95                               MEDIUM  sample               6496.000               ns/op EncoderBenchmark.standard:standard·p0.99                               MEDIUM  sample              16096.000               ns/op EncoderBenchmark.standard:standard·p0.999                              MEDIUM  sample             275968.000               ns/op EncoderBenchmark.standard:standard·p0.9999                             MEDIUM  sample            2448839.475               ns/op EncoderBenchmark.standard:standard·p1.00                               MEDIUM  sample           30343168.000               ns/op EncoderBenchmark.standard:·gc.alloc.rate                               MEDIUM  sample        3     17321.737 ±  6117.869  MB/sec EncoderBenchmark.standard:·gc.alloc.rate.norm                          MEDIUM  sample        3     20584.740 ±     0.986    B/op EncoderBenchmark.standard:·gc.churn.PS_Eden_Space                      MEDIUM  sample        3     17373.760 ±  8861.711  MB/sec EncoderBenchmark.standard:·gc.churn.PS_Eden_Space.norm                 MEDIUM  sample        3     20645.069 ±  5169.821    B/op EncoderBenchmark.standard:·gc.churn.PS_Survivor_Space                  MEDIUM  sample        3         0.348 ±     1.126  MB/sec EncoderBenchmark.standard:·gc.churn.PS_Survivor_Space.norm             MEDIUM  sample        3         0.414 ±     1.491    B/op EncoderBenchmark.standard:·gc.count                                    MEDIUM  sample        3       156.000              counts EncoderBenchmark.standard:·gc.time                                     MEDIUM  sample        3        89.000                  ms EncoderBenchmark.standard                                                 BIG  sample  1108559     25400.314 ±   383.783   ns/op EncoderBenchmark.standard:standard·p0.00                                  BIG  sample              21184.000               ns/op EncoderBenchmark.standard:standard·p0.50                                  BIG  sample              22272.000               ns/op EncoderBenchmark.standard:standard·p0.90                                  BIG  sample              23296.000               ns/op EncoderBenchmark.standard:standard·p0.95                                  BIG  sample              24288.000               ns/op EncoderBenchmark.standard:standard·p0.99                                  BIG  sample              58752.000               ns/op EncoderBenchmark.standard:standard·p0.999                                 BIG  sample             515584.000               ns/op EncoderBenchmark.standard:standard·p0.9999                                BIG  sample            3512631.296               ns/op EncoderBenchmark.standard:standard·p1.00                                  BIG  sample           51118080.000               ns/op EncoderBenchmark.standard:·gc.alloc.rate                                  BIG  sample        3      9092.443 ±  1508.929  MB/sec EncoderBenchmark.standard:·gc.alloc.rate.norm                             BIG  sample        3     45650.467 ±     3.312    B/op EncoderBenchmark.standard:·gc.churn.PS_Eden_Space                         BIG  sample        3      9174.451 ±  3205.813  MB/sec EncoderBenchmark.standard:·gc.churn.PS_Eden_Space.norm                    BIG  sample        3     46060.476 ± 11092.691    B/op EncoderBenchmark.standard:·gc.churn.PS_Survivor_Space                     BIG  sample        3         0.323 ±     1.038  MB/sec EncoderBenchmark.standard:·gc.churn.PS_Survivor_Space.norm                BIG  sample        3         1.620 ±     5.011    B/op EncoderBenchmark.standard:·gc.count                                       BIG  sample        3       163.000              counts EncoderBenchmark.standard:·gc.time                                        BIG  sample        3        90.000                  ms EncoderBenchmark.withCloseAndRelease                                    SMALL  sample  1396264       836.310 ±   107.060   ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.00          SMALL  sample                500.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.50          SMALL  sample                600.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.90          SMALL  sample                600.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.95          SMALL  sample                700.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.99          SMALL  sample                700.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.999         SMALL  sample              19680.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.9999        SMALL  sample             442041.088               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p1.00          SMALL  sample           27131904.000               ns/op EncoderBenchmark.withCloseAndRelease:·gc.alloc.rate                     SMALL  sample        3      7274.705 ±  5323.424  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.alloc.rate.norm                SMALL  sample        3       904.073 ±     0.186    B/op EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Eden_Space            SMALL  sample        3      7329.033 ±  6542.575  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Eden_Space.norm       SMALL  sample        3       910.611 ±   165.411    B/op EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Survivor_Space        SMALL  sample        3         0.291 ±     1.342  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Survivor_Space.norm   SMALL  sample        3         0.036 ±     0.171    B/op EncoderBenchmark.withCloseAndRelease:·gc.count                          SMALL  sample        3       175.000              counts EncoderBenchmark.withCloseAndRelease:·gc.time                           SMALL  sample        3        89.000                  ms EncoderBenchmark.withCloseAndRelease                                   MEDIUM  sample  1343486      2877.905 ±   109.585   ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.00         MEDIUM  sample               2100.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.50         MEDIUM  sample               2400.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.90         MEDIUM  sample               2500.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.95         MEDIUM  sample               2600.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.99         MEDIUM  sample               3500.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.999        MEDIUM  sample              63520.832               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.9999       MEDIUM  sample             762522.931               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p1.00         MEDIUM  sample           14794752.000               ns/op EncoderBenchmark.withCloseAndRelease:·gc.alloc.rate                    MEDIUM  sample        3      4904.697 ±   344.229  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.alloc.rate.norm               MEDIUM  sample        3      2536.282 ±     0.168    B/op EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Eden_Space           MEDIUM  sample        3      4964.870 ±   516.275  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Eden_Space.norm      MEDIUM  sample        3      2567.401 ±   213.382    B/op EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Survivor_Space       MEDIUM  sample        3         0.197 ±     1.073  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Survivor_Space.norm  MEDIUM  sample        3         0.102 ±     0.561    B/op EncoderBenchmark.withCloseAndRelease:·gc.count                         MEDIUM  sample        3       127.000              counts EncoderBenchmark.withCloseAndRelease:·gc.time                          MEDIUM  sample        3        77.000                  ms EncoderBenchmark.withCloseAndRelease                                      BIG  sample  1172404     23765.922 ±   183.083   ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.00            BIG  sample              20672.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.50            BIG  sample              21600.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.90            BIG  sample              22496.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.95            BIG  sample              23072.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.99            BIG  sample              50944.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.999           BIG  sample             366592.000               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p0.9999          BIG  sample            1568845.824               ns/op EncoderBenchmark.withCloseAndRelease:withCloseAndRelease·p1.00            BIG  sample           19070976.000               ns/op EncoderBenchmark.withCloseAndRelease:·gc.alloc.rate                       BIG  sample        3      5693.537 ±   619.550  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.alloc.rate.norm                  BIG  sample        3     27100.606 ±     0.954    B/op EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Eden_Space              BIG  sample        3      5857.821 ±  3192.046  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Eden_Space.norm         BIG  sample        3     27880.071 ± 12267.127    B/op EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Survivor_Space          BIG  sample        3         0.185 ±     0.779  MB/sec EncoderBenchmark.withCloseAndRelease:·gc.churn.PS_Survivor_Space.norm     BIG  sample        3         0.879 ±     3.722    B/op EncoderBenchmark.withCloseAndRelease:·gc.count                            BIG  sample        3       139.000              counts EncoderBenchmark.withCloseAndRelease:·gc.time                             BIG  sample        3        77.000                  ms ``` Probably all places which use `com.fasterxml.jackson.core.JsonFactory#_getBufferRecycler` should be managed properly","closed","type: enhancement,","robotmrv","2020-10-13T12:48:03Z","2020-10-20T13:42:36Z"
"","25965","Correct DispatcherServlet initialization sample webmvc.adoc","**Affects:** 5.2.9  --- The example uses ac.refresh(); but throws an exception. Everything works perfectly without it.","closed","type: task,","chereshnyabtw","2020-10-23T15:44:28Z","2020-10-26T07:50:32Z"
"","26202","Clarify intended advice execution behavior in Spring version 5.2.7+","**Affects:** 5.2.7.RELEASE  StackOverflow question : https://stackoverflow.com/q/65032499/4214241  Sample Github project shared for the question : https://github.com/RitamChakraborty/bank_transaction_springaop/tree/r_g_answer  Issue descrption :   The following `@AfterThrowing` advice does not work as expected in Spring versions above : 5.2.6.RELEASE ```  @After(""execution(public void dev.ritam.model.Bank.setTempPin(..))"") public void validatePin() {     if (bank.getPinCode() != bank.getTempPin()) {         throw new RuntimeException(""Wrong Pin"");     } else {         System.out.println(""Correct Pin"");     } }  @AfterThrowing(value = ""execution(public void dev.ritam.model.Bank.setTempPin(..))"", throwing = ""e"") public void logException(Exception e) {     System.out.println(e.getMessage()); }   ``` For spring versions above : 5.2.6.RELEASE ( tested with releases 5.2.7.RELEASE,5.2.8.RELEASE,5.2.9.RELEASE,5.3.1)  `@AfterThrowing` advice does not execute on exception from `@After` advice. The same results if `@After` advice is replaced with `@Before`.  For spring versions equal to or below : 5.2.6.RELEASE ( tested with releases 5.2.6.RELEASE,5.2.5.RELEASE,5.2.4.RELEASE, 5.2.3.RELEASE) , the advice happens from `@AfterThrowing` on exception from `@After`","closed","in: core,","ranjit-g","2020-12-03T07:52:02Z","2020-12-08T13:31:50Z"
"","26358","Request to log stack trace in AbstractHandlerExceptionResolver when enable `warnLogCategory`","**Affects:** 5.2.12.RELEASE  ---  Currently by default HandlerExceptionResolvers which enabled `warnLogCategory` only log a simple message such like ""Resolved []"" without the stack trace, which is difficult to debug. Suggest to also log stack trace (https://github.com/spring-projects/spring-framework/blob/e36d4162c254826d8cde048bd17691e312b4fcaa/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerExceptionResolver.java#L207)  Interestingly, this behavior was introduced in https://github.com/spring-projects/spring-framework/issues/17691 (https://github.com/spring-projects/spring-framework/commit/a08c9f3137d114bbdd0cdb2800024d45a6a21e3a#diff-79219eb3028165aaa060f6e3db7e70a2a50b5dccd01387f03fed02a3bdf89ca8L183-R186), maybe we can balance the needs by introduce another option to enable/ disable logging stack trace.","closed","status: declined,","sammyhk","2021-01-08T03:42:22Z","2021-01-08T12:42:01Z"
"","26246","AbstractJackson2HttpMessageConverter writes partial data when exception occurs during write","**Affects:** 5.2.10.RELEASE and later  ---  The AbstractJackson2HttpMessageConverter.writeInteral method was modified to use a try with resources block to optimize Jackson resource management [gh-25910](https://github.com/spring-projects/spring-framework/issues/25910). This now calls close on the JsonGenerator in the event of an error such as a JsonProcessingException, which flushes what was written before the error occurred to the response body. When attempting to return a customized error response from a ControllerAdvice, the response body will contain the data written before the exception was thrown concatenated with the data written by the ControllerAdvice. This leads to an invalid response being returned to the client.","closed","type: regression,","jdelong747","2020-12-08T15:14:19Z","2020-12-08T20:19:09Z"
"","26152","Error 415 when handle a multipart form request with RequestEntity>","**Affects:** 5.2.0 I'm try to handle a multipart request with follow code: ```java // A RestController @RequestMapping(path = ""form"", consumes = {MediaType.MULTIPART_FORM_DATA_VALUE, MediaType.APPLICATION_FORM_URLENCODED_VALUE}) public void testFrom(RequestEntity> requestEntity) {     log.info(requestEntity.toString()); } ``` then tomcat return a 415 code with console output: ``` 2020-11-25 14:42:16,244 WARN  (AbstractHandlerExceptionResolver.java:199) - Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/x-www-form-urlencoded;charset=UTF-8' not supported] ``` if i use code like this, everything works well: ```java @RequestMapping(path = ""form"", consumes = {MediaType.MULTIPART_FORM_DATA_VALUE, MediaType.APPLICATION_FORM_URLENCODED_VALUE}) public void testFrom(@RequestBody MultiValueMap requestEntity) {     log.info(requestEntity.toString()); } ``` After some debug of spring's code, I found in `org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor#resolveArgument`, calling  `getHttpEntityType` returns a ParameterizedType. But when calling  `org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters(org.springframework.http.HttpInputMessage, org.springframework.core.MethodParameter, java.lang.reflect.Type)` to convert request body, following code make the `targetClass` become `RequestEntity` instead of `MultiValueMap`, cause the fail of message convertion. ```java Class targetClass = (targetType instanceof Class ? (Class) targetType : null); if (targetClass == null) { 	ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter); 	targetClass = (Class) resolvableType.resolve(); } ``` Is it a bug?","open","in: web,","ztyzbb","2020-11-25T07:03:27Z","2021-11-08T11:46:10Z"
"","26408","Netty4ClientHttpRequest appends duplicate Host headers to requests","**Affects:** 4.3.24  We have a requirement to set the `Host` header with our own some ""xyz"" value and use it in Nginx.   [By debugging the code here](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/client/Netty4ClientHttpRequest.java#L141), I found that one `Host` header is set with a value of URI in `Netty4ClientHttpRequest` class using a `Set` method. The other headers are added in line 143 using the `add` method.   As a result, when this piece of code runs, there are two `Host` header one with the value of URI and one with our own ""xyz"" value, and the `Host` header with a value of URI takes precedence and it hides our `Host` header with ""xyz"" value.   Is there any way possible by which we can override the `Host` header with our own value?","closed","status: invalid,","krunalyadav","2021-01-20T06:46:54Z","2021-01-20T14:02:26Z"
"","26389","Payload value must not be empty for Acknowledgment parameter","**Affects:** 2.3.7.RELEASE  ---   I have a `@KafkaListener` with this signature:  ```     @KafkaListener(topics = ""${matcher.reply.channel:matcher_response${matcher.kafka.topic.suffix}}"")     public void processMessage(@Payload ConsumerRecord record, Acknowledgment acknowledgment) {  ```  When I receive a message I get an exception that `Payload value must not be empty` about the `acknowledgment` parameter:  ``` [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] SeekToCurrentErrorHandler - Backoff none exhausted for ConsumerRecord(topic = multilateral_matcher_results, partition = 0, leaderEpoch = 0, offset = 2, CreateTime = 1610624163545, serialized key size = -1, serialized value size = 76, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = {""matchProcessId"":""dc033ece-4e0e-4a60-86ce-7f8071678418"",""status"":""SUCCESS""}) org.springframework.kafka.listener.ListenerExecutionFailedException: Listener method could not be invoked with the incoming message Endpoint handler details: Method [public void com.capitolis.matcher_client.kafka.consumer.MatcherReplyKafkaConsumer.processMessage(org.apache.kafka.clients.consumer.ConsumerRecord,org.springframework.kafka.support.Acknowledgment)] Bean [com.capitolis.matcher_client.kafka.consumer.MatcherReplyKafkaConsumer@193f5509]; nested exception is org.springframework.messaging.handler.annotation.support.MethodArgumentNotValidException: Could not resolve method parameter at index 1 in public void com.capitolis.matcher_client.kafka.consumer.MatcherReplyKafkaConsumer.processMessage(org.apache.kafka.clients.consumer.ConsumerRecord,org.springframework.kafka.support.Acknowledgment): 1 error(s): [Error in object 'acknowledgment': codes []; arguments []; default message [Payload value must not be empty]] , failedMessage=GenericMessage [payload=org.springframework.kafka.support.KafkaNull@437ffb4f, headers={id=99763706-5013-dcae-a45a-16485a65854e, timestamp=1610624118214}]; nested exception is org.springframework.messaging.handler.annotation.support.MethodArgumentNotValidException: Could not resolve method parameter at index 1 in public void com.capitolis.matcher_client.kafka.consumer.MatcherReplyKafkaConsumer.processMessage(org.apache.kafka.clients.consumer.ConsumerRecord,org.springframework.kafka.support.Acknowledgment): 1 error(s): [Error in object 'acknowledgment': codes []; arguments []; default message [Payload value must not be empty]] , failedMessage=GenericMessage [payload=org.springframework.kafka.support.KafkaNull@437ffb4f, headers={id=99763706-5013-dcae-a45a-16485a65854e, timestamp=1610624118214}] ```  I guess that if the `PayloadMethodArgumentResolver` already handled the payload argument it should not be activated again for another argument. Maybe add a `boolean resolveOnlyOneArgument()` method to the `HandlerMethodArgumentResolver` interface and use that method somehow in the `HandlerMethodArgumentResolverComposite` and the `getMethodArgumentValues()` method of `InvocableHandlerMethod`.  Removing the `Acknowledment` argument worked around the problem for me but for some scenarios it may be required and can't be removed","closed","for: external-project,","selalerercapitolis","2021-01-14T16:36:48Z","2021-01-17T19:07:32Z"
"","26002","spring-mongodb: MappingMongoConverter appears to be using a Maps Value Type to serialise it's Key for Custom Map implementations","**Affects:** <2.1.8  --- I have a custom map implementation  ``` class IdentityMap : MutableMap ```  And I have registered a ``` @WritingConverter class IdentityWriteConverter : Converter ``` and a  ``` @ReadingConverter class IdentityReadConverter : Converter ``` so that Spring know how to handle the complex key type.  I use this in a `@Document` ``` @Document class Cache(     val id: String,     val timestamps: IdentityMap = emptyIdentityMap() ) ```  When saving this document, it generates the expected JSON, however when reading it, the MappingMongoConverter appears to be trying to use the Value Type (Instant in this case) to convert the Key (String) and ends up throwing a  `No converter found capable of converting from type String to type Instant` `ConverterNotFoundException` here:  https://github.com/spring-projects/spring-data-mongodb/blob/6ab43c239191b8e48b257671ffbbb91259d5366d/spring-data-mongodb/src/main/java/org/springframework/data/mongodb/core/convert/MappingMongoConverter.java#L1180  For whatever reason, the two lines a bit higher in the method ``` Class rawKeyType = keyType != null ? keyType.getType() : null; Class rawValueType = valueType != null ? valueType.getType() : null; ``` are both pulling the same type out, `Instant`. Even though the key type of my map implementation is an `Identity`.","closed","for: external-project,","ed0906","2020-10-30T20:26:45Z","2020-11-01T13:53:02Z"
"","26161","Allow RestTemplate JSON MessageMappers to take higher precedence than XML ones (even if XML mapping libraries are present)","**Affects:**  Spring Framework (web) < 5.3.1  ---  While improving an existing architectural component (used by many microservices) we have found the need to use jackson-dataformat-xml mappers to cope with legacy XML structures. This has effectively made every spring boot microservice that, in turn, includes this component, to change it's restTemplate default behavior from sending application/JSON requests to sending application/XML requests (and, of course, mapping it's postForObject payloads as XML instead of JSON) and breaking everything.  I've been googling extensively and found several references to simmilar problems: https://stackoverflow.com/questions/57706610/how-to-set-default-messageconverter-to-json-with-jackson-dataformat-xml-added/58376392#58376392 https://stackoverflow.com/questions/47894619/spring-resttemplate-message-converter-priority-when-posting https://stackoverflow.com/questions/57343161/spring-resttemplate-selecting-messageconverter-to-use https://stackoverflow.com/questions/9381665/how-can-we-configure-the-internal-jackson-mapper-when-using-resttemplate  But it seems there is no other way around this behaviour than adding explicit header information to every restTemplate request (wich involves a lot of code changes).  In spring framework 5.3.1 we have seen the _spring.xml.ignore_ property, but this could effectively disable a lot of xml-based functions that may affect other features (logback.xml configuration, maybe?  Nowadays JSON payloads are extremely popular versus XML ones, and developers using restTemplate are often confident that JSON will always be their restTemplate's default format.  I suggest altering the order on which the RestTemplate adds mappers in its default constructor, moving the XML mappers below JSON ones, so JSON keeps on taking precedence even if some third-party library on your microservice depends on the XML mapping libraries, or at least adding a property to influence this behavior (while not altering backwards compatibility) so you can keep on using JSON mappers despite imported libraries.","closed","status: declined,","mediocaballero","2020-11-26T18:23:19Z","2021-02-25T11:53:38Z"
"","26365","Optimistic lock does not work correctly when REST call is received","**Affects:**  Spring boot 2.4.1 and earlier **Affects:**  spring-boot-starter-data-jpa 2.4.1 and earlier **Affects:**  spring-boot-starter-web 2.4.1 and earlier  **Description:** I found out that optimistic lock does not work correctly in a case when a method, which can produce it, is called via REST controller.  As an example, the following method of a service must produce an optimistic lock exception every time it is called (let assume that a book entity is already created in the database):  ```java 1  public void produceOptimisticLock(Long id) { 2   Book found = bookRepository.findById(id) 3        .orElseThrow(() -> new RuntimeException(""Oops"")); 4    found.setName(""optLock !""); 5    found.setVersion(-777L); 6    save(found); 7  } ```  Because there is no _@Transaction_ annotation above the method and a read only transaction as well as hibernate session are created on line 2, then entity is loaded and got a DETACHED status. After that on line 6 a new transaction as well as hibernate session are created to merge  ""found"" entity changes. Finally _DefaultMergeEventListener_ (hibernate) produces a new optimistic lock exception, because the entity is processed as DETACHED (_entityIsDetached_ method) and the version field was changed. It works correctly when it is called internally in an application.   But it does not work at all when it is called as part of REST request handling. Because _OpenEntityManagerInViewFilter_ delegates _OpenEntityManagerInViewInterceptor_ to create a new entity manager instance which creates one hibernate session to process entire request. In this case on line 2 the ""found"" entity is cached by _StatefulPersistenceContext_ which leads to a problem on line 6, because the session is still alive/active _StatefulPersistenceContext_ still contains ""found"" entity in L1 cache. In this case entity state is resolved as PERSISTENT in _DefaultMergeEventListener.onMerge_ method. It means that ""found"" entity is processed as  PERSISTENT in _entityIsPersistent_ method of _DefaultMergeEventListener_. _entityIsPersistent_ does not check if the version is changed. Because of it ""found"" entity is saved on line 6 without any optimistic lock exception.  I guess this method should work always identical and produces the optimistic lock exception. Am i right ?   I created a demo project to produce this problem: https://github.com/Dennisber00/spring-opt-log-bug  **Step to reproduce in the demo project**  No optimistic lock exception: 1. Run the app 2. Send a rest call -  http://localhost:8080/book/opt-lock/1 3. Open h2 console http://localhost:8088/h2-console/ 4. Execute ""select * from book"" 5. Check that entity with ID - 1 was successfully updated (version was increased to 1)  Optimistic lock exception: 1. Open application.properties 2. Change _do.magic.fire.opt.lock=false_ -> _do.magic.fire.opt.lock=true_ property 3. Run the app 4. The app should be crashed with optimistic lock exception due to _DoMagic_ event listener class which receives ApplivaitonReadyEvent and calls _produceOptimisticLock_ method. ---","open","in: data,","Dennisber00","2021-01-09T16:57:05Z","2021-11-10T12:13:43Z"
"","26200","WebFlux response type mangling","**Affects:**  2.4.0  ---   Implementing `PATCH` in WebFlux is giving me issues trying to return a 404 with the following code. The compiler complains that a `Mono>` is being returned instead of a `Mono>`  ```java   public Mono> updatePost(       UUID postId, Mono updatePostRequest) {     Mono post = REPOSITORY.findById(postId);     return post.zipWith(updatePostRequest)         .map(             zip ->                 zip.getT1().toBuilder()                     .title(                         zip.getT2().getUpdateMask().contains(PostUpdateMask.TITLE)                             ? zip.getT2().getTitle()                             : zip.getT1().getTitle())                     .summary(                         zip.getT2().getUpdateMask().contains(PostUpdateMask.SUMMARY)                             ? zip.getT2().getSummary()                             : zip.getT1().getSummary())                     .markdown(                         zip.getT2().getUpdateMask().contains(PostUpdateMask.MARKDOWN)                             ? zip.getT2().getMarkdown()                             : zip.getT1().getMarkdown())                     .imageUrl(                         zip.getT2().getUpdateMask().contains(PostUpdateMask.IMAGE_URL)                             ? zip.getT2().getImageUrl()                             : zip.getT1().getImageUrl())                     .build())         .map(REPOSITORY::save)         .thenReturn(noContent().build());         //.defaultIfEmpty(notFound().build());         // ^^ The offender   } ```","closed","for: stackoverflow,","optimisticninja","2020-12-02T16:59:52Z","2020-12-03T09:21:01Z"
"","26360","Add API to use ParameterizedTypeReference on RequestEntity Function on Get / Post function, like exchange.","**Affects:**    If this is not the right place for this issue, please let me know.  ---   Hello  I think that **exchange, getForEntity, postForEntity function** which is in RestTemplate, Spring web Framework is designed to receive ResponseEntities from each http method request like below. And there's no guide in docs ever, so users are using same purpose depending on their needs.   ```java @Override 	public  ResponseEntity exchange(String url, HttpMethod method, 			@Nullable HttpEntity requestEntity, Class responseType, Object... uriVariables) 			throws RestClientException {  		RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType); 		ResponseExtractor> responseExtractor = responseEntityExtractor(responseType); 		return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables)); 	} ```  ```java @Override 	public  ResponseEntity getForEntity(String url, Class responseType, Object... uriVariables) 			throws RestClientException {  		RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); 		ResponseExtractor> responseExtractor = responseEntityExtractor(responseType); 		return nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables)); 	} ```  ```java @Override 	public  ResponseEntity postForEntity(String url, @Nullable Object request, 			Class responseType, Object... uriVariables) throws RestClientException {  		RequestCallback requestCallback = httpEntityCallback(request, responseType); 		ResponseExtractor> responseExtractor = responseEntityExtractor(responseType); 		return nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables)); 	} ```  However, Spring Web supports **ParameterizedTypeReference** for mapping response to any Type like Collections in **exchange**. On the other hand, **getForEntity, postForEntity** are not supported.   ```java @Override 	public  ResponseEntity exchange(RequestEntity entity, ParameterizedTypeReference responseType) 			throws RestClientException {  		Type type = responseType.getType(); 		RequestCallback requestCallback = httpEntityCallback(entity, type); 		ResponseExtractor> responseExtractor = responseEntityExtractor(type); 		return nonNull(doExecute(resolveUrl(entity), entity.getMethod(), requestCallback, responseExtractor)); 	} ```  Therefore request for applying on **getForEntity, postForEntity** using **ParameterizedTypeReference**. Spring is designed to allow programmers to use freely without limitation, so I personally think adaptation is required.","closed","status: superseded,","Hubtwork","2021-01-08T09:40:23Z","2021-01-08T12:26:12Z"
"","26221","Add in the 'Build from Source' page: what must be the minimum or/and specific Gradle version to develop Spring","---   In the [Build from Source](https://github.com/spring-projects/spring-framework/wiki/Build-from-Source) section/page, it has the `Build from the Command Line` section, in case the developer has many Gradle versions installed in the machine, for contributor purposes (play or do some experiments with the project itself).   * Why not include explicitly a special note or add a new section indicating what must be the _minimum_ **or/and** _specific_ `Gradle` version?  It to import in peace the `spring framework` project in the IDE and avoid potential daemon locks by Gradle.  Remember, in the machine would exists many Gradle versions, 6.6, 6.7 etc installed. So Gradle wrapper would be not an option.  Thanks for your understanding","closed","status: declined,","manueljordan","2020-12-05T20:49:49Z","2020-12-06T18:24:32Z"
"","25988","enhancements for spring-webflux",": ![image](https://user-images.githubusercontent.com/24351983/97524439-a285a100-19df-11eb-9048-17fa968403fa.png)  For enhancements, provide context and describe the problem. context&problem: When I use webclient to request an http address with optional request parameters, even if I pass a null value to the optional parameter, the null value will be changed to an empty string in the final request ![image](https://user-images.githubusercontent.com/24351983/97524543-e8db0000-19df-11eb-9434-2e337123d3a4.png)  ![image](https://user-images.githubusercontent.com/24351983/97524207-0c517b00-19df-11eb-8360-5de8c382bff4.png) Can webclient automatically recognize the request parameter that is null, and then not display it in the request address? Means that when'org_team' is null, the last request address is'/api/list_sla_instances?bu=%E9%85%92%E5%BA%97%E6%97%85%E6%B8%B8&bg=%E9 %85%92%E5%BA%97&dateKey=2020-10-29'","closed","","binggo-top","2020-10-29T04:08:48Z","2020-10-29T12:21:44Z"
"","25964","Cannot build Spring with OpenJDK 8 on Linux","1. Install OpenJDK and use it as default one (output of `echo $JAVA_HOME` is `/usr/lib/jvm/java-8-openjdk-amd64` 2. Checkout Spring 3. Build as specified in https://github.com/spring-projects/spring-framework/wiki/Build-from-Source (`./gradlew build`) 4. Go to console and see compilation errors: ```shell s.tsypanov@UAIEV8529NBL:~/IdeaProjects/spring-framework$ ./gradlew build  Welcome to Gradle 6.7!  Here are the highlights of this release:  - File system watching is ready for production use  - Declare the version of Java your build requires  - Java 15 support  For more details see https://docs.gradle.org/6.7/release-notes.html  Starting a Gradle Daemon, 2 busy and 4 incompatible and 1 stopped Daemons could not be reused, use --status for details  > Task :spring-core:compileJava /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:19: error: package jdk.jfr does not exist import jdk.jfr.Category;               ^ /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:20: error: package jdk.jfr does not exist import jdk.jfr.Description;               ^ /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:21: error: package jdk.jfr does not exist import jdk.jfr.Event;               ^ /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:22: error: package jdk.jfr does not exist import jdk.jfr.Label;               ^ /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:37: error: cannot find symbol class FlightRecorderStartupEvent extends Event {                                          ^   symbol: class Event /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:34: error: cannot find symbol @Category(""Spring Application"")  ^   symbol: class Category /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:35: error: cannot find symbol @Label(""Startup Step"")  ^   symbol: class Label /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:36: error: cannot find symbol @Description(""Spring Application Startup"")  ^   symbol: class Description /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:43: error: cannot find symbol         @Label(""Name"")          ^   symbol:   class Label   location: class FlightRecorderStartupEvent /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupEvent.java:46: error: cannot find symbol         @Label(""Tags"")          ^   symbol:   class Label   location: class FlightRecorderStartupEvent /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupStep.java:47: error: cannot find symbol                 this.event.begin();                           ^   symbol:   method begin()   location: variable event of type FlightRecorderStartupEvent /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupStep.java:86: error: cannot find symbol                 this.event.end();                           ^   symbol:   method end()   location: variable event of type FlightRecorderStartupEvent /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupStep.java:87: error: cannot find symbol                 if (this.event.shouldCommit()) {                               ^   symbol:   method shouldCommit()   location: variable event of type FlightRecorderStartupEvent /home/s.tsypanov/IdeaProjects/spring-framework/spring-core/src/main/java/org/springframework/core/metrics/jfr/FlightRecorderStartupStep.java:94: error: cannot find symbol                 this.event.commit();                           ^   symbol:   method commit()   location: variable event of type FlightRecorderStartupEvent  > Task :spring-core:compileJava FAILED  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-core:compileJava'. > Compilation failed; see the compiler error output for details. ```  Looks like JAR is missing for the following imports ```java import jdk.jfr.Category; import jdk.jfr.Description; import jdk.jfr.Event; import jdk.jfr.Label; ```","closed","status: invalid,","stsypanov","2020-10-23T11:53:19Z","2020-10-23T11:59:11Z"
"","26785","Improve @EventListener documentation in reference manual","1) According to a source code of *ApplicationListenerMethodAdapter* class we can see that return type of a method annotated with *@EventListener* can be not only a *Collection* but also *array*. 2) Method annotated with *@EventListener* can have any visibility (public, protected, package-private and private) and can be final and static.","closed","type: task,","hrybs","2021-04-10T17:46:36Z","2021-04-13T09:27:19Z"
"","26188","AnnotatedElementUtils.getMergedRepeatableAnnotations does not return meta annotations on repeatedly-annotated class","- We use a meta-annotation @As400Sql for the annotation @Sql. It is repeatable. - We annotate DoubleAnnotatedClass.class with two such annotations.  - AnnotatedElementUtils.getMergedRepeatableAnnotations() does then not retreive the @Sql annotations. - When using an intermediate annotation (@TwoSql) it works as expected.  Observed in spring-core 5.2.8.RELEASE via spring-boot 2.3.3.RELEASE  ```java public class As400SqlTest {    @Target({ElementType.TYPE, ElementType.METHOD})   @Retention(RetentionPolicy.RUNTIME)   @Repeatable(As400SqlGroup.class)   @Sql(config = @SqlConfig(dataSource = ""as400DataSource"", transactionManager =       ""as400TransactionManager""))   public @interface As400Sql {      @AliasFor(attribute = ""scripts"", annotation = Sql.class)     String[] value() default {};   }    @Target({ElementType.TYPE, ElementType.METHOD})   @Retention(RetentionPolicy.RUNTIME)   public @interface As400SqlGroup {      As400Sql[] value();   }      @As400Sql(""script1"")   public static class AnnotatedClass {    }    @Test   void getMergedRepeatableAnnotations_shouldReturnSql_forClassWithAs400SqlAnnotation() {     Set actual = AnnotatedElementUtils         .getMergedRepeatableAnnotations(AnnotatedClass.class, Sql.class, SqlGroup.class);      assertThat(actual).hasSize(1);     Sql actual0 = actual.iterator().next();     assertThat(actual0.scripts()).containsExactly(""script1"");     assertThat(actual0.config().dataSource()).isEqualTo(""as400DataSource"");   }     @As400Sql(""script1"")   @As400Sql(""script2"")   public static class DoubleAnnotatedClass {    }    @Disabled(""getMergedRepeatableAnnotations returns 0 annotations - why?"")   @Test   void getMergedRepeatableAnnotations_shouldReturnTwoSql_forDoubleAnnotatedClass() {     Set actual = AnnotatedElementUtils         .getMergedRepeatableAnnotations(DoubleAnnotatedClass.class, Sql.class, SqlGroup.class);      assertThat(actual).hasSize(2);     Iterator actualElements = actual.iterator();     assertThat(actualElements.next().config().dataSource()).isEqualTo(""as400DataSource"");     assertThat(actualElements.next().config().dataSource()).isEqualTo(""as400DataSource"");   }     @As400Sql(""script1"")   @As400Sql(""script2"")   @Retention(RetentionPolicy.RUNTIME)   public @interface TwoSql {    }    @TwoSql   public static class MetaDoubleAnnotatedClass {    }    @Test   void getMergedRepeatableAnnotations_shouldReturnTwoSql_forMetaDoubleAnnotatedClass() {     Set actual = AnnotatedElementUtils         .getMergedRepeatableAnnotations(MetaDoubleAnnotatedClass.class, Sql.class, SqlGroup.class);      assertThat(actual).hasSize(2);     Iterator actualElements = actual.iterator();     assertThat(actualElements.next().config().dataSource()).isEqualTo(""as400DataSource"");     assertThat(actualElements.next().config().dataSource()).isEqualTo(""as400DataSource"");   } } ```","open","in: core,","mischkes","2020-12-01T12:42:07Z","2021-11-10T12:22:52Z"
"","26340","Ensure content-length header is only written once","- undertow sends all content-length headers back to the client causing browser issues - more comments on the issue in #26330  Fixes #26330  Investigative PR","closed","status: superseded,","paulcwarren","2021-01-04T01:22:00Z","2021-01-06T20:04:27Z"
"","26529","AspectJ transaction management and spring.main.lazy-initialization=true","- Spring 5.3.3  - Spring Boot 2.4.2 - AspectJ 1.9.6  We use AspectJ compile Time Weaving to manage `@Transactional` annotations. Everything works fine until we activate `spring.main.lazy-initialization=true`. The Transaction is not started.  The error is somewhere in `TransactionAspectSupport`, as the `beanFactory` is still `null` when running with `lazy-init` activated:  ```java 	protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) { 		// Do not attempt to lookup tx manager if no tx attributes are set 		if (txAttr == null || this.beanFactory == null) { 			return getTransactionManager(); 		} ```  I hope this is a spring issue and not a Spring Boot issue. I searched the docs if `lazy-init` is not supported with AspectJ but I did not found anything and didn't any other issue regarding this bug.    Very small project reproducing the issue: https://github.com/kicktipp/spring-lazy-aspectj-issue  Just checkout and run  ```shell ./gradlew test --tests NonLazyTest ./gradlew test --tests LazyTest ```  First on with success, second one fails.   If you need further information I am eager to help.","open","in: core,","kicktipp","2021-02-09T11:43:49Z","2021-02-09T13:22:39Z"
"","26125","Use Collection View instead of a separate collection","- return a keySet view of map instead of cacheNames - remove cacheNames - simplify get-if-put -> computeIfAbsent - remove synchronized block","closed","","bananayong","2020-11-20T03:43:50Z","2022-02-18T19:06:33Z"
"","25899","Avoid multiple volatile reads/writes in a row where only one is enough","- in `MethodInvocationProceedingJoinPoint` use the same approach as in `InjectionPoint.getAnnotations()` to do only one volatile read for all calls after field initialization instead of two. - in `AutowiredAnnotationBeanPostProcessor` we are guareded by `synchronized` - `AbstractCacheManager` newly created `LinkedHashSet` always has some extra capacity, so calculation of it's size +1 is redundant","closed","type: enhancement,","stsypanov","2020-10-12T17:12:11Z","2020-11-10T14:25:00Z"
"","26238","Possibly redundant code in SerializableTypeWrapper","- in [link](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/SerializableTypeWrapper.java) I read the fortypeprovider method ，I think a piece of code may be redundant   about code   ```java @Nullable 	static Type forTypeProvider(TypeProvider provider) { 		Type providedType = provider.getType(); 		if (providedType == null || providedType instanceof Serializable) { 			// No serializable type wrapping necessary (e.g. for java.lang.Class) 			return providedType; 		} 		if (IN_NATIVE_IMAGE || !Serializable.class.isAssignableFrom(Class.class)) { 			// Let's skip any wrapping attempts if types are generally not serializable in 			// the current runtime environment (even java.lang.Class itself, e.g. on GraalVM native images) 			return providedType; 		}  		// Obtain a serializable type proxy for the given provider... 		Type cached = cache.get(providedType); 		if (cached != null) { 			return cached; 		} 		for (Class type : SUPPORTED_SERIALIZABLE_TYPES) { 			if (type.isInstance(providedType)) { 				ClassLoader classLoader = provider.getClass().getClassLoader(); 				Class[] interfaces = new Class[] {type, SerializableTypeProxy.class, Serializable.class}; 				InvocationHandler handler = new TypeProxyInvocationHandler(provider); 				cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler); 				cache.put(providedType, cached); 				return cached; 			} 		} 		throw new IllegalArgumentException(""Unsupported Type class: "" + providedType.getClass().getName()); 	} ````     `!Serializable.class.isAssignableFrom(Class.class)` The result of this code is always **false**","closed","in: core,","huifer","2020-12-08T07:27:12Z","2020-12-09T00:48:44Z"
"","26024","Lettuce memory leaks (io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected)","**We have the next application setup:** 1) Spring boot `2.0.6.RELEASE` 2) spring-boot-starter-webflux `2.0.6.RELEASE` 3) Lettuce `5.1.6.RELEASE` (use Netty `4.1.29.Final`) 4) Project reactor `io.projectreactor.ipc:reactor-netty:jar:0.7.10.RELEASE`  **What I'm actually trying to do?** We have an application inside a docker container, which consumes more memory than JVM limitations. And yep, the application just got out of memory errors.   I know, that such reactor version (0.7.10) is [kind of old](https://github.com/reactor/reactor-netty/issues/1304#issuecomment-720596737), but anyway, I'm facing the next issues: ``` [2020-11-03 10:34:40,794] ERROR [lettuce-epollEventLoop-6-2] io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information. Recent access records:  #1: 	Hint: 'reactor.right.reactiveBridge' will handle the message from this point. 	io.netty.handler.codec.http.DefaultHttpContent.touch(DefaultHttpContent.java:88) 	io.netty.handler.codec.http.DefaultHttpContent.touch(DefaultHttpContent.java:24) 	io.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:297) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:413) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:410) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:310) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) 	java.base/java.lang.Thread.run(Thread.java:832) #2: 	io.netty.handler.codec.http.DefaultHttpContent.release(DefaultHttpContent.java:94) 	io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88) 	io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:90) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:297) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:413) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:410) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:310) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) 	java.base/java.lang.Thread.run(Thread.java:832) #3: 	io.netty.handler.codec.http.DefaultHttpContent.retain(DefaultHttpContent.java:70) 	io.netty.handler.codec.http.HttpContentDecoder.decode(HttpContentDecoder.java:145) 	io.netty.handler.codec.http.HttpContentDecoder.decode(HttpContentDecoder.java:46) 	io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:88) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:297) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:413) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:410) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:310) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) 	java.base/java.lang.Thread.run(Thread.java:832) #4: 	Hint: 'reactor.left.decompressor' will handle the message from this point. 	io.netty.handler.codec.http.DefaultHttpContent.touch(DefaultHttpContent.java:88) 	io.netty.handler.codec.http.DefaultHttpContent.touch(DefaultHttpContent.java:24) 	io.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310) 	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:297) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:413) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:410) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:310) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) 	java.base/java.lang.Thread.run(Thread.java:832) Created at: 	io.netty.buffer.SimpleLeakAwareByteBuf.unwrappedDerived(SimpleLeakAwareByteBuf.java:143) 	io.netty.buffer.SimpleLeakAwareByteBuf.readRetainedSlice(SimpleLeakAwareByteBuf.java:67) 	io.netty.buffer.AdvancedLeakAwareByteBuf.readRetainedSlice(AdvancedLeakAwareByteBuf.java:107) 	io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:345) 	io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:410) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:310) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) 	java.base/java.lang.Thread.run(Thread.java:832) ```  I really don't understand, why i have such issues with the `lettuce-epollEventLoop` thread?   Actually, in this we have the next reactive places: 1) Reactive WebClient 2) Lettuce for redis template 3) Reactive Mono/Flux usages  How can I fix it? How can I choose the correct versions?  P.S: Tried to increase the version of `lettuce-core` from **5.1.6.RELEASE** to **6.0.1.RELEASE**, but it's not worked for me.","closed","for: external-project,","SlandShow","2020-11-03T11:29:35Z","2020-11-03T15:30:01Z"
"","26582","LinkedMultiValueMap replaces % with %25","**Version: spring-boot-starter-web version 2.4.1.**  Hello,  I am trying to make a post request using LinkedMultiValueMap<>() for authentication but I keep receiving a 400 BAD REQUEST.   When I send it as a raw string I get a 200. Code:    ```   String test = ""client_secret=1234&grant_type=refresh_token&refresh_token=1%2F%2F&client_id=12345"";   ResponseEntity stringResponseEntity = restTemplate.postForEntity(""/token"", test, String.class); ```  ![Screenshot 2021-02-21 at 16 34 13](https://user-images.githubusercontent.com/9571065/108629984-da1eca00-7462-11eb-8dd6-e7418cca75a6.png)  When I send it as a LinkedMultiValueMap<>(). Code:  ```             MultiValueMap formUrlEncoded = new LinkedMultiValueMap<>();         formUrlEncoded.add(""client_secret"", ""1234"");         formUrlEncoded.add(""grant_type"", ""refresh_token"");         formUrlEncoded.add(""refresh_token"", ""1%2F%2F"");         formUrlEncoded.add(""client_id"", ""12345"");          HttpHeaders httpHeaders = new HttpHeaders();         httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);          HttpEntity> httpEntity = new HttpEntity<>(formUrlEncoded, httpHeaders);          ResponseEntity stringResponseEntity = restTemplate.postForEntity(""/token"", httpEntity, String.class); ```  ![Screenshot 2021-02-21 at 16 37 17](https://user-images.githubusercontent.com/9571065/108630046-3bdf3400-7463-11eb-96c0-b338a633eef4.png)  What I noticed is that the value of the **refresh_token is changed** and **% is replaced with %25**??    I know the solution (Send as a string), but still I find this weird and I want to know why this is happening? What am I not seeing?","closed","status: invalid,","M-Smits","2021-02-21T15:42:11Z","2021-02-24T13:07:13Z"
"","26247","Allow next resolver to resolve when current resolver return null","**Version**:5.1.13.RELEASE There are two resolvers, one resolve value from [Apollo](https://github.com/ctripcorp/apollo), another resolver  resolve value from file of my project. A Bean with a @Value field, the field value is existed in file of my project and not in Apollo.  I get a java.lang.IllegalArgumentException when I run my project. ``` java.lang.IllegalArgumentException: Could not resolve placeholder 'verifyCode.bVariableFont' in value ""${verifyCode.bVariableFont}"" ``` A bean: ``` @Service public class VerifyCodeConfig {      @Value(value = ""${verifyCode.bVariableFont}"")     private String bVariableFont;      public String getbVariableFont() {         return bVariableFont;     } } ``` A resolver resolve value from file of my project: ``` @Configuration public class PropertiesConfiguration {      @Bean     @Order(0)     public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {          PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer =                 new PropertySourcesPlaceholderConfigurer();         List resources = new ArrayList<>();         resources.add(new ClassPathResource(""META-INF/res/application-verify-code.properties""));         propertySourcesPlaceholderConfigurer.setLocations(resources.toArray(new Resource[] {}));         propertySourcesPlaceholderConfigurer.setIgnoreResourceNotFound(true);          return propertySourcesPlaceholderConfigurer;     } } ``` Extract from AbstractBeanFactory: ``` 	@Override 	@Nullable 	public String resolveEmbeddedValue(@Nullable String value) { 		if (value == null) { 			return null; 		} 		String result = value; 		for (StringValueResolver resolver : this.embeddedValueResolvers) { 			result = resolver.resolveStringValue(result); 			if (result == null) { 				return null; 			} 		} 		return result; 	} ``` I think a solution should be to continue the resolving chain, if an embeddedValueResolver resolves the value to null, and all embeddedValueResolver resolves the value to null,then return null;  **Possible Solution:**  Extract from AbstractBeanFactory: ``` 	@Override 	@Nullable 	public String resolveEmbeddedValue(@Nullable String value) { 		if (value == null) { 			return null; 		} 		String result = null; 		for (StringValueResolver resolver : this.embeddedValueResolvers) { 			result = resolver.resolveStringValue(value); 			if (result != null) { 				return result; 			} 		} 		return result; 	} ```","open","in: core,","GuiSong01","2020-12-09T09:47:51Z","2021-11-11T09:32:05Z"
"","26335","FormattingConversionService#addFormatterForFieldType  occurred NullPointerException bug","**Spring Framework Version：5.3.1**  When I was writing the formatter special column. I need to write a demo about the detailed use of `FormatterRegistry`. You know  `Formattingconversionservice` can be considered as its unique implementation.  In the process of using `Formattingconversionservice`, I found a bug in it  by accident. Here is my demo source code: ```java @Data @NoArgsConstructor @AllArgsConstructor public class Person {     private Integer id;     private String name; }  public class Demo {      // Customize a parser: String -> Integer     private static class IntegerParser implements Parser {         @Override         public Integer parse(String text, Locale locale) throws ParseException {             return NumberUtils.parseNumber(text, Integer.class);         }     }       @Test     public void test4() {         FormattingConversionService formattingConversionService = new FormattingConversionService();         FormatterRegistry formatterRegistry = formattingConversionService;         ConversionService conversionService = formattingConversionService;          // 注册格式化器         formatterRegistry.addFormatterForFieldType(Person.class, null, new IntegerParser());         formatterRegistry.addConverter(new Converter() {             @Override             public Person convert(Integer source) {                 return new Person(source, ""YourBatman"");             }         });          System.out.println(conversionService.canConvert(String.class, Person.class));         System.out.println(conversionService.convert(""1"", Person.class));     }  } ``` Run the program,throw an `NullPointerException` exception: ```java java.lang.NullPointerException 	at org.springframework.format.support.FormattingConversionService$PrinterConverter.resolvePrinterObjectType(FormattingConversionService.java:179) 	at org.springframework.format.support.FormattingConversionService$PrinterConverter.(FormattingConversionService.java:155) 	at org.springframework.format.support.FormattingConversionService.addFormatterForFieldType(FormattingConversionService.java:95) 	at cn.yourbatman.formatter.Demo.test4(Demo.java:86)         ... ```  The location of the exception is obvious. In FormattingConversionService: ```java FormattingConversionService:  	@Override 	public void addFormatterForFieldType(Class fieldType, Printer printer, Parser parser) { 		addConverter(new PrinterConverter(fieldType, printer, this)); 		addConverter(new ParserConverter(fieldType, parser, this)); 	}          private static class PrinterConverter implements GenericConverter {                 ... 		public PrinterConverter(Class fieldType, Printer printer, ConversionService conversionService) { 			this.fieldType = fieldType;                         // Where the NullPointerException exception occurred 			this.printerObjectType = TypeDescriptor.valueOf(resolvePrinterObjectType(printer)); 			this.printer = printer; 			this.conversionService = conversionService; 		}                 ...         } ```  If I modify my demo just like this: ```java     @Test     public void test4() {         ...          // 注册格式化器        // just use new IntegerPrinter() instead of null for this second param         formatterRegistry.addFormatterForFieldType(Person.class, new IntegerPrinter(), new IntegerParser());         ...     } ``` Run the program again.Normal output: ```java true Person(id=1, name=YourBatman) ```  ---  I think the implementation of `FormattingConversionService` is not rigorous. I just want to register a `Parser` for specified type, but `Printer` doesn't need. Even if I specify the second param null must also work natural.There's no reason to tie them together.  ---  So I think it's a bug.I have the following suggestions to fix it: ```java FormattingConversionService:  	@Override 	public void addFormatterForFieldType(Class fieldType, Printer printer, Parser parser) {                 if (printer != null) {                     addConverter(new PrinterConverter(fieldType, printer, this));                 } 		if (parser != null) {                     addConverter(new ParserConverter(fieldType, parser, this));                 } 	} ``` > If printer/parser is null,There's no point in registering `PrinterConverter/ParserConverter` in the `ConverterRegistry`.In `FormattingConversionService` all registered places need to be judge null.  In addition, at the API level，I suggest adding the following two APIs: ```java FormatterRegistry:      void addPrinter(Class fieldType, Printer printer);     void addParser(Class fieldType, Parser parser); ``` Thanks for reading my advice.","open","in: core,","yourbatman","2021-01-03T15:34:21Z","2021-11-11T09:32:06Z"
"","26497","Aspectj @Configurable not working in bean post construct","**Spring Boot 2.4.2**  Using two beans: `Parent implements InitializingBean` and `@Configurable Child`. Parent inside `afterPropertiesSet` creates a `Child` instance.  The newly created child doesn't have any `@Autowired` props set because `BeanConfigurerSuport` is not initialized (null beanfactory): https://github.com/spring-projects/spring-framework/blob/8589804012efda8db2d70094e8efbd8f74d06dc5/spring-beans/src/main/java/org/springframework/beans/factory/wiring/BeanConfigurerSupport.java#L126-L133  This happens during spring boot startup, stacktrace: ``` .... preInstantiateSingletons:897, DefaultListableBeanFactory (org.springframework.beans.factory.support) finishBeanFactoryInitialization:879, AbstractApplicationContext (org.springframework.context.support) refresh:551, AbstractApplicationContext (org.springframework.context.support) refresh:143, ServletWebServerApplicationContext (org.springframework.boot.web.servlet.context) refresh:758, SpringApplication (org.springframework.boot) refresh:750, SpringApplication (org.springframework.boot) refreshContext:397, SpringApplication (org.springframework.boot) run:315, SpringApplication (org.springframework.boot) ```  The `BeanConfigurerSuport` is initialized (setBeanFactory) when `org.springframework.context.config.internalBeanConfigurerAspect` is created. During initialization, `org.springframework.context.config.internalBeanConfigurerAspect` has **index 174** inside `beanNames` list: https://github.com/spring-projects/spring-framework/blob/8589804012efda8db2d70094e8efbd8f74d06dc5/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java#L921 This means, all 173 beans created before cannot use `@Configurable` (this includes some of my user beans).  This bean should be initialized with priority, before any user bean, so that `@Configurable` will work.","open","in: core,","cdalexndr","2021-02-02T16:17:37Z","2022-02-11T17:41:53Z"
"","26326","Per-Statement QueryTimeout for JdbcTemplate","**Context:** As described here (https://github.com/spring-projects/spring-framework/issues/7444) it is possible to set a general query timeout for `JdbcTemplate`. However, having in mind that `JdbcTemplate` typically is a singleton bean, this is not sufficient when it comes to thread-per-request handling. Setting the queryTimeout _state_ once would affect every subsequent query and interfere with parallel threads that use the `JdbcTemplate` bean. The use case is to easily set statement timeout individually and dynamically (e.g. because of expected query runtime that is affected by different statement params).  **Proposal for new feature:** Overloading once more the `execute()`, `query()`, `queryForX()` and `update()` methods by adding a timeout parameter that then gets passed though the stack (i.a.`applyStatementSettings()`) to finally call `setQueryTimeout` on the `Statement`.   **Further References:**  https://jira.spring.io/browse/DATAJDBC-638","open","in: data,","MahatmaFatalError","2020-12-30T19:55:20Z","2021-11-10T12:11:02Z"
"","26766","Enhancing SpelExpressionParser to accept expressions containing Mono instances","**context**: So I've been trying to work with SPEL and Mono instance as input that would be parsed to an instance of Mono but SPEL isn't able to do the conversion and handle a Mono instance  ``` @UtilityClass  public class ReactiveSpelUtil {      private static ExpressionParser SPEL_PARSER = new SpelExpressionParser();      private static final EvaluationContext STANDARD_EVALUATION_CONTEXT = new StandardEvaluationContext();          @SuppressWarnings(""ALL"")     public static Mono evaluate(final Object rootObject, String expression) {          STANDARD_EVALUATION_CONTEXT.setVariable(rootObject.getClass().getSimpleName(),rootObject);                  return SPEL_PARSER.parseExpression(expression)                 .getValue(STANDARD_EVALUATION_CONTEXT, Mono.class);     }     // expression sample is #rootObject.age>20 , age is wrapped in Mono } ```  **The Problem**: I usually get error like this EL1013E: Cannot compare instances of class reactor.core.publisher.MonoJust and class java.lang.Integer, and the problem is that I can't do the parsing inside the map of the mono instance itself `age` because the expressions are built in a way that can be parsed only as per the above code, so is there any way to achieve working with Mono instances as part of (within) SPEL expression?","closed","in: core,","saeed-abdelhalim","2021-04-06T11:37:01Z","2021-05-03T08:57:21Z"
"","26626","Spring RSocket client send unexpected data whose payload is wrong when during connecting and cause unlimited retry","**Basic env info:**  OS: mac os 10.15.4 JDK: openjdk8 Springboot version: 2.3.4.RELEASE   **Reproduce:**  I create a spring rsocket client as follows. The requesterMono object is prepared for sending data. ```java // prepare requester object  Mono   requesterMono = rsocketRequesterBuilder.setupRoute(""conn-setup"")             .setupData(new ObjectMapper().writeValueAsString(connAuthDTO))             .dataMimeType(MimeTypeUtils.parseMimeType(WellKnownMimeType.APPLICATION_JSON.getString()))             .rsocketConnector(connector -> connector.acceptor(responder)                 .fragment(MTU_BYTE_SIZE)                 .keepAlive(Duration.ofSeconds(KEEP_ALIVE_INTERVAL_SEC), Duration.ofSeconds(KEEP_ALIVE_MAX_TIME_SEC))                 .reconnect(Retry.fixedDelay(Integer.MAX_VALUE, Duration.ofSeconds(RSOCKET_RETRY_INTERVAL_SECONDS))                     .doAfterRetry(retrySignal -> log.warn(""RSocket client is reconnecting to get the newest connection....""))))             .connect(TcpClientTransport.create(TcpClient.create()                 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, TCP_CONN_TIMEOUT)                 .option(ChannelOption.TCP_NODELAY, true)                 .option(ChannelOption.SO_KEEPALIVE, true)                 .host(clientAuthManager.acquireServerDomain())                 .port(SERVER_PORT)                 .secure(ssl -> ssl.sslContext(sslContext))));  //send data with requesterMono     public RSocketRequester getWorkingRequester() {         RSocketRequester requester = requesterMono.block(Duration.ofSeconds(1));         if (requester == null || requester.rsocket().isDisposed()) {             throw new RuntimeException(""try to get rsocket requester ,but it is ABNORMAL...."");         }         return requester;     } ```  The expected setup payload should be a json value of ConnAuthDTO.  ```java public class ConnAuthDTO {      private String ak;      private String sk;      private String ip;      /**      * sidecar's unique identify      */     private String wsn;      private long   sendAuthTimeMs; } ```  The rsocket client have another schedule thread periodically send rsocket request like invoke method 'updateWorkerState' to send data by rsocket . The request will invoke getWorkingRequester to get the requester and send data. The data payload's related class is : ```java @Data public class WorkerUpdateDTO {      private WorkerIdentity workerIdentity;      private WorkerState    workerState;      private String         localIp;      private String         externalIp;      private boolean        needUpdateLocalIp;      private boolean        needUpdateExternalIp;      private Date           sendDate; }  //WorkerIdentity definition @Data @Builder public class WorkerIdentity {      @Tolerate     public WorkerIdentity(){     }      private String workerSeqNumber;      private String accessKey;      private String localIp; }    ```   When server is restarted, client will try to reconnect and I will see the first stream is always retrying and its payload is not what we expected. The setup payload is not complete and it is just a part of WorkerUpdateDTO's json value. ![image](https://user-images.githubusercontent.com/4374015/109494881-72532980-7ac9-11eb-9335-ffb88adefa27.png)    I think it is a concurrency issue. Other thread's payload data will replace the correct setup payload during reconnecting. Is it a bug of spring rsocket?","closed","for: external-project,","KaimingWan","2021-03-01T12:02:21Z","2021-03-02T12:32:59Z"
"","26474","Exclude User Destination Messages in Broker Message Handler","**Affects:** v5.3.3  We used WebSockets within Spring Boot 2.3.5 (Spring Framework 5.2.10). After updating to Spring Boot 2.4.2 (Spring Framework 5.3.3), we noticed that our WebSocket mechanism was no longer working.  We looked at #26118, but the discussion there was about duplicate subscriptions and wrongly registered /user destinations. In our case we have only a single subscription per sessionId/subscriptionId.  WebSocket is basically configured like this:  ``` @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { 	@Override 	public void configureMessageBroker(final MessageBrokerRegistry registry) { 		registry.setApplicationDestinationPrefixes(""/app""); 		registry.setUserDestinationPrefix(""/user""); 	} 	@Override 	public void registerStompEndpoints(final StompEndpointRegistry registry) { 		registry.addEndpoint(""/websocket"").withSockJS(); 	} } ```  In our application we use user-specific WebSocket messages as a push mechanism. The client subscribes to _/user/events_, the server sends messages to _/user/{username}/events_ using _SimpMessagingTemplate#convertAndSendToUser_. This worked as expected up to Version 5.3.3.  ``` _simpMessagingTemplate.convertAndSendToUser(""username"", ""/events"", pojo); ```  After a little bit of debugging, we've noticed that there might now be a problem with user-specific subscriptions due to a change with #24395. _DestinationCache#calculateSubscriptions_ now operates on an exact destination equals-comparison when using non-pattern-based subscriptions.  ``` 		@NonNull 		private LinkedMultiValueMap calculateSubscriptions(String destination) { 			LinkedMultiValueMap sessionsToSubscriptions = new LinkedMultiValueMap<>(); 			DefaultSubscriptionRegistry.this.subscriptionRegistry.forEachSubscription((sessionId, subscriptionDetail) -> { 				if (subscriptionDetail.isAntPattern()) { 					... 				} 				else if (destination.equals(subscriptionDetail.getDestination())) { 					... ```  While debugging the issue you can see, that the active subscription to `subscriptionDetail.getDestination()=""/user/events""` is compared to a given `destination=""/user/{username}/events""`, which has been extracted from the new user-specific _Message_ in _AbstractSubscriptionRegistry#findSubscriptions_ called by _SimpleBrokerMessageHandler#sendMessageToSubscribers_.  To me it looks like the _{username}_ part of the message destination is not properly handled here.","closed","type: enhancement,","ellers-espirit","2021-01-29T10:13:09Z","2021-02-05T13:28:46Z"
"","26361","Cannot remove headers from httpHeaders.keySet() in WebFlux","**Affects:** v5.3.2  I have ExchangeFilterFunction which should retain only allowed response headers: ```java private static final Collection ALLOWED_RESPONSE_HEADERS = Arrays.asList(HttpHeaders.CONTENT_TYPE, HttpHeaders.CONTENT_DISPOSITION);  private ExchangeFilterFunction filterResponseHeaders() {     return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> Mono.just(ClientResponse.from(clientResponse)             .headers(httpHeaders -> httpHeaders.keySet().removeIf(headerName -> !ALLOWED_RESPONSE_HEADERS.contains(headerName)))             .body(clientResponse.bodyToFlux(DataBuffer.class))             .build())); } ``` This one is working correctly.  Because of ClientResponse.from() deprecation, the method is rewritten to: ```java private ExchangeFilterFunction filterResponseHeaders() {     return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> Mono.just(clientResponse.mutate()             .headers(httpHeaders -> httpHeaders.keySet().removeIf(headerName -> !ALLOWED_RESPONSE_HEADERS.contains(headerName)))             .build())); } ``` That one is not working. Response headers are not affected.","closed","type: bug,","zeljko-mirovic","2021-01-08T10:48:56Z","2021-01-11T08:22:55Z"
"","26055","PathPatternRouteMatcher - Possible Minor Memory Leak","**Affects:** v5.3.0  The PathPatternRouteMatcher appears to utilize the below cache to optimize the parsing of Routes:   https://github.com/spring-projects/spring-framework/blob/6825287360e7d881066b7fbd16ab7e970985c225/spring-web/src/main/java/org/springframework/web/util/pattern/PathPatternRouteMatcher.java#L40  Given the cache is implemented as a ConcurrentHashMap it appears that there are no bounds on this. Furthermore, there is no way to define an eviction policy (e.g. LRU) so, as far as I can see, the Map will continue to grow for the life of the JVM, particularly in use cases where there are large numbers of distinct patterns being matched.  I acknowledge that the items in this Map will be small in size so this may represent a minor issue but perhaps defining a (customisable?) eviction strategy would be a useful improvement?","closed","status: invalid,","phil-applegate","2020-11-09T18:42:43Z","2020-11-10T18:38:55Z"
"","25864","jsessionid breaks request mappings when removeSemicolonContent is turned off","**Affects:** v5.2.9 (and probably v5.3.0)  ---  In our project, we setup the `UrlPathHelper` to not remove semicolon content, because we want to use matrix variables. Until and including _v5.2.8_, the `jsessionid` parameter was still removed from URLs. The parameter is injected into the URL by servlet containers if cookies cannot be used for session tracking (e.g. because the client doesn't accept cookies) or if the server was configured explicitly to use the URL for session tracking.  Starting with _v5.2.9_, the parameter is not removed anymore, which breaks our request mappings: For example a request to `/data;jsessionId=1234` cannot be mapped to the endpoint with the `@RequestMapping(""/data"")` because of the additional `jsessionid` parameter and the result is an HTTP status 404 (Not Found).  The change was introduced with [commit 899761f0a8890353dc01f10d2af96ae192f3e655](https://github.com/spring-projects/spring-framework/commit/899761f0a8890353dc01f10d2af96ae192f3e655) where the `removeJsessionid()` method was removed without (obvious) replacement.  Thx for your help to make the request mappings work again.","closed","type: regression,","jkissel","2020-10-06T19:05:06Z","2020-10-07T11:46:57Z"
"","26080","UrlPathHelper#removeJsessionid doesn't remove the jsessionid from the URL","**Affects:** v5.2.10  ---  The fix for [issue 25864](https://github.com/spring-projects/spring-framework/issues/25864) re-introduced the `UrlPathHelper#removeJsessionid` method which should fix broken request mappings when the `jsessionid` is included in the request URI and `removeSemicolonContent` is turned off.  Unfortunately it doesn't work: It doesn't remove the `jsessionid` from a URI like `/test;jsessionid=12345`, i.e. the result of `removeJsessionid(""/test;jsessionid=12345"")` is the input string. With v5.2.8 it's `/test`, which is correct.  Thx for your help to make the request mappings work again.","closed","","jkissel","2020-11-12T14:27:20Z","2020-11-12T14:27:49Z"
"","26079","UrlPathHelper#removeJsessionid doesn't remove the jsessionid from the URL","**Affects:** v5.2.10  ---  The fix for [issue 25864](https://github.com/spring-projects/spring-framework/issues/25864) re-introduced the `UrlPathHelper#removeJsessionid` method which should fix broken request mappings when the `jsessionid` is included in the request URI and `removeSemicolonContent` is turned off.  Unfortunately it doesn't work: It doesn't remove the `jsessionid` from a URI like `/test;jsessionid=12345`, i.e. the result of `removeJsessionid(""/test;jsessionid=12345"")` is the input string. With v5.2.8 it's `/test`, which is correct.  Thx for your help to make the request mappings work again.","closed","type: regression,","jkissel","2020-11-12T14:26:34Z","2020-11-12T22:01:51Z"
"","26262","WebSocketMessageBrokerConfigurationSupport source and binary incompatibility introduced in version 5.3.2","**Affects:** v.5.3.2 **Worked in version**: 5.3.1  In the latest point release the method subProtocolWebSocketHandler in class [WebSocketMessageBrokerConfigurationSupport](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/web/socket/config/annotation/WebSocketMessageBrokerConfigurationSupport.html) was quietly changed in an incompatible version so my app does not compile any more.  The old code was      public WebSocketHandler subProtocolWebSocketHandler()  while the new one is       public WebSocketHandler subProtocolWebSocketHandler(AbstractSubscribableChannel clientInboundChannel,                                                         AbstractSubscribableChannel clientOutboundChannel)  At the same time the [clientInboundChannel](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.html#clientInboundChannel--) and clientOutboundChannel do not exist any more so it's not trivial (for my usecase) to change the code to the new release.  I think you should do this kind of source and binary incompatibility only on major releases and not in minor releases, at least without a clear documentation about it explaining why it has been done and how to migrate user code.","closed","","Polve","2020-12-12T13:20:17Z","2021-11-10T12:26:17Z"
"","26707","Resource.isFile() return true when the resource path actually not exists","**Affects:** springframework-5.3.5; spring web 5.3.5; spring boot 2.4.4  **demo**: ```java @SpringBootApplication public class ResourcebugApplication {      public static void main(String[] args) {         ConfigurableApplicationContext context = SpringApplication.run(ResourcebugApplication.class, args);         Resource notExistsResource = context.getResource(""com/example/resourcebug/NotExists.java"");         System.out.println(""notExistsResource is file: "" + notExistsResource.isFile());     } } ```  **output**: notExistsResource is file: true  **expected output**: notExistsResource is file: false","open","in: core,","drgnchan","2021-03-20T11:11:29Z","2021-11-11T09:32:07Z"
"","26599","Improve Javadoc of RestOperations#exchange for responses without a body","**Affects:** spring-web:5.3.4  --- The various `RestTemplate.exchange()` methods do not mark the parameter `Class responseType` as `@Nullable`. For example: https://github.com/spring-projects/spring-framework/blob/v5.3.4/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L597 ```java public  ResponseEntity exchange(String url, HttpMethod method,     @Nullable HttpEntity requestEntity, /* >HERE< */ Class responseType, Object... uriVariables)     throws RestClientException {          RequestCallback requestCallback = httpEntityCallback(requestEntity, responseType);         ResponseExtractor> responseExtractor = responseEntityExtractor(responseType);         return nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables)); } ``` This causes code analysis warnings for methods which do not return a response, such as `DELETE`, forcing developers to use `Void.TYPE` as the `responseType` instead of `null`.  --- The usages of that parameter explicitly expect `null` values as valid cases. For example:  In the `HttpEntityRequestCallback ` class, ```java public HttpEntityRequestCallback(@Nullable Object requestBody, @Nullable Type responseType) {     // ... } ```  In the `ResponseEntityResponseExtractor` class,  ```java public ResponseEntityResponseExtractor(@Nullable Type responseType) {     if (responseType != null && Void.class != responseType) {         this.delegate = new HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);     }     else {         this.delegate = null;     } } ```","closed","type: task,","metacubed","2021-02-24T02:43:32Z","2021-02-25T18:29:50Z"
"","26297","Support for MultiValueMap elements in web data binding","**Affects:** spring-web 5.2.11  ---  Given a controller like the following: ```java import javax.annotation.Nullable;  import org.springframework.util.MultiValueMap; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  @RestController @RequestMapping(""/path"") public class MyController {  	private static class MyCriteria {  		@Nullable 		private String param1;  		@Nullable 		private MultiValueMap otherParams;  		// getters and setter omitted 	}  	@GetMapping 	public void getByCriteria(MyCriteria criteria) { 		// body 	} } ```  I would expect a GET request to `/path?param1=a&otherParams[otherParam]=b` to cause an instance of `MyCriteria` with `param1 = ""a""` and `otherParams = {""otherParam"": [""b""]}` to be passed in.  Instead, the following exception is thrown: ``` java.lang.ClassCastException: class java.lang.String cannot be cast to class java.util.List (java.lang.String and java.util.List are in module java.base of loader 'bootstrap') 	at org.springframework.util.LinkedMultiValueMap.put(LinkedMultiValueMap.java:42) 	at org.springframework.beans.AbstractNestablePropertyAccessor.processKeyedProperty(AbstractNestablePropertyAccessor.java:371) 	at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:275) 	at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:266) 	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:104) 	at org.springframework.validation.DataBinder.applyPropertyValues(DataBinder.java:848) 	at org.springframework.validation.DataBinder.doBind(DataBinder.java:744) 	at org.springframework.web.bind.WebDataBinder.doBind(WebDataBinder.java:197) 	at org.springframework.web.bind.ServletRequestDataBinder.bind(ServletRequestDataBinder.java:107) ```  This works as expected when `MultiValueMap` is replaced with `Map>`","open","type: enhancement,","MHajoha","2020-12-18T16:42:01Z","2021-09-13T15:15:09Z"
"","26165","Cannot convert the string value to the Date value in controllers of WebFlux","**Affects:** Spring-Framework:5.3.1, spring-boot:2.4.0  --- **Expected** The endpoints in controllers should parse the String value to the Date value.  **Actual** The endpoints in controllers throw the TypeMismatchException exception. ``` (""org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.util.Date] for value '2020-11-26'; nested exception is java.lang.IllegalArgumentException"") and respond with 400 to the client. ``` ```java @RestController public class MyController {      @GetMapping     public String get(Date date) {         return date.toString();     }  } ``` ![image](https://user-images.githubusercontent.com/44962329/100451869-0d1b2100-30f3-11eb-90ec-3b585622d0a0.png)","closed","","JamesChenX","2020-11-27T12:59:28Z","2020-12-31T16:41:59Z"
"","26590","Override content type while using BodyInserters.fromMultipartData","**Affects:** Spring Webmvc-5.2.7.RELEASE  **Use case:** I need to stream large files to another service via the WebClient class with a specific Content-Type (multipart/related). To build the request body I use the MultipartBodyBuilder.  To create the BodyInserter for the WebClient I use the BodyInserters.fromMultipartData factory method.  **Problem:** Because the returned DefaultMultipartInserter from the BodyInserters.fromMultipartData factory method sets the Content-Type to multipart/form-data, I need to subclass MultipartInserter and copy almost the whole code from DefaultMultipartInserter only to change the content type. There is no easy way to override the standard content type while using BodyInserters.fromMultipartData.  **Wish:** Add the possibility to set the content type while using the aforementioned factory method.","closed","status: invalid,","Gurkensalat1234","2021-02-22T16:57:13Z","2021-02-23T15:18:36Z"
"","26189","WebClient exchangeToMono documentation sample issue","**Affects:** Spring WebFlux latest  ---  Hi.  The java example of the new exchangeToMono method does not compile.  https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-exchange  ClientResponse.createException returns Mono. Even if one maps the flow still goes into doOnSuccess  ``` client.get()        .uri(""/persons/1"")        .accept(MediaType.APPLICATION_JSON)        .exchangeToMono(response -> {            if (response.statusCode().equals(HttpStatus.OK)) {                return response.bodyToMono(Person.class);            }            else if (response.statusCode().is4xxClientError()) {                return response.bodyToMono(ErrorContainer.class);            }            else {                return response.createException().map(exception -> Mono.error(exception));                // return response.createException();                // return Mono.error(response.createException());            }        })        .doOnError(...)        .doOnSuccess(...)        .subscribe();  ```  I just want to fail the sequence and precieve exception within Mono.error.","closed","type: task,","windymindy","2020-12-01T13:17:49Z","2020-12-03T10:03:35Z"
"","26539","Allow logging REST endpoint mappings independent of other log categories","**Affects:** Spring Web MVC 5.3.3  After upgrading from Spring4 to Spring5.3 we face a problem: there is no easy way to log just mappings of Controllers to endpoints.  The expected scenario: during booting a Spring MVC web application we would like to have all endpoint mappings in logs. However we don't want all request processing by Spring MVC to be logged because it would generate enormous amount of logs in production.  Currently, if we enable **TRACE** log level for `org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping` we receive both needed logs during boot of the webapp but also all requests processed are logged `RequestMappingHandlerMapping - Mapped to ...`).  Please provide a way to just log the endpoint mappings.  The issue was discussed in SO: https://stackoverflow.com/questions/40621044/log-restful-endpoints-on-container-startup-in-a-spring-application","closed","type: enhancement,","lrozenblyum","2021-02-11T09:20:24Z","2021-06-06T11:25:38Z"
"","25986","Inefficient request handling inside ServletRequestDataBinder","**Affects:** Spring web 4.2+, 5.x (confirmed, possibly others)  --- A large, publicly-facing application receives more than 100 request parameters (don't ask) and the growing runtime of ServletRequestDataBinder has exposed an inefficiency: for each parameter, AbstractNestablePropertyAccessor.processLocalProperty() throws an exception, which is caught by AbstractPropertyAccessor.setPropertyValues().  This exception is then discarded because ""ignoreUnknown"" is true, and life goes on.  Throwing exceptions is an expensive operation because of the need to fill in stack traces (Throwable.fillInStackTrace) and this generates significant wasted effort.  Modifying ServletRequestDataBinder.bind() to mark each PropertyValue as optional eliminates this penalty while maintaining the same functional behavior.  Custom benchmarking shows a 93% reduction in cpu and clock time (21 vs. 350).  Workarounds are difficult because ServletRequestDataBinder is accessed via a chain of hard-coded references, plus our application uses the subclass ExtendedServletRequestDataBinder.  The best option I've found so far is to use a custom bean factory to override the requestMappingHandlerAdapter bean (declared in WebMvcConfigurationSupport.requestMappingHandlerAdapter()) and make a subclass that overrides createDataBinderFactory, etc.  ""Convoluted"" and ""ugly"" are good descriptions of those solution.","closed","type: enhancement,","jengebr","2020-10-28T18:23:26Z","2020-11-06T10:39:05Z"
"","25977","Nested transaction synchronization registration","**Affects:** spring version: 5.2.2  Hi team, I found register TransactionSynchronizationAdapter in a nested way could fail the inner invocation.  The test case should be like: ``` @RestController public class TestController {      @Resource     private SomeTestClass someTestClass;      @Transactional     @GetMapping(""/testTx"")     public String testTx() {         int a = 3;         if (TransactionSynchronizationManager.isSynchronizationActive()) {             TransactionSynchronizationManager.registerSynchronization(                     new TransactionSynchronizationAdapter() {                         @Override                         public void afterCommit() {                             someTestClass.doSomeTx();                         }                     });         } else {             someTestClass.doSomeTx();         }         return """";     } } ```  ``` @Component public class SomeTestClass {      public void doSomeTx() {         if (TransactionSynchronizationManager.isSynchronizationActive()) {             TransactionSynchronizationManager.registerSynchronization(                     new TransactionSynchronizationAdapter() {                         @Override                         public void afterCommit() {                             System.err.println(""print 1"");                         }                     });         } else {             System.err.println(""print 2"");         }     } } ```  After invoking `/testTx`, neither `print 1` or `print 2` is printed out. After I explored the source code, I found the invocation of the outer `TransactionSynchronizationAdapter.afterCommit` happens in `TransactionSynchronizationUtils.invokeAfterCommit`, at this time, the threadlocal variable `synchronizations` is not cleared(`isSynchronizationActive()` returns true), and the inner registration success. However, after `TransactionSynchronizationUtils.invokeAfterCommit`, the `AbstractPlatformTransactionManager.triggerAfterCompletion` is invoked and `synchronizations` is cleared, no more invocation to the inner `afterCommit`.  Personally I think this is a issue of the `isSynchronizationActive()`. This method should judge whether the transaction is already in a *after commit* state.  Maybe I got it wrong, please figure it out for me. Thx for your work.","open","in: data,","yizhao1998","2020-10-27T02:57:24Z","2021-11-10T09:27:07Z"
"","26851","@EnableLoadTimeWeaving does not work for spring beans annotated by @Component, @Configuration, etc.","**Affects:** Spring Framework 5.3.4  When I use the ```@EnableLoadTimeWeaving``` annotation, beans will not be woven, but using XML configuration `````` can be successfully woven.  Here's a snippet that use ```@EnableLoadTimeWeaving```  annotation:  ```java @ComponentScan({""com.example.demo"",""foo""}) @EnableLoadTimeWeaving public class LwtStart {     public static void main(String[] args) {         AnnotationConfigApplicationContext ctx=new AnnotationConfigApplicationContext(LwtStart.class);         //ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(""beans.xml"");         //a bean annotated by @Component         EntitlementCalculationService service1=ctx.getBean(EntitlementCalculationService.class);         service1.calculateEntitlement();                           //A simple object that is not managed by the Spring container ,not annotated by @Component         EntitlementCalculationService service2=new MyEntitlementCalculationService();         //For comparison,to prove load-time-weaver takes effect         service2.calculateEntitlement();     } } ```  **aop.xml**  ```xml                                                                     ```          **the aspect**  ```java @Around(""methodsToBeProfiled()"") public Object profile(ProceedingJoinPoint pjp) throws Throwable {     StopWatch sw = new StopWatch(getClass().getSimpleName());     try {         System.out.println(pjp.getTarget());         sw.start(pjp.getSignature().getName());         return pjp.proceed();     } finally {         sw.stop();         System.out.println(sw.prettyPrint());     } }  @Pointcut(""execution(public * foo.*.*(..))"") public void methodsToBeProfiled(){} ```  In this simple case, the `EntitlementCalculationService` object that was successfully woven will print the execution time . As mentioned before, `service2` prints the execution time, `service1` does not, proving that it was not successfully woven.  When switching to the XML configuration method, both `service1` and `service2` can be successfully woven, and they can both print the execution time.  ```java // AnnotationConfigApplicationContext ctx=new AnnotationConfigApplicationContext(LwtStart.class); ClassPathXmlApplicationContext ctx=new ClassPathXmlApplicationContext(""beans.xml"");  EntitlementCalculationService service1=ctx.getBean(EntitlementCalculationService.class); service1.calculateEntitlement();  EntitlementCalculationService service2=new MyEntitlementCalculationService(); service2.calculateEntitlement(); ```  ```xml      ```  When using Java configuration, the ```AspectJWeavingEnabler.enableAspectJWeaving``` method will not be called until Spring loads the bean classes, which seems to be the reason why `@EnableLoadTimeWeaving` does not take effect.","closed","in: core,","pop1213","2021-04-23T05:25:21Z","2022-06-28T15:20:37Z"
"","26412","PersistenceExceptionTranslationInterceptor attempting to instantiate prototype PersistenceExceptionTranslator beans","**Affects:** spring framework 5.3.3  Attempting to upgrade our application to boot 2.4.2 from 2.3.4 and ran into this issue.  We have a prototype bean defined as:  ```java     @Bean(name = ""protoConnectionFactory"", autowireCandidate = false)     @Scope(value = SCOPE_PROTOTYPE)     public RedisConnectionFactory protoConnectionFactory(@NonNull Bar instance) {     } ```  If there is a persistence exception this now causes the following exception (at runtime):  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'protoConnectionFactory' defined in FooConfig: Unsatisfied dependency expressed through method 'protoConnectionFactory' parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'foo.Bar' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}  at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:800)  at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:541)  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1336)  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1179)  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:571)  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531)  at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353)  at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)  at org.springframework.beans.factory.support.DefaultListableBeanFactory$1.orderedStream(DefaultListableBeanFactory.java:481)  at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.detectPersistenceExceptionTranslators(PersistenceExceptionTranslationInterceptor.java:167)  at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:149)  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)  at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:174)  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)  at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)  at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)  at com.sun.proxy.$Proxy214.saveAndFlush(Unknown Source) ```  In other words, it is trying to instantiate the prototype bean now (RedisConnectionFactory is a PersistenceExceptionTranslator).  I believe this was caused by:  https://github.com/spring-projects/spring-framework/commit/14839b1f4ab765228a3e739ba0dfc06b189f19e0  Previously:  ```java   Map pets = BeanFactoryUtils.beansOfTypeIncludingAncestors(   beanFactory, PersistenceExceptionTranslator.class, false, false); ```  Excluded prototypes (the first false).  I'm pretty sure we could workaround this behavior by dynamically registering these beans (not using prototypes), but, this seems like a potential regression.","closed","type: documentation,","krm1312","2021-01-20T20:57:55Z","2021-11-09T21:45:39Z"
"","26486","SimpleJdbcInsert (sporadically) does not insert all columns","**Affects:** Spring Framework 5.3.3  ---  When using `SimpleJdbcInsert` without `usingColumns()`, it tries to determine the columns from database metadata. When there is any exception, a warning is logged, but otherwise the exception is ignored:  https://github.com/spring-projects/spring-framework/blob/91509805b759a108d7eca0b6b3041c434c61d837/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericCallMetaDataProvider.java#L415-L419  This is fine as long as the exception occurs **before any** metadata could be read, because later this will cause an exception when generating the SQL string:  https://github.com/spring-projects/spring-framework/blob/91509805b759a108d7eca0b6b3041c434c61d837/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/TableMetaDataContext.java#L305-L306  However, when an `SQLException` occurs in `columns.next()` ...  https://github.com/spring-projects/spring-framework/blob/91509805b759a108d7eca0b6b3041c434c61d837/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericCallMetaDataProvider.java#L390   ... **after** the first column metadata has already been read and added to `this.callParameterMetaData`, it continues with an **incomplete** list of columns and only inserts these, ignoring any other columns.  We have experienced this problem in our system very sporadically, and it's especially dangerous, because `SimpleJdbcInsert.execute()` (as long as there are no `NOT NULL` constraints for the columns) returns seemingly successfully, so the transactions are committed with incomplete/corrupted data.  It seems like we can work around the problem by calling `usingColumns()` for all uses of `SimpleJdbcInsert`.","closed","type: bug,","JulianKurz","2021-02-01T13:39:07Z","2021-02-04T09:45:39Z"
"","26104","PathMatchingResourcePatternResolver fails to resolve resources from JAR located in path with '#' on JDK 11+","**Affects:** Spring Framework 5.3.1 on JRE 11+  ---  I have a simple JAR which contains the resource `demo/dummy.txt` and a class with this code: ```java ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource[] resources = resolver.getResources(""classpath*:**/dummy.txt""); System.out.println(""resources = "" + Arrays.toString(resources)); ```  If I put this JAR into `c:\tmp\demo` and run the code, the resource is found. If I put this JAR into `c:\tmp\#demo` and run the code, no resources are found.  Instead, an exception is logged at debug level: ``` Cannot search for matching files underneath [c:\tmp\#demo\resource-resolver-demo-1.0-SNAPSHOT.jar] because it cannot be converted to a valid 'jar:' URL: no !/ in spec  java.net.MalformedURLException: no !/ in spec 	at java.base/java.net.URL.(URL.java:679) 	at java.base/java.net.URL.(URL.java:541) 	at java.base/java.net.URL.(URL.java:488) 	at org.springframework.core.io.UrlResource.(UrlResource.java:95) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.addClassPathManifestEntries(PathMatchingResourcePatternResolver.java:435) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.addAllClassLoaderJarRoots(PathMatchingResourcePatternResolver.java:400) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindAllClassPathResources(PathMatchingResourcePatternResolver.java:346) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.findAllClassPathResources(PathMatchingResourcePatternResolver.java:321) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.getResources(PathMatchingResourcePatternResolver.java:288) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.findPathMatchingResources(PathMatchingResourcePatternResolver.java:494) 	at org.springframework.core.io.support.PathMatchingResourcePatternResolver.getResources(PathMatchingResourcePatternResolver.java:284) 	at demo.ResourceResolverDemo.main(ResourceResolverDemo.java:13) Caused by: java.lang.NullPointerException: no !/ in spec 	at java.base/sun.net.www.protocol.jar.Handler.parseAbsoluteSpec(Handler.java:181) 	at java.base/sun.net.www.protocol.jar.Handler.parseURL(Handler.java:163) 	at java.base/java.net.URL.(URL.java:674) 	... 11 more ```  This is only reproducible with JRE 11 and newer. Both cases work as expected if I run them with JRE 8.  See also this demo project: https://github.com/rweisleder/resource-resolver-demo","closed","in: core,","rweisleder","2020-11-17T12:17:37Z","2020-11-18T15:27:21Z"
"","26598","Change in behaviour for cron expression with day of the week range starting with SUN","**Affects:** Spring Framework 5.3  ---  Before Spring 5.3 the parse for cron expressions had a different behaviour for the day of the week.  Example of an expression that has been working for years: `""32 22/5 * ? * SUN-FRI""` Example of its use in Spring 5.3: `CronExpression.parse(""32 22/5 * ? * SUN-FRI"");`  Before the six space-separated string SUN-FRI was interpreted as 0-5. Now in Spring 5.3 it is interpreted as 7-5 and that throws un exception:  ``` Exception in thread ""main"" java.lang.IllegalArgumentException: Minimum value must be less than maximum value '7-5' in cron expression ""32 22/5 * ? * SUN-FRI"" 	at org.springframework.scheduling.support.CronExpression.parse(CronExpression.java:201) 	at TestCron.main(TestCron.java:8) Caused by: java.lang.IllegalArgumentException: Minimum value must be less than maximum value '7-5' 	at org.springframework.scheduling.support.BitsCronField.parseField(BitsCronField.java:150) 	at org.springframework.scheduling.support.BitsCronField.parseDate(BitsCronField.java:117) 	at org.springframework.scheduling.support.BitsCronField.parseDaysOfWeek(BitsCronField.java:103) 	at org.springframework.scheduling.support.CronField.parseDaysOfWeek(CronField.java:105) 	at org.springframework.scheduling.support.CronExpression.parse(CronExpression.java:195) 	... 1 more Caused by: java.lang.IllegalArgumentException: Minimum value must be less than maximum value 	at java.time.temporal.ValueRange.of(ValueRange.java:127) 	at org.springframework.scheduling.support.BitsCronField.parseRange(BitsCronField.java:169) 	at org.springframework.scheduling.support.BitsCronField.parseField(BitsCronField.java:129) 	... 5 more ```  A complete and very simple example of use:  ```java import org.springframework.scheduling.support.CronExpression;  public class TestCron {  	public static void main(String[] args) throws Exception { 		CronExpression.parse(""32 22/5 * ? * SUN-FRI""); 	} 	 } ```  It seems the class `org.springframework.scheduling.support.CronField` always consider Monday as position 0 (zero) in its array DAYS. But the documentation https://spring.io/blog/2020/11/10/new-in-spring-5-3-improved-cron-expressions says Sunday is zero (or seven).","closed","in: core,","andrecampanini","2021-02-23T22:31:07Z","2021-02-25T10:11:12Z"
"","26726","AnnotationUtils.isCandidateClass always return true","**Affects:** Spring Context 5.4.5 ---  When I want to use this method to find those beans annotated with a custom annotation it always return true Did I misunderstand the Java Docs  *Determine whether the given class is a candidate for carrying the specified annotation(at type, method or field level).*  ```Java     public @interface Job{           String value();     }     // customer BeanPostProcessor     @Override     public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {         Class targetClass = AopProxyUtils.ultimateTargetClass(bean);         if (AnnotationUtils.isCandidateClass(targetClass, Job.class)) {             //do something          }     } ```","closed","in: core,","xxxcrel","2021-03-25T07:19:18Z","2021-05-25T14:07:12Z"
"","26489","Spring WebClient multipart/form-data does not include a content length","**Affects:** Spring Boot 2.4.2  ---  Hi, I've noticed that multipart/form-data does not include a content length when the request is created with multipart/form-data . This has caused an issue with trying to access a route that requires a content-length to be set or else I get a 411. I've created a small demo to recreate the problem which can found here https://github.com/JoeBalduz/spring-webclient-multipart-no-content-length.  I also saw that #26046 appears to be the same issue as mine but it is closed. Is this possibly something that can be fixed in a future version so that the content-length is set automatically for multipart/form-data? I've tried setting the content-length myself in multiple ways but the closest I got was being off by about 10 bytes.","closed","status: declined,","JoeBalduz","2021-02-01T15:22:43Z","2021-08-10T17:38:12Z"
"","26068","AOP pointcut matching `ProceedingJoinPoint.proceed` when it is passed as a lambda / method reference","**Affects:** Spring Boot 2.3.5.RELEASE  There appears to be a bug in spring aop - see [this](https://stackoverflow.com/questions/64718434/spring-aop-pointcut-applying-to-method-only-when-joinpoint-proceed-is-invoked) stackoverflow issue, and my [MCVE](https://github.com/moxaj/aspect-mcve).  TLDR: when in an around advice, if I pass `joinPoint::proceed` (where `joinPoint` is the injected `ProceedingJoinPoint`) as a lambda or a method reference into another method (`foo`) of another class (`Bar`), an advice with a pointcut matching `Bar::foo` intercepts `joinPoint.proceed()` (**NOT** `Bar::foo`).","open","in: core,","moxaj","2020-11-11T09:48:57Z","2021-11-10T10:03:02Z"
"","26498","Inefficient reflection operations for destroy method determination","**Affects:** Spring 4.x, 5.x  --- Problem: Each call to DisposableBeanAdapter.hasDestroyMethod() for a given bean class will return the same boolean value, however in many cases those invocations issue one or two reflection operations to determine whether those methods exist.  In the case of high-volume web applications, request-scoped beans are frequently initialized, resulting in many repetitve reflection operations.  Impact: In two large, publicly-facing web applications, this problem uses between 1% and 3% cpu, and adds several milliseconds of latency to the server response.  Suggested solution: We solved this internally by caching the result  in a WeakHashMap keyed off of the classname.  There was some discussion of using the Class rather than the name but we saw slightly better performance with this configuration.","closed","type: enhancement,","jengebr","2021-02-02T17:29:33Z","2021-02-14T16:59:08Z"
"","26861","java.lang.annotation.IncompleteAnnotationException: kz.qbi.cells.meta.RSocketController missing element value","**Affects:** SB 2.4.4  --- build.gradle.kts: ``` ...     implementation(""org.springframework.boot:spring-boot-starter-rsocket"") ... ``` When one has this: ``` ... @Controller @MessageMapping annotation class RSocketController(     @get:AliasFor(annotation = MessageMapping::class)     val value: String ) ``` and this: ``` ... @RSocketController(""reader"") class Reader(     private val cellRepository: CellRepository, ) {      @MessageMapping(""get-rows-count-in-a-sheet"")     suspend fun getRowsCountInASheet(dto: GetRowsCountInASheetDto): Long = coroutineScope { ... ``` Then one gets the aforementioned (in the subject) exception. But one must say that this: ``` ... @Validated @RequestMapping @RestController annotation class ApiController(     @get:AliasFor(annotation = RequestMapping::class)     val value: String = """" ) ``` does not incur any issues.  The stack trace: ``` ... Caused by: java.lang.annotation.IncompleteAnnotationException: kz.qbi.cells.meta.RSocketController missing element value 	at java.base/sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:83) 	at com.sun.proxy.$Proxy77.value(Unknown Source) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282) 	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:266) 	at org.springframework.core.annotation.TypeMappedAnnotation.getValue(TypeMappedAnnotation.java:394) 	at org.springframework.core.annotation.TypeMappedAnnotation.getValue(TypeMappedAnnotation.java:365) 	at org.springframework.core.annotation.TypeMappedAnnotation.getAttributeValue(TypeMappedAnnotation.java:350) 	at org.springframework.core.annotation.AbstractMergedAnnotation.getValue(AbstractMergedAnnotation.java:178) 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.lambda$getAttributeValue$1(SynthesizedMergedAnnotationInvocationHandler.java:218) 	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.getAttributeValue(SynthesizedMergedAnnotationInvocationHandler.java:216) 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.invoke(SynthesizedMergedAnnotationInvocationHandler.java:90) 	at com.sun.proxy.$Proxy103.value(Unknown Source) 	at org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler.getCondition(RSocketMessageHandler.java:313) 	at org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler.getMappingForMethod(MessageMappingMessageHandler.java:279) 	at org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler.getMappingForMethod(MessageMappingMessageHandler.java:84) 	at org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler.lambda$detectHandlerMethods$0(AbstractMethodMessageHandler.java:335) 	at org.springframework.core.MethodIntrospector.lambda$selectMethods$0(MethodIntrospector.java:74) 	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:364) 	at org.springframework.core.MethodIntrospector.selectMethods(MethodIntrospector.java:72) 	at org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler.detectHandlerMethods(AbstractMethodMessageHandler.java:334) 	at org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler.initHandlerMethods(AbstractMethodMessageHandler.java:308) 	at org.springframework.messaging.handler.invocation.reactive.AbstractMethodMessageHandler.afterPropertiesSet(AbstractMethodMessageHandler.java:260) 	at org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler.afterPropertiesSet(MessageMappingMessageHandler.java:238) 	at org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler.afterPropertiesSet(RSocketMessageHandler.java:286) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) 	... 85 more ```","open","in: messaging,","yerzhant","2021-04-26T04:43:29Z","2021-11-10T09:11:31Z"
"","26351","Build and test on ARM64","**Affects:** Any supported series  ---  More and more software deployment and development is being done on ARM64 CPU architecture. It would be good if Spring Framework is being regularly tested on ARM64!  Spring uses [Concourse CI](https://ci.spring.io/teams/spring-framework/pipelines/spring-framework-5.3.x) and I assume it runs the build and tests only on AMD64 because Concourse provides only AMD64 [binaries](https://github.com/concourse/concourse/releases/tag/v6.7.2). There is a [ticket](https://github.com/concourse/concourse/issues/1379) to provide aarch64 binaries.  Since Spring is pure Java, without native C code, one can say that since JVM supports ARM64 there is nothing to do. And this is correct 99% of the time! But ARM64 has different memory model than AMD64 and concurrency related code may behave differently, e.g. recently Scala Cats project experienced such problem on the new Mac M1 - [announcement](https://github.com/typelevel/cats-effect/releases/tag/v3.0.0-M4) and [demo+explanation](https://gist.github.com/RaasAhsan/8e3554a41e07068536425ca0de46c9e8).  I see three possible outcomes for this issue:  1) Close the issue with an explanation similar to ""Nothing to do! ARM64 is a supported CPU architecture for Spring applications but the JVM has to deal with the platform differences""  2) Add an extra job to ConcourseCI to run the build and tests on ARM64 worker.  For this you may use the provided workarounds at https://github.com/concourse/concourse/issues/1379 until an official release is provided. ARM64 support is in their [roadmap](https://project.concourse-ci.org/). I could give you a hand on this task! I work for one of the cloud providers, so I could even give you a free ARM64 VM if you like !  3) Use TravisCI/DroneCI just for ARM64 builds, as unofficial CI. I could provide a Pull Request if you prefer this option!","closed","status: declined,","martin-g","2021-01-06T08:06:30Z","2021-12-09T12:33:14Z"
"","26322","java.util.ConcurrentModificationException: null","**Affects:** `4.3.1.RELEASE`   * Spring Boot `1.5.10.RELEASE`  * Spring Cloud `1.3.4.RELEASE`  **ErrorCode:** ```java ResponseEntity response = restTemplate.postForEntity(url, request, String.class); ```  **Exception StackTrace:** ``` java.util.ConcurrentModificationException: null         at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)         at java.util.ArrayList$Itr.next(ArrayList.java:859)         at org.springframework.web.client.RestTemplate$AcceptHeaderRequestCallback.doWithRequest(RestTemplate.java:771)         at org.springframework.web.client.RestTemplate$HttpEntityRequestCallback.doWithRequest(RestTemplate.java:836)         at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:658)         at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:621)         at org.springframework.web.client.RestTemplate.postForEntity(RestTemplate.java:415)         at org.springframework.web.client.RestTemplate$$FastClassBySpringCGLIB$$aa4e9ed0.invoke()         at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)         at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)         at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:85)         at org.springframework.cloud.netflix.metrics.RestTemplateUrlTemplateCapturingAspect.captureUrlTemplate(RestTemplateUrlTemplateCapturingAspect.java:33)         at sun.reflect.GeneratedMethodAccessor364.invoke(Unknown Source)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629)         at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618)         at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)         at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)         at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)         at org.springframework.web.client.RestTemplate$$EnhancerBySpringCGLIB$$542b8900.postForEntity() ```","closed","","chailinglu","2020-12-28T10:41:22Z","2020-12-29T07:37:16Z"
"","25900","Loggers apparently constructed on a per HTTP request basis in reactive web code cause CPU overhead","**Affects:** \v5.2.9.RELEASE  ---  CPU profiling of some fairly high HTTP traffic spring Webflux (on Tomcat) applications has shown between ~3-10% of time (in aggregate) spent in org.apache.commons.logging.LogFactory.getLog calls made from the following locations:  - https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpRequest.java#L49 - https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java#L65 - https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/result/condition/AbstractMediaTypeExpression.java#L38 - https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/HandlerMethodArgumentResolverComposite.java#L44 - https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java#L62  Based on my initial inspection, some of these loggers _may_ be unused in spring-framework code. Comments suggest in at least some of the cases that the loggers are intentionally available for use by subclasses (though I haven't seen any such usage in the spring-framework included subclasses that are in play in my specific stack traces).  I think the most typical pattern is to use `static` constants to refer to Loggers (since their construction is relatively expensive). Is there good reason for these Loggers to be instance members instead in these cases? If so, I wonder if it could be made configurable such that applications that aren't interested in these loggers can avoid spending time constructing them? I looked for an existing way to configure this, but wasn't able to find anything.","closed","type: enhancement,","danielra","2020-10-12T19:11:20Z","2020-10-12T22:11:50Z"
"","25971","springmvc get request query string param wrap to a pojo","**Affects:** \springmvc latest how to set the default value of the pojo property? ---","closed","for: stackoverflow,","L1yp","2020-10-26T06:07:45Z","2020-10-26T07:33:17Z"
"","26520","Inbound stream cancellation does not propagate in Spring Boot RSocket Reactive","**Affects:** \5.3.3 (Spring Boot 2.4.2)  --- Expected = RSocket channel endpoint in my Spring Boot application receives cancellation signal from the inbound, client-driven stream to allow server side cleanup, etc.  Actual = No cancellation, completion, or error signal received by my reactive stream, either Flux or Flow.  Setup = Relevant dependencies:  - Spring Boot 2.4.2 - Kotlin 1.4.21 - Kotlinx Coroutines 1.4.2 - RSocket Core 1.1.0 (also tried 1.1.1-SNAPSHOT, which suppresses ""Operator called default onErrorDropped"" but still doesn't propagate the cancellation)  I have tried to achieve my goal with both Kotlin coroutine Flows and Reactor Flux(en?). Both client/server pairs below should do the same thing: establish an RSocket channel, send 2 ""ping"" payloads from the client, the server responds to each with a ""pong"" payload, and the client closes the connection.    Flow server side: ```     @MessageMapping(""testFlow"")     fun testPingFlow(input: Flow): Flow {         val cs = CoroutineScope(EmptyCoroutineContext)         val output = MutableSharedFlow(10)          cs.launch {             try {                 input                     .catch { e ->                         logger.error(""Rsocket server input error"", e)                     }                     .onCompletion { exception ->                         logger.debug(""Rsocket server input completed"")                         if (exception != null) {                             logger.error(""Exception received while processing Rsocket server input flow"", exception)                         }                     }                     // Normal .collect complains about being internal-only                     .collectIndexed { _, message ->                         logger.debug(""Rsocket server input received $message"")                         output.emit(""pong ${System.currentTimeMillis()}"")                     }             } catch (e: Throwable) {                 logger.error(""Rsocket server input connection exception caught"", e)             }         }         return output     } ```  Flow client side test:   ```     @Test     fun testPingFlow() {         val outToServer = MutableSharedFlow(10)          runBlocking {             val socketFlow = rSocketRequester                 .route(""testFlow"")                 .data(outToServer.asFlux())                 .retrieveFlow()                 .take(2)              outToServer.emit(""Ping ${System.currentTimeMillis()}"")             outToServer.emit(""Ping ${System.currentTimeMillis()}"")              socketFlow                 .onCompletion { exception ->                     logger.debug(""Rsocket client output completed"")                     if (exception != null) {                         logger.error(""Exception received while processing Rsocket client output flow"", exception)                     }                 }                 .collect { message ->                     logger.debug(""Received pong from server $message"")                 }         }     }  ```    Flux server side:  ```     @MessageMapping(""testFlux"")     fun testPingFlux(input: Flux): Flux {         val output = Sinks.many().unicast().onBackpressureBuffer()         try {             input                 .doOnNext { message ->                     logger.debug(""Rsocket server input message received $message"")                 }                 .doOnError { e ->                     logger.error(""Rsocket server input connection error"", e)                 }                 .doOnCancel {                     logger.debug(""Rsocket server input cancelled"")                 }                 .doOnComplete {                     logger.debug(""Rsocket server input completed"")                 }                 .subscribe { message ->                     output.tryEmitNext(""pong ${System.currentTimeMillis()}"")                 }         } catch (e: Throwable) {             logger.error(""Rsocket server input connection exception caught"", e)         }         return output.asFlux()     }  ```  Flux client side test: ```     @Test     fun testPingFlux() {         val outToServer = Sinks.many().unicast().onBackpressureBuffer()          rSocketRequester             .route(""testFlux"")             .data(outToServer.asFlux())             .retrieveFlux()             .doOnCancel {                 logger.debug(""Rsocket client output connection completed"")             }             .doOnError { e ->                 logger.error(""Exception received while processing Rsocket client output flow"", e)             }             .take(2)             .subscribe { message ->                 logger.debug(""Received pong from server $message"")             }          outToServer.tryEmitNext(""Ping ${System.currentTimeMillis()}"")         outToServer.tryEmitNext(""Ping ${System.currentTimeMillis()}"")     } ```  The Problem =  Both client/server snippets above do in fact send ping/pong payloads back and forth, but in each case I get no handling on the server side of the client cancelling the connection. I get my own log line of `Rsocket client output completed` from the client side, then `Operator called default onErrorDropped` from Reactor and the following stack trace from RSocket: ``` java.util.concurrent.CancellationException: Inbound has been canceled 	at io.rsocket.core.RequestChannelResponderSubscriber.tryTerminate(RequestChannelResponderSubscriber.java:357) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.RequestChannelResponderSubscriber.handleCancel(RequestChannelResponderSubscriber.java:345) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.RSocketResponder.handleFrame(RSocketResponder.java:217) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.LambdaSubscriber.onNext(LambdaSubscriber.java:160) ~[reactor-core-3.4.2.jar:3.4.2] 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onNext(ReactorContextTestExecutionListener.java:120) ~[spring-security-test-5.4.2.jar:5.4.2] 	at io.rsocket.core.ClientServerInputMultiplexer$InternalDuplexConnection.onNext(ClientServerInputMultiplexer.java:248) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.ClientServerInputMultiplexer.onNext(ClientServerInputMultiplexer.java:129) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.ClientServerInputMultiplexer.onNext(ClientServerInputMultiplexer.java:48) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.SetupHandlingDuplexConnection.onNext(SetupHandlingDuplexConnection.java:118) ~[rsocket-core-1.1.0.jar:na] 	at io.rsocket.core.SetupHandlingDuplexConnection.onNext(SetupHandlingDuplexConnection.java:19) ~[rsocket-core-1.1.0.jar:na] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.2.jar:3.4.2] 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:267) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:377) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:381) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.3.jar:1.0.3] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.58.Final.jar:4.1.58.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.58.Final.jar:4.1.58.Final] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na] ```  This is a problem as (beyond this toy example) my application needs to do server-side cleanup on connection close.  Things I Have Tried = - All the various methods to catch exceptions, cancellation, or completion on Flows or Fluxen, many of which are illustrated in the example above. - try/catch blocks in the subscribe/collect lambdas. - Coupling the server response Flux/Flow directly to the input Flux/Flow via a map operator rather than creating a separate output Flux/Flow. - Stepping through framework code in the debugger, which I am not ashamed to say lost me pretty quickly. My best theory from this adventure is that the Flux/Flow that receives the cancellation signal is somehow decoupled from the input Flux/Flow that my server method receives, but there are too many layers of abstraction for me to trace it. - I asked about this [on Stackoverflow](https://stackoverflow.com/questions/66083658/how-to-handle-inbound-stream-cancellation-in-spring-boot-rsocket-reactive?noredirect=1#comment116850453_66083658) and was told this is 'a bug in the reactor `switchOnFirst` operator which does not propagate an inbound error if outbound has been canceled' and was directed to report a bug here, so here we are. I kind of wonder if this is a Project Reactor bug because `switchOnFirst` is part of that project, but I was directed here by Oleh Dokuka, who wrote that class, so I assume he knows what he's talking about.","closed","for: external-project,","dvankley","2021-02-07T20:33:35Z","2021-11-06T20:10:27Z"
"","26239","AsyncServerResponse interoperability issue with path variables","**Affects:** \5.3.2 --- There is an interoperability issue with the new `AsyncServerResponse` and routing functions. I tried to create a test in the webmvc project, but I'm afraid I don't know the framework well enough to reproduce it there. Instead there is a reproduction using springboot, with all the latest greatest spring, and webmvc is managed to 5.3.2-snapshot. [spring-webmvc-interop-bug](https://github.com/alexfeigin/spring-webmvc-interop-bug)  when routing a request that has path variables, we get routed correctly, and get to a function that returns a `ServerResponse.async` response, but during the handling of the response, the routing function is called again, and we get an exception `org.springframework.web.util.pattern.PatternParseException: Not allowed to capture 'pathVariable' twice in the same pattern`  This does not happen if the response is a non async ServerResponse.","closed","type: bug,","alexfeigin","2020-12-08T09:41:53Z","2020-12-08T12:23:18Z"
"","25879","NullPointerException when running a SpringBootTest with webMvc.fn and ResourceServer","**Affects:** \5.2.9 **Affects:** \security: 5.3.4  ---  I have the following code, where `testBWithAuth` throws a null pointer exception.  ```java  @SpringBootTest @ContextConfiguration(classes = Configuration.class) public class ApplicationTest {    private static String signingKey = ""signingKey"";    @TestConfiguration   @EnableResourceServer   public static class Configuration extends ResourceServerConfigurerAdapter {      @Override     public void configure(HttpSecurity http) throws Exception {       http.cors();       http.authorizeRequests().anyRequest().authenticated();       http.sessionManagement().sessionCreationPolicy(STATELESS);     }       @Bean     @Primary     public DefaultTokenServices tokenServices() {       DefaultTokenServices defaultTokenServices = new DefaultTokenServices();       defaultTokenServices.setTokenStore(tokenStore());       defaultTokenServices.setSupportRefreshToken(true);       return defaultTokenServices;     }      @Bean     TokenStore tokenStore() {       return new JwtTokenStore(accessTokenConverter());     }      @Bean     JwtAccessTokenConverter accessTokenConverter() {       final JwtAccessTokenConverter converter = new JwtAccessTokenConverter();       converter.setSigningKey(signingKey);       return converter;     }       @Bean     RouterFunction routerFunction() {       final Builder routerBuilder = route();        routerBuilder         .GET(""a"", x -> ServerResponse.ok().body(""A""))         .GET(""b"", x -> ServerResponse.ok().body(""B""))       ;        return routerBuilder.build();     }   }    MockMvc mockMvc;    @Autowired   WebApplicationContext context;     public static String createToken() {      final JwtBuilder jwtBuilder = Jwts.builder();     String token = jwtBuilder       .claim(""user_name"", ""123"")       .signWith(         SignatureAlgorithm.HS256, Base64.getEncoder().encodeToString(signingKey.getBytes()))       .compact();     return String.format(""Bearer %1$s"", token);   }    @Test   void testAWithAuth() throws Exception {     mockMvc = MockMvcBuilders.webAppContextSetup(this.context)       .apply(springSecurity()).build();      mockMvc.perform(get(""/a"")       .header(""Authorization"", createToken())     ).andExpect(status().isOk());   }    @Test   void testBWithAuth() throws Exception {     mockMvc = MockMvcBuilders.webAppContextSetup(this.context)       .apply(springSecurity())       .build();      mockMvc.perform(get(""/b"")       .header(""Authorization"", createToken())     )       .andExpect(status().isOk());   }    @Test   void testAWithoutAuth() throws Exception {     mockMvc = MockMvcBuilders.webAppContextSetup(this.context).build();      mockMvc.perform(get(""/a"")).andExpect(status().isOk());   }    @Test   void testBWithoutAuth() throws Exception {     mockMvc = MockMvcBuilders.webAppContextSetup(this.context).build();      mockMvc.perform(get(""/b"")).andExpect(status().isOk());   }  } ```  When adding more endpoints, they will also fail with a null pointer exception, only the first route can succeed.  I could trigger the NPE with the resource server only and not with ""normal"" JWT authentication. Also when disabling springSecurity (see tests), the code seems to work. However, when tracking down this issue I stumbled mainly over spring-framework classes and not over spring-security classes. This is why I am posting the issue here.  ### My current analysis is the following:  `org.springframework.test.web.servlet.MockMvc.MVC_RESULT_ATTRIBUTE` gets deleted before the handler method is called. Thus, after the execution of the handler function, when writing back the result, the search for this attribute results in `null`. Thus setting the value results in a NullPointerExceptino.  In fact, during execution of the springSecurity filter chain several attributes on the request are deleted since the `restoreAttributes` methods of  `RequestPredicates` are unable to restore attributes in the map implementation of `HandlerMappingIntrospector.RequestAttributeChangeIgnoringWrapper`.  Currently, as a workaround I disable the CorsFilter in the FilterChainProxy.  ### Further Observations  The same setup worked for a standard setup with mappings via annotations only. However, when using WebMVC.fn those fail on tests as well. The issue does not seem to occur when starting the server itself (At least the mappings via annotations still seem to work).  ### Pointers to source code:  https://github.com/spring-projects/spring-framework/blob/fee8abfa5f54b9fa45f6f5a491bbbec1ac53b0a0/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/HandlerMappingIntrospector.java#L156-L164  `getHandler` calls eventually `route` of `RouterFunctionBuilder`  https://github.com/spring-projects/spring-framework/blob/fee8abfa5f54b9fa45f6f5a491bbbec1ac53b0a0/spring-webmvc/src/main/java/org/springframework/web/servlet/function/RouterFunctionBuilder.java#L359-L368  Which in turn will `test` a route and after the test `restoreAttributes`  https://github.com/spring-projects/spring-framework/blob/fee8abfa5f54b9fa45f6f5a491bbbec1ac53b0a0/spring-webmvc/src/main/java/org/springframework/web/servlet/function/RequestPredicates.java#L294-L299  `putAll` is implemented via `put` which uses `setAttribute`  https://github.com/spring-projects/spring-framework/blob/fee8abfa5f54b9fa45f6f5a491bbbec1ac53b0a0/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/HandlerMappingIntrospector.java#L233-L249","open","in: web,","tobiaslieber-aroov","2020-10-07T22:17:49Z","2021-11-08T11:41:46Z"
"","25955","WildFly WFLYEE0007 ""Not installing optional component"" warning when deploying spring-framework >5.0 WAR for o.s.h.s.r.ServletServerHttpResponse$ResponseAsyncListener and others","**Affects:** \5.0 and newer, latest test 5.3.0-RC2  To reproduce:  1) Download a WildFly https://www.wildfly.org/downloads/ unzip in a folder of your choice 2) Create a simple spring initializr project, time of writing this issue 2.4.0M4; Packaging WAR; Java 8. One Dependency Spring Web. 3) Run the build and create the WAR file 4) Copy the result out of 3 to /standalone/deployments 5) modify /standalone/configuration/standalone.xml ; add logger ```                                            ``` 6) Start the server, observe /standalone/log/server.log (It will not appear on the console!)  The following classes are missing a default constructor, which was removed in 5.0  - org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseAsyncListener - org.springframework.http.server.reactive.ServletServerHttpRequest$RequestAsyncListener - org.springframework.http.server.reactive.ServletHttpHandlerAdapter$HandlerResultAsyncListener - org.springframework.http.server.ServletServerHttpAsyncRequestControl - org.springframework.web.context.request.async.StandardServletAsyncWebRequest  **Please check, whether you can add safely a default constructor**  Warnings in server.log ``` 2020-10-22 10:59:04,188 WARN  [org.jboss.as.ee] (MSC service thread 1-3) WFLYEE0007: Not installing optional component org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseAsyncListener due to an exception (enable DEBUG log level to see the cause) 2020-10-22 10:59:04,188 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Not installing optional component org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseAsyncListener due to an exception: org.jboss.as.server.deployment.DeploymentUnitProcessingException: WFLYEE0048: Could not find default constructor for class org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseAsyncListener 	at org.jboss.as.ee.component.DefaultInterceptorConfigurator.configure(DefaultInterceptorConfigurator.java:92) 	at org.jboss.as.ee.component.deployers.EEModuleConfigurationProcessor.deploy(EEModuleConfigurationProcessor.java:92) 	at org.jboss.as.server.deployment.DeploymentUnitPhaseService.start(DeploymentUnitPhaseService.java:144) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1739) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1701) 	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1559) 	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) 	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1985) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1487) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1378) 	at java.lang.Thread.run(Thread.java:748)  2020-10-22 10:59:04,188 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Configuring component class: org.springframework.http.server.reactive.ServletHttpHandlerAdapter$HandlerResultAsyncListener named org.springframework.http.server.reactive.ServletHttpHandlerAdapter$HandlerResultAsyncListener 2020-10-22 10:59:04,188 WARN  [org.jboss.as.ee] (MSC service thread 1-3) WFLYEE0007: Not installing optional component org.springframework.http.server.reactive.ServletHttpHandlerAdapter$HandlerResultAsyncListener due to an exception (enable DEBUG log level to see the cause) 2020-10-22 10:59:04,188 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Not installing optional component org.springframework.http.server.reactive.ServletHttpHandlerAdapter$HandlerResultAsyncListener due to an exception: org.jboss.as.server.deployment.DeploymentUnitProcessingException: WFLYEE0048: Could not find default constructor for class org.springframework.http.server.reactive.ServletHttpHandlerAdapter$HandlerResultAsyncListener 	at org.jboss.as.ee.component.DefaultInterceptorConfigurator.configure(DefaultInterceptorConfigurator.java:92) 	at org.jboss.as.ee.component.deployers.EEModuleConfigurationProcessor.deploy(EEModuleConfigurationProcessor.java:92) 	at org.jboss.as.server.deployment.DeploymentUnitPhaseService.start(DeploymentUnitPhaseService.java:144) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1739) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1701) 	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1559) 	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) 	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1985) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1487) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1378) 	at java.lang.Thread.run(Thread.java:748)  2020-10-22 10:59:04,198 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Configuring component class: org.springframework.http.server.ServletServerHttpAsyncRequestControl named org.springframework.http.server.ServletServerHttpAsyncRequestControl 2020-10-22 10:59:04,198 WARN  [org.jboss.as.ee] (MSC service thread 1-3) WFLYEE0007: Not installing optional component org.springframework.http.server.ServletServerHttpAsyncRequestControl due to an exception (enable DEBUG log level to see the cause) 2020-10-22 10:59:04,198 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Not installing optional component org.springframework.http.server.ServletServerHttpAsyncRequestControl due to an exception: org.jboss.as.server.deployment.DeploymentUnitProcessingException: WFLYEE0048: Could not find default constructor for class org.springframework.http.server.ServletServerHttpAsyncRequestControl 	at org.jboss.as.ee.component.DefaultInterceptorConfigurator.configure(DefaultInterceptorConfigurator.java:92) 	at org.jboss.as.ee.component.deployers.EEModuleConfigurationProcessor.deploy(EEModuleConfigurationProcessor.java:92) 	at org.jboss.as.server.deployment.DeploymentUnitPhaseService.start(DeploymentUnitPhaseService.java:144) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1739) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1701) 	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1559) 	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) 	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1985) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1487) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1378) 	at java.lang.Thread.run(Thread.java:748)  2020-10-22 10:59:04,198 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Configuring component class: org.springframework.web.context.request.async.StandardServletAsyncWebRequest named org.springframework.web.context.request.async.StandardServletAsyncWebRequest 2020-10-22 10:59:04,198 WARN  [org.jboss.as.ee] (MSC service thread 1-3) WFLYEE0007: Not installing optional component org.springframework.web.context.request.async.StandardServletAsyncWebRequest due to an exception (enable DEBUG log level to see the cause) 2020-10-22 10:59:04,198 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Not installing optional component org.springframework.web.context.request.async.StandardServletAsyncWebRequest due to an exception: org.jboss.as.server.deployment.DeploymentUnitProcessingException: WFLYEE0048: Could not find default constructor for class org.springframework.web.context.request.async.StandardServletAsyncWebRequest 	at org.jboss.as.ee.component.DefaultInterceptorConfigurator.configure(DefaultInterceptorConfigurator.java:92) 	at org.jboss.as.ee.component.deployers.EEModuleConfigurationProcessor.deploy(EEModuleConfigurationProcessor.java:92) 	at org.jboss.as.server.deployment.DeploymentUnitPhaseService.start(DeploymentUnitPhaseService.java:144) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1739) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1701) 	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1559) 	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) 	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1985) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1487) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1378) 	at java.lang.Thread.run(Thread.java:748)  2020-10-22 10:59:04,198 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Configuring component class: org.springframework.http.server.reactive.ServletServerHttpRequest$RequestAsyncListener named org.springframework.http.server.reactive.ServletServerHttpRequest$RequestAsyncListener 2020-10-22 10:59:04,206 WARN  [org.jboss.as.ee] (MSC service thread 1-3) WFLYEE0007: Not installing optional component org.springframework.http.server.reactive.ServletServerHttpRequest$RequestAsyncListener due to an exception (enable DEBUG log level to see the cause) 2020-10-22 10:59:04,206 DEBUG [org.jboss.as.ee] (MSC service thread 1-3) Not installing optional component org.springframework.http.server.reactive.ServletServerHttpRequest$RequestAsyncListener due to an exception: org.jboss.as.server.deployment.DeploymentUnitProcessingException: WFLYEE0048: Could not find default constructor for class org.springframework.http.server.reactive.ServletServerHttpRequest$RequestAsyncListener 	at org.jboss.as.ee.component.DefaultInterceptorConfigurator.configure(DefaultInterceptorConfigurator.java:92) 	at org.jboss.as.ee.component.deployers.EEModuleConfigurationProcessor.deploy(EEModuleConfigurationProcessor.java:92) 	at org.jboss.as.server.deployment.DeploymentUnitPhaseService.start(DeploymentUnitPhaseService.java:144) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.startService(ServiceControllerImpl.java:1739) 	at org.jboss.msc.service.ServiceControllerImpl$StartTask.execute(ServiceControllerImpl.java:1701) 	at org.jboss.msc.service.ServiceControllerImpl$ControllerTask.run(ServiceControllerImpl.java:1559) 	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35) 	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1985) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1487) 	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1378) 	at java.lang.Thread.run(Thread.java:748)   ```","closed","status: feedback-provided,","bunckelvhv","2020-10-22T10:57:52Z","2022-02-18T19:06:31Z"
"","26045","Spring 5.2.10.RELEASE tries too flush closed OutputStream on HTTP response","**Affects:** \  --- Starting from version 5.2.10.RELEASE on HTTP response AbstractGenericHttpMessageConverter (Jackson) tries too flush already closed stream .  Seems Tomcat handles this gracefully, even if `org.apache.catalina.connector.OutputBuffer.closed == true` on the last flush. But this causes problems for OpenLiberty: [https://github.com/OpenLiberty/open-liberty/issues/14875](https://github.com/OpenLiberty/open-liberty/issues/14875) Here is repository with example for OL: https://github.com/pkunk/wlp-spring","closed","status: duplicate,","pkunk","2020-11-07T22:57:51Z","2020-11-08T00:32:41Z"
"","26637","How to get request header in webflux aspect?","**Affects:** \  **stackoverflow** https://stackoverflow.com/questions/66468364/how-to-get-request-header-in-weblux-aspect","closed","for: stackoverflow,","Zengzehao","2021-03-04T04:03:20Z","2021-03-04T07:37:08Z"
"","26357","Allow Spring Security Authentication to be directly set in REST request header for Spring WebFlux WebClient","**Affects:** \      If this is not the right place for this issue, please let me know.  ---  There is a specific issue with Spring Security and Spring WebFlux's WebClient in general, where it is not that easy to understand how to pass the authentication from the Spring Framework MVC controller directly into WebClient, if the project does not use `OAuth2Authentication`, and when the Spring Security is configured so that the endpoints must require authority (ROLE_ etc.).  The username and password can be obtained from the `Authentication` object passed into the Spring controller method argument. However, the password is BCrypt-encoded and is not viewable in plain text form.  Here's a code example:  ```java   @RequestMapping (value = ""/whatever"") public String passthroughToSpringBootActuator(Authentication auth, HttpServletRequest request, HttpSession session) { 	//Do some magic with the user-authorized authentication.  	String baseUrl = request.getRequestUrl().toString().replace(request.getRequestUri().toString(), """");  	WebClient webClient = WebClient.builder().baseUrl(baseUrl).build(); 	String json = webClient 		.get() 		.uri(baseUrl + ""/actuator"") 		 		//Do some voodoo magic here that sets the ""Authorization"" token with the user-authorized authentication from above 		.headers(headers -> ...) 		 		.retrieve().bodyToMono(String.class).block();  	//Do stuffs with the JSON response.  	//... 	return ""myFoo.page""; } ```  The purpose of the code above is to invoke a REST GET request to a Spring Boot Actuator to get JSON data back, and doing so while Spring Security made the actuator endpoints all requiring the user having some authority (roles). It is simple as that.  On the line `.headers(headers -> ...)`, the WebClient `headers` can invoke these methods, `setBasicAuth(...)`, and `setBearerToken(...)`. But none of these methods allow the developer to create a valid basic authentication header token if the password is BCrypt-encoded.  I wanted to request for an enhancement, to allow a direct way of setting the `Authorization` request header with something that can be obtained from the `Authentication` object that is passed in as the argument of the Spring controller method. That way, the Spring WebFlux WebClient can send a REST request to an endpoint secured by Spring Security, with little complexity involved.  Otherwise, the current scope of only obtaining the JSON response data from an endpoint (or Spring Boot Actuator) secured by Spring Security would explode in complexity, all because Spring Security requires the endpoint to be accessible only to those with the proper authorities/roles.  Or, we can set the endpoints to be permitted by all in Spring Security, but this will compromise the integrity of the security around those endpoints.  I do not see a way to pass `Authentication` object or derived objects from `Authentication`, to WebClient to get through to the endpoint through Spring Security, while the user's password credential is BCrypt-encoded,","closed","for: stackoverflow,","tommai78101","2021-01-07T18:17:17Z","2021-01-08T21:51:37Z"
"","26481","NamedParameterJdbcTemplate.query() breaks handling of SqlParameterValue with a collection of UUID's","**Affects:** [v5.2.12.RELEASE](https://github.com/spring-projects/spring-framework/releases/tag/v5.2.12.RELEASE) (Spring Boot `v2.3.7.RELEASE`)  I have a PostgreSQL query  ```sql SELECT * FROM items WHERE id IN (:ids) ```  executed as   ```java var jdbcTemplate = new NamedParameterJdbcTemplate(new JdbcTemplate(dataSource)); RowMapper rowMapper = null; // not relevant  List ids = List.of(     UUID.fromString(""57feb862-b8e4-4754-8b75-4e2621388fa0""),     UUID.fromString(""2225559e-97d3-4839-b7b4-a97f4f4f49a9"") );  var parameters = new LinkedHashMap(); parameters.put(""ids"", new SqlParameterValue(Types.OTHER, ids));  var query = ""SELECT * FROM items WHERE id IN (:ids)"";  var result = jdbcTemplate.query(query, parameters, rowMapper); ```  Previously, this happily worked, it expanded the collection to a list of parameters and executed it.  ``` org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback; SQL [SELECT * FROM items WHERE id IN (?, ?)]; No value specified for parameter 2.; nested exception is org.postgresql.util.PSQLException: No value specified for parameter 2.     at org.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:104)     at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72)     at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81)     at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81)     at org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1443)     at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:633)     at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:669)     at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:694)     at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:748)     at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query(NamedParameterJdbcTemplate.java:216)     at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query(NamedParameterJdbcTemplate.java:223)     ...  org.postgresql.util.PSQLException: No value specified for parameter 2.     at org.postgresql.core.v3.SimpleParameterList.checkAllParametersSet(SimpleParameterList.java:275)     at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:307)     at org.postgresql.jdbc.PgStatement.executeInternal(PgStatement.java:473)     at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:393)     at org.postgresql.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:164)     at org.postgresql.jdbc.PgPreparedStatement.executeQuery(PgPreparedStatement.java:114)     at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeQuery(ProxyPreparedStatement.java:52)     at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.executeQuery(HikariProxyPreparedStatement.java)     at org.springframework.jdbc.core.JdbcTemplate$1.doInPreparedStatement(JdbcTemplate.java:678)     at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:617)     at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:669)     at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:694)     at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:748)     at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query(NamedParameterJdbcTemplate.java:216)     at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query(NamedParameterJdbcTemplate.java:223)     ... ```  I've tried to debug it and at some point, the parameters that it's trying to bind to the prepared statement contain string like this  ```java String valueBeforeApplyingToPrepareStatement = ""['57feb862-b8e4-4754-8b75-4e2621388fa0', '2225559e-97d3-4839-b7b4-a97f4f4f49a9']""; ```  which suggest to me that the query is correctly expanded based on the number of values in the collection, but the parameter is then converted somehow to a single value, which breaks the parameter binding","closed","status: feedback-provided,","fprochazka","2021-01-31T16:02:33Z","2021-02-15T10:06:23Z"
"","25885","Non-compliant Content-Type header for multipart media types","**Affects:** 5.x --- The `org.springframework.http.codec.multipart` package contains various methods for building a `Content-Type` header for `multipart` media types. The default method produces a header with the following format:  `""multipart/{sub-type};boundary={boundary};charset={charset|UTF-8}""`  However, [RFC7578](https://www.iana.org/assignments/media-types/multipart/form-data) specifies only a required parameter of `boundary` and optional parameters as `none`. Hence, the addition of a charset parameter is not strictly in accordance with RCF7578. Robust server implementations should ignore this parameter, but some do not (in my case, civetweb), causing request failures. Here are the relevant framework versions and code locations causing the problems:  - master: https://github.com/spring-projects/spring-framework/blob/24bd0148d5e569d8f995c422496ef325e6aa8379/spring-web/src/main/java/org/springframework/http/codec/multipart/MultipartWriterSupport.java#L105 - 5.x.x: https://github.com/spring-projects/spring-framework/blob/ec9de943eef738caf9d2a7a8a591aed170b5899d/spring-web/src/main/java/org/springframework/http/codec/multipart/MultipartHttpMessageWriter.java#L234 - < 5.x implementations work differently, I haven't taken time to verify.  I'd like to hear concerns - is removing charset for multipart requests appropriate?","closed","type: bug,","rcgardne","2020-10-08T15:52:58Z","2020-11-24T14:20:24Z"
"","26290","Non-compliant Content-Type header for multipart media type","**Affects:** 5.x  --- Two months ago [similar issue](https://github.com/spring-projects/spring-framework/issues/25885) has been submitted but has already been fixed and released so I'm opening a new one.  I also came across a server that is not robust enough and fails when `charset` is used as a parameter inside `Content-Type` header for `multipart` media type. As specified by [RFC7578](https://www.iana.org/assignments/media-types/multipart/form-data), only `boundary` is a required parameter and there are no optional parameters.  I'm submitting an issue for `FormHttpMessageConverter`. Same logic applied as a fix for #25885 can probably be used in this situation also.  https://github.com/spring-projects/spring-framework/blob/a109b4c31a29a9a6c147e3238e14be27d70527f9/spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java#L478  _Edit:_ I know there is a workaround where one can use `setMultipartCharset()` to prevent `charset` from showing in header. In my opinion it would be better if `Content-Type` header was aligned with specification and it worked in same fashion as `MultipartWriterSupport` now works.","closed","type: bug,","ijakus","2020-12-16T23:57:40Z","2021-01-08T13:06:59Z"
"","26453","UriComponentsBuilder documentation error for HTTP request encoding","**Affects:** 5.3.x and potentially earlier releases  ---  In `src/docs/asciidoc/web/web-uris.adoc` (https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#web-uri-encoding )  I think there is a bug in the example right after the following text ""You can shorten it further still with a full URI template, as the following example shows:""  ```java 	URI uri = UriComponentsBuilder.fromPath(""/hotel list/{city}?q={q}"") 			.build(""New York"", ""foo+bar"") ```  should be  ```java 	URI uri = UriComponentsBuilder.fromStringUri(""/hotel list/{city}?q={q}"") 			.build(""New York"", ""foo+bar"") ```  See in jshell:  ```shell jshell> UriComponentsBuilder.fromPath(""/hotel list/{city}?q={q}"")  .build(""New York"", ""foo+bar"") $37 ==> /hotel%20list/New%20York%3Fq=foo%2Bbar  jshell> UriComponentsBuilder.fromUriString(""/hotel list/{city}?q={q}"")  .build(""New York"", ""foo+bar"") $38 ==> /hotel%20list/New%20York?q=foo%2Bbar ```  In the first case, the question mark indicating the beginning of the query string has been incorrectly escaped.","closed","type: documentation,","jonenst","2021-01-27T13:34:52Z","2021-01-27T14:18:29Z"
"","26777","Addition of fallback patterns to temporal parser loses cause in Spring 5.3.5","**Affects:** 5.3.5  We've just pulled in the latest spring framework as a result of a spring boot upgrade to 2.4.4 and noticed that some of our unit tests are now failing as the error messages have now changed.  When we detect a validation failure our code calls `e.getMostSpecificCause().getMessage()` to get the reason for the failure.  So for input value of `2019-30-17` we expect to get the error message of  ``` Invalid value for MonthOfYear (valid values 1 - 12): 30 ```  as that is what the root `DateTimeException` message is set to.  However it appears that changes for #20292 create a brand new `DateTimeParseException` without passing in the `cause` into the constructor on creation.  This can be seen at https://github.com/spring-projects/spring-framework/blob/b2bcb0f93ad04a6ddc729a487f9346defa6c39d6/spring-context/src/main/java/org/springframework/format/datetime/standard/TemporalAccessorParser.java#L102 and should be changed to pass through the existing `DateTimeException` cause.  This means that the error message we now get is  ``` Unable to parse date time value ""2019-30-17"" using configuration from @org.springframework.format.annotation.DateTimeFormat(pattern="""", style=""SS"", iso=DATE, fallbackPatterns={}) ```  which isn't nearly as human readable as the original, divulges inner spring annotations, and isn't suitable for end users.  I understand that there is a desire to output the `fallbackPatterns` in case there are multiple specified, but I would have expected the underlying cause to be preserved so that applications can choose which cause to present to the user.  Furthermore I wouldn't expect patch versions of spring to change the validation error messages.  In our spring boot code the field is annotated with  ```java  @DateTimeFormat(iso = ISO.DATE) @RequestParam(value = ""from_date"", required = false) LocalDate fromDate ```","closed","in: core,","petergphillips","2021-04-08T13:13:42Z","2021-04-20T16:50:12Z"
"","26691","Version agnostic URLs for Webjars fail on JBoss EAP7.3 with multiple deployments","**Affects:** 5.3.5  ---  Please see https://github.com/jensdt/spring-webjar-resolve-issue for a project that easily reproduces this issue on an out-of-the-box JBoss EAP 7.3 installation.  If you deploy 2 completely separate WAR files on JBoss EAP 7.3 containing WebJar libraries for the same library but with a different version, only the WAR that is deployed first will be able to use version agnostic URLS.   For example:  my-deployable contains swagger-ui-0.44.0.jar my-second-deployable contains swagger-ui-0.45.0.jar  There are no cross-dependencies whatsoever between these applications.  Version-agnotic WebJar URLs only work for the application that is deployed first.  Note that webjars-locator-jboss-vfs has no impact on this (and it seems no longer required to run on newer JBoss versions, like 7.3).  It seems triggered by the Classpath scanning of the WebJar-locator library, where it picks up JAR files that are not on the classpath of the WAR itself, but also JARs that belong to other applications, but I'm unsure whether this is a bug in that library or in the way that Spring uses it, that's why I'm reporting this issue here.","open","in: web,","jensdt","2021-03-17T08:40:30Z","2021-11-12T14:16:21Z"
"","26444","Difficulty importing root project 'spring' into IDEA","**Affects:** 5.3.4-SNAPSHOT  When importing into idea:  ``` Warning:root project 'spring': Unable to resolve additional project configuration. Details: java.lang.IllegalStateException: Resolving dependency configuration 'testFixturesCompileOnly' is not allowed as it is defined as 'canBeResolved=false'. Instead, a resolvable ('canBeResolved=true') dependency configuration that extends 'testFixturesCompileOnly' should be resolved. ```","closed","status: feedback-provided,","vmvm-org","2021-01-26T09:55:47Z","2021-01-27T11:06:38Z"
"","26693","WebClient - configuring reactor-netty's `disableRetry` setting","**Affects:** 5.3.4 and earlier versions  I'm using WebClient.  I've found that it automatically retries once any requests that experiencea connection reset.  This seams to be caused by a feature in `reactor-netty`:   https://github.com/reactor/reactor-netty/issues/587#issuecomment-655686821  Is there a way to configure reactor-netty's `disableRetry` setting when using WebClient?  Thanks","closed","status: invalid,","msmsimondean","2021-03-17T12:00:25Z","2021-03-23T14:27:03Z"
"","26464","SimpMessagingTemplate.convertAndSend causes hanging thread","**Affects:** 5.3.3.RELEASE  I'm using spring boot 2.4.2 with RabbitMQ as message broker and spring-boot-starter-jetty. I got an issue on my production server with a jetty thread hangs so long time(almost 2 days) with the thread dump information as below  ``` ""qtp682812632-42"" Id=0x2a WAITING on java.util.concurrent.CompletableFuture$Signaller@1601acdf           at java.base@11.0.9.1/jdk.internal.misc.Unsafe.park(Native Method)           -  waiting on java.util.concurrent.CompletableFuture$Signaller@1601acdf           at java.base@11.0.9.1/java.util.concurrent.locks.LockSupport.park(LockSupport.java:194)           at java.base@11.0.9.1/java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1796)           at java.base@11.0.9.1/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3128)           at java.base@11.0.9.1/java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1823)           at java.base@11.0.9.1/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1998)           at org.springframework.util.concurrent.CompletableToListenableFutureAdapter.get(CompletableToListenableFutureAdapter.java:99)           at org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler$SystemSessionConnectionHandler.forward(StompBrokerRelayMessageHandler.java:1081)           at org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.handleMessageInternal(StompBrokerRelayMessageHandler.java:599)           at org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler.handleMessage(AbstractBrokerMessageHandler.java:262)           at org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:144)           at org.springframework.messaging.support.ExecutorSubscribableChannel.sendInternal(ExecutorSubscribableChannel.java:100)           at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:139)           at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:125)           at org.springframework.messaging.simp.SimpMessagingTemplate.sendInternal(SimpMessagingTemplate.java:187)           at org.springframework.messaging.simp.SimpMessagingTemplate.doSend(SimpMessagingTemplate.java:162)           at org.springframework.messaging.simp.SimpMessagingTemplate.doSend(SimpMessagingTemplate.java:48)           at org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)           at org.springframework.messaging.core.AbstractMessageSendingTemplate.convertAndSend(AbstractMessageSendingTemplate.java:151)           at org.springframework.messaging.core.AbstractMessageSendingTemplate.convertAndSend(AbstractMessageSendingTemplate.java:129)           at org.springframework.messaging.core.AbstractMessageSendingTemplate.convertAndSend(AbstractMessageSendingTemplate.java:122) ```  For sending messages, I just using this code:  ```java response.getMessageList().forEach(m -> messageTemplate.convertAndSend(m.getTopicUrl(), m.getMessageData())); response.setMessageList(null); //Remove message list return response; ```  Any help would be appreciated.","closed","for: external-project,","hurahurat","2021-01-28T04:37:46Z","2021-06-25T16:04:42Z"
"","26615","ServerHttpRequest content-type cannot be mutated","**Affects:** 5.3.3 Library: `spring-web` --- The `ReadOnlyHttpHeaders` type wraps an existing (mutable) `MultiValueMap`. That map can be updated independently without going through the `ReadOnlyHttpHeaders` interface. This makes it inappropriate to cache the `Accept` and `Content-Type` headers.  For example: I am working on a Spring Cloud Gateway project. Because the multipart/form-data parser does not correctly handle quoted boundary values (a separate issue) I tried to write both a `GlobalFilter` and a `WebFilter` that would unwrap the boundary value before I attempt to use the built-in decoders for form data. This doesn't work, though, because the original quoted value is cached in a `ReadOnlyHttpHeaders` instance, even though its backing `MultiValueMap` was updated by my filter.  See an example snippet below: ```     @Override     public Mono filter(ServerWebExchange exchange, WebFilterChain chain) {         var headers = exchange.getRequest().getHeaders();         if(headers.getContentType().isCompatibleWith(MediaType.MULTIPART_FORM_DATA)) {             LOG.trace(""Examining multipart/form-data request"");             // Check the boundary value and rewrite it if necessary             return chain.filter(exchange.mutate().request(req -> req.headers(original -> {                 var contentTypeValue = original.getFirst(""Content-Type"");                 LOG.trace(""Original Content-Type header:"" + contentTypeValue);                 var matcher = BOUNDARY.matcher(contentTypeValue);                 var found = matcher.find();                 if(!found) {                     throw new IllegalStateException(""A Content-Type header must specify a boundary for a multipart/form-data request ("" + contentTypeValue + "")"");                 }                 var boundary = matcher.group(""boundary"");                 if(boundary.startsWith(""\"""") && boundary.endsWith(""\"""")) {                     //original.setContentType(new MediaType(""multipart/form-data; boundary="" + boundary.substring(1, boundary.length() - 1)));                     original.set(""Content-Type"", ""multipart/form-data; boundary="" + boundary.substring(1, boundary.length() - 1));                 }                 LOG.trace(""Modified Content-Type header:"" + original.getContentType());             })).build());         }                  return chain.filter(exchange);     } ``` The headers passed to the builder method are mutable and are intended to allow for this use case -- great! But then when I get to the actual boundary detection code in the multipart codec shipped with Spring Cloud Gateway, it does the following: ``` 	@Nullable 	private static byte[] boundary(HttpMessage message) { 		MediaType contentType = message.getHeaders().getContentType(); 		if (contentType != null) { 			String boundary = contentType.getParameter(""boundary""); 			if (boundary != null) { 				return boundary.getBytes(StandardCharsets.ISO_8859_1); 			} 		} 		return null; 	} ``` That `HttpMessage#getHeaders()` returns a `ReadOnlyHttpHeaders` instance, which someone else has already called `getContentType()` on before my filter ran. So I'm stuck with the 'broken' value of the boundary and my code dies. I have no other way to rewrite that request short of running a whole separate gateway instance in front of my actual gateway to rewrite that header and forward it.  It's not obvious why those two headers require caching. There are no comments describing reasons why they are particularly expensive to compute, for example.","closed","type: bug,","TomRK1089","2021-02-26T20:05:34Z","2021-03-01T20:01:04Z"
"","26616","Multipart boundary should strip quotes","**Affects:** 5.3.3 Library: `spring-web` --- Although uncommon, some HTTP clients will quote the multipart boundary value. This does appear to be acceptable based on a reading of the RFC. As a specific example, the .NET SDK's `HttpClient` class will generate a quoted UUID to use as the boundary:  ``` POST /foo HTTP/1.1 Content-Type: multipart/form-data; boundary=""7e296554-91ca-4075-ada1-c72043296dd7"" Host: foo.bar.example Content-Length:  Expect: 100-continue  --7e296554-91ca-4075-ada1-c72043296dd7 Content-Type: text/plain; charset=utf-8 Content-Disposition: form-data; name=Foo  BAR --7e296554-91ca-4075-ada1-c72043296dd7-- ```  The problem is the codec shipped with `spring-web` does not handle this case: ``` 	@Nullable 	private static byte[] boundary(HttpMessage message) { 		MediaType contentType = message.getHeaders().getContentType(); 		if (contentType != null) { 			String boundary = contentType.getParameter(""boundary""); 			if (boundary != null) { 				return boundary.getBytes(StandardCharsets.ISO_8859_1); 			} 		} 		return null; 	} ```  The code should check the `boundary` string to see if it starts and ends with an ASCII double-quote (`""`). If so, it should strip them before creating the byte array to be used later.  See https://github.com/spring-projects/spring-framework/issues/26615 which led to me discovering this issue.","closed","type: bug,","TomRK1089","2021-02-26T20:09:58Z","2021-03-01T14:54:58Z"
"","26533","Tracing information is missing when Exception is thrown from Scheduled methods","**Affects:** 5.3.3 ---  The issue was originally reported for Spring Cloud Sleuth but it seems it is not a Sleuth issue (and I can't transfer issues across orgs) so I'm opening this one to track it at the right place.  The original issue is this: https://github.com/spring-cloud/spring-cloud-sleuth/issues/1729 opened by @sting2804 It contains the details to understand what is going on, a sample project that reproduces the issue and some investigation details. The issue is very similar to https://github.com/spring-cloud/spring-cloud-sleuth/issues/1660  **Description** When an exception is thrown from a method annotated with `@Scheduled` all tracing information is lost when it reaches the error handler and error logs do not contain tracing information.  **Sample**: https://github.com/jonatan-ivanov/sleuth-gh-1729  Investigation details: https://github.com/spring-cloud/spring-cloud-sleuth/issues/1729#issuecomment-750448639 (also see spring-cloud/spring-cloud-sleuth#1660) Possible fix (breaking change): should be similar to https://github.com/spring-projects/spring-amqp/pull/1287","open","in: core,","jonatan-ivanov","2021-02-09T22:26:46Z","2021-11-10T12:03:15Z"
"","26532","Tracing information is missing when Exception is thrown from JmsListener methods","**Affects:** 5.3.3 ---  The issue was originally reported for Spring Cloud Sleuth but it seems it is not a Sleuth issue (and I can't transfer issues across orgs) so I'm opening this one to track it at the right place.  The original issue is this: https://github.com/spring-cloud/spring-cloud-sleuth/issues/1663 opened by @m-grzesiak It contains the details to understand what is going on, a sample project that reproduces the issue and some investigation details. The issue is very similar to https://github.com/spring-cloud/spring-cloud-sleuth/issues/1660  **Description** When an exception is thrown from a method annotated with `@JmsListener` all tracing information is lost when it reaches the error handler and error logs do not contain tracing information.  **Sample**: https://github.com/jonatan-ivanov/sleuth-gh-1663  Investigation details: https://github.com/spring-cloud/spring-cloud-sleuth/issues/1663#issuecomment-749835267 (also see spring-cloud/spring-cloud-sleuth#1660) Possible fix (breaking change): should be similar to https://github.com/spring-projects/spring-amqp/pull/1287","open","in: messaging,","jonatan-ivanov","2021-02-09T22:19:54Z","2021-11-11T09:33:01Z"
"","26495","Missing CORS Headers for Static Resources in WebFlux","**Affects:** 5.3.3 **Affected component:** WebFlux  I created a configuration that roughly looks like this:  ```java @EnableWebFlux @Configuration class WebfluxConfig : WebFluxConfigurer {     override fun addResourceHandlers(registry: ResourceHandlerRegistry) {         registry.addResourceHandler(""/public/**"")             .addResourceLocations(""classpath:/public/"")     }      override fun addCorsMappings(registry: CorsRegistry) {         registry.addMapping(""/public/**"")             .allowedMethods(""GET"", ""OPTIONS"")             .allowedOriginPatterns(""*"")     } } ```  **Expectation**:  A GET / OPTIONS request to `http://localhost:8080/public/path/to/file` should return with CORS headers.  **Actual result**: CORS headers seem to be missing.  **Possible cause**: [In the bean declaration](https://github.com/spring-projects/spring-framework/blob/8589804012efda8db2d70094e8efbd8f74d06dc5/spring-webflux/src/main/java/org/springframework/web/reactive/config/WebFluxConfigurationSupport.java#L248-L256) there seems to be no call to `setCorsConfigurations()` / `configureAbstractHandlerMapping()`, although there is in case of `RequestMappingHandler` and `RouterFunctionMapping`. FWIW, [in the MVC counterpart, this call seems to exist.](https://github.com/spring-projects/spring-framework/blob/8589804012efda8db2d70094e8efbd8f74d06dc5/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L607)  I tried adding that line using a breakpoint, after which CORS started working for me.  ---  Sorry if I'm missing something obvious -- I'm just getting started with WebFlux. 😄  For the time being I guess I'll resort to a WebFilter.","closed","type: enhancement,","EusthEnoptEron","2021-02-02T15:42:16Z","2021-02-03T12:13:42Z"
"","26492","Document the ""SpringProperties mechanism"" mentioned in the testing chapter","**Affects:** 5.3.3  The testing chapter mentions the `SpringProperties` mechanism or API in three places but doesn't explain what the mechanism is. I searched in the core chapter and couldn't find a description there. Apologies if I missed it. I presume it's `org.springframework.core.SpringProperties`. Perhaps some documentation could be added describing the mechanism or at least a link to the javadoc to help to join the dots?","closed","type: documentation,","wilkinsona","2021-02-02T09:09:02Z","2021-02-02T12:57:08Z"
"","26535","@EnableAspectJAutoProxy(proxyTargetClass = true) not working on @Async and @Scheduled bean that implements an interface","**Affects:** 5.3.3  --- I have a `@Bean` class with a public method ""void schedule()"", that is annotated with both `@Async` and `@Scheduled`; the class also implements an interface, while the ""schedule()"" method is not part of that interface.  The `@Configuration` class for this testcase is also annotated with all of the following: `@EnableAsync`, `@EnableScheduling` *and* `@EnableAspectJAutoProxy(proxyTargetClass = true)`.  Spring complains however with the following exception : `IllegalStateException: Need to invoke method 'schedule' declared on target class 'TestBean', but not found in any interface(s) of the exposed proxy type. Either pull the method up to an interface or switch to CGLIB proxies by enforcing proxy-target-class mode in your configuration.`  I can only get the testcase to succeed by adding the ""schedule()"" method to the interface even though I shouldn't have to because I've already used `@EnableAspectJAutoProxy(proxyTargetClass = true)`.  (Other not really feasible options for getting the testcase to work include not letting the bean implement the interface, or removing all methods from the interface).  Here is the full source for the testcase:  ```Java import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; import org.springframework.scheduling.annotation.Async; import org.springframework.scheduling.annotation.EnableAsync; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;  /**  * This test will fail even though there is already a @EnableAspectJAutoProxy(proxyTargetClass = true) on  * the TestConfiguration class, with the following error:  *  * ""WARN  GenericApplicationContext:596 - Exception encountered during context initialization - cancelling  * refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name  * 'testBean' defined in SchedulingTest$TestConfiguration: Initialization of bean failed; nested exception  * is java.lang.IllegalStateException: Need to invoke method 'schedule' declared on target class 'TestBean',  * but not found in any interface(s) of the exposed proxy type. Either pull the method up to an interface  * or switch to CGLIB proxies by enforcing proxy-target-class mode in your configuration.""  *  * Commenting either *one* of the lines marked with (1), (2), or (3) will make the test succeed.  */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SchedulingTest.TestConfiguration.class) public class SchedulingTest {      @Configuration     @EnableAsync     @EnableScheduling     @EnableAspectJAutoProxy(proxyTargetClass = true)     static class TestConfiguration {         @Bean         public TestBean testBean() {             return new TestBean();         }         @Bean         public ThreadPoolTaskExecutor threadPoolTaskExecutor() {             return new ThreadPoolTaskExecutor();         }     }      interface TestInterface {     //  void schedule();                // (1) uncommenting this method will make the test succeed         void execute();                 // (2) commenting this method will make the test succeed     }      static class TestBean             implements TestInterface    // (3) commenting this implements clause will make the test succeed     {         @Async         @Scheduled(cron = ""*/5 * * * * *"")         public void schedule() {             System.out.println(""In schedule method"");         }          public void execute() {         }     }      @Test     public void testIt() throws InterruptedException {         Thread.sleep(6000);     } } ```","open","in: core,","florimon","2021-02-10T14:27:58Z","2021-11-10T12:02:13Z"
"","26400","MockPart is not added to parameter list anymore for Content-Type application/json","**Affects:** 5.3.3  --- After the update to version 5.3.3 a few of my MockMvc tests failed. After hours of debuging I found out that it is related to  #26261. In my test I do the following.      mvc.multipart(POSTS_ME) {             part(mockMultipartJson(""video_attributes"", payload))             file(mockMultipartFile(""video"", ""sample_video.mp4"", ""video/mp4"", video))     }      protected fun mockMultipartFile(name: String, file: String, type: String, resource: Resource) =         MockMultipartFile(name, file, type, resource.inputStream)      protected fun mockMultipartJson(partName: String, payload: Map) =         MockPart(partName, JSONObject(payload).toString().encodeToByteArray()).apply {             headers.contentType = MediaType.APPLICATION_JSON     }  Using Postman everything works as expected. I found out my Part file is not getting set as request parameter inside the MockHttpRequest. My Controller has the following methods:      @PostMapping(consumes = [MediaType.MULTIPART_FORM_DATA_VALUE], params = [""image_attributes""])     fun createImagePost(         @RequestPart(""image"") image: MultipartFile,         @Valid @RequestPart(""image_attributes"") attributes: CreatePostWithContentCommand,         request: HttpServletRequest     ): ResponseEntity      @PostMapping(consumes = [MediaType.MULTIPART_FORM_DATA_VALUE], params = [""video_attributes""])     fun createVideoPost(         @RequestPart(""video"") video: MultipartFile,         @Valid @RequestPart(""video_attributes"") attributes: CreatePostWithContentCommand,         request: HttpServletRequest     ): ResponseEntity  My Controller decides based on the Request-Paramter which method to call. The methods do various different things with the underlying image / video file. In the MockMultipartHttpServletRequestBuilder class of version 5.3.3 is now an additional check if the Content-Type of my Part file (video_attributes) is compatible to 'text/html', which it is not. Because of that method `toParameterValue()` my Parts name is not added to the parameter collection anymore. As I said, with Postman everything works.   Can you please elaborate on that for me? Is there a way to make the test work again? I would rather not change my endpoint just to get the test working, especially by dividing the  endpoint or using an additional query parameter this makes my API less efficient.  Thanks in advance, looking forward to your response.","closed","type: regression,","cmdjulian","2021-01-18T22:31:08Z","2021-01-20T17:43:44Z"
"","26469","Improve Javadoc of ServerHttpRequest.getPath() to mention query is not included","**Affects:** 5.3.3  ---  The Javadoc for ServerHttpRequest.getPath() reads: > Returns a structured representation of the request path including the context path + path within application portions, path segments with encoded and decoded values, **and path parameters**.  However, getPath().toString() actually results in the path only up to (but excluding) the first ""?"". Any query parameters that were part of the original URI are not included, contrary to what the Javadoc claims.  For example, this Kotlin/JUnit5 test ```java     @Test     fun getPathShouldContainParams() {         val exchange = MockServerWebExchange.from(MockServerHttpRequest.get(""http://test.com/items?id=5""))         assertThat(exchange.request.path).isEqualTo(""/items?id=5"")     } ``` fails with this message: ``` org.opentest4j.AssertionFailedError: expected:<[""/items?id=5""]> but was:<[/items]> Expected :/items?id=5 Actual   :/items ``` When debugging into the test, I could see that the returned RequestPath object doesn't contain any info about the parameters.  I first noticed this in production, i.e. this als happens with real requests, not just with mocked ones.  Expected behavior: ServerHttpRequest.getPath() returns an object that knows about the parameters, and returns them as part of its toString().","closed","type: task,","fblampe","2021-01-28T16:02:47Z","2021-02-10T16:27:20Z"
"","26314","CVE-2020-28052 on bouncy castle library","**Affects:** 5.3.2,  Spring framework has the bouncy castle as a dependency library whose issue is registered as a [CVE](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28052) The vulnerability has already patched on version 1.6.7 whereas Spring remains in 1.6.6 and I couldn't find any issue or PR mentioning it so I raise an issue here.","closed","status: invalid,","deepkimchi","2020-12-23T06:12:38Z","2020-12-23T07:38:18Z"
"","26332","The implementaion of isOpen() in ReactorNettyWebSocketSession is wrong","**Affects:** 5.3.2  The implementation of `isOpen()` in `org.springframework.web.reactive.socket.adapter.ReactorNettyWebSocketSession` is wrong.  ## Implementation ##  ```java 	@Override 	public boolean isOpen() { 		DisposedCallback callback = new DisposedCallback(); 		getDelegate().getInbound().withConnection(callback); 		return callback.isDisposed(); // Wrong 	} ```  It should be:  ```java 	@Override 	public boolean isOpen() { 		DisposedCallback callback = new DisposedCallback(); 		getDelegate().getInbound().withConnection(callback); 		return !callback.isDisposed(); 	} ```","closed","status: superseded,","JamesChenX","2021-01-01T14:35:47Z","2021-01-04T10:18:58Z"
"","26312","Fix JdbcOperations.queryForObject/queryForList extensions","**Affects:** 5.3.2  JdbcOperationsExtensions passes kotlin Array to Java varargs, so Array of array is passed to database, and fails.  ``` inline fun  JdbcOperations.queryForObject(sql: String, args: Array): T? = 		queryForObject(sql, T::class.java, args) as T ```   should be  ``` inline fun  JdbcOperations.queryForObject(sql: String, args: Array): T? = 		queryForObject(sql, T::class.java, *args) as T ```   And, `JdbcOperations.queryForList(sql: String, args: Array): List` has the same problem.","closed","type: bug,","m15o","2020-12-23T01:06:19Z","2021-01-04T14:00:08Z"
"","26321","Spring using kotlin serialization over jackson for its own classes","**Affects:** 5.3.2  In my project I am using kotlin serialization internally for kotlin data classes but expected spring/spring-boot to use jackson as HTTP message converter which was fine until i tried to upgrade from spring boot 2.4.0 to 2.4.1.  After the upgrade, my unit tests failed with the following exception; ``` 2020-12-28 09:15:12.624 ERROR 4263 --- [           main] o.s.s.o.provider.endpoint.TokenEndpoint  : Handling error: HttpMessageNotWritableException, Could not write JSON: Class 'DefaultOAuth2AccessToken' is not registered for polymorphic serialization in the scope of 'OAuth2AccessToken'. Mark the base class as 'sealed' or register the serializer explicitly.; nested exception is kotlinx.serialization.SerializationException: Class 'DefaultOAuth2AccessToken' is not registered for polymorphic serialization in the scope of 'OAuth2AccessToken'. Mark the base class as 'sealed' or register the serializer explicitly.  org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Class 'DefaultOAuth2AccessToken' is not registered for polymorphic serialization in the scope of 'OAuth2AccessToken'. Mark the base class as 'sealed' or register the serializer explicitly.; nested exception is kotlinx.serialization.SerializationException: Class 'DefaultOAuth2AccessToken' is not registered for polymorphic serialization in the scope of 'OAuth2AccessToken'. Mark the base class as 'sealed' or register the serializer explicitly. 	at org.springframework.http.converter.json.KotlinSerializationJsonHttpMessageConverter.encode(KotlinSerializationJsonHttpMessageConverter.java:161) 	at org.springframework.http.converter.json.KotlinSerializationJsonHttpMessageConverter.writeInternal(KotlinSerializationJsonHttpMessageConverter.java:145) 	at org.springframework.http.converter.AbstractGenericHttpMessageConverter.write(AbstractGenericHttpMessageConverter.java:104) ```  Looking further and debugging i found the following change: https://github.com/spring-projects/spring-framework/commit/43faa439ab567c382e50ae670560024cebdf63d2  To be more precise the order of message converters changed between 5.3.1 and 5.3.2: * In 5.3.1 jackson is registered before kotlin serialization -> https://github.com/spring-projects/spring-framework/blob/v5.3.1/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L921 * In 5.3.2 jackson is registered after kotlin serialization -> https://github.com/spring-projects/spring-framework/blob/v5.3.2/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L909  I tried to find a way to change the order in a simple way or disable kotlin serialization for spring without success. I would like to avoid registering the message converters manually if possible.  Is there a way to workaroud the issue? Is it intentional that kotlin serialization will be used for classes that are not marked as `@Serializable` and further then that classes that are internal to spring?","closed","type: regression,","tomfi","2020-12-28T07:21:07Z","2021-01-04T10:31:51Z"
"","26278","Changed behaviour in Nested tests and catched exception","**Affects:** 5.3.2  After upgrading from spring boot 2.3.x to 2.4.1, some nested tests are failing with an exception that was catched.   Code example:  ```java // Service:   public void createTodo(Todo todo) {     try {       todoRepository.save(todo);     } catch (DataIntegrityViolationException e) {       log.warn(""Could not store todo "", e);       logRepository.save(new Log(e.getMessage()));     }   }  // Test:   @Nested   class CreateTodo {      @Test     void checkThatErrorIsPersistedOnException() {       service.createTodo(new Todo(""way too long message > 10 characters""));       // before spring boot 2.4.x this runs successful       // after spring boot 2.4.x this throws the already catched exception       assertThat(todoRepository.findAll()).isEmpty();       assertThat(logRepository.findAll()).hasSize(1);     }   }   ```   Test case: to execute https://github.com/knoobie/spring-nested-test   Changing the spring boot version to e.g. 2.3.5.RELEASE fixes the test.","closed","","knoobie","2020-12-15T13:59:31Z","2022-02-18T19:05:34Z"
"","26317","@ExceptionHandler methods not invokable if matched on exception's cause level > 1","**Affects:** 5.3.2  --- It looks like PR #23380 introduced a major regression in the way exceptions are handled by @ControllerAdvice components.  Before that PR was merged, Spring resolved @ExceptionHandler methods only on the main exception or its 1st level cause. `ExceptionHandlerExceptionResolver` was aligned with that, and after resolution it would invoke the resolved method by using the exception and its cause as 'candidate' arguments for the target method:  ```Java protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, 	HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) {      ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);     if (exceptionHandlerMethod == null) { 	return null;     }      if (this.argumentResolvers != null) { 	exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);     }     if (this.returnValueHandlers != null) { 	exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);     }      ServletWebRequest webRequest = new ServletWebRequest(request, response);     ModelAndViewContainer mavContainer = new ModelAndViewContainer();      try { 	if (logger.isDebugEnabled()) { 		logger.debug(""Using @ExceptionHandler "" + exceptionHandlerMethod); 	} 	Throwable cause = exception.getCause(); 	if (cause != null) { 		// Expose cause as provided argument as well 		exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod); 	} 	else { 		// Otherwise, just the given exception as-is 		exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod); 	}     }     catch (Throwable invocationEx) { 	// Any other than the original exception (or its cause) is unintended here, 	// probably an accident (e.g. failed assertion or the like). 	if (invocationEx != exception && invocationEx != exception.getCause() && logger.isWarnEnabled()) { 		logger.warn(""Failure in @ExceptionHandler "" + exceptionHandlerMethod, invocationEx); 	} 	// Continue with default processing of the original exception... 	return null; } ```  But PR #23380 didn't come with any change in the way arguments of the target method are resolved... and that's the problem. Whenever the `@ExceptionHandler` method is resolved due to a match on a cause above the 1st level, and if a throwable of this type is used as an argument of the method, ExceptionHandlerExceptionResolver has no way to resolve this argument as it still only tries the main exception and its 1st cause.  So if we do this in a controller...  ```Java @GetMapping(""/greeting"") public Greeting greeting(@RequestParam(value = ""name"", defaultValue = ""World"") String name) {  	if (""err3"".equals(name)) { 		throw new RuntimeException( 			new Exception( 				new IllegalArgumentException(""ExceptionHandler will be resolved but cannot be invoked""))); 	} 	... } ``` ... and have this kind of `@ControllerAdvice` :  ```Java @ControllerAdvice public class MyControllerAdvice {  	@ExceptionHandler(IllegalArgumentException.class) 	public ResponseEntity handleIllegalArgumentException(IllegalArgumentException ex) { 		return ResponseEntity.badRequest().body(ex.toString()); 	} } ```  ... then the `handleIllegalArgumentException` is resolved but actually not invokable when exception thrown is like in the code above, and we get this in the log:  ```text 2020-12-22 19:52:45.387  WARN 29244 --- [           main] .m.m.a.ExceptionHandlerExceptionResolver : Failure in @ExceptionHandler com.example.restservice.MyControllerAdvice#handleIllegalArgumentException(IllegalArgumentException)  java.lang.IllegalStateException: Could not resolve parameter [0] in public org.springframework.http.ResponseEntity com.example.restservice.MyControllerAdvice.handleIllegalArgumentException(java.lang.IllegalArgumentException): No suitable resolver 	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) ~[spring-web-5.3.2.jar:5.3.2] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) ~[spring-web-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:420) ~[spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:75) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:141) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:80) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1321) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.test.web.servlet.TestDispatcherServlet.processHandlerException(TestDispatcherServlet.java:149) [spring-test-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1132) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1078) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.2.jar:5.3.2] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.3.2.jar:5.3.2]  ```  So if the changes made by PR #23380 are to be kept, i.e. @ExceptionHandler methods have to be able to handle any cause in the causality chain of an exception, a change of design is necessary in arguments resolution.  Regards","closed","type: bug,","rod2j","2020-12-24T00:52:03Z","2021-01-11T10:37:27Z"
"","26349","ClassCastException handling at SimpleApplicationEventMulticaster of payload items","**Affects:** 5.3.2  --- I am trying to programatically register `ApplicationListener` via lambda and `ApplicationListener.forPayload` like this: ``` class EventBusListenersRegistration(   private val applicationContext: ConfigurableApplicationContext,   private val eventListenersProvider: ObjectProvider> ): ApplicationRunner {   override fun run(args: ApplicationArguments?) {     eventListenersProvider.forEach{ eventListener ->       applicationContext.addApplicationListener(ApplicationListener.forPayload { eventListener.on(it) }) }   } } ``` and I am getting ClassCastException since this does not match. ReadinessState is payload of AvailabilityChangeEvent. I guess there is something wrong how payload is handled ![image](https://user-images.githubusercontent.com/8619173/103678761-3c3f7080-4f84-11eb-86b7-41fe41176786.png)","closed","status: feedback-provided,","bukajsytlos","2021-01-05T17:33:07Z","2021-01-11T08:46:08Z"
"","26150","Generic return type in controller not serialized correctly to JSON","**Affects:** 5.3.1 (Spring boot 2.4.0)  --- Let's say I have abstract `Shape` class with `Square` and `Circle` subclasses annotated as Jackson ""polymorphic"" type (see complete example bellow). When serializing those classes to JSON Jackson adds ""discriminant"" property `kind` so it is possible to determine which subclass was serialized.  When I have REST controller with GET method returning `Shape` class serialization works correctly and Jackson adds `kind` property. Also when returning `List` serialized JSON is correct. But when returning custom generic wrapper class `Result` containing some `Shape` then JSON doesn't contain `kind` property.  Here is complete Java example code: ``` java import com.fasterxml.jackson.annotation.JsonSubTypes; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.annotation.JsonTypeName; import java.util.List; import java.util.Optional; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  @SpringBootApplication public class SpringTestApplication {      public static void main(String[] args) {         SpringApplication.run(SpringTestApplication.class, args);     }      @RestController     public static class TestController {          // works correctly         @RequestMapping(""/test"")         public Shape test() {             return new Circle();         }          // works correctly         @RequestMapping(""/testList"")         public List testList() {             return List.of(new Circle());         }          // here is the issue         @RequestMapping(""/testResult"")         public Result testResult() {             return new Result<>(new Circle());         }          // also Optional doesn't work correctly         @RequestMapping(""/testOptional"")         public Optional testOptional() {             return Optional.of(new Circle());         }      }          public static class Result {         public T result;          public Result(T result) {             this.result = result;         }     }      @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = ""kind"")     @JsonSubTypes({         @JsonSubTypes.Type(Square.class),         @JsonSubTypes.Type(Circle.class),     })     public abstract static class Shape {     }      @JsonTypeName(""square"")     public static class Square extends Shape {         public double size;     }      @JsonTypeName(""circle"")     public static class Circle extends Shape {         public double radius;     }  } ```  Running this code demonstrated that returning `Result` produces inconsistent result as summarized in following table:  | URL | result | expected |---|---|---| | http://localhost:8080/test | `{""kind"":""circle"",""radius"":0.0}` | ✔️ | | http://localhost:8080/testList | `[{""kind"":""circle"",""radius"":0.0}]` | ✔️ | | http://localhost:8080/testResult | `{""result"":{""radius"":0.0}}` | ❌ `{""result"":{""kind"":""circle"",""radius"":0.0}}` | | http://localhost:8080/testOptional| `{""radius"":0.0}` | ❌ `{""kind"":""circle"",""radius"":0.0}` |  Note: wrapping return type in `ResponseEntity` doesn't have any effect.","open","in: web,","vojtechhabarta","2020-11-24T22:48:17Z","2021-11-08T11:46:09Z"
"","26219","Generalize validation error handling","**Affects:** 5.3.1 Relates to #23107  Basically, I have the exact same feeling as the author did but he never clarified his point.   You can validate a DTO using `@Valid` annotation (whether it is built from a bunch of query parameters or from the body) but you can't validate literals like that. So, to validate a request parameter or a path parameter, one has to apply `@Validated` annotation on the controller class level to enable the AOP proxy for method validation, then it will pick up any JSR 380 annotations.  So, here is a little example. Given the following definition:  ```java class UserDto { @Email String email; }  @RestController @RequestMapping(""users"") @Validated class UserController {      @PostMapping   void createUser(@Valid @RequestBody UserDto userDto) {...}      @GetMapping(""{email}"")   UserDto getUser(@Email @PathVariable String email) {...} ```  If we send the following requests, we will get these results: ``` ---------> POST users {   ""email"": ""invalid-email"" }  <--------- throws MethodArgumentNotValidException  ---------> GET users/invalid-email <--------- throws ConstraintViolationException ```  Now, handling these 2 is not very nice although we want the same result in the end: ```java  class ValidationErrorResponse { List violations; } class Violation { String fieldName, message; }    @ExceptionHandler   ResponseEntity onConstraintValidationException(ConstraintViolationException e) {     ValidationErrorResponse error = new ValidationErrorResponse();     for (ConstraintViolation violation : e.getConstraintViolations()) {       error.getViolations().add(         new Violation(violation.getPropertyPath().toString(), violation.getMessage()));     }     return ResponseEntity.badRequest().body(error);   }    @ExceptionHandler   ResponseEntity onMethodArgumentNotValidException(MethodArgumentNotValidException e) {     ValidationErrorResponse error = new ValidationErrorResponse();     for (FieldError fieldError : e.getBindingResult().getFieldErrors()) {       error.getViolations().add(         new Violation(fieldError.getField(), fieldError.getDefaultMessage()));     }     return ResponseEntity.badRequest().body(error);   } ```  So, I see 3 inconveniences: - I have to always specify @Valid annotation whenever I have a @RequestBody. Can't we just assume I want to validate all bodies? I feel like I might forget it in one place and it won't be validated. Or maybe we could add @Valid onto the DTO class itself and look there for it? Or maybe we could just scan all fields and see if any field has the @Constraint annotation on it? - I have to always specify @Validated annotation on the controller class level to inspect the literals. Why doesn't it inspect them by default since it already searches for @Valid/@Validated on the body? - Error handling is cumbersome","open","in: web,","Sam-Kruglov","2020-12-05T18:32:02Z","2022-07-26T09:58:16Z"
"","26112","NoSuchMethodError in UrlPathHelper.skipServletPathDetermination","**Affects:** 5.3.1  Launching an application that uses Spring MVC 5.3.1 on a TomCat 8.5 gives the error:  > Caused by: java.lang.NoSuchMethodError: javax.servlet.http.HttpServletRequest.getHttpServletMapping()Ljavax/servlet/http/HttpServletMapping; 	at org.springframework.web.util.UrlPathHelper.skipServletPathDetermination(UrlPathHelper.java:265) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.util.UrlPathHelper.getLookupPathForRequest(UrlPathHelper.java:250) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.util.UrlPathHelper.resolveAndCacheLookupPath(UrlPathHelper.java:199) ~[spring-web-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.initLookupPath(AbstractHandlerMapping.java:567) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.getHandlerInternal(AbstractUrlHandlerMapping.java:136) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:491) ~[spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1255) [spring-webmvc-5.3.1.jar:5.3.1] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1037) [spring-webmvc-5.3.1.jar:5.3.1] 	... 34 more  The application finds servlet-api version 4.0.1 in it's classpath (so _isServlet4Present_ is true), but the HttpServletRequest passed to the method is actually from Tomcat's servlet 3, thus lacking the method getHttpServletMapping.","closed","type: bug,","FabioMarangonSMI","2020-11-18T13:31:01Z","2020-11-19T08:44:54Z"
"","26089","Spring MVC: Suspending function returns bad response when using MockMvc","**Affects:** 5.3.1  ```kotlin @Controller class TestFetchController {      @Autowired     lateinit var repository: TestRepository      @RequestMapping(""/categoriesfetch/"", method = [RequestMethod.GET])     @ResponseBody     suspend fun categoriesGetFetched(         @RequestParam page: Int? = 0,         @RequestParam maxResults: Int? = 100     ): ResponseEntity<*> {          val response: Page = repository.findAll(             PageRequest.of(page!!, maxResults!!)         )                  val headers = Consumer {             it.add(""TotalElements"", response.totalElements.toString())             it.add(""TotalPages"", response.totalPages.toString())             it.add(""PerPage"", response.numberOfElements.toString())             it.add(""CurrentPage"", response.number.toString())         }          return ResponseEntity.ok()             .contentType(MediaType.APPLICATION_JSON)             .headers(headers)             .body(response)     } } ``` Returns the following response when using MockMvc: ``` Async:     Async started = true      Async result = <200 OK OK,[TestEntity(id=1, modificationDate=2020-11-13 10:04:07.613, modifierId=user, level=0, parentNode=null, displayName=Test0, relations=[]), TestEntity(id=2, modificationDate=2020-11-13 10:04:07.713, modifierId=user, level=0, parentNode=null, displayName=Test1, relations=[]), TestEntity(id=3, modificationDate=2020-11-13 10:04:07.719, modifierId=user, level=0, parentNode=null, displayName=Test2, relations=[]), TestEntity(id=4, modificationDate=2020-11-13 10:04:07.725, modifierId=user, level=0, parentNode=null, displayName=Test3, relations=[]), TestEntity(id=5, modificationDate=2020-11-13 10:04:07.73, modifierId=user, level=0, parentNode=null, displayName=Test4, relations=[])],[Content-Type:""application/json"", TotalElements:""30"", TotalPages:""6"", PerPage:""5"", CurrentPage:""0""]>  Resolved Exception:              Type = null  ModelAndView:         View name = null              View = null             Model = null  FlashMap:        Attributes = null  MockHttpServletResponse:            Status = 200     Error message = null           Headers = [X-Content-Type-Options:""nosniff"", X-XSS-Protection:""1; mode=block"", Cache-Control:""no-cache, no-store, max-age=0, must-revalidate"", Pragma:""no-cache"", Expires:""0"", X-Frame-Options:""DENY""]      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = [] ``` The most interesting part IMO is the  `[Content-Type:""application/json"", TotalElements:""30"", TotalPages:""6"", PerPage:""5"", CurrentPage:""0""]` and the missing body.  When removing the suspend keyword everything works as expected. The same applies when returning List directly without the ResponseEntity (without the header part of course):  ``` MockHttpServletResponse:            Status = 200     Error message = null           Headers = [X-Content-Type-Options:""nosniff"", X-XSS-Protection:""1; mode=block"", Cache-Control:""no-cache, no-store, max-age=0, must-revalidate"", Pragma:""no-cache"", Expires:""0"", X-Frame-Options:""DENY""]      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = [] ``` Please note the missing body.  The MockMVC test: ```kotlin  @Test     @WithMockUser     fun `lazy loaded relationships are fetched via fetch`() {          val maxResults = 5          mockMvc.get(""/categoriesfetch/?page=0&maxResults=$maxResults"") {             header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE)         }.andExpect {             status { isOk() }             header {                 string(PassHeaders.TOTALPAGES, ""6"")                 string(PassHeaders.TOTALELEMENTS, ""30"")                 string(PassHeaders.PERPAGE, ""5"")                 string(PassHeaders.CURRENTPAGE, ""0"")             }         }.andReturn().response.contentAsString.let { body ->             val parsedCategories: List = jacksonObjectMapper().readValue(body)         }     } ```  Please note: the request does work fine when actually running the Spring Boot app and querying the URL. The issue only applies within MockMVC tests.","closed","","jonasbark","2020-11-13T09:22:20Z","2020-11-16T09:48:10Z"
"","26154","5.3.0 and 5.3.1 versions published to Maven central missing .RELEASE suffix","**Affects:** 5.3.0 and 5.3.1  The latest 5.3.x versions published to Maven central and the Spring release repo do not have a `.RELEASE` suffix. Prior GA versions since 3.x are all named MAJOR.MINOR.PATCH.RELEASE:  https://mvnrepository.com/artifact/org.springframework/spring-core https://repo.spring.io/release/org/springframework/spring-core/  Are the 5.3.0 and 5.3.1 versions GA releases and will this be the naming going forward (without the suffix)?","closed","status: invalid,","sehrope","2020-11-25T16:47:38Z","2020-11-25T16:50:43Z"
"","26066","Can't access setAllowedOriginPatterns method","**Affects:** 5.3.0  --- I use the following code to configure CORS...  ```java import java.util.List;  import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  @Component public class WebConfig implements WebMvcConfigurer {     @Override     public void addCorsMappings(CorsRegistry registry) {         String[] allowedOrigins = ;         CorsRegistration cors = registry.addMapping(""/**"").allowCredentials(true);         cors.allowedOrigins(allowedOrigins);     } } ```  But I would like to use the `setAllowedOriginPatterns` that is on `CorsConfiguration` but `CorsRegistration` does not expose this so I can't. Why is this protected?","closed","status: invalid,","crowmagnumb","2020-11-10T19:50:00Z","2020-11-12T20:57:35Z"
"","25998","@Transactional on suspending function returning a value always rollbacks","**Affects:** 5.3.0","closed","type: bug,","lujijiang","2020-10-30T06:10:34Z","2020-11-09T16:48:33Z"
"","26601","Allow AOP proxies to be created using the original ClassLoader","**Affects:** 5.3  There's [a problem in Spring Boot's DevTools](https://github.com/spring-projects/spring-boot/issues/25367) that's caused by an AOP proxy being created using the restart class loader rather than the class loader of the proxy's target. This causes problem when calling package-private methods on the proxy.   I've hacked together [something](https://github.com/spring-projects/spring-boot/issues/25367#issuecomment-781999430) that overrides the proxy creator to use the target's class loader and it fixes the problem. I'd now like to explore how we could make the solution more robust and I think some Framework changes are required. The override of AbstractAutoProxyCreator.createProxy is only changing the behaviour of a single line:  https://github.com/spring-projects/spring-framework/blob/a9240e0bac4d71792bc22642093cbda86ed82f85/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java#L461  Rather than using `getProxyClassLoader()`, my override uses `beanClass.getClassLoader()`.  The other part of the problem is then configuring the context to use the customized `AnnotationAwareAspectJAutoProxyCreator`. I'm changing the class of its bean definition at the moment. Perhaps there's already a more elegant way to do this?","closed","type: enhancement,","wilkinsona","2021-02-24T19:20:25Z","2021-03-10T16:23:14Z"
"","25932","allow-bean-definition-overriding=true should respect @Primary","**Affects:** 5.2.9.RELEASE  When allow-bean-definition-overriding=true, the @Primary annotation for overriden bean names is not behaving as expected. If the configuration class with the overridden bean name and @Primary annotation is processed before the configuration providing the same bean name and without the @Primary annotation, that definition would be used.  In fact, in DefaultListableBeanFactory.registerBeanDefinition(String beanName, BeanDefinition beanDefinition), there is no handling to check if the exisitingDefinition.isPrimary().  The expected behaviour is that the configuration with the @Primary annotation on the overridden bean name is the one that is used for that bean type and name. I would also expect that an exception is raised if more than one @Primary ovveriding configuration is found.","closed","status: invalid,","alienisty","2020-10-19T06:52:40Z","2020-10-20T04:59:21Z"
"","25908","HttpServerOperations overrides content-length to 0 on HTTP HEAD","**Affects:** 5.2.9.RELEASE  ---  According to the specification RFC https://tools.ietf.org/html/rfc7231#section-4.3.2  ``` The server SHOULD send the same    header fields in response to a HEAD request as it would have sent if    the request had been a GET, except that the payload header fields    (Section 3.3) MAY be omitted. ```  This is the endpoint  ```java private final DataBufferFactory dataBufferFactory = new DefaultDataBufferFactory();  @GetMapping(""/headers"") public ResponseEntity> testHeadersGET() { 	return ResponseEntity 			.ok() 			.body(Flux.defer(() -> { 				byte[] bytes = ""variableLengthString"".getBytes(); 					  				return Flux.just(dataBufferFactory.wrap(bytes)); 			})); } ```  With GET request these are the request/response headers  ``` GET /headers HTTP/1.1 Host: localhost:8080 Accept: */* ```  ``` HTTP/1.1 200 OK transfer-encoding: chunked Content-Type: text/event-stream ```  With HEAD request these are the request/response headers  ``` GET /headers HTTP/1.1 Host: localhost:8080 Accept: */* ```  ``` HTTP/1.1 200 OK Content-Type: text/event-stream Content-Length: 20 ```  In the first case with GET, `transfer-encoding` is used, while in the case with HEAD it is `Content-Length: 20`. Why is that?  Also additional question why Spring Framework decides to return `Content-Type: text/event-stream` as it is not specified that this is SSE.  This is related to https://github.com/reactor/reactor-netty/issues/1333","closed","type: bug,","violetagg","2020-10-13T10:09:06Z","2020-10-29T09:37:29Z"
"","25886","Use spring.components only for JARs that define an index","**Affects:** 5.2.9 --- I am trying to use `spring-context-indexer` on my project. It creates a `META-INF/spring-components` file with a list of my own beans. So far, so good.   However, if I have additional components on my classpath, e.g., `keycloak-spring-boot-starter`, these provide beans on their own - but they are not instantiated any longer since they are missing from the generated index. I guess the application container should still perform a classpath search even if some beans could be instantiated right from the index.  On behalf of my customer project I have provided a show case of the problem with one of my pet projects: * Please  clone https://github.com/dukecon/dukecon_feedback, * Switch to branch feature/spring-context-indexer, * Call `./mvnw clean test` and check for the errors.  * The error can also be found in our Gradle Enterprise test reports at https://gradle.dukecon.org/s/kxjpnfo3bglpy/tests/org.dukecon:dukecon-feedback:surefire:test/org.dukecon.feedback.adapters.jpa.FeedbackStoreJPAPostgresTest/testToSave?anchor=e30&focused-exception-line=0-4-2-0-0#1 * Or on our Jenkins server at https://dev.dukecon.org/jenkins/job/dukecon_feedback/job/feature%252Fspring-context-indexer/2/console  Thanks to @mp911de for discussions and for encouraging me to raise this issue.","open","type: enhancement,","ascheman","2020-10-08T20:15:19Z","2020-10-09T06:34:23Z"
"","26457","Document UriComponentsBuilder.pathSegment doesn't allow segments ""without text""","**Affects:** 5.2.8.RELEASE  ---  `UriComponentsBuilder.pathSegment` doesn't allow segments ""without text"". Those segments are valid, so I think the API should allow to build them ? Or at least document the existing behavior ?  ```shell jshell> UriComponentsBuilder.newInstance().pathSegment(""a"","""",""c"").encode().build().toString() $119 ==> ""/a/c"" //should this be  ""/a//c"" ?  jshell> UriComponentsBuilder.newInstance().pathSegment(""a"","" "",""c"").encode().build().toString() $120 ==> ""/a/c"" //should this be ""/a/%20/c"" ?  jshell> UriComponentsBuilder.newInstance().pathSegment(""a"","" b"",""c"").encode().build().toString() $121 ==> ""/a/%20b/c"" //OK ```","closed","in: web,","jonenst","2021-01-27T17:45:38Z","2021-02-11T21:27:55Z"
"","25872","@ControllerAdvice order defined via @Order on a @Bean method is not applied","**Affects:** 5.2.7   A `ControllerAdviceBean` is not sorted based on the `@Bean` order.  e.g.  ```java @RestControllerAdvice public class BaseExceptionHandler {      // Methods }  @RestControllerAdvice public class CoreExceptionHandler {      // Methods }  @Configuration public class ExceptionHandlerConfiguration {       @Bean     @Order(20)     public BaseExceptionHandler baseExceptionHandler() {         return new BaseExceptionHandler();     }      @Bean     @Order(10)     public CoreExceptionHandler coreExceptionHandler() {         return new CoreExceptionHandler();     } } ```  The `@Order` on the bean definitions is ignored. When `ControlerAdviceBean#findAnnotatedBeans(applicationContext)` is returned then the list contains `BaseExceptionHandler` and then `CoreExceptionHandler` (although the order based on `@Order` should be the other way around).  When the exception handlers implement the `Ordered` interface everything is OK. Not sure if this is a bug or it works as designed like that.  I can't add `@Order` or implemented `Ordered` because we want our users to be able to override those beans and provide their own before or after our defined beans. They can also entirely replace them when using Spring Boot because we use `ConditionalOnMissingBean#name`.","closed","type: enhancement,","filiphr","2020-10-07T11:44:57Z","2020-10-12T16:07:37Z"
"","26511","StringDecoder fails to strip windows newlines across source buffers","**Affects:** 5.2.12 etc (looks like bug was introduced in https://github.com/spring-projects/spring-framework/commit/db9e0b0ccb756378093d58635922c8d17aeb0815)  ---   I'm consuming server-side events using `WebClient` and experience an issue which seems to boil down to how `StringDecoder` strips newlines (the event stream that I consume consist of mostly empty lines terminated by `\r\n`). Basically, if a `\r\n` sequence happens to get split up in two separate byte buffers, we get an `IndexOutOfBoundsException` in `StringDecoder` when it tries to strip out the newline (I understand it as it tries to strip 2 bytes from the current buffer but there are only 1 byte available).  I created a test case to demonstrate the issue (can be pasted right into `org.springframework.core.codec.StringDecoderTests`); ```java @Test void decodeNewlinesAcrossBuffers()  { 	Flux input = Flux.just( 			stringBuffer(""\r""), 			stringBuffer(""\n""), 			stringBuffer(""xyz"") 	);  	testDecode(input, String.class, step -> step 			.expectNext("""") 			.expectNext(""xyz"") 			.expectComplete() 			.verify()); } ```  When executing the above test you get the underlying exception as a suppressed exception. The relevant part of the stack trace is; ``` java.lang.IndexOutOfBoundsException: readerIndex: 0, writerIndex: -1 (expected: 0 <= readerIndex <= writerIndex <= capacity(1)) 		at io.netty.buffer.AbstractByteBuf.checkIndexBounds(AbstractByteBuf.java:112) 		at io.netty.buffer.AbstractByteBuf.writerIndex(AbstractByteBuf.java:135) 		at io.netty.buffer.WrappedByteBuf.writerIndex(WrappedByteBuf.java:132) 		at org.springframework.core.io.buffer.NettyDataBuffer.writePosition(NettyDataBuffer.java:126) 		at org.springframework.core.io.buffer.NettyDataBuffer.writePosition(NettyDataBuffer.java:43) 		at org.springframework.core.codec.StringDecoder.processDataBuffer(StringDecoder.java:161) 		at org.springframework.core.codec.StringDecoder.lambda$decode$0(StringDecoder.java:121) 		at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drainSync(FluxFlattenIterable.java:552) ```","closed","in: core,","tommyk-gears","2021-02-05T08:59:37Z","2021-02-09T13:40:35Z"
"","26155","ConcurrentModificationException in NativeMessageHeaderAccessor#copyHeaders","**Affects:** 5.2.10.RELEASE, 5.2.11.RELEASE  When switching from `spring-messaging` version 5.2.9.RELEASE or lower to 5.2.10.RELEASE or newer we encounter a ConcurrentModificationException in `org.springframework.messaging.support.NativeMessageHeaderAccessor#copyHeaders` as soon as a client tries to connect via websocket.  The log entry is `o.s.w.s.m.StompSubProtocolHandler        : Failed to send message to MessageChannel in session 7475384d-daf2-24fe-ada2-6a679e5af772:Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]; nested exception is java.util.ConcurrentModificationException`  The stacktrace of the ConcurrentModificationException looks like this: ``` java.util.ConcurrentModificationException: null 	at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1493) ~[na:na] 	at java.base/java.util.HashMap$EntryIterator.next(HashMap.java:1526) ~[na:na] 	at java.base/java.util.HashMap$EntryIterator.next(HashMap.java:1524) ~[na:na] 	at java.base/java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1.next(Collections.java:1662) ~[na:na] 	at java.base/java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1.next(Collections.java:1655) ~[na:na] 	at java.base/java.util.Map.forEach(Map.java:651) ~[na:na] 	at org.springframework.messaging.support.MessageHeaderAccessor.copyHeaders(MessageHeaderAccessor.java:382) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.messaging.support.NativeMessageHeaderAccessor.copyHeaders(NativeMessageHeaderAccessor.java:135) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.outputMessage(TracingChannelInterceptor.java:224) ~[spring-cloud-sleuth-core-2.2.6.RELEASE.jar:2.2.6.RELEASE] 	at org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.preSend(TracingChannelInterceptor.java:191) ~[spring-cloud-sleuth-core-2.2.6.RELEASE.jar:2.2.6.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel$ChannelInterceptorChain.applyPreSend(AbstractMessageChannel.java:181) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:135) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	... 28 common frames omitted ```  The exception seems to be related to the headers inserted by `spring-cloud-sleuth`, but it is working without an exception if we use `spring-messaging` version 5.2.9.RELEASE or lower.  We have several Spring Boot WebMVC Applications running behind a Spring Cloud Gateway and the exception occurs in all of them as soon as we switch to `spring-messaging` 5.2.10.RELEASE or newer.  I believe that the problem could be caused by the following commits:  - https://github.com/spring-projects/spring-framework/commit/7ad60d385bf4af507fba530a6e77e4fc4e3fded6#diff-9c9bd4734096797978f2493f3c2ddef3493fe35083db245f77489593613c55a2 - https://github.com/spring-projects/spring-framework/commit/86f2ebec1b1f5438ba4d9908c71c710ef2f14219#diff-9c9bd4734096797978f2493f3c2ddef3493fe35083db245f77489593613c55a2  The full stacktrace for reference: ``` org.springframework.messaging.MessageDeliveryException: Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]; nested exception is java.util.ConcurrentModificationException 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:149) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:125) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageFromClient(StompSubProtocolHandler.java:306) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:335) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.handler.WebSocketHandlerDecorator.handleMessage(WebSocketHandlerDecorator.java:75) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.handler.LoggingWebSocketHandlerDecorator.handleMessage(LoggingWebSocketHandlerDecorator.java:56) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecorator.handleMessage(ExceptionWebSocketHandlerDecorator.java:58) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.handleTextMessage(StandardWebSocketHandlerAdapter.java:114) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.access$000(StandardWebSocketHandlerAdapter.java:43) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:85) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:82) ~[spring-websocket-5.2.11.RELEASE.jar:5.2.11.RELEASE] 	at org.apache.tomcat.websocket.WsFrameBase.sendMessageText(WsFrameBase.java:402) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFrameServer.sendMessageText(WsFrameServer.java:119) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.WsFrameBase.processDataText(WsFrameBase.java:502) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.WsFrameBase.processData(WsFrameBase.java:301) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.WsFrameBase.processInputBuffer(WsFrameBase.java:133) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFrameServer.onDataAvailable(WsFrameServer.java:82) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFrameServer.doOnDataAvailable(WsFrameServer.java:171) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsFrameServer.notifyDataAvailable(WsFrameServer.java:151) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.upgradeDispatch(WsHttpUpgradeHandler.java:148) ~[tomcat-embed-websocket-9.0.39.jar:9.0.39] 	at org.apache.coyote.http11.upgrade.UpgradeProcessorInternal.dispatch(UpgradeProcessorInternal.java:54) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.39.jar:9.0.39] 	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na] Caused by: java.util.ConcurrentModificationException: null 	at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1493) ~[na:na] 	at java.base/java.util.HashMap$EntryIterator.next(HashMap.java:1526) ~[na:na] 	at java.base/java.util.HashMap$EntryIterator.next(HashMap.java:1524) ~[na:na] 	at java.base/java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1.next(Collections.java:1662) ~[na:na] 	at java.base/java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1.next(Collections.java:1655) ~[na:na] 	at java.base/java.util.Map.forEach(Map.java:651) ~[na:na] 	at org.springframework.messaging.support.MessageHeaderAccessor.copyHeaders(MessageHeaderAccessor.java:382) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.messaging.support.NativeMessageHeaderAccessor.copyHeaders(NativeMessageHeaderAccessor.java:135) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.outputMessage(TracingChannelInterceptor.java:224) ~[spring-cloud-sleuth-core-2.2.6.RELEASE.jar:2.2.6.RELEASE] 	at org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.preSend(TracingChannelInterceptor.java:191) ~[spring-cloud-sleuth-core-2.2.6.RELEASE.jar:2.2.6.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel$ChannelInterceptorChain.applyPreSend(AbstractMessageChannel.java:181) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:135) ~[spring-messaging-5.2.10.RELEASE.jar:5.2.10.RELEASE] 	... 28 common frames omitted ```","closed","type: regression,","Johannes-Rost","2020-11-25T22:15:49Z","2020-11-27T07:58:11Z"
"","26134","DateTimeFormat ISO.DATE_TIME javadoc contains misleading default note","**Affects:** 5.2.10.RELEASE  Maybe I'm missing something, but I think the JavaDoc on the @DateTimeFormat is out of date / not correct.  The DateTimeFormat.ISO#DATE_TIME JavaDoc states, that the DATE_TIME is the default used, when no iso value is specified: ``` /**  * The most common ISO DateTime Format {@code yyyy-MM-dd'T'HH:mm:ss.SSSXXX},  * e.g. ""2000-10-31T01:30:00.000-05:00"".  * This is the default if no annotation value is specified.  */  DATE_TIME ```  However, when looking at the DateTimeFormat#iso() implementation, it's as follows: ``` /**  * The ISO pattern to use to format the field.  * The possible ISO patterns are defined in the {@link ISO} enum.  * Defaults to {@link ISO#NONE}, indicating this attribute should be ignored.  * Set this attribute when you wish to format your field in accordance with an ISO format.  */ ISO iso() default ISO.NONE; ```  So there clearly is a mismatch. Is it just an outdated JavaDoc issue?","closed","in: core,","norbertspiess","2020-11-23T12:26:12Z","2020-11-25T10:41:44Z"
"","26127","MimeType is no longer actually serializable","**Affects:** 5.2.10 and up  The **org.springframework.util.MimeType** class implements **Serializable** interface, but since the **resolvedCharset** field was introduced in 5.2.10, serialization with charset will fail since **Charset** class does _not_ implement **Serializable**.  Code to reproduce:  ``` MimeType mimeType = new MimeType(""text"", ""plain"", StandardCharsets.UTF_8); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(mimeType); ```  On OpenJDK 8 & 11 (Ubuntu), the above gives **java.io.NotSerializableException**.","closed","in: core,","holmis83","2020-11-20T16:54:17Z","2020-11-20T17:41:08Z"
"","25880","Occasional NPE when using RestTemplate.postForEntity method","**Affects:** 5.0.16.RELEASE  --- Hi, We're occasionally getting an NPE when using RestTemplate.postForEntity method.   ``` •	java.lang.NullPointerException: while trying to invoke the method org.springframework.http.converter.HttpMessageConverter.canRead(java.lang.Class, org.springframework.http.MediaType) of a null object loaded from local variable 'converter' •	       at org.springframework.web.client.RestTemplate$AcceptHeaderRequestCallback.canReadResponse(RestTemplate.java:816) •	       at org.springframework.web.client.RestTemplate$AcceptHeaderRequestCallback.lambda$doWithRequest$0(RestTemplate.java:801) •	       at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:174) •	       at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384) •	       at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) •	       at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) •	       at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) •	       at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) •	       at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) •	       at org.springframework.web.client.RestTemplate$AcceptHeaderRequestCallback.doWithRequest(RestTemplate.java:805) •	       at org.springframework.web.client.RestTemplate$HttpEntityRequestCallback.doWithRequest(RestTemplate.java:865) •	       at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:687) •	       at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:646) •	       at org.springframework.web.client.RestTemplate.postForEntity(RestTemplate.java:432)  ``` We have not been able to reproduce this issue voluntarily until now. From the looks of it, one of the message converters in the list is null. We are **NOT** manually editing the list. And we're relying on spring framework's default list of converters.  Whenever this issue happens, we need to restart the server and the issue goes away. And then randomly comes back a few days/weeks down the line.  Anyone else faced such an issue?","open","in: web,","RaghavPrakash","2020-10-08T05:36:53Z","2021-11-10T12:08:08Z"
"","26617","Property placeholder in bean class name results exception but bean is instantiated afterwards","**Affects:** 4.3.30, 5.2.13, 5.3.4  I tried all three, same result.  I have a Spring Web Application. The root context is loaded with:  ```xml 	 		org.springframework.web.context.ContextLoaderListener 	  	 		contextConfigLocation 		/WEB-INF/spring/*.xml 	 ```  and files are:  ``` /webapp/src/main/webapp/WEB-INF/spring /webapp/src/main/webapp/WEB-INF/spring/jaxrs /webapp/src/main/webapp/WEB-INF/spring/jaxws /webapp/src/main/webapp/WEB-INF/spring/config-properties.xml /webapp/src/main/webapp/WEB-INF/spring/root-context.xml /webapp/src/main/webapp/WEB-INF/spring/x2tc-proxy-components.xml ``` Note JAX-RS and JAX-WS have their subcontexts. They do not matter now here.  `config-properties.xml` is merely:  ```xml 	 		 			 				classpath:x2tc-proxy.properties 				classpath:x2tc-proxy-override.properties 				file:${catalina.base}/conf/x2tc-proxy/tc-system.properties 				file:${catalina.base}/conf/x2tc-proxy/credentials.properties 			 		 		 	 ```  `x2tc-proxy.properties` contains:  ``` ... teamcenter.auth.credentialsFactory.plain=....PlainCredentialsFactoryBean teamcenter.auth.credentialsFactory.offlineSso=....OfflineSsoCredentialsFactoryBean teamcenter.auth.credentialsFactory.onlineSso=...OnlineSsoCredentialsFactoryBean ```  All of these factory beans have everything autowired and return an object of interface type `Credentials`. Now `credentials.properties` contains specific config for a factory type, depending on a deployment. The properties file contains:  ``` teamcenter.auth.credentialsFactory=onlineSso # followed by all properties the `OnlineSsoCredentialsFactoryBean` requires.  ``` `x2tc-proxy-components.xml` contains:  ```xml 	 ```  I'd like to configure the concrete factory bean class name in the properties file w/o fiddling the beans definition. At startup I see the following:  ``` 22:30:53.037 [localhost-startStop-1] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Ignoring bean class loading failure for bean 'credentialsFactory' org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [${teamcenter.auth.credentialsFactory.${teamcenter.auth.credentialsFactory}}] for bean with name 'credentialsFactory' defined in ServletContext resource [/WEB-INF/spring/x2tc-proxy-components.xml]; nested exception is java.lang.ClassNotFoundException: ${teamcenter.auth.credentialsFactory.${teamcenter.auth.credentialsFactory}} 	at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1397) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:638) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:607) 	at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1496) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:425) ```  but as it seems the factory bean is still wired and the objects from the factory are perfectly.  It is not clear whether this is intentional or bug. StackOverflow contains a bunch of questions where people try to provide a class name from a property.","closed","in: core,","michael-o","2021-02-26T21:34:50Z","2021-02-28T19:13:05Z"
"","26470","DefaultHandlerExceptionResolver handling of media type exception on Tomcat 7+","**Affects:** 3.0.0-latest  To start out with this is referring specifically to this little piece of code found in DefaultHandlerExceptionResolver: https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.java#L278-L287  So given this as contextual information, we can observe the test that backs this code found here: https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolverTests.java#L79-L88  The behavior should be as defined in the test which I do agree completely with. However, at least when running a Tomcat embedded served Spring application this particular piece of code fails to satisfy the behavior as defined by the test. The reason behind this is that the `response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE)` commits the response, so when the `response.setHeader(String, String)` method is called just a few statements later the header containing the accepted MediaTypes is thrown away.   You can see in the Tomcat code over the last few versions that this behavior has been in place since 7.x and still exists within 10.x Tomcat 7: https://github.com/apache/tomcat/blob/7.0.108/java/org/apache/catalina/connector/ResponseFacade.java#L527-L536 Tomcat 8: https://github.com/apache/tomcat/blob/8.5.62/java/org/apache/catalina/connector/ResponseFacade.java#L467-L480 Tomcat 9: https://github.com/apache/tomcat/blob/9.0.42/java/org/apache/catalina/connector/ResponseFacade.java#L466-L479 Tomcat 10: https://github.com/apache/tomcat/blob/10.0.1/java/org/apache/catalina/connector/ResponseFacade.java#L466-L479  I believe the resolution here is that in the DefaultHandlerExceptionResolver the `sendError` method call should be moved down to just before the return as is the case in the similarly constructed `handleHttpRequestMethodNotSupported` (https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.java#L254-L263).","closed","type: bug,","shanman190","2021-01-28T16:45:37Z","2021-01-29T20:42:02Z"
"","26638","@EventListener annotated bean cannot be removed from the ApplicationEventMulticaster","**Affects:** 2.4.3  According to the JavaDoc of the `ApplicationEventMulticaster` I was expecting to be able to remove and/or add ApplicationListeners at runtime.   This currently does not work for `@EventListener` annotated methods, which apparently lead to a `ApplicationListenerMethodAdapter` instance at runtime.  Would be great, if we could remove this listener as well, either by   1. making the Adapter instance injectable and then remove it with `multicaster.removeApplicationListener()`, or 2. giving the Adapter instance a well defined bean name and remove it with `multicaster.removeApplicationListenerBean()`  I've included a small demo app with a failing test to illustrate what I'm trying to achieve:  [event-sample.zip](https://github.com/spring-projects/spring-framework/files/6081917/event-sample.zip)","closed","type: enhancement,","birnbuazn","2021-03-04T08:22:10Z","2021-03-09T11:15:32Z"
"","26117","Spring Boot 2.4 upgrade breaks injection of Principal","**Affects:** 2.4.0  Our code: ```   fun me(@ApiIgnore principal: Principal): UserDetail { ``` used to inject the `principal` in Spring Boot versions prior to 2.4.0.  Under 2.4.0 the argument is then `null` and our application breaks.  If the `@ApiIgnore` annotation is removed then the `principal` is then injected, however we don't want the `principal` to be exposed in our API documentation since it is an internal parameter.  It appears that the bug was introduced in https://github.com/spring-projects/spring-framework/pull/25780.  That PR doesn't check to see if there is a `AuthenticationPrincipal` annotation on the field, merely that the parameter has any annotations at all so even `Nonnull` will break the injection.  We've tried adding the `AuthenticationPrincipal` annotation on the field, however that doesn't work since the parameter resolver tries to inject `authentication.getPrincipal` which in our case is a `String` since we're using spring security oauth2.  We want the `Principal` injected instead.","closed","type: bug,","petergphillips","2020-11-19T11:37:15Z","2021-04-21T16:31:16Z"
"","25996","""No converter ..."" for wildcard ResponseEntity with StreamingResponseBody as body","**Affects:** 2.2.4  That controller works perfectly: ```java @GetMapping(""/test"") public ResponseEntity test() {     var response = ResponseEntity.ok().contentType(MediaType.APPLICATION_OCTET_STREAM)             .header(HttpHeaders.CONTENT_DISPOSITION, ""attachment;filename=\""test.txt\"""")             .body(os -> os.write(""simple streaming test"".getBytes(StandardCharsets.UTF_8)));     return response; } ``` But that controller ```java @GetMapping(""/test"") public ResponseEntity test() {     var response = ResponseEntity.ok().contentType(MediaType.APPLICATION_OCTET_STREAM)             .header(HttpHeaders.CONTENT_DISPOSITION, ""attachment;filename=\""test.txt\"""")             .body((StreamingResponseBody)os -> os.write(""simple streaming test"".getBytes(StandardCharsets.UTF_8)));     return response; } ``` produces an exception in response: ```json {     ""timestamp"": ""2020-10-29T17:46:55.769+0000"",     ""status"": 500,     ""error"": ""Internal Server Error"",     ""message"": ""No converter for [class local.pryadko.streamtest.TestControlle$$Lambda$1667/0x0000000840c3c040] with preset Content-Type 'application/octet-stream'"",     ""path"": ""/api/test"" } ``` Looks like Spring can't correctly find out **type** :neutral_face:","closed","status: invalid,","MikePryadko","2020-10-29T18:07:50Z","2021-04-29T10:59:42Z"
"","26062","AbstractNestablePropertyAccessor.processLocalProperty does not support generic type","**Affects:** 2.2.3.RELEASE  I was using Spring boot to build a microservice. I request a **GET** method through `url:port/v2/api/user?limit=1&condition.name=AAA`, but my input DTO cannot parse `condition.name` correctly. When the condition in the DTO is a **generic type**, the class of `condition` in PropertyHandler which the code run in AbstractNestablePropertyAccessor.processLocalProperty seems to be `Object`, and the above error occurs. And I try to change `condition` to a **specified java type**, the framework could successfully parse `condition.name`. Could you guys help to check this situation and provide a usable processing method?","open","in: core,","chaosmin","2020-11-10T13:20:22Z","2021-11-11T09:32:03Z"
"","26505","Inconsistency between source code and reference manual for StoredProcedure","**Affects:** 2.0.0 - 5.3.3  --- The first paragraph of the `StoredProcedure`'s documentation mentions that the `execute` methods of this class are protected (which is the desired behavior), but in the source code they are public.  https://docs.spring.io/spring-framework/docs/2.0.0/reference/jdbc.html#jdbc-StoredProcedure https://docs.spring.io/spring-framework/docs/2.5.x/reference/jdbc.html#jdbc-StoredProcedure https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/htmlsingle/#jdbc-StoredProcedure https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/htmlsingle/#jdbc-StoredProcedure https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/data-access.html#spring-data-tier  3.0.0.RELEASE - StoredProcedure.java: https://github.com/spring-projects/spring-framework/blob/30604ae861d378669a9719918f3068dadcc5aed5/org.springframework.jdbc/src/main/java/org/springframework/jdbc/object/StoredProcedure.java#L114 5.3.3 - StoredProcedure.java: https://github.com/spring-projects/spring-framework/blob/91509805b759a108d7eca0b6b3041c434c61d837/spring-jdbc/src/main/java/org/springframework/jdbc/object/StoredProcedure.java#L110","closed","type: task,","tyutyutyu","2021-02-04T07:48:22Z","2021-02-04T10:13:04Z"
"","26748","Invalid IPv6 Address with X-Forwarded-For leads to number format exception","**Affects:**  Spring Web 5.3.5  --- Hi Spring Team,   we run our Spring Boot Application using Spring Boot 2.4.4 which includes spring-web-5.3.5 in Google Cloud run.  Every IPv6 address that do not end with only numeric values lead to an internal server error due to a number format exception. For example, this IPv6 address ```2a02:918:175:ab60:45ee:c12c:dac1:808b``` leads to a number format exception: as ```808b``` is interpreted as the port. We know that the IPv6 address is invalid due to https://tools.ietf.org/html/rfc7239#section-6 and should be in the format of ```[2a02:918:175:ab60:45ee:c12c:dac1:808b]```. Therefore we also raised an issue at Google (https://issuetracker.google.com/issues/184230536).  Regardless, I wanted to discuss whether better error handling would be useful here:  ```java public static InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress) {  		int port = (remoteAddress != null ? 				remoteAddress.getPort() : ""https"".equals(request.getURI().getScheme()) ? 443 : 80);  		String forwardedHeader = request.getHeaders().getFirst(""Forwarded""); 		if (StringUtils.hasText(forwardedHeader)) { 			String forwardedToUse = StringUtils.tokenizeToStringArray(forwardedHeader, "","")[0]; 			Matcher matcher = FORWARDED_FOR_PATTERN.matcher(forwardedToUse); 			if (matcher.find()) { 				String value = matcher.group(1).trim(); 				String host = value; 				int portSeparatorIdx = value.lastIndexOf(':'); 				if (portSeparatorIdx > value.lastIndexOf(']')) { 					host = value.substring(0, portSeparatorIdx); 					port = Integer.parseInt(value.substring(portSeparatorIdx + 1)); 				} 				return new InetSocketAddress(host, port); 			} 		} ```  I would suggest to enforce the format described in RFC-7239 and if not, throw an exception describing the reason.  Kind Regards, Florian","closed","type: enhancement,","FlorianLautenschlager","2021-04-01T11:48:28Z","2021-07-28T08:05:16Z"
"","26630","java.lang.VerifyError when proxying ThreadPoolTaskExecutor","**Affects:**  Spring version 5.2  Hello, in a particular docker environment using Oracle JDK1.8.0_261. When I run (as the main method)  ```java         ThreadPoolTaskExecutor bean = new ThreadPoolTaskExecutor();         ProxyFactoryBean factory = new ProxyFactoryBean();         factory.setProxyTargetClass(true);         factory.setTarget(bean);          Object x = factory.getObject(); ```  I get an exception like so  ``` Caused by: java.lang.VerifyError: Stack map does not match the one at exception handler 122 Exception Details:   Location:     org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor$$EnhancerBySpringCGLIB$$c6fcfbe9.submit(Ljava/lang/Runnable;)Ljava/util/concurrent/Future; @122: astore   Reason:     Type 'java/util/concurrent/Future' (current frame, locals[2]) is not assignable to integer (stack map, locals[2])   Current Frame:     bci: @109     flags: { }     locals: { 'org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor$$EnhancerBySpringCGLIB$$c6fcfbe9', 'java/lang/Runnable', 'java/util/concurrent/Future', 'java/lang/Runnable', 'org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor$$EnhancerBySpringCGLIB$$c6fcfbe9', 'java/lang/Runnable' }     stack: { 'java/lang/Exception' }   Stackmap Frame:     bci: @122     flags: { }     locals: { 'org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor$$EnhancerBySpringCGLIB$$c6fcfbe9', 'java/lang/Runnable', integer, 'java/lang/Runnable' }     stack: { 'java/lang/Throwable' }   Bytecode:     0x0000000: 014e 033d b804 0a3a 0419 04c6 001a 2bc6     0x0000010: 0016 b204 102a b604 159a 000c 2b4e 1904     0x0000020: 2bb6 041b 4ca7 0006 b604 1e2a 3a04 2b3a     0x0000030: 0519 04b4 0034 59c7 000e 5719 04b8 0038     0x0000040: 1904 b400 3459 c600 1f19 04b2 003a 04bd     0x0000050: 003c 5903 1905 53b2 003e b900 4405 00c0     0x0000060: 0046 a700 1019 0419 05b7 0032 4d57 2ca7     0x0000070: 0003 3a04 013a 05a7 0008 3a05 013a 042d     0x0000080: c600 2519 05c0 0402 c104 209a 000e 1905     0x0000090: c004 02c1 03ea 9900 0f2d 4cb2 0410 2ab6     0x00000a0: 0423 a700 0b03 a700 07b6 041e 033d 1c99     0x00000b0: 0006 a7ff 7919 05c6 0006 1905 bf19 04b0     0x00000c0:   Exception Handler Table:     bci [4, 40] => handler: 40     bci [49, 114] => handler: 122     bci [127, 169] => handler: 169   Stackmap Table:     append_frame(@4,Integer,Object[#1028])     append_frame(@37,Object[#1047])     full_frame(@40,{Object[#2],Object[#1028],Integer,Object[#1028]},{Object[#999]})     same_frame(@43)     append_frame(@49,Object[#2],Object[#1028])     same_locals_1_stack_item_frame(@69,Object[#64])     same_locals_1_stack_item_frame(@101,Object[#64])     full_frame(@114,{Object[#2],Object[#1028],Integer,Object[#1028]},{Object[#70]})     same_locals_1_stack_item_frame(@122,Object[#999])     append_frame(@127,Object[#70],Object[#999])     same_frame(@153)     same_frame(@165)     same_locals_1_stack_item_frame(@169,Object[#999])     same_locals_1_stack_item_frame(@173,Integer)     same_frame(@181)     same_frame(@189)          at java.lang.Class.forName0(Native Method)         at java.lang.Class.forName(Class.java:348)         at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:571)         at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363)         at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:585)         at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110)         at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108)         at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)         at java.util.concurrent.FutureTask.run(FutureTask.java:266)         at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)         ... 21 more ```  The bytecode looks all wrong, I don't think the submit method of the proxy should even have an exception handler, it doesn't seem to when I capture the proxied class on my own computer.  It works fine normally (i.e. running it on my machine). It used to work on the container when using Spring 5.1  What could cause this? I am not going to be able to provide a docker image you can see this in, I don't control the image where the issue is.  I'm using Gradle to make the jar, only dependencies are  ```groovy compile(""org.springframework:spring-context:5.2.9.RELEASE"") compile(""org.springframework:spring-core:5.2.9.RELEASE"") compile(""org.springframework:spring-aop:5.2.9.RELEASE"") ```  I tried reading the class file generation code for a hint of something platform dependent, but it's complex of course...","open","status: feedback-provided,","itsyaboiyeah","2021-03-02T18:41:06Z","2021-11-10T10:03:03Z"
"","26566","MockHttpServletRequest needs servlet api 4.0 after upgrade from 5.3.3 to 5.3.4","**Affects:**  Spring Framework 5.3.4  After upgrading spring to 5.3.4 the constructor of `MockHttpServletRequest` throws java.lang.NoClassDefFoundError: javax/servlet/http/HttpServletMapping. The project uses older servlet api 3.1 because the tomcat 8.5.x is still used in production.  ```                      javax.servlet             javax.servlet-api             3.1.0             provided          ``` When the version of servlet api is changed to 4.0.0 or above, the exception is of course gone.  In [1] is mentioned that the older API should be sufficient for spring framework 5.x.  > The Java EE 7 API level is required in Spring's corresponding modules now, with runtime support for the EE 8 level  [1] https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x","closed","status: duplicate,","jirkait","2021-02-18T08:44:08Z","2021-02-19T12:47:01Z"
"","26302","Add Support for @NonBinding in javax.inject.Qualifier annotations","**Affects:**  `5.3.2`  In our project we reuse Java annotations across Framework boundaries (Spring/CDI/Micronaut). It turns our that Spring does not fully support the semantics of `javax.inject.Qualifier` annotations. Specifically, Spring Framework should support the marking of annotation fields with the `@Nonbinding` annotation. This would be especially useful when using `@Bean` methods together with `org.springframework.beans.factory.InjectionPoint`.  I have created a demo application to show the current behavior and desired behavior:  https://github.com/ghillert/spring-injectionpoint-demo  Please see especially:   https://github.com/ghillert/spring-injectionpoint-demo/blob/main/src/main/java/com/hillert/injectionpoint/config/AppConfig.java  It looks like @jhoeller aknowledged the issue in 2016:  https://gist.github.com/moelholm/4317e93f18b02e9582afefc152debb44  For reference:  **Java EE JavaDoc - Annotation Type Nonbinding** https://javaee.github.io/javaee-spec/javadocs/javax/enterprise/util/Nonbinding.html  **Advanced Using @Nonbinding to combine a configuration annotation and a qualifier annotation into one annotation** https://dzone.com/articles/cdi-di-p2","open","in: core,","ghillert","2020-12-19T21:25:43Z","2021-11-11T09:06:11Z"
"","26410","BodyInserters.fromMultipartData swallows content type in certain cases","**Affects:**  5.3.3  --- My use case is that I need to proxy some multipart form to another service:  ```java   @PostMapping(       consumes = MediaType.MULTIPART_FORM_DATA_VALUE,       produces = MediaType.APPLICATION_JSON_VALUE)   @ResponseStatus(HttpStatus.CREATED)   public Mono> upload(       @RequestBody Mono> parts) {     return someServiceClient.upload(parts);   }    public Mono> upload(       Mono> partsMono) {     return partsMono.flatMap(         parts ->             webClient                 .post()                 .uri(""/api/someservice/v2"")                 .contentType(MediaType.MULTIPART_FORM_DATA)                 .accept(MediaType.APPLICATION_JSON)                 .body(BodyInserters.fromMultipartData(parts))                 .retrieve()                 .toEntity(SomeEntityId.class)                 .publishOn(Schedulers.boundedElastic())                 .doOnError(e -> LOGGER.error(""Couldn't upload media"", e)));   } ```  Problem here is that `BodyInserters.fromMultipartData` swallows content type from `Part.headers()`.  As a workaround I convert `MultiValueMap` before passing it to `BodyInserters.fromMultipartData`:  ```java   private MultiValueMap> mapForm(       MultiValueMap parts) {     MultipartBodyBuilder builder = new MultipartBodyBuilder();     parts.forEach(         (key, valueList) -> {           for (Part value : valueList) {             builder.part(key, value, value.headers().getContentType());           }         });      return builder.build();   } ```  I'm not sure how it's actually supposed to work, but perhaps [here](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/client/MultipartBodyBuilder.java#L132), apart from `context()`, is it worth it to copy `headers()` as well?","closed","type: bug,","lazystone","2021-01-20T09:49:33Z","2021-05-25T15:26:24Z"
"","26305","Add ability to ignore certain Qualifier Annotations using CustomAutowireConfigurer","**Affects:**  5.3.2  Spring provides the [CustomAutowireConfigurer](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) that allows for registration of custom autowire qualifier types.  In certain scenarios, e.g. when using `org.springframework.beans.factory.InjectionPoint`, it might be useful to have the ability to ignore certain `@Qualifier` annotations altogether (basically the inverse behavior).  For instance, users may have the need to reuse custom 3rd party annotations that happen to be annotated with `javax.inject.Qualifier`. Right now there seems to be no easy way to simply pass them down into the `@Bean` method and handle the annotation via `InjectionPoint`. Please see also issue #26302.  Related to this, I also observed a problematic behavior around `javax.inject.Qualifier`:  A user may use a third-party annotation that is annotated with `javax.inject.Qualifier`, without having the relevant [_JSR-330_](https://github.com/javax-inject/javax-inject) dependency on the classpath. In that case Spring will NOT detect the annotation as a Qualifier and the annotation can be handled by via InjectionPoint. This is certainly expected behavior.  However, as soon as the JSR-330 dependency has been added, the application will break as all of a sudden the annotation is treated as a Qualifier. I understand that this is more of an edge-case, but I wonder if the user-experience could be improved here as the exception may not be the most intuitive. Please let me know if I shall rewrite this as a separate issue.","open","in: core,","ghillert","2020-12-21T08:43:59Z","2021-11-10T11:58:08Z"
"","26092","@Transactional causes casting error for suspending function on Spring MVC","**Affects:**  5.3.1  Minimal project: https://github.com/jonasbark/spring-framework-transactional-coroutine-bug  Running DemoApplicationTests causes the casting error below. Attaching @Transactional to the Test Controller works, however.  ``` class reactor.core.publisher.MonoOnErrorResume cannot be cast to class java.lang.String (reactor.core.publisher.MonoOnErrorResume is in unnamed module of loader 'app'; java.lang.String is in module java.base of loader 'bootstrap') java.lang.ClassCastException: class reactor.core.publisher.MonoOnErrorResume cannot be cast to class java.lang.String (reactor.core.publisher.MonoOnErrorResume is in unnamed module of loader 'app'; java.lang.String is in module java.base of loader 'bootstrap') 	at com.example.demo.DemoApplicationTests$contextLoads$test$1.invokeSuspend(DemoApplicationTests.kt:17) 	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) 	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) 	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274) 	at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:84) 	at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:59) 	at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source) 	at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:38) 	at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source) 	at com.example.demo.DemoApplicationTests.contextLoads(DemoApplicationTests.kt:16) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:133) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 	at java.base/java.lang.Thread.run(Thread.java:832) ```","closed","type: bug,","jonasbark","2020-11-13T12:31:07Z","2020-11-17T07:39:26Z"
"","26040","WebClient: encoded slashes in query string gets double-encoded","**Affects:**  5.2.11.RELEASE  I'm getting URI from third party service which contains percent encoded slashes in the query part. When  I pass this URI to WebClient's `get().uri()` method as URI class instance WebClient url-encodes the percent-signs in the query string.  Expected behaviour is that the URI will be used AS-IS and won't be manipulated as long as it is valid URI.  ```kotlin val uri = URI(""http://example.org/test?param=my%2Fexample%2Forg"")  println(uri.rawQuery) // prints param=my%2Fexample%2Forg println(uri.query) // prints param=my/example/org  webClient.get().uri(uri).retrieve().bodyToMono(Void::class.java).block() // sends GET request to http://example.org/test?param=my%252Fexample%252Forg ```","closed","","javolek","2020-11-06T08:59:19Z","2020-11-09T16:38:24Z"
"","25931","WebMvc.fn: ServerResponse.async does not handle exceptions as expected","**Affects:**  v5.3.0-RC1  Related Kotlin Slack conversation: https://kotlinlang.slack.com/archives/C0B8ZTWE4/p1602780417061400  When using functional routing and MVC the exception handling when using ServerResponse.async does not work as expected:  *Router:* ``` @Bean     fun route(         categoryHandler: TestHandler,     ): RouterFunction = router {         ""/categories"".nest {            GET(""/{categoryId}"", categoryHandler::categoriesCategoryIdGet)         }     } ``` *Implementation:* ```  fun categoriesCategoryIdGet(request: ServerRequest): ServerResponse {           return ServerResponse.async(mono(Dispatchers.Unconfined) {             throw ResponseStatusException(HttpStatus.BAD_GATEWAY)         })     } ``` I would expect the request to show HTTP Bad Gateway, but instead I'm getting HTTP 200 with an empty response: ```  curl -v 'http://localhost:8080/categories/1/' ... < HTTP/1.1 200 < X-Content-Type-Options: nosniff < X-XSS-Protection: 1; mode=block < Cache-Control: no-cache, no-store, max-age=0, must-revalidate < Pragma: no-cache < Expires: 0 < X-Frame-Options: DENY < Content-Length: 0 < Date: Mon, 19 Oct 2020 06:33:06 GMT < * Connection #0 to host localhost left intact * Closing connection 0 ``` with the following exception in the server: ``` javax.servlet.ServletException: javax.servlet.ServletException: org.springframework.web.server.ResponseStatusException: 502 BAD_GATEWAY 	at org.springframework.web.servlet.function.ErrorHandlingServerResponse.handleError(ErrorHandlingServerResponse.java:69) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at org.springframework.web.servlet.function.AsyncServerResponse.lambda$writeTo$0(AsyncServerResponse.java:116) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:760) ~[na:1.8.0_201] 	at java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:778) ~[na:1.8.0_201] 	at java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2140) ~[na:1.8.0_201] 	at org.springframework.web.servlet.function.AsyncServerResponse.writeTo(AsyncServerResponse.java:103) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at org.springframework.web.servlet.function.support.HandlerFunctionAdapter.handle(HandlerFunctionAdapter.java:77) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1061) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:961) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.0-RC2.jar:5.3.0-RC2] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) ~[tomcat-embed-core-9.0.39.jar:4.0.FR] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.39.jar:9.0.39] ```  I would expect the request to be handled by e.g. ResponseStatusExceptionHandler and the ModelAndView exception handler. I did not find documentation about the async handling.","closed","type: bug,","jonasbark","2020-10-19T06:37:16Z","2020-11-20T14:56:29Z"
"","26688","exchangeToMono return type ignored, uses responseToMono type instead","**Affects:**  5.3.0  The return type of the `exchangeToMono` callback is ignored. Even worse, Spring is apparently abusing type erasure to return a type that is not the one declared as returning, so you end up with odd runtime errors. In short, you appear to always get a String, even if it's different then the declared return type in the `exchangeToMono` callback.  In short:  Web call like so ``` class DesiredReturnType {         public final int statusCode;         public final Mono body;          private DesiredReturnType(int statusCode, Mono body) {             this.statusCode = statusCode;             this.body = body;         }     } .....     Mono ret = webClient.post()                 .uri(aUrl)                 .body(BodyInserters.fromValue(aRequestObject))                 .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)                 .exchangeToMono( resp -> callback(resp, someOtherVar) )                 .publishOn(Schedulers.fromExecutor(executorService)); ``` callback like so: ``` public Mono callback(ClientResponse resp, SomeOther someOtherVar) {       .... response code checking elided...       return Mono.just( new DesiredReturnType( resp.rawStatusCode, resp.bodyToMono(String.class) ) ); } ```  Now, there's some code somewhere that deals with your response:  ```   Mono letsDoThis = ret.block(); ```  Ok, now, any guesses on what type ret.block() returns? We declared it as the `DesiredReturnType`  in: ``` Mono ret = webClient.post()                 .uri(aUrl)... ``` And, in fact, returned that type here: ``` return Mono.just( new DesiredReturnType( resp.rawStatusCode, resp.bodyToMono(String.class) ) ); ``` And the compiler does indeed expect a `Mono` to be returned from `.publishOn(Schedulers.fromExecutor(executorService));`  SO.. `ret.block()` must return a...... String!!!! WHAT?  Yeah, that's what happens, Spring decided it was a going to return a String from the mono instead. Apparently whatever type you put in:  ~`resp.bodyToMono(String.class)` is what is actually returned.~  Actually, I appear to always get a string back.   ~In fact, whatever, `resp.bodyToMono(String.class)` is what gets returned by `ret.block()`, regardless of the actual type of `ret` (`Mono`)~  So now you get a `java.lang.ClassCastException: class java.lang.String cannot be cast to class ....DesiredReturnType`....   This is extremely counter-intuitive. You would not expect your type to be what is returned by some arbitrary method inside your callback instead of the actual, declared return type.  Also, it prevents you from enriching the data returned from `ClientResponse` downstream, which is what is the goal here, and it's super annoying that you can't do that.","closed","status: invalid,","StuAtGit","2021-03-17T00:42:10Z","2021-03-18T10:44:26Z"
"","26467","Iterable argument for NamedParameterJdbcTemplate not correctly processed","**Affects**: `spring-jdbc` `5.3.3`  ----  We have the following code:  ```java  return jdbcTemplate.query(""SELECT whatever FROM table WHERE id IN (:ids)"",                 new MapSqlParameterSource(""ids"",                         new SqlParameterValue(BIGINT, orders.stream().map(Order::getOrderId)                                                             .collect(Collectors.toSet()))),                 rs -> {                    // elided...                 }); ```  ... Spring correctly identifies the parameter value as `Iterable` and replaces the `:ids` with the correct number of question marks.  But here https://github.com/spring-projects/spring-framework/blob/d7e05aa48f449af4bf0a34623a68e117f2c8cbc9/spring-jdbc/src/main/java/org/springframework/jdbc/core/PreparedStatementCreatorFactory.java#L268  Spring does not correctly identify the value as an Iterable. This is because a few lines earlier  https://github.com/spring-projects/spring-framework/blob/d7e05aa48f449af4bf0a34623a68e117f2c8cbc9/spring-jdbc/src/main/java/org/springframework/jdbc/core/PreparedStatementCreatorFactory.java#L254-L258  ... Spring unwraps the `SqlParameterValue`, but its content is just another `SqlParameterValue` which contains the actual `Iterable`.  We can use the following code to circumvent the problem:  ```java  return jdbcTemplate.query(""SELECT whatever FROM table WHERE id IN (:ids)"",                 new MapSqlParameterSource()                     .addValue(""ids"", orders.stream().map(Order::getOrderId)                                                             .collect(Collectors.toSet())),                 rs -> {                    // elided...                 }); ```","closed","status: superseded,","Serranya","2021-01-28T14:22:19Z","2021-02-15T10:05:40Z"
"","26491","WebClients awaitBody throws Exception when expecting ""Unit""","**Affected component**: spring-webflux **Version**:  5.3.2  When using the Kotlin-Extensions for WebClient on Endpoints that do not return any data, `awaitBody` is throwing `java.util.NoSuchElementException: No value received via onNext for awaitSingle`.  I was thinking I may accidentally misuse the API, but [spring-docs](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-body) document also this call: ``` val personDeferred: Deferred = ...  client.post()         .uri(""/persons/{id}"", id)         .contentType(MediaType.APPLICATION_JSON)         .body(personDeferred)         .retrieve()         .awaitBody() ```  **Reproduction**: Given the following controller: ``` import org.springframework.http.HttpStatus import org.springframework.web.bind.annotation.*  @RestController class TestController {      @PostMapping(""/test"")     @ResponseStatus(HttpStatus.NO_CONTENT)     fun postTest() {}  } ``` And this Unit-Test: ``` @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) internal class TestControllerTest(     @LocalServerPort private val port : Int ) {      @Test     fun postTest()  = runBlocking {         WebClient.create(""localhost:$port/test"")             .post()             .retrieve()             .awaitBody()     }  } ``` The test will fail with ``` java.util.NoSuchElementException: No value received via onNext for awaitSingle  	at |b|b|b(Coroutine boundary.|b(|b) 	at TestControllerTest$deleteTest$1.invokeSuspend(TestControllerTest.kt:52) Caused by: java.util.NoSuchElementException: No value received via onNext for awaitSingle 	at kotlinx.coroutines.reactive.AwaitKt$awaitOne$$inlined$suspendCancellableCoroutine$lambda$1.onComplete(Await.kt:181) 	at reactor.core.publisher.StrictSubscriber.onComplete(StrictSubscriber.java:123) ```","closed","status: superseded,","blatobi","2021-02-02T08:35:01Z","2021-02-04T18:10:09Z"
"","26323","Add the ability for SpEL AST Indexer to interpret java.lang.Iterable object","* make object implementing java.lang.Iterable accessible with SpEL indexing * only read access is possible, as we cannot write an iterable object * make compiler compatible","closed","status: superseded,","pilak","2020-12-28T14:36:37Z","2021-02-09T13:07:02Z"
"","26143","Provide a way for an ApplicationContextInitializer to access the current test class in the TestContext framework","(Not _entirely_ sure this is a lacking feature, but I have not found it yet!)  It seems like when you're within a ApplicationContextInitializer (specified by \@ContextConfiguration), you have no way of knowing which test class is being configured. That would have been nice wrt. reading annotation parameters.  Maybe a ThreadLocal hack, whereby the thread class / instance in question was available while the ApplicationContextInitializers was run, and could be accessed via a static method?","closed","type: enhancement,","stolsvik","2020-11-23T22:20:24Z","2020-11-24T19:13:43Z"
"","26436","Fix typo in URI Encoding section of reference docs","> VALUES_ONLY: Does not encode the URI template and, instead, applies strict encoding to URI variables through UriUtils#encodeUriUriVariables prior to expanding them into the template.  I fixed `UriUtils#encodeUriUriVariables` into `UriUtils#encodeUriVariables` in  ""[1.5.3. URI Encoding](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#web-uri-encoding)"" section of reference docs.","closed","type: task,","daisuzz","2021-01-24T13:18:05Z","2021-01-24T15:49:50Z"
"","26709","check file with realPath is existing","#26707 .Tomcat's `StandardContext.getRealPath(String path)` will return non null value when the file actually not exists.So add some code in `ServletContextResource` to check file is actually exists with jdk's `File` class.","open","in: core,","drgnchan","2021-03-21T08:52:37Z","2022-02-27T08:50:56Z"
"","26399","Improve the logic of registerBeanPostProcessors() in PostProcessorRegistrationDelegate","#26398  merge the three filtering step to one for statement  the main code is below ````java                 // Separate between BeanPostProcessors that implement PriorityOrdered, 		// Ordered, and the rest. 		List priorityOrderedPostProcessors = new ArrayList<>(); 		List internalPostProcessors = new ArrayList<>(); 		List orderedPostProcessors = new ArrayList<>(); 		List nonOrderedPostProcessors = new ArrayList<>(); 		for (String ppName : postProcessorNames) { 			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 			if (pp instanceof MergedBeanDefinitionPostProcessor) { 				internalPostProcessors.add(pp); 			} 			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 				priorityOrderedPostProcessors.add(pp); 			} 			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { 				orderedPostProcessors.add(pp); 			} 			else { 				nonOrderedPostProcessors.add(pp); 			} 		} ```` with merging the filtering,  - the goal of this function is more distinct  - can save unnecessary code - save more space as no need to use `List orderedPostProcessorNames` - achieve the goal with only one for statement","closed","in: core,","Jirath-Liu","2021-01-18T13:08:28Z","2021-01-18T17:38:28Z"
"","26198","Optimize PostProcessorRegistrationDelegate's invokeBeanFactoryPostProcessors()","#26177 opt invokeBeanFactoryPostProcessors","closed","in: core,","zhuyuehui","2020-12-02T02:44:00Z","2020-12-30T14:46:14Z"
"","26220","Support hints for codec on client and server side","#26174","closed","status: superseded,","rudy2steiner","2020-12-05T18:45:34Z","2021-01-12T16:17:20Z"
"","26249","ServerHttpRequestDecorator's getBody is not invoked without @RequestBody","### Version  - spring-boot-starter-webflux: 2.3.3.RELEASE ### What happened We're using a class that extending `ServerHttpRequestDecorator` and is being used in a filter chain to do a sort of validation against body of a request. And the our custom decorator is being invoked in normal situation but if there is body of a request from a client to call a API that defined without `@RequestBody`, then the decorator is not invoked.  I guess the decorator have to be invoked if there is body of a request, even though there is no `@RequestBody` annotated.  Sorry a sort of short explanation but I will attach more if I found anything.  Thanks","closed","for: stackoverflow,","ryukato","2020-12-10T06:19:44Z","2020-12-11T04:24:34Z"
"","26056","WebClient & HTTP2, response with Content-Encoding=gzip results in decoding failure","### Set Up - Client using Spring WebClient - Reactor HttpClient protocols includes H2 (Reactor upgraded to 20.0.0) - Server supports Http2 - TLS configured successfully - Response payload is valid JSON - Response headers from server uses compression  ### Actual Behavior  When the response from the server includes the `Content-Encoding:gzip` the following error is observed. ``` java.util.concurrent.ExecutionException: org.springframework.core.codec.DecodingException: JSON decoding error: Illegal character ((CTRL-CHAR, code 31)): only regular white space (\\r, \\n, \\t) is allowed between tokens; nested exception is com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 31)): only regular white space (\\r, \\n, \\t) is allowed between tokens\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] ```  ### Dependencies - Spring Boot 2.3.5.RELEASE - Reactor 20.0.0 (Upgraded in order to use Http2)  ### Configuration Note : clientSslContextBuilder details excluded for brevity. ```java     @Bean     public ReactorNettyHttpClientMapper reactorNettyHttpClientMapper(SslContextBuilder clientSslContextBuilder) {         return httpClient -> httpClient.secure(ssl -> ssl.sslContext(clientSslContextBuilder))             .protocol(HttpProtocol.H2);     }     @Bean     public WebClientCustomizer webClientCustomizer() {         return webClientBuilder -> webClientBuilder.baseUrl(""https://localhost:8443/"");     } ``` ### Usage Note: WebClient.Builder injected from application context.  Example abbreviated for brevity.  ```java Mono dto = webClientBuilder.get().uri(""/"").exchange().flatMap(r -> r.bodyToMono(Dto.class)); ``` ### Service Details  1. Wiremock (gzip enabled) The issue was first observed when using the wiremock server.  When the wiremock compression is disabled using `--disable-gzip`, the error described above is not observed.  2. Spring Boot (embedded Tomcat) The issue was repeated using a simple Spring Boot server with the following properties set to enable compression for the response. - server.compression.enabled=true - server.compression.mime-types=application/json - server.compression.min-response-size=1B   ### Notes - If the Reactor HttpClient is configured to use Http1.1, the error does not occur.","closed","for: external-project,","maddenj-ie","2020-11-09T18:44:57Z","2020-11-11T09:28:29Z"
"","26294","Draft: WebClient incorrectly handling HTTP 100","### Overview  Adding the header `Expect: 100-continue` to WebClient causes an improper response to be returned because HTTP 100 is not handled correctly. In my case, the body of the HTTP 100 was blank and that is the value returned to my service. But, the initial response with HTTP 100 does not contain the response the client is looking for.  Below, you will see that `Received last HTTP packet` is emitted from the reactor netty code. But, the netty `HttpClient` shows the wiretap for the actual message the service was waiting for.  Found using Spring Framework 5.2.10  ### WireTap Output Reactor netty wiretap output: ``` 2020-12-09 14:29:20.678 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] FLUSH 2020-12-09 14:29:20.684 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] READ: 25B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 48 54 54 50 2f 31 2e 31 20 31 30 30 20 43 6f 6e |HTTP/1.1 100 Con| |00000010| 74 69 6e 75 65 0d 0a 0d 0a                      |tinue....       | +--------+-------------------------------------------------+----------------+  2020-12-09 14:29:20.684 DEBUG 13379 --- [ctor-http-nio-2] r.n.http.client.HttpClientOperations     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] Received response (auto-read:false) : []  2020-12-09 14:29:20.686 DEBUG 13379 --- [ctor-http-nio-2] r.n.http.client.HttpClientOperations     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] Received last HTTP packet  2020-12-09 14:29:20.686 ERROR 13379 --- [ctor-http-nio-2] c.m.f.s.lead_manager.LeadManagerService  : HTTP call complete  2020-12-09 14:29:20.744 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] READ COMPLETE  2020-12-09 14:29:21.135 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] READ: 328B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d |HTTP/1.0 200 OK.| |00000010| 0a 44 61 74 65 3a 20 57 65 64 2c 20 30 39 20 44 |.Date: Wed, 09 D| |00000020| 65 63 20 32 30 32 30 20 32 32 3a 32 39 3a 32 30 |ec 2020 22:29:20| |00000030| 20 47 4d 54 0d 0a 53 65 72 76 65 72 3a 20 41 70 | GMT..Server: Ap| |00000040| 61 63 68 65 2f 32 2e 32 2e 31 35 20 28 43 65 6e |ache/2.2.15 (Cen| |00000050| 74 4f 53 29 0d 0a 41 63 63 65 73 73 2d 43 6f 6e |tOS)..Access-Con| |00000060| 74 72 6f 6c 2d 41 6c 6c 6f 77 2d 4f 72 69 67 69 |trol-Allow-Origi| |00000070| 6e 3a 20 2a 0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 |n: *..Content-Le| |00000080| 6e 67 74 68 3a 20 31 32 31 0d 0a 43 6f 6e 6e 65 |ngth: 121..Conne| |00000090| 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 43 6f |ction: close..Co| |000000a0| 6e 74 65 6e 74 2d 54 79 70 65 3a 20 61 70 70 6c |ntent-Type: appl| |000000b0| 69 63 61 74 69 6f 6e 2f 6a 73 6f 6e 3b 20 63 68 |ication/json; ch| |000000c0| 61 72 73 65 74 3d 75 74 66 2d 38 0d 0a 0d 0a 0a |arset=utf-8.....| |000000d0| 7b 22 66 6f 72 6d 49 64 22 3a 22 31 22 2c 22 66 |{""formId"":""1"",""f| |000000e0| 6f 6c 6c 6f 77 55 70 55 72 6c 22 3a 6e 75 6c 6c |ollowUpUrl"":null| |000000f0| 2c 22 61 6c 69 49 64 22 3a 22 65 79 4a 70 49 6a |,""aliId"":""eyJpIj| |00000100| 6f 69 52 54 55 31 52 55 39 68 54 6e 70 59 64 6b |oiRTU1RU9hTnpYdk| |00000110| 35 48 63 32 39 6c 55 79 49 73 49 6e 51 69 4f 69 |5Hc29lUyIsInQiOi| |00000120| 4a 34 53 55 46 6c 53 6e 42 49 58 43 39 70 59 30 |J4SUFlSnBIXC9pY0| |00000130| 6c 51 52 58 6f 30 57 6b 74 63 4c 32 4e 77 57 58 |lQRXo0WktcL2NwWX| |00000140| 63 39 50 53 4a 39 22 7d                         |c9PSJ9""}        | +--------+-------------------------------------------------+----------------+  2020-12-09 14:29:21.136 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] READ COMPLETE  2020-12-09 14:29:21.136 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 - R:localhost/127.0.0.1:18080] READ COMPLETE  2020-12-09 14:29:21.136 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 ! R:localhost/127.0.0.1:18080] INACTIVE  2020-12-09 14:29:21.136 DEBUG 13379 --- [ctor-http-nio-2] reactor.netty.http.client.HttpClient     : [id: 0xe76f6179, L:/127.0.0.1:63115 ! R:localhost/127.0.0.1:18080] UNREGISTERED  2020-12-09 14:51:15.457 DEBUG 13379 --- [ctor-http-nio-3] reactor.netty.http.client.HttpClient     : [id: 0x002182d6] REGISTERED  2020-12-09 14:51:15.457 DEBUG 13379 --- [ctor-http-nio-3] reactor.netty.http.client.HttpClient     : [id: 0x002182d6] CONNECT: localhost/127.0.0.1:8086  2020-12-09 14:51:15.458 DEBUG 13379 --- [ctor-http-nio-3] reactor.netty.http.client.HttpClient     : [id: 0x002182d6, L:/127.0.0.1:52563 - R:localhost/127.0.0.1:8086] ACTIVE  2020-12-09 14:51:15.458 DEBUG 13379 --- [ctor-http-nio-3] r.netty.http.client.HttpClientConnect    : [id: 0x002182d6, L:/127.0.0.1:52563 - R:localhost/127.0.0.1:8086] Handler is being applied: {uri=http://localhost:8086/assetapi/internal/rest/asset/v1/form/fields.json?_munchkinId=622-LME-718&filterValues=1, method=GET}  2020-12-09 14:51:15.468 DEBUG 13379 --- [ctor-http-nio-3] reactor.netty.http.client.HttpClient     : [id: 0x002182d6, L:/127.0.0.1:52563 - R:localhost/127.0.0.1:8086] WRITE: 213B ```  ### What I Am Working On  How can I better test this? I would like to: - Manually test this fix - Add comprehensive unit tests - Understand if I am missing more places to fix this  I have attempted to test this code form a unit test by calling out to a server that returns HTTP 100. I keep getting a socket error even though curl works on the same machine. Have you seen this before?  And, how would you suggest I add uint tests for this. I know the netty server emits with this the proper header in the request. Should I spin up that server in case the mock server does not return a HTTP 100?  ### Reference  [RFC2616 - HTTP 1.1 - Use of the 100 (Continue) Status](https://tools.ietf.org/html/rfc2616#page-48)","closed","in: web,","tweiand","2020-12-18T00:59:46Z","2021-09-27T18:19:45Z"
"","26719","Add a way to set executeExistingDelayedTasksAfterShutdown from ThreadPoolTaskScheduler","### Observed behaviour  `ThreadPoolTaskScheduler` is used for methods annotated with `@Scheduled`.    In the example of a method which is to be run at a specific time e.g. `@Scheduled( cron = ""0 0 2 * * *"" )` (run at 2 a.m.), the `ScheduledThreadPoolExecutor` within `ThreadPoolTaskScheduler` knows that it must execute this at the future time.  However, when I call `threadPoolTaskScheduler.shutdown()` the shutdown is being blocked until the queued task has been exectued. In the above example this would be, 2 a.m. + the time it takes to execute the task. Note that this behaviour only happens when I have configured a long enough termination period with `threadPoolTaskScheduler.setAwaitTerminationSeconds`.   One other point. I know the `ThreadPoolTaskScheduler` will get automatically shutdown when the application shuts down, but I am doing it manually for other reasons which I won't go into in this issue.  In summary: * I have a method scheduled for execution in the future * my `ThreadPoolTaskScheduler` has a long terimation period (`setAwaitTerminationSeconds`) * before that time I'm manually calling `threadPoolTaskScheduler.shutdown()` * shutdown is blocking until the scheduled time  My requirement here is that the `ThreadPoolTaskScheduler` should shut down faster by only waiting for those tasks which are currently being processed. Tasks which are scheduled for a future time will not be executed.  ### Current workaround  I found a method on `ScheduledThreadPoolExecutor` named `setExecuteExistingDelayedTasksAfterShutdownPolicy` which seems to do what I need.   >     * Sets the policy on whether to execute existing delayed >     * tasks even when this executor has been {@code shutdown}. >     * In this case, these tasks will only terminate upon >     * {@code shutdownNow}, or after setting the policy to >     * {@code false} when already shutdown. >     * This value is by default {@code true}.  When I set this value to `false` by configuring a custom `ThreadPoolTaskScheduler` I observe the desired behaviour.  ```         final ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler()         {             @Override             protected ExecutorService initializeExecutor(final ThreadFactory threadFactory, final RejectedExecutionHandler rejectedExecutionHandler)             {                 final ExecutorService executorService = super.initializeExecutor(threadFactory, rejectedExecutionHandler);                  if (executorService instanceof ScheduledThreadPoolExecutor)                 {                     ((ScheduledThreadPoolExecutor) executorService).setExecuteExistingDelayedTasksAfterShutdownPolicy(false);                 }                  return executorService;             }         }; ```  ### Suggested improvement  Could we configure this more easily using a property on the `ThreadPoolTaskScheduler`? In the `ThreadPoolTaskScheduler` method `initializeExecutor` it already does similar configurations e.g. for the `removeOnCancelPolicy`  ``` 		if (this.removeOnCancelPolicy) { 			if (this.scheduledExecutor instanceof ScheduledThreadPoolExecutor) { 				((ScheduledThreadPoolExecutor) this.scheduledExecutor).setRemoveOnCancelPolicy(true); 			} 			else { 				logger.debug(""Could not apply remove-on-cancel policy - not a ScheduledThreadPoolExecutor""); 			} 		} ```  If being able to set this configuration would be valuable for this framework, then maybe this would be a suitable place to put it?  The end result of how to use the new functionality might look like this:  ```     @Bean     public ThreadPoolTaskScheduler threadPoolTaskScheduler()     {         ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();         scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);         return scheduler;     } ```","closed","type: enhancement,","tkgregory","2021-03-24T10:29:41Z","2021-07-13T07:28:37Z"
"","26043","Expose a public method ""isClosed"" to indicate whether the connection has been closed in WebSocketSession (WebFlux)","### Context spring-webflux:5.3.0. org.springframework.web.reactive.socket.WebSocketSession  ### Motivation It's common to decide what to do next according to the status (open or closed) of ""WebSocketSession"". And we know WebSocketSession#closeStatus can be used as a workaround to know whether a session has been closed but it's troublesome to check the status of a session in that way.  ### Solution Expose a public method like ""isClosed"" to indicate whether the connection has been closed in WebSocketSession (WebFlux)","closed","type: enhancement,","JamesChenX","2020-11-07T02:20:51Z","2020-11-09T14:10:34Z"
"","26327","WebClient builder can't change content-type","### **Environment** ``` Spring boot version: 2.4.1 implementation 'org.springframework.boot:spring-boot-starter-webflux' ```   ### **Problem is** I changed MediaType as [application_json] using accept setter but webClient throw WebclientReponseException. ``` public Member getMember(String id) {       Member member = webClient 		      .mutate() 		      .build() 		      .get() 		      .uri(""/v1/api/member/id?id={id}"", id) 		      .accept(MediaType.APPLICATION_JSON) 		      .retrieve() 		      .bodyToMono(Member.class) 		      .flux() 		      .toStream() 		      .findFirst() 		      .orElse(null);              return member; } ```  ``` org.springframework.web.reactive.function.client.WebClientResponseException: 200 OK from GET http://localhost:9090/v1/api/member/id?id=test; nested exception is org.springframework.web.reactive.function.UnsupportedMediaTypeException: Content type 'text/html;charset=UTF-8' not supported for bodyType=com.masterpiece.core.model.Member ```   ### **Weired thing is** ""The problem depends on uri structure.""  /v1/api/member/id  <- problem (throw UnsupportedMediaTypeException) /api/v1/member/id <- working properly","closed","status: invalid,","hangryul","2020-12-31T00:26:51Z","2020-12-31T07:22:36Z"
"","26541","AbstractServerHttpResponse#cookies is not thread safe","## Versions  Spring Boot 2.4.2 Spring Web: 5.3.3 Spring Security: 5.4.2  ## Problem  I am accessing to Cookie of Spring WebFlux in user code.  At one time, I noticed that an error ""java.util.ConcurrentModificationException: null"" was logged. The following is the actual log recorded (reactor checkpoint cannot be provided because it contains business code).   Problem log.  ```plaintext java.util.ConcurrentModificationException: null         at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134)         Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  (Removed checkpoint) Stack trace:                 at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134)                 at org.springframework.util.MultiValueMapAdapter.add(MultiValueMapAdapter.java:66)                 at org.springframework.http.server.reactive.AbstractServerHttpResponse.addCookie(AbstractServerHttpResponse.java:185)                 at org.springframework.security.web.server.csrf.CookieServerCsrfTokenRepository.lambda$saveToken$0(CookieServerCsrfTokenRepository.java:83)                 at reactor.core.publisher.MonoRunnable.subscribe(MonoRunnable.java:49)                 at reactor.core.publisher.Mono.subscribe(Mono.java:4046)                 at reactor.core.publisher.MonoDelayUntil$DelayUntilCoordinator.subscribeNextTrigger(MonoDelayUntil.java:226)                 at reactor.core.publisher.MonoDelayUntil$DelayUntilCoordinator.onNext(MonoDelayUntil.java:170)                  (Removed: business class name)                  at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.onNext(MonoSubscribeOn.java:146)                  (Removed: business class name)                  at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1789)                 at reactor.core.publisher.MonoCallable.subscribe(MonoCallable.java:61)                 at reactor.core.publisher.Mono.subscribe(Mono.java:4046)                 at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:126)                 at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)                 at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)                 at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)                 at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)                 at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)                 at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)                 at java.base/java.lang.Thread.run(Thread.java:834) ```    The reason is that `cookies` in `AbstractServerHttpResponse` is a `LinkedMultiValueMap`, which is not thread-safe.  https://github.com/spring-projects/spring-framework/blob/91509805b759a108d7eca0b6b3041c434c61d837/spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java#L88  I believe this error is a result of Spring Security and the user code accessing the cookie at the same time. So far, I have only been able to see the error that occurred in the Spring Securty stack trace, so I don't know which cookie operation it conflicted with.  How do I safely access cookies?","closed","status: feedback-provided,","tt4g","2021-02-12T08:37:35Z","2021-04-27T11:38:02Z"
"","25917","@NestedTestConfiguration should not be discovered on enclosing class for nested interface","## Status Quo  While switching the default `@NestedTestConfiguration` mode to `INHERIT` in fbb3c5cce73f07679afebbb39980fb971efb9f4f, I noticed that `@NestedTestConfiguration` was discovered on an enclosing class for a nested interface if a `@Nested` test class implemented the nested interface.  If the nested interface is local to a test class that is itself annotated with `@NestedTestConfiguration`, the search algorithm in `MetaAnnotationUtils.lookUpEnclosingConfiguration()` will find that annotation before declarations more _local_ to the `@Nested` test class, and that annotation may be declared differently than a local declaration.   As a workaround, developers can redeclare `@NestedTestConfiguration` with the desired mode directly on a `@Nested` test class that implements such an interface, but that is cumbersome and error prone.  ## Analysis  This bug originates from use of `SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES` in the `MergedAnnotations` API. To fix this bug, a custom annotation search algorithm will have to be used, analogous to other search algorithms recently introduced in `MetaAnnotationUtils`.  ## Deliverables  - [x] Ensure that `MetaAnnotationUtils.lookUpEnclosingConfiguration()` does not search on enclosing classes for nested interfaces.","closed","type: bug,","sbrannen","2020-10-14T12:09:01Z","2020-10-14T12:50:44Z"
"","26145","Find all local @ActiveProfiles annotations on a test class","## Status Quo  Currently, multiple `@ActiveProfiles` declarations are discovered within a test class hierarchy (both within the inheritance hierarchy and within the enclosing class hierarchy); however, only one `@ActiveProfiles` declaration per class is supported, namely the first one found beginning with directly declared annotations and traversing up annotation hierarchies in search of meta-annotations.  ## Proposal  Initially proposed by @odrotbohm offline, it would be beneficial to support lookups for multiple `@ActiveProfiles` declarations on a given test class. This would allow one to create custom _composed annotations_ that are meta-annotated with `@ActiveProfiles` that can be combined on a given test class in an additive fashion.  For example, given the following two composed `@ProfileA` and `@ProfileB` annotations...  ```java @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ActiveProfiles(""A"") public @interface ProfileA { } ```  ```java @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @ActiveProfiles(""B"") public @interface ProfileB { } ```  ... ideally one could declare both of those annotations as follows, and Spring would activate both profiles `A` and `B`.  ```java @SpringJUnitConfig @ProfileA @ProfileB class MyIntegrationTests {   // ... } ```  ## Related Issues  - #26142  - #26141   ## Deliverables  - [ ] Determine if we wish to support multiple _local_ `@ActiveProfiles` declarations on a given test class. - [ ] If we decide to support this feature, determine if we wish to introduce a `SpringProperties` flag to disable the feature in order to support the previous semantics for backwards compatibility.","closed","type: enhancement,","sbrannen","2020-11-24T14:11:17Z","2022-06-07T22:28:21Z"
"","26447","Improve reference documentation on Resources","## Status Quo  As discussed in #26443, the [Resources section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources) of the reference documentation is very outdated, focusing primarily on XML-based configuration of the resource locations for the `ApplicationContext` and not directly mentioning `ResourcePatternResolver` at all.  ## Deliverables  - [x] Document the `ResourcePatternResolver` API as an alternative to the `ResourceLoader` API. - [x] Document `PathResource` as a built-in `Resource`. - [x] Consider providing examples where resources are injected into fields of type `Resource` or `Resource[]` in `@Configuration` classes or annotated components via `@Autowired` or `@Value` semantics.","closed","in: core,","sbrannen","2021-01-26T16:14:43Z","2021-05-06T10:34:41Z"
"","25909","Support Propagation.NEVER for disabling test-managed transactions","## Status Quo  `Propagation.NOT_SUPPORTED` can be used to disable test-managed transactions via the `@Transactional` annotation as documented in the [Javadoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/transaction/TransactionalTestExecutionListener.html) and [reference manual](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions), but `Propagation.NEVER` does not have the same effect even though users might assume it would (see https://github.com/spring-projects/spring-boot/issues/23630#issuecomment-707694364).  ## Deliverables  - [x] Support `Propagation.NEVER` for disabling test-managed transactions - [x] Document in the Javadoc for `TransactionalTestExecutionListener` - [x] Document in the reference manual","closed","type: enhancement,","sbrannen","2020-10-13T12:25:22Z","2020-10-13T16:32:36Z"
"","25973","@ActiveProfiles with same profiles but different order results in duplicate ApplicationContext","## Overview  While working on #25800, I realized that two `@ActiveProfiles` declarations on different test classes using the same profiles but declared in a different order would result in the creation of a duplicate yet identical `ApplicationContext` in the context cache in the Spring TestContext Framework. This is because `ActiveProfilesUtils` stores the active profiles in a `LinkedHashSet` to preserve registration order. The set is then converted to a `String[]` which is handed off to `MergedContextConfiguration` which also uses a `LinkedHashSet` to ensure uniqueness but still retains the registration order of the active profiles. When the `MergedContextConfiguration` is used as the context cache key to check whether an `ApplicationContext` already exists for the given metadata, the implementation of `equals()` in `MergedContextConfiguration` uses `Arrays.equals()` to compare two _sets_ of active profiles, and that results in a cache _miss_ for semantically identical active profile arrays `{ apples, oranges }` and `{ oranges, apples }`. Consequently, an identical `ApplicationContext` is created and stored in the context cache when that should not be the case.  ## Deliverables  - [x] Ensure that active profiles are both unique and sorted within `MergedContextConfiguration` in order to avoid context cache misses.","closed","type: bug,","sbrannen","2020-10-26T10:12:50Z","2020-10-26T11:55:22Z"
"","26804","Addition of fallback patterns to DateFormatter loses cause in Spring 5.3.5","## Overview  This is a follow up to #26777.  The support for fallback patterns introduced in Spring Framework 5.3.5 also introduced a regression regarding the loss of the original `ParseException` in `org.springframework.format.datetime.DateFormatter.parse(String, Locale)`.  ## Deliverables  - [x] Retain the original `ParseException` in `DateFormatter`.","closed","in: core,","sbrannen","2021-04-14T12:48:37Z","2021-04-16T17:15:40Z"
"","25913","Discover @Sql, @SqlConfig, @SqlGroup, & @SqlMergeMode on enclosing class for nested test class","## Overview  This is a follow up to #19930.  ## Deliverables  - [x] Support `@Sql` / `@SqlConfig` / `@SqlGroup` / `@SqlMergeMode` with the new `@NestedTestConfiguration` feature","closed","type: enhancement,","sbrannen","2020-10-13T13:06:26Z","2020-10-22T15:12:23Z"
"","25912","Document @NestedTestConfiguration support","## Overview  This is a follow up to #19930.  ## Deliverables  - [x] Document `@NestedTestConfiguration` support in the reference manual - [x] Document `@NestedTestConfiguration` support and switching of the default mode to `INHERITED` in the upgrade notes in the wiki","closed","type: documentation,","sbrannen","2020-10-13T13:00:45Z","2020-10-18T12:33:34Z"
"","26618","How to use a custom ObjectInputStream for secure deserialization in Spring","## Overview  Our tech stack is Spring, JPA using Hibernate, and SQL server.  1. We use Jackson for JSON serialization/deserialization for REST implementation.  2. In our model class - we have `implements Serializable`. 3. Jackson `ObjectMapper` which Spring uses also implements `Serializable`.  As we can see, Hibernate has serialization which is binary (Java), and Jackson is text (JSON) based serialization.  We would like to harden all uses of `ObjectInputStream` of java and make sure that there are no deserialization issues in our application.  @jhoeller, we request your insights in building a hardened application.  ## Questions  1. When spring and jpa/hibernate are implemented, does hibernate use the `ConfigurableObjectInputStream`? 2. Does jackson use the `ConfigurableObjectInputStream`? 3. How can we configure Spring to use our `LookAheadObjectInputStream` instead of `ConfigurableObjectInputStream`?  ## Custom ObjectInputStream  Inspired by [an example from OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#harden-your-own-javaioobjectinputstream), we would like to define a `LookAheadObjectInputStream` which would extend Spring's `ConfigurableObjectInputStream` where we can define our own application classes that can be resolved.   ```java public class LookAheadObjectInputStream extends ConfigurableObjectInputStream {      public LookAheadObjectInputStream(InputStream inputStream) throws IOException {         super(inputStream);     }     /**     * Only deserialize instances of our expected Bicycle class     */     @Override     protected Class resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {         if (!desc.getName().equals(Bicycle.class.getName())) {             throw new InvalidClassException(""Unauthorized deserialization attempt"", desc.getName());         }         return super.resolveClass(desc);     } } ```","closed","status: invalid,","mattjerry","2021-02-27T04:50:05Z","2021-03-01T15:01:14Z"
"","26554","Document all supported SpringProperties keys in the reference manual","## Overview  As a follow-up to #26492, we should document all known, supported properties that can be used with `SpringProperties` -- for example, by adding a dedicated section or appendix to the reference manual.  ## Initial Analysis  We currently support the following Spring properties within the core Spring Framework.  - `spring.beaninfo.ignore` - `spring.expression.compiler.mode` - `spring.getenv.ignore` - `spring.index.ignore` - `spring.jdbc.getParameterType.ignore` - `spring.jndi.ignore` - `spring.objenesis.ignore` - `spring.test.constructor.autowire.mode` - `spring.test.context.cache.maxSize` - `spring.test.enclosing.configuration`  None of these (other than the ones from `spring-test`) are documented anywhere in the reference manual.  NOTE: Although `spring.xml.ignore` and `spring.spel.ignore` are currently used by the framework, they are not officially supported and are subject to change (name and/or semantics) over time.  ## Deliverables  - [x] Assemble a list/table of supported Spring properties and introduce a new section in the reference manual (perhaps an appendix of sorts) that briefly describes what they are for and links to Javadoc or an appropriate section of the reference manual.","closed","type: documentation,","sbrannen","2021-02-16T14:31:25Z","2021-02-24T16:42:07Z"
"","25985","Avoid use of SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES in AnnotationDescriptor","## Overview  `AnnotationDescriptor.findAllLocalMergedAnnotations()` still uses `SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES`.  In fact, that method is the only place in the core Spring Framework that uses that search strategy.  ## Deliverables  - [x] Assess whether `SearchStrategy.TYPE_HIERARCHY` should be used instead.","closed","type: task,","sbrannen","2020-10-28T14:24:29Z","2020-11-03T15:18:55Z"
"","26778","Add awaitExchangeOrNull extension function to reactive webclient","## Background  When using the `awaitExchange` extension function on a Kotlin project, I've missed the presence of a `awaitExchangeOrNull` function, that would receive a function returning `T?`. I've added it to my project, but I think it would be nice to have it on the lib aswell, since I believe it is a usefull extension function.  ## Changes  I've simple added a new extension function `awaitExchangeOrNull` and two test scenarios.  This is my first time attempting to contribute to an open source repository, so, feel free to correct me or suggest changes, I will gladly adhere to suggestions. And let me know if this isn't desired.","closed","type: enhancement,","gabrielerzinger","2021-04-08T17:46:10Z","2021-06-08T10:09:40Z"
"","26703","Cyclic dependency with constructor injection","## Background  Spring is discouraging use of filed injection, and in favor or constructor injection.  However, when the beans need to cross reference to each other. For example:  ```java class BeanA{     @Autowired     public BeanA(BeanB beanB) {         this.beanB= beanB;     } }  class BeanB{     @Autowired     public BeanB(BeanA beanA) {         this.beanA= beanA;     }  ```  this will instead throw out exception  ``` APPLICATION FAILED TO START ***************************  Description:  The dependencies of some of the beans in the application context form a cycle:  ┌─────┐ |  beanA defined in URL [jar:file:/...class] ↑     ↓ |  beanB defined in URL [jar:file:/....class] ↑     ↓ |  xx (field xx)   ```  ## Changes  Instead of just saying ""Field injection is not recommended"", can we make it clear, by adding ``` Field injection is not recommended **however, please don't constructor injection with circular reference** ? ``` ?","open","in: core,","1zg12","2021-03-19T08:07:03Z","2022-06-07T13:28:10Z"
"","26761","Make the property resolver configurable","## Background  Prior to Spring 5.2, when we need to customize the PropertiesLoader, we can subclass `PropertyPlaceholderConfigurer`, and override the `resolvePlaceholder` method.  Now with `PropertySourcesPlaceholderConfigurer` deprecated `PropertyPlaceholderConfigurer`, the `resolvePlaceholder` method has been moved out of the `PlaceHolderConfigurer` and into a separate `PropertyResolver`.  Somehow the `PropertyResolver` is hardcoded [*]: https://github.com/spring-projects/spring-framework/blob/01bea34569cd3dd00e8691a08ab1a2fc53d6c13e/spring-context/src/main/java/org/springframework/context/support/PropertySourcesPlaceholderConfigurer.java#L157  Due to the hardcode, the only way left for developers to override the `resolvePlaceholder` now becomes to duplicate the whole `postProcessBeanFactory` method and then provide custom `PropertyResolver`.  ## Changes  Instead of hardcoding a `PropertyResolver` as existing and make it very difficult to customize, this PR will point to a factory method to provide the `PropertyResolver` as needed.  I believe there is no side effect on this. It only adds the flexibility for customization which has been lost.  #### Note [*]  Even though `PropertyPlaceholderConfigurer` was also using a hardcoded class, https://github.com/spring-projects/spring-framework/blob/01bea34569cd3dd00e8691a08ab1a2fc53d6c13e/spring-beans/src/main/java/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.java#L210  It's a private inner class, which even doesn't allow override. However, after several redirects, it eventually points to the `resolvePlaceholder` of the current class implementation https://github.com/spring-projects/spring-framework/blob/01bea34569cd3dd00e8691a08ab1a2fc53d6c13e/spring-beans/src/main/java/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.java#L250","open","in: core,","1zg12","2021-04-05T09:08:07Z","2022-05-25T14:49:48Z"
"","25905","NamedParameterJdbcTemplate#query use postgresql ""WITH GROUP"" ERROR","# version * JDK:1.8 * SpringBoot:2.2.4.RELEASE * postgresql driver:42.2.11 * postgresql: 9.4  # question  When I use NamedParameterJdbcTemplate# query error  **code** ```java String sql=""select percentile_cont(0.5) WITHIN GROUP (order by dm_assistant_user_wechat.user_id) as alias_key_1 from dm_assistant_user_wechat offset 0 limit 500""; queryResult = jdbcTemplate.query(sql, Maps.newHashMap(), new ColumnMapRowMapper()); ```  **error** ``` PreparedStatementCallback; uncategorized SQLException for SQL [select percentile_cont(0.5) WITHIN GROUP (order by dm_assistant_user_wechat.user_id) as alias_key_1 from dm_assistant_user_wechat offset 0 limit 500]; SQL state [null]; error code [0]; sql injection violation, syntax error: syntax error, error in :'THIN GROUP (order by dm_assistant_u', expect BY, actual LPAREN pos 42, line 1, column 42, token LPAREN : select percentile_cont(0.5) WITHIN GROUP (order by dm_assistant_user_wechat.user_id) as alias_key_1 from dm_assistant_user_wechat offset 0 limit 500; nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'THIN GROUP (order by dm_assistant_u', expect BY, actual LPAREN pos 42, line 1, column 42, token LPAREN : select percentile_cont(0.5) WITHIN GROUP (order by dm_assistant_user_wechat.user_id) as alias_key_1 from dm_assistant_user_wechat offset 0 limit 500 ```  * Asked the PGJDBC developers, confirming not PGJDBC problem, I think it may be springboot NamedParameterJdbcTemplate problem.   **pgjdbc issue**  [pgjdbc](https://github.com/pgjdbc/pgjdbc/issues/1917)","open","in: data,","collabH","2020-10-13T01:36:30Z","2021-11-10T12:11:02Z"
"","26786","HttpRange.toResourceRegion() does incorrect calculations, resulting in 416 error responses.","# Issue  `HttpRange`'s `public ResourceRegion toResourceRegion(Resource resource)` method incorrectly validates `Content-length` when the remaining amount of ranged-data is less than the starting range value, throwing `'position' exceeds the resource length` errors and returning 416 errors in my server's response.  # Version  Spring Boot version 2.3.0.RELEASE.  # Details  When returning a `ResponseEntity` with a byte range of `199819264-201121204/201121205`, the EntityResponseBuilder's call to `HttpRange.toResourceRegion()` throws an error. Upon inspection, this seems to be caused by the `Content-length: 1301941` being 1 byte greater than the `getRangeStart()` and `getRangeEnd()` functions. However, the content length is actually correct due to the range start and range end values being inclusive.  For example, using the same `Content-range` from above:  * `long contentLength = getLengthFor(resource) -> 1301941` * `long start = getRangeStart(contentLength) -> 199819264` * `long end = getRangeEnd(contentLength) -> contentLength - 1 == 1301940` * `Assert.isTrue(start < contentLength) -> error`  If `rangeEnd - rangeStart = contentLength - 1`, then `201121204 - 199819264 = 1301941`; `1301941 - 1 = 1301940` due to the rangeEnd being inclusive (i.e. we add 1 to `rangeEnd - rangeStart`. This means the response `Content-range` should be correct. However, it's failing just because the `getRangeStart()` is greater than the `contentLength`.   Furthermore, `start < contentLength` should not be the deciding factor to determining if the response is valid; rather `start + contentLength-1 <= end` should be the deciding factor.  Here is an image of my debugger showing the issue in action:  ![Spring content-range bug](https://user-images.githubusercontent.com/15034905/114288973-58462880-9a31-11eb-9905-76d6d5cac2c2.png)","closed","status: feedback-provided,","D-Pow","2021-04-11T01:20:13Z","2021-04-13T13:20:59Z"
"","26279","Azure issue when implementing reports with com.azure.identity.clientsecretcredential","# I tried to implement Azure into my application in 2 ways ## 1) Succesful Azure implementation I tried to implement Azure into Spring as Azure Storage File Datalake https://docs.microsoft.com/en-us/java/api/overview/azure/storage-file-datalake-readme?view=azure-java-stable , with this code it runs succesfully ``` DataLakeFileSystemClient dataLakeFileSystemClient = new DataLakeFileSystemClientBuilder()     .endpoint("""" + ""/"" + ""myfilesystem"" + ""?"" + """")     .buildClient(); ``` ## 2) Unsuccessful Azure implementation However in order to use Azure with com.azure.identity.clientsecretcredential https://docs.microsoft.com/en-us/java/api/com.azure.identity.clientsecretcredential?view=azure-java-stable ``` val clientSecretCredential: ClientSecretCredential = ClientSecretCredentialBuilder()             .clientId(clientid)             .clientSecret(clientsecret)             .tenantId(tenantid)             .build()          val builder = DataLakeServiceClientBuilder()          try {             val dataLakeClient = if (httpClient == null) {                  builder.credential(clientSecretCredential)                     .endpoint(endpoint)                     .buildClient() ``` I use these dependencies ```  azureCoreHttpNettyVersion = ""1.7.0""         azureIdentityVersion = ""1.2.0""         azureStorageFileDataLakeVersion = ""12.3.0""   implementation(""com.azure:azure-storage-file-datalake:${azureStorageFileDataLakeVersion}"")     implementation(""com.azure:azure-identity:${azureIdentityVersion}"")     implementation(""com.azure:azure-core-http-netty:${azureCoreHttpNettyVersion}"") ``` I got this Error ``` 2020-12-15 12:03:01.727 ERROR 6416 --- [nPool-worker-19] c.azure.identity.ClientSecretCredential  : Azure Identity => ERROR in getToken() call for scopes [https://storage.azure.com/.default]: com/nimbusds/oauth2/sdk/http/CommonContentTypes 2020-12-15 12:03:01.728 ERROR 6416 --- [nPool-worker-19] c.a.core.credential.SimpleTokenCache     : Failed to acquire a new access token. Exception in thread ""main"" java.lang.NoClassDefFoundError: com/nimbusds/oauth2/sdk/http/CommonContentTypes 	at com.microsoft.aad.msal4j.TokenRequestExecutor.createOauthHttpRequest(TokenRequestExecutor.java:46) 	at com.microsoft.aad.msal4j.TokenRequestExecutor.executeTokenRequest(TokenRequestExecutor.java:36) 	at com.microsoft.aad.msal4j.AbstractClientApplicationBase.acquireTokenCommon(AbstractClientApplicationBase.java:119) 	at com.microsoft.aad.msal4j.AcquireTokenByAuthorizationGrantSupplier.execute(AcquireTokenByAuthorizationGrantSupplier.java:63) 	at com.microsoft.aad.msal4j.AuthenticationResultSupplier.get(AuthenticationResultSupplier.java:59) 	at com.microsoft.aad.msal4j.AuthenticationResultSupplier.get(AuthenticationResultSupplier.java:17) 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run$$$capture(CompletableFuture.java:1700) 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java) 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1692) 	at java.base/java.util.concurrent.ForkJoinTask.doExec$$$capture(ForkJoinTask.java:290) 	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java) 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020) 	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656) 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594) 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183) Caused by: java.lang.ClassNotFoundException: com.nimbusds.oauth2.sdk.http.CommonContentTypes 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) 	... 15 more ```  ### If I run the method 2 as a simple function it works correctly, If I run it using spring I got the error above.   **Affects:** \ Spring 2.1.4.RELEASE and 2.4.1  ---","closed","for: external-project,","nandorrb","2020-12-15T13:59:45Z","2020-12-15T15:09:18Z"
"","26418","Close mapping streams after the ValidatorFactory has been built in LocalValidatorFactoryBean","""The stream should be closed by the client API after the ValidatorFactory has been built. ""","closed","type: enhancement,","limo520","2021-01-21T04:58:41Z","2021-02-14T16:29:09Z"
"","26356","Getting Started Guides  - Links for Build with Maven, Gradle and IDE don't work","![Capture](https://user-images.githubusercontent.com/41189303/103912912-ccee8b80-50ff-11eb-84e0-56a67352e111.PNG) For example, go to https://spring.io/guides/gs/accessing-data-gemfire/ and click on the Build With Maven link. It doesn't do anything.","closed","for: external-project,","sam1999uk","2021-01-07T15:47:25Z","2021-01-07T16:48:26Z"
"","26667","Problems in applyprehandle processing","![bbs_1615476229893](https://user-images.githubusercontent.com/7982205/110884793-9eb84280-8320-11eb-8950-1c2ef1f22d3b.png)  ![bbs_1615476501636](https://user-images.githubusercontent.com/7982205/110884814-a7a91400-8320-11eb-9f52-218b9181483d.png)  ![bbs_1615476580222](https://user-images.githubusercontent.com/7982205/110884836-ae378b80-8320-11eb-96e1-0a2d7c6bef19.png)   As long as the interceptor throws an exception by executing prehandle, it will not perform the aftercompletion operation  If the after completion operation is not executed, there is no reasonable time to process the cleaning code (such as threadload and cache)","closed","status: invalid,","thankgoodness","2021-03-12T02:52:47Z","2021-11-10T12:38:48Z"
"","26863","Rename default branch to main","","closed","type: task,","snicoll","2021-04-27T05:09:03Z","2021-04-27T05:10:11Z"
"","26860","Optimize the assignment of UnsatisfiedServletRequestParameterException paramConditions","","closed","status: invalid,","TAKETODAY","2021-04-25T15:29:51Z","2021-04-26T13:44:00Z"
"","26827","WebMvcConfigurer support Order","","closed","status: invalid,","liaozan","2021-04-20T11:53:25Z","2021-04-20T14:36:41Z"
"","26781","Update to Gradle Enterprise Gradle Plugin 3.6.1","","closed","type: task,","runningcode","2021-04-09T11:11:27Z","2021-04-09T14:47:27Z"
"","26768","Upgrade to Reactor Dysprosium-SR19","","closed","type: dependency-upgrade,","snicoll","2021-04-06T16:30:12Z","2021-04-12T16:12:31Z"
"","26767","Upgrade to Reactor 2020.0.6","","closed","type: dependency-upgrade,","snicoll","2021-04-06T16:29:30Z","2021-04-12T19:32:03Z"
"","26764","pull代码","","closed","","liwenzlw","2021-04-06T03:22:00Z","2021-04-06T03:22:38Z"
"","26747","my first github project!","","closed","status: invalid,","myflzh119","2021-03-30T18:16:24Z","2021-03-31T11:45:25Z"
"","26735","avoid re-initializing the HandlerMethod","","closed","status: declined,","liaozan","2021-03-26T16:00:32Z","2021-03-29T16:42:21Z"
"","26733","Avoid other threads to get early objects directly","","open","in: core,","coderlaohei","2021-03-26T10:42:37Z","2021-11-12T14:16:36Z"
"","26689","lwj_spring5.0_study","","closed","status: invalid,","lengweijian","2021-03-17T03:20:25Z","2021-03-17T08:00:18Z"
"","26678","Fix Commons FileUpload URL in reference guide","","closed","type: documentation,","1993heqiang","2021-03-15T02:58:19Z","2021-03-15T08:45:33Z"
"","26650","Upgrade to Reactor 2020.0.5","","closed","type: dependency-upgrade,","rstoyanchev","2021-03-08T18:40:53Z","2021-03-16T07:19:52Z"
"","26640","Fixed typo in ref docs","","closed","type: task,","alex-krav","2021-03-04T17:21:49Z","2021-03-05T14:07:23Z"
"","26596","Add 6 large files","","closed","","dan-codacy","2021-02-23T16:42:11Z","2021-02-23T17:05:06Z"
"","26595","Add vscode folder to .gitignore","","closed","type: task,","ShaoqiangLu","2021-02-23T16:07:30Z","2021-02-23T16:43:49Z"
"","26580","#update:添加cglib,objenesis","","closed","","hadesvip","2021-02-21T08:24:33Z","2021-02-21T08:24:48Z"
"","26577","Improve Javadoc of ExchangeFunction","","closed","type: task,","limo520","2021-02-20T08:10:13Z","2021-02-24T09:38:20Z"
"","26568","Fix Javadoc link in DynamicIntroductionAdvice","","closed","in: core,","1993heqiang","2021-02-18T11:50:48Z","2021-02-18T12:31:29Z"
"","26552","Upgrade to Gradle 6.8.2","","closed","type: task,","snicoll","2021-02-15T15:56:19Z","2021-02-15T16:09:02Z"
"","26551","Fix typo in @Configurable example in reference manual","","closed","type: task,","cprayer","2021-02-15T15:20:00Z","2021-02-16T01:12:35Z"
"","26549","Upgrade to Reactor Dysprosium-SR17","","closed","type: dependency-upgrade,","jhoeller","2021-02-15T11:57:13Z","2021-02-15T17:43:34Z"
"","26548","Upgrade to Reactor 2020.0.4","","closed","type: dependency-upgrade,","jhoeller","2021-02-15T11:56:37Z","2021-02-16T19:57:49Z"
"","26545","Upgrade to Kotlin 1.4.30","","closed","type: dependency-upgrade,","sdeleuze","2021-02-15T09:46:53Z","2021-02-15T09:51:53Z"
"","26540","Update ref docs for nested class names","","closed","in: core,","alex-krav","2021-02-11T17:14:38Z","2021-02-12T11:45:03Z"
"","26515","4.3.x","","closed","status: invalid,","zhangjian965","2021-02-06T02:15:46Z","2021-02-06T07:40:33Z"
"","26477","add learning projects.","","closed","status: invalid,","papwuj","2021-01-30T00:56:36Z","2021-01-31T14:09:56Z"
"","26468","Fix ContentCachingResponseWrapper comment typo","","closed","type: task,","grimsa","2021-01-28T15:19:14Z","2021-01-28T17:54:06Z"
"","26429","同步","","closed","","FlyingNewbie","2021-01-22T02:07:36Z","2021-01-22T10:48:16Z"
"","26421","@Transactional on suspending function returning Long type never commit tx,and database session show sleep status.","","open","in: data,","lujijiang","2021-01-21T10:42:39Z","2021-11-10T09:27:08Z"
"","26416","5.1 learn","","closed","status: invalid,","liweifan0616","2021-01-21T03:03:44Z","2021-01-21T06:07:16Z"
"","26402","Make CommonsPool2TargetSource generic","","closed","in: core,","quaff","2021-01-19T01:46:11Z","2021-12-13T08:44:57Z"
"","26383","V5.1 learn","","closed","status: invalid,","liweifan0616","2021-01-14T06:24:35Z","2021-01-14T10:00:24Z"
"","26374","Update Gradle Enterprise Plugin versions","","closed","type: dependency-upgrade,","runningcode","2021-01-12T12:28:29Z","2021-01-12T12:59:50Z"
"","26367","Upgrade to Reactor 2020.0.3","","closed","type: dependency-upgrade,","rstoyanchev","2021-01-11T09:25:45Z","2021-01-11T15:42:52Z"
"","26342","spring source","","closed","status: invalid,","dodoitwell","2021-01-04T08:16:51Z","2021-01-04T08:32:29Z"
"","26325","注释","","closed","status: invalid,","JimiDeer","2020-12-30T03:11:34Z","2020-12-30T08:27:01Z"
"","26286","Update Gradle Enterprise Gradle Plugin and Spring Conventions Plugin","","closed","status: duplicate,","runningcode","2020-12-16T16:33:07Z","2021-01-12T12:40:39Z"
"","26284","@PreDestroy @PostConstruct support @Order","","closed","in: core,","biuabiu","2020-12-16T01:34:57Z","2021-12-10T23:15:21Z"
"","26280","Stop the started LifeCycle when start any LifeCycle failed","","open","in: core,","wangkaish","2020-12-15T14:01:52Z","2021-11-11T09:50:26Z"
"","26237","Remove duplicate ""property"" in PropertyCacheKey.toString()","","closed","in: core,","limo520","2020-12-08T02:41:09Z","2020-12-08T13:51:11Z"
"","26233","Upgrade to Reactor Californium-SR23","","closed","type: dependency-upgrade,","jhoeller","2020-12-07T21:20:39Z","2020-12-07T21:35:56Z"
"","26226","Upgrade to Kotlin Coroutines 1.4.2","","closed","type: dependency-upgrade,","sdeleuze","2020-12-07T09:47:47Z","2020-12-07T09:49:37Z"
"","26225","Upgrade to Gradle 6.7.1","","closed","type: task,","snicoll","2020-12-07T09:42:59Z","2020-12-07T09:44:02Z"
"","26218","新提交","","closed","status: invalid,","cxyxd","2020-12-05T10:05:48Z","2020-12-05T12:17:30Z"
"","26211","Correct satisfies statements in SpelParserTests.generalExpressions","","closed","in: core,","limo520","2020-12-04T09:31:00Z","2020-12-04T18:11:58Z"
"","26176","Upgrade to Reactor 2020.0.2","","closed","type: dependency-upgrade,","snicoll","2020-11-30T06:13:40Z","2020-12-07T23:00:51Z"
"","26175","Upgrade to Reactor Dysprosium-SR15","","closed","type: dependency-upgrade,","snicoll","2020-11-30T06:13:15Z","2020-12-08T04:53:18Z"
"","26132","Upgrade to Kotlin 1.4.21","","closed","type: dependency-upgrade,","sdeleuze","2020-11-23T10:23:31Z","2020-12-08T07:30:08Z"
"","26109","A3 pull request","","closed","status: invalid,","JaguP","2020-11-18T07:17:07Z","2020-11-18T07:18:43Z"
"","26076","Make tests meaningful in DefaultListableBeanFactoryTests","","closed","in: core,","limo520","2020-11-12T04:26:47Z","2020-11-12T12:50:31Z"
"","26051","Use RxJava 2/3 fromPublisher() when possible in ReactiveAdapterRegistry","","closed","in: core,","sdeleuze","2020-11-09T13:46:58Z","2020-11-09T13:52:37Z"
"","26044","Delete explicit type arguments that can be inferred","","closed","type: task,","NaNrailgun","2020-11-07T05:14:09Z","2020-11-08T14:40:07Z"
"","26030","Kotlin extensions for WebClient.ResponseSpec","","closed","type: enhancement,","mplain","2020-11-04T09:11:40Z","2020-12-07T09:35:35Z"
"","25991","Remove rogue semicolon in WebClient docs","","closed","type: task,","aksh1618","2020-10-29T10:06:52Z","2020-10-31T10:18:44Z"
"","25969","Upgrade to Kotlin Coroutines 1.4.0","","closed","type: dependency-upgrade,","sdeleuze","2020-10-25T18:05:49Z","2020-10-26T19:13:40Z"
"","25957","Upgrade to RSocket 1.0.3","","closed","type: dependency-upgrade,","rstoyanchev","2020-10-22T20:45:57Z","2020-10-26T21:49:59Z"
"","25956","Upgrade to RSocket 1.1.0","","closed","type: dependency-upgrade,","rstoyanchev","2020-10-22T20:38:45Z","2020-10-27T14:05:27Z"
"","25948","Upgrade to Reactor Californium-SR22","","closed","type: dependency-upgrade,","snicoll","2020-10-21T12:24:45Z","2020-10-25T17:12:58Z"
"","25947","Upgrade to Reactor 2020.0.0","","closed","type: dependency-upgrade,","snicoll","2020-10-21T12:17:09Z","2020-10-27T02:22:40Z"
"","25946","Upgrade to Reactor Dysprosium-SR13","","closed","type: dependency-upgrade,","snicoll","2020-10-21T12:14:53Z","2020-10-26T16:02:35Z"
"","25916","Create spring-framework","","closed","","13656663676","2020-10-14T07:37:14Z","2020-10-14T07:39:53Z"
"","25911","Prepare Concourse pipeline for GA releases","","closed","type: task,","bclozel","2020-10-13T12:51:35Z","2020-10-15T16:07:46Z"
"","25898","Upgrade to RSocket 1.1.0-RC1","","closed","type: dependency-upgrade,","rstoyanchev","2020-10-12T13:29:06Z","2020-10-13T14:43:32Z"
"","25893","Fix a few typos in the web reference docs","","closed","type: task,","sokrato","2020-10-10T12:25:59Z","2021-04-27T11:33:58Z"
"","25884","Upgrade to Reactor 2020.0.0-RC2","","closed","type: dependency-upgrade,","rstoyanchev","2020-10-08T13:59:24Z","2020-10-13T14:43:44Z"
"","25876","README Added","","closed","status: invalid,","touhid-jisan","2020-10-07T13:15:51Z","2020-10-07T13:47:18Z"
"","25866","Add missing awaitBodilessEntity and createExceptionAndAwait ClientResponse extensions","","closed","type: enhancement,","sdeleuze","2020-10-07T08:49:36Z","2020-10-07T09:10:18Z"