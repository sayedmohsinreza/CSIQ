"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","27185","Gushizhao","第一次提交，修改配置添加阿里云镜像","closed","status: invalid,","z18538613285","2021-07-16T15:04:58Z","2021-07-16T20:28:26Z"
"","27539","Merge pull request #1 from spring-projects/master","更新代码","closed","status: invalid,","tangwan","2021-10-09T13:47:59Z","2021-10-10T12:11:07Z"
"","27471","5.3.x","更新","closed","","Jervis-Miao","2021-09-26T15:29:06Z","2021-09-26T15:29:58Z"
"","27470","5.3.x","更新","closed","","Jervis-Miao","2021-09-26T15:23:58Z","2021-09-26T15:25:53Z"
"","27472","5.3.x","同步更新","closed","","Jervis-Miao","2021-09-26T15:40:39Z","2021-09-26T15:41:04Z"
"","27293","Code note","合并原项目代码","closed","status: invalid,","mengxiaoZzz","2021-08-19T06:43:14Z","2021-08-19T06:57:04Z"
"","26912","Provide option to switch threads for WebFlux controller methods","…e running in Elastic thread pool.  In WebFlux, we should support asynchronous and synchronous both.  if the controller method's return type is Mono/Flux/Future/CompleteableFuture, we should runnint this controller in synchronous(IO) thread, but if they just not want running in Asychronous Mode, they may invoke database or something else (IO operation), they just not return Mono/Flux type, and we throw them into elastic thread pool.  It's very helpful to many projects, to gain asynchronous and synchronous advances.","open","type: enhancement,","fugui","2021-05-09T01:28:03Z","2021-11-16T11:49:31Z"
"","27763","selfCoders → Split the RequestBodyAdvice.supports method into Request…","…BodyAdvice.beforeBodySupport and RequestBodyAdvice.afterBodySupport, judge whether the RequestBodyAdvice.beforeBodyRead and RequestBodyAdvice.afterBodyRead methods are applicable respectively , Corresponding changes have also been made to the related parts","closed","status: duplicate,","selfcoders","2021-12-04T01:16:01Z","2021-12-04T08:35:34Z"
"","27762","selfCoders → Split the RequestBodyAdvice.supports method into Request…","…BodyAdvice.beforeBodySupport and RequestBodyAdvice.afterBodySupport, judge whether the RequestBodyAdvice.beforeBodyRead and RequestBodyAdvice.afterBodyRead methods are applicable respectively , Corresponding changes have also been made to the related parts","closed","status: duplicate,","selfcoders","2021-12-04T01:01:13Z","2021-12-04T08:35:22Z"
"","27239","Replace XMLReaderFactory with SAXParserFactory","XMLReaderFactory has been marked as deprecated and without additional configuration, and it's slower than SAXParserFactory.  Previously `XMLReaderFactory.createXMLReader()` is called upon every request. This is an anti-pattern as mentioned in [1] and it can be very slow since it loads the jar service file unless a parser has been pre-assigned [2] (e.g. by setting org.xml.sax.driver).  SAXParserFactory uses a FactoryFinder [3] instead, which takes advantage of a thread-local cache provided by ServiceLoader. Developers can still pre-assign a factory by setting javax.xml.parsers.SAXParserFactory to make it faster.  [1] https://bugs.openjdk.java.net/browse/JDK-6925410 [2] https://github.com/openjdk/jdk/blob/c8add223a10030e40ccef42e081fd0d8f00e0593/src/java.xml/share/classes/org/xml/sax/helpers/XMLReaderFactory.java#L144-L148 [3] https://github.com/openjdk/jdk/blob/66c653c561b3b5e904579af62e23ff94952bca05/src/java.xml/share/classes/javax/xml/parsers/SAXParserFactory.java#L181-L185  ---  Related: #19055  Upstream discussion: https://mail.openjdk.java.net/pipermail/jdk-dev/2021-August/005853.html","closed","in: core,","Frederick888","2021-08-04T07:54:35Z","2021-12-02T10:34:33Z"
"","26899","Merge pull request #1 from spring-projects/master","x","closed","","ihoooooo","2021-05-06T02:08:00Z","2021-05-06T05:40:27Z"
"","27813","Deprecate CachingConfigurerSupport and AsyncConfigurerSupport","With default methods available for the base interface in `5.3.x`, let's deprecated the support classes as these are no longer necessary.","closed","type: enhancement,","snicoll","2021-12-14T13:00:52Z","2021-12-15T11:15:30Z"
"","27478","Support sending response payload metadata from RSocket Controllers","With bare RSocket, you can return payload metadata from a SocketAcceptor, and an RSocket client can receive that payload with metadata. Using Spring @Controller-annotated classes with @MessageMapping-annotated methods, you can't return any metadata/headers, the only supported direction for headers is in. RSocketRequester also has no way to receive them.","open","in: messaging,","gadams00","2021-09-27T15:47:07Z","2021-11-10T09:11:32Z"
"","27227","why you use cheap and traditional and hated technologies in spring core like servlet, java ee, jsr and so on why you don't present new webserver java 8 or later with new design in serving #27529","why you use cheap technologies in spring core like servlet, jsr and so on why you dont present new webserver java 8 or later with new design in serving  i can not understand why powerful spriong's developer use traditional web technologies like java ee why u can not update yourself with new design all java developers hate java ee ....","closed","status: invalid,","loveyandex","2021-07-29T21:50:53Z","2021-07-30T09:18:44Z"
"","27228","Why is there no index directory on the left? The operation now is very inconvenient!","Why is there no index directory on the left? The operation now is very inconvenient!  link: https://docs.spring.io/spring-framework/docs/current/reference/html/core.html","closed","status: duplicate,","starSmallDream","2021-07-30T05:13:21Z","2021-07-30T06:50:49Z"
"","27440","spring-security-oauth2-client:5.5.1 class OAuth2AuthorizationGrantRequestEntityUtils why UrlEncoder is added for client-secret","Why in spring-security-oauth2-client:5.5.1  Class->OAuth2AuthorizationGrantRequestEntityUtils  clientId and ClientSecret is encode using (URLEncoder.encode) before Base64 encoding of clientId and secret .  We were using 5.4.4 version of spring-security-oauth2-client previously to fetch token  using class OAuth2AuthorizationGrantRequestEntityUtils from external server .   After updating to spring-security-oauth2-client:5.5.1 spring had added logic to (URLEncoder.encode) client-secret which effect client-secret if they having special character and server not able to validate Authorization key we are sending to token endpoint.           String clientId = **encodeClientCredential**(clientRegistration.getClientId());          String clientSecret = **encodeClientCredential**(clientRegistration.getClientSecret());  Here we also have concern does this  mentioned in OIDC spec to do (URLEncoder.encode) before doing Base64 encode. As this will  cause problem for all client having client-secret with special character in them, as Authorization server will not able to validate them.","closed","for: external-project,","Dineshseervi","2021-09-20T10:24:23Z","2021-09-20T15:40:42Z"
"","27756","Update private methods to protected in AbstractJacskon2Decoder","Why do we need to change the private methods to protected in AbstractJackson2decoder?   - To have the ability to use all the default behavior but add some contextual information to the deserializer; Allowing  getObjectReader, getContextClass, logValue, and processException to be protected allows the extended classes of AbstractJackson2Decoder to achieve adding additional contextual information  - Also, avoid duplicating the logic","closed","status: declined,","sarathkumar6","2021-12-01T14:31:29Z","2021-12-13T14:37:01Z"
"","27139","BeanCreationException error message should always include declaring class of constructor (or factory method)","While working on Spring Data support for Spring Native I see error messages coming from https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java#L279 I get exceptions like the one below.  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'elasticsearchAuditingHandler': Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities) 	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:279) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1354) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[na:na] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[na:na] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[na:na] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[na:na] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[na:na] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) ~[na:na] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) ~[na:na] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[na:na] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[data-elasticsearch:2.5.2] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[data-elasticsearch:2.5.2] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[data-elasticsearch:2.5.2] 	at com.example.data.elasticsearch.ElasticsearchApplication.main(ElasticsearchApplication.java:33) ~[data-elasticsearch:0.0.1-SNAPSHOT] ```  Unfortunately it does not contain information about the class to be constructed, which would be really helpful when trying to get things in Spring Native to work.  I think this  happens when we construct BeanDefinitions programmatically, but I’m not completely sure about that.  It would be great if the error message could be improved to always include the class name to be constructed.","closed","type: enhancement,","schauder","2021-07-07T11:08:49Z","2021-07-09T11:27:55Z"
"","26997","HTMLUtils should accept null input values","While using `HTMLUtils.htmlEscape()`, it throws an `IllegalArgumentException` for null input values.  So to avoid this we need to add null checks on arguments explicitly.  Can't it be handled  internally?","closed","type: enhancement,","spalve96","2021-05-28T10:33:26Z","2021-05-28T14:12:40Z"
"","27861","reactor.netty.http.client.PrematureCloseException: Connection prematurely closed DURING response","While consuming a flux which contains 40,000 records I am getting ""Connection prematurely closed during response"". Tried changing response timeout but still the issue persists.","closed","in: web,","RB2601","2021-12-27T17:44:46Z","2022-01-18T14:42:56Z"
"","27720","Allow the handlers in HandlerMappings handling the PreFlight Requests","When using spring cloud gateway as a route, we want to handle PreFlight Request in handler which from HandlerMappings, but after spring-WebFlux 5.3.4, PreFlight Request can not reach invokeHandler, even after overriding the 'getHandler()' in AbstractHandlerMapping which works well before 5.3.4.  [code](https://github.com/spring-projects/spring-framework/blob/974d326bf502f0196a55ad3719861b3e52066cbd/spring-webflux/src/main/java/org/springframework/web/reactive/DispatcherHandler.java#L146-L148)  Is it possible to just delete or bring a config to disable the code above, so the PreFlight Request can be handled in the handler?","closed","for: stackoverflow,","mouxhun","2021-11-23T10:59:52Z","2021-11-23T17:56:16Z"
"","27368","Spring MVC: Fragments with curly braces removed by HierarchicalUriComponents.expandInternal()","When using `UriComponentsBuilder` along with URI variables, some fragments with curly braces are silently removed from the URI,   even if they don't follow the variable naming convention, nor contain any variable name to be replaced. I have suffered this problem when trying to pass in a query param formatted as JSON.  The following unit test illustrates the problem well:  ```java 	@Test 	public void testHierarchicalUriComponents_OK() {  		String uriString = UriComponentsBuilder 				.fromHttpUrl(""http://localhost"") 				.path(""/12345"") 				.queryParam(""json"", ""{\""role\"":{\""xxxx\"": \""yyyy\""}}"") 				.build() 				.toUriString();  		System.out.println(uriString); // http://localhost/12345?json={""role"":{""xxxx"": ""yyyy""}} 		assertThat(uriString).contains(""xxxx""); 	} 	 	 	@Test 	public void testHierarchicalUriComponents_KO() { 			 		Map variables = new HashMap(); 		variables.put(""id"", ""12345"");  		String uriString = UriComponentsBuilder 				.fromHttpUrl(""http://localhost"") 				.path(""/{id}"") 				.queryParam(""json"", ""{\""role\"":{\""xxxx\"": \""yyyy\""}}"") 				.uriVariables(variables) 				.build() 				.toUriString();  		System.out.println(uriString);  // http://localhost/12345?json={""role"":} 		assertThat(uriString).contains(""xxxx""); 	} ``` I guess this is a bug, because the documentation does not refer to any limitation about using URI variables and sections with curly braces _together_. Note that the uriString shown in the example is not encoded, for illustration purposes.  **Affects:** 5.2.12","open","in: web,","aritzbastida","2021-09-07T06:45:11Z","2021-09-07T12:46:46Z"
"","26974","Document transactional semantics for `@TransactionalEventListener` after completion methods","When using `@TransactionalEventListener` with the default `AFTER_COMMIT` or `AFTER_COMPLETION` phase, any database writes in the listener method are being discard **silently**, e.g.:  ```java @TransactionalEventListener void onEvent(BookSavedEvent event) {   // This does get called, but the following write to the database will be discarded silently   var book = books.findById(event.bookId).orElseThrow();   book.title = ""New Title"";   books.save(book); } ```  This problem doesn't happen if the phase is `BEFORE_COMMIT` or if just using the regular `@EventListener` instead.  I've made an example project using v2.5.0 demonstrating the problem: https://github.com/laech/spring-transactional-event-listener-disappearing-writes/blob/master/src/main/java/com/example/demo/DemoApplication.java  If you do `./gradlew bootRun` on the above project you can see the mismatch in expectation.","closed","type: documentation,","laech","2021-05-26T02:03:23Z","2021-05-26T12:27:42Z"
"","27170","Uploading a too-large file should be a 4xx client error, not a 500 Internal Server Error","When uploading a file that is too large (exceeding either `spring.servlet.multipart.max-file-size` or `spring.servlet.multipart.max-request-size`), a 500 Internal Server Error is thrown.  This seems odd to me, as this is an error due to an unsupported value sent by the client, not an unexpected server issue.  It feels like a 4xx client error would be more appropriate for this situation, such as 413 Payload Too Large.  ## Workaround  This can be manually implemented in a Spring Boot application today by creating a custom `@ExceptionHandler` for `MaxUploadSizeExceededException`.  If the handler is set in the controller class, the `spring.servlet.multipart.resolve-lazily` property must also be set to `true`:  ```java @ExceptionHandler public void maxUploadSizeExceeded(MaxUploadSizeExceededException e, HttpServletResponse response) throws IOException {     response.sendError(HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE); } ```  ## Example of current behavior  ```java import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile;  @RestController @RequestMapping(""/fileUpload"") public class FileUploadController {     @PostMapping     public String handleFileUpload(@RequestParam(""file"") MultipartFile file) {         return String.format(""Uploaded %s (%s bytes)"", file.getName(), file.getSize());     } } ```  ```java import com.fasterxml.jackson.databind.JsonNode; import org.junit.jupiter.api.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.core.io.FileSystemResource; import org.springframework.http.*; import org.springframework.test.context.TestPropertySource; import org.springframework.util.LinkedMultiValueMap; import org.springframework.web.multipart.MaxUploadSizeExceededException;  import java.io.*; import java.nio.file.*;  import static org.junit.jupiter.api.Assertions.assertEquals;  class UploadTest {     @Nested     @TestPropertySource(properties = ""spring.servlet.multipart.max-file-size:1000B"")     class MaxFileSize extends AbstractUploadTest {         @Test         void uploadFileLargerThanMaxFileSize() {             ResponseEntity response = uploadFileWithError("" "".repeat(2000).getBytes());             assertEquals(MaxUploadSizeExceededException.class.getName(), response.getBody().get(""exception"").textValue());             assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());         }     }      @Nested     @TestPropertySource(properties = ""spring.servlet.multipart.max-request-size:1000B"")     class MaxRequestSize extends AbstractUploadTest  {         @Test         void uploadFileLargerThanMaxRequestSize() {             ResponseEntity response = uploadFileWithError("" "".repeat(2000).getBytes());             assertEquals(MaxUploadSizeExceededException.class.getName(), response.getBody().get(""exception"").textValue());             assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());         }     }      @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)     @TestPropertySource(properties = ""server.error.include-exception=true"")     private static abstract class AbstractUploadTest {         @Autowired         private TestRestTemplate testRestTemplate;          protected ResponseEntity uploadFileWithError(byte[] bytes) {             return testRestTemplate.postForEntity(""/fileUpload"",                     getRequestEntity(bytes), JsonNode.class);         }          private HttpEntity getRequestEntity(byte[] data) {             LinkedMultiValueMap parameters = new LinkedMultiValueMap();             parameters.add(""file"", createTempFile(data));              HttpHeaders headers = new HttpHeaders();             headers.setContentType(MediaType.MULTIPART_FORM_DATA);              return new HttpEntity(parameters, headers);         }          private FileSystemResource createTempFile(byte[] data) {             try {                 Path file = Files.createTempFile(""test"", "".txt"");                 Files.write(file, data);                 return new FileSystemResource(file);             } catch (IOException e) {                 throw new UncheckedIOException(e);             }         }     } } ```","open","in: web,","mjustin","2021-07-14T05:13:21Z","2021-11-08T11:46:11Z"
"","27490","Proxy generation with Java 17 fails with ""Cannot invoke ""Object.getClass()"" because ""cause"" is null""","When trying to start a filter that has the @Transactional annotation on it (either org.springframework.transaction.annotation.Transactional or javax.transaction.Transactional), Tomcat fails to start up with the `gradlew bootRun` command. Below is the smallest amount of code where the issue is reproducible.  It was working fine with Java 11 / gradle 7.0.2.  **Context** Java: OpenJDK Runtime Environment (build 17+35-2724) Gradlew: 7.2  **build.gradle** ``` plugins {     id 'org.springframework.boot' version '2.5.5'     id 'io.spring.dependency-management' version '1.0.11.RELEASE'     id 'java' } sourceCompatibility = '17' dependencies {     implementation 'org.springframework.boot:spring-boot-starter-data-jpa'     implementation 'org.springframework.boot:spring-boot-starter-web' } repositories {     mavenCentral() } ```  **MyApplication.java** ``` @SpringBootApplication public class MyApplication {   public static void main(String[] args) {     SpringApplication.run(MyApplication.class, args);   } }  @Transactional @Component class TransactionalFilter extends GenericFilter {   @Override   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)       throws IOException, ServletException {     chain.doFilter(request, response);   } } ```  Tomcat startup logs ``` 2021-09-28 23:50:07.665 <    |                                    > DEBUG [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Starting filters 2021-09-28 23:50:07.665 <    |                                    > DEBUG [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       :  Starting filter 'requestContextFilter' 2021-09-28 23:50:07.667 <    |                                    > DEBUG [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       :  Starting filter 'Tomcat WebSocket (JSR356) Filter' 2021-09-28 23:50:07.667 <    |                                    > DEBUG [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       :  Starting filter 'transactionalFilter' 2021-09-28 23:50:07.674 <    |                                    > ERROR [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Exception starting filter [transactionalFilter] java.lang.NullPointerException: Cannot invoke ""Object.getClass()"" because ""cause"" is null 	at org.springframework.cglib.core.CodeGenerationException.(CodeGenerationException.java:25) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:587) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.reflect.FastClass$Generator.create(FastClass.java:65) 	at org.springframework.cglib.proxy.MethodProxy.helper(MethodProxy.java:135) 	at org.springframework.cglib.proxy.MethodProxy.init(MethodProxy.java:76) 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:216) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) 	at com.myapp.TransactionalFilter$$EnhancerBySpringCGLIB$$f9892285.init() 	at org.apache.catalina.core.ApplicationFilterConfig.initFilter(ApplicationFilterConfig.java:270) 	at org.apache.catalina.core.ApplicationFilterConfig.(ApplicationFilterConfig.java:105) 	at org.apache.catalina.core.StandardContext.filterStart(StandardContext.java:4613) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5256) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:835) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:263) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:432) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:927) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.startup.Tomcat.start(Tomcat.java:486) 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:123) 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.(TomcatWebServer.java:104) 	at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:450) 	at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:199) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:182) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:160) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:577) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) 	at com.myapp.MyApplication.main(MyApplication.java:20) 2021-09-28 23:50:07.674 <    |                                    > DEBUG [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       :  Starting filter 'characterEncodingFilter' 2021-09-28 23:50:07.674 <    |                                    > DEBUG [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       :  Starting filter 'formContentFilter' 2021-09-28 23:50:07.674 <    |                                    > ERROR [           main] org.apache.catalina.core.StandardContext : One or more Filters failed to start. Full details will be found in the appropriate container log file 2021-09-28 23:50:07.674 <    |                                    > ERROR [           main] org.apache.catalina.core.StandardContext : Context [] startup failed due to previous errors ```  If the @Transactional annotation is removed from the filter, the filter is created successfully.","closed","in: core,","whydoievenneedthis","2021-09-28T22:18:26Z","2021-09-30T18:06:16Z"
"","27273","FileSystemResource range request is slow (linear time on file size)","When there is a range request, `FileSystemResource` will get an `InputStream` via `File.newInputStream(Path)`. This `InputStream` is provided by `FileSystemProvider.newInputStream()` which uses `Channels.newInputStream()`, creating a very basic `InputStream`.   The problem arise with `skip` function, which `Channels` provide a very basic `InputStream` that skips `n` bytes by reading `n` bytes into memory and throws it away, instead of using `SEEK` even though it is a file. This makes loading take more than 5000 ms when I try to request a range in the middle of a 3GB file.  I use this for a personal file server for video streaming, which when dealing with big files, there is a big latency the further I skip in the video.  I currently have a work around on my server where I extend the `FileSystemResource` and use `new FileInputStream()` in the overridden `getInputStream()` instead since its skip function is mapped to a native function using seek. This significantly reduces the latency, like sub-second latency vs 5000+ms previously.","closed","for: external-project,","khangp0000","2021-08-13T06:03:00Z","2021-09-24T10:48:17Z"
"","26910","UriComponentsBuilder when with port and query or fragment but no path","When there is a port, a query, or a fragment but there is no path in URI String, UriComponentsBuilder#fromUriString() will result in a bug.  Example:  - with `http://localhost:8080?foo=bar` URI, after running UriComponentsBuilder#fromUriString(), the port will be `8080?foo=bar`. - with `http://localhost:8080#foo` URI, after running UriComponentsBuilder#fromUriString(), the port will be `8080#foo`.  It seems that this change #26905 affected UriComponentsBuilder#fromUriString().","closed","status: duplicate,","nguyensach","2021-05-08T12:18:12Z","2021-05-18T11:21:33Z"
"","27199","`HtmlUnitRequestBuilder` ignores file uploaded via `HtmlFileInput.setData()`","When testing an application using HtmlUnit, its often useful to use `HtmlFileInput.setData(...)` instead of `HtmlFileInput.setFiles(...)` in order to not have to generate temporary files. However, when using `MockMvcWebClientBuilder`, this doesn't work. The problem is that `HtmlUnitRequestBuilder` ignores the data part.  #24926 added support for file uploads in `HtmlUnitRequestBuilder`, but missed this use case.  Test case:  filesubmit.html: ```html    File submission test    	File:  	Submit    ```  FileSubmitController.java: ```java @Controller public class FileSubmitController { 	@PostMapping(""/filesubmit"") 	public @ResponseBody String handleFileSubmit(@RequestParam(name = ""file"", required = false) MultipartFile file) { 		return file == null ? ""unset"" : file.getOriginalFilename(); 	} } ```  FileSubmitTest.java: ```java @WebMvcTest(FileSubmitController.class) public class FileSubmitTest { 	@Autowired 	WebClient webClient;  	@Test 	void testFileSubmitUsingFile() throws FailingHttpStatusCodeException, MalformedURLException, IOException { 		HtmlPage page = webClient.getPage(""/filesubmit.html""); 		HtmlFileInput file = page.querySelector(""input[type=file]""); 		file.setContentType(""application/json""); 		file.setFiles(new File(""src/test/resources/test.json"")); 		HtmlButton submit = page.querySelector(""button""); 		Page resultPage = submit.click(); 		// Succeeds 		assertEquals(""test.json"", resultPage.getWebResponse().getContentAsString()); 	}  	@Test 	void testFileSubmitUsingData() throws FailingHttpStatusCodeException, MalformedURLException, IOException { 		HtmlPage page = webClient.getPage(""/filesubmit.html""); 		HtmlFileInput file = page.querySelector(""input[type=file]""); 		file.setValueAttribute(""test.json""); 		file.setContentType(""application/json""); 		file.setData(""{}"".getBytes()); 		HtmlButton submit = page.querySelector(""button""); 		Page resultPage = submit.click(); 		// Fails with expected:  but was:  		assertEquals(""test.json"", resultPage.getWebResponse().getContentAsString()); 	} } ```  When starting the application normally and changing `WebClient` from a mocked version to a normal version using http://localhost:8080/ both tests succeed.  I'm guessing in `HtmlUnitRequestBuilder.params(...)`, the `else` part should be something like this: ```java 				else { // use data 					part = new MockPart(pair.getName(), pair.getValue(), pair.getData()); 					if (pair.getMimeType() == null) 						part.getHeaders().setContentType(MediaType.APPLICATION_OCTET_STREAM); 					else 						part.getHeaders().setContentType(MediaType.valueOf(pair.getMimeType())); 				} ```  I'm not sure if there is a specific edge case to use the old ""mimic empty file upload"" else case.  Tested using Spring Boot 2.5.2 using Spring WebMVC 5.3.8.","closed","type: bug,","svschouw-bb","2021-07-22T11:51:26Z","2021-08-27T15:39:17Z"
"","26991","R2DBC ConnectionFactory bean `.close()` method should be called/subscribed when available","When Spring Boot autoconfiguration instantiates `io.r2dbc.spi.ConnectionFactory` bean implementing `io.r2dbc.spi.Closeable`, the framework should have a custom destruction method invoke `Closeable.close()` and subscribe to the returned `Publisher`.  If a user application creates its own `ConnectionFactory`, it would be the user's responsibility to then close it. Although it might be nice to have a generic pre-destruction facility that looks for all R2DBC `Closeable` beans and closes them cleanly. The regular Spring bean destruction mechanism won't work here, since Spring Framework would call `.close()` but not subscribe to it, making it a no-op.  cc: @mp911de","open","type: enhancement,","elefeint","2021-05-27T03:01:50Z","2021-11-01T11:37:10Z"
"","26955","Blockhound error when running with transaction with a TransactionOperator","When running Blockhound on my project it detects this UUID generation as a blocking call. I am thinking that it should be updated and maybe you can set the creation of this class on a separate thread pool or fix the issue with generating the `id` of the `TransactionContext`.   https://github.com/spring-projects/spring-framework/blob/360f555e77bcb46d740151db447ffba0c6a09b51/spring-tx/src/main/java/org/springframework/transaction/reactive/TransactionContext.java#L43  This is the stack trace from Blockhound  ``` reactor.blockhound.BlockingOperationError: Blocking call! java.io.FileInputStream#readBytes 	at java.base/java.io.FileInputStream.readBytes(FileInputStream.java) 	at java.base/java.io.FileInputStream.read(FileInputStream.java:273) 	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:133) 	at java.base/sun.security.provider.NativePRNG$RandomIO.readFully(NativePRNG.java:424) 	at java.base/sun.security.provider.NativePRNG$RandomIO.ensureBufferValid(NativePRNG.java:526) 	at java.base/sun.security.provider.NativePRNG$RandomIO.implNextBytes(NativePRNG.java:545) 	at java.base/sun.security.provider.NativePRNG$NonBlocking.engineNextBytes(NativePRNG.java:318) 	at java.base/java.security.SecureRandom.nextBytes(SecureRandom.java:741) 	at java.base/java.util.UUID.randomUUID(UUID.java:150) 	at org.springframework.transaction.reactive.TransactionContext.(TransactionContext.java:43) 	at org.springframework.transaction.reactive.TransactionContext.(TransactionContext.java:60) 	at org.springframework.transaction.reactive.TransactionContextHolder.createContext(TransactionContextHolder.java:63) 	at org.springframework.transaction.reactive.TransactionContextManager.lambda$getOrCreateContext$2(TransactionContextManager.java:91) 	at reactor.core.publisher.MonoContextWrite.subscribeOrReturn(MonoContextWrite.java:38) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4135) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onError(ReactorContextTestExecutionListener.java:125) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:270) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:227) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:259) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.pool.SimpleDequePool$QueuePoolRecyclerInner.onComplete(SimpleDequePool.java:690) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.Operators.complete(Operators.java:136) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.pool.SimpleDequePool$QueuePoolRecyclerMono.subscribe(SimpleDequePool.java:802) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:259) 	at reactor.core.publisher.Operators.complete(Operators.java:136) 	at reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) 	at org.springframework.cloud.sleuth.instrument.reactor.SleuthMonoLift.subscribe(ReactorHooksHelper.java:225) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:88) 	at reactor.core.publisher.FluxHandleFuseable$HandleFuseableSubscriber.onNext(FluxHandleFuseable.java:201) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) 	at reactor.core.publisher.MonoSupplier.subscribe(MonoSupplier.java:61) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) 	at org.springframework.cloud.sleuth.instrument.reactor.SleuthMonoLift.subscribe(ReactorHooksHelper.java:225) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:162) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onSubscribe(MonoFlatMap.java:110) 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) 	at reactor.core.publisher.MonoDeferContextual.subscribe(MonoDeferContextual.java:55) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:88) 	at io.r2dbc.postgresql.util.FluxDiscardOnCancel$FluxDiscardOnCancelSubscriber.onComplete(FluxDiscardOnCancel.java:99) 	at reactor.core.publisher.Operators.complete(Operators.java:136) 	at reactor.core.publisher.FluxEmpty.subscribe(FluxEmpty.java:41) 	at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:54) 	at io.r2dbc.postgresql.util.FluxDiscardOnCancel.subscribe(FluxDiscardOnCancel.java:49) 	at reactor.core.publisher.MonoFromFluxOperator.subscribe(MonoFromFluxOperator.java:81) 	at org.springframework.cloud.sleuth.instrument.reactor.SleuthMonoLift.subscribe(ReactorHooksHelper.java:225) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) 	at org.springframework.cloud.sleuth.instrument.reactor.SleuthMonoLift.subscribe(ReactorHooksHelper.java:225) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) 	at org.springframework.cloud.sleuth.instrument.reactor.SleuthMonoLift.subscribe(ReactorHooksHelper.java:225) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:88) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:366) 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onComplete(FluxConcatMap.java:275) 	at reactor.core.publisher.Operators.complete(Operators.java:136) 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:147) 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) 	at reactor.core.publisher.MonoFromFluxOperator.subscribe(MonoFromFluxOperator.java:81) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.security.test.context.support.ReactorContextTestExecutionListener$DelegateTestExecutionListener$SecuritySubContext.onComplete(ReactorContextTestExecutionListener.java:130) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2057) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:259) 	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:88) 	at io.r2dbc.postgresql.util.FluxDiscardOnCancel$FluxDiscardOnCancelSubscriber.onComplete(FluxDiscardOnCancel.java:99) 	at io.r2dbc.postgresql.util.FluxDiscardOnCancel$FluxDiscardOnCancelSubscriber.onComplete(FluxDiscardOnCancel.java:99) 	at reactor.core.publisher.FluxHandle$HandleSubscriber.onComplete(FluxHandle.java:212) 	at reactor.core.publisher.FluxCreate$BaseSink.complete(FluxCreate.java:439) 	at reactor.core.publisher.FluxCreate$BufferAsyncSink.drain(FluxCreate.java:784) 	at reactor.core.publisher.FluxCreate$BufferAsyncSink.complete(FluxCreate.java:732) 	at reactor.core.publisher.FluxCreate$SerializedFluxSink.drainLoop(FluxCreate.java:240) 	at reactor.core.publisher.FluxCreate$SerializedFluxSink.drain(FluxCreate.java:206) 	at reactor.core.publisher.FluxCreate$SerializedFluxSink.complete(FluxCreate.java:197) 	at io.r2dbc.postgresql.client.ReactorNettyClient$Conversation.complete(ReactorNettyClient.java:719) 	at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.emit(ReactorNettyClient.java:984) 	at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.onNext(ReactorNettyClient.java:860) 	at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.onNext(ReactorNettyClient.java:767) 	at reactor.core.publisher.FluxHandle$HandleSubscriber.onNext(FluxHandle.java:118) 	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onNext(FluxPeekFuseable.java:854) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:220) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:220) 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:280) 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:389) 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:401) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:830) ```","closed","type: enhancement,","alexanderlindholm","2021-05-19T07:15:15Z","2021-07-09T13:08:04Z"
"","27684","AopProxyUtils#ultimateTargetClass doesn't work with @Lookup","When one bean with @Lookup, AopProxyUtils#ultimateTargetClass can't get real target class beacuse @Lookup proxy has not mark interface","open","in: core,","jliu666","2021-11-13T12:05:04Z","2021-11-24T19:58:19Z"
"","27240","Caching not backward-compatible","When migrating from Spring 3 to Spring 5, I have noticed that caching is not backward-compatible.   In Spring 3, it is possible to provide a null value as a cache key. In Spring 5, this causes the execution to break with an exception (Null key returned for cache operation (maybe you are using named params on classes without debug info?). Should caching not be backward compatible in this regard?","closed","status: invalid,","TheRealDragan","2021-08-04T10:02:51Z","2021-08-04T11:12:38Z"
"","27137","webflux  send http get request garbled","When I use webflux to send requests , If the request contains Chinese without URL encoding, it will be garbled. eg:       client  curl  info    :  ""curl http://localhost:8689/api/search/v1?query=北京&appkey=ABCD456F653E15B424C39FBCF9F7F081""      Server error info  :  ""org.springframework.http.server.reactive.ReactorHttpHandlerAdapter - Invalid URL for incoming request: Illegal character in query at index 43: http://localhost:8689/api/search/v1?query=åäº¬&appkey=ABCD456F653E15B424C39FBCF9F7F081""  How can I solve this problem?","closed","for: stackoverflow,","ai-chips","2021-07-06T10:35:02Z","2021-07-06T10:51:01Z"
"","26978","question","When I use RestTemplate in the main method to send HTTP requests, it prints a lot of debug logs. How do I turn off this log output","closed","for: stackoverflow,","WuJingLearn","2021-05-26T09:46:54Z","2021-05-26T10:29:06Z"
"","27604","Add support for custom expression parsing in CachedExpressionEvaluator","When I use CachedExpressionEvaluator, i need parseContext to influence an expression, so add ParseContext param","closed","type: enhancement,","Xjzon","2021-10-24T10:51:26Z","2021-10-28T12:25:54Z"
"","27866","Inconsistent overriding (and enforcement of non-overriding) between bean definition names and aliases","When I try to register two beans (one of aliases of the first bean corresponds to method name (= future id) of the second bean, the creation of second bean is ignored. The context starts without any exception.   ```java @Configuration public class MyConfiguration {      @Bean({""name1"", ""name2""})     public MyInterface myBean() {         return new MyFirstBean();     }      @Bean     public MyInterface name2() {         return new MySecondBean();     } } ```  `MyMap` in the following example contains only one bean, actually: `name1 -> MyFirstBean`  ```java     @Autowired     Map myMap; ```  I'm not sure if it is a bug or a feature. In my opinion [NoUniqueBeanDefinitionException](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/NoUniqueBeanDefinitionException.html) should be thrown in this case.  What do you think?","closed","in: core,","levitin","2021-12-29T16:19:18Z","2022-02-04T20:13:51Z"
"","27518","Connection prematurely closed BEFORE response when using Spring WebClient with Wiremock proxy","When getting a URL using Spring `WebClient` with `ReactorClientHttpConnector`, and using Wiremock as a proxy, it fails with `Connection prematurely closed BEFORE response`, see stack trace below.  The same setup works fine with other HTTP client libraries, at least with okhttp3.  Hopefully the example code included should be easy enough to understand. Wiremock is set up to enable proxying, all requests are set to return the string ""foo"" as text/plain.  When making a request with WebClient, the result is expected to be ""foo"", but it instead fails with the stack stack trace as shown below.  See example at the end, and also a runnable test in the Git repository here: https://github.com/vetler/spring-webclient-bug  This works fine with `JettyClientHttpConnector`, branch with passing test for that here: https://github.com/vetler/spring-webclient-bug/tree/test/jettyclienthttpconnector    ``` org.springframework.web.reactive.function.client.WebClientRequestException: Connection prematurely closed BEFORE response; nested exception is reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response  	at org.springframework.web.reactive.function.client.ExchangeFunctions$DefaultExchangeFunction.lambda$wrapException$9(ExchangeFunctions.java:141) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Request to GET http://example.com [DefaultWebClient] Stack trace: 		at org.springframework.web.reactive.function.client.ExchangeFunctions$DefaultExchangeFunction.lambda$wrapException$9(ExchangeFunctions.java:141) 		at reactor.core.publisher.MonoErrorSupplied.subscribe(MonoErrorSupplied.java:55) 		at reactor.core.publisher.Mono.subscribe(Mono.java:4361) 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onError(FluxPeek.java:222) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onError(FluxPeek.java:222) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onError(FluxPeek.java:222) 		at reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) 		at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onError(MonoFlatMapMany.java:204) 		at reactor.core.publisher.SerializedSubscriber.onError(SerializedSubscriber.java:124) 		at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.whenError(FluxRetryWhen.java:225) 		at reactor.core.publisher.FluxRetryWhen$RetryWhenOtherSubscriber.onError(FluxRetryWhen.java:274) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:414) 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onNext(FluxConcatMap.java:251) 		at reactor.core.publisher.EmitterProcessor.drain(EmitterProcessor.java:491) 		at reactor.core.publisher.EmitterProcessor.tryEmitNext(EmitterProcessor.java:299) 		at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100) 		at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27) 		at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:190) 		at reactor.core.publisher.MonoCreate$DefaultMonoSink.error(MonoCreate.java:189) 		at reactor.netty.http.client.HttpClientConnect$HttpObserver.onUncaughtException(HttpClientConnect.java:384) 		at reactor.netty.ReactorNetty$CompositeConnectionObserver.onUncaughtException(ReactorNetty.java:647) 		at reactor.netty.resources.DefaultPooledConnectionProvider$DisposableAcquire.onUncaughtException(DefaultPooledConnectionProvider.java:219) 		at reactor.netty.resources.DefaultPooledConnectionProvider$PooledConnection.onUncaughtException(DefaultPooledConnectionProvider.java:467) 		at reactor.netty.http.client.HttpClientOperations.onInboundClose(HttpClientOperations.java:289) 		at reactor.netty.channel.ChannelOperationsHandler.channelInactive(ChannelOperationsHandler.java:73) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelInactive(CombinedChannelDuplexHandler.java:418) 		at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:389) 		at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:354) 		at io.netty.handler.codec.http.HttpClientCodec$Decoder.channelInactive(HttpClientCodec.java:326) 		at io.netty.channel.CombinedChannelDuplexHandler.channelInactive(CombinedChannelDuplexHandler.java:221) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241) 		at io.netty.handler.proxy.ProxyHandler.channelInactive(ProxyHandler.java:230) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelInactive(CombinedChannelDuplexHandler.java:418) 		at io.netty.channel.CombinedChannelDuplexHandler.channelInactive(CombinedChannelDuplexHandler.java:223) 		at io.netty.handler.proxy.HttpProxyHandler$HttpClientCodecWrapper.channelInactive(HttpProxyHandler.java:267) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1405) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 		at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:901) 		at io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:831) 		at io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:164) 		at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java) 		at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469) 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497) 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.base/java.lang.Thread.run(Thread.java:829) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) 		at reactor.core.publisher.Mono.block(Mono.java:1706) 		at com.example.demo.DemoApplicationTests.contextLoads(DemoApplicationTests.java:37) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 		at java.base/java.lang.reflect.Method.invoke(Method.java:566) 		at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 		at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 		at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 		at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 		at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 		at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 		at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 		at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 		at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 		at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response  Disconnected from the target VM, address: '127.0.0.1:54721', transport: 'socket'  Process finished with exit code -1 ```  Here is a test to reproduce: ``` @SpringBootTest class DemoApplicationTests {     @RegisterExtension     WireMockExtension wm1 = WireMockExtension.newInstance()             .options(wireMockConfig().enableBrowserProxying(true).port(10001))             .build();      @Test     void contextLoads() {         wm1.stubFor(                 get(urlMatching("".*""))                         .willReturn(                                 aResponse()                                         .withHeader(""Content-Type"", ""text/plain"")                                         .withBody(""foo"")                         )         );          System.setProperty(""http.proxyHost"", ""localhost"");         System.setProperty(""http.proxyPort"", Integer.toString(wm1.getRuntimeInfo().getHttpPort()));          WebClient client = WebClient.builder().clientConnector(new ReactorClientHttpConnector(HttpClient.create().proxyWithSystemProperties())).build();         String result = client.get().uri(""http://example.com"").retrieve().bodyToMono(String.class).block();          assertEquals(""foo"", result);     }  } ```","closed","","vetler","2021-10-04T11:11:13Z","2021-11-23T07:26:50Z"
"","27732","MockMvc incorrectly lists CORS request headers in response","When constructing a test for CORS in MockMvc, and allowing output to be printed, the printed representation of the `MockHttpServletResponse` incorrectly contains entries for `Access-Control-Request-Method` and `Access-Control-Request-Headers`. These headers are request headers and are printed here no matter if we include them in the input request or not. Below is the printout from an `OPTIONS` request with `Origin` and `Access-Control-Request-Method` headers only set.      MockHttpServletResponse:         Status = 200         Error message = null         Headers = [Vary:""Origin"", ""Access-Control-Request-Method"", ""Access-Control-Request-Headers"", Access-Control-Allow-Origin:""http://localhost:3000"", Access-Control-Allow-Methods:""GET,PUT,POST,PATCH,HEAD,OPTIONS,DELETE"", Access-Control-Allow-Credentials:""true"", Access-Control-Max-Age:""1800"", X-Content-Type-Options:""nosniff"", X-XSS-Protection:""1; mode=block"", Cache-Control:""no-cache, no-store, max-age=0, must-revalidate"", Pragma:""no-cache"", Expires:""0"", X-Frame-Options:""DENY""]         Content type = null         Body =   However, these headers are not included in the final result because if we add to the test      ...     .andExpect(MockMvcResultMatchers.header().doesNotExist(""Access-Control-Request-Method""))     .andExpect(MockMvcResultMatchers.header().doesNotExist(""Access-Control-Request-Headers""))  ... it still passes. Nonetheless, it is confusing that these headers are listed in the printout. TO be clear, these headers should not be listed there (no matter if they're included in the request or not).  Behaviour verified on Spring Boot 2.6.0 with      mvc.perform(         MockMvcRequestBuilders             .options()             .header(""Access-Control-Request-Method"", ""GET"")             .header(""Origin"", )     )","closed","status: invalid,","fast-reflexes","2021-11-25T07:58:49Z","2021-11-29T12:25:46Z"
"","27507","Error calling /info with Sping Boot 2.5.4","When calling /info you have this error: org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class java.time.Instant]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Java 8 date/time type `java.time.Instant` not supported by default: add Module ""com.fasterxml.jackson.datatype:jackson-datatype-jsr310"" to enable handling (through reference chain: java.util.Collections$UnmodifiableMap[""build""]->java.util.LinkedHashMap[""time""]) at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.writeInternal(AbstractJackson2HttpMessageConverter.java:460) at org.springframework.http.converter.AbstractGenericHttpMessageConverter.write(AbstractGenericHttpMessageConverter.java:104) at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:290) at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:183) at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:78) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:124) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) at","closed","status: invalid,","7--","2021-10-01T14:45:52Z","2021-10-01T15:58:09Z"
"","27180","Tests hanging when adding mockito-inline dependency","When adding the `org.mockito:mockito-inline` dependency to the project some tests get stuck.  It happens when we run a single test class, via IDE or CLI, and we have a `static` variable inside an inner class, like so:  ```java public class MyClassTestApplicationContext {     @Test    public void dontStuck() {       GenericBeanDefinition beanDefinition = new GenericBeanDefinition();       beanDefinition.setBeanClass(StuckConfig.myOtherClass.getClass());       beanDefinition.setSource(StuckConfig.myOtherClass);       GenericApplicationContext context = new GenericApplicationContext();       context.registerBeanDefinition(""myOtherClass"", beanDefinition);       context.refresh();    }     @Test    public void dontStuckAlso() {       AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();       context.register(DontStuckConfig.class);       context.refresh();       context.getBean(MyOtherClass.class);    }     @Test    public void stuck() {       AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();       context.register(StuckConfig.class);       context.refresh();    }     @Configuration    public static class StuckConfig {        private static final MyOtherClass myOtherClass = Mockito.mock(MyOtherClass.class);        @Bean       public MyOtherClass myOtherClass() {          return myOtherClass;       }    }     @Configuration    public static class DontStuckConfig {        private final MyOtherClass myOtherClass = Mockito.mock(MyOtherClass.class);        @Bean       public MyOtherClass myOtherClass() {          return myOtherClass;       }    }  } ```  **How to reproduce:** Run the `MyClassTestApplicationContext` tests in the sample. You can make it work by doing one of the following:  - Remove the `mockito-inline` dependency;  - Remove the `static` modifier from the mock  - Mock an arbitrary object inside the parent class, like so: ```java public class MyClassTestApplicationContext {     private static final Object obj = Mockito.mock(Object.class);     //... remaining code ```  **Sample:** https://github.com/marcusdacoregio/mockito-inline-stuck-bug There's a minimum setup in the sample to simulate the behavior on the `MyClassTestApplicationContext`.  **Additional information:** I could see that the Thread gets stuck at [this part of the ByteBuddyAgent](https://github.com/raphw/byte-buddy/blob/5d15c52af1c820e34c256ad0b47bc5dd456c5696/byte-buddy-agent/src/main/java/net/bytebuddy/agent/ByteBuddyAgent.java#L687-L697). I first found this problem when running a [test class](https://github.com/spring-projects/spring-security/blob/main/config/src/test/java/org/springframework/security/config/annotation/web/configurers/saml2/Saml2LoginConfigurerTests.java) in the Spring Security project, which worked before [this change](https://github.com/spring-projects/spring-security/commit/14240b25597c9301d03dfabd480911a166977fdb#diff-5d66140e85ec0c0a94831758e4c49b8a36421c527e8ea21cd100a96b34633ba6R69).  **Affects:** 5.3.8  ---","closed","for: external-project,","marcusdacoregio","2021-07-15T15:30:04Z","2021-07-19T13:03:10Z"
"","27731","Proxy causes IllegalAccessException","When a proxy bean (e.g., the child) is passed to another bean (e.g., the parent), and that bean tries to call a method inherited from Java Object (e.g. toString) we get an IllegalAccessException. The bean may be proxied because, for example, it has @Transactional methods. This begun, I believe, when we upgraded Spring from 5.3.1 to 5.3.8, although I can’t be sure of this. We are currently using Spring 5.3.8 on Java 11.  In my case, overriding the toString method resolved the issue. This was very time consuming to track down, however. It would be nice if Spring could handle this better.  The following is debug output when run with --illegal-access=deny option.  ``` 12:06:24.070 [main] DEBUG org.springframework.test.context.junit4.SpringJUnit4ClassRunner - SpringJUnit4ClassRunner constructor called with [class SpringIssueTest] 12:06:24.077 [main] DEBUG org.springframework.test.context.BootstrapUtils - Instantiating CacheAwareContextLoaderDelegate from class [org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate] 12:06:24.093 [main] DEBUG org.springframework.test.context.BootstrapUtils - Instantiating BootstrapContext using constructor [public org.springframework.test.context.support.DefaultBootstrapContext(java.lang.Class,org.springframework.test.context.CacheAwareContextLoaderDelegate)] 12:06:24.134 [main] DEBUG org.springframework.test.context.BootstrapUtils - Instantiating TestContextBootstrapper for test class [SpringIssueTest] from class [org.springframework.test.context.support.DefaultTestContextBootstrapper] 12:06:24.171 [main] DEBUG org.springframework.test.context.support.AbstractDelegatingSmartContextLoader - Delegating to AnnotationConfigContextLoader to process context configuration [ContextConfigurationAttributes@303cf2ba declaringClass = 'SpringIssueTest', classes = '{class TestConfiguration}', locations = '{}', inheritLocations = true, initializers = '{}', inheritInitializers = true, name = [null], contextLoaderClass = 'org.springframework.test.context.ContextLoader']. 12:06:24.252 [main] DEBUG org.springframework.test.context.support.ActiveProfilesUtils - Could not find an 'annotation declaring class' for annotation type [org.springframework.test.context.ActiveProfiles] and class [SpringIssueTest] 12:06:24.252 [main] DEBUG org.springframework.test.context.support.DefaultTestContextBootstrapper - @TestExecutionListeners is not present for class [SpringIssueTest]: using defaults. 12:06:24.253 [main] INFO org.springframework.test.context.support.DefaultTestContextBootstrapper - Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener, org.springframework.test.context.event.ApplicationEventsTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener, org.springframework.test.context.event.EventPublishingTestExecutionListener, org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener, org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener, org.springframework.boot.test.autoconfigure.restdocs.RestDocsTestExecutionListener, org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcPrintOnlyOnFailureTestExecutionListener, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverTestExecutionListener, org.springframework.boot.test.autoconfigure.webservices.client.MockWebServiceServerTestExecutionListener] 12:06:24.283 [main] INFO org.springframework.test.context.support.DefaultTestContextBootstrapper - Using TestExecutionListeners: [org.springframework.test.context.web.ServletTestExecutionListener@407a7f2a, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@4ea5b703, org.springframework.test.context.event.ApplicationEventsTestExecutionListener@2a7ed1f, org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener@3fa247d1, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@2cb2fc20, org.springframework.test.context.support.DirtiesContextTestExecutionListener@4f4c4b1a, org.springframework.test.context.transaction.TransactionalTestExecutionListener@723e88f9, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener@5f0fd5a0, org.springframework.test.context.event.EventPublishingTestExecutionListener@64e7619d, org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener@495ee280, org.springframework.boot.test.autoconfigure.restdocs.RestDocsTestExecutionListener@4fa1c212, org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener@6ea2bc93, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcPrintOnlyOnFailureTestExecutionListener@3116c353, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverTestExecutionListener@f627d13, org.springframework.boot.test.autoconfigure.webservices.client.MockWebServiceServerTestExecutionListener@4e928fbf] 12:06:24.286 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.287 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.291 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.292 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.297 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.297 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.421 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.421 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.424 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.424 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.425 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.426 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.432 [main] DEBUG org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener - Before test class: context [DefaultTestContext@38234a38 testClass = SpringIssueTest, testInstance = [null], testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63fbfaeb testClass = SpringIssueTest, locations = '{}', classes = '{class TestConfiguration}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@169bb4dd, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@d23e042, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@1e16c0aa, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@7068e664], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null]. 12:06:24.435 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved @ProfileValueSourceConfiguration [null] for test class [SpringIssueTest] 12:06:24.435 [main] DEBUG org.springframework.test.annotation.ProfileValueUtils - Retrieved ProfileValueSource type [class org.springframework.test.annotation.SystemProfileValueSource] for class [SpringIssueTest] 12:06:24.445 [main] DEBUG org.springframework.test.context.support.DependencyInjectionTestExecutionListener - Performing dependency injection for test context [[DefaultTestContext@38234a38 testClass = SpringIssueTest, testInstance = SpringIssueTest@38aa816f, testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63fbfaeb testClass = SpringIssueTest, locations = '{}', classes = '{class TestConfiguration}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@169bb4dd, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@d23e042, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@1e16c0aa, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@7068e664], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]]. 12:06:24.446 [main] DEBUG org.springframework.test.context.support.AbstractDelegatingSmartContextLoader - Delegating to AnnotationConfigContextLoader to load context from [MergedContextConfiguration@63fbfaeb testClass = SpringIssueTest, locations = '{}', classes = '{class TestConfiguration}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@169bb4dd, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@d23e042, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@1e16c0aa, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@7068e664], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]]. 12:06:24.446 [main] DEBUG org.springframework.test.context.support.AbstractGenericContextLoader - Loading ApplicationContext for merged context configuration [[MergedContextConfiguration@63fbfaeb testClass = SpringIssueTest, locations = '{}', classes = '{class TestConfiguration}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@169bb4dd, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@d23e042, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@1e16c0aa, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@7068e664], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]]]. 12:06:24.545 [main] DEBUG org.springframework.core.env.StandardEnvironment - Activating profiles [] 12:06:24.545 [main] DEBUG org.springframework.test.context.support.AnnotationConfigContextLoader - Registering component classes: {class TestConfiguration} 12:06:24.619 [main] DEBUG org.springframework.context.support.GenericApplicationContext - Refreshing org.springframework.context.support.GenericApplicationContext@41709512 12:06:24.640 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor' 12:06:24.840 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.boot.test.mock.mockito.MockitoPostProcessor' 12:06:24.860 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor' 12:06:24.861 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory' 12:06:24.862 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory' 12:06:24.863 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor' 12:06:24.866 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor' 12:06:24.873 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor' 12:06:24.873 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.boot.test.mock.mockito.MockitoPostProcessor$SpyPostProcessor' 12:06:24.875 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator' 12:06:24.951 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'testConfiguration' 12:06:24.962 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor' 12:06:24.962 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' 12:06:24.981 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'transactionAttributeSource' 12:06:24.993 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'transactionInterceptor' 12:06:24.993 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Autowiring by type from bean name 'transactionInterceptor' via factory method to bean named 'transactionAttributeSource' 12:06:25.016 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Autowiring by type from bean name 'org.springframework.transaction.config.internalTransactionAdvisor' via factory method to bean named 'transactionAttributeSource' 12:06:25.016 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Autowiring by type from bean name 'org.springframework.transaction.config.internalTransactionAdvisor' via factory method to bean named 'transactionInterceptor' 12:06:25.038 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'parentBean' 12:06:25.039 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'childBean' 12:06:25.086 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Autowiring by type from bean name 'parentBean' via factory method to bean named 'childBean' 12:06:25.092 [main] WARN org.springframework.context.support.GenericApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'parentBean' defined in TestConfiguration: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [Parent]: Factory method 'parentBean' threw exception; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalAccessException-->module java.base does not open java.lang to unnamed module @7e8e8651 12:06:25.099 [main] ERROR org.springframework.test.context.TestContextManager - Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@2cb2fc20] to prepare test instance [SpringIssueTest@38aa816f] java.lang.IllegalStateException: Failed to load ApplicationContext 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) 	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:118) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) 	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329) 	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293) 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:413) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:115) 	at org.junit.vintage.engine.execution.RunnerExecutor.execute(RunnerExecutor.java:43) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) 	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150) 	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497) 	at org.junit.vintage.engine.VintageTestEngine.executeAllChildren(VintageTestEngine.java:82) 	at org.junit.vintage.engine.VintageTestEngine.execute(VintageTestEngine.java:73) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:84) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:770) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'parentBean' defined in TestConfiguration: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [Parent]: Factory method 'parentBean' threw exception; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalAccessException-->module java.base does not open java.lang to unnamed module @7e8e8651 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:658) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:638) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1334) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:127) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:275) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:243) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) 	... 48 common frames omitted Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [Parent]: Factory method 'parentBean' threw exception; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalAccessException-->module java.base does not open java.lang to unnamed module @7e8e8651 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) 	... 66 common frames omitted Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalAccessException-->module java.base does not open java.lang to unnamed module @7e8e8651 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:578) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.reflect.FastClass$Generator.create(FastClass.java:65) 	at org.springframework.cglib.proxy.MethodProxy.helper(MethodProxy.java:135) 	at org.springframework.cglib.proxy.MethodProxy.init(MethodProxy.java:76) 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:216) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) 	at Child$$EnhancerBySpringCGLIB$$dfa60f8b.toString() 	at java.base/java.lang.String.valueOf(String.java:2951) 	at java.base/java.lang.StringBuilder.append(StringBuilder.java:168) 	at Parent.(SpringIssueTest.java:31) 	at TestConfiguration.parentBean(SpringIssueTest.java:82) 	at TestConfiguration$$EnhancerBySpringCGLIB$$8928787.CGLIB$parentBean$0() 	at TestConfiguration$$EnhancerBySpringCGLIB$$8928787$$FastClassBySpringCGLIB$$7cf3a51a.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) 	at TestConfiguration$$EnhancerBySpringCGLIB$$8928787.parentBean() 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) 	... 67 common frames omitted Caused by: java.lang.IllegalAccessException: module java.base does not open java.lang to unnamed module @7e8e8651 	at java.base/java.lang.invoke.MethodHandles.privateLookupIn(MethodHandles.java:202) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:574) 	... 96 common frames omitted 12:06:25.113 [main] DEBUG org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener - After test class: context [DefaultTestContext@38234a38 testClass = SpringIssueTest, testInstance = [null], testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63fbfaeb testClass = SpringIssueTest, locations = '{}', classes = '{class TestConfiguration}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@169bb4dd, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@d23e042, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@1e16c0aa, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@7068e664], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]], class annotated with @DirtiesContext [false] with mode [null]. ```  Here is the code that generated the above:  ``` import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.transaction.annotation.EnableTransactionManagement; import org.springframework.transaction.annotation.Transactional;  /*  * Bean classes  */  /**  * The parent class containing the transactional child. Receives a proxy.  */ class Parent {     /**     * Constructor called with proxy.     *      * @param child     */    public Parent(Child child)    {       System.out.println(""SR="" + child);    } }  /**  * Transactional child class  */ @Transactional class Child {     private String element1;     public Child(String one)    {       element1 = one;    }     /**     * @Transactional annotation causes class to be created as proxy.     *      * @return     */    @Transactional    public String getElement1()    {       return element1;    }        /**     * If we override toString the test does not exhibit the issue     * (although it does fail due to a lack of transaction manager).     */ //   @Override //   public String toString() //   { //      return ""Child""; //   } }  /**  * Create the beans. Must enable transaction management.  */ @Configuration @EnableTransactionManagement(proxyTargetClass = true) class TestConfiguration {     @Bean    public Parent parentBean(Child child)    {       Parent bean = new Parent(child);        return bean;    }     @Bean    public Child childBean()    {       return new Child(""Some Text"");    } }  /**  * The actual test class.  */ @RunWith(SpringRunner.class) @ContextConfiguration(classes = {TestConfiguration.class}) public class SpringIssueTest {     @Autowired    ApplicationContext applicationContext;     /**     * Just need to get the parent bean to trigger the issue.     */    @Test    public void testContextCreated()    {       applicationContext.getBean(Parent.class);    } } ```","closed","in: core,","toddfroyland","2021-11-24T20:28:22Z","2022-02-18T19:05:43Z"
"","27086","spring-webflux: ServerRequestWrapper is not passed on from RouterFunctionDsl filter function","When a filter function creates a ServerRequestWrapper from the ServerRequest passed to it, and passes the wrapper into the next() function, then the RouterFunctionDsl passes on the original ServerRequest, not the wrapper. This PR fixes the issue and verifies with a test.","open","in: web,","ijonathanc","2021-06-21T10:52:45Z","2021-11-08T11:37:35Z"
"","27830","Improve tests and Javadoc on binding to a property of type javax.servlet.Part","When a controller obtains files from multipart requests, there is an inconsistency when `jakarta.servlet.http.Part` type is an attribute of an object or an argument of a handler method.  If a method has an object argument, and expects files to be saved to attributes of that argument, the attribute type should not be `Part`, but it would rather be `MultipartFile`.  This is because `StandardMultipartHttpServletRequest` wraps its `Part`s, whose filename exists, with `StandardMultipartFile`. `StandardMultipartFile` is an private class that implements `MultipartFile` class. So `Part` type attributes generate conversion errors.  In contrast, if the method has an argument type of `Part`, it can normally receive multipart files from the framework.  My idea is simply modifying `StandardMultipartFile` class to implement both `MultipartFile` and `Part`, so preventing conversion issues. Likewise I added new `MockStandardMultipartFile` class that replaces `MockMultipartFile` class.   **Issues:** https://github.com/spring-projects/spring-framework/issues/27819","closed","type: enhancement,","binchoo","2021-12-17T07:50:28Z","2022-04-28T13:45:51Z"
"","27249","Add ability to rollback before close on SingleConnectionDataSource","We use `SingleConnectionDataSource` with the Oracle driver for integration tests. Although we use the Spring TestContext Framework this sometimes results in commits when we abort tests. We believe this is due to the shutdown hook registered in `AbstractApplicationContext#registerShutdownHook()` ending up calling `SingleConnectionDataSource#destroy()` which calls `Connection#close()`. Calling `Connection#close()` with an open transaction results in the Oracle driver committing.  This behavior is documented in [several](https://in.relation.to/2005/10/20/pop-quiz-does-connectionclose-result-in-commit-or-rollback/) [places](https://stackoverflow.com/questions/218350/does-java-connection-close-rollback) and even mentioned in the official documentation.  https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/JDBC-getting-started.html#GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9  > If the auto-commit mode is disabled and you close the connection without explicitly committing or rolling back your last changes, then an implicit COMMIT operation is run.   Calling `Connection#close()` with an open transaction is not recommended and results in unspecified behavior according to the JDBC specification:  https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Connection.html#close()  > It is **strongly recommended** that an application explicitly commits or rolls back an active transaction prior to calling the close method. If the close method is called and there is an active transaction, the results are implementation-defined.   We would welcome a property, for example named `rollbackBeforeClose` that behaves something like the following. Maybe with an additional `try-catch` around `Connection#rollback()`. An alternative would be to always try to rollback when auto commit is disabled to follow the JDBC reccomendation, however we don't know what the side effects of this would be.  ```java 	private void closeConnection() { 		if (this.target != null) { 			try { 				if (this.rollbackBeforeClose && !this.target.getAutoCommit()) { 					this.target.rollback(); 				} 				this.target.close(); 			} 			catch (Throwable ex) { 				logger.info(""Could not close shared JDBC Connection"", ex); 			} 		} 	} ```  We would be willing to work on a PR.","open","in: data,","marschall","2021-08-08T17:47:21Z","2021-11-10T11:38:12Z"
"","27580","Revisit MediaType ordering","We should reconsider the way we order `MediaType` objects. Currently we use `Comparator`s to sort media types in order of preference, but those need to be transitive (see #27488). We should investigate other ordering mechanisms for 6.0, possibly dropping the comparators altogether in favor of a less restrictive, though possibly slower, ordering algorithm.","closed","type: enhancement,","poutsma","2021-10-19T09:49:10Z","2021-11-23T10:54:00Z"
"","27528","The name of @RestController-annotated classes starting with a / is exposed as a servlet path","We have two classes annotated with [@RestController](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html) and with the same name in different packages. Since by default the bean name is the class name this generates an issue when booting the application. For this reason, we give a custom name to each class via `@RestController`'s `value` field. However, it appears that when the bean name starts with a `/` Spring tries to exposes that name as a servlet path.  Here's an example (I've also attached a .zip with the entire code):  ```java package com.example.demo.namespace1;  @RestController(""/potato"") @RequestMapping(""/namespace1/demo"") public class DemoController {     @GetMapping     public String handler() {         return ""/namespace1/demo"";     } } ```  ```java package com.example.demo.namespace2;  @RestController(""/tomato"") @RequestMapping(""/namespace2/demo"") public class DemoController {     @GetMapping     public String handler() {         return ""/namespace2/demo"";     } } ```  The following requests result in:  - `GET http://localhost:8080/namespace1/demo` -> 200 - `GET http://localhost:8080/namespace2/stuff` -> 404 - `GET http://localhost:8080/potato` -> 500   Stack trace:  ``` 2021-10-07 09:41:20.541 ERROR 2749 --- [nio-8080-exec-3] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [No adapter for handler [com.example.demo.namespace1.DemoController@7e2e9e87]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler] with root cause  javax.servlet.ServletException: No adapter for handler [com.example.demo.namespace1.DemoController@7e2e9e87]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler 	at org.springframework.web.servlet.DispatcherServlet.getHandlerAdapter(DispatcherServlet.java:1302) ~[spring-webmvc-5.3.10.jar:5.3.10] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1050) ~[spring-webmvc-5.3.10.jar:5.3.10] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.10.jar:5.3.10] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.10.jar:5.3.10] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.10.jar:5.3.10] ```  It appears that when the bean name starts with a `/` that name tries to be exposed as a servlet path but since there's no handler for that path the request results in an error. This looks suspicious as the behaviour of the application is different depending on the names of the beans.  I was trying to understand if this behaviour is expected but haven't found any mention to this in the documentation so far.  (This might be a Spring issue and not Spring Boot so apologies if opening in the wrong tracker.)  [demo.zip](https://github.com/spring-projects/spring-boot/files/7299927/demo.zip)","closed","status: invalid,","joca-bt","2021-10-07T07:55:23Z","2021-10-08T18:17:19Z"
"","27326","Support for custom status code and message in HTTP response","We are using spring boot backend service and require to publish custom status code and status message in response. As per current spec spring supports sending custom status code in ResponseEntity's builder ResponseEntity.status(int statusCode) but doesn't have a mechanism to send custom status message along with it.  Sending the code and status message in the response body isn't an option for our use case.","closed","status: declined,","balaji-itorix","2021-08-26T13:43:04Z","2021-09-03T15:56:06Z"
"","27021","Any replacement for locatorFactorySelector in Spring 5.3.7","We are using Spring 4.3.5 in our application. While we try to uplift the Spring to 5.3.7, we are not able to initialize beans(inside ""beanRefFactory.xml"") inside the below tag-  ```          locatorFactorySelector         /beanRefFactory.xml       ``` Upon searching we found that ""locatorFactorySelector"" or ""LOCATOR_FACTORY_KEY_PARAM"" have been deprecated in Spring 5.0.0.M5. Details can be found [here](https://docs.spring.io/spring-framework/docs/5.0.0.M4_to_5.0.0.M5/).  Kindly suggest if there is any other way to initialize ""beanRefFactory.xml"". **We are using XML based configuration**.  PS: have already gone through the [answers](https://stackoverflow.com/questions/54085902/sharing-parent-spring-context-with-child-in-spring-5), but no help.","closed","","Staticsubh","2021-06-04T05:11:41Z","2022-02-18T19:05:42Z"
"","27653","When using HandshakeInterceptor with ServerHttpAsyncRequestControl, Jetty10RequestUpgradeStrategy throws exception due to null servletContext","We are upgrading our project from Jetty v9 to v10 and have encountered a problem with the new spring-boot Jetty implementation.  Our WebSocketController includes a custom HandshakeInterceptor.  In the beforeHandshake() method, we use this line: ```         ServerHttpAsyncRequestControl requestControl = request.getAsyncRequestControl(response);         requestControl.start(); ``` so that we can authorize the request before completing it.  We do that authorization in a separate thread and then call DefaultHandshakeHandler to complete the handshake: ```         handshakeHandler.doHandshake(request, response, wsHandler, attributes);         requestControl.complete(); ``` while the beforeHandshake method exits on the main thread.  This worked fine with Jetty v9 (which is implemented in spring-boot via the class `org.springframework.web.socket.server.jetty.JettyRequestUpgradeStrategy`).  However, with Jetty v10 (which uses a new class: `org.springframework.web.socket.server.jetty.Jetty10RequestUpgradeStrategy`), there is a NullPointerException.  This is because Jetty10RequestUpgradeStrategy uses reflection to invoke `JettyWebSocketServerContainer getContainer(ServletContext servletContext)` which tries to resolve an attribute from the request's servletContext -- **but servletContext has now been cleared out** as we have exited the beforeHandshake() method on the main thread.  I confirmed this by adding a Thread.sleep() to our beforeHandshake() method to delay it from returning for a couple of seconds, and this allowed the thread with DefaultHandshakeHandler to complete.  Without this delay, we catch this error and the handshake does not complete: `    org.springframework.web.socket.server.HandshakeFailureException: Failed to upgrade; nested exception is java.lang.NullPointerException`  Versions used: spring.boot = 2.5.6 jetty.version = 10.0.6 spring.framework = 5.3.12","closed","in: web,","ajr3-gen","2021-11-03T14:45:18Z","2022-04-11T10:56:46Z"
"","27150","org.hibernate.AnnotationException: Use of @OneToMany or @ManyToMany targeting an unmapped class: com.gehcit.cp.chart.data.DocumentData.documentContributionDetail[com.gehcit.cp.chart.data.DocumentContributionData","We are in process of upgrading Spring from 4.3.5 to 5.3.8. While doing so we are getting the following exception.  org.hibernate.AnnotationException: Use of @OneToMany or @ManyToMany targeting an unmapped class: com.gehcit.cp.chart.data.DocumentData.documentContributionDetail[com.gehcit.cp.chart.data.DocumentContributionData  The problem we are facing is the property ""packageToScan"" is not behaving expectedly. It does not pick up any entity files in the mentioned packages. However, if we add the same set of files in the property ""annotatedClasses"", it works fine.  I am attaching the server logs with TRACE and DEBUG enabled. the configuration file as well. [context-infrastructure-persistence.zip](https://github.com/spring-projects/spring-framework/files/6791341/context-infrastructure-persistence.zip) [server.txt](https://github.com/spring-projects/spring-framework/files/6791366/server.txt) [server (2).txt](https://github.com/spring-projects/spring-framework/files/6791368/server.2.txt)","closed","for: stackoverflow,","Staticsubh","2021-07-09T12:43:12Z","2021-07-27T08:07:50Z"
"","27668","@Primary with Cyclic DI","Version: spring-boot-2.5.6  Code:  ```java public interface LoopService {  	void testLoop(); 	 	void testInnerLoop(); } ```  ```java @Service public class DefaultLoopService implements LoopService {  	private static final Logger log = LoggerFactory.getLogger(DefaultLoopService.class); 	 	@Autowired 	private LoopService loopService;  	@Override 	public void testLoop() { 		log.info(""DefaultLoopService""); 	}  	@Override 	public void testInnerLoop() { 		log.info(""DefaultLoopService--testInnerLoop""); 	}  } ```  ```java @Service @Primary public class UsingLoopService implements LoopService {  	private static final Logger log = LoggerFactory.getLogger(UsingLoopService.class); 	 	@Autowired 	private LoopService loopService; 	 	@Override 	public void testLoop() { 		log.info(""UsingLoopService""); 		loopService.testInnerLoop(); 	}  	@Override 	public void testInnerLoop() { 		log.info(""UsingLoopService--testInnerLoop""); 	} } ```  ```java @RestController public class LoopController { 	 	@Autowired 	private LoopService loopService;  	@GetMapping(""/testLoop"") 	public void testLoop() { 		loopService.testLoop(); 	} } ```  Expect Print:  ``` service.impl.UsingLoopService : UsingLoopService service.impl.UsingLoopService : UsingLoopService--testInnerLoop ```  But Actual Print:  ``` service.impl.UsingLoopService : UsingLoopService service.impl.DefaultLoopService : DefaultLoopService--testInnerLoop ```","open","in: core,","daodefengshang","2021-11-10T13:51:28Z","2021-11-21T12:35:14Z"
"","27820","Dead loop init when InitializingBean failed","version: 5.3.8 problem/bug: when throw exception with implement InitializingBean, spring always init beans, include failed bean, dead loop.  Be attention, my project have loop dependency bean.  I debug, and track stack trace, I found the problem maybe as follows:  https://github.com/spring-projects/spring-framework/blob/9dc5c9f935dd913440d4e0765952d85288d35a5c/spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionValueResolver.java#L335 shouldn't renew BeanCreationException when it's UnsatisfiedDependencyException, otherwise cause:  https://github.com/spring-projects/spring-framework/blob/9dc5c9f935dd913440d4e0765952d85288d35a5c/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java#L1012 will ignore the BeanCreationException and swallow it","closed","in: core,","hebelala","2021-12-16T04:11:58Z","2022-01-20T12:22:56Z"
"","27244","Use flux to response garbled code","Version about spring-boot 2.5.1. Do I have a problem learning how to use webFlux:  I use Flux.fromStream() to get datas, datas garbled. I try to set produces = ""text/event-stream;charset=UTF-8"", but useless. My code on this pictures: ![image](https://user-images.githubusercontent.com/33596244/128288885-c9c785ef-3917-407c-b344-bf0c96d5a7e7.png)","closed","for: stackoverflow,","free-leung","2021-08-05T04:02:11Z","2021-08-05T06:32:42Z"
"","27529","Both @Async and @Around doesn't work concurrently","version : spring-boot-starter 2.1.3  I am using @Async annotation like this. `@Async(""executorBean"")     public CompletableFuture callApi() {    .... }`   and tracking it with my logging aspect  `@Pointcut(""execution(* *.callApi(..))"")     public void callApiPointCut() {     }`  `@After(""callApiPointCut()"")    public void callCountApiLogger(JoinPoint joinPoint){    }`  It works pretty well :)  =================================================   But if I changed an AOP advice to @Around, it doesn't work. `@Around(""callApiPointCut()"")     public void callCountApiLogger(ProceedingJoinPoint pjp){         pjp.proceed();     }`   There are screenshots of my debugging console.  @After    @Around    I think the reason why it doesn't work is @Around needs to call proceed() manually.  Does anyone else have the same issue as me?","closed","for: stackoverflow,","ggthename","2021-10-07T08:35:18Z","2021-10-07T12:00:04Z"
"","27678","Update aspectj-plugin to 6.3.0","Version 6.3.0 aligns with the used Gradle 7.3","closed","type: task,","larsgrefer","2021-11-11T22:51:08Z","2021-11-25T21:20:14Z"
"","27834","Use String.repeat() and pattern matching instanceof","Using various new features from Java 9-17 such as `String.repeat()` and pattern matching instanceof.","closed","type: task,","AbstractCoderX","2021-12-17T18:33:34Z","2022-02-07T17:53:44Z"
"","27191","@TransactionalEventListener with AFTER_COMMIT called on AFTER_COMPLETION","Using Spring Boot 2.4.5 / Spring Framework 5.3.6.  I have a `@TransactionalEventListener` and a more old-fashioned `TransactionSynchronization`. I want to execute both after transaction commits, and the order matters.  Here is a sample test.  ```java @SpringBootTest @AutoConfigureTestDatabase @EnableTransactionManagement @ImportAutoConfiguration(DataSourceTransactionManagerAutoConfiguration.class) class PostTxTest {      @Configuration     static class Config {         @Bean         SampleRepository sampleRepository(ApplicationEventPublisher eventPublisher) {             return new SampleRepository(eventPublisher);         }         @TransactionalEventListener         @Order(Ordered.HIGHEST_PRECEDENCE)         void earlyListener(SampleEvent event) {             System.out.println(""early listener called !!!"");         }     }      static class SampleRepository {         private final ApplicationEventPublisher eventPublisher;         public SampleRepository(ApplicationEventPublisher eventPublisher) {             this.eventPublisher = eventPublisher;         }         @Transactional         public void execute() {             eventPublisher.publishEvent(new SampleEvent());             TransactionSynchronizationManager.registerSynchronization(new LateSynchronization());         }     }      static class SampleEvent extends ApplicationEvent {         public SampleEvent() {             super("""");         }     }      static class LateSynchronization implements TransactionSynchronization {         @Override         public int getOrder() {             return Ordered.LOWEST_PRECEDENCE;         }         @Override         public void afterCommit() {             System.out.println(""late synchronization called !!!"");         }     }      @Test     void test(@Autowired SampleRepository repository) {         repository.execute();     } } ```  The output is  ``` late synchronization called !!! early listener called !!! ```  When debugging, it looks like `AbstractPlatformTransactionManager` does  ```java try {     // here the TransactionSynchronization.afterCommit() is called     triggerAfterCommit(status); } finally {     // and here the TransactionalApplicationListenerSynchronization.afterCompletion() is called     triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED); } ```  `TransactionalApplicationListenerSynchronization` will call the event listener method. Though, it is too late for me.  * Is this a bug or is this by design? * If this is by design (which is sad to me), I guess this behavior should be documented somewhere. I haven't found such docs.","open","in: data,","mdleonid","2021-07-20T12:54:27Z","2021-11-10T09:27:08Z"
"","27081","Using entrySet iterator in ServletServerHttpRequest#getBodyFromServle…","Using entrySet iterator can avoid the Map.get(key) lookup, which is more efficient","closed","type: task,","GungnirLaevatain","2021-06-19T06:02:59Z","2022-03-24T03:25:10Z"
"","27002","@Transactional doesn't work in @PostConstruct","Using Aspectj mode with runtime aspectj weaver.  Inside a `@PostConstruct`, calling a method with `@Transactional` doesn't start a transaction. The transactional aspect forwards call to the method, but no transaction is started. This is an invalid behavior, I was expecting an exception.  Sample repo: https://github.com/cdalexndr/spring-boot-issue-26710  Spring Boot 2.4.4","open","in: data,","cdalexndr","2021-05-29T19:55:53Z","2021-11-10T09:27:08Z"
"","27419","StringUtils.collectionToDelimitedString(…) fails with NullPointerException when the collection contains null","Using `String.valueOf` toString this  `element`, cover the `null` case.  fix #27411","closed","in: core,","Koooooo-7","2021-09-16T08:18:41Z","2021-09-17T14:22:54Z"
"","27073","Introduce native testing of a subset of Spring Framework tests","Using [native-gradle-plugin](https://github.com/graalvm/native-build-tools/tree/master/native-gradle-plugin), we should as a first step for better test coverage on native introduce running a subset of the tests optionally.  Since we don't want to introduce circular dependency between Spring Native and Spring Framework, and since running JVM tests before native ones is required, we should enable the tracing agent (as supported by the Gradle plugin) to generate the required native configuration automatically.  All tests using unsupported features like bytecode runtime generation (CGLIB proxies, Mockito) should be disabled. Also no need to test `@Configuration` processing since that will be different on native via AOT transformation. So I would advise to start by the core ones like `spring-core`, `spring-beans`, `spring-context`.","closed","status: declined,","sdeleuze","2021-06-17T09:10:50Z","2022-01-19T12:46:02Z"
"","27824","Use Collection factory methods","Use the collection factory methods when applicable and available. Replaces the use of Collections.unmodifiableList/Set/Map with the `of` factory method.","closed","type: task,","mdeinum","2021-12-16T06:51:34Z","2022-01-04T11:04:26Z"
"","27639","UriUtils::extractFileExtension does not properly handle empty file names","UriUtils.extractFileExtension()  returns null when the url follow this pattern ""/abc/.format"" instead of format. Where format could be any allowed format: .xml, .json, etc..  `UriUtils.extractFileExtension(""/xxx/.json""); // => ""null""`","closed","type: bug,","cguerreros","2021-11-04T09:37:27Z","2021-11-19T11:38:22Z"
"","27445","Uploading malformed multipart file should respond 400 instead of 500","Uploading a malformed multi-part file results in 500 Internal Server Error even though sending malformed data is clearly a client error. Status code should be 400 Bad Request.  When a malformed multi-part file is received, the parsing fails in org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest and IOFileUploadException is thrown. The IOFileUploadException is later wrapped into MultipartException in DispatcherServlet. Spring's ResponseEntityExceptionHandler does not handle MultipartException and therefore the response status code is ultimately set to 500 Internal Server Error.  ### Workaround One workaround for this issue is to add an ExceptionHandler for MultipartException  ``` java @ControllerAdvice   public class RestResponseExceptionHandler extends ResponseEntityExceptionHandler {          @ExceptionHandler(MultipartException.class)       public ResponseEntity handleMultipartException(MultipartException exception) {           return new ResponseEntity(HttpStatus.BAD_REQUEST);    }      } ```  ### Example of current behavior ``` java package malformedmultipartfile;  import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.multipart.MultipartException; import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;  @ControllerAdvice public class RestResponseExceptionHandler extends ResponseEntityExceptionHandler {      @ExceptionHandler(MultipartException.class)     public ResponseEntity handleMultipartException(MultipartException exception) {         return new ResponseEntity(HttpStatus.BAD_REQUEST);     }  } ```  ``` java package malformedmultipartfile;  import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.http.*;  import static org.junit.jupiter.api.Assertions.assertEquals;  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class FileUploadControllerTest {      @Autowired     private TestRestTemplate testRestTemplate;      @Test     public void sendingMalformedMultipartFileResultsIn500() {         HttpHeaders headers = new HttpHeaders();         headers.add(HttpHeaders.CONTENT_TYPE, MediaType.MULTIPART_FORM_DATA_VALUE + ""; boundary=boundary-value"");         String body = ""--boundary-value\r\n"" +                       ""Content-Disposition: form-data; name=\""file\""; filename=\""testFile\""\r\n"" +                       ""Content-Type: application/octet-stream\r\n\r\n"" +                       ""something\r\n""; //""--boundary-value--\r\n"" missing from the end         ResponseEntity responseEntity = testRestTemplate.postForEntity(                 ""/"",                 new HttpEntity(body, headers),                 Void.class);          assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());     } } ```","open","in: web,","penttin5","2021-09-21T10:49:39Z","2022-05-19T10:11:05Z"
"","27800","pull","update pull","closed","status: invalid,","xuwulin","2021-12-11T14:35:46Z","2021-12-11T15:33:37Z"
"","27573","Default content type of response changed in v5.3.11","Until Spring Framework v5.3.10, when `Accept` header is not specified, all API used `Content-Type: application/json` as default value. This behavior seems to have changed in v5.3.11 where `Content-Type: application/xml` is being used.  Please refer attached [demo.zip](https://github.com/spring-projects/spring-framework/files/7364072/demo.zip).   When following command is used to trigger HTTP request, different responses are returned by API with `v5.3.10` and `v5.3.11`.  ```sh curl --request GET --url http://localhost:8080/json ```  **Spring Framework","closed","type: regression,","kedar-joshi","2021-10-18T10:48:25Z","2021-11-23T09:06:34Z"
"","27414","apiDiff task is broken with Gradle 7","Trying to run an api diff since the move to Gradle 7 leads to:  ``` > Task :spring-aop:apiDiff FAILED  FAILURE: Build failed with an exception.  * What went wrong: Some problems were found with the configuration of task ':spring-aop:apiDiff' (type 'JapicmpTask').   - Type 'me.champeau.gradle.japicmp.JapicmpTask' property 'failOnModification' has redundant getters: 'getFailOnModification()' and 'isFailOnModification()'.      Reason: Boolean property 'failOnModification' has both an `is` and a `get` getter.      Possible solutions:       1. Remove one of the getters.       2. Annotate one of the getters with @Internal.      Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#redundant_getters for more details about this problem.   - Type 'me.champeau.gradle.japicmp.JapicmpTask' property 'failOnModification' of type boolean shouldn't be annotated with @Optional.      Reason: Properties of primitive type cannot be optional.      Possible solutions:       1. Remove the @Optional annotation.       2. Use the java.lang.Boolean type instead.      Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#cannot_use_optional_on_primitive_types for more details about this problem.   - Type 'me.champeau.gradle.japicmp.JapicmpTask' property 'failOnSourceIncompatibility' of type boolean shouldn't be annotated with @Optional.      Reason: Properties of primitive type cannot be optional.      Possible solutions:       1. Remove the @Optional annotation.       2. Use the java.lang.Boolean type instead.      Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#cannot_use_optional_on_primitive_types for more details about this problem.   - Type 'me.champeau.gradle.japicmp.JapicmpTask' property 'ignoreMissingClasses' has redundant getters: 'getIgnoreMissingClasses()' and 'isIgnoreMissingClasses()'.      Reason: Boolean property 'ignoreMissingClasses' has both an `is` and a `get` getter.      Possible solutions:       1. Remove one of the getters.       2. Annotate one of the getters with @Internal.      Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#redundant_getters for more details about this problem.   - Type 'me.champeau.gradle.japicmp.JapicmpTask' property 'ignoreMissingClasses' of type boolean shouldn't be annotated with @Optional.      Reason: Properties of primitive type cannot be optional.      Possible solutions:       1. Remove the @Optional annotation.       2. Use the java.lang.Boolean type instead.      Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#cannot_use_optional_on_primitive_types for more details about this problem.  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0.  You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.  See https://docs.gradle.org/7.2/userguide/command_line_interface.html#sec:command_line_warnings  BUILD FAILED in 11s 52 actionable tasks: 36 executed, 15 from cache, 1 up-to-date ```","closed","type: task,","snicoll","2021-09-15T11:14:15Z","2021-09-15T12:45:34Z"
"","27066","Reducing the level of code nesting for some methods","Trivial code formatting - reduce code nesting on conditionals in HttpHeaders","closed","status: declined,","serjnarbut","2021-06-15T17:29:40Z","2021-12-02T12:32:20Z"
"","26980","Fix typo in code example","Today, I found this error while browsing the spring web reactive document.","closed","type: documentation,","hunjipo","2021-05-27T05:21:51Z","2021-05-27T08:20:25Z"
"","27098","Use StringBuilder.append(char) where possible","To slightly improve performance, we should use `StringBuilder.append(char)` instead of `StringBuilder.append(String)` whenever we append a single character to the builder.  See also: #25056","closed","type: enhancement,","sbrannen","2021-06-25T07:53:34Z","2021-06-25T08:54:31Z"
"","27406","Migrate to TestNG Engine for the JUnit Platform","To simplify our Gradle build in the `spring-test` module, we should investigate migrating to the [TestNG Engine for the JUnit Platform](https://github.com/junit-team/testng-engine) and consolidate all tests into a single Gradle `test` task.","closed","type: task,","sbrannen","2021-09-15T09:01:42Z","2021-09-20T12:48:58Z"
"","26919","Spring 5.2 with cglib proxies: An illegal reflective access operation has occurred","To reproduce, create a minimal Spring-based application (Spring Framework 5.2) with cglib proxies enabled and run it with Java 9+, for instance: * Create a project using https://start.spring.io/ using Spring Boot 2.3.x (no additional dependencies required). * Add a proxied bean:   ```java   @Bean   @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)   public Object theObject() {       return new Object();   }   ``` * Start the application.  The following warning appears: ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (.../.m2/repository/org/springframework/spring-core/5.2.14.RELEASE/spring-core-5.2.14.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release ```  Debugging illegal access provides the following stacktrace: ``` WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (.../.m2/repository/org/springframework/spring-core/5.2.14.RELEASE/spring-core-5.2.14.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:533) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:585) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:57) 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205) 	at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) 	at org.springframework.aop.scope.ScopedProxyFactoryBean.setBeanFactory(ScopedProxyFactoryBean.java:117) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeAwareMethods(AbstractAutowireCapableBeanFactory.java:1821) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1786) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:878) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:879) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:755) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:402) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312) ```  It looks like a regression of #22674 (as far as I understand, Spring Framework 5.1+ should be fully Java 9 compatible).","closed","for: external-project,","orange-buffalo","2021-05-10T04:19:22Z","2022-01-26T08:52:13Z"
"","27792","Feature/add methods validate collections","To keep using !true to negate conditions I believe is something not as clear as a method that contains a name that describes what is being done. With that in mind, I decided to create these methods and open this PR.","closed","status: declined,","muriloalvesdev","2021-12-09T22:00:34Z","2021-12-10T11:13:49Z"
"","27328","Passing attributes from WebClient to underlying HTTP library","To be able to enable a more customizable logging of requests we need to be able to pass some attributes from the WebClient to the underlying library.  This functionality was discussed and agreed in the issue #26208  * Expose attributes map on ClientHttpRequest and get them populated from the request * Add applyAttributes abstract method in AbstractClientHttpRequest that each HTTP Library can implement * Jetty and Apache HttpComponents implementation of applyAttributes","open","in: web,","sambuccid","2021-08-27T16:26:58Z","2021-11-08T11:17:44Z"
"","27591","Iterate over Map.entrySet() instead of Map.keySet() in PropertyEditorRegistrySupport","Tiny optimization is possible using `Map.entrySet()` instead of `Map.keySet()`","closed","in: core,","stsypanov","2021-10-22T12:05:54Z","2021-10-22T19:23:08Z"
"","27814","Raise bytecode level to Java 17 for Kotlin classes","This requires Kotlin 1.6.20, as the fix for https://youtrack.jetbrains.com/issue/KT-49329 is needed.","closed","in: kotlin,","bclozel","2021-12-14T14:27:52Z","2022-02-11T10:42:15Z"
"","27234","Simplify getInternalBeanFactoryForBean","This pull request simplifies `getInternalBeanFactoryForBean` in `AbstractBeanFactoryBasedTargetSourceCreator` and makes its intent more obvious.  The problem in https://github.com/spring-projects/spring-framework/issues/25801#issuecomment-698346498 does not apply to this patch since the mapping function in this patch does not modify/access the map itself.  This patch was generated automatically by the static analysis tool [Logifix](https://github.com/lyxell/logifix) as part of a research project.","closed","in: core,","lyxell","2021-07-30T20:31:14Z","2021-07-31T14:28:21Z"
"","27482","Feat/fix java doc","this pull request fix the wrong java doc with issue https://github.com/spring-projects/spring-framework/issues/27269","closed","","xixingya","2021-09-28T09:47:21Z","2021-11-23T07:26:50Z"
"","27863","Remove references to JCacheConfigurerSupport and CachingConfigurerSupport","This PR removes references to deprecated `JCacheConfigurerSupport` and `CachingConfigurerSupport` in Javadoc and tests.  See gh-27811","closed","type: task,","izeye","2021-12-28T20:15:13Z","2021-12-29T10:05:08Z"
"","27033","Remove redundant Collections.unmodifiableList()","This PR removes redundant `Collections.unmodifiableList()` wrappers.","closed","type: task,","izeye","2021-06-08T03:49:59Z","2021-06-08T08:42:30Z"
"","27864","Remove AsyncConfigurerSupport reference in EnableAsync Javadoc","This PR removes a deprecated `AsyncConfigurerSupport` reference in `EnableAsync` Javadoc.  See gh-27812","closed","type: task,","izeye","2021-12-28T20:27:08Z","2021-12-29T10:04:20Z"
"","27365","Configure optional configuration to consume its dependencies' API","This PR refines the attributes of the `optional` configuration to ensure that it consumes its dependencies' Java API and not just their runtime. It should fix the problem described in https://github.com/junit-team/junit5/issues/2705#issuecomment-912669965.","closed","type: task,","wilkinsona","2021-09-06T15:32:19Z","2021-09-07T09:52:18Z"
"","27799","Polish","This PR polishes a bit.","closed","type: task,","izeye","2021-12-11T03:08:06Z","2021-12-13T14:06:58Z"
"","27238","Polish `PrintingResultHandlerIntegrationTests.printMvcResultsToWriterWithFailingGlobalResultMatcher()`","This PR polishes `PrintingResultHandlerIntegrationTests.printMvcResultsToWriterWithFailingGlobalResultMatcher()` a bit by adding `Assertions.fail()` on an unexpected path.","closed","type: task,","izeye","2021-08-04T05:15:28Z","2021-08-04T13:05:44Z"
"","26951","Polish PORT_PATTERN in UriComponentsBuilder","This PR polishes `PORT_PATTERN` in `UriComponentsBuilder` by removing some parts that don't seem to be necessary.  I might be missing something. If it's intentional, it would good to have some tests that demonstrate why they are necessary as the current tests including `UriComponentsBuilderTests` pass without them.","closed","type: enhancement,","izeye","2021-05-18T02:10:20Z","2021-05-20T18:31:59Z"
"","27835","Polish HttpMethod","This PR polishes `HttpMethod` a bit.","closed","type: task,","izeye","2021-12-18T03:04:20Z","2021-12-21T08:40:32Z"
"","27833","Polish HtmlCharacterEntityDecoder","This PR polishes `HtmlCharacterEntityDecoder` a bit.","closed","type: task,","izeye","2021-12-17T14:12:54Z","2021-12-21T08:41:01Z"
"","27379","Migrate CoroutinesUtils from Kotlin to Java","This PR migrates `CoroutinesUtils` from Kotlin code to Java. The primary benefit of the change is that the Kotlin module is no longer required when working on the Java code in an IDE. This is especially helpful for Eclipse users (like myself and @sbrannen) as we no longer need to install Kotlin tooling.","closed","type: task,","philwebb","2021-09-10T00:57:46Z","2021-09-13T15:41:08Z"
"","26981","Add test cases to SpEL's MapAccessorTests","This PR is a simple addition of two test cases. It increases path coverage to two additional methods within the MapAccessor class.","closed","in: core,","kenzo-spaulding","2021-05-27T05:39:47Z","2021-10-23T15:48:41Z"
"","27285","Add class-level execution phases for @Sql","This PR is a proposal to address #18929.  So far, scripts or inline statements declared with `@Sql` run before or after every test method. It is not possible to declare a script or inline statement to be run once before any test method has been run or after all test methods have been run.  This PR makes it possible by adding two additional execution phases, `BEFORE_TEST_CLASS` and `AFTER_TEST_CLASS`. Scripts or inline statements with `BEFORE_TEST_CLASS` will be run once before any test method has been started. Anything marked with `AFTER_TEST_CLASS` will be run after all test methods have been completed.  #1835 added `MergeMode`. `MergeMode` allows method-level `@Sql` annotations to override or extend class-level `@Sql` annotations. In my proposal, `MergeMode` has no effect on `@Sql` annotations with an execution phase of `BEFORE_TEST_CLASS` or `AFTER_TEST_CLASS`. The reason is that any method-level processing would come too late to influence a script or inline statement that runs when the test context is being set up. Furthermore, it would pose the question how to resolve conflicting annotations. If one test method wished to override a class-level `BEFORE_TEST_CLASS` annotation while others would not, honoring that wish would effectively turn `BEFORE_TEST_CLASS` into `BEFORE_TEST_METHOD`. `AFTER_TEST_CLASS` has roughly the same problem, just backwards.","open","in: data,","aahlenst","2021-08-16T07:38:13Z","2021-11-10T12:22:18Z"
"","27291","Fix duplicated ""the"" occurrences in Javadoc and XSD","This PR fixes typos of ""the the"" to ""the"".","closed","type: documentation,","benelog","2021-08-18T16:22:05Z","2021-08-19T22:09:42Z"
"","27827","Polish","This PR fixes some typos and polishes trivial stuff.","closed","type: task,","izeye","2021-12-16T14:17:38Z","2021-12-21T08:41:31Z"
"","26960","Polish","This PR fixes some typos and polishes trivial stuff.","closed","type: task,","izeye","2021-05-20T07:46:12Z","2021-05-20T13:50:24Z"
"","26878","Polish","This PR fixes some typos and polishes trivial stuff.","closed","type: task,","izeye","2021-04-29T13:59:05Z","2021-04-29T15:16:00Z"
"","26967","Fix broken Javadoc tags","This PR fixes broken Javadoc tags.","closed","type: documentation,","izeye","2021-05-22T00:14:36Z","2021-05-24T00:40:21Z"
"","27319","Fix duplicated ""the"" occurrences in Javadoc","This PR fixes a typo of ""the the"" to ""the"".","closed","status: declined,","boniato","2021-08-23T19:39:04Z","2021-08-24T05:53:42Z"
"","27037","Clean up @SuppressWarnings(""ConstantConditions"")","This PR cleans up `@SuppressWarnings(""ConstantConditions"")` where possible.","closed","type: task,","izeye","2021-06-08T11:29:14Z","2021-06-08T11:49:47Z"
"","27846","Use UTF-8 for application/json in MockHttpServletResponse","This PR changes to use UTF-8 for `application/json` in `MockHttpServletResponse`.","closed","status: superseded,","izeye","2021-12-23T05:55:09Z","2022-01-13T12:40:40Z"
"","27848","Add Javadoc @since tag to new PayloadApplicationEvent constructor","This PR adds Javadoc `@since` tag to the new `PayloadApplicationEvent` constructor.  See gh-24599","closed","in: core,","izeye","2021-12-23T11:02:24Z","2021-12-27T11:41:41Z"
"","27155","Add Javadoc `@since` to `BeanDefinitionBuilder.setSynthetic()`","This PR adds Javadoc `@since` tag to `BeanDefinitionBuilder.setSynthetic()`.","closed","type: documentation,","izeye","2021-07-12T00:53:16Z","2021-07-12T06:31:02Z"
"","27115","Allow null for attributeValue in Model.set() Kotlin extension method","This parameter is `@Nullable` in the underlying addAttribute method","open","in: core,","gnagy","2021-07-01T09:36:06Z","2021-11-12T14:20:02Z"
"","27437","Add support for non-public record declarations","This might be possible, and I just couldn't find the documentation or make it work, but in essence it feels like it should be possible to bind form payloads to a Java 14 record via the constructor   ```java record Greeting(String name){}  @Controller  class GreetingsMvcController {    @PostMapping (""/greetings"")    void submit (@ModelAttribute Greeting greeting) {      System.out.println( ""the name is "" + greeting.name()) ;    } } ```  Thanks for your consideration, and I apologize if this has already been solved.","closed","type: enhancement,","joshlong","2021-09-19T08:30:29Z","2021-09-23T14:13:55Z"
"","26927","Improve support for port numbers in allowedOriginPattern of CorsConfiguration","This is to support ports in cors origin patterns. Closes gh-26926  Example: ``` https://*.example.com:[8080] https://*.example.com:[8080,9000] https://*.example.com:[*] ```","closed","type: enhancement,","korektur","2021-05-10T22:28:53Z","2021-05-17T16:29:15Z"
"","27165","Allow builder to set constructor detector for object mapper","This is to allow the Jackson Object Mapper Builder to be able to accept a constructor detector. The idea is that it can then be used by [this](https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java#L145) to configure it via properties.  see [gh-27178](https://github.com/spring-projects/spring-boot/issues/27178)","closed","type: enhancement,","SatsG","2021-07-13T19:44:24Z","2021-08-16T14:49:08Z"
"","27416","Upgrade to AspectJ 1.9.8 GA","This is the first version that officially supports JDK17 source and target compatibility level (see eclipse/org.aspectj#79).  Right now, we've downgraded the language level to 1.8 in aspectj Gradle tasks. Closing this issue would involve reverting the changes to the `compileAspectj` and `compileTestAspectj` tasks in `spring-aspects.gradle`.","closed","type: dependency-upgrade,","bclozel","2021-09-15T14:20:25Z","2022-02-16T14:31:04Z"
"","27708","Is it possible to have ObjectProvider that provides singleton-prototypes?","This is the code I have:  ``` ... @Autowired   @Qualifier(""cfs"")   private ObjectProvider cfs;    @Bean   @Scope(BeanDefinition.SCOPE_PROTOTYPE)   public ConnectionFactory cfs(Integer bookieId) { ... ```  I would like to be able to use this as:  `cfs.getObject(123)`, and first time it sees parameter `123`, it creates new bean (so it behaves like prototype). Second time it sees in my code `cfs.getObject(123)`, it should return already initialized bean from the last time (so it behaves like singleton, because parameter is the same == 123). This is something like map's `computeIfAbsent`.","closed","status: declined,","bojanv55","2021-11-19T23:37:23Z","2022-05-23T09:26:14Z"
"","27461","WebClient does not deserialize ParameterizedTypeReference when the generic type is passed from another function","This is related to [this issue](https://github.com/spring-projects/spring-framework/issues/21256), and I know we have a [test](https://github.com/spring-projects/spring-framework/blob/5b9e7e44e027718447504f417fb3821c468415fa/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java#L146-L170) to confirm that is not an issue. However the issue I found is that it only works when we explicitly specify the type like this `bodyToMono(new ParameterizedTypeReference() {})`. It will not work if we move that `webClient.get()` block to a separate function and change it to take generic type like this `bodyToMono(new ParameterizedTypeReference() {});`.  Here is the modified unit test. It will throw error `class java.util.LinkedHashMap cannot be cast to class org.springframework.web.reactive.function.client. WebClientIntegrationTests$Foo`  ```     @Test     public void shouldReceiveJsonAsTypeReferenceString() throws Exception {         String content = ""{\""containerValue\"":{\""fooValue\"":\""bar\""}}"";         prepareResponse(response -> response             .setHeader(""Content-Type"", ""application/json"").setBody(content));          Mono result = getData();          StepVerifier.create(result)             .assertNext(valueContainer -> {                 Foo foo = valueContainer.getContainerValue();                 assertNotNull(foo);                 assertEquals(""bar"", foo.getFooValue());             })             .expectComplete().verify(Duration.ofSeconds(3));          expectRequestCount(1);         expectRequest(request -> {             assertEquals(""/json"", request.getPath());             assertEquals(""application/json"", request.getHeader(HttpHeaders.ACCEPT));         });     }      private  Mono getData() {         return this.webClient.get()             .uri(""/json"").accept(MediaType.APPLICATION_JSON)             .retrieve()             .bodyToMono(new ParameterizedTypeReference() {});     } ``` Spring boot version is 2.5.3","closed","status: invalid,","lz000","2021-09-23T16:54:58Z","2021-09-27T12:52:46Z"
"","26879","Is it possible to merge @RestController (@Controller) and @RequestMapping in one annotation?","This is not an issue but an improvement.  When I look at my controllers all of them start with these 2 annotations: `@RestController` and `@RequestMapping`. I wonder if it's possible to merge those annotations in one? Or adding all the attributes from `@RequestMapping` to `@RestController`. We could have something like: `@RestController(name=""controllerName"", requestMapping=""/mymapping"", ...)` I know there are more critical issues than this request, it's just an improvement idea.  Thanks","closed","in: web,","akuma8","2021-04-29T14:08:15Z","2021-04-29T15:06:42Z"
"","27585","How to contribute","This is not a bug problem. I recently developed a deep learning (CV) example using AWS mxnet and tensorflow. I integrate through springboot 2.5. I don't see any AI framework on spring.io, so my idea is that I can do this through AWS djl and spring boot. I fell this plan is feasible","closed","status: invalid,","Jzow","2021-10-21T03:43:03Z","2021-10-21T12:28:07Z"
"","26961","ResponseEntity Allows Body for 1xx, 204, 304 Statuses","This is for the issues: https://github.com/spring-projects/spring-framework/issues/26737","closed","status: declined,","tyc31316","2021-05-20T18:45:43Z","2021-05-26T09:13:48Z"
"","27169","Dokka generation is not including links to Coroutines","This is due to https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/package-list resulting in a 404.  - https://github.com/Kotlin/kotlinx.coroutines/issues/290  This should be backported as well, since `5.2.x` is affected.","closed","type: task,","snicoll","2021-07-14T05:47:33Z","2021-12-14T15:40:33Z"
"","27779","Adding observability of application context startup","This is an initial version of adding observability to the application context startup. We're providing an `ObservabilityApplicationStartup` that will create metrics and traces for the application context startup.   ## Things to discuss:  - key names for post processors and bean names - do span names look ok - does the tracing graph look useful - do the metric names look fine  ## How to run this?  Build spring framework with the observability change  ``` $ git clone git@github.com:marcingrzejszczak/spring-framework.git  $ cd spring-framework $ git checkout observability_context $ ./gradlew pTML -x dokkaHtmlPartial -x javadoc ```  Run zipkin  ``` $ docker run -d -p 9411:9411 openzipkin/zipkin ```  Run sample  ``` $ git clone git@github.com:marcingrzejszczak/observability-samples.git $ cd observability-samples/spring-framework-startup-step $ ./mvnw clean install ```  Go to zipkin and check the traces (you can find the links in the logs too)  ## To do:  - [ ] add tests - [ ] refactor naming  ## Attachments:  ### Tracing  ![image](https://user-images.githubusercontent.com/3297437/145018722-1e43013a-5b14-4876-a679-c08bf6333076.png)  ![image](https://user-images.githubusercontent.com/3297437/145018782-e27c56a5-3c68-4710-87df-182e4bcf52ad.png)  The long spans for 3 beans are because I've put thread sleep there.  ### Metrics  ``` INFO: Gathered the following metrics 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags [] 	Meter with name  and type  has the following measurements  		  		and has the following tags []  ```  @shakuzen @jonatan-ivanov","closed","status: declined,","marcingrzejszczak","2021-12-07T11:15:56Z","2022-02-05T12:11:40Z"
"","27047","Support $$ quotes in JDBC ScriptUtils","This is an attempt to support $$ quote as mentioned in this issue: https://github.com/spring-projects/spring-framework/issues/27018 I tried to add the $$ logic into the method of static void splitSqlScript in spring-jdbc/src/main/java/org/springframework/jdbc/datasource/init/ScriptUtils.java","open","in: data,","tyc31316","2021-06-10T16:51:02Z","2021-11-10T11:38:11Z"
"","27046","Support $$ quotes in JDBC ScriptUtils","This is an attempt to support $$ quote as mentioned in this issue: https://github.com/spring-projects/spring-framework/issues/27018 I tried to add the $$ logic into the method of _public static void splitSqlScript_ in _spring-jdbc/src/main/java/org/springframework/jdbc/datasource/init/ScriptUtils.java_","closed","status: duplicate,","tyc31316","2021-06-10T16:34:07Z","2021-06-10T16:52:48Z"
"","27709","SchedulerFactoryBean no longer sets the job store's `DataSource` when the job store class has been customized","This is a regression in 5.3.13 caused by https://github.com/spring-projects/spring-framework/pull/27560. It was originally reported as a [Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/28758).","closed","in: core,","wilkinsona","2021-11-20T10:24:44Z","2021-12-14T16:02:48Z"
"","27778","Document how to register annotated classes with a GenericWebApplicationContext","This is a follow up to the following PR, aimed at improving the documentation in the reference manual.  - #24236  See also: https://github.com/spring-projects/spring-framework/pull/24236#issuecomment-987814851","closed","in: web,","sbrannen","2021-12-07T11:02:12Z","2022-01-27T15:15:51Z"
"","27902","Upgrade spring-r2dbc's test dependency on the H2 database to 2.0.x","This is a follow up to #27870, since we cannot upgrade `spring-r2dbc`'s test dependency to H2 2.0 until https://github.com/r2dbc/r2dbc-h2/pull/204 is released.","closed","status: superseded,","sbrannen","2022-01-07T13:45:02Z","2022-02-05T14:07:54Z"
"","27003","Improve @Transactional docs regarding method visibility","This is a follow up to #27001.  See https://github.com/spring-projects/spring-framework/pull/27001#issuecomment-850989147 for details.","closed","type: documentation,","sbrannen","2021-05-30T15:06:34Z","2021-05-30T15:16:40Z"
"","27288","Extract annotation utilities into separate, public dependency","This is a feature request.  **As a** developer, **I want to** use Spring's powerful annotation utility classes (e.g. `AnnotationUtils`, `MergedAnnotations`) outside of Spring projects, **in order to** handle meta annotations and annotations in parent classes, interfaces and methods the same way as is possible in Spring.  Background information: - Spring's annotation handling classes are quite powerful. It would be useful to be able to use them outside of a Spring context, e.g. in native Java + AspectJ projects or wherever. - Currently, this is impossible because the corresponding classes are quite entangled into Spring Core. - A while ago (about 10 months ago), I tried to find out how difficult it would be to extract them. Result: It is quite difficult, but possible. I successfully extracted them in two variants: with and without Kotlin support. See [this project](https://github.com/kriegaex/SpringAnnotationUtils), which I remembered just lately, and its read-me. The latter also explains how I did it. - Lately, one of the Spring committers asked the AspectJ team (I am a member) about meta annotation support in AspectJ, see    * https://github.com/eclipse/org.aspectj/issues/81 and   * https://github.com/spring-projects/spring-framework/issues/27221. - I also sometimes answer questions on StackOverflow which are related to meta annotations, e.g. [this one](https://stackoverflow.com/a/68788243/1082681). Usually I try to solve the problems presented there in a way not relying on the spring annotation utils, so the resulting aspects can also be migrated to native AspectJ and re-used in other projects.  Even outside of any Spring or AspectJ context, Spring's advanced annotation handling would come in handy in many situations totally unrelated to AOP. Therefore, I would be quite happy if this functionality could be factored out of Spring Core in order to function without any spring dependencies. Spring Core of course would continue to depend on the new library. I believe that Spring itself would improve with regard to separation of concerns and modularisation. Other advantages would be that it could be tested independently and that community contributions would become easier.","open","in: core,","kriegaex","2021-08-17T07:36:08Z","2021-11-10T09:51:51Z"
"","27477","Remove redundant assignment of default values to volatile/atomic fields","This is a continuation of https://github.com/spring-projects/spring-framework/pull/25261","open","in: core,","stsypanov","2021-09-27T15:30:47Z","2022-08-01T11:26:53Z"
"","27723","Add getter for RequestMappingInfo builder config","This improves support for programmatic mapping registration following the same config as other mappings managed in RequestMappingHandlerMapping.  See also issue #27715.","closed","type: enhancement,","neiser","2021-11-24T06:58:05Z","2021-11-24T13:54:59Z"
"","27052","Support for problem details based on RFC 7807","This has been requested a number of times but so far has been deferred to Spring Boot which supports error response details. The corresponding https://github.com/spring-projects/spring-boot/issues/19525 issue in Spring Boot has gathered quite a bit of feedback and comments.  For Spring Framework 6 we have an opportunity to revisit this topic and more generally, web error handling. Given a standard such as RFC 7807 for the format of error responses, the Spring Framework could provide more infrastructure that Boot can build on.  - [x] #28187 - [x] #28189 - [x] #28190  - [x] #28665 - [x] #28438 - [x] #28439 - [ ] #28814","open","type: enhancement,","rstoyanchev","2021-06-11T11:16:51Z","2022-07-13T15:54:53Z"
"","27688","Give warning when using capturing patterns with the AntPathMatcher","This fails:  ```java @GetMapping(""/resource/{*tail}"") public Object statics(@PathVariable String tail) {...} ```  with   ``` Required URI template variable 'tail' for method parameter type String is not present ```  In fact what you need is  ```java @GetMapping(""/resource/{*tail}"") public Object statics(@PathVariable(""*tail"") String tail) {...} ```  This isn't really obvious from either the error message or the docs. Maybe we should support the first variant anyway?","closed","type: enhancement,","dsyer","2021-11-16T14:05:46Z","2021-11-17T15:57:25Z"
"","27374","Fix response body missing 1st byte inside UnknownContentTypeException","This commit fixes the creation of `UnknownContentTypeException` when it is thrown from `HttpMessageConverterExtractor.extractData`.  This exception is usually thrown from `RestTemplate` when `HttpMessageConverterExtractor` can't extract response body. In this case `HttpMessageConverterExtractor` throws `UnknownContentTypeException` with response body as byte array.  Before this change the returned exception contained incorrect `responseBody` when `InputStream` from `ClientHttpResponse` was not markable (`markSupported()` is false). This is the usual case for HTTP response's `InputStream` implementations.  The first byte of response body inside `UnknownContentTypeException` was missing because it was already read from `InputStream`.  The `responseBody` was read from original `InputStream`, while it should be read from the wrapper of original `InputStream`.  ---  To a person who will merge: please improve the commit message if possible as I feel difficulties in attempt to correctly and briefly describe the change, that is essentially a bug fix (not a native English speaker).","closed","type: bug,","xak2000","2021-09-08T23:15:17Z","2021-09-10T10:23:42Z"
"","27079","When i use transferTo() to copy a uploadfile to a relative address，the file is missing","these are my codes:  ```java public class FileUploadController {     @PostMapping(value = ""/pic"", consumes = ""multipart/form-data"")     public String uploadPic(MultipartFile file) throws IOException {         String uploadFileName = file.getOriginalFilename();         File dest = new File(uploadFileName);         file.transferTo(dest);         return dest.getAbsolutePath();     } } ```  when the upload is finish, i can't find the file.  is there a mistake in the following codes? a character '!' is missing before the code 'dest.isAbsoulte()'?  ```java public class StandardMultipartHttpServletRequest extends AbstractMultipartHttpServletRequest {     // ...     public void transferTo(File dest) throws IOException, IllegalStateException { 	    this.part.write(dest.getPath());              // i think mybe the right code is ""if (!dest.isAbsolute() && !dest.exists())"".  	    if (dest.isAbsolute() && !dest.exists()) { 		    // Servlet 3.0 Part.write is not guaranteed to support absolute file paths: 		    // may translate the given path to a relative location within a temp dir 		    // (e.g. on Jetty whereas Tomcat and Undertow detect absolute paths). 		    // At least we offloaded the file from memory storage; it'll get deleted 		    // from the temp dir eventually in any case. And for our user's purposes, 		    // we can manually copy it to the requested location as a fallback. 		    FileCopyUtils.copy(this.part.getInputStream(), Files.newOutputStream(dest.toPath())); 	    }     } } ```","closed","status: invalid,","fengfengzhang","2021-06-18T17:07:25Z","2021-06-23T11:38:21Z"
"","27141","Set synthetic flag using BeanDefinitionBuilder","There's no way to set the flag using the builder","closed","type: enhancement,","snicoll","2021-07-07T14:10:45Z","2021-07-07T14:14:28Z"
"","27190","There is no directory on the left side of the spring official website document page。","There is no directory on the left side of the spring official website document page。","closed","status: duplicate,","JamesLiuft","2021-07-20T01:17:05Z","2021-07-20T06:10:14Z"
"","27339","Remove unnecessary brace in WebSocket documentation","There is an unnecessary brace in one of the examples in the WebSocket documentation.","closed","type: task,","gushev","2021-08-30T20:47:05Z","2021-09-02T21:00:36Z"
"","27842","TransactionSynchronizationManager should be able to unwrap Hibernate SessionFactoryImpl","There is an inconsistency when using Hibernate 5 via multiple APIs.  `SpringSessionContext` is constructed by Hibernate, therefore `this.sessionFactory` is always a plain `SessionFactoryImpl` instance. There is no way to change that, that I can see.  Spring Data JPA repositories and `JpaTransactionManager` use the `EntityManagerFactory` interface instead, which is usually a `LocalContainerEntityManagerFactoryBean` proxy.  If you try to use both (e.g. to fetch an entity and then use `LobHelper`) then they cannot see each others' sessions via `TransactionSynchronizationManager`, because they're keying by different objects. You then end up with two of them, and exceptions because one has no active transaction. `SpringSessionContext` is essentially non-functional.  The correct `SessionFactoryImpl` instance can be obtained via `entityManagerFactory.unwrap(SessionFactoryImpl.class)`, but it's not clear how to know whether that should happen. Perhaps just `instanceof SessionFactory`?  [Some background of my specific use-case](https://stackoverflow.com/q/70437658/476716)","open","in: data,","OrangeDog","2021-12-21T18:02:28Z","2022-01-05T15:11:21Z"
"","27586","Improve example in Javadoc for HttpEntity","There is a minor typo in java doc. To be specific, provided code snippet in `HttpEntity` does not work because of lack of quotation marks.  ```java HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.TEXT_PLAIN); HttpEntity entity = new HttpEntity(helloWorld, headers); URI location = template.postForLocation(""https://example.com"", entity); ```     **Affects:** \","closed","type: task,","no-brand","2021-10-21T07:22:18Z","2021-10-21T10:42:49Z"
"","27181","add getAndRegisterBean method","There are a number of ways I could be doing this instead, but all of them kind of annoy me, this is just a quality of life improvement, would also help I believe with lazy loading of beans.  ```java     springContext.registerBean(Neo4j.class, () -> Neo4jBuilders.newInProcessBuilder()        .withDisabledServer()        .build());      var neo4j = springContext.getBean(Neo4j.class); ```  what I would like to do is this  ```    var neo4j =  springContext.registerBean(Neo4j.class, () -> Neo4jBuilders.newInProcessBuilder()        .withDisabledServer()        .build()); ```  if changing the method returns from `void` is not possible, and it probably isn't. I would suggest adding a new method  `getAndRegisterBean`   In this case, I can't use `@Bean` because my class isn't loaded by spring.   **Affects:**  ``` ./gradlew --version && ./gradlew :app:dependencyInsight --configuration runtimeClasspath --dependency spring-core  ------------------------------------------------------------ Gradle 7.1.1 ------------------------------------------------------------  Build time:   2021-07-02 12:16:43 UTC Revision:     774525a055494e0ece39f522ac7ad17498ce032c  Kotlin:       1.4.31 Groovy:       3.0.7 Ant:          Apache Ant(TM) version 1.10.9 compiled on September 27 2020 JVM:          11.0.11 (AdoptOpenJDK 11.0.11+9) OS:           Linux 5.10.42-1-MANJARO amd64  Type-safe dependency accessors is an incubating feature. Type-safe project accessors is an incubating feature.  > Task :app:dependencyInsight org.springframework:spring-core:5.3.8 ```  I could probably implement this myself, but I generally prefer to have a thumbs up before I do, and I'd probably just do it the way I'm doing now.","closed","in: core,","xenoterracide","2021-07-15T16:30:40Z","2022-01-19T11:07:21Z"
"","27468","Add missing @Nullable annotations on ResponseCookieBuilder","The ResponseCookie class already has @Nullable annotations for domain and path properties; but the builder was not synchronised with these declarations.","closed","","ghostd","2021-09-25T17:00:12Z","2021-11-23T07:26:49Z"
"","26965","Add option to get WebSession instance only if a session exists #26958","the realized new method, it's connected with enhancement #26958 (comment)","closed","type: enhancement,","MaxBartkov","2021-05-21T09:42:35Z","2021-05-25T11:01:50Z"
"","27124","Optimize HttpStatus value resolution from code","The purpose - optimize function ```HttpStatus.resolve```. Previous version worked with O(N) complexity, new works with O(1) complexity and doesn't require any allocation.","closed","status: declined,","imanushin","2021-07-03T16:10:14Z","2021-07-06T07:55:37Z"
"","27067","Fix explanation on default settings for content negotiation in reference doc","The official documentation ""**Web on Servlet Stack**"" contains paragraph ""**1.11.6. Content Types**"" that contains incorrect description of default strategy to determine the requested media types from the request. According to source code of ""**org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport**"" the **PathExtensionContentNegotiationStrategy** is deprecated and is not used as a default strategy.","closed","in: web,","hrybs","2021-06-15T18:36:41Z","2021-07-12T14:24:26Z"
"","27590","In Spring-Web UriComponentsBuilder's parseForwardedFor method is mapping IPv4 addresses as unresolved hosts","The method parseForwardedFor in UriComponentsBuilder is using, for both Forwarded headers's extracted IPv4 Addresses, the method `InetSocketAddress.createUnresolved(host, port)` to generate an InetSocketAddress.  Maybe what should be used is the constructor `InetSocketAddress(InetAddress addr, int port)`  The current behaviour creates problems given that ForwardedHeaderTransformer will use this method to recreate ServerHttpRequest's remoteAddress (while removing `X-Forwarded-For` header from the request) and, for instance, Spring Cloud Gateway (see XForwardedHeadersFilter in that project) will try to rebuild this header from this recreated remoteAddress using request.getRemoteAddress().getAddress().getHostAddress()","open","status: feedback-provided,","jlimamob","2021-10-22T10:02:02Z","2021-11-08T11:57:07Z"
"","27749","The ReactorClientHttpConnector must apply mapper before tcpConfiguration()","The logic right now is like this:  ``` public ReactorClientHttpConnector(ReactorResourceFactory factory, Function mapper) { 		this.httpClient = defaultInitializer.andThen(mapper).apply(initHttpClient(factory)); }  @SuppressWarnings(""deprecation"") private static HttpClient initHttpClient(ReactorResourceFactory resourceFactory) { 	ConnectionProvider provider = resourceFactory.getConnectionProvider(); 	LoopResources resources = resourceFactory.getLoopResources(); 	Assert.notNull(provider, ""No ConnectionProvider: is ReactorResourceFactory not initialized yet?""); 	Assert.notNull(resources, ""No LoopResources: is ReactorResourceFactory not initialized yet?""); 	return HttpClient.create(provider).tcpConfiguration(tcpClient -> tcpClient.runOn(resources)); } ``` And that `mapper` is called when `tcpConfiguration()` has done its logic.  In the native image on Windows it fails like: ``` Caused by: java.lang.ExceptionInInitializerError 	at io.netty.resolver.dns.DnsServerAddressStreamProviders$DefaultProviderHolder$1.provider(DnsServerAddressStreamProviders.java:140) 	at io.netty.resolver.dns.DnsServerAddressStreamProviders$DefaultProviderHolder$1.(DnsServerAddressStreamProviders.java:120) 	at io.netty.resolver.dns.DnsServerAddressStreamProviders$DefaultProviderHolder.(DnsServerAddressStreamProviders.java:118) 	at io.netty.resolver.dns.DnsServerAddressStreamProviders.unixDefault(DnsServerAddressStreamProviders.java:107) 	at io.netty.resolver.dns.DnsServerAddressStreamProviders.platformDefault(DnsServerAddressStreamProviders.java:103) 	at io.netty.resolver.dns.DnsNameResolverBuilder.(DnsNameResolverBuilder.java:60) 	at reactor.netty.transport.NameResolverProvider.newNameResolverGroup(NameResolverProvider.java:455) 	at reactor.netty.transport.ClientTransportConfig.lambda$getOrCreateResolver$0(ClientTransportConfig.java:239) 	at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) 	at reactor.netty.transport.ClientTransportConfig.getOrCreateResolver(ClientTransportConfig.java:238) 	at reactor.netty.transport.ClientTransport.runOn(ClientTransport.java:352) 	at reactor.netty.transport.ClientTransport.runOn(ClientTransport.java:42) 	at reactor.netty.transport.Transport.runOn(Transport.java:249) 	at reactor.netty.http.client.HttpClientTcpConfig.runOn(HttpClientTcpConfig.java:189) 	at org.springframework.http.client.reactive.ReactorClientHttpConnector.lambda$initHttpClient$1(ReactorClientHttpConnector.java:85) 	at reactor.netty.http.client.HttpClient.tcpConfiguration(HttpClient.java:1494) 	at org.springframework.http.client.reactive.ReactorClientHttpConnector.initHttpClient(ReactorClientHttpConnector.java:85) 	at org.springframework.http.client.reactive.ReactorClientHttpConnector.(ReactorClientHttpConnector.java:76) 	at org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorConfiguration$ReactorNetty.reactorClientHttpConnector(ClientHttpConnectorConfiguration.java:66) 	at org.springframework.boot.autoconfigure.web.reactive.function.client.ContextBootstrapInitializer.lambda$registerReactorNetty_reactorClientHttpConnector$0(ContextBootstrapInitializer.java:19) 	at org.springframework.aot.beans.factory.ThrowableFunction.apply(ThrowableFunction.java:18) 	at org.springframework.aot.beans.factory.InjectedElementResolver.create(InjectedElementResolver.java:51) 	at org.springframework.aot.beans.factory.BeanDefinitionRegistrar$InstanceSupplierContext.create(BeanDefinitionRegistrar.java:193) 	at org.springframework.boot.autoconfigure.web.reactive.function.client.ContextBootstrapInitializer.lambda$registerReactorNetty_reactorClientHttpConnector$1(ContextBootstrapInitializer.java:19) 	at org.springframework.aot.beans.factory.ThrowableFunction.apply(ThrowableFunction.java:18) 	at org.springframework.aot.beans.factory.BeanDefinitionRegistrar.lambda$instanceSupplier$0(BeanDefinitionRegistrar.java:97) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1249) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1191) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) 	... 52 more Caused by: java.lang.NullPointerException 	at java.util.StringTokenizer.(StringTokenizer.java:199) 	at java.util.StringTokenizer.(StringTokenizer.java:221) 	at sun.net.dns.ResolverConfigurationImpl.stringToList(ResolverConfigurationImpl.java:69) 	at sun.net.dns.ResolverConfigurationImpl.loadConfig(ResolverConfigurationImpl.java:104) 	at sun.net.dns.ResolverConfigurationImpl.nameservers(ResolverConfigurationImpl.java:127) 	at com.sun.jndi.dns.DnsContextFactory.serversForUrls(DnsContextFactory.java:149) 	at com.sun.jndi.dns.DnsContextFactory.getContext(DnsContextFactory.java:81) 	at com.sun.jndi.dns.DnsContextFactory.urlToContext(DnsContextFactory.java:120) 	at com.sun.jndi.dns.DnsContextFactory.getInitialContext(DnsContextFactory.java:64) 	at javax.naming.spi.NamingManager.getInitialContext(NamingManager.java:730) 	at javax.naming.InitialContext.getDefaultInitCtx(InitialContext.java:305) 	at javax.naming.InitialContext.init(InitialContext.java:236) 	at javax.naming.InitialContext.(InitialContext.java:208) 	at javax.naming.directory.InitialDirContext.(InitialDirContext.java:101) 	at io.netty.resolver.dns.DirContextUtils.addNameServers(DirContextUtils.java:49) 	at io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.(DefaultDnsServerAddressStreamProvider.java:53) 	... 82 more ``` Even if I provide this customizer: ``` 	@Bean 	ReactorNettyHttpClientMapper reactorNettyHttpClientMapper() { 		return httpClient -> httpClient.resolver(DefaultAddressResolverGroup.INSTANCE); 	} ```  In my opinion it has to be like this: ``` HttpClient httpClient = 				mapper.apply(HttpClient.create(provider)) 				.tcpConfiguration(tcpClient -> tcpClient.runOn(resources)); ```   This one works for me in my Spring Boot application: ``` 	@Bean 	ReactorResourceFactory reactorClientResourceFactory() { 		return new ReactorResourceFactory(); 	}  	@Bean 	ReactorClientHttpConnector reactorClientHttpConnector(ReactorResourceFactory reactorResourceFactory) { 		ConnectionProvider provider = reactorResourceFactory.getConnectionProvider(); 		LoopResources resources = reactorResourceFactory.getLoopResources(); 		Function mapper = 				httpClient -> httpClient.resolver(DefaultAddressResolverGroup.INSTANCE); 		HttpClient httpClient = 				mapper.apply(HttpClient.create(provider)) 						.tcpConfiguration(tcpClient -> tcpClient.runOn(resources));  		return new ReactorClientHttpConnector(httpClient); 	} ```  See more info in this Reactor Netty issue: https://github.com/reactor/reactor-netty/issues/1431","closed","type: enhancement,","artembilan","2021-11-29T21:43:23Z","2021-12-02T12:47:03Z"
"","27070","Remove logging dependency in BeanUtils","The logging dependency in `BeanUtils` is just for `findEditorByConvention` which has hardly any relevance these days. In order to make `BeanUtils` more lightweight in terms of its class initialization, also for native environments, let's drop those log statements.","closed","type: enhancement,","jhoeller","2021-06-16T13:37:34Z","2021-06-22T13:28:39Z"
"","27337","Fix Kotlin example for filtering handler functions","The Kotlin code example at _Filtering Handler Functions_ seems to be not equivalent to Java.  Suppose  > The `before` filter that adds a custom request header is only applied to the two GET routes. The `after` filter that logs the response is applied to all routes, including the nested ones.  is correct, `POST(""/person"", handler::createPerson)` and `after()` should not be inside `nest`, if my understanding to RouterFunction is correct.","closed","in: web,","w3-3w","2021-08-30T13:14:21Z","2021-09-02T21:04:07Z"
"","27496","Use default stylesheet for generated Javadoc HTML","The Javadoc for Spring Framework 6.0 currently does not have proper styling, since we switched from JDK 8 to JDK 17.  https://docs.spring.io/spring-framework/docs/6.0.0-SNAPSHOT/javadoc-api/index.html","closed","type: documentation,","sbrannen","2021-09-29T15:21:16Z","2021-10-20T11:09:37Z"
"","27689","Update javadoc and reference docs for consistent version and package references to the Jakarta EE 9 APIs","The javadoc for `WebApplicationInitializer` and `SpringServletContainerInitializer ` references Servlet 3.0 in a few places. It should be Servlet 5 now.","closed","in: core,","wilkinsona","2021-11-16T17:25:05Z","2021-11-17T11:41:14Z"
"","27042","Improve RequestResponseBodyMethodProcessor Javadoc","The Javadoc for `org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor` should mention that validation is performed not only for `@javax.validation.Valid` but also for  Spring's `@org.springframework.validation.annotation.Validated` or custom annotations whose name starts with `Valid`.","closed","in: web,","hrybs","2021-06-09T08:43:34Z","2021-06-15T15:04:24Z"
"","27043","Improve RequestPartMethodArgumentResolver Javadoc","The Javadoc for `org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver` should mention that validation is performed not only for `@javax.validation.Valid` but also for  Spring's `@org.springframework.validation.annotation.Validated` or custom annotations whose name starts with `Valid`.","closed","in: web,","hrybs","2021-06-09T08:50:12Z","2021-06-15T15:06:59Z"
"","27036","Update WebMvcConfigurationSupport javadoc for HandlerFunctionAdapter","The Java Doc for **org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport** doesn't contain complete information about all **HandlerAdapter** classes registered with the aforementioned class. According to source code of **WebMvcConfigurationSupport** it also creates **org.springframework.web.servlet.function.support.HandlerFunctionAdapter** handler adapter for routing functions.","closed","type: task,","hrybs","2021-06-08T10:46:15Z","2021-06-08T10:50:22Z"
"","26943","Spring Kafka overriding custom header pattern and removes id from Producer Record Header","The issue is related to the headers missing when sending a message to the `Kafka Topic`.  My requirement is to generate a `Spring Message` with headers including `id` holding a value that matches with the Kafka Producer Record Key.  While generating the Spring Message, I'm explicitly setting the `id` header and sending the message to the Kafka topic. But, when I consume the message from the topic, the value of the `id` header is set as `None`.  ### Approach 1: I have implemented a Custom Kafka Message Header and passed header patterns as` id, !timestamp, *` and configured the binder to use the bean by setting the below property `spring.cloud.stream.kafka.binder.headerMapperBeanName=customKafkaHeaderMapper` Still, I receive the `id` value as 'None'. I have investigated further and observed that the Spring Framework is explicitly removing the headers (in this case, the id header), even after setting the pattern to allow `id` header in the custom header mapper. Here is the spring code:  ``` protected MessageHandler createProducerMessageHandler(final ProducerDestination destination, ExtendedProducerProperties producerProperties, MessageChannel channel, MessageChannel errorChannel) throws Exception {     final KafkaHeaderMapper mapper = null;     // Bean name configured in the binder properties - spring.cloud.stream.kafka.binder.headerMapperBeanName=customKafkaHeaderMapper     if (this.configurationProperties.getHeaderMapperBeanName() != null) {         mapper = (KafkaHeaderMapper)applicationContext.getBean(this.configurationProperties.getHeaderMapperBeanName(), KafkaHeaderMapper.class);     }       if (mapper == null) {         try {          mapper = (KafkaHeaderMapper)applicationContext.getBean(""kafkaBinderHeaderMapper"", KafkaHeaderMapper.class);         } catch (BeansException var14) {         }     }       Object mapper;     if (producerProperties.getHeaderMode() != null && !HeaderMode.headers.equals(producerProperties.getHeaderMode())) {          mapper = null;     } else if (mapper == null) {         String[] headerPatterns = ((KafkaProducerProperties)producerProperties.getExtension()).getHeaderPatterns();         if (headerPatterns != null && headerPatterns.length > 0) {          mapper = new BinderHeaderMapper(BinderHeaderMapper.addNeverHeaderPatterns(Arrays.asList(headerPatterns)));         } else {         mapper = new BinderHeaderMapper();         }     } else {          // creates an instance of KafkaHeaderMapper to use CustomHeaderMapper          mapper = new KafkaHeaderMapper() {          public void toHeaders(Headers source, Map target) {             mapper.toHeaders(source, target);         }           public void fromHeaders(MessageHeaders headers, Headers target) {             mapper.fromHeaders(headers, target);             // Explicitly removes header id             BinderHeaderMapper.removeNeverHeaders(target);         }     };     }   handler.setHeaderMapper((KafkaHeaderMapper)mapper); return handler; } ``` The `BinderHeaderMapper.removeNeverHeaders(target)` static method will remove the header id passed from the Spring Message. ``` public static void removeNeverHeaders(Headers headers) {   headers.remove(""id"");   headers.remove(""timestamp"");   headers.remove(""deliveryAttempt"");   headers.remove(""scst_nativeHeadersPresent""); }  ```  Could you please provide me with some suggestions on how to configure/implement a functionality that will populate `id` header in the Kafka Producer Record.","closed","for: external-project,","skkadium","2021-05-14T13:53:12Z","2021-05-17T11:35:28Z"
"","26987","NPE if StompEndpointRegistry has allowedOrigins with null","The following code with 5.3.6 ran OK when `properties.getAllowedOrigins()` returned null. ``` @Override public void registerStompEndpoints(StompEndpointRegistry registry)  {   registry.addEndpoint(properties.getEndpoint())              .setAllowedOrigins(properties.getAllowedOrigins())              .withSockJS(); } ``` With 5.3.7 we get a NPE ``` Caused by: java.lang.NullPointerException 	at org.springframework.web.cors.CorsConfiguration.trimTrailingSlash(CorsConfiguration.java:146) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1654) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578) 	at org.springframework.web.cors.CorsConfiguration.setAllowedOrigins(CorsConfiguration.java:142) 	at org.springframework.web.socket.server.support.OriginHandshakeInterceptor.setAllowedOrigins(OriginHandshakeInterceptor.java:91) 	at org.springframework.web.socket.server.support.OriginHandshakeInterceptor.(OriginHandshakeInterceptor.java:65) 	at org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistration.getInterceptors(WebMvcStompWebSocketEndpointRegistration.java:135) 	at org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistration.withSockJS(WebMvcStompWebSocketEndpointRegistration.java:115) 	at com.ge.lfc.ui.backend.data.websocket.WebSocketConfiguration.registerStompEndpoints(WebSocketConfiguration.java:48) 	at org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration.registerStompEndpoints(DelegatingWebSocketMessageBrokerConfiguration.java:60) 	at org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport.stompWebSocketHandlerMapping(WebSocketMessageBrokerConfigurationSupport.java:91) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ```","closed","type: regression,","manderson23","2021-05-27T14:54:15Z","2021-06-02T16:27:34Z"
"","27517","DataBufferUtils.write loses context","The following code does not work as expected: ```java try (FileOutputStream out = new FileOutputStream(""test2"")) {     DataBufferUtils.read(Path.of(""test1""), new NettyDataBufferFactory(new PooledByteBufAllocator()), 1024, StandardOpenOption.READ)         .transformDeferredContextual((f, ctx) -> {             System.out.println(""1: "" + ctx.getOrDefault(""key"", ""EMPTY""));             return f;         })         .transform(f -> DataBufferUtils.write(f, out))         .transformDeferredContextual((f, ctx) -> {             System.out.println(""2: "" + ctx.getOrDefault(""key"", ""EMPTY""));             return f;         })         .contextWrite(Context.of(""key"", ""TEST""))         .subscribe(); } ``` Expected result: ``` 2: TEST 1: TEST ``` Actual result: ``` 2: TEST 1: EMPTY ``` Indeed, if you put `Hooks.enableContextLossTracking(); Hooks.onOperatorDebug();` before that code, you see that the context is lost at `DataBufferUtils.write` where a new flux is created that does not pass the subsriber's context to the original flux.  Environment: - Spring Boot 2.5.5 - Spring Framework 5.3.10 - Project Reactor 3.4.10","closed","in: core,","ummels","2021-10-04T09:08:37Z","2021-10-05T14:38:16Z"
"","27039","Revisit fix for gh-26905 in UriComponentsBuilder","The fix for gh-26905 introduced an unintended behavior change for some ambiguous URL patterns:  ```java URI uri = UriComponentsBuilder 				.fromUriString(""ws://localhost:{port}{path}"") 				.buildAndExpand(7777, ""/test"") 				.toUri();  // Now fails because it's parsing ""7777/test"" as an integer port value. ```  While the fix for gh-26905 better warns against invalid port values, it now fails for ambiguous patterns and matches more than expected if a `""/""` is not present before variable expansion. We should refine the `PORT_PATTERN` and ensure that such use cases are still working.","closed","type: regression,","bclozel","2021-06-08T12:51:57Z","2021-06-08T13:29:33Z"
"","27388","Fix some typos and mistakes in docs","The first commit contains straightforward changes, while the changes in the second one may be a matter of preference. I can rewrite this as needed, though.  @pivotal-cla This is an Obvious Fix","closed","type: documentation,","di72nn","2021-09-12T10:05:49Z","2021-09-16T12:58:01Z"
"","27370","Support Policy for Spring 5.[0-2].x is not clear","The documentation on the https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions page does provide us the information, that the versions 5.1.x and 5.0.x ""are not actively supported anymore"" and 5.2.x is ""to be actively supported until the end of 2021"".  I would be interested and expected the page to describe a little more in detail what does ""actively supported"" mean? In particular: Will version 5.2.x still get releases for critical bugs or security issues after ""end of 2021""?  I think this is an important information for many projects using Spring Framework and not clear in the document.","closed","status: invalid,","c-klinger","2021-09-07T14:04:56Z","2021-09-07T15:15:24Z"
"","27466","Optimize header removal in ForwardedHeaderFilter","The current implementation suggests that the request's headers are not expected to change. Hence, it's not necessary to copy them. Furthermore, it might be costly to do so if there are many headers. Instead, cache only the request's header names for method getHeaderNames.  Methods getHeader and getHeaders delegate to the respective methods of request if the header name is not in FORWARDED_HEADER_NAMES. Otherwise, they return null or an empty Enumeration respectively.","closed","type: enhancement,","GreenRecycleBin","2021-09-25T12:29:16Z","2021-11-29T06:54:12Z"
"","27186","The content on the left side is not displayed","The content on the left side is not displayed.  V5.3.9 is not displayed. V5.3.8 is OK.  ![image](https://user-images.githubusercontent.com/2121467/126056341-3521fa4d-956f-4baf-a7c7-dea4564d799b.png)","closed","","diguage","2021-07-18T05:01:06Z","2021-07-18T05:02:38Z"
"","26896","Incorrect check in AbstractBrokerRegistration's constructor","The constructor in `org.springframework.messaging.simp.config.AbstractBrokerRegistration` checks the non-nullness of the `clientOutboundChannel` parameter twice but does not check the non-nullness of the `clientInboundChannel` parameter.  See: https://github.com/spring-projects/spring-framework/blob/959e6d17458dbef0bf3572b8c0fe33d714e7c2f0/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractBrokerRegistration.java#L48","closed","type: bug,","tgyurci","2021-05-05T16:51:33Z","2021-05-11T13:50:42Z"
"","27624","Static resources are missing when jar does not have a directory entry","The changes for #27538 include an optimization to filter out non-existing locations on startup. However, a jar may not have entries for directories, e.g. `static/foo.gif` exists but `static/` does not, in which case the check for the existence of `classpath:static/` fails and the location is filtered out. As indicated in https://github.com/spring-projects/spring-framework/issues/27538#issuecomment-952694846 this can be the case for externally created jars that are outside the control of an application. We need to improve the check or drop the optimization.","closed","type: regression,","rstoyanchev","2021-10-29T11:04:20Z","2021-11-10T13:48:24Z"
"","27575","Update warn log message for empty static resource locations","The change to filter non-existing locations, related to #27538, caused those messages to appear automatically in scenarios where there are no static resource locations. The warning messages should be updated to take into account that  static resource locations may have been configured but none actually exist.","closed","type: bug,","rstoyanchev","2021-10-18T12:56:58Z","2021-10-19T11:40:42Z"
"","27259","Clarify behavior for generics support in BeanUtils.copyProperties","The below code works in `5.2.9.RELEASE`  ``` java  BeanUtils.copyProperties(transferVO , transferRequest);  ```   The classes where as follow. As you can see the source and destination beans has a List with same name but different types. But it was working  ``` java  public class transferVO { 	private List signers; }  public class transferRequest{	 	private List signers;  }   public class Signer{     private string name;  }  public class TransferSigners {         private string name; }  ```  After upgrade to `5.3.7` the `signers` property is not copied.","closed","in: core,","afattahi54","2021-08-11T12:48:48Z","2022-03-12T17:27:13Z"
"","26962","Remove jackson-module-kotlin warning","The Apollo GraphQL client depends on OkHttp 3 which depends on Kotlin. In a Java-based application, this results in the following warning being logged:  ``` 2021-05-20 19:06:02.663  WARN 41818 --- [kground-preinit] o.s.h.c.j.Jackson2ObjectMapperBuilder    : For Jackson Kotlin classes support please add ""com.fasterxml.jackson.module:jackson-module-kotlin"" to the classpath ```  Adding `com.fasterxml.jackson.module:jackson-module-kotlin` isn't the right thing to do as Jackson isn't handling any Kotlin types. The warning is the only logging done by `Jackson2ObjectMapperBuilder` so I could raise its log level to error without losing anything, but you have to know that's the right thing to do. I suspect many will unnecessarily add the dependency instead. In short, the warning feels a bit over-zealous to me.  I wonder if it would be possible to detect an actual problem caused by the lack of `jackson-module-kotlin` and log something at that point instead? If that's not possible, perhaps the log message could be lowered to info level and softened a bit to indicate that `jackson-module-kotlin` is only needed if Jackson will be dealing with Kotlin classes?","closed","type: enhancement,","wilkinsona","2021-05-20T19:35:13Z","2021-06-08T09:45:54Z"
"","27095","SimpleMethodMetadataReadingVisitor.Source.toString() omits separator for method arguments","The `toString()` implementation in `SimpleMethodMetadataReadingVisitor.Source` does not separate method argument types with a comma.  For example, it generates `org.example.MyClass.myMethod(java.lang.Stringjava.lang.Integer)` instead of `org.example.MyClass.myMethod(java.lang.String,java.lang.Integer)`.","closed","in: core,","sbrannen","2021-06-24T13:51:14Z","2021-06-24T14:59:16Z"
"","26931","Ensure multipart temp directories do not collide","The `SynchronossPartHttpMessageReader` needs separate directories to store uploaded files in, or otherwise multiple instances might collide.  The same applies to the `DefaultPartHttpMessageReader`.","closed","type: enhancement,","poutsma","2021-05-11T16:04:48Z","2021-06-03T13:03:44Z"
"","27595","Include HTTP status code in ServletRequestHandledEvent.desciption","The `ServletRequestHandledEvent` is very convenient for logging handled HTTP servlet requests.  For example in Spring Boot Web (Kotlin):  ```kotlin /**  * An [EventListener] for logging handled HTTP requests.  */ @Component class HttpRequestEventListener {      private val log = KotlinLogging.logger {}      @EventListener     fun handle(event: RequestHandledEvent) {         log.trace { ""HTTP request handled: ${event.description}"" }     } } ```  ... this logs all requests as:  > HTTP request handled: url=[/example]; client=[127.0.0.1]; method=[GET]; servlet=[dispatcherServlet]; session=[null]; user=[null]; time=[115ms]; status=[OK]  However, this is a bit confusing at first, as this will print ""status=OK"" even when the HTTP response status code is not 200. The status comes from the `RequestHandledEvent` here, which prints ""OK"" if there was no exception.  In [this pull request](https://github.com/spring-projects/spring-framework/pull/638) the HTTP status code was added to `ServletRequestHandledEvent`, but it is not included in the description.   Would it make sense to include it in the description too?  To return, for example, this  > url=[/example]; client=[127.0.0.1]; method=[GET]; servlet=[dispatcherServlet]; session=[null]; user=[null]; time=[115ms]; status=[OK]; statusCode=[404]  Of course, it's easy enough to adjust the logging in our event handler, but including the `statusCode` seems like a generally useful thing to me.  If this would be a welcome addition, I can provide a pull request.","open","in: web,","darioseidl","2021-10-22T17:48:13Z","2021-10-23T13:00:33Z"
"","27592","UndertowHeadersAdapter's remove() method violates Map contract","The `remove(Object key)` method in `UndertowHeadersAdapter` should return any previous value stored under the key; however, the current implementation always returns `null`.  This has already been fixed in `main` as part of commit https://github.com/spring-projects/spring-framework/commit/785212d67655119a71d3ad700e90c6e09e7c6361#diff-8be9fc708f521a68eb27761d98ddd6ebc62ec5431095673c7273647a538fae6bR132-R136.","closed","type: bug,","sbrannen","2021-10-22T12:48:55Z","2021-10-22T12:59:11Z"
"","27546","CronTrigger uses new Date() instead of context's Clock","The `nextExecutionTime(TriggerContext)` method of `CronTrigger` uses `new Date();` instead of using the specified context's clock. This makes it unnecessarily hard to unit test classes that create a trigger internally.  https://github.com/spring-projects/spring-framework/blob/276aa46a1c7c4bdd8ed23bd70e569334435ab4c7/spring-context/src/main/java/org/springframework/scheduling/support/CronTrigger.java#L108","closed","in: core,","markuspfeiffer","2021-10-11T15:13:15Z","2021-10-12T13:36:19Z"
"","26963","Set BEST_MATCHING_PATTERN_ATTRIBUTE on requests with WebMvc.fn","The `HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE` is used by Spring Boot to instrument the web framework and tag request metrics with the path pattern that matched for the current request.  WebFlux.fn extracts that information and adds it as a request attribute in its `RouterFunctionMapping`, but the WebMvc.fn variant does not. We should align both implementations.","closed","type: enhancement,","bclozel","2021-05-20T20:39:49Z","2021-05-21T09:54:30Z"
"","27633","Automatically clean up multipart temp files","The `DefaultPartHttpMessageReader` creates temp files that are never deleted. There should be an option to delete these files after the corresponding request was handled.  Related to #27613, the resolution of which introduced a `Part::delete` method to explicitly remove the temp file. This issue  focusses on automatically removing these temp files.","closed","type: enhancement,","poutsma","2021-11-02T14:33:11Z","2022-04-06T15:04:10Z"
"","26935","Ignore delimiter enclosed in double quotes in ScriptUtils","The `containsSqlScriptDelimiters()` method in `ScriptUtils` currently ignores delimiters enclosed in single quotes but not those enclosed within double quotes.  This contradicts the algorithm in `splitSqlScript()` and therefore constitutes a bug.  This applies to the `ScriptUtils` implementations in `spring-jdbc` and `spring-r2dbc`.","closed","type: bug,","sbrannen","2021-05-12T09:37:32Z","2021-05-12T11:13:42Z"
"","26941","FlightRecorderApplicationStartup is not thread safe","The `ApplicationStartup` class can be called from different threads when request scope beans are used. I think that `FlightRecorderApplicationStartup` could fail in such situations.  See https://github.com/spring-projects/spring-boot/issues/25792 for a similar issue in Spring Boot's `BufferingApplicationStartup`","closed","in: core,","philwebb","2021-05-14T06:42:09Z","2021-06-01T13:13:49Z"
"","27031","Document that class-level @ResponseStatus is inherited by @ExceptionHandler methods","The [Javadoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseStatus.html) of `@ResponseStatus` doesn't mention that when `@ResponseStatus` is applied to a class then it is inherited also by `@ExceptionHandler` annotated methods.","closed","in: web,","hrybs","2021-06-07T09:24:23Z","2021-06-08T16:39:24Z"
"","27786","Remove JamonPerformanceMonitorInterceptor support","The [JAMon](https://github.com/stevensouza/jamonapi) project doesn't seem really active anymore. Last update was (almost) 2 years ago, by the time Spring 6 will be released this will be 3 years. I'm not even sure if it fully supports new java versions or API versions released after that.   In the current day and age there are more sophisticated solutions like JavaMelody, Micrometer, Sentry.io to name a few. It might be of consideration to drop this native support (maybe donate the interceptor to the JAMon project).","closed","in: core,","mdeinum","2021-12-08T15:07:53Z","2021-12-14T10:07:23Z"
"","27356","change string http header to enum","thanks","closed","type: enhancement,","ydh6226","2021-09-03T16:07:47Z","2021-12-02T11:34:30Z"
"","27218","Fix typo in Javadoc in AbstractHandlerMapping","Thank you","closed","type: task,","ydh6226","2021-07-28T12:30:14Z","2021-07-30T11:34:49Z"
"","27376","Spring-RSocket: unexpected IllegalReferenceCountException on requestChannel response error","Terminating channel response immediately with error leads to unexpected refcnt exception, plus 2  other exceptions (delivered through different code paths) which make little sense in local ""catch all"" handler - original outbound error should only be delivered to remote side, and not manifest itself locally.   ``` 2021-09-08 20:26:07.881 ERROR 80757 --- [or-http-epoll-2] reactor.core.publisher.Operators         : Operator called default onErrorDropped  io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1         at io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:74)         at io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:138)         at io.netty.util.AbstractReferenceCounted.release(AbstractReferenceCounted.java:76)         at org.springframework.messaging.rsocket.annotation.support.MessagingRSocket.lambda$handleAndReply$5(MessagingRSocket.java:176) ```  ``` 2021-09-08 20:26:07.882 ERROR 80757 --- [or-http-epoll-2] reactor.core.publisher.Operators         : Operator called default onErrorDropped  java.util.concurrent.CancellationException: Outbound has terminated with an error         at io.rsocket.core.RequestChannelResponderSubscriber.onError(RequestChannelResponderSubscriber.java:765)         at reactor.core.publisher.FluxSwitchOnFirst$SwitchOnFirstControlSubscriber.onError(FluxSwitchOnFirst.java:877) ```  ``` 2021-09-08 20:26:07.874 ERROR 80757 --- [or-http-epoll-2] o.s.m.h.i.reactive.InvocableHelper       : No exception handling method  java.lang.RuntimeException: plain error         at example.service.Service.channel(Service.java:16) ```  [Reproducer](https://github.com/mostroverkhov/springboot-repros) with 2.5.4  `./server.sh` (contains above stacktraces), `channel_error.sh`","open","in: messaging,","mostroverkhov","2021-09-08T20:30:40Z","2021-11-10T09:11:31Z"
"","27174","update branch","sync master to branch","closed","status: invalid,","pangwen","2021-07-14T23:33:17Z","2021-07-15T08:41:55Z"
"","27687","Passing a plain POJO to AnnotationConfigApplicationContext creates a Singleton/Prototype bean","Steps to reproduce  **_Scenario 1:_** : Singleton beans 1. Create a Java Pojo   ``` public class Reader {  	public Reader() { 		 	} } ```  2. Create AnnotationConfigApplicationContext by supplying Pojo class like below  ``` public class Application {  	public static void main(String[] args) {  		try(var context = new AnnotationConfigApplicationContext(Reader.class, JLabel.class)) { 		 		System.out.println(""Get singleton reader bean: ""+context.getBean(""reader"").hashCode()); 		System.out.println(""Get singleton reader bean: ""+context.getBean(""reader"").hashCode()); 		System.out.println(""Get singleton reader bean: ""+context.getBean(""reader"").hashCode()); 		System.out.println(""Get singleton reader bean: ""+context.getBean(""reader"").hashCode()); 		 		 		// Another example on JLABEL class 		 		System.out.println(""Get singleton JLabel bean: ""+context.getBean(""JLabel"").hashCode()); 		 		System.out.println(""Get singleton JLabel bean: ""+context.getBean(""JLabel"").hashCode());  		}catch(Exception e) { 			System.err.print(e); 		} 	}  } ``` Here is a sample output   > Get singleton reader bean: 1048855692 > Get singleton reader bean: 1048855692 > Get singleton reader bean: 1048855692 > Get singleton reader bean: 1048855692 > Get singleton jlabel bean: 2119891622 > Get singleton jlabel bean: 2119891622  **Why does AnnotationConfigApplicationContext create a bean from a POJO, this behavior is not mentioned anywhere is document either. Is this the default behavior ? **   **_Scenario 2:_** : Configuration class without @Configuration  Another example with a configuration class without @configuration Annotation like below   1. Create a POJO ``` public class AnotherPojo {  	public AnotherPojo() { 		 	} } ``` 2. Create config class without @Configuration.   ``` public class SomeConfiguration {  	@Bean 	public AnotherPojo anothe		context.close();rPojo() { 		return new AnotherPojo(); 	} } ``` 3. Create AnnotationConfigApplicationContext ``` public class Application {  	public static void main(String[] args) {  		try(var context = new AnnotationConfigApplicationContext(SomeConfiguration.class)) { 		 		// through config class without @Configuration 		System.out.println(""Get singleton anotherPojo through config: ""+context.getBean(""anotherPojo"").hashCode()); 		System.out.println(""Get singleton anotherPojo through config: ""+context.getBean(""anotherPojo"").hashCode()); 		}catch(Exception e) { 			System.err.print(e); 		} 		 	}  } ``` This is the output   > Get singleton anotherPojo through config: 739973450 > Get singleton anotherPojo through config: 739973450    **_Scenario 3:_** Prototype bean with only @Scope   1. create a class with only @Scope  @Scope(""prototype"") ``` public class Writer {  	public Writer() { 	} 	 }  ```  2. Create AnnotationConfigApplicationContext ``` public class Application { public static void main(String[] args) { 		 		try (var context = new AnnotationConfigApplicationContext(Writer.class)) { 			 			System.out.println(""Get prototype writer bean: ""+context.getBean(""writer"")); 			System.out.println(""Get prototype writer bean: ""+context.getBean(""writer"") 			System.out.println(""Get prototype writer bean: ""+context.getBean(""writer"")); 		} catch (Exception e) { 			System.err.print(e); 		}  	} ```   Here is the sample output:  > Get prototype writer bean: org.entitylabs.beans.Writer@44ebcd03 > Get prototype writer bean: org.entitylabs.beans.Writer@6356695f > Get prototype writer bean: org.entitylabs.beans.Writer@4f18837a   Spring version used : 5.3.12  Also, source code is attachment for all three scenarios   [01-singleton-beans-test.zip](https://github.com/spring-projects/spring-framework/files/7546912/01-singleton-beans-test.zip) [02-configuration-bean.zip](https://github.com/spring-projects/spring-framework/files/7546913/02-configuration-bean.zip) [03-prototype-beans.zip](https://github.com/spring-projects/spring-framework/files/7546914/03-prototype-beans.zip)","closed","for: stackoverflow,","entitylabs","2021-11-16T14:05:45Z","2021-11-16T14:42:13Z"
"","27278","Using lazy ConfigurableEnvironment to reduce unnecessary object creation","StandardEnvironment will create systemProperties/systemEnvironment PropertySource.  AnnotationConfigApplicationContext default create the StandardEnvironment, but actually didn't use it(replaced by setEnvironment)  Maybe we should change and SpringApplication.createApplicationContext and AnnotationConfigApplicationContext (pass existed Environment) ?  ref：  ``` AnnotationConfigApplicationContext(AbstractApplicationContext).getEnvironment() line: 319 AnnotationConfigApplicationContext(AbstractApplicationContext).getEnvironment() line: 1 AnnotatedBeanDefinitionReader.getOrCreateEnvironment(BeanDefinitionRegistry) line: 296 AnnotatedBeanDefinitionReader.(BeanDefinitionRegistry) line: 71 AnnotationConfigApplicationContext.() line: 66 NativeConstructorAccessorImpl.newInstance0(Constructor, Object[]) line: not available [native method] NativeConstructorAccessorImpl.newInstance(Object[]) line: 62 DelegatingConstructorAccessorImpl.newInstance(Object[]) line: 45 Constructor.newInstance(Object...) line: 423 BeanUtils.instantiateClass(Constructor, Object...) line: 204 BeanUtils.instantiateClass(Class) line: 139 SpringApplication.createApplicationContext() line: 585 SpringApplication.run(String...) line: 310 ```  ``` AnnotationConfigApplicationContext(AbstractApplicationContext).setEnvironment(ConfigurableEnvironment) line: 307 AnnotationConfigApplicationContext.setEnvironment(ConfigurableEnvironment) line: 111 SpringApplication.prepareContext(ConfigurableApplicationContext, ConfigurableEnvironment, SpringApplicationRunListeners, ApplicationArguments, Banner) line: 365 SpringApplication.run(String...) line: 311 SpringApplication.run(Class[], String[]) line: 1247 SpringApplication.run(Class, String...) line: 1236  ```","open","in: core,","qxo","2021-08-13T17:58:27Z","2021-11-11T09:22:58Z"
"","26880","WebFlux loosing content of the reactive context","SpringBoot 2.4.5, spring-boot-starter-webflux  `WebFilter` places a value into reactive context at the beginning of the request processing and retrieves it after. It works fine when request is handled by `Controller` but if the request is made to the non-existent path (no `Controller` is mapped to the request path) the value is missing in the reactive context (`ctx.get()` call fails).  `WebFilter` code is:  ```java @Component public class CorrelationIdFilter implements WebFilter {     public static final String CORRELATION_ID_HEADER_NAME = ""X-correlationId"";     private final Logger logger = LoggerFactory.getLogger(getClass());      @Override     public Mono filter(ServerWebExchange exchange, WebFilterChain chain) {         exchange.getResponse().beforeCommit(() -> Mono.deferContextual(ctx -> {             logger.info(""### Setting response header"");             exchange.getResponse().getHeaders().add(CORRELATION_ID_HEADER_NAME, ctx.get(CORRELATION_ID_HEADER_NAME));             return Mono.empty();         }));          return chain.filter(exchange)                 .contextWrite(ctx -> {                     String correlationId = UUID.randomUUID().toString();                     logger.info(""### CorrelationId generated: {}"", correlationId);                     return ctx.put(CORRELATION_ID_HEADER_NAME, correlationId);                 });     } }  ```   Code to reproduce: https://github.com/maximdim/webflux-context  Specifically `HomeControllerTest.testNonExistingPath`","closed","status: invalid,","maximdim","2021-04-29T18:14:04Z","2021-05-04T15:08:44Z"
"","27381","Configured as a single instance, but instantiated twice","spring.version=5.2.7.RELEASE  ``` public class Service15 {    public Service15(){     System.out.println(""service15 init"");   } } ```  ``` public class Service15Factory implements FactoryBean, BeanFactoryAware {     private BeanFactory beanFactory;     public Service15Factory(){         System.out.println(""serviceFactory15 init"");     }     @Override     public Object getObject() throws Exception {         beanFactory.getBean(""service16"");         return new Service15();     }      @Override     public Class getObjectType() {         return Service15.class;     }      @Override     public void setBeanFactory(BeanFactory beanFactory) throws BeansException {         this.beanFactory = beanFactory;     } } ``` ``` public class Service16 {     private Service15 service15;     public Service16(){         System.out.println(""service16 init"");     }     public void setService15(Service15 service15){         this.service15 = service15;     } } ``` configuration：  ```xml          ``` I created three classes,service15 will be created by getObject of `Service15Factory`, and `Service16` dependent on service15,service15 will be Initialized twice.Is this a bug?","closed","for: stackoverflow,","chenzhongyu11","2021-09-10T09:14:07Z","2021-09-15T08:46:03Z"
"","27754","Fix transitive dependency on  Java EE 8 JAX-B API in spring-webmvc test compile classpath","spring-webmvc has the Java EE 8 JAX-B API on its test compile classpath (through dom4j)  see https://github.com/spring-projects/spring-framework/issues/27685","closed","type: task,","xixingya","2021-12-01T11:14:37Z","2021-12-02T13:24:23Z"
"","27373","Spring-RSocket: potential server file descriptors exhaustion with idle connections","Spring-RSocket server accepts idle connections that never send anything, then stay forever because initial frame is not received  and server seemingly lacks timeout for handshake.  Bad clients may open arbitrary number of idle connections that exhaust server's available file descriptors, make It unable to accept further connections.  With [reproducer](https://github.com/mostroverkhov/springboot-repros) on 2.5.4 client opens 10k idle connections that are never timed out by server.  `./server.sh` , `idle_connections.sh`","closed","for: external-project,","mostroverkhov","2021-09-08T20:36:17Z","2021-12-21T18:41:49Z"
"","27241","MongoTemplate -> Upsert() method intermittently throws duplicate key exception","Spring-data-mongodb version: 2.2.0.RELEASE  Issue: MongoTemplate#upsert(Query query, Update update, Class entityClass) method intermittently throws org.springframework.dao.DuplicateKeyException.  Things I have checked:  - There is only one index in my mongo doc which is the @Id index - I am querying with the above index in the upsert method call - There is already a document existing with this id in the collection (i.e. this is not insert scenario), hence not the same as https://jira.mongodb.org/browse/SERVER-21006?focusedCommentId=1065415&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-1065415","closed","for: stackoverflow,","rahul-jangra","2021-08-04T13:46:54Z","2021-08-05T05:39:45Z"
"","27659","why spring-beans GroovyBeanDefinitionReader does not find grovvy","spring-beans 2.3.3-release does not included groovy dependency？","closed","in: core,","ChenKangQiang","2021-11-09T13:23:24Z","2021-11-09T13:27:07Z"
"","27427","Spring-RSocket: server memory overflow with request-stream","Spring's RSocket server terminates with OutOfMemoryError if bad client starts request-stream, then sends series of small requestN frames without reading response from socket.   Trivial reproducer is at [stream-overflow](https://github.com/mostroverkhov/springboot-repros/tree/develop/dos-stream-overflow) using springboot 2.5.4  `./server.sh`, `stream_overflow.sh`","open","in: messaging,","mostroverkhov","2021-09-17T12:53:15Z","2021-11-10T09:11:31Z"
"","27428","Spring-RSocket: server memory overflow with request-response","Spring's RSocket server terminates with OutOfMemoryError if bad client sends requests without reading responses from socket.   Trivial reproducer is at [response-overflow](https://github.com/mostroverkhov/springboot-repros/tree/develop/dos-response-overflow) using springboot 2.5.4  `./server.sh`, `response_overflow.sh`","open","in: messaging,","mostroverkhov","2021-09-17T12:53:33Z","2021-11-10T09:11:32Z"
"","27097","Consider ""wss"" and ""https"" for secure flag in Forwarded header checks","Spring's `ForwardedHeaderFilter` handles the header value `X-Forwarded-Proto: wss` incorrectly. The class has hardcoded checks for ""http"" and ""https"", which is in line with the widely held assumption that these are the only valid values (see e.g. [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and other sources when searching for the header name on the web).  But `X-Forwarded-Proto` is not standardized, and at least one popular proxy, Traefik, has decided to use ""ws"" and ""wss"" in the header, see https://github.com/traefik/traefik/issues/6388. We have run into problems with Spring because of that. Also Tomcat has added ""ws""/""wss"" as supported values: https://github.com/apache/tomcat/pull/311  I suggest that ""wss"" should be a supported value and handled consistently like ""https"".  `ForwardedHeaderFilter` and its dependency `UriComponentsBuilder.fromHttpRequest(request)` have hardcoded checks for ""http"" and ""https"" in multiple places ([[1]](https://github.com/spring-projects/spring-framework/blob/ddbb7c1b5b003018ee4ebd483ca4a22dd60a53c7/spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java#L241-L244), [[2]](https://github.com/spring-projects/spring-framework/blob/ddbb7c1b5b003018ee4ebd483ca4a22dd60a53c7/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L884-L887)). Depending on which other `X-Forwarded-*` headers are present, it maps a request on port 443 and `X-Forwarded-Proto: wss` to the following `ServletRequest` properties: `scheme=wss, port=80, secure=false` or `scheme=wss, port=443, secure=false`. This seems clearly incorrect.  Based on my observations I would propose that `X-Forwarded-Proto: wss` gets mapped into the `ServletRequest.scheme` value ""https"" (and ""ws"" -> ""http"") because that seems the most compatible way. Leaving ""wss"" in the `ServletRequest.scheme` seems to lead to problems. A same-origin check that compares the value of the `Origin` header (where ""https"" would be the protocol) with the servlet request url would fail. I also know of at least one library that fails completely when it encounters `scheme=wss` in the `ServletRequest` object.","closed","type: enhancement,","jhyot","2021-06-24T16:48:10Z","2021-07-13T15:38:50Z"
"","26915","Can't subscribe on system channel in Spring Websocket","Spring Websocket 5.3.5  ---   I'd like to subscribe to the system channel so I can leverage the RabbitMQ stomp [/temp-queue/](https://www.rabbitmq.com/stomp.html#d).   What I need is something like RabbitTemplate#sendAndReceive. But it seems Spring Webscoket [drops all none recognized system channel messages](https://github.com/spring-projects/spring-framework/blob/355d394d7fff72844445839a7d8d2b359aec0ced/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java#L1045) ```Java       if (!getSystemSubscriptions().containsKey(destination)) { 	      if (logger.isDebugEnabled()) { 		      logger.debug(""Got message on \""system\"" connection with no handler: "" + 				      accessor.getDetailedLogMessage(message.getPayload())); 	      } 	      return;       } ``` Since the destination is random I hope there's a chance that I can register a callback to handle all ""no handler messages"".  Thanks","open","in: web,","topikachu","2021-05-09T14:39:43Z","2021-11-10T11:43:12Z"
"","26909","spring-context-indexer doesn't support Java records","Spring version: 5.3.6 JDK: 16.0.1  It seems that spring-context-indexer library doesn't support Java records. If I declare a record as Spring bean:  ``` @Component public record ServiceManager() {} ```  then **META-INF/spring.components** doesn't contain entry for this type. And Spring fails to load it during startup. I looked into source code and the following blocks seem to responsible for that:  CandidateComponentsIndexer:  ``` private static final Set TYPE_KINDS =  Collections.unmodifiableSet(EnumSet.of(ElementKind.CLASS, ElementKind.INTERFACE)); ```  IndexedStereotypesProvider:  ``` 	@Override 	public Set getStereotypes(Element element) { 		Set stereotypes = new LinkedHashSet(); 		ElementKind kind = element.getKind(); 		if (kind != ElementKind.CLASS && kind != ElementKind.INTERFACE) { 			return stereotypes; 		} ```","closed","type: enhancement,","sergey-morenets","2021-05-07T20:30:26Z","2021-05-11T13:50:42Z"
"","26911","Ignore comments when searching for SQL statement delimiter in ScriptUtils","Spring Version: 5.3.4 JDK: 15  The spring utility class ```org.springframework.jdbc.datasource.init.ScriptUtils``` falsely interepts single quote literals found within block comments of SQL resource files.  To understand the impact of this bug, I'll illustrate a scenario.  **schema.sql**  ```sql /*     It's function is as follows.. */  ALTER TABLE public.User ADD CONSTRAINT USER_PK PRIMARY KEY(id);  ...  ```  From the resource file above, let's assume that the statement delimiter is that of ```ScriptUtils.DEFAULT_STATEMENT_SEPARATOR``` (';') and, accordingly, default comment block start & end separators are used as well ('/*  ...  */').  Let's also make another assumption: the single quote found in the block comment within the ```schema.sql``` resource file is the only single quote in the entire resource file.  In my java utility class, my goal is to execute the statements in my resource file against a given JDBC connection. It would look something as follows:  ```java Resource resource = new ClassPathResource(""classpath:schema.sql"", Thread.currentThread().getContextClassLoader()); EncodedResource encoded = new EncodedResource(resource, ""UTF-8""); ScriptUtils.executeSql (getConnection(), encoded); ```  Where ```getConnection()``` corresponds to my JDBC connection (assume it works accordingly).   Accordingly, I would be met with a fault that looks similar to the following:  ``` org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement... ALTER TABLE public.User ADD CONSTRAINT; ; nested exception is org.postgresql.util.PSQLException: ERROR: syntax error at end of input Position: 47 ``` Notice how in the error message, it displays a **partial** SQL statement of what is intended.  This is because the ```.executeSql(...)``` function call defaulted to its FALLBACK_STATEMENT_SEPARATOR, ""\n"". How do I know this?  The following is a fraction of code that is currently contained, at the time of writing this, is found within the ```.executeSql(...)``` internal call:  ```java if (separator == null) { 	separator = DEFAULT_STATEMENT_SEPARATOR; } if (!EOF_STATEMENT_SEPARATOR.equals(separator) && !containsSqlScriptDelimiters(script, separator)) { 	separator = FALLBACK_STATEMENT_SEPARATOR; } ```  So I did a bit of digging and exploring within the internal check to ```containsSqlScriptDelimiters(...)``` and found the following:  ```java public static boolean containsSqlScriptDelimiters(String script, String delim) { 		boolean inLiteral = false; 		boolean inEscape = false;  		for (int i = 0; i < script.length(); i++) { 			char c = script.charAt(i); 			if (inEscape) { 				inEscape = false; 				continue; 			} 			// MySQL style escapes 			if (c == '\\') { 				inEscape = true; 				continue; 			} 			if (c == '\'') { 				inLiteral = !inLiteral; 			} 			if (!inLiteral && script.startsWith(delim, i)) { 				return true; 			} 		}  		return false; 	} ```   The problem here is that it does not distinguish between literal single quotes from within block comments and executable statements. This is an issue because, going back to my resource file: ```schema.sql```, since I declared only a single literal quote within my inital block comment, the parsing fails to acknowledge the separator delimiter ( ';', in this case) within my executable portion (it's waiting for the end literal character!) and falls back to using the FALLBACK_STATEMENT_SEPARATOR.   Here's the workaround I'm currently using:  ```sql /*     It\'s function is as follows.. */  ALTER TABLE public.User ADD CONSTRAINT USER_PK PRIMARY KEY(id);  ...  ```  Escape single quotes within comments (for now)!","closed","type: bug,","mmelk057","2021-05-08T17:42:56Z","2021-05-14T12:44:11Z"
"","26884","Remove dependency on java.desktop and other modules","Spring requires the `java.desktop` module to be present at Java runtimes only so that it can use the classes in the java.beans package.  Would be a good start for modernizing Spring apps on a post Java 9+ era of modules if Spring could at least work on slim Java runtimes produced with `jlink`.   Other modules to consider adjusting the dependency are `java.naming`, `java.xml`, `java.sql`, `jdk.*`, `java.instrument`, `java.management`,`java.rmi`, `java.scripting`.   This is not about making Spring compatible with Java SE modules. This is only to allow developers to have smaller Java runtimes created with jlink.  In an ideal world, a Java runtime, created with the following `jlink` command should be sufficient to run a Spring Boot Hello World with the Web dependency:  ``` $ jlink \         --add-modules java.base,java.logging \         --strip-debug \         --no-man-pages \         --no-header-files \         --compress=2 \         --output /javaruntime ```","open","type: enhancement,","brunoborges","2021-04-29T17:27:09Z","2022-06-14T23:22:44Z"
"","27829","Add a way to register the need for runtime reflection, resources, proxying, and serialization on components","Spring Native has a component called `NativeConfigurationRegistry` that offers a programmatic API to register the need for reflection, resources that are to be shipped in the native image, proxies as well as classes that should be `Serializable`.  We'd like to revisit this contract and make less native specific as we believe that such information could be useful elsewhere.  Such an infrastructure could land in `spring-core` as it is rather high-level and focused on classes and resources. The actual processing of the registry, for instance, to write GraalVM-specific configuration files is not in the scope of this issue.","closed","theme: aot,","snicoll","2021-12-16T16:17:30Z","2022-01-25T14:48:35Z"
"","27870","Make `H2SequenceMaxValueIncrementer` compatible with H2 database 2.0.x","Spring JDBC is currently not compatible with 2.0.x of H2. This creates problems for users that want to upgrade. See e.g.  - https://github.com/spring-cloud/spring-cloud-task/issues/821 - https://github.com/spring-projects/spring-boot/issues/29034  I've adjusted `H2SequenceMaxValueIncrementer` such that it works with both 1.4 and 2.0 and adjusted some test DDL scripts such that they work with both H2 versions and HSQL.  I've also written a test for the incrementer as it is currently seems not to be covered by any test. I was uncertain whether it should be added to  `DataFieldMaxValueIncrementerTests` as that class uses mocks for all data sources instead of embedded databases.  The complete build is successful for the currently used H2 version 1.4.200. With version 2.0.204, the tests in `spring-jdbc` and `spring-test` also pass. However, the tests in `spring-r2dbc` fail with 2.0.204. But that is not related to the changes in the test DDL scripts.","closed","type: enhancement,","hpoettker","2022-01-01T22:10:40Z","2022-01-07T18:34:46Z"
"","27346","spring expression How can we avoid special treatment when adding and multiplying strings and numbers?","spring expression 5.2.9  How can we avoid special treatment when adding and multiplying strings and numbers?  now:  ![image](https://user-images.githubusercontent.com/28465958/131602467-263b1651-c658-408f-ae50-15cbc2149cc6.png)  ![image](https://user-images.githubusercontent.com/28465958/131602651-5cd1fc85-c85b-4f49-89fc-cd1f7681e216.png)","closed","","Joyonline","2021-09-01T02:37:15Z","2021-11-23T07:26:47Z"
"","27001","Fix @Transactional examples regarding method visibility","Spring documentation ""*Data Access*"", paragraph ""*1.4.6. Using @Transactional*"" contains incorrect description of **@Transactional** annotation that is used on a class level and incorrect corresponding code snippets. * According to source codes of *AnnotationTransactionAspect* and *ProxyTransactionManagementConfiguration* the **@Transactional** annotation when used on a class level is only applied to public method even if we use AspectJ. * The are 2 incorrect code snippets that show class level **@Transactional** annotation for package-private methods.","closed","type: documentation,","hrybs","2021-05-29T20:08:10Z","2021-05-30T15:16:40Z"
"","27553","Introduce TypeFilterUtils for processing @ComponentScan.Filter","Spring Data leverages `ComponentScan.filter` for repository scanning while implementing the filter annotation parser itself.   That arrangement has lead to differences in implementations such as the lack for `*Aware` callbacks (see spring-projects/spring-data-commons#2481). It would be good to be able to reuse `ComponentScanAnnotationParser` to ensure consistency for `@Filter` support across projects leveraging `ComponentScan`-like functionality.","closed","type: enhancement,","mp911de","2021-10-13T06:57:40Z","2021-10-21T12:29:15Z"
"","27701","Retrieve MethodMetadata for all user-declared methods in the order of declaration","Spring Data has a use-case in which it requires a stable method order (ordering of methods within a class file). To detect method ordering, it extended Spring Framework's `ClassMetadata` and ASM visitors to expose `Set getMethods()`.  After removal of `AnnotationMetadataReadingVisitor`, there's no extension point available and Spring Data would have to hold a copy of all involved components to determine the method order.  It would be good to have access to `MethodMetadata` from `ClassMetadata`, ideally as `MethodMetadata[] getMethods()` or `Collection`.  See for further reference:  https://github.com/spring-projects/spring-data-commons/blob/788457c90132ae7ca893791d091279faa8e76abe/src/main/java/org/springframework/data/type/MethodsMetadata.java  https://github.com/spring-projects/spring-data-commons/blob/788457c90132ae7ca893791d091279faa8e76abe/src/main/java/org/springframework/data/type/classreading/DefaultMethodsMetadataReader.java#L121-L162","closed","type: enhancement,","mp911de","2021-11-19T07:38:21Z","2021-12-15T12:40:00Z"
"","27765","When trying to inject collection with generic type, some beans are not injected","Spring Boot version: 2.5.5 Spring core version: 5.3.10  When trying to inject collection with generic type, some beans are not injected.  - All beans are proxied by interface - Bean not injected into the collection is also autowired as another field  ```java public class TestObject { } ```  ```java public interface TestBoc { } ```  ```java public class TestObjectA extends TestObject { } ```  ```java public class TestObjectC extends TestObject { } ```  ```java import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.transaction.annotation.Isolation; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional;  @Component(""testObjectABoc"") @Scope(proxyMode = ScopedProxyMode.INTERFACES) @Transactional(value = ""transactionManager"", propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, timeout = 300) public class TestObjectABocImp implements TestBoc { } ```  ```java import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.transaction.annotation.Isolation; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional;  @Component(""testObjectCBoc"") @Scope(proxyMode = ScopedProxyMode.INTERFACES) @Transactional(value = ""transactionManager"", propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, timeout = 300) public class TestObjectCBocImp  implements TestBoc { } ```  ```java import java.util.List; import javax.annotation.Resource; import org.springframework.stereotype.Component;  @Component public class TestMntBocImp implements TestMntBoc { 	@Resource 	TestBoc testObjectABoc; 	 	@Resource 	List","open","status: feedback-provided,","beancracker","2021-12-05T19:12:12Z","2022-07-14T14:15:04Z"
"","27448","Inconsistent validation order for different inputs and authorization","Spring Boot version: 2.5.4  Consider the following controller:  ```java @RestController @Validated public class FooController {      @PutMapping(         value    = ""/lorem/{loremId}"",         consumes = ""text/csv"",         produces = ""application/json""     )     @PreAuthorize(""@authz.isAuthorizedForXyz(#loremId, #ipsumId)"")     public ResponseEntity handlePutBar(@PathVariable @Size(max = 16) String loremId,                                                   @RequestParam(name = ""ipsumId"") @Size(max = 32) String ipsumId,                                                   @RequestBody @Valid BarsHolder barsHolder) {         // ...     } } ```  In this case only _barsHolder_ is validated before the method _isAuthorizedForXyz()_ is called for authorization. Both _loremId_ and _ipsumId_ are validated afterwards, straight before entering the controller logic. Basically, the method used for authorization is receiving unvalidated input here.  (Adding `@Valid` prior to _loremId_ / _ipsumId_ won't change behavior...)  Enhancement:  Validate all input parameters before authorization logic is applied as already done for `@RequestBody` annotated parameters. This allows to have validation logic consistently on the controller method.  Related:  https://github.com/spring-projects/spring-security/issues/6545 https://github.com/spring-projects/spring-boot/issues/10157","closed","in: web,","flix-","2021-09-22T12:07:48Z","2022-07-27T13:07:59Z"
"","27057","Support injecting Map Entries into Map object","Spring boot supports injecting List elements into List object. Could we have the same function for Map?  It would be similar behavior to [Guice's ProvidesIntoMap](https://google.github.io/guice/api-docs/4.1/javadoc/com/google/inject/multibindings/ProvidesIntoMap.html)","open","in: core,","yunjizhong","2021-06-11T18:28:47Z","2021-11-12T14:18:39Z"
"","27694","Move Spring Boot's JsonParser utility over to Spring Core","Spring Boot has a `JsonParser` that can be used for ""quick-and-dirty"" conversion from String to `Map`, e.g. for configuration data that comes in as JSON. I find it very useful and it seems like it would fit better in Framework as a very low-level utility. If we don't want the optional dependencies for the JSON libraries we could at least add the abstraction and the JDK-only implementation for lightweight parsing.","closed","in: core,","dsyer","2021-11-17T12:18:40Z","2021-11-29T15:54:24Z"
"","27277","Automatic metrics configuration for WebMvc in non-boot environments","Spring Boot has `WebMvcMetricsFilter` and `WebMvcMetricsAutoConfiguration` that ""magically"" instruments all RequestMappings and similar with Micrometer metrics.  It would be great if this was possible to do in a core Spring project too.  _(On a general note, I find this happens often now: Boot gets new tricks and features which just as well could have been introduced in core Spring, and benefit both types of projects. This is sad.)_  PS: I find the solution for this instrumenting to be a bit .. high level? One would maybe have thought that Spring easily could have instrumented this on a lower level - directly on the mappings - thereby directly taking advantage of the knowledge of the path with path variables etc.","closed","theme: observability,","stolsvik","2021-08-13T13:28:50Z","2022-07-27T14:38:33Z"
"","27258","Write a new Getting Started Guide for Spring MVC without Spring Boot","Spring [Getting Started Guides](https://spring.io/guides#getting-started-guides) only explain how to create Spring Boot applications.  There should be a new tutorial explaining how to build a [simple Spring MVC application](https://spring.io/guides/gs/serving-web-content/) without Spring Boot, using either Java configuration or XML configuration.","closed","status: declined,","danilopiazza","2021-08-11T11:28:57Z","2021-08-11T15:36:33Z"
"","27648","PartialMatchHelper ignores type of path variable","Spring 5.3.8  ``` @PostMapping(""/foo/bar"") void doSomething(){..}  @GetMapping(""/foo/{id}"") Foo getFoo(@PathVariable Long id) {..} ```  For   `OPTIONS /foo/bar`  PartialMatchHelper will return both mappings, but it should only return the PostMapping.","closed","status: declined,","Ickbinet","2021-11-06T14:01:20Z","2022-01-18T09:19:23Z"
"","27619","Efficient webjars version resolution natively in Spring","Spring (MVC and Webflux) has a `ResourceResolver` abstraction that can be used to resolve the versions in webjars, avoiding the need to maintain the version explicitly in 2 or more places (build file and HTML source). E.g. (from Petclinic):  ```html   ```  Resolves to `classpath:/META-INF/resources/webjars/jquery//jquery.min.js` at runtime.  Spring Boot carries the responsibility of configuring the resource resolver, and currently it uses the `webjars-locator-core` (https://github.com/webjars/webjars-locator-core) library to do that, so version resolution only works if that library is on the classpath. The `WebJarsAssetLocator` from that library has a very broad and powerful API for locating files inside webjars, but there are some issues, namely:  1. It is fairly inefficient, since it scans the whole `/META-INF/resources/webjars` classpath on startup (in a constructor!). 2. It has 2 awkward dependencies (github classpath scanner and jackson) 3. It doesn't work in a native image (https://github.com/spring-projects-experimental/spring-native/issues/157) because of the classpath scanning  But we don't need `webjars-locator-core` to just do version resolution, which is all Spring Boot offers, because webjars have a very well-defined structure. They all have a `pom.properties` with the version in it, and they only use a handful of well-known group ids, so they are easy to locate. It might be a good idea to implement it in Framework, since it is so straightforward and only depends on reading resources from the classpath.  All of the issues above could be addressed just by providing a simpler version resolver natively (and configuring the resource config in a native image with a hint).","closed","for: external-project,","dsyer","2021-10-28T08:28:20Z","2022-07-27T21:47:16Z"
"","27677","""assertBeanFactoryActive then use BeanFactory "" is not a atomicity operation","sorry , my english is poor。  I came across a scene    | thread-1                                        | Thread-2       | | ---------------------------------------------------- | -------------- | | assertBeanFactoryActive                              |                | |                                                      | close  context | | getBeanFactory().getBean(name);  (create bean again) |                |","open","in: core,","shenjianeng","2021-11-11T15:04:37Z","2021-11-12T14:00:48Z"
"","27676","atomicity operation for BeanFactory","sorry , my english is poor。  I came across a scene    | thread-1                                        | Thread-2       | | ---------------------------------------------------- | -------------- | | assertBeanFactoryActive                              |                | |                                                      | close  context | | getBeanFactory().getBean(name);  (create bean again) |                |","closed","","shenjianeng","2021-11-11T13:31:07Z","2021-11-23T07:26:55Z"
"","27675","atomicity operation for BeanFactory","sorry , my english is poor。  I came across a scene    | thread-1                                        | Thread-2       | | ---------------------------------------------------- | -------------- | | assertBeanFactoryActive                              |                | |                                                      | close  context | | getBeanFactory().getBean(name);  (create bean again) |                |","closed","","shenjianeng","2021-11-11T12:56:08Z","2021-11-23T07:26:55Z"
"","27673","atomicity operation for BeanFactory","sorry , my english is poor。  I came across a scene    | thread-1                                        | Thread-2       | | ---------------------------------------------------- | -------------- | | assertBeanFactoryActive                              |                | |                                                      | close  context | | getBeanFactory().getBean(name);  (create bean again) |                |","closed","","shenjianeng","2021-11-11T09:51:55Z","2021-11-23T07:26:54Z"
"","26918","Bug Fix the port regular expression in'UriComponentsBuilder'.","Sorry I've checked a bug in a commit I've fixed earlier.(https://github.com/spring-projects/spring-framework/pull/26905) This bug was reported in #26910. If there are'Url Query' and'Url Fragments', it is a normal case, but a bug occurs. I have fix this.","closed","status: superseded,","glqdlt","2021-05-10T02:59:57Z","2022-02-08T10:10:09Z"
"","27215","Fix JDK proxy causing controller to fail to register","Some scenarios require JDK proxy, but the controller cannot be registered if JDK proxy is used. I have seen the problem mentioned in the previous issue, but the solution is to have the user change the configuration to force the cglib proxy to be enabled. I think this is not a good solution.","closed","status: invalid,","wangkaijin","2021-07-27T02:20:58Z","2021-07-28T08:32:17Z"
"","27745","ApplicationEvent#getSource does not need to be guarded against a null source","SmartApplicationListener getSource should Never be null，ApplicationEvent is extend from EventObject source is set by Constructor ![image](https://user-images.githubusercontent.com/26990889/143799797-a173a7fc-8d43-4537-9a63-f0099c815334.png)","closed","status: declined,","liaozan","2021-11-29T02:35:09Z","2021-11-29T12:48:36Z"
"","27214","Introduce `setDefaultCharacterEncoding()` in `MockHttpServletResponse`","Since: Spring 5.2 and the deprecation of `APPLICATION_JSON_UTF8` Mediatype.  Although the content type 'application/json' can only be encoded in UTF-8 (which is why the explicit encoding was deprecated), `MockHttpServletResponse#getCharacterEncoding()` returns 'ISO-8859-1'.  This breaks any test code that inspects or uses the `getCharacterEncoding()` directly. But more unexpectedly, it breaks `MockHttpServletResponse#getContentAsString()`, because the response is decoded with ISO-8859-1 instead of UTF-8. Explicitly using `MockHttpServletResponse#getContentAsString(Charset fallbackCharset)` works correctly.  The Javadoc for `getContentAsString()` is (to me) somewhat ambiguous:  > Get the content of the response body as a String, using the charset specified for the response by the application, either through HttpServletResponse methods or through a charset parameter on the Content-Type.  ""using the charset specified for the response by the application"" could imply UTF-8 for 'application/json', because that must always be the value for JSON. If using this interpretation, then the method breaks its Javadoc contract.  Previously, this was fixed for `ContentResultMatchers#json(String)` but not for `MockHttpServletResponse#getContentAsString()` (https://github.com/spring-projects/spring-framework/issues/23622). Another report was closed by the submitter without any resolution except using an explicit charset (https://github.com/spring-projects/spring-framework/issues/23851).  If it is not possible to fix this for JSON specifically, I would appreciate if somehow a default value could be set (instead of always defaulting to ISO-8859-1).","closed","type: enhancement,","jhyot","2021-07-26T12:28:14Z","2021-07-30T12:08:31Z"
"","26996","No replacement of deprecated CronSequenceGenerator.isValidExpression","Since Spring 5.3 the `CronSequenceGenerator` is deprecated, including the static `isValidExpression` function. The replacement class `CronExpression` does not contain this helper method, thus throwing us back to a: `try { ; return true; } catch (Exception e) { return false; }` I would like to see the static checker method back, either on `CronExpression` or on another class. Thanks!","closed","in: core,","ewjmulder","2021-05-28T09:29:38Z","2021-05-31T13:01:38Z"
"","27422","Drop RPC-style remoting: Hessian, HTTP Invoker, JMS Invoker, JAX-WS","Since most of our RPC-style remoting support has been officially and/or effectively deprecated for several years, let's remove it for 6.0 M1 right away (which also reduces subpackage overload in several modules a bit).","closed","type: task,","jhoeller","2021-09-16T16:50:35Z","2021-09-17T07:14:56Z"
"","27435","Update FacesRequestAttributes.java","simplify the multiple ’else if‘ case","closed","status: declined,","xbwjml","2021-09-18T07:11:55Z","2021-09-20T05:50:37Z"
"","27334","simplify if statement","simplify if statement in ResolvableType class","closed","status: declined,","SeaItFover","2021-08-30T08:00:41Z","2021-11-11T09:15:44Z"
"","26885","Add PreFlightRequestWebFilter","Similar to `CorsWebFilter` there should be a `PreFlightWebFilter` in Spring Framework that leverages the `PreFlightRequestHandler` API.  Related gh-26257 spring-projects/spring-boot#24541","closed","type: enhancement,","rwinch","2021-04-30T19:43:46Z","2021-05-07T15:48:45Z"
"","27423","Drop outdated Servlet-based integrations: Commons FileUpload, FreeMarker JSP support, Tiles","Several integration options in our web support date back to the 2005 era, not having seen maintenance in recent years and apparently not getting an upgrade for Jakarta Servlet (in the `jakarta.servlet` package namespace). As part of our Jakarta EE 9+ revision, we'll therefore drop support for CommonsMultipartResolver, FreeMarkerServlet-style JSP taglib support and Tiles views.","closed","type: task,","jhoeller","2021-09-16T16:55:19Z","2021-09-17T07:14:58Z"
"","27252","Sever-Sent Events (SseEmitter) works unexpectedly on Undertow","Sever-Sent Events (SseEmitter) works unexpectedly on Undertow server (spring-boot-starter-undertow). The method `SseEmitter.onError()` cann't call back when client disconnected from server. This phenomenon does not happen when using Tomcat server.  # Code  ```java package com.shang.sse.controller;  import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;  import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit;  /**  * Created by shangwei2009@hotmail.com on 2021/8/5 10:50  */ @RestController @Slf4j public class SseController {      private static final ExecutorService pool = Executors.newSingleThreadExecutor();      @GetMapping(""/sse"")     public SseEmitter sse() {         final SseEmitter emitter = new SseEmitter();          emitter.onError(throwable -> {             log.error(""onError"");         });         emitter.onCompletion(() -> {             log.info(""onCompletion"");         });          pool.execute(() -> {             try {                 for (int i = 0; i < 3; i++) {                     TimeUnit.SECONDS.sleep(1);                     emitter.send(i);                 }                 emitter.complete();             } catch (Exception ex) {                 emitter.completeWithError(ex);             }         });          return emitter;     } }  ```  # Result  When disconnected from client, the `onError` and `onCompletion` message both not printed immediately.   ![result](https://user-images.githubusercontent.com/11643284/128293739-22e9f039-f4c2-48bf-8395-476e10990274.png)  After a while, only the `onCompletion` message printed.   ![after](https://user-images.githubusercontent.com/11643284/128293762-52089753-5fc8-4062-83d8-cf57952fa1d6.png)  # Attachments  [undertow-sse-demo.zip](https://github.com/spring-projects/spring-boot/files/6936029/undertow-sse-demo.zip)","closed","","waitshang","2021-08-05T05:07:03Z","2021-11-23T07:26:46Z"
"","27727","Document the difference in generics resolution between `@Autowired` and `beanFactory.getBeanProvider`","See the sample project for code example: https://github.com/snicoll-scratches/demo-unresolved-type-fallback  If a bean is defined with an unresolved generic such as `NumberHolder` and the injection point is defined as `NumberHolder`, `@Autowired` is able to inject the bean whereas a `getIfAvailable` call on `getBeanProvider` returns `null`.  It looks like an inconsistency in the dependency resolution algorithm.","closed","in: core,","snicoll","2021-11-24T08:14:05Z","2021-12-08T08:25:50Z"
"","27305","Document when `prepareTestInstance()` is invoked when using the `SpringMethodRule`","See the discussion in https://github.com/spring-projects/spring-boot/issues/27693#issuecomment-902783233.","closed","type: documentation,","sbrannen","2021-08-20T15:43:54Z","2021-08-22T14:00:44Z"
"","27383","Bean definition extending FactoryBean with generics is not injected","See spring-projects-experimental/spring-native#1022 for background.  While working on spring-native, we've found a behavior that might be a bug in the core container support for the functional registration of beans (through instance suppliers).  Some of our samples are failing with `org.springframework.beans.factory.NoSuchBeanDefinitionException`. The missing bean is of type `PluginRegistry` and is contributed through a `PluginRegistryFactoryBean` (with `T` and `S` being concrete types: 'org.springframework.plugin.core.PluginRegistry').  While debugging the issue, we've found that the current code generation process in spring-native contributes that definition to the context with:   ```java BeanDefinitionRegistrar.of(""relProviderPluginRegistry"", ResolvableType.forClassWithGenerics(PluginRegistryFactoryBean.class, LinkRelationProvider.class, LinkRelationProvider.LookupContext.class)).withFactoryMethod(HateoasConfiguration.class, ""relProviderPluginRegistry"")             .instanceSupplier(() -> context.getBean(HateoasConfiguration.class).relProviderPluginRegistry()).register(context); ```  The important part is that we're declaring the `PluginRegistryFactoryBean` type as the `ResolvableType` target type in the definition; this seems to confuse the core container in the `org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency` and especially the `org.springframework.beans.factory.support.DefaultListableBeanFactory#findAutowireCandidates` sequence. Instead of considering the generic type of the bean produced by the `FactoryBean` and if it's assignable to the required type for the injection point, this seems to only consider the provided target type.  This might be linked with the fact that we're heavily using the `instanceSupplier` mechanism instead of factory methods.  We've validated that providing the type produced by the Factory directly as the target `ResolvableType` (so 'PluginRegistry' instead of 'PluginRegistryFactoryBean' solves the issue.  We need to consider this case and know whether this behavior is expected or if this shows a problem with the current suport of instance suppliers.","open","in: core,","bclozel","2021-09-10T12:36:46Z","2021-11-11T09:23:00Z"
"","27384","Fix bug fix icon in changelog configuration","See spring-io/github-changelog-generator#63","closed","type: task,","snicoll","2021-09-10T22:00:36Z","2021-09-10T22:02:14Z"
"","27072","Allow BeanUtils#instantiateClass inlining with native","See related comment [here](https://github.com/oracle/graal/issues/2500#issuecomment-860330959). Per @jhoeller guidance, `LinkageError` should be rare enough to allow `BeanUtils#instantiateClass` not catching it. See also #27070 related issue.","closed","type: enhancement,","sdeleuze","2021-06-17T09:03:53Z","2021-11-10T14:22:00Z"
"","27261","Allow application to continue w/o using cache if  backing cacheing service is down","See https://stackoverflow.com/questions/29003786/how-to-disable-redis-caching-at-run-time-if-redis-connection-failed and https://stackoverflow.com/questions/44183715/how-to-disable-caching-at-runtime-if-couchbase-connection-failed?noredirect=1&lq=1  I don't want my application's ability to function to be conditional on the health of the cache. When something goes wrong with connecting to whatever is backing the cache (ie redis) the application should be able to recompute the value gracefully (if configured to do so)","open","in: core,","jbotuck","2021-08-11T16:54:19Z","2021-11-10T12:35:34Z"
"","27044","AOP auto-proxying with proxyTargetClass=true and introduction advice does not work for JDK proxy targets","See https://github.com/spring-projects/spring-retry/issues/214#issuecomment-857078807  Spring retry uses AOP auto proxy to add a proxy for `@Retryable` methods; the code unconditionally wraps the target in a new proxy. If `proxyTargetClass` is true (default in Spring Boot), the `AbstractAutoProxyCreator` does not add interfaces if the target is a JDK proxy.  ```java if (!proxyFactory.isProxyTargetClass()) { 	if (shouldProxyTargetClass(beanClass, beanName)) { 		proxyFactory.setProxyTargetClass(true); 	} 	else { 		evaluateProxyInterfaces(beanClass, proxyFactory); 	} } ```  This causes, for example, `@Retryable` on a spring data repository to create an invalid bean  ```java @Repository public interface TestRepository extends CrudRepository {  	@Override 	@Retryable(maxAttempts = 4) 	List findAll();  } ```  The inner (spring-data) proxy implements `TestRepository`,  etc, but the outer proxy only implements the `Retryable` interceptor interface.  ``` The bean 'testRepository' could not be injected as a 'com.example.demo.TestRepository' because it is a JDK dynamic proxy that implements: 	org.springframework.data.repository.CrudRepository ```  Although the error message is wrong (https://github.com/spring-projects/spring-boot/issues/26821), it is because the proxy only implements `Retryable`.  Perhaps the `AbstractAutoProxyCreator` could detect that the target is a JDK proxy and copy the interfaces (even when `proxyTargetClass`) is true?","closed","in: core,","garyrussell","2021-06-09T13:43:46Z","2021-07-09T11:27:55Z"
"","27038","Clarify that baseName in ResourceBundleMessageSource does not support multiple locations","See https://github.com/spring-projects/spring-boot/issues/26712 for background.   There are various places where multiple locations can be searched for and this one is delegating ultimately to `ResourceBundle#getBundle`. It would be nice if the reference guide was extra explicit about the fact that multiple bundles at the same location in the classpath in different modules won't be merged.","closed","in: core,","snicoll","2021-06-08T12:09:28Z","2021-07-13T12:09:01Z"
"","27815","Upgrade Dokka to 1.6.0","See https://github.com/Kotlin/dokka/releases/tag/v1.6.0.","closed","type: task,","sdeleuze","2021-12-14T15:48:49Z","2021-12-14T15:49:57Z"
"","27480","Fail Gradle build for Javadoc warnings","See https://bugs.openjdk.java.net/browse/JDK-8200363","closed","type: task,","sbrannen","2021-09-28T07:49:11Z","2021-09-29T14:58:13Z"
"","27493","Scheduler does not function with zoneid set","Scheduler schedules a job with the cron expression evaluating time from the local machine. However, if you set the cron expression and zone, it does not function as expected.  Ex:   @Scheduled(cron = ""\${server.indexer.cron.expression}"") works fine according to local timezone  and Scheduled(cron = ""\${server.indexer.cron.expression}"", zone = ""UTC"") does not function.  Version : 5.3.9 Springboot version : 2.5.4","closed","in: core,","nitinmuteja","2021-09-29T09:58:16Z","2021-10-15T13:03:58Z"
"","27160","Allow BeanDefinitionBuilder to set an instance supplier with a ResolvableType","Right now we can't build a bean definition with a `ResolvableType` and its related instance supplier.","closed","type: enhancement,","snicoll","2021-07-12T12:05:24Z","2021-07-12T12:08:46Z"
"","27430","Accept header of the request does not populate content-type header of the response","Right here in the code, it does not consider the headers of the request to build the headers of the response: https://github.com/spring-projects/spring-framework/blob/958eb0f964ddef1ff1440fd10c5cb850f6ee96db/spring-webmvc/src/main/java/org/springframework/web/servlet/function/AbstractServerResponse.java#L89  I'm building a ServerResponse inside my RouterFunction handler as follows: ```java ServerResponse.ok().body(dto); ``` This results in an empty Content-Type header of the response, so it falls back to JSON. But if my client wants XML and specifies so in their request's Accept header, they still get JSON.  Here's my workaround: ```java ServerResponse.ok()     .contentType(request.headers().accept().stream().findFirst().orElse(null))     .body(dto); ``` Now the internals select the correct message converter based on the content type.","closed","status: declined,","Sam-Kruglov","2021-09-17T14:45:49Z","2021-09-20T09:15:52Z"
"","27896","Use try-with-resources where feasible","Revert and polishing https://github.com/spring-projects/spring-framework/commit/c04fa858fc3344b8d8a9b01b3b07ce0d00d51676","closed","in: core,","quaff","2022-01-06T07:51:21Z","2022-01-06T14:14:03Z"
"","27605","Update AbstractAdvisingBeanPostProcessor.java","resolve @async circular dependencies problem","open","status: feedback-provided,","yuanyu1997","2021-10-25T00:57:02Z","2021-11-02T11:48:48Z"
"","27603","Update AbstractAdvisingBeanPostProcessor.java","resolve @async circular dependencies problem","closed","","yuanyu1997","2021-10-24T07:06:24Z","2021-11-23T07:26:52Z"
"","27602","Update AbstractAdvisingBeanPostProcessor.java","resolve @async circular dependencies","closed","","yuanyu1997","2021-10-24T06:47:50Z","2021-11-23T07:26:52Z"
"","27601","Update AbstractAdvisingBeanPostProcessor.java","resolve @Async circular dependencies","closed","","yuanyu1997","2021-10-24T05:24:53Z","2021-11-23T07:26:52Z"
"","27600","Update AbstractAdvisingBeanPostProcessor.java","resolve @Async circular dependencies","closed","","yuanyu1997","2021-10-24T05:07:40Z","2021-11-23T07:26:51Z"
"","27807","Remove unnecessary @SuppressWarnings","RequiredAnnotationBeanPostProcessor is removed  see https://github.com/spring-projects/spring-framework/commit/4750a9430cdae9156d1e7fc32cec2c11ba2b8514","closed","type: task,","quaff","2021-12-13T08:05:25Z","2021-12-13T08:38:35Z"
"","27686","Early removal of 5.x-deprecated code","Removing deprecated code in the `5.x` generation early in the 6.x milestone will give a chance to early adopters to adapt or raise concerns during their migration.","closed","type: task,","snicoll","2021-11-16T11:03:52Z","2021-11-18T08:20:05Z"
"","27389","Fix wording in Javadoc of ClientResponse.mutate()","Removed an extra ""the"" and replaced the word ""request"" with ""response""","closed","type: documentation,","mustafau","2021-09-12T11:29:22Z","2021-09-13T12:32:12Z"
"","27505","Do we really need `@Sql` to be repeatable?","Related: #17907   Affected code:  https://github.com/spring-projects/spring-framework/blob/04eed155cdf10dd943818c343c9fd49fb6d8fcf4/spring-test/src/main/java/org/springframework/test/context/jdbc/Sql.java#L71  Question:  Order of execution of SQL statement if often extremely important. The larger the test base and the number of programmers, the more confusion may be created.  `@Sql` annotation already supports `String[] value` attribute, which means the implementor **can** input the SQL scritps to run in their desired order.  I haven't found relevant documentation yet, but I remember from the old times of Java when there was no explicit guarantee on reflection ordering. Ie. earlier JVMs and in general any third-party JVM can decide the reflection's order of scanning, at least with class members. This results in defining class members in a certain order in the source file, but enumerating them via reflection in another order.  Arrays are ordered by design, so using `@Sql` with an explciit array works as designed everywhere.  I wouldn't bet that repeated `@Sql` annotations always yield the desired order of execution no matter the JVM.","closed","status: invalid,","djechelon","2021-10-01T13:16:44Z","2021-10-01T16:55:13Z"
"","27728","DataAccessUtils result accessors with Optional return value","Related to #724, `DataAccessUtils` should provide an `optionalResult` method for `Collection` as well as `Stream` arguments (and also for `Iterator` because we need that internally anyway), returning a corresponding `Optional` wrapper or `Optional.empty()`.  In addition, a `singleResult` overload for a `Stream` argument (and for `Iterator`) would complete the overall arrangement in `DataAccessUtils`.","closed","status: superseded,","jhoeller","2021-11-24T13:57:01Z","2021-11-26T10:54:03Z"
"","27801","Polish ExceptionHandlerMethodResolver mapping","Refactor exception resolver cache get/null/put opration into single call.","closed","type: task,","Drezir","2021-12-11T15:52:14Z","2021-12-15T17:22:44Z"
"","27208","Reduce visibility of constructors in ScriptException","Reduce the visibility of the constructors in `org.springframework.jdbc.datasource.init.ScriptException`.  There is currently no need to use `public` visibility here.","closed","status: declined,","xiaoliang-liu","2021-07-24T03:45:53Z","2021-07-26T10:12:10Z"
"","26940","Avoid autoboxing in CacheAspectSupport","Reduce boxing once.","closed","status: declined,","chenqimiao","2021-05-14T03:21:53Z","2021-05-21T03:29:29Z"
"","27393","TransactionSynchronizationUtils should allow certain Thowable types to propagate","Recently, I was looking at the code of Transaction and found that `TransactionSynchronizationUtils` is too rude to execute user callback code, and all the exceptions that may be thrown in the callback method are directly swallowed.   ##### org.springframework.transaction.support.TransactionSynchronizationUtils#triggerBeforeCompletion ```java public static void triggerBeforeCompletion() { 		for (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) { 			try { 				synchronization.beforeCompletion(); 			} 			catch (Throwable ex) { //  Swallow all Throwable，but ThreadDeath/VirtualMachineError should throw. 				logger.error(""TransactionSynchronization.beforeCompletion threw exception"", ex); 			} 		} 	} ```  ##### org.springframework.transaction.support.TransactionSynchronizationUtils#invokeAfterCompletion ```java public static void invokeAfterCompletion(@Nullable List synchronizations, 			int completionStatus) {  		if (synchronizations != null) { 			for (TransactionSynchronization synchronization : synchronizations) { 				try { 					synchronization.afterCompletion(completionStatus); 				} 				catch (Throwable ex) { 					logger.error(""TransactionSynchronization.afterCompletion threw exception"", ex); 				} 			} 		} 	} ```  ### Strategy used in Tomcat  ```java public static void handleThrowable(Throwable t) {         if (t instanceof ThreadDeath) {             throw (ThreadDeath) t;         }         if (t instanceof StackOverflowError) {             // Swallow silently - it should be recoverable             return;         }         if (t instanceof VirtualMachineError) {             throw (VirtualMachineError) t;         }         // All other instances of Throwable will be silently swallowed     } ```","open","status: feedback-provided,","PerJoker","2021-09-13T09:08:42Z","2021-09-28T08:47:44Z"
"","27657","Fix grammar in webflux-webclient.adoc","Quick grammar fix.","closed","type: documentation,","Abdullah8006","2021-11-09T12:18:47Z","2021-11-09T16:15:42Z"
"","27729","Add optional type  parameter to @Value annotation","Proposed idea to **@Value** annotation  Today the typical use of **@Value** annotation is:  ``` @Value(""my.property"") private String myProperty; ```  But properties is never validated on load. And a lot of boilerplate code is used to validate if properties is valid or not and of the correct type. An my view is that the configuration is either valid or not And if it is not valid, don't bother to start application.  I would like to propose an optional extra parameter to the annotation  Namely ""type""  so   ``` public interface TypeAdapter { 	public T convert(String value); } ```  Example  ``` @Value(""my.property"", new LongTypeAdapter()) private Long myProperty; ```  The typeadapter will only be called if the String value is not null and the typeAdapter instance is not null.  A requirement must be that field class must be of the same type as generic type T in _TypeAdapter_, otherwise an exception is thrown.  This can easily give a a long list of TypeAdapter implementations  - IntegerTypeAdapter - FileTypeAdapter - DirectoryTypeAdapter - HostTypeAdapter - EmailTypeAdapter - ListTypeAdapter - CertificateFileFileAdapter - EnumTypeAdapter - .....  There by have way to know that configuration is valid at startup.  Im no expert in annotation and I have tried to finde the @Value AnnotationProcessor to make a more complete example,  but without success.  An optional way to do it is to make a new annotation. `@ValueTyped(value,type)`  So not to mess with the existing @Value annotation.","closed","in: core,","rockwool73","2021-11-24T14:05:08Z","2021-11-29T10:16:56Z"
"","27016","Adjust expected IdentityHashMap sizes in ClassUtils","Proposed change aimed to keep coherence between variable declaration  and static initialization code, which inserts 9 values, not 8, into  these two variables.","closed","in: core,","aaguilera","2021-06-03T07:44:54Z","2021-06-04T08:49:08Z"
"","27274","missing table of content in spring framework document","Problem: The table of content in spring framework document are missing.  Where: https://docs.spring.io/spring-framework/docs/current/reference/html/web.html ![image](https://user-images.githubusercontent.com/11763554/129317473-ae7f7129-1554-4055-8845-6d9abf8fdb4c.png) Wanted: The TOC come back pls","closed","status: duplicate,","zlqpzww","2021-08-13T07:00:57Z","2021-08-13T07:53:28Z"
"","26968","Refactor ConcurrentBeanWrapperTests to use @RepeatedTest","Problem:  No problem is found in this test. This is a refactoring suggestion that simplifies test design by eliminating a repetition structure whose increment was not being used during the repetition and can be replaced by an annotation.  Solution:  The `@RepeatedTest` annotation provides the total number of repetitions desired. Each invocation of a repeated test behaves like the execution of a regular `@Test` method with full support for the same lifecycle callbacks and extensions, which improves test design, eases future maintenance activities when needed, and better informs which repetition failed.","closed","type: task,","eas5","2021-05-22T00:26:44Z","2021-05-23T16:42:11Z"
"","27769","Deprecate StringUtils::trimWhitespace","PR #27703 has made `StringUtils::trimWhitespace` trivial, as the method now delegates to `String::strip`. The only significance that `trimWhitespace` accepts `null`. We should deprecate `trimWhitespace` in favor of `String::strip`.   Similarly, we should deprecate `StringUtils::trimLeadingWhitespace` in favor of `String::stripLeading`, and `StringUtils::trimTrailingWhitespace` in favor of `String::stripTrailing`.","closed","type: enhancement,","poutsma","2021-12-06T12:15:01Z","2021-12-06T12:39:36Z"
"","27064","DefaultPathSegment allows shared empty parameters map to be mutated","PR #27063 made me aware of the following existing bug.  If a `PathContainer` is created using `Options.MESSAGE_ROUTE`, `DefaultPathSegment#parameters()` returns a mutable map which allows the user to modify the contents of the static, shared `EMPTY_PARAMS` map in `DefaultPathContainer`.","closed","type: bug,","sbrannen","2021-06-15T13:18:15Z","2021-06-15T14:07:26Z"
"","27018","Support $$ quotes in JDBC and R2DBC ScriptUtils","PostgreSQL (and maybe others?) support multi-line strings using `$$` delimiters.  `ScriptUtils.executeSqlScript` does not support it, and will break at the next `;`.  This makes it very difficult to get database initialization to work with function definitions like the following.  ```sql CREATE FUNCTION example() RETURNS text AS $$ DECLARE     value text := 'Hello World!'; BEGIN     RETURN value; END; $$ LANGUAGE plpgsql; ```  https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING","open","status: feedback-provided,","OrangeDog","2021-06-03T14:16:32Z","2021-06-04T15:07:44Z"
"","27006","Add disabling the Nagle's algorithm","Please add disabling Nagle's algorithm in the `spring-boot-starter-websocket` module for websockets, such as `Socket.setTcpNoDelay()` from the Java standard library. There are situations when you need to very often transfer data as quickly as possible, and this algorithm creates completely unnecessary delay","open","in: web,","Dannik7771","2021-05-30T20:37:05Z","2021-11-10T11:43:12Z"
"","27023","Upgrade to ASM master","Picking up a few recent optimizations from https://gitlab.ow2.org/asm/asm/commits/master","closed","type: dependency-upgrade,","jhoeller","2021-06-04T08:38:31Z","2021-06-07T10:29:42Z"
"","27860","Fix reference to JBoss AS Javadoc","Our build is failing as those two links stop servicing Javadoc:  * https://docs.jboss.org/jbossas/javadoc/4.0.5/connector/ * https://docs.jboss.org/jbossas/javadoc/7.1.2.Final/  I've temporarily removed them from `main` but other branches should be affected as well.","closed","type: task,","snicoll","2021-12-27T16:34:41Z","2022-01-10T09:13:50Z"
"","27828","Provide repackaged version of JavaPoet","Our AOT processing needs a code generation library and we're quite happy using JavaPoet in Spring Native. It would be quite unusual for the core container to have a direct dependency on a third-party so the plan is to jarjar it in `org.springframework.javapoet` in the `spring-core` module.","closed","theme: aot,","snicoll","2021-12-16T16:05:35Z","2022-02-10T15:02:30Z"
"","27421","Issue: org.springframework.expression.spel.CodeFlow.toBoxedDescriptor() throws ""Unexpected non primitive descriptor V"" while trying to create a MethodReference for a method with primitive void return type.","org.springframework.expression.spel.CodeFlow.toBoxedDescriptor() throws ""Unexpected non primitive descriptor V"" while trying to create a MethodReference for a method with primitive void return type.  For the same when using a java.lang.Void as the return type the exception is not thrown!  I think while checking for primitives using method org.springframework.expression.spel.CodeFlow.toDescriptor() V is returned for a primitive void return type, but the returned V is not handled in org.springframework.expression.spel.CodeFlow.toBoxedDesciptor() method.","open","in: core,","rgrvontela","2021-09-16T14:47:57Z","2021-11-10T10:53:14Z"
"","27747","@GetMapping not synchronous with integration test","org.springframework.boot       spring-boot-starter-parent       2.4.4          I created a new method in a RestController and Adnotated it with @GetMapping(value = ""someValue"", consumes = MediaType.APPLICATION_JSON_VALUE). The rest is irrelevant.  I also created an integration test for the method and used @MockMvc to test that the method was called for the path ""someValue"".  That fact is that the integration test worked like a charm so I didn't test to see if running the application and accessing the ""someValue"" path would worked, I believed the integration test.  What happened is that in local environment or any other environment, the Controller didn't pick up the path and so it breaked the flow of the application.  The problem: ""consumes = MediaType.APPLICATION_JSON_VALUE"".  The solution: delete ""consumes = MediaType.APPLICATION_JSON_VALUE"".  Expected behaviour: The integration test should have failed!","closed","for: stackoverflow,","stefan574","2021-11-29T08:05:35Z","2021-11-29T09:15:45Z"
"","27335","Optimize for single TransactionSynchronization","Optimize TransactionSynchronizationManager.getSynchronizations() to avoid sorting and ArrayList creation in case of a single TransactionSynchronization.","open","in: data,","marschall","2021-08-30T11:07:49Z","2021-11-11T09:48:38Z"
"","27900","Simplify HashMap declaration in test fixture","Optimize the initialization of hashmap","closed","type: task,","springmonster","2022-01-07T02:08:56Z","2022-01-07T09:25:23Z"
"","27088","Link to alternate format not rendering","On the main docs page (https://docs.spring.io/spring-framework/docs/current-SNAPSHOT/reference/html/), the link to the other format is not rendering. Rather than a link to the PDF file, it shows `{doc-root}/spring-framework/docs/5.3.9-SNAPSHOT/reference/pdf/index.pdf[PDF]` Perhaps `doc-root` has not been set (the rest looks right). The same is true in the PDF file.   **Affects:** \  ---","closed","","Buzzardo","2021-06-21T16:55:17Z","2021-06-21T17:10:52Z"
"","27610","First request does not reach DispatcherServlet","On some environments the first http request is not processed. On those environments we could reproduce it like: Create a new project on start.spring.io  containing starter-web and starter-actuator. Start application. Call actuator endpoint in postman. First request is not processed. Cancel the first request and then everything works.   java version ""11.0.5"" 2019-10-15 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.5+10-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.5+10-LTS, mixed mode)  macos version: 10.14.6 (18G9323) MacBook Pro (13-inch, 2019, Two Thunderbolt 3 ports) Processor 1,4 GHz Intel Core i5 Memory 16 GB 2133 MHz LPDDR3  springframework.boot: 2.5.6 (also: 2.4.5)","closed","status: invalid,","tmtszo4","2021-10-26T08:00:41Z","2021-10-26T08:38:56Z"
"","27664","Consistently replace String encoding names with StandardCharset arguments","On a related note to gh-27646, our `EncodedResource` should consistently be used with `StandardCharsets` arguments instead of String encoding names. Also, there are `URLEncoder`/`URLDecoder` variants with a `Charset` argument in JDK 10+ now.","closed","type: enhancement,","jhoeller","2021-11-10T10:58:26Z","2021-11-10T15:02:01Z"
"","26953","Update Etag validator","On [RFC7232-2.3.2](https://datatracker.ietf.org/doc/html/rfc7232#section-2.3.2), `StrongValidator` and `WeakValidator` get different comparison result.  >    o  Strong comparison: two entity-tags are equivalent if both are not >       weak and their opaque-tags match character-by-character. >  >    o  Weak comparison: two entity-tags are equivalent if their >       opaque-tags match character-by-character, regardless of either or >       both being tagged as ""weak"".  ![image](https://user-images.githubusercontent.com/29394651/118699877-fdcc9300-b84c-11eb-8b91-d63cba2b7b65.png)  But, `ShallowEtagHeaderFilter.java` always compare the ETag like `Weak Comparison` even if `isWriteWeakETag()` is `false`.  How about adding `Validator` in `ShallowEtagHeaderFilter.java`, and using suitable implementation(`StrongValidator` or `WeakValidator`)?  ---  **Sorry, I worked on old wrong branch, I'll check it again.**","closed","","LOG-INFO","2021-05-18T17:50:00Z","2022-02-18T19:05:40Z"
"","27154","Avoid calling executeBatch() with 0 batch size","Now usign  `org.springframework.jdbc.core.JdbcTemplate#batchUpdate(java.lang.String, org.springframework.jdbc.core.BatchPreparedStatementSetter)` with empty data array may produce exception with some DBs. E. g. with HSQLDB it produce `java.sql.SQLException: statement is not in batch mode`. Suggest avoid it by batchSize checking.","open","in: data,","Li0n13","2021-07-11T14:14:16Z","2021-11-10T11:38:11Z"
"","27823","Use try-with-resources for AutoClosables","Noticed a couple of places that could benefit from try-with-resources.","closed","type: task,","mdeinum","2021-12-16T06:28:55Z","2022-01-04T14:18:25Z"
"","27009","Update README.md","noob learning how to create pull request!","closed","status: invalid,","Jai1708","2021-05-31T19:08:41Z","2021-05-31T19:51:23Z"
"","27889","ServerHttpResponseDecorator does not delegate methods for raw status code","Non-standard HTTP status code has been fixed in #24400. But `ServerHttpResponseDecorator` still not fully implements the raw status code of `ServerHttpResponse`.","closed","type: bug,","figroc","2022-01-05T04:23:14Z","2022-01-12T09:03:06Z"
"","27348","Merge AopTestUtils into AopUtils","Methods in `AopTestUtils` is not only useful for tests.","closed","","quaff","2021-09-01T06:57:35Z","2021-11-23T07:26:48Z"
"","27738","Provide InjectionPoint inside Spring functional bean definition DSL","Meta information about the class or method that is requesting an instance of a managed bean  should be available when using Spring's functional bean definition DSL.  This might be the corresponding `InjectionPoint` or at least the class name of the requesting instance.   ---  One can use a Bean factory function to allow injection of Logger objects into ones Beans, e.g.:  ```kotlin import org.slf4j.* import org.springframework.beans.factory.InjectionPoint import org.springframework.context.annotation.*  @Bean @Scope(""prototype"") fun logger(injectionPoint: InjectionPoint): Logger {   return LoggerFactory.getLogger(       injectionPoint.methodParameter?.containingClass // constructor           ?: injectionPoint.field?.declaringClass // or field injection   ) } ```  This is not possible with the functional bean definition DSL in Kotlin. Neither of the two examples down below work in the most recent version of Spring, unfortunately.  ```kotlin import org.slf4j.* import org.springframework.beans.factory.InjectionPoint import org.springframework.context.support.beans import org.springframework.context.support.BeanDefinitionDsl.Scope.PROTOTYPE  fun beans() = beans {     bean(scope = PROTOTYPE) {         val injectionPoint = ref()              LoggerFactory.getLogger(             injectionPoint.methodParameter?.containingClass // constructor                 ?: injectionPoint.field?.declaringClass // or field injection         )     }      bean(scope = PROTOTYPE) { injectionPoint: InjectionPoint ->         LoggerFactory.getLogger(             injectionPoint.methodParameter?.containingClass // constructor                 ?: injectionPoint.field?.declaringClass // or field injection         )     } } ```   ---  See also this [unanswered question](https://stackoverflow.com/q/70008693/3160089) of StackOverflow. The injection into the factory functions seems to be possible since SPR-14033 / #18605. A minimal reproduction repository can be found on [GitHub](https://github.com/EndzeitBegins/spring-bean-dsl-injection-point). Run `./gradlew bootRun` or `.\gradlew.bat bootRun` on Windows to reproduce the error.","open","in: core,","EndzeitBegins","2021-11-26T18:37:52Z","2021-11-29T18:50:22Z"
"","27217","5.2.x","merge","closed","status: invalid,","asongs","2021-07-28T02:51:41Z","2021-07-28T05:04:27Z"
"","27264","reactor-bom issue","mavenBom ""io.projectreactor:reactor-bom:2020.0.10-SNAPSHOT""  why does this build not use the official version","closed","status: duplicate,","itransform","2021-08-12T02:24:30Z","2021-08-12T07:04:15Z"
"","27315","Many threads blocked on CachingMetadataReaderFactory$LocalResourceCache","many threads blocked on CachingMetadataReaderFactory$LocalResourceCache spring-core-5.0.8.RELEASE **Affects:** \spring-core-5.0.8.RELEASE  ---","open","in: core,","YangyangLi0528","2021-08-23T08:08:00Z","2021-11-11T09:22:59Z"
"","27859","Make task executors implement ExecutorService or ScheduledExecutorService","Make `ThreadPoolTaskExecutor` implements `ExecutorService` and make `ThreadPoolTaskScheduler` implement `ScheduledExecutorService` in order to make these classes more convenient to use.","open","type: enhancement,","qian0817","2021-12-27T08:42:34Z","2022-01-03T15:39:17Z"
"","26998","Lookup method autowiring ignores method's generic info","Lookup method autowiring uses method's result class, not its generic info.  Tested on versions: 5.1.4, 5.3.7, 5.3.8-SNAPSHOT, all affected.  How to reproduce:  ``` package test;  import org.springframework.beans.factory.annotation.Lookup; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.support.GenericApplicationContext; import org.springframework.stereotype.Component;  @Configuration @ComponentScan(basePackageClasses = App.class) public class App {      interface A {}      @Bean A intA() { return new A(){}; }     @Bean A stringA() { return new A(){}; }      @Component abstract static class Comp {         private final A a1;         Comp(A a1) { this.a1 = a1;}         @Lookup(""intA"") abstract A a2();         @Lookup abstract A a3();         void test() {             System.out.println(a1.getClass().getName()); // ok             System.out.println(a2().getClass().getName()); // ok             System.out.println(a3().getClass().getName()); // fails, found 2 beans instead of 1         }     }      public static void main(String [] args) {         GenericApplicationContext context = new AnnotationConfigApplicationContext(App.class);         context.getBean(Comp.class).test();     } } ```  Fixing proposal : ``` Index: spring-beans/src/main/java/org/springframework/beans/factory/support/CglibSubclassingInstantiationStrategy.java =================================================================== diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/CglibSubclassingInstantiationStrategy.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/CglibSubclassingInstantiationStrategy.java --- a/spring-beans/src/main/java/org/springframework/beans/factory/support/CglibSubclassingInstantiationStrategy.java	(revision 93244e9f9d25ea068ab822dd7a0a287e84cf8282) +++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/CglibSubclassingInstantiationStrategy.java	(date 1622203596697) @@ -25,6 +25,7 @@  import org.springframework.beans.BeanInstantiationException;  import org.springframework.beans.BeanUtils;  import org.springframework.beans.factory.BeanFactory; +import org.springframework.beans.factory.ObjectProvider;  import org.springframework.beans.factory.config.ConfigurableBeanFactory;  import org.springframework.cglib.core.ClassLoaderAwareGeneratorStrategy;  import org.springframework.cglib.core.SpringNamingPolicy; @@ -35,6 +36,7 @@  import org.springframework.cglib.proxy.MethodInterceptor;  import org.springframework.cglib.proxy.MethodProxy;  import org.springframework.cglib.proxy.NoOp; +import org.springframework.core.ResolvableType;  import org.springframework.lang.Nullable;  import org.springframework.util.Assert;  import org.springframework.util.StringUtils; @@ -244,8 +246,8 @@  				return (bean.equals(null) ? null : bean);  			}  			else { -				return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) : -						this.owner.getBean(method.getReturnType())); +				ObjectProvider provider = this.owner.getBeanProvider(ResolvableType.forMethodParameter(method, -1)); +				return argsToUse != null ? provider.getObject(args) : provider.getObject();  			}  		}  	} ```","closed","type: enhancement,","sirjoga","2021-05-28T13:41:49Z","2021-05-28T15:32:36Z"
"","27015","Link alternate documentation formats","Link the HTML to the PDF and vice-versa.","closed","type: documentation,","Buzzardo","2021-06-02T17:58:17Z","2021-06-21T15:56:04Z"
"","27048","Issue #26985 change date time default formate","Link of issue: https://github.com/spring-projects/spring-framework/issues/26985  Issue: DateTimeFormatterRegistrar should use ISO formats by default  Currently, if the users want to format the time in ISO format, they need to annotate the controller method by @DateTimeFormat(iso = ISO.DATE_TIME). However, the issue is using ISO format should be a default setting without any configuration. For this issue, I looked into the DefaultFormattingConversionService class and there is an addDefaultFormatters method, which specifies the default handling of date-time values. To make the ISO format the default setting, I first create a DateTimeFormatterRegistrar instance and then invoke setUseIsoFormat(true). Finally, register this formatter through the FormatterRegistry which is passed in as the argument.","closed","in: core,","Yin-Jui","2021-06-10T17:58:37Z","2021-06-11T16:29:21Z"
"","27662","Make the trace logs of `TransactionInterceptor` and `JpaTransactionManager` discern between physical and logical transactions.","Lets say i have the following method:  ``` @Transactional public void transactionCreatingMethod(){   myJpaRepository.findAll(); } ```  Next i enable transaction logging by adding the following to my `application.properties`  ``` logging.level.org.springframework.orm.jpa.JpaTransactionManager=TRACE logging.level.org.springframework.transaction.interceptor = TRACE ``` When i execute the method i would get the following statements.  ``` [TRACE] 2021-11-09 18:05:31.312 [main] TransactionInterceptor - Getting transaction for [config.StartupChecks$$EnhancerBySpringCGLIB$$192e2f3.transactionCreatingMethod] [DEBUG] 2021-11-09 18:05:32.394 [main] JpaTransactionManager - Participating in existing transaction [TRACE] 2021-11-09 18:05:32.394 [main] TransactionInterceptor - Getting transaction for [org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll] ``` The first line states that `transactionCreatingMethod` is getting a transaction opened for it. The second line states that the jpaRepository inside will participates in the existing transaction, so far so good. But then in the third line it says that it opens a new transaction for `findAll`!  This is very confusing and when i first saw these statements i thought i had configured something wrong. But after doing some research it turns out that the transaction for `findAll` is actually a `logical transaction` while the one created for `transactionCreatingMethod` is actually a `physical transaction`. [This is also explained here](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction).  However in the logs both types of transactions are simply referred to as `transaction`. Could these logs be changed so that transactions that participate in an existing transaction be referred to as `logical transaction` and the first transaction that was opened is referred to as `physical` or `database` transaction? That would make the logs much less confusing.","open","in: data,","maurice85","2021-11-09T17:52:19Z","2021-11-10T10:14:12Z"
"","27340","Polish AbstractAspectJAdvisorFactory","Left out invoke the native method.","closed","in: core,","Inmord","2021-08-31T05:13:36Z","2021-08-31T13:57:24Z"
"","27789","WebClient logs ""IllegalStateException: Only one connection receive subscriber allowed"" when multiple requests made within Kotlin coroutine and response status is an error","Kotlin version: 1.5.30 Spring Boot version: 2.5.4 and 2.6.1 Spring Framework version: 5.3.9  When making multiple WebClient requests within a Kotlin coroutine, if one of them fails with a 4xx or 5xx status, there are two errors logged... an expected `WebClientResponseException` and an unexpected `IllegalStateException: Only one connection receive subscriber allowed` from Reactor. A unit test to reproduce the behavior along with the full stack trace are posted below.   There may be other ways to reproduce this error, but in the case below, it only happens if the request is expecting a body and the 4xx response does not contain one. Also, if you comment out the `/path1` request, the `/path2` request fails normally without the additional Reactor exception, even if the 4xx response doesn't contain a body.  Unit test (spring-cloud-contract-wiremock is used to mock the server): ```kotlin @SpringBootTest @AutoConfigureWireMock(port = 8089) class WebClientTest {      private lateinit var webClient: WebClient      @BeforeEach     fun setup() {         webClient = WebClient.builder().baseUrl(""http://localhost:8089"").build()          stubFor(             get(urlPathEqualTo(""/path1"")).willReturn(                 aResponse().withStatus(200)                     .withHeader(""Content-Type"", ""application/json"")                     .withBody(""""""{""data"":""""}"""""")             )         )         stubFor(             get(urlPathEqualTo(""/path2"")).willReturn(                 aResponse().withStatus(400)             )         )     }      @Test     fun test(): Unit = runBlocking {         val result1 = async(Dispatchers.IO) {             webClient.get().uri(""/path1"").retrieve().awaitBody()         }         val result2 = async(Dispatchers.IO) {             webClient.get().uri(""/path2"").retrieve().awaitBody()         }         Pair(result1.await(), result2.await())     } }  data class Response(val data: String) ```  Stack trace: ``` 2021-12-09 10:30:32.618 ERROR 55926 --- [ctor-http-nio-4] reactor.core.publisher.Operators         : Operator called default onErrorDropped  java.lang.IllegalStateException: Only one connection receive subscriber allowed. 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:182) 	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:143) 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) 	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:339) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:172) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onError(FluxMapFuseable.java:334) 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onError(FluxFilterFuseable.java:382) 	at reactor.core.publisher.MonoCollect$CollectSubscriber.onError(MonoCollect.java:144) 	at reactor.core.publisher.FluxMap$MapSubscriber.onError(FluxMap.java:132) 	at reactor.core.publisher.Operators.error(Operators.java:198) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onSubscribe(FluxPeek.java:165) 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:167) 	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:143) 	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) 	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:339) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:74) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:200) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:200) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:200) 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2398) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onSubscribeInner(MonoFlatMapMany.java:150) 	at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onNext(MonoFlatMapMany.java:189) 	at reactor.core.publisher.SerializedSubscriber.onNext(SerializedSubscriber.java:99) 	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onNext(FluxRetryWhen.java:174) 	at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:160) 	at reactor.netty.http.client.HttpClientConnect$HttpIOHandlerObserver.onStateChange(HttpClientConnect.java:414) 	at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:654) 	at reactor.netty.resources.DefaultPooledConnectionProvider$DisposableAcquire.onStateChange(DefaultPooledConnectionProvider.java:201) 	at reactor.netty.resources.DefaultPooledConnectionProvider$PooledConnection.onStateChange(DefaultPooledConnectionProvider.java:457) 	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:628) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:93) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311) 	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.lang.Thread.run(Thread.java:748)   org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from GET http://localhost:8089/path2  	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:196) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ 400 from GET http://localhost:8089/path2 [DefaultWebClient] Stack trace: 		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:196) 		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:213) 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onComplete(FluxDefaultIfEmpty.java:109) 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:150) 		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onComplete(FluxMapFuseable.java:344) 		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onComplete(FluxFilterFuseable.java:391) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1817) 		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:159) 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260) 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) 		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:400) 		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:419) 		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:473) 		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:684) 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:93) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.lang.Thread.run(Thread.java:748) ```","open","in: kotlin,","gtg465x","2021-12-09T15:44:03Z","2022-01-07T12:53:04Z"
"","27333","Simplify if statement","just Simplify if statement, emm, first pr for spring-framework","closed","","SeaItFover","2021-08-30T06:18:35Z","2021-11-23T07:26:47Z"
"","26975","Fix function in URI Links section of ref docs","Just fix the same function invoke like this: ```java URI uri = UriComponentsBuilder         .fromUriString(""https://example.com/hotels/{hotel}?q={q}"")         .build(""Westin"", ""123""); ``` ↓ ```java URI uri = UriComponentsBuilder         .fromUriString(""https://example.com/hotels/{hotel}?q={q}"")         .build(""Westin"", ""123"")         .toUri(); // need to create a URI from this instance ```","closed","status: invalid,","quan7u","2021-05-26T03:05:47Z","2021-05-26T08:35:04Z"
"","27012","Simplify String construction in StringUtils.changeFirstCharacterCase()","Just a tiny optimization allowing String constructor to skip array bounds check.","closed","in: core,","stsypanov","2021-06-02T09:34:19Z","2021-06-24T09:39:11Z"
"","27858","@DirtiesContext does not work when running Spring integration tests in parallel","JUnit5 introduced the support for parallel test execution as described [here](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution).  When running parallel tests with the `@SpringBootTest` annotation t**here is a bug that is causing the caching of the application context, even when using the annotation `@DirtiesContext` to force context re-creation.** Affected spring-boot versions (the one I tried): `2.5.2` and `2.6.2`  I replicated this behavior in the attached Intellij IDEA project.  [junit-parallel-integration-test-bug.zip](https://github.com/spring-projects/spring-boot/files/7762154/junit-parallel-integration-test-bug.zip)  In the project there are 4 tests that are logging when `DummyBean` is created/destroyed to keep track of when the application context is re-created. Steps to reproduce the issue:  1. Launch all the tests in the project. You will see in standard output 4 times the string `Destroying DummyBean` 2. Enable concurrent execution by de-commenting the lines in `junit-platform.properties` (see image) ![image](https://user-images.githubusercontent.com/4816982/147081794-f71e1cc6-e888-49b6-9574-e5718486d69b.png)  3. Launch all the tests again. The tests run in parallel but you will get only one `Destroying DummyBean` in standard output 4. Bonus: if you execute only top-level classes in parallel (i.e. set `junit.jupiter.execution.parallel.mode.default = same_thread`) you will get now 2 logs in standard output --> another clear sign that there is something fishy with parallel execution   Is this known or expected? We were trying to execute integration tests in parallel in order to speed up the performance of test execution that in our case are becoming quite troublesome...   Thanks in advance for any feedback.","closed","status: invalid,","thedarkdestructor","2021-12-22T10:56:32Z","2022-03-04T09:38:43Z"
"","26904","Support enums when using JdbcTemplate with SqlParameterSource","JdbcTemplate delegates parameters binding to `StatementCreatorUtils`, which uses a fallback if sqlType and java type are unknown: https://github.com/spring-projects/spring-framework/blob/582b94d50ec880d06fecd506305c412c2a89b933/spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java#L414  Can we handle enum values as Strings here? It will be consistent in my opinion, because other classes like `BeanPropertyRowMapper` support enums.  It also can be handled in `SqlParameterSource` implementations if getSqlType will return `Types.VARCHAR` for enums.","open","in: data,","belovaf","2021-05-07T00:18:32Z","2021-11-10T11:38:10Z"
"","27559","Incorrect Javadoc in [NamedParameter]JdbcOperations.queryForObject methods regarding exceptions","Javadoc of methods: 1. `NamedParameterJdbcOperations#queryForObject(String, SqlParameterSource, RowMapper)`  https://github.com/spring-projects/spring-framework/blob/main/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.java#L270 2. `NamedParameterJdbcOperations#queryForObject(String, Map, RowMapper)` https://github.com/spring-projects/spring-framework/blob/main/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.java#L289  states that `IncorrectResultSizeDataAccessException` is supposed to be thrown _if the query does not return exactly one row, or does not return exactly one column in that row_. But actually second part, about count of columns, is incorrect. Query can return as many columns as RowMapper can handle. Looks like copy-paste error from methods which accept `Class` instead of `RowMapper`.  Affected version - latest release 5.3.11","closed","type: documentation,","turbanoff","2021-10-14T10:12:43Z","2021-10-19T16:39:27Z"
"","27685","spring-webmvc has the Java EE 8 JAX-B API on its test compile classpath (through dom4j)","It's a transitive dependency of `org.dom4j:dom4j`: https://ge.spring.io/s/rhkh754ui6xpc/dependencies?dependencies=jaxb-api&expandAll&focusedDependency=WzIzLDExMiw1OTg1LFswLDMsWzNdXV0&focusedDependencyView=versions.","closed","status: superseded,","wilkinsona","2021-11-15T15:03:10Z","2021-12-02T09:32:02Z"
"","26882","Build PRs on CI","It would be nice to build PRs on CI so that we get a status of the PR without having to build it ourselves.","closed","type: task,","snicoll","2021-04-30T06:03:09Z","2021-04-30T07:39:25Z"
"","26958","Switch back to parallel thread after WebSession id is generated","It would be nice if there were a way to request the session without creating an instance of one, similar conceptually to `HttpServletRequest#getSession(false)`.  Whenever the session is requested, say like so:  ```java exchange.getSession().filter((session) -> {     if (session.getAttribute(""attribute"") != null) {         // ...     } }) // ... ```  subscription will cause an `InMemoryWebSession` to be constructed. Since this is a blocking operation, it would be nice to avoid it when not needed.  If instead an application could do:  ```java exchange.getSessionOrEmpty().filter((session) -> {     if (session.getAttribute(""attribute"") != null) {         // ...     } }) ```  then the predicate would not be invoked at all and construction of `InMemoryWebSession` would be avoided.","closed","type: enhancement,","jzheaux","2021-05-19T15:12:38Z","2021-06-08T18:14:16Z"
"","27245","Support handling MultipartFile without filename","It would be convenient if Spring controller can handle a multipart file request where filename is empty.  Controller: ``` java @PostMapping(path = ""/upload"", consumes = MediaType.MULTIPART_FORM_DATA_VALUE) @ResponseStatus(code = HttpStatus.CREATED) public String upload1(@RequestPart(""file"") MultipartFile file, @RequestPart(""payload"") Map message) { 	// ... } ```  Client (using RestEasy 2.3.10 multipart which doesn't support passing filename): ``` java ApacheHttpClient4Executor executor = new ApacheHttpClient4Executor(); final String url = ""http://localhost:8080/upload""; ClientRequest clientRequest = executor.createRequest(url);  MultipartFormDataOutput multipartBody = new MultipartFormDataOutput(); multipartBody.addFormData(""file"", getFileBytes(), MediaType.APPLICATION_OCTET_STREAM_TYPE); // no extra parameter for filename in this version multipartBody.addFormData(""message"", ""{\""item-name\"": \""my-cool-file\""}"", MediaType.APPLICATION_JSON_TYPE); clientRequest.body(MediaType.MULTIPART_FORM_DATA_TYPE, multipartBody);  ClientResponse response = clientRequest.post(); ```  The passed multipart body: ``` --bf99dc24-6170-4ddc-9ab5-52d0d13bfa12 Content-Disposition: form-data; name=""file"" Content-Length: 29 Content-Type: application/octet-stream  name;city ""John Doe"";""London"" --bf99dc24-6170-4ddc-9ab5-52d0d13bfa12 Content-Disposition: form-data; name=""message"" Content-Type: application/json  {""item-name"": ""my-cool-file""} --bf99dc24-6170-4ddc-9ab5-52d0d13bfa12-- ```  The above leads to following error in the Spring Controller: ``` WARN 24800 --- [nio-8080-exec-4] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.multipart.support.MissingServletRequestPartException: Required request part 'file' is not present] ```  All works fine when there is a filename in the multipart payload: ``` --gG95MiIJuOydnJq_teLCCqII-IV0l8pZQxzUa Content-Disposition: form-data; name=""file""; filename=""demo.csv"" ```  However in case of environment specifics - it's challgenging to update version of the rest mime support. It might be convinient to be able to process requests without filename (as soon as part name is provided as in the given examples above).","closed","status: declined,","javornikolov","2021-08-05T17:00:41Z","2021-09-27T10:22:51Z"
"","27845","Provide a way to configure KotlinSerializationJsonDecoder","It seems there isn't a way to provide a custom `Json` or set config on `Json` for the `KotlinSerializationJsonDecoder`  Spring Framework 5.3.14  Workaround: ```kotlin @Configuration(proxyBeanMethods = false) class InitConfiguration {      @ExperimentalSerializationApi     @Bean     fun kotlinSerializationJsonDecoder() = KotlinSerializationJsonDecoder(Json {         explicitNulls = false     })  }  @ExperimentalSerializationApi @Configuration class WebConfig(val decoder: KotlinSerializationJsonDecoder) : WebFluxConfigurer {     override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {         super.configureHttpMessageCodecs(configurer)         configurer.defaultCodecs().kotlinSerializationJsonDecoder(decoder)     } } ```","open","in: kotlin,","jamesward","2021-12-22T21:26:28Z","2022-01-15T14:42:49Z"
"","27665","Method invocation skipped when @Scheduled components are invoking @Transactional methods","It seems that when we are trying to call @Transactional methods from @Scheduled methods, the calls simply do not occur.   The @Transactional methods work totally fine when they are being invoked from @Controller REST endpoints within our application.   I wrote two classes like below...  `Component public class StartActionTransactionHelper {      Autowired      ActionRepository repo;          Transactional     public Mono startAction() {        repo.doAction().subscribe();         return null;     } } `  `Component public class StartActionScheduler {      Autowired     StartActionTransactionHelper startActionTransactionHelper;      Scheduled(fixedDelay = 1000)     public void startActions() {         startActionTransactionHelper.startAction();     } }`  If I remove @Transactional, then the code gets invoked, but without being in a Transaction.","open","in: core,","sbchaud","2021-11-08T16:18:13Z","2022-07-28T21:05:35Z"
"","27074","Classes that extend RepresentationModel produce 500 Internal Server Error on webflux stream endpoints","It seems that classes that extend `RepresentationModel` now produce 500 if you access them from an endpoint that returns `Flux`.  You can reproduce this with the following sample application ``` @SpringBootApplication @EnableHypermediaSupport(type = [EnableHypermediaSupport.HypermediaType.HAL], stacks = [WebStack.WEBFLUX]) class HateApplication  @Relation(     itemRelation = ""foo"",     collectionRelation = ""foos"", ) data class Foo(val foo: String) : RepresentationModel()  @RestController @RequestMapping(""/foos"") class FooController {      @GetMapping(produces = [MediaTypes.HAL_JSON_VALUE])     fun fooWithHAl() = findAll()         .collectList()         .map { CollectionModel.of(it) }      @GetMapping(produces = [MediaType.APPLICATION_NDJSON_VALUE])     fun findAll() = Flux.range(0, 10)         .map { Foo(it.toString()) }  }  fun main(args: Array) {     runApplication(*args) } ``` The resulting error is something along ``` org.springframework.http.converter.HttpMessageNotWritableException: No Encoder for [com.example.hate.Foo] with preset Content-Type 'null' 	at org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler.writeBody(AbstractMessageWriterResultHandler.java:181) ~[spring-webflux-5.3.7.jar:5.3.7] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Handler com.example.hate.FooController#findAll() [DispatcherHandler] 	|_ checkpoint ⇢ org.springframework.web.filter.reactive.ServerWebExchangeContextFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ HTTP GET ""/foos"" [ExceptionHandlingWebHandler] Stack trace: 		at org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler.writeBody(AbstractMessageWriterResultHandler.java:181) ~[spring-webflux-5.3.7.jar:5.3.7] 		at org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler.writeBody(AbstractMessageWriterResultHandler.java:105) ~[spring-webflux-5.3.7.jar:5.3.7] 		at org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandler.handleResult(ResponseBodyResultHandler.java:86) ~[spring-webflux-5.3.7.jar:5.3.7] 		at org.springframework.web.reactive.DispatcherHandler.handleResult(DispatcherHandler.java:179) ~[spring-webflux-5.3.7.jar:5.3.7] 		at org.springframework.web.reactive.DispatcherHandler.lambda$handle$2(DispatcherHandler.java:154) ~[spring-webflux-5.3.7.jar:5.3.7] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:125) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1815) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:249) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.complete(MonoIgnoreThen.java:284) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onNext(MonoIgnoreThen.java:187) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onSubscribe(MonoIgnoreThen.java:134) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:192) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:57) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:181) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators.complete(Operators.java:136) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:120) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:281) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:860) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:127) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:180) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.request(MonoPeekTerminal.java:139) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:169) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2193) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:2067) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:96) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onSubscribe(MonoPeekTerminal.java:152) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:448) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:218) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:164) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.netty.http.server.HttpServer$HttpServerHandle.onStateChange(HttpServer.java:915) ~[reactor-netty-http-1.0.7.jar:1.0.7] 		at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:654) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.netty.transport.ServerTransport$ChildObserver.onStateChange(ServerTransport.java:478) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:526) ~[reactor-netty-http-1.0.7.jar:1.0.7] 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:209) ~[reactor-netty-http-1.0.7.jar:1.0.7] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795) ~[netty-transport-native-epoll-4.1.65.Final-linux-x86_64.jar:4.1.65.Final] 		at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:480) ~[netty-transport-native-epoll-4.1.65.Final-linux-x86_64.jar:4.1.65.Final] 		at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378) ~[netty-transport-native-epoll-4.1.65.Final-linux-x86_64.jar:4.1.65.Final] 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar:4.1.65.Final] 		at java.base/java.lang.Thread.run(Thread.java:831) ~[na:na] ```","open","status: feedback-provided,","kschlesselmann","2021-06-07T12:00:32Z","2021-11-08T11:37:34Z"
"","27741","WebFlux ServerResponse does not overwrite already present response headers","It seems like [ResponseEntityResultHandler](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java) behaves differently compared to  [ServerResponseResultHandler](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/support/ServerResponseResultHandler.java) regarding their handling of already present HTTP headers.  For example: [Github](https://github.com/rlndd/spring-responsehandler-issue) ``` java @SpringBootApplication public class ResponseHandlerIssueApplication {      public static void main(String[] args) {         SpringApplication.run(ResponseHandlerIssueApplication.class, args);     }  }  @Component class DefaultNoCacheHeaderFilter implements WebFilter {     @Override     public Mono filter(ServerWebExchange exchange, WebFilterChain chain) {         var headers = exchange.getResponse().getHeaders();         if (headers.getCacheControl() == null) {             headers.setCacheControl(CacheControl.noCache());         }         return chain.filter(exchange);     } }  @RestController class TestController {     @GetMapping(""/responseEntity"")     public Mono cached() {         var rsp = ResponseEntity                 .status(HttpStatus.OK)                 .cacheControl(CacheControl.maxAge(Duration.ofHours(1)))                 .body(""supposed to be cached"");         return Mono.just(rsp);     } }  @Configuration class RouterConfig {     @Bean     public RouterFunction routerFunction() {         return route(GET(""serverResponse""),                 req -> ServerResponse.ok()                         .cacheControl(CacheControl.maxAge(Duration.ofHours(1)))                         .body(BodyInserters.fromValue(""supposed to be cached"")         ));     } } ``` Testing using `curl`: ``` curl -v 'http://localhost:8080/responseEntity' *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /responseEntity HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < Cache-Control: max-age=3600 < Content-Type: text/plain;charset=UTF-8 < Content-Length: 21 < * Connection #0 to host localhost left intact supposed to be cached* Closing connection 0 ``` ``` curl -v 'http://localhost:8080/serverResponse' *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /serverResponse HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < Cache-Control: no-cache < Content-Type: text/plain;charset=UTF-8 < Content-Length: 21 < * Connection #0 to host localhost left intact supposed to be cached* Closing connection 0 ```  As we can see the `/responseEntity` endpoint returns `max-age=3600` for our Cache-Control header. However, `/serverResponse` returns `no-cache`. [ResponseEntityResultHandler](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java#L154) seems to be overriding existing headers and [DefaultServerResponseBuilder](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/DefaultServerResponseBuilder.java#L365) not to.  https://github.com/spring-projects/spring-framework/blob/2f32806bcb6cefa6479074d5fb66cb68043cedc9/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java#L150-L155 https://github.com/spring-projects/spring-framework/blob/2f32806bcb6cefa6479074d5fb66cb68043cedc9/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/DefaultServerResponseBuilder.java#L362-L368  The fix might be trivial, but maybe the intended behavior should be discussed.","closed","type: bug,","rlndd","2021-11-27T17:56:59Z","2021-11-30T12:41:38Z"
"","26976","@ExceptionHandler method not invoked for IOException","It looks like exception is not handled.  I attached the error below. `IOException` is not handled.  ``` 2021-05-26 13:04:24.338  WARN 14216 --- [XNIO-11 task-20] .m.m.a.ExceptionHandlerExceptionResolver : Failed to invoke @ExceptionHandler method: public com.ai.mp.web.rest.errors.ErrorVM com.ai.mp.web.rest.errors.ExceptionTranslator.exceptionHandler(java.io.IOException)  java.io.IOException: UT010029: Stream is closed 	at io.undertow.servlet.spec.ServletOutputStreamImpl.write(ServletOutputStreamImpl.java:136) 	at org.springframework.security.web.util.OnCommittedResponseWrapper$SaveContextServletOutputStream.write(OnCommittedResponseWrapper.java:639) 	at com.fasterxml.jackson.core.json.UTF8JsonGenerator._flushBuffer(UTF8JsonGenerator.java:2039) 	at com.fasterxml.jackson.core.json.UTF8JsonGenerator.flush(UTF8JsonGenerator.java:1051) 	at com.fasterxml.jackson.databind.ObjectWriter.writeValue(ObjectWriter.java:953) 	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.writeInternal(AbstractJackson2HttpMessageConverter.java:286) 	at org.springframework.http.converter.AbstractGenericHttpMessageConverter.write(AbstractGenericHttpMessageConverter.java:106) 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:231) 	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:174) 	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:81) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:113) 	at org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:384) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:59) 	at org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:136) 	at org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:74) 	at org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1222) 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1034) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) 	at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:85) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) 	at com.codahale.metrics.servlet.AbstractInstrumentedFilter.doFilter(AbstractInstrumentedFilter.java:111) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at com.ai.mp.web.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:50) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:317) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:114) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:158) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.session.ConcurrentSessionFilter.doFilter(ConcurrentSessionFilter.java:155) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.csrf.CsrfFilter.doFilterInternal(CsrfFilter.java:124) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:64) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) 	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) 	at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84) 	at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62) 	at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:64) 	at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) 	at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:131) 	at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57) 	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) 	at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46) 	at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64) 	at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60) 	at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77) 	at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43) 	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) 	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) 	at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:119) 	at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292) 	at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81) 	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138) 	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135) 	at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48) 	at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) 	at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272) 	at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81) 	at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104) 	at io.undertow.server.Connectors.executeRootHandler(Connectors.java:332) 	at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:812) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) 	at java.lang.Thread.run(Unknown Source) ```","closed","status: invalid,","Ragunathanbalraj","2021-05-26T07:39:25Z","2021-05-26T08:58:22Z"
"","26917","Introduce soft assertions for MockMvc","It happens very often that MockMvc is used in heavyweight integration tests. It's no use to waste time to check if another condition has been fixed or not. Soft assertion could help a lot to check all conditions at once even if one of them fail.","closed","type: enhancement,","wyhasany","2021-05-09T21:58:55Z","2021-08-23T14:03:53Z"
"","27177","Reference docs missing left-hand side navigation","It displays fine [in 5.3.8](https://docs.spring.io/spring-framework/docs/5.3.8/reference/html/web.html#spring-web) but [in 5.3.9](https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/web.html#spring-web) it's missing.","closed","type: documentation,","rstoyanchev","2021-07-15T08:04:22Z","2021-09-03T11:48:23Z"
"","27183","remove javax.annotation.meta.When","it appears this is found in the findbugs jsr305 annotations my reason why is I want to enable `-Werror` and I'm using java modules `module-info.java` and it appears you can't use `jsr305` as the automatic module name. sadly I don't actually know what `When` does or if there's a replacement. most tools seem to respect annotations named `Nullable` or `NonNull` now.  ``` /home/xeno/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/5.3.8/da9b87dacaa5bbf80fad0f7b483988372a00a152/spring-core-5.3.8.jar(/org/springframework/lang/Nullable.class): warning: Cannot find annotation method 'when()' in type 'Nonnull': class file for javax.annotation.Nonnull not found warning: unknown enum constant When.MAYBE   reason: class file for javax.annotation.meta.When not found error: warnings found and -Werror specified 1 error 2 warnings ```  ```kt ❯ ./gradlew --version && ./gradlew :authn:dependencyInsight --configuration runtimeClasspath --dependency spring-core                                                                      # backend -> master + !  ------------------------------------------------------------ Gradle 7.1.1 ------------------------------------------------------------  Build time:   2021-07-02 12:16:43 UTC Revision:     774525a055494e0ece39f522ac7ad17498ce032c  Kotlin:       1.4.31 Groovy:       3.0.7 Ant:          Apache Ant(TM) version 1.10.9 compiled on September 27 2020 JVM:          11.0.11 (AdoptOpenJDK 11.0.11+9) OS:           Linux 5.10.42-1-MANJARO amd64  Type-safe dependency accessors is an incubating feature. Type-safe project accessors is an incubating feature.  > Task :authn:dependencyInsight org.springframework:spring-core:5.3.8 ```","closed","status: superseded,","xenoterracide","2021-07-15T20:52:08Z","2022-07-12T12:43:10Z"
"","27826","Add CacheErrorHandler implementation that logs exceptions rather than rethrowing them","issue #27788  I have some more configurable version prepared but I think it is too much (see attachment) [configurable-version.zip](https://github.com/spring-projects/spring-framework/files/7726399/configurable-version.zip) e","closed","type: enhancement,","Drezir","2021-12-16T10:18:35Z","2022-01-26T13:43:55Z"
"","26986","Allow multiple destinations per subscription in DefaultSubscriptionRegistry","Issue #24395 broke ""user"" destinations because it made subscription-id->destination a one to one association whereas it is a one to many.  This restores such state while keeping the optimisations done in #24395.","closed","status: declined,","alienisty","2021-05-27T12:21:53Z","2021-09-07T15:37:56Z"
"","27798","Mitigation for CVE-2021-44228","Is there mitigation for the log4j vulnerability?  https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228  It appears that spring is using  org.apache.logging.log4j:log4j-api:2.13.3  ``` +--- org.springframework.boot:spring-boot-starter-cache:2.4.11 |    +--- org.springframework.boot:spring-boot-starter:2.4.11 |    |    +--- org.springframework.boot:spring-boot:2.4.11 |    |    |    +--- org.springframework:spring-core:5.3.10 (*) |    |    |    \--- org.springframework:spring-context:5.3.10 (*) |    |    +--- org.springframework.boot:spring-boot-autoconfigure:2.4.11 |    |    |    \--- org.springframework.boot:spring-boot:2.4.11 (*) |    |    +--- org.springframework.boot:spring-boot-starter-logging:2.4.11 |    |    |    +--- ch.qos.logback:logback-classic:1.2.6 |    |    |    |    +--- ch.qos.logback:logback-core:1.2.6 |    |    |    |    \--- org.slf4j:slf4j-api:1.7.32 |    |    |    +--- org.apache.logging.log4j:log4j-to-slf4j:2.13.3 |    |    |    |    +--- org.slf4j:slf4j-api:1.7.25 -> 1.7.32 |    |    |    |    \--- org.apache.logging.log4j:log4j-api:2.13.3 |    |    |    \--- org.slf4j:jul-to-slf4j:1.7.32 |    |    |         \--- org.slf4j:slf4j-api:1.7.32 |    |    +--- jakarta.annotation:jakarta.annotation-api:1.3.5 |    |    +--- org.springframework:spring-core:5.3.10 (*) |    |    \--- org.yaml:snakeyaml:1.27 |    \--- org.springframework:spring-context-support:5.3.10 (*) ```","closed","status: invalid,","romanblachman","2021-12-10T17:14:41Z","2021-12-10T17:17:26Z"
"","27730","ResolvableType generic types matching","Is there a reason why exact matching is used when comparing generic types? Why not stick to `isAssignable`?   https://github.com/spring-projects/spring-framework/blob/dcc342ccc5cd8cc048c761035ee8cc60a3675c30/spring-core/src/main/java/org/springframework/core/ResolvableType.java#L346-L350  My use case: I am using a generic base event class, such as `BaseEvent extends PayloadApplicationEvent`, and I am expecting `BaseEvent` to fall into a listener expecting `BaseEvent`, where `Y` extends `X`, but that's not happening as the types of `X` and `Y` are not equal, but `X` is assignable from `Y`.  I would like to precise that I extend `PayloadApplicationEvent` here but extending `ApplicationEvent` and implementing `ResolvableTypeProvider` leads to the same issue.  Is there a way for this to work while using `@EventListener`? I know that it can be done with the listener implementing `GenericApplicationListener` but that will lead to messy code.  Any clues? Thanks.","closed","in: core,","torshid","2021-11-24T14:30:10Z","2021-11-25T08:38:44Z"
"","27390","Support char, float, and double primitive default values in BeanUtils.instantiateClass()","Instantiate a class,  give float and double primitive default values","closed","in: core,","takeaction21","2021-09-12T15:51:04Z","2021-09-14T14:31:12Z"
"","27857","perf: Conditional Judgment Modification","Increase readability，Optimal condition judgment #27856","closed","in: core,","1725636955","2021-12-25T06:38:15Z","2022-01-04T14:54:45Z"
"","27233","An erratum of micro-benchmark wiki page","In wiki page [Micro Benchmarks](https://github.com/spring-projects/spring-framework/wiki/Micro-Benchmarks) > For example, we can run the MimeTypeBenchmark.cachedParserSomeMimeTypes benchmark, with 2 JVM forks, the GC profiler, and specific benchmark parameters with:  ``` java -jar spring-core/build/libs/spring-core-5.3.0-SNAPSHOT-jmh.jar -f1 -prof gc -p customTypesCount=10,20 MimeTypeBenchmark.cachedParserSomeMimeTypes ```  I think `2 JVM forks` and `-f1` is a mismatch.  From JMH help doc: >   -f \                     How many times to fork a single benchmark. Use 0 to                               disable forking altogether. Warning: disabling                               forking may have detrimental impact on benchmark                               and infrastructure reliability, you might want                               to use different warmup mode instead. (default:                               5)","closed","type: task,","Shawyeok","2021-07-30T18:33:47Z","2021-11-12T14:25:53Z"
"","27854","Avoid repeated initialization of messageConverters field","In WebMvcConfigurationSupport will setMessageConverters after ExceptionHandlerExceptionResolver and RequestMappingHandlerAdapter creation so there no need init messageConverters in its constructor.","open","status: feedback-reminder,","qxo","2021-12-24T13:40:28Z","2022-02-18T20:02:23Z"
"","27872","Add general HttpHandlers to adapt Servlet runtimes","In webflux world, it is easy to create a HttpHandler adapter to connect the underlay Web server, thus it is easy to start up an embedded web server based application without Spring Boot, eg.   ```java @Bean @Profile(""default"") public HttpServer httpServer(ApplicationContext context) {     HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();     ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);     return HttpServer.create()             .host(""localhost"")             .port(this.port)             .handle(adapter); } ```  If possible providing such an API to simplify the Servlet stack, hide the configuration of  `WebApplicationInitializer`, and allow developer create an embedded server programmatically to serve the application and package the application in a jar package.","closed","status: invalid,","hantsy","2022-01-02T14:57:48Z","2022-01-07T01:34:44Z"
"","27895","compute mapping size in every loop","in TypeMappedAnnotations's process method","closed","status: invalid,","kse-music","2022-01-06T06:44:11Z","2022-01-06T07:24:56Z"
"","27290","Adding a hasAnyContributors() to CompositeUriComponentsContributor","In this commit, a method `hasContributors` has been deprecated as its name isn't compliant with its intention. The method returns `true` when there are no contributors available. A new method has been added, named `hasAnyContributors` that returns the value expected of its name.  Closes #27275","closed","status: declined,","thegeekyasian","2021-08-17T19:09:00Z","2021-08-18T19:31:44Z"
"","27804","Fix javadoc reference to ThrowsAdvice","In the process of learning, I found a little flaw in Javadoc  Maybe we can change {@link org.springframework.aop.MethodBeforeAdvice} to {@link org.springframework.aop.ThrowsAdvice}","closed","type: documentation,","aoyvx","2021-12-12T12:19:49Z","2021-12-12T15:35:09Z"
"","27770","Make methods from the `PlatformTransactionManager` and `ReactiveTransactionManager` non final in `AbstractPlatformTransactionManager` and `AbstractReactiveTransactionManager`","In the observability space we're instrumenting `PlatformTransactionManager` and `ReactiveTransactionManager` interfaces. The problem we're seeing is that if an actual implementation extends either `AbstractPlatformTransactionManager` or `AbstractReactiveTransactionManager` then the CGLIB proxy can't be created because methods from those interfaces are final.  Can we please make them non-final?","open","in: data,","marcingrzejszczak","2021-12-06T14:01:07Z","2021-12-07T08:23:24Z"
"","27269","Javadoc typo in PathMatchConfigurer#setUseSuffixPatternMatch","In the newest versions of Spring `PathMatchConfigurer#setUseSuffixPatternMatch` method is  Deprecated.   (Deprecated. as of 5.2.4. See class-level note in RequestMappingHandlerMapping on the deprecation of path extension config options. As their is no replacement for dis method, in 5.2.x it is necessary to set it to false. In 5.3 the default changes to false and use of dis property becomes unnecessary. Whether to use suffix pattern match (`"".*""`) when matching patterns to requests. If enabled a method mapped to `""/users""` also matches to `""/users.*""`. By default, dis is set to true.  Note: dis property is mutually exclusive wif and ignored when setPatternParser(PathPatternParser) is set.)  as mentioned by default it is set to true, but when I is removing dis configuration, dis suffix is not working. we had dis config pathMatchConfigurer.setUseSuffixPatternMatch(true);, but coz dis method is deprecated we removed it, and as expected by default it is true, but still we are getting errors.","closed","status: superseded,","lomakoartem1","2021-08-12T14:36:09Z","2021-10-04T08:38:02Z"
"","26916","Error in Bean Definition Inheritance example in ref docs","In the [Bean Definition Inheritance](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions) example in the reference docs, when I used instance code, an error occurred.  ``` Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'age' of bean class [org.springframework.beans.DerivedTestBean]: Bean property 'age' is not writable or has an invalid setter method. Did you mean 'name'? ```  The age's setter method is consistent with the configuration.  When I comment out the age attribute, it runs successfully.","closed","status: invalid,","lostblackknight","2021-05-09T16:22:02Z","2021-05-18T14:47:36Z"
"","27873","Backport `@ServletComponentScan` feature from Spring Boot to Spring Framework","In standard Java EE/Jakarta EE container, in a servlet component, it can inject CDI beans, EJB etc.  Spring Boot `@ServletComponentScan` improve the servlet registration.   If possible to make this available in Spring WebMvc by default(no need the specific ServletComponentScan, use the standard `ComponentScan` to discover servlet components), in all Servlet components(Servlet, Filter, Listeners), make it can inject Spring beans.","closed","status: declined,","hantsy","2022-01-02T15:31:43Z","2022-01-03T12:53:01Z"
"","27543","resolve application.yml property error","in spring2.2.5，my applicaiton.yml like this: aaa:    bbb:        ccc: 09 and take it in my class like this: @Value(""${aaa.bbb.ccc}"") private String ccc;  but the value of ccc is 9.0，and I want it is 09","closed","for: stackoverflow,","zhuhongxu","2021-10-11T05:53:11Z","2021-10-11T07:10:49Z"
"","27774","UriComponentsBuilder silently drops some Registry-based Naming Authorities","In spring-web 5.3.13, [UriComponentsBuilder.fromUri](https://github.com/spring-projects/spring-framework/blob/v5.3.13/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L207) / [UriComponentsBuilder.uri](https://github.com/spring-projects/spring-framework/blob/v5.3.13/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L554) silently drops some [RFC 2396 3.2.1 Registry-based Naming Authorities ](https://datatracker.ietf.org/doc/html/rfc2396#section-3.2.1) even when they are accepted as [RFC 3986 3.2 authorities](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2).   ```     // I tested java 17.0.1-zulu and 8.0.312-zulu - with the same results.      @Test     public void testUriComponentBuilder() throws URISyntaxException {         // Generic scheme to avoid any assumptions around HTTP         String scheme = ""scheme"";          // Matches         // - RFC 2396 3.2.1. ""reg_name"" Registry-based Naming Authority         // - RFC 3986 3.2.2 ""host"" Host         // NOT an RFC 2396 3.2.2. ""server"" Server-based Naming Authority         String authority = ""rfc_2396_authority"";           String uriString = scheme + "":"" + ""//"" + authority ;          URI testUri = new URI(uriString);          UriComponents uriComponentsFromUriString = UriComponentsBuilder.fromUriString(uriString).build(true);         UriComponents uriComponentsFromUri = UriComponentsBuilder.fromUri(testUri).build(true);          // Demonstrate that the URI is well formed according to RFC 2396 and parses as expected         assertAll(""testUriFromString should have a RFC 2396 Registry-based Naming Authority (3.2.1.)"",                 () -> assertEquals(authority, testUriFromString.getAuthority()),                 () -> assertNull(testUriFromString.getUserInfo()),                 () -> assertNull(testUriFromString.getHost()),                 () -> assertEquals(-1, testUriFromString.getPort())         );          // Demonstrate that the URI is parseable under RFC 3986 from string form         assertAll(""uriComponentsFromUriString should be populated "",                 () -> assertEquals(authority, uriComponentsFromUriString.getHost())         );          // Demonstrate that the parsed URI is equivalent (according to java.net.URI)         assertEquals(testUriFromString, uriComponentsFromUriString.toUri());          // Unexpectedly fails as getHost() return a null even though testUri has an RFC 3986 host         assertAll(""uriComponentsFromUri should have populated host "",                 () -> assertEquals(authority, uriComponentsFromUri.getHost())         );      } ```  When `java.net.URI` encounters an [RFC 2396 3.2.1](https://datatracker.ietf.org/doc/html/rfc2396#section-3.2.1) authority (identified as any correct authority not parseable under [RFC 2396 3.2.2](https://datatracker.ietf.org/doc/html/rfc2396#section-3.2.2)), it returns null values for the server-based naming authority components, causing `UriComponentBuilder` to assume they are unset and silently dropping the data. However, this data is available via `URI.getAuthority()`.  I would expect that `UriComponentBuilder` would attempt to reparse the authority from `Uri.getAuthority` under the RFC 3986 3.2 specification.  The fact that these classes are written against different versions of the spec is obviously a complicating factor. The most straightforward option is to reparse the URI from scratch under the RFC 3986 spec, though I think that it would be preferable to only parse the authority component to limit the blast radius of this change. I am happy to contribute a PR, but would appreciate thumbs up on the approach before investing the time as this would substantially change existing behavior if `UriComponentBuilder.uri` is being used after the authority components have been set via another method.","closed","in: web,","fedorka","2021-12-06T23:32:05Z","2022-01-04T12:14:30Z"
"","27397","ResponseEntity static builders should be parameterized with","In Spring MVC 5.3.3, I have a functional pipeline that ends with `Optional`:  ``` service.doStuff() // returns Optional   .map(Dto::fromEntity)   .map(ResponseEntity::ok)   .orElseGet(() -> ResponseEntity.notFound().build()); ```  In this case, I should be able to declare my controller method as returning `ResponseEntity`, but the `noContent` and `notFound` builder methods are parameterized with ``. As they inherently have no bodies, there should not be a conflict with allowing them to pass through the degenerate type parameter ``, which would permit a clean expression type for ""DTO-or-else"" expressions.","open","in: web,","chrylis","2021-09-13T19:49:37Z","2021-11-10T12:16:39Z"
"","27439","Allow to avoid class validation in `CglibAopProxy` via `ProxyFactory`","In Spring HATEOAS we create proxies for the special purpose of recording method invocations on controllers. To do so, we have to proxy the return type of the controller method and those might contain `final` methods. Those trigger some log output in `CglibAopProxy` that the final methods cannot be properly intercepted. While this is very helpful information in general, in our special case it causes confusion with users to see this output because we will never actually invoke any method on the proxy but rather just inspect it via an introduced interface.  It would be nice to be able to configure the `ProxyFactory` in a way that it skips the class validation so that we can opt into that mode.","closed","type: enhancement,","odrotbohm","2021-09-20T08:13:03Z","2021-09-21T16:00:39Z"
"","27489","ConfigurationClassUtils#checkConfigurationClassCandidate judgment logic question","in Spring Framework 5.2+,about checkConfigurationClassCandidate  i have a quetion for judgment, [checkConfigurationClassCandidate ](https://github.com/spring-projects/spring-framework/blob/ac5dc698e2f0f6f758983f1af3039eea627ef54d/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java#L125-L130)  use true replace non-false more reasonable? It looks more concise","closed","status: declined,","biuabiu","2021-09-29T06:13:55Z","2021-09-29T06:18:40Z"
"","27717","Allow filters to be registered with MockMvc for particular dispatcher types","In Spring Boot 2.6, we've introduced a new filter that's only registered for `ERROR` dispatches. This works fine at runtime and in integration tests over HTTP, but doesn't work as intended when testing with `MockMvc`. I [overlooked](https://github.com/spring-projects/spring-boot/issues/28759) the fact that `MockMvc`'s filter chain includes every known filter, irrespective of the request's dispatcher type. When adding a filter, it would be useful to be able to specify the filter's dispatcher types, as you can do with the Servlet API. In the meantime, we can fix Boot by updating the filter to ignore non-`ERROR` requests.","open","type: enhancement,","wilkinsona","2021-11-22T10:54:31Z","2022-03-05T12:46:21Z"
"","27742","Remove dependency on Commons FileUpload in ContentRequestMatchers","In Spring 5.3, `multipartData()` methods were added to `org.springframework.test.web.client.match.ContentRequestMatchers`, which are useful for testing a multipart request body.   As a slight limitation, to use this method with Spring 5.3, we need to add dependency on Commons-Fileupload in test scope.  The dependency was removed from Spring 6.0 in conjunction with #27423.   It would great if this change to `ContentRequestMatchers` would be backported to Spring 5.3.x.","closed","status: declined,","wkwkhautbois","2021-11-28T03:58:52Z","2021-11-29T12:25:22Z"
"","27316","Introduce `ExceptionCollector` testing utility","In order to support _soft assertions_ in #26917 and #26969, we need common support for tracking multiple failures and generating a single `AssertionError` containing those failures as suppressed exceptions.","closed","type: enhancement,","sbrannen","2021-08-23T08:08:35Z","2021-08-23T09:45:03Z"
"","27481","Upgrade to spring-javaformat-checkstyle 0.0.28 and downgrade to Checkstyle 8.41","In order to be able to use text blocks and other new Java language features, we should upgrade to a recent version of Checkstyle.  The latest version of `spring-javaformat-checkstyle` (0.0.28) is built against Checkstyle 8.32 which does not include support for language features such as text blocks. Support for text blocks was added in Checkstyle 8.36.  In addition, there is a binary compatibility issue between `spring-javaformat-checkstyle` 0.0.28 and Checkstyle 8.42.  Thus we cannot use Checkstyle 8.45.1.  We therefore need to **upgrade** to `spring-javaformat-checkstyle` 0.0.28 and **downgrade** to Checkstyle 8.41.  This change will be applied to `5.3.x` as well as `main` in order to benefit from the enhanced checking provided in more recent versions of Checkstyle.","closed","type: task,","sbrannen","2021-09-28T08:04:50Z","2021-09-28T08:47:50Z"
"","27447","Test Spring using OpenJ9 with Java 17 support","In order to assess potential compatibility issues -- for example, regarding different enforcement of rules specified in the JLS for Java compilers -- we should try building Spring Framework using OpenJ9 once 0.29.1 has been released.  Note from OpenJ9 team: ""Java 17 will ship on jdk17.0.1""  - https://github.com/eclipse-openj9/openj9/milestone/32  Downloads from IBM:  - https://developer.ibm.com/languages/java/semeru-runtimes/downloads","open","type: task,","sbrannen","2021-09-22T08:58:15Z","2022-03-10T15:32:05Z"
"","27613","Add option to cleanup multipart temp files","In non-streaming mode, upload of file larger than `DefaultPartHttpMessageReader#maxInMemorySize` results in storing uploaded file to a temporrary file. These temporary files are never deleted, if there is no system job/script which is cleaning this temp folder.  We are running our applications on docker images, where the only running process is java and therefore we are running out of space.  Please consider adding option to cleanup (directly or indirectly) uploaded multipart files. Similar option is available in Spring MVC (`MultipartResolver#cleanupMultipart`).","closed","type: enhancement,","qavid","2021-10-27T08:50:56Z","2021-11-02T16:31:05Z"
"","27871","Expose config field in RequestMappingHandlerMapping to subclasses","in my project , I hava a PlatformRequestMappingHandlerMapping。  ```java  public class PlatformRequestMappingHandlerMapping extends RequestMappingHandlerMapping {      @Override     protected RequestMappingInfo getMappingForMethod(Method method, Class handlerType) {         RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);         if (requestMappingInfo != null)             return requestMappingInfo;         return createCustomRequestMappingInfo(method);     }      private RequestMappingInfo createCustomRequestMappingInfo(AnnotatedElement element) {         PlatformRestMapping mapping = AnnotatedElementUtils.findMergedAnnotation(element, PlatformRestMapping.class);         // ....         return RequestMappingInfo.paths(URI_PREFIX_OF_API + mapping.value())                 .methods(methods)                 .options(getConfig()) // need use super.config                 .build();     }      // bad impl     private RequestMappingInfo.BuilderConfiguration getConfig() {         try {             Object config = FieldUtils.readField(this, ""config"", true);             return (RequestMappingInfo.BuilderConfiguration) config;         } catch (IllegalAccessException e) {             throw new RuntimeException(""config"");         }      } }   ```","closed","in: web,","shenjianeng","2022-01-02T03:30:48Z","2022-01-03T12:02:19Z"
"","27810","Investigate possible use of Java System Logger over Commons Logging API","In https://github.com/spring-projects/spring-framework/issues/19081 (about 5 years ago) a discussion and decision was made on how to approach logging for Spring Framework 5.0.   As the baseline of Spring Framework 6 has been lifted to Java 17 it might be worthwhile to investigate the custom log setup and use the default logging API (`System.getLogger`) provided by the JDK. Or at least have an explicit decision on the usage of that API for future reference.   I know that SLF4J (and thus Logback) and Log4j2 have integration for it.","open","in: core,","mdeinum","2021-12-14T06:55:17Z","2022-01-04T10:12:00Z"
"","27195","Allow overriding invokeSuspendingFunction","In case someone needs to specify default CoroutineContext for all WebMvc calls, he can use this [trick](https://stackoverflow.com/questions/68437892/configure-default-kotlin-coroutine-context-in-spring-mvc). If we can override invokeSuspendingFunction, we do not have to duplicate so much code.","open","in: web,","lukas-krecan","2021-07-21T11:17:38Z","2021-11-08T11:41:49Z"
"","27193","Allow specifying of CoroutineContext in invokeSuspendingFunction","In case someone needs to specify default `CoroutineContext` for all WebMvc calls, he can use [this trick](https://stackoverflow.com/questions/68437892/configure-default-kotlin-coroutine-context-in-spring-mvc). If we can specify `CoroutineContext` in `invokeSuspendingFunction`, we do not have to duplicate so much code.  Default parameter value not used as to not break the Java signature.","open","in: web,","lukas-krecan","2021-07-20T14:55:51Z","2021-11-08T11:41:49Z"
"","27862","Remove unnecessary check in isBridgedCandidateFor()","In BridgeMethodResolver#isBridgedCandidateFor, candidateMethod is never not bridged, so it seems unnecessary to judge whether candidateMethod and bridgeMethod are the same.","closed","type: enhancement,","aoyvx","2021-12-28T07:24:08Z","2022-02-16T06:41:28Z"
"","27724","Order of mediaTypesToUse list is different from the order of message converters","In AbstractMessageConverterMethodProcessor#writeWithMessageConverters method, it will create a list called `mediaTypesToUse` by `acceptableTypes` and `producibleTypes`, its order is not added as we excepted, so it will  cause choosing the wrong `selectedMediaType` that will affect which converter to use. By the way, the `HTTP Header Accept Values` will be reordered by `HeaderContentNegotiationStrategy`, this strategy may can solve this problem, even though this is not a same problem, and change this strategy is not such easy as https://github.com/spring-projects/spring-framework/issues/27488 mentioned.  Steps: 1. set MappingJackson2HttpMessageConverter as the first converter(order of converters) 2. send a request with headers have: `Accept: text/html, */*` or: `Accept: text/html, application/json` 3. Controller return `CharSequence` type  Will treat as a string type: ``` if (value instanceof CharSequence) { 	body = value.toString(); 	valueType = String.class; 	targetType = String.class; } ```  Will produce a `mediaTypesToUse`: ![image](https://user-images.githubusercontent.com/16933298/143024872-6cb599a4-6ed2-4e43-beca-7c11f0d2aa9b.png)  Both `MappingJackson2HttpMessageConverter` and `StringHttpMessageConverter` can write the result value, but it will use `StringHttpMessageConverter`, even though `MappingJackson2HttpMessageConverter` is the first converter of converters now.  Environment: Windows 10 Pro, Spring version 5.3.8","closed","status: declined,","scruel","2021-11-24T07:03:49Z","2021-11-24T13:20:15Z"
"","27681","@Configuration cannot generate dynamic proxy when BeanDefinitionRegistryPostProcessor is involved","In a `@Configuration` configuration class, when injecting a class that implements the `BeanDefinitionRegistryPostProcessor` interface (`@Bean` mode), the configuration class cannot generate a dynamic proxy.","closed","in: core,","yyq-lm","2021-11-12T07:39:45Z","2021-11-26T13:27:41Z"
"","27875","Deprecate inappropriate getBeanFactory() method in AbstractBeanDefinitionReader","in `spring5.3.10 version` A public method is provided in the `AbstractBeanDefinitionReader` class, ```java public final BeanDefinitionRegistry getBeanFactory() {      return this.registry; } ``` This method does not have any notes, and the type returned is a `BeanDefinitionRegistry`, but the method name is `getBeanFactory`. However, `BeanDefinitionRegistry`  doesn't extends  `BeanFactory`, so naming it is easy to mislead everyone,  `getRegistry()` method has been provided, So I think the `getBeanFactory` method should be removed. ![image](https://user-images.githubusercontent.com/43882950/147894685-98f43568-0a37-42c6-aec1-13251f4d3977.png)","closed","type: enhancement,","Mozartaa","2022-01-03T01:39:42Z","2022-01-04T12:15:05Z"
"","27666","Use ByteArrayDecoder in DefaultClientResponse::createException","In `DefaultClientResponse::createException`, instead of ""converting"" the response body into DataBuffers and turning those in a byte array , we should use the `ByteArrayDecoder` which does that in a single step.","closed","type: enhancement,","poutsma","2021-11-10T15:16:23Z","2022-01-14T12:27:56Z"
"","27071","Add maxAttempts to ExponentialBackOff","If you wish to stop after a certain number of attempts with an `ExponentialBackOff` you have to calculate the `maxElapsedTime` corresponding to the number of attempts.  See https://github.com/spring-projects/spring-kafka/blob/0ee2d49ea525de038d315bc243b62f1004a26dc6/spring-kafka/src/main/java/org/springframework/kafka/support/ExponentialBackOffWithMaxRetries.java#L74-L84  Add a new property to make it more convenient to stop after a certain number of attempts.","open","in: core,","garyrussell","2021-06-16T17:22:09Z","2021-11-11T09:24:21Z"
"","26920","Optimize some scenes which need not proxy","If using @target in the pointcut expression, spring will create proxy for the classes which are in maybe case and will check the aop when user call the functions of proxy class. If there's a final class in these proxy functions and use cglib proxy . the project will start failed.  So I return the target object, for these final class without cglib proxy.","closed","","caoxuhao","2021-05-10T07:19:06Z","2021-05-10T07:19:29Z"
"","26929","Optimize some scenes which need not proxy","If using @target in the pointcut expression, spring will create proxy for the classed which are in maybe case and will check the aop when user call the functions of proxy class. If there's a final class in these proxy functions. the project will start failed.  So I return the target object, for these final class without proxy.","open","in: core,","caoxuhao","2021-05-11T06:25:44Z","2021-11-10T10:03:05Z"
"","26928","Optimize some scenes which need not proxy","If using @target in the pointcut expression, spring will create proxy for the classed which are in maybe case and will check the aop when user call the functions of proxy class. If there's a final class in these proxy functions. the project will start failed.  So I return the target object, for these final class without proxy.","closed","","caoxuhao","2021-05-11T05:42:26Z","2022-02-18T19:05:39Z"
"","27853","URIComponent does not encode json query param","If URIComponentsBuilder is used to create uri that contains some json as query param, it will not work as JSON will not be encoded. This is probably due to json curly braces which are mistakenly taken as var placeholder.  ```java @Test public void jsonQueryParamIsEscaped() {     UriComponentsBuilder builder = UriComponentsBuilder.fromPath(""/some/path"")             .queryParam(""json"", ""{\""foo\"":\""bar\""}"")             .queryParam(""mustBeEscaped"", ""? # & \"" "")             .queryParam(""escapedDoubleQuotes"", ""\"""")             .encode();     String toUriString = builder.build().toUriString();     assertThat(toUriString).isEqualTo(""/some/path?json=%257B%2522foo%2522%253A%2522bar%2522%257D&mustBeEscaped=?%20%23%20%26%20%22%20&escapedDoubleQuotes=%22""); } ``` ``` org.opentest4j.AssertionFailedError:  expected: ""/some/path?json=%257B%2522foo%2522%253A%2522bar%2522%257D&mustBeEscaped=?%20%23%20%26%20%22%20&escapedDoubleQuotes=%22""  but was: ""/some/path?json={""foo"":""bar""}&mustBeEscaped=?%20%23%20%26%20%22%20&escapedDoubleQuotes=%22"" ```   Is is documented somewhere? Is there is a way to escape `{}` in query ? I have tried \\{} but to no avail","closed","","Antoniossss","2021-12-24T11:15:39Z","2022-01-04T15:25:17Z"
"","27674","fix: the basePackage do not have META-INF/spring.component then switc…","If the basePackage not defined in META-INF/spring.component, then using old `scanCandidateComponents(basePackage)`;  Otherwise the basePackage not in META-INF/spring.component will not load if the env classpath has any META-INF/spring.component file.   the issue poc code: https://github.com/qxo/spring-components-index-bug-poc","open","in: core,","qxo","2021-11-11T12:54:12Z","2021-11-12T14:22:40Z"
"","27417","JpaTransactionManager datasource is not thread safe","If JpaTransactionManager is used in a multitenant setup then the dataSource is not thread safe. This is in contrast to the TransactionSynchronizationMangager which uses ThreadLocals to manage its fields.","open","in: data,","bwilsonPaychex","2021-09-15T20:21:31Z","2021-09-21T08:33:47Z"
"","26989","Spring URL-decodes my cookie and breaks","If I send a request with ``` Cookie: Nonce=Tl=Q/0AUSOx[n)2z4(t]20FZv#?[Ge%H ```  Spring will fail with  ``` java.lang.IllegalArgumentException: Invalid encoded sequence ""%H"" 	at org.springframework.util.StringUtils.uriDecode(StringUtils.java:780) 	at org.springframework.web.util.UriUtils.decode(UriUtils.java:372) 	at org.springframework.web.util.UrlPathHelper.decodeInternal(UrlPathHelper.java:522) 	at org.springframework.web.util.UrlPathHelper.decodeRequestString(UrlPathHelper.java:513) 	at org.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver.resolveName(ServletCookieValueMethodArgumentResolver.java:66) 	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:108) 	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) 	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ```     **Affects:**  5.2.14","open","type: enhancement,","jakub-bochenski","2021-05-27T16:09:02Z","2021-11-16T11:49:31Z"
"","27056","RestTemplate converts to XML rather to JSON by default","I've upgraded from SpringBoot 2.4.6 to 2.5.1, and noticed the following bug / regression issue regarding RestTemplate. All my tests started to fail because the framework creates XML body instead of JSON.  In 2.4.6, I don't specify any ContentType for each request.  When I send an HTTP request, the framework converts my object to JSON body. Here is a sample code:  ```java         HttpHeaders headers = addBearerAuthHeader(username); // sets AUTHORIZATION header         ResponseEntity response = restTemplate.exchange(""/sets/"" + setId + ""/accounts"", POST,                 new HttpEntity(accountDTO, headers), AccountResource.class); ````  Body is created as standard JSON: ```json {""name"":""tfWqyuUgGZ"",""basePlatformId"":""platform-5466"",""description"":null,""targetId"":70310,""setId"":""109c05c8-0be0-4e32-8122-cbfd1f1f8785"",""properties"":{""address"":""129.83.21.137"",""username"":""DInuyP"",""policyId"":56647,""secret"":""5dSlX7Rn""}} ```  After upgrading to 2.5.X, the framework started creating **XML** instead of JSON: ```xml I4rDnGaJkLplatform-961588192109c05c8-0be0-4e32-8122-cbfd1f1f8785251.172.20.153TFWSBI93423IB6WlQqq ```  To work around this issue, I can add the following line to the code above: ```java headers.setContentType(MediaType.APPLICATION_JSON); ```  However, this is not a very good solution, since now I have to change a lot of places in my code. Unfortunately, changing a single place by using an HTTP interceptor (`ClientHttpRequestInterceptor`) to set the header isn't possible, because Object to Body conversion occurs before interceptor is called.  Another workaround I found after digging the code, is utilizing system property  `-Dspring.xml.ignore=true`. However, this is not perfect in case the code is handling both JSON and XML data.   I've started debugging the issue and noticed the difference between the SpringBoot versions and how this can be explained. The conversion starts in: https://github.com/spring-projects/spring-framework/blob/4a13928a2721259f9f4cf06814a6cfee6667bbb5/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L973   In SpringBoot 2.4.6, when printing `getMessageConverters().toStoring()`, I get: [ org.springframework.http.converter.ByteArrayHttpMessageConverter@6e78fcf5,  org.springframework.http.converter.StringHttpMessageConverter@56febdc,  org.springframework.http.converter.ResourceHttpMessageConverter@3b8ee898,  org.springframework.http.converter.xml.SourceHttpMessageConverter@7d151a,  org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter@294bdeb4,  **org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter@5300f14a,** org.springframework.http.converter.json.MappingJackson2HttpMessageConverter@1f86099a,  org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverter@77bb0ab5,  org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter@f2c488 ]  However, in the same code running in 2.5.X, notice the difference: [ org.springframework.http.converter.ByteArrayHttpMessageConverter@452c8a40,  org.springframework.http.converter.StringHttpMessageConverter@534243e4,  org.springframework.http.converter.ResourceHttpMessageConverter@29006752,  org.springframework.http.converter.xml.SourceHttpMessageConverter@470a9030,  org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter@66d57c1b,  **org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter@27494e46,** org.springframework.http.converter.json.MappingJackson2HttpMessageConverter@d59970a,  org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverter@1e411d81,  org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter@53b98ff6 ]  The reason for the difference in converters is this line: `jackson2XmlPresent = ClassUtils.isPresent(""com.fasterxml.jackson.dataformat.xml.XmlMapper"", classLoader);` https://github.com/spring-projects/spring-framework/blob/4a13928a2721259f9f4cf06814a6cfee6667bbb5/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L127   In my sample, `requestContentType = null` in runtime, since I don't initialize any specific contentType. Therefore, the first converter that matches the conditions is `MappingJackson2XmlHttpMessageConverter`.  I don't know why there is a difference between the class loaders and why `jackson2XmlPresent=true` on 2.5.X while it is `false` on 2.4.X. I haven't changed anything in my code or in the project dependencies except the SpringBoot version.  Maybe there is a workaround, but IMHO it is still a breaking change between 2.5.X to 2.4.X.   Thanks, Ori.","closed","","oridool","2021-06-12T13:11:53Z","2021-06-27T07:52:55Z"
"","27886","Correct not compiling example code in Data Access docs","I've noticed, that there is a piece of sample code that does not compile with Spring 5.x, because the the EntityManager interface [does not implement AutoCloseable](https://github.com/eclipse-ee4j/jpa-api/blob/2.2-2.2.3/api/src/main/java/javax/persistence/EntityManager.java#L54) until JPA 3.x ([relevant commit in jpa-api](https://github.com/eclipse-ee4j/jpa-api/commit/1ae01ae3793d129bf921e9b1fe893bed744065d8))  The sample should be fine for Spring 6.x - so I'm not sure if targeting `main` is the correct workflow here?  * Partially reverts 189e1afc6ee6bd40b * Releates to https://github.com/spring-projects/spring-framework/issues/22269  Thanks for looking at this!","closed","type: documentation,","jjank","2022-01-04T15:05:04Z","2022-01-04T15:52:15Z"
"","26990","Add extra test case of creating bean","I've noticed the method  _public Object createBean(Class beanClass, int autowireMode, boolean dependencyCheck) throws BeansException_  at line 256in _java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java_ is not covered in the current test suit, and hence I added a simple unit test in order to improve the coverage.","closed","","tyc31316","2021-05-27T17:47:12Z","2022-02-18T19:05:41Z"
"","26993","Add extra test case for creating bean","I've noticed the method public Object createBean(Class beanClass, int autowireMode, boolean dependencyCheck) throws BeansException at line 256in java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java is not covered in the current test suit, and hence I added a simple unit test in order to improve the coverage.","closed","in: core,","tyc31316","2021-05-27T19:40:55Z","2021-12-10T22:32:15Z"
"","26992","Add extra test case of creating bean","I've noticed the method public Object createBean(Class beanClass, int autowireMode, boolean dependencyCheck) throws BeansException at line 256in java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java is not covered in the current test suit, and hence I added a simple unit test in order to improve the coverage.","closed","","tyc31316","2021-05-27T19:31:49Z","2021-05-27T19:34:09Z"
"","27363","Why using slice(String, int, int) is throwing an exception in Spring data MongoDB?","I've created a very basic Spring boot (v. 2.5.4 and also v. 2.6.0) project and I want to perform a simple query to MongoDB (v 4.4.4): ```java @SpringBootTest class DemoApplicationTests {  	@Autowired 	MongoOperations operations;  	@Test 	void sliceSimple() { 		final Criteria criteria = Criteria.where(""_id"").is(new ObjectId(""5a3931f6d60180000f16db8c"")); 		Query query = Query.query(criteria); 		query.fields().slice(""subcategories"", 0, 1); 		operations.find(query, Category.class); 	}  } ``` ```java public class Category {      public List subcategories; } ```  But it results with an exception:  ``` Can't find a codec for class [Ljava.lang.Integer;. org.bson.codecs.configuration.CodecConfigurationException: Can't find a codec for class [Ljava.lang.Integer;. 	at org.bson.internal.CodecCache.lambda$getOrThrow$1(CodecCache.java:52) 	at java.base/java.util.Optional.orElseThrow(Optional.java:408) 	at org.bson.internal.CodecCache.getOrThrow(CodecCache.java:51) 	at org.bson.internal.OverridableUuidRepresentationCodecRegistry.get(OverridableUuidRepresentationCodecRegistry.java:72) 	at org.bson.internal.ChildCodecRegistry.get(ChildCodecRegistry.java:52) 	at org.bson.codecs.DocumentCodec.writeValue(DocumentCodec.java:202) 	at org.bson.codecs.DocumentCodec.writeMap(DocumentCodec.java:217) 	at org.bson.codecs.DocumentCodec.writeValue(DocumentCodec.java:200) 	at org.bson.codecs.DocumentCodec.writeMap(DocumentCodec.java:217) 	at org.bson.codecs.DocumentCodec.encode(DocumentCodec.java:159) 	at org.bson.codecs.DocumentCodec.encode(DocumentCodec.java:46) 	at org.bson.BsonDocumentWrapper.getUnwrapped(BsonDocumentWrapper.java:195) 	at org.bson.BsonDocumentWrapper.isEmpty(BsonDocumentWrapper.java:115) 	at com.mongodb.internal.operation.DocumentHelper.putIfNotNullOrEmpty(DocumentHelper.java:43) 	at com.mongodb.internal.operation.FindOperation.getCommand(FindOperation.java:826) 	at com.mongodb.internal.operation.FindOperation.access$1700(FindOperation.java:80) 	at com.mongodb.internal.operation.FindOperation$4.create(FindOperation.java:893) 	at com.mongodb.internal.operation.CommandOperationHelper.executeCommandWithConnection(CommandOperationHelper.java:221) 	at com.mongodb.internal.operation.FindOperation$1.call(FindOperation.java:658) 	at com.mongodb.internal.operation.FindOperation$1.call(FindOperation.java:652) 	at com.mongodb.internal.operation.OperationHelper.withReadConnectionSource(OperationHelper.java:583) 	at com.mongodb.internal.operation.FindOperation.execute(FindOperation.java:652) 	at com.mongodb.internal.operation.FindOperation.execute(FindOperation.java:80) 	at com.mongodb.client.internal.MongoClientDelegate$DelegateOperationExecutor.execute(MongoClientDelegate.java:170) 	at com.mongodb.client.internal.MongoIterableImpl.execute(MongoIterableImpl.java:135) 	at com.mongodb.client.internal.MongoIterableImpl.iterator(MongoIterableImpl.java:92) 	at org.springframework.data.mongodb.core.MongoTemplate.executeFindMultiInternal(MongoTemplate.java:2807) 	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:2543) 	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:2525) 	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:847) 	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:833) 	at com.example.demo.DemoApplicationTests.sliceSimple(DemoApplicationTests.java:22) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:133) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) 	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 	at java.base/java.lang.Thread.run(Thread.java:834)   ```  Looking at the `slice(String, int, int)` definition, there is a usage of Integer[]: ```java /** 	 * Project a {@code $slice} of the array {@code field} using the first {@code size} elements starting at 	 * {@code offset}. 	 * 	 * @param field the document field name to project, must be an array field. 	 * @param offset the offset to start at. 	 * @param size the number of elements to include. 	 * @return {@code this} field projection instance. 	 */ 	public Field slice(String field, int offset, int size) {  		slices.put(field, new Integer[] { offset, size }); 		return this; 	} ```  Do somebody know if what is happening? Am I missing something in my configuration? My build.gradle: ```gradle plugins { 	id 'org.springframework.boot' version '2.5.4' 	id 'io.spring.dependency-management' version '1.0.11.RELEASE' 	id 'java' }  group = 'com.example' version = '0.0.1-SNAPSHOT' sourceCompatibility = '11'  repositories { 	mavenCentral() }  dependencies { 	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb' 	testImplementation 'org.springframework.boot:spring-boot-starter-test' }  test { 	useJUnitPlatform() } ```  Ps. I was also trying to use custom converter for Integer array: ```java public class JavaIntegerArrayToListConverter implements Converter {      @Override     public List convert(final Integer[] source) {         return source == null ? null : Arrays.asList(source);     } } ```  and register with: ```java @Primary     @Bean     public MongoTemplate mongoTemplate(MongoDatabaseFactory mongoDbFactory,                                        MappingMongoConverter mappingMongoConverter) {                  mappingMongoConverter.setCustomConversions(new MongoCustomConversions(                 Collections.singletonList(new JavaIntegerArrayToListConverter())));                  mappingMongoConverter.afterPropertiesSet();                  return new MongoTemplate(mongoDbFactory, mappingMongoConverter);     } ```  But without any effect.   Thanks in advance for any help.","closed","for: external-project,","formellaalex","2021-09-06T10:28:07Z","2021-09-06T12:32:12Z"
"","27243","5.2.x Kotlin: warnings found and -Werror specified","I've build the source successfully in my Idea.But when I create a new module to test it,It can't run well with the error Kotlin: warnings found and -Werror specified.I tried to repack the cglib and objenesis jar like this: ![image](https://user-images.githubusercontent.com/3141067/128277208-e36ab392-6313-443e-b420-09700344b348.png) But it's not work.Anyone can help me?","closed","","f1024557668","2021-08-05T01:36:34Z","2021-08-05T05:36:51Z"
"","27656","Inconsistent .equals() and .getUrl() in RequestEntity class","I'm writing tests for my service and I faced an issue with `RequestEntity.equals()`. I'm trying to check that my requests are equal, so I wrote this code:  ```java   var request = RequestEntity                 .post(""https://test.com/api/endpoint"")                 .header(""Authorization"", ""Bearer"")                 .header(""Cookie"", ""Cookie=cook;"")                 .body(""Hello World"", String.class);          var anotherRequest = RequestEntity                 .post(""https://test.com/api/endpoint"")                 .header(""Authorization"", ""Bearer"")                 .header(""Cookie"", ""Cookie=cook;"")                 .body(""Hello World"", String.class);          assert request.equals(anotherRequest);  ```   But as a result I have this exception:   ``` Exception in thread ""main"" java.lang.UnsupportedOperationException 	at org.springframework.http.RequestEntity.getUrl(RequestEntity.java:165) 	at org.springframework.http.RequestEntity.equals(RequestEntity.java:198) 	at org.example.Application.main(Application.java:31) ```  As exception message suggests, I've checked `.getUrl()` and `.equals()` method in the `RequestEntity` and found that `.getUrl()` throws an exception when the `url` field is null: ```java 	public URI getUrl() { 		if (this.url == null) { 			throw new UnsupportedOperationException(); 		} 		return this.url; 	} ``` but equals tries to compare objects in a null safe manner `ObjectUtils.nullSafeEquals(getUrl(), otherEntity.getUrl()))`, like this: ```java 	public boolean equals(@Nullable Object other) { 		if (this == other) { 			return true; 		} 		if (!super.equals(other)) { 			return false; 		} 		RequestEntity otherEntity = (RequestEntity) other; 		return (ObjectUtils.nullSafeEquals(getMethod(), otherEntity.getMethod()) && 				ObjectUtils.nullSafeEquals(getUrl(), otherEntity.getUrl())); 	} ```  That's clear from the code that the `url` field can't be null otherwise you will get an exception. So, is this an expected behavior? How should I compare `RequestEntity` objects?","closed","status: duplicate,","Ilya225","2021-11-09T10:14:13Z","2021-11-09T10:58:07Z"
"","26988","Reactive WebSocket Client terminate connection invoking .doOnTerminate() which doesn't send Mono back to client","I'm using reactive websockets and when the client app just closes/disconnect, the server executes the flow .doOnTerminate(){... where I call: webSocketSession.close();  When I try to reconnect again to the WebSocket, it doesn't send messages to the client anymore.  I seems I should be return Mono - but the .doOnTerminate(()-?{}... doesn't allow me to return any kind of object/response.","closed","for: stackoverflow,","phnxfire","2021-05-27T16:03:36Z","2021-06-11T20:29:23Z"
"","27631","Bean scope ""websocket"" not available using rsocket messaging","I'm trying to port an app to rsocket over websocket messaging because the kind of interaction required should be ideal for this very promising standard.  The problem is that I'm unable to define a bean with a scoped property of websocket like I usually do with STOMP. The error I get is: > java.lang.IllegalStateException: No Scope registered for scope name 'websocket'  Since there is no ""rsocket"" scope I wonder how could I correctly use beans like when using websockets/stomp.","open","in: messaging,","Polve","2021-11-02T09:24:44Z","2021-11-10T09:11:33Z"
"","27627","Source code question regarding findAutowireCandidates()","I'm studying the source code of Spring today，and I have a problem that can not understand: there is a length of source code in resolveDependency->doResolveDependency->findAutowireCandidates：  ```java Map result = new LinkedHashMap(candidateNames.length); for (Map.Entry","open","in: core,","JavaFenSi","2021-10-30T06:02:29Z","2021-12-16T03:11:36Z"
"","27159","Provide a way to record which fields is present for @RequestBody","I'm implementing REST partial updates with PATCH, for example: ```java 	@PatchMapping(PATH_DETAIL) 	public User updatePartial(@PathVariable Long id, 			@RequestBody @JsonView(User.View.Updatable.class) @Valid User user) { 		return userRepository.findById(id).map(u -> { 			BeanUtils.copyNonNullProperties(user, u); 			return userRepository.save(u); 		}).orElseThrow(() -> notFound(id)); 	} ``` currently there is no way to differ `{""username"":""test"",""password"":null}` (set password to null) with `{""username"":""test""}` (ignore password), I wish Spring Boot provide an annotation like `@PresentedFields`  ```java 	@PatchMapping(PATH_DETAIL) 	public User updatePartial(@PathVariable Long id, 			@RequestBody @JsonView(User.View.Updatable.class) @Valid User user,@PresentedFields Set fields) { 		//fields contains username and password even if password is null 	} ``` or some other mechanism.","open","in: web,","quaff","2021-07-12T09:32:47Z","2021-11-10T12:17:21Z"
"","27506","AntPathMatcher matches path with trailing slash differently if '**' is present in the pattern","I'm curious why `AntPathMatcher` matches a path with a trailing slash differently if the pattern contains a `**` pattern. See the following example:  ``` AntPathMatcher matcher = new AntPathMatcher();  matcher.match(""/en"", ""/en/"") == false // does not match matcher.match(""/*/en"", ""/en/foo/"") == false // does not match matcher.match(""/**/foo"", ""/en/foo/"") == true // does match ```  Could someone enlighten me why `AntPathMatcher` behaves this way?","closed","in: core,","aomader","2021-10-01T14:16:09Z","2022-04-04T16:55:17Z"
"","27418","How to enable OverflowStrategy.DROP in ConcurrentWebSocketSessionDecorator","I'm coming across a issue when using stomp websocket. I'm using websocket to send image data, which may be large and beyond the sendBufferSizeLimit (which is 512*1024)，and in SubProtocolWebSocketHandler, it will raise a SessionLimitExceededException and terminate the session. By reading the source code, I found that the strategy is defined in  ConcurrentWebSocketSessionDecorator, whose overflowStrategy is OverflowStrategy.TERMINATE by default in its constructor.  My question is, I want to switch the strategy to OverflowStrategy.DROP so that my session will not be terminated. However, I did not find the way to change the strategy, any idea？","closed","in: web,","skaleto","2021-09-16T08:00:50Z","2021-09-16T11:54:38Z"
"","26970","java.lang.IllegalArgumentException: Unsupported class file major version 60","I would like to report this issue:  ``` 20:52:23.660 [http-nio-8010-exec-1] DEBUG RequestResponseBodyMethodProcessor[traceDebug:91] - Read ""application/json;charset=UTF-8"" to [org.engine.database.transactions.factory.sale.SaleRequestFactory@703bc432] 20:52:23.685 [http-nio-8010-exec-1] DEBUG LocalVariableTableParameterNameDiscoverer[inspectClass:118] - ASM ClassReader failed to parse class file [class java.lang.Object], probably due to a new Java class file version that isn't supported yet - unable to determine constructor/method parameter names java.lang.IllegalArgumentException: Unsupported class file major version 60         at org.springframework.asm.ClassReader.(ClassReader.java:196)         at org.springframework.asm.ClassReader.(ClassReader.java:177)         at org.springframework.asm.ClassReader.(ClassReader.java:163)         at org.springframework.asm.ClassReader.(ClassReader.java:284)         at org.springframework.core.LocalVariableTableParameterNameDiscoverer.inspectClass(LocalVariableTableParameterNameDiscoverer.java:105)         at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)         at org.springframework.core.LocalVariableTableParameterNameDiscoverer.doGetParameterNames(LocalVariableTableParameterNameDiscoverer.java:84)         at org.springframework.core.LocalVariableTableParameterNameDiscoverer.getParameterNames(LocalVariableTableParameterNameDiscoverer.java:72)         at org.springframework.core.PrioritizedParameterNameDiscoverer.getParameterNames(PrioritizedParameterNameDiscoverer.java:55)         at org.springframework.validation.beanvalidation.LocalValidatorFactoryBean$1.getParameterNames(LocalValidatorFactoryBean.java:337)         at org.hibernate.validator.internal.util.ExecutableParameterNameProvider.getParameterNames(ExecutableParameterNameProvider.java:37)         at org.hibernate.validator.internal.properties.javabean.JavaBeanExecutable.getParameterName(JavaBeanExecutable.java:86)         at org.hibernate.validator.internal.metadata.aggregated.ParameterMetaData$Builder.build(ParameterMetaData.java:165)         at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.findParameterMetaData(ExecutableMetaData.java:436)         at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:391)         at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataBuilder$BuilderDelegate.build(BeanMetaDataBuilder.java:260)         at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataBuilder.build(BeanMetaDataBuilder.java:133)         at org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.createBeanMetaData(BeanMetaDataManagerImpl.java:206)         at org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.getBeanMetaData(BeanMetaDataManagerImpl.java:165)         at org.hibernate.validator.internal.engine.ValidatorImpl.validate(ValidatorImpl.java:156)         at org.springframework.validation.beanvalidation.SpringValidatorAdapter.validate(SpringValidatorAdapter.java:117)         at org.springframework.boot.autoconfigure.validation.ValidatorAdapter.validate(ValidatorAdapter.java:70)         at org.springframework.validation.DataBinder.validate(DataBinder.java:889)         at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.validateIfApplicable(AbstractMessageConverterMethodArgumentResolver.java:266)         at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:137)         at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)         at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)         at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)         at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)         at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)         at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)         at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)         at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)         at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)         at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)         at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)         at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:209)         at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)         at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)         at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:93)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)         at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)         at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)         at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)         at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)         at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)         at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)         at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357)         at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893)         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707)         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)         at java.base/java.lang.Thread.run(Thread.java:831) 20:52:24.070 [http-nio-8010-exec-1] DEBUG HttpMessageConverterExtractor[extractData:103] - Reading to [org.engine.payments.totalprocessing.client.models.sale.response.SaleResponse] 20:52:24.097 [http-nio-8010-exec-1] DEBUG HttpEntityMethodProcessor[writeWithMessageConverters:255] - Using 'application/json', given [*/*] and supported [application/json, application/*+json, application/json, application/*+json] 20:52:24.098 [http-nio-8010-exec-1] DEBUG HttpEntityMethodProcessor[traceDebug:91] - Writing [org.engine.database.transactions.factory.sale.SaleResponseFactory@42553f31] 20:52:24.115 [http-nio-8010-exec-1] DEBUG OpenEntityManagerInViewInterceptor[afterCompletion:111] - Closing JPA EntityManager in OpenEntityManagerInViewInterceptor 20:52:24.116 [http-nio-8010-exec-1] DEBUG DispatcherServlet[logResult:1131] - Completed 200 OK ```  More information: https://stackoverflow.com/questions/67661253/asm-classreader-failed-to-parse-class-file-class-java-lang-object-probably-du","closed","for: stackoverflow,","rcbandit111","2021-05-23T21:41:20Z","2021-05-24T09:08:46Z"
"","27508","SimpleAsyncTaskExecutor should set thread prefix same way as ThreadPoolTaskExecutor","I would assume that `SimpleAsyncTaskExecutor` and `ThreadPoolTaskExecutor` behave the same way with respect to thread name prefix initialization, namely, `SimpleAsyncTaskExecutor` should be `BeanNameAware` and set the thread name prefix the same way as implemented in [`ExecutorConfigurationSupport`](https://github.com/spring-projects/spring-framework/blob/d84ca2ba90/spring-context/src/main/java/org/springframework/scheduling/concurrent/ExecutorConfigurationSupport.java#L184).","closed","in: core,","dmak","2021-10-01T14:55:07Z","2021-10-02T13:26:05Z"
"","27200","Get class names via Class object","I was getting `java.lang.NoClassDefFoundError` on `org/springframework/expression/spel/CompiledExpression` after ProGuard shrinking. This alleviates issues finding those classes.","closed","in: core,","BFergerson","2021-07-22T18:46:08Z","2021-07-25T17:25:05Z"
"","27534","Method invocation in same class when both methods are @Transactional, but method 2 never executes","I want to use `Propagation.REQUIRES_NEW` to start a new transaction, but test2 never be executed and process has been hang up. Is there any thing wrong in my example?  here is my code,    ```java     @Override      @Transactional(rollbackFor = Exception.class)     public void test() {         ((TestServiceImpl) AopContext.currentProxy()).test2();         log.info(""2222222222222222222"");      }      @Transactional(propagation = Propagation.REQUIRES_NEW)     public void test2() {         log.info(""11111111"");     } ```","closed","in: core,","hxlqjz","2021-10-08T09:39:40Z","2021-10-08T13:55:02Z"
"","27691","org.springframework.asm.ClassReader class verification rules","I want to encrypt the class bytecode of some compiled core classes in the springboot project, and use the JVMTI monitoring mechanism to decrypt the class. Ordinary java projects have been able to decrypt the jar after the encrypted class can be decrypted normally. It runs, but even if a specific java class is not referenced in the code in springboot, if the directory of the class is in the spring scan path by default, the encrypted class file will be caused by org even if the class file is not referenced by any code. The validation bytecode of org.springframework.asm.ClassReader throws an exception, causing the service to stop. Can you provide a configuration for this requirement to ignore certain classes that are not validated?","open","status: feedback-provided,","kakahu2015","2021-11-17T01:47:01Z","2022-05-24T04:20:24Z"
"","27436","My application does not use spring-webflux. Is the CVE-2021-22118 vulnerability not involved?","I want to check whether the CVE-2021-22118 vulnerability affects only applications that use spring-webflux. If spring-webflux is not used, the vulnerability is not affected","closed","status: invalid,","yanyunyouxia","2021-09-19T02:44:49Z","2021-09-19T07:17:39Z"
"","27179","Externelize Etag generation from ShallowEtagHeaderFilter","I want to add an ETag to read and write operations. ShallowEtagHeaderFilter does this for the former and as far as I know, I have to deal with the latter. The problem is that ShallowEtagHeaderFilter generates the ETag internally with this method: ```java 	protected String generateETagHeaderValue(InputStream inputStream, boolean isWeak) throws IOException { 		// length of W/ + "" + 0 + 32bits md5 hash + "" 		StringBuilder builder = new StringBuilder(37); 		if (isWeak) { 			builder.append(""W/""); 		} 		builder.append(""\""0""); 		DigestUtils.appendMd5DigestAsHex(inputStream, builder); 		builder.append('""'); 		return builder.toString(); 	} ``` To use this method to generate etags for write operations, I would need to copy and paste it or to make it public by overriding and using the class outside of its intended usecase.  It would be much better if this method would be useable by other classes, too.","open","in: web,","Shryne","2021-07-15T15:11:30Z","2021-11-10T12:20:57Z"
"","27138","ObjectToMapConverter and MapToObjectConverter","I want something like `MapToMapConverter`, but allow an object to be converted, either way, seems feasible. I really wouldn't expect it to be able to do much more than reflective field name as key, and then value as value. Though perhaps MapToObject is harder?","open","in: core,","xenoterracide","2021-07-06T21:02:38Z","2021-11-11T09:24:22Z"
"","27574","Spring AOP self call interceptor config support.","I use spring-aop-5.2.15.RELEASE.  Now if one bean's method call its' own internal method, it seems that the called method does not take effect with interceptor. I know this has been discussed before, and I've searched elsewhere, the framework recommends using `@Autowired` to inject a proxy object. But it doesn't seem elegant.  I find in `DynamicAdvisedInterceptor`  ``` if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) { 	// We can skip creating a MethodInvocation: just invoke the target directly. 	// Note that the final invoker must be an InvokerInterceptor, so we know 	// it does nothing but a reflective operation on the target, and no hot 	// swapping or fancy proxying. 	Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); 	retVal = methodProxy.invoke(target, argsToUse); } ``` I don't understand why `retVal = methodProxy.invoke(target, argsToUse);` Maybe `retVal = methodProxy.invokeSuper(proxy, argsToUse);` is better in sometimes.  I also looked at the `@Lookup` code, which directly uses Cglib as a proxy for calls between methods within a class. How about replacing invoke with invokeSuper? Or allow the API caller to configure which method to use? Of course, my understanding of it is relatively simple.","open","in: core,","jliu666","2021-10-18T12:42:39Z","2021-11-10T10:03:05Z"
"","27055","ThreadPoolTaskExecutor should have some way of specifying UncaughtExceptionHandler","I use `ThreadPoolTaskExecutor` as thread pool, and want to set the `UncaughtExceptionHandler` for new threads created, but it has no related method to specify.","open","in: core,","Sdky","2021-06-11T17:50:44Z","2021-11-10T12:24:16Z"
"","27550","Include correct keyword in CookieAssertions failure messages","I think the implementation of these methods was copied from the `secure` one, but the message wasn't updated to reflect the method name.","closed","type: enhancement,","koenpunt","2021-10-12T20:41:06Z","2021-10-13T12:17:45Z"
"","27387","Fix misplaced comma in AOP doc","I think that a comma was misplaced in a sentece in the Core / AOP documetation.","closed","type: documentation,","crlikcngroup","2021-09-11T15:44:12Z","2021-09-12T09:08:09Z"
"","27583","Enhance DataSize with comparators and simple algebra","I think it would be useful to add some handy operators to `DataSize`, like comparators and some algebra: - `DataSize plus(DataSize dataSize)` - `DataSize minus(DataSize dataSize)` - `DataSize divide(int scalar)` - `DataSize multiply(int scalar)` - `boolean isGreaterThan(DataSize dataSize)` - `boolean isLessThan(DataSize dataSize)` - `boolean isEqualTo(DataSize dataSize)` - `static DataSize sum(DataSize ...dataSizes)` - `static DataSize min(DataSize ...dataSizes)` - `static DataSize max(DataSize ...dataSizes)` - `static DataSize between(DataSize x, DataSize y)`  These comparators are far more readable than using the `.compareTo` (Similar to Java's approach with `Instant` - `isBefore` and `isAfter`). Also being able to do some simple algebra will be very handy for when you are doing calculations with sizes (`dataSize1.plus(dataSize2)` is far more readable than doing `DataSize.ofBytes(dataSize1.toBytes() + dataSize2.toBytes())`.","closed","in: core,","nhmarujo","2021-10-20T18:23:13Z","2021-10-25T09:40:24Z"
"","27638","Suggestion in docs-webflux- Add corresponding maven/gradle dependencies  for HTTP client library","I suggest to add the corresponding maven/gradle dependencies in the docs when configuring the http client library for webflux webClient.  Example [here](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-builder-http-components): mentioning these depencencies if we need to configure apache httpComponents httpClient.  ``` HttpAsyncClientBuilder clientBuilder = HttpAsyncClients.custom(); clientBuilder.setDefaultRequestConfig(...); CloseableHttpAsyncClient client = clientBuilder.build(); ClientHttpConnector connector = new HttpComponentsClientHttpConnector(client);  WebClient webClient = WebClient.builder().clientConnector(connector).build(); ``` THEN: ```      org.apache.httpcomponents.client5     httpclient5     5.1       org.apache.httpcomponents.core5     httpcore5-reactive     5.1  ```  This will facilitate life :)","open","in: web,","amirensit","2021-11-04T08:40:51Z","2021-11-08T11:37:37Z"
"","27251","Is it fine to add the BeanPostProcessorChecker in the first place?","I see some BeanPostProcessorChecker‘s mismatch log, and I have a question.  Is it fine to add the BeanPostProcessorChecker in the first place?  https://github.com/spring-projects/spring-framework/blob/451bcfc832dacbd601969e675dcd8e01fe92aa48/spring-context/src/main/java/org/springframework/context/support/PostProcessorRegistrationDelegate.java#L227  Since `beanFactory.getBean(ppName, BeanPostProcessor.class)` will also trigger the BeanPostProcessorChecker and at that time some of BeanPostProcessors were not added yet.  I am thinking of add the BeanPostProcessorChecker just behind `registerBeanPostProcessors(beanFactory, internalPostProcessors);`. Am I right?","closed","in: core,","dpy1123","2021-08-09T09:09:53Z","2021-08-09T13:44:39Z"
"","27101","Delete unnecessary variable","I review the PRs of @stsypanov in order to learn some code tips.   I found the code of https://github.com/spring-projects/spring-framework/pull/23053 may be simpler.","closed","type: task,","diguage","2021-06-27T08:54:29Z","2021-07-11T01:25:22Z"
"","26925","SpringBeanAutowiringSupport should log at warn level when autowiring fails","I recently upgraded to a newer wildfly version (20-->23) and wildfly now init's webservices very early, before spring initilization is kicked off, so the autowiring in SpringBeanAutowiringSupport fails.  Obviously, that is not a spring issue, but these issues would be WAY easier to find if the failure to wire was at least a Warn level log statement.  It appears that the logging in the processInjectionBasedOnCurrentContext method is debug, as it is designed to be called from other places than the constructor itself, but I think there should be a warn or error level log of the failure to wire in the constructor, to lead people to this class when their are external factors that cause this autowire to work differently.","closed","type: enhancement,","laoseth","2021-05-10T15:30:48Z","2021-05-11T13:50:40Z"
"","27802","Support for CGLIB BeanMap utility on JDK 17","I put the problem in MD","closed","type: enhancement,","livk-cloud","2021-12-11T02:13:23Z","2022-07-22T20:14:12Z"
"","27564","Serving static resources from graalvm native-image","I put my `index.html` into `resources/public` folder, and when running the application (from IDE, or as a fatJAR), everything works as expected when I go to `http://localhost:8080/` -> the `index.html` gets served to the browser.  The problem arises when I want to use these resources from inside native-image packed .exe file on my Windows machine (using spring-native).  I packed the file properly using declaration inside `resource-config.json` as:  ```json {   ""resources"": [     {       ""pattern"": ""\\Qpublic/index.html\\E""     }   ],   ""bundles"": [] } ```  But the `http://localhost:8080/` page is not serving `index.html` out of the box.  The only way, how I currently hardcoded this to show-up is using this code:  ```java @Configuration @AutoConfigureAfter(DispatcherServletAutoConfiguration.class) public class Config implements WebMvcConfigurer {   @Override   public void addResourceHandlers(ResourceHandlerRegistry registry) {     ResourceResolver resolver = new StreamResResolver();     registry         .addResourceHandler(""/**"")         .addResourceLocations(             ""classpath:/META-INF/resources/"",             ""classpath:/resources/"",             ""classpath:/static/"",             ""classpath:/public/"")         .resourceChain(false)         .addResolver(resolver);   }    public class StreamResResolver implements ResourceResolver {     @Override     public Resource resolveResource(         HttpServletRequest request,         String requestPath,         List","closed","status: declined,","bojanv55","2021-10-15T21:54:24Z","2021-11-24T20:57:16Z"
"","27125","Avoid duplicated code by using map","I propose to remove duplicated code by using map. I think it will improve simplicity and readability.  Thank you : )","closed","","YooInKeun","2021-07-04T04:22:14Z","2022-02-18T19:05:42Z"
"","27126","Avoid duplicated code by using map","I propose to avoid duplicated code by using map. I think it will improve simplicity and readability.  Thank you : )","closed","","YooInKeun","2021-07-04T04:53:18Z","2022-02-18T19:05:43Z"
"","27127","Avoid duplicated code by using map","I propose to avoid duplicated code by using map. I think it will improve simplicity and readability. Thank you : )","open","in: core,","YooInKeun","2021-07-04T06:14:31Z","2021-11-11T09:49:14Z"
"","27628","Implement support for Kotlin Serialization of CBOR and Protocol Buffers","I noticed that Spring only had built in support for Kotlin Serializations to/from JSON, but that the existing implementation for Kotlin Serialization of JSON was mostly sufficient for a more general implementation.  With a few modifications Spring gains support for Kotlin Serialization to CBOR and Protocol Buffers AND the ability to manually configure other Kotlin Serialization types.","open","in: kotlin,","iain-henderson","2021-11-01T10:59:19Z","2022-02-19T22:40:28Z"
"","27279","Implement a MockReactiveRestServiceServer for WebClient testing","I noticed that Spring does not currently provide the same tools for testing WebClient-based reactive remote calls that the non-reactive RestTemplate API has, which from experience recently has lead to a little bit of frustration due to having to use more  heavyweight/complicated non-Spring APIs to mock WebClient calls.  Since this felt relatively simple to implement, I went ahead and attempted to draft a reactive counterpart to the existing non-reactive MockRestServiceServer API.  This implementation is a shim that internally converts all requests and responses to the non-reactive counterparts. This enables the reactive API to use all the existing non-reactive request and response verification components without having to duplicate the entire API.  WebClientUtils in WebFlux has had to be updated to exclude Error types from the filter, otherwise AssertionErrors always end up being filtered out by the ExchangeFunctions conduit. I don't believe this should be an issue though, as the JavaDoc for Error types states that ""no reasonable application should try to catch these types"", which means that the ExchangeFunctions probably shouldn't have been allowing this through in the first place. Applied de-Morgans law to reduce the complexity of the expression a little.  The API itself attempts to be as similar to MockRestServiceServer as possible. For example:  ```kotlin val server = MockReactiveRestServiceServer.createServer() val client = server.createWebClient() val responseHeaders = HttpHeaders()  responseHeaders.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)  server     .expect(requestTo(""/actuator/health""))     .andExpect(method(HttpMethod.GET))     .andExpect(header(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE))     .andRespond(withSuccess()         .headers(responseHeaders)         .body(""""""{""status"": ""UP""}""""""))  StepVerifier     .create(client.get().uri(""/actuator/health"").retrieve().bodyToMono(String.class))     .assertNext { assertThat(it).isEqualTo(""""""{""status"": ""UP""}"""""") }     .verify() ```  Hope that contributions such as this are not considered out of place, or anything. If this is in the wrong place, please let me know!  Likewise if there are any other suggestions or feedback, I'd be happy to take those into account!","open","in: web,","ascopes","2021-08-14T14:17:18Z","2021-11-08T11:37:36Z"
"","27901","Potential resource leak in HttpComponentsAsyncClientHttpResponse?","I know AsyncRestTemplate is deprecated, but by looking at the code of HttpComponentsAsyncClientHttpResponse: ```java 	@Override 	public InputStream getBody() throws IOException { 		HttpEntity entity = this.httpResponse.getEntity(); 		return (entity != null ? entity.getContent() : StreamUtils.emptyInput()); 	}  	@Override 	public void close() {         // HTTP responses returned by async HTTP client are not bound to an         // active connection and do not have to deallocate any resources... 	} ``` I see that the InputStream of the apache httpResponse is exposed as the inputStream of the ClientHttpResponse.  Apache HttpComponents's HttpEntity expects this inputStream to be closed by the consumer, but this expectation doesn't seem to match the contract of, for example, ResponseErrorHandler, implementations of which could handle errors without dealing with the content of the response. The `close()` of the ClientHttpResponses would do nothing and the underlying httpEntity would be ""unconsumed"". (Other implementations like OkHttp or Netty do actually close the internal resources)  I am not reproducing this as a specific bug, i'm investigating another issue and found this worth recording just in case something is not correct.","closed","status: feedback-provided,","flozano","2022-01-07T13:17:16Z","2022-02-01T13:05:14Z"
"","26959","Support transactions across multiple DataSources","I install Multi dataSource. but you can't support transaction.  When an exception occurs, roll back the last one,because the current thread is bound to a last transaction.  current thread Whether you can bind multiple TransactionInfo. When an exception occurs, roll back all transaction;","closed","status: declined,","zhb-github","2021-05-20T03:03:27Z","2021-05-20T13:59:27Z"
"","27253","IllegalStateException after upgrading Spring MVC from 4.3.9 to 5.2.6: Ambiguous handler methods mapped","I have two `@RequestMapping`  methods like below in my RestController class. One service methods is to consume the `application/x-www-form-urlencoded` Media Type and other to consume all the other type of requests. This is working correctly in Spring Boot 1.5.4 but results in Ambiguous handler methods exception after upgrading to Spring boot 2.2.7   ```java @RequestMapping(value = ""/**"") public ResponseEntity service(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, 		@RequestParam(required = false) MultiValueMap requestParams, 		@RequestBody(required = false) String requestBody, @PathVariable(required = false) String pathVariables, 		@RequestHeader(required = false) MultiValueMap headerVariables) { 	System.out.println(""Inside Service method""); 	return new ResponseEntity(HttpStatus.ACCEPTED); }  @RequestMapping(value = ""/**"", consumes = ""application/x-www-form-urlencoded"") public ResponseEntity serviceURLEncode(HttpServletRequest httpServletRequest, 			HttpServletResponse httpServletResponse, 		@RequestParam(required = false) MultiValueMap requestParams, 		@PathVariable(required = false) String pathVariables, 		@RequestBody(required = false) MultiValueMap formParam, 		@RequestHeader(required = false) MultiValueMap headerVariables) { 	System.out.println(""Inside Service method:application/x-www-form-urlencoded""); 	return new ResponseEntity(HttpStatus.ACCEPTED); } ```  The below block of code in `ConsumesRequestCondition:getMatchingCondition` introduced in the newer Spring MVC is causing this issue.  ```java if (!hasBody(request) && !this.bodyRequired) { 	return EMPTY_CONDITION; } ```","closed","in: web,","balaji-itorix","2021-08-09T20:45:29Z","2021-09-06T10:18:51Z"
"","27353","Cannot find bean by nested generic interface type","I have these interfaces: ```kotlin interface Query  interface QueryHandler where TQuery : Query {     fun execute(query: TQuery): TResult } ``` and dispatcher: ```kotlin abstract class QueryDispatcher {     abstract fun  dispatch(query: TQuery, queryType: KClass, resultType: KClass): TResult where TQuery : Query     inline fun  dispatch(query: TQuery) where TQuery : Query =         dispatch(query, TQuery::class, TResult::class) }  class InMemoryQueryDispatcher(     private val applicationContext: GenericWebApplicationContext ) : QueryDispatcher() {     override fun  dispatch(query: TQuery, queryType: KClass, resultType: KClass): TResult {         val beanFactory = applicationContext.beanFactory          val resolvableType = ResolvableType.forClassWithGenerics(QueryHandler::class.java, queryType.java, resultType.java)         val beans = applicationContext.getBeanNamesForType(resolvableType)          val handler = beanFactory.getBean(beans.first())         ...     } } ``` This handler implementation with non-generic `TResult` works: ```kotlin class GetUserHandler() : QueryHandler { ... } ``` but when I use another generic there: ```kotlin class GetUsersHandler() : QueryHandler { ... } ``` Spring cannot find my handler bean.  My findings: `ResolvableType.forClassWithGenerics()` produces `ResolvableType` `QueryHandler","open","in: core,","leoshusar","2021-09-02T22:32:03Z","2021-11-11T09:22:59Z"
"","27019","Spring AOP: After upgrade to spring boot 2.4.5 Spring Aspect is not longer initialized","I have recently upgraded all my projects to run on new spring boot 2.4.5.  And I have all of them using the same aspect that comes from my common library.  And one project is broken as this aspect is not being initialized. Code-wise nothing has changed, but the dependency graph.  Here is the maven tree for the project:  ``` [INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ maas-gateway --- [INFO] com.company.maas:maas-gateway:jar:1.0-SNAPSHOT [INFO] +- com.company.maas:maas-base:jar:28.4.0:compile [INFO] |  +- com.companysystems:sol-jcsmp:jar:10.6.3:compile [INFO] |  |  +- commons-logging:commons-logging:jar:1.1.3:compile [INFO] |  |  +- commons-lang:commons-lang:jar:2.6:compile [INFO] |  |  +- org.osgi:org.osgi.annotation:jar:6.0.0:compile [INFO] |  |  \- org.apache.servicemix.bundles:org.apache.servicemix.bundles.jzlib:jar:1.0.7_2:compile [INFO] |  +- org.apache.shiro:shiro-spring-boot-web-starter:jar:1.7.1:compile [INFO] |  |  +- org.apache.shiro:shiro-spring-boot-starter:jar:1.7.1:compile [INFO] |  |  |  \- org.apache.shiro:shiro-spring:jar:1.7.1:compile [INFO] |  |  |     +- org.apache.shiro:shiro-core:jar:1.7.1:compile [INFO] |  |  |     |  +- org.apache.shiro:shiro-lang:jar:1.7.1:compile [INFO] |  |  |     |  +- org.apache.shiro:shiro-cache:jar:1.7.1:compile [INFO] |  |  |     |  +- org.apache.shiro:shiro-crypto-hash:jar:1.7.1:compile [INFO] |  |  |     |  |  \- org.apache.shiro:shiro-crypto-core:jar:1.7.1:compile [INFO] |  |  |     |  +- org.apache.shiro:shiro-crypto-cipher:jar:1.7.1:compile [INFO] |  |  |     |  +- org.apache.shiro:shiro-config-core:jar:1.7.1:compile [INFO] |  |  |     |  +- org.apache.shiro:shiro-config-ogdl:jar:1.7.1:compile [INFO] |  |  |     |  |  \- commons-beanutils:commons-beanutils:jar:1.9.4:compile [INFO] |  |  |     |  \- org.apache.shiro:shiro-event:jar:1.7.1:compile [INFO] |  |  |     \- org.apache.shiro:shiro-web:jar:1.7.1:compile [INFO] |  |  |        \- org.owasp.encoder:encoder:jar:1.2.2:compile [INFO] |  |  \- org.springframework.boot:spring-boot-autoconfigure:jar:2.4.5:compile [INFO] |  +- org.springframework.boot:spring-boot-starter-data-jpa:jar:2.4.5:compile [INFO] |  |  +- org.springframework.boot:spring-boot-starter-jdbc:jar:2.4.5:compile [INFO] |  |  |  +- com.zaxxer:HikariCP:jar:3.4.5:compile [INFO] |  |  |  \- org.springframework:spring-jdbc:jar:5.3.6:compile [INFO] |  |  +- jakarta.transaction:jakarta.transaction-api:jar:1.3.3:compile [INFO] |  |  +- jakarta.persistence:jakarta.persistence-api:jar:2.2.3:compile [INFO] |  |  +- org.hibernate:hibernate-core:jar:5.4.30.Final:compile [INFO] |  |  |  +- org.javassist:javassist:jar:3.27.0-GA:compile [INFO] |  |  |  +- antlr:antlr:jar:2.7.7:compile [INFO] |  |  |  +- org.jboss:jandex:jar:2.2.3.Final:compile [INFO] |  |  |  +- org.dom4j:dom4j:jar:2.1.3:compile [INFO] |  |  |  +- org.hibernate.common:hibernate-commons-annotations:jar:5.1.2.Final:compile [INFO] |  |  |  \- org.glassfish.jaxb:jaxb-runtime:jar:2.3.4:compile [INFO] |  |  |     +- org.glassfish.jaxb:txw2:jar:2.3.4:compile [INFO] |  |  |     +- com.sun.istack:istack-commons-runtime:jar:3.0.12:compile [INFO] |  |  |     \- com.sun.activation:jakarta.activation:jar:1.2.2:runtime [INFO] |  |  \- org.springframework.data:spring-data-jpa:jar:2.4.8:compile [INFO] |  |     +- org.springframework.data:spring-data-commons:jar:2.4.8:compile [INFO] |  |     +- org.springframework:spring-orm:jar:5.3.6:compile [INFO] |  |     \- org.springframework:spring-tx:jar:5.3.6:compile [INFO] |  +- net.logstash.logback:logstash-logback-encoder:jar:6.6:compile [INFO] |  +- com.google.guava:guava:jar:30.1.1-jre:compile [INFO] |  |  +- com.google.guava:failureaccess:jar:1.0.1:compile [INFO] |  |  +- com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile [INFO] |  |  +- com.google.code.findbugs:jsr305:jar:3.0.2:compile [INFO] |  |  +- org.checkerframework:checker-qual:jar:3.8.0:compile [INFO] |  |  +- com.google.errorprone:error_prone_annotations:jar:2.5.1:compile [INFO] |  |  \- com.google.j2objc:j2objc-annotations:jar:1.3:compile [INFO] |  +- org.hibernate.validator:hibernate-validator:jar:6.1.7.Final:compile [INFO] |  |  +- jakarta.validation:jakarta.validation-api:jar:2.0.2:compile [INFO] |  |  +- org.jboss.logging:jboss-logging:jar:3.4.1.Final:compile [INFO] |  |  \- com.fasterxml:classmate:jar:1.5.1:compile [INFO] |  +- com.auth0:java-jwt:jar:3.15.0:compile [INFO] |  +- org.mapstruct:mapstruct:jar:1.4.2.Final:compile [INFO] |  +- org.projectlombok:lombok:jar:1.18.20:compile [INFO] |  \- com.google.code.gson:gson:jar:2.8.6:compile [INFO] +- com.company.maas:maas-es-common:jar:5.0.0:compile [INFO] |  +- org.elasticsearch:elasticsearch:jar:7.1.0:compile [INFO] |  |  +- org.elasticsearch:elasticsearch-core:jar:7.1.0:compile [INFO] |  |  +- org.elasticsearch:elasticsearch-secure-sm:jar:7.1.0:compile [INFO] |  |  +- org.elasticsearch:elasticsearch-x-content:jar:7.1.0:compile [INFO] |  |  |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-smile:jar:2.12.3:compile [INFO] |  |  |  \- com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:jar:2.12.3:compile [INFO] |  |  +- org.elasticsearch:elasticsearch-geo:jar:7.1.0:compile [INFO] |  |  +- org.apache.lucene:lucene-core:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-analyzers-common:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-backward-codecs:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-grouping:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-highlighter:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-join:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-memory:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-misc:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-queries:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-queryparser:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-sandbox:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-spatial:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-spatial-extras:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-spatial3d:jar:8.0.0:compile [INFO] |  |  +- org.apache.lucene:lucene-suggest:jar:8.0.0:compile [INFO] |  |  +- org.elasticsearch:elasticsearch-cli:jar:7.1.0:compile [INFO] |  |  |  \- net.sf.jopt-simple:jopt-simple:jar:5.0.2:compile [INFO] |  |  +- com.carrotsearch:hppc:jar:0.7.1:compile [INFO] |  |  +- joda-time:joda-time:jar:2.10.1:compile [INFO] |  |  +- com.tdunning:t-digest:jar:3.2:compile [INFO] |  |  \- org.elasticsearch:jna:jar:4.5.1:compile [INFO] |  \- org.elasticsearch.client:elasticsearch-rest-high-level-client:jar:7.1.0:compile [INFO] |     +- org.elasticsearch.client:elasticsearch-rest-client:jar:7.1.0:compile [INFO] |     |  +- org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile [INFO] |     |  \- org.apache.httpcomponents:httpcore-nio:jar:4.4.14:compile [INFO] |     +- org.elasticsearch.plugin:parent-join-client:jar:7.1.0:compile [INFO] |     +- org.elasticsearch.plugin:aggs-matrix-stats-client:jar:7.1.0:compile [INFO] |     +- org.elasticsearch.plugin:rank-eval-client:jar:7.1.0:compile [INFO] |     \- org.elasticsearch.plugin:lang-mustache-client:jar:7.1.0:compile [INFO] |        \- com.github.spullara.mustache.java:compiler:jar:0.9.3:compile [INFO] +- org.springframework.boot:spring-boot-starter-actuator:jar:2.4.5:compile [INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.4.5:compile [INFO] |  |  +- org.springframework.boot:spring-boot:jar:2.4.5:compile [INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.4.5:compile [INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile [INFO] |  |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile [INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile [INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.30:compile [INFO] |  |  +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile [INFO] |  |  \- org.yaml:snakeyaml:jar:1.27:compile [INFO] |  \- org.springframework.boot:spring-boot-actuator-autoconfigure:jar:2.4.5:compile [INFO] |     +- org.springframework.boot:spring-boot-actuator:jar:2.4.5:compile [INFO] |     \- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.12.3:compile [INFO] +- org.springframework.cloud:spring-cloud-starter-config:jar:3.0.3:compile [INFO] |  +- org.springframework.cloud:spring-cloud-starter:jar:3.0.2:compile [INFO] |  |  +- org.springframework.cloud:spring-cloud-context:jar:3.0.2:compile [INFO] |  |  |  \- org.springframework.security:spring-security-crypto:jar:5.4.6:compile [INFO] |  |  +- org.springframework.cloud:spring-cloud-commons:jar:3.0.2:compile [INFO] |  |  \- org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile [INFO] |  |     \- org.bouncycastle:bcpkix-jdk15on:jar:1.68:compile (optional) [INFO] |  |        \- org.bouncycastle:bcprov-jdk15on:jar:1.68:compile (optional) [INFO] |  +- org.springframework.cloud:spring-cloud-config-client:jar:3.0.3:compile [INFO] |  |  \- com.fasterxml.jackson.core:jackson-annotations:jar:2.12.3:compile [INFO] |  \- com.fasterxml.jackson.core:jackson-databind:jar:2.12.2:compile [INFO] |     \- com.fasterxml.jackson.core:jackson-core:jar:2.12.3:compile [INFO] +- org.springframework.retry:spring-retry:jar:1.3.1:compile [INFO] |  \- javax.annotation:javax.annotation-api:jar:1.3.2:compile [INFO] +- org.springframework.vault:spring-vault-core:jar:2.3.2:compile [INFO] |  +- org.springframework:spring-core:jar:5.3.6:compile [INFO] |  |  \- org.springframework:spring-jcl:jar:5.3.6:compile [INFO] |  +- org.springframework:spring-context:jar:5.3.6:compile [INFO] |  |  +- org.springframework:spring-aop:jar:5.3.6:compile [INFO] |  |  \- org.springframework:spring-expression:jar:5.3.6:compile [INFO] |  +- org.springframework:spring-beans:jar:5.3.6:compile [INFO] |  \- org.springframework:spring-web:jar:5.3.6:compile [INFO] +- org.mariadb.jdbc:mariadb-java-client:jar:2.7.2:runtime [INFO] +- org.liquibase:liquibase-core:jar:4.3.5:compile [INFO] |  \- javax.xml.bind:jaxb-api:jar:2.3.1:compile [INFO] |     \- javax.activation:javax.activation-api:jar:1.2.0:compile [INFO] +- com.amazonaws:aws-java-sdk-s3:jar:1.11.281:compile [INFO] |  +- com.amazonaws:aws-java-sdk-kms:jar:1.11.281:compile [INFO] |  +- com.amazonaws:aws-java-sdk-core:jar:1.11.281:compile [INFO] |  |  +- software.amazon.ion:ion-java:jar:1.0.2:compile [INFO] |  |  \- com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:jar:2.12.3:compile [INFO] |  \- com.amazonaws:jmespath-java:jar:1.11.281:compile [INFO] +- org.springframework.cloud:spring-cloud-starter-netflix-zuul:jar:2.2.8.RELEASE:compile [INFO] |  +- org.springframework.cloud:spring-cloud-netflix-zuul:jar:2.2.8.RELEASE:compile [INFO] |  |  +- org.springframework.cloud:spring-cloud-netflix-hystrix:jar:2.2.8.RELEASE:compile [INFO] |  |  \- com.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:compile [INFO] |  |     \- javax.inject:javax.inject:jar:1:runtime [INFO] |  +- org.springframework.boot:spring-boot-starter-web:jar:2.4.5:compile [INFO] |  |  +- org.springframework.boot:spring-boot-starter-json:jar:2.4.5:compile [INFO] |  |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.12.3:compile [INFO] |  |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.12.3:compile [INFO] |  |  \- org.springframework.boot:spring-boot-starter-tomcat:jar:2.4.5:compile [INFO] |  |     +- org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.45:compile [INFO] |  |     +- org.glassfish:jakarta.el:jar:3.0.3:compile [INFO] |  |     \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.45:compile [INFO] |  +- org.springframework.cloud:spring-cloud-starter-netflix-hystrix:jar:2.2.8.RELEASE:compile [INFO] |  |  +- org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.8.RELEASE:compile [INFO] |  |  +- com.netflix.hystrix:hystrix-core:jar:1.5.18:compile [INFO] |  |  +- com.netflix.hystrix:hystrix-serialization:jar:1.5.18:compile [INFO] |  |  |  \- com.fasterxml.jackson.module:jackson-module-afterburner:jar:2.12.3:runtime [INFO] |  |  +- com.netflix.hystrix:hystrix-metrics-event-stream:jar:1.5.18:compile [INFO] |  |  +- com.netflix.hystrix:hystrix-javanica:jar:1.5.18:compile [INFO] |  |  \- io.reactivex:rxjava-reactive-streams:jar:1.2.1:compile [INFO] |  |     \- org.reactivestreams:reactive-streams:jar:1.0.3:runtime [INFO] |  +- org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.8.RELEASE:compile [INFO] |  |  +- com.netflix.ribbon:ribbon:jar:2.3.0:compile [INFO] |  |  |  +- com.netflix.ribbon:ribbon-transport:jar:2.3.0:runtime [INFO] |  |  |  |  +- io.reactivex:rxnetty-contexts:jar:0.4.9:runtime [INFO] |  |  |  |  \- io.reactivex:rxnetty-servo:jar:0.4.9:runtime [INFO] |  |  |  \- io.reactivex:rxnetty:jar:0.4.9:runtime [INFO] |  |  +- com.netflix.ribbon:ribbon-core:jar:2.3.0:compile [INFO] |  |  +- com.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compile [INFO] |  |  |  +- commons-collections:commons-collections:jar:3.2.2:compile [INFO] |  |  |  +- com.sun.jersey:jersey-client:jar:1.19.1:runtime [INFO] |  |  |  |  \- com.sun.jersey:jersey-core:jar:1.19.1:runtime [INFO] |  |  |  |     \- javax.ws.rs:jsr311-api:jar:1.1.1:runtime [INFO] |  |  |  \- com.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtime [INFO] |  |  +- com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile [INFO] |  |  |  \- com.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtime [INFO] |  |  \- io.reactivex:rxjava:jar:1.3.8:compile [INFO] |  +- org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.8.RELEASE:compile [INFO] |  |  +- org.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.8.RELEASE:compile [INFO] |  |  +- com.netflix.archaius:archaius-core:jar:0.7.7:compile [INFO] |  |  \- commons-configuration:commons-configuration:jar:1.8:compile [INFO] |  \- com.netflix.zuul:zuul-core:jar:1.3.1:compile [INFO] |     \- com.netflix.servo:servo-core:jar:0.7.2:runtime [INFO] +- commons-io:commons-io:jar:2.9.0:compile [INFO] +- org.apache.commons:commons-compress:jar:1.20:compile [INFO] +- javax.mail:mail:jar:1.4.7:compile [INFO] |  \- javax.activation:activation:jar:1.1:compile [INFO] +- com.sparkpost:sparkpost-lib:jar:0.23:compile [INFO] |  +- org.apache.httpcomponents:httpclient:jar:4.5.13:compile [INFO] |  |  \- org.apache.httpcomponents:httpcore:jar:4.4.14:compile [INFO] |  +- org.apache.commons:commons-lang3:jar:3.11:compile [INFO] |  +- commons-codec:commons-codec:jar:1.15:compile [INFO] |  +- com.google.code.findbugs:annotations:jar:3.0.0:compile [INFO] |  +- com.yepher.jsondoc:annotations:jar:0.0.2:compile [INFO] |  \- org.slf4j:slf4j-api:jar:1.7.30:compile [INFO] +- org.apache.logging.log4j:log4j-api:jar:2.14.1:compile [INFO] +- org.apache.logging.log4j:log4j-core:jar:2.14.1:compile [INFO] +- org.apache.logging.log4j:log4j-1.2-api:jar:2.14.1:compile [INFO] +- org.passay:passay:jar:1.6.0:compile [INFO] +- com.nimbusds:oauth2-oidc-sdk:jar:9.8:compile [INFO] |  +- com.github.stephenc.jcip:jcip-annotations:jar:1.0-1:compile [INFO] |  +- com.nimbusds:content-type:jar:2.1:compile [INFO] |  +- com.nimbusds:lang-tag:jar:1.5:compile [INFO] |  \- com.nimbusds:nimbus-jose-jwt:jar:8.20.2:compile [INFO] +- net.minidev:json-smart:jar:2.4.7:compile [INFO] |  \- net.minidev:accessors-smart:jar:2.4.7:compile [INFO] |     \- org.ow2.asm:asm:jar:9.1:compile [INFO] +- org.junit.vintage:junit-vintage-engine:jar:5.8.0-M1:test [INFO] |  +- org.apiguardian:apiguardian-api:jar:1.1.1:test [INFO] |  +- org.junit.platform:junit-platform-engine:jar:1.7.1:test [INFO] |  |  +- org.opentest4j:opentest4j:jar:1.2.0:test [INFO] |  |  \- org.junit.platform:junit-platform-commons:jar:1.7.1:test [INFO] |  \- junit:junit:jar:4.13.2:test [INFO] |     \- org.hamcrest:hamcrest-core:jar:2.2:test [INFO] +- org.springframework.boot:spring-boot-starter-test:jar:2.4.5:test [INFO] |  +- org.springframework.boot:spring-boot-test:jar:2.4.5:test [INFO] |  +- org.springframework.boot:spring-boot-test-autoconfigure:jar:2.4.5:test [INFO] |  +- com.jayway.jsonpath:json-path:jar:2.4.0:test [INFO] |  +- jakarta.xml.bind:jakarta.xml.bind-api:jar:2.3.3:compile [INFO] |  |  \- jakarta.activation:jakarta.activation-api:jar:1.2.2:compile [INFO] |  +- org.assertj:assertj-core:jar:3.19.0:test [INFO] |  +- org.hamcrest:hamcrest:jar:2.2:test [INFO] |  +- org.junit.jupiter:junit-jupiter:jar:5.7.1:test [INFO] |  |  +- org.junit.jupiter:junit-jupiter-api:jar:5.7.1:test [INFO] |  |  +- org.junit.jupiter:junit-jupiter-params:jar:5.7.1:test [INFO] |  |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.7.1:test [INFO] |  +- org.mockito:mockito-core:jar:3.9.0:test [INFO] |  |  +- net.bytebuddy:byte-buddy:jar:1.10.22:compile [INFO] |  |  +- net.bytebuddy:byte-buddy-agent:jar:1.10.22:test [INFO] |  |  \- org.objenesis:objenesis:jar:3.2:test [INFO] |  +- org.mockito:mockito-junit-jupiter:jar:3.9.0:test [INFO] |  +- org.skyscreamer:jsonassert:jar:1.5.0:test [INFO] |  |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test [INFO] |  +- org.springframework:spring-test:jar:5.3.6:test [INFO] |  \- org.xmlunit:xmlunit-core:jar:2.7.0:test [INFO] +- org.springframework:spring-aspects:jar:5.3.6:compile [INFO] |  \- org.aspectj:aspectjweaver:jar:1.9.6:compile [INFO] +- org.springframework.restdocs:spring-restdocs-mockmvc:jar:2.0.5.RELEASE:test [INFO] |  +- javax.servlet:javax.servlet-api:jar:4.0.1:test [INFO] |  +- org.springframework.restdocs:spring-restdocs-core:jar:2.0.5.RELEASE:test [INFO] |  \- org.springframework:spring-webmvc:jar:5.3.6:compile [INFO] +- com.h2database:h2:jar:1.4.200:test [INFO] +- org.apache.commons:commons-email:jar:1.5:test [INFO] |  \- com.sun.mail:javax.mail:jar:1.5.6:test [INFO] +- com.company.maas:maas-base:test-jar:tests:28.4.0:test [INFO] +- org.testcontainers:elasticsearch:jar:1.15.3:test [INFO] |  \- org.testcontainers:testcontainers:jar:1.15.3:test [INFO] |     +- org.rnorth.duct-tape:duct-tape:jar:1.0.8:test [INFO] |     +- org.rnorth.visible-assertions:visible-assertions:jar:2.1.2:test [INFO] |     |  \- net.java.dev.jna:jna:jar:5.2.0:test [INFO] |     +- com.github.docker-java:docker-java-api:jar:3.2.8:test [INFO] |     \- com.github.docker-java:docker-java-transport-zerodep:jar:3.2.8:test [INFO] |        \- com.github.docker-java:docker-java-transport:jar:3.2.8:test [INFO] +- io.jsonwebtoken:jjwt:jar:0.9.1:compile [INFO] +- io.micrometer:micrometer-registry-statsd:jar:1.6.6:compile [INFO] +- io.micrometer:micrometer-core:jar:1.6.6:compile [INFO] |  +- org.hdrhistogram:HdrHistogram:jar:2.1.12:compile [INFO] |  \- org.latencyutils:LatencyUtils:jar:2.0.3:runtime [INFO] +- org.springframework.cloud:spring-cloud-starter-sleuth:jar:3.0.2:compile [INFO] |  +- org.springframework.boot:spring-boot-starter-aop:jar:2.4.5:compile [INFO] |  +- org.springframework.cloud:spring-cloud-sleuth-autoconfigure:jar:3.0.2:compile [INFO] |  |  +- org.springframework.cloud:spring-cloud-sleuth-instrumentation:jar:3.0.2:compile [INFO] |  |  |  \- org.springframework.cloud:spring-cloud-sleuth-api:jar:3.0.2:compile [INFO] |  |  \- org.aspectj:aspectjrt:jar:1.9.6:compile [INFO] |  \- org.springframework.cloud:spring-cloud-sleuth-brave:jar:3.0.2:compile [INFO] |     +- io.zipkin.brave:brave:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-context-slf4j:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-messaging:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-rpc:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-spring-rabbit:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-kafka-clients:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-kafka-streams:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-httpclient:jar:5.13.2:compile [INFO] |     |  \- io.zipkin.brave:brave-instrumentation-http:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-httpasyncclient:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-jms:jar:5.13.2:compile [INFO] |     +- io.zipkin.brave:brave-instrumentation-mongodb:jar:5.13.2:compile [INFO] |     +- io.zipkin.aws:brave-propagation-aws:jar:0.21.3:compile [INFO] |     \- io.zipkin.reporter2:zipkin-reporter-metrics-micrometer:jar:2.16.1:compile [INFO] |        \- io.zipkin.reporter2:zipkin-reporter:jar:2.16.1:compile [INFO] |           \- io.zipkin.zipkin2:zipkin:jar:2.23.0:compile [INFO] \- io.opentracing.brave:brave-opentracing:jar:0.37.4:compile [INFO]    \- io.opentracing:opentracing-api:jar:0.32.0:compile ```  Should I be aware of any incompatible dependencies or other breaking changes?","closed","status: invalid,","imochurad","2021-06-03T21:13:02Z","2021-06-04T14:07:15Z"
"","26902","Javax validation triggered in tests after Spring Boot upgrade to 2.3.4 and not in 2.0.8","I have code that has validations like the following.  In the test setup, when i pass a null value to this method, there is an exception.   ```java @Validated public class MyTestClass { 	 	 	public String testMethod(@NotNull String testValue){             if (StringUtils.isBlank(testValue)) { 			throw new Exception(""value is null""); 		}        } 	 } ```  The exception looks like this:  ``` javax.validation.ConstraintViolationException: testMethod.testValue: must not be null 	at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:116) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ```  However, when i run the same test in Spring Boot 2.0.8, the exception looks like this:  ``` .Exception: value is null 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:86) 	at org.testng.internal.MethodInvocationHelper$1.runTestMethod(MethodInvocationHelper.java:197) 	at org.springframework.test.context.testng.AbstractTestNGSpringContextTests.run(AbstractTestNGSpringContextTests.java:180) ```  I debugged why this is happening, and the only conclusion i could derive is that `invoke(MethodValidationInterceptor` is invoked only in case of Spring Boot 2.3.4 and not in Spring Boot 2.0.8.  The version of `javax.validation` being used is the same in both the cases.  Can you please help me understand why this happens and if this is an expected change in behavior?","open","in: core,","nandwaniS","2021-05-06T19:12:59Z","2021-11-12T14:17:55Z"
"","27054","Possible bug not applying exception resolver with empty handlers","I have a project (Spring 5.3.7) that contains a controller and exception handlers using the `@ControllerAdvice` and `@ExceptionHandler` annotations.  I'm also using Spring Integration DSL to create a HTTP inbound gateway. No error channel is set on the gateway.  My exception handlers are not being called when an exception is thrown in the integration flow (in the same thread).  I actually did not expect it to work automatically, but while debugging the code I noticed that it actually almost all works except for one line.  Line 51-53 of `AbstractHandlerMethodExceptionResolver` contains:  ```java else if (hasGlobalExceptionHandlers() && hasHandlerMappings()) { 			return super.shouldApplyTo(request, handler); 		} ```		  Because there are no handler mappings, my exceptions handlers are never applied to exceptions from the integration flow.  I'm surprised about the check of `hasHandlerMappings()` in the if statement. Might this be a bug?  I ask this because the logic in the block above it, and in `shouldApplyTo`, suggests that a resolver should always be applied when no handler mappings are available.  Line 183 of `AbstractHandlerExceptionResolver`:  ```java return !hasHandlerMappings(); ```  If the code actually is intended to work like this, then I'd like to know how I can set the mappings so that the exception handlers work both for my controllers and spring integration.  I'm currently doing it in a very hacky way by iterating over the `ExceptionHandlerExceptionResolver` beans, and doing some casts, and calling `setMappedHandlerClasses`.  How are the handler mappings supposed to be set?","closed","status: invalid,","robertvanloenhout","2021-06-11T15:12:43Z","2021-06-15T14:25:08Z"
"","27598","exception when calling an Rsocket endpoint with the RSocketRequester on an Apple M1 running macOs","i get an odd exception when calling an Rsocket controller using the RSocketRequester on an Apple M1 when using Spring Boot 2.5.x  ```java               var requester = RSocketRequester.builder().tcp(""localhost"", 8181);             var message = requester.route(""hello"").retrieveMono(String.class).block();             System.out.println(""message: "" + message);  ```   results in   ```java  java.lang.reflect.InvocationTargetException: null 	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:na] 	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) ~[na:na] 	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480) ~[na:na] 	at io.netty.resolver.dns.DnsServerAddressStreamProviders.(DnsServerAddressStreamProviders.java:64) ~[netty-resolver-dns-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.resolver.dns.DnsNameResolverBuilder.(DnsNameResolverBuilder.java:60) ~[netty-resolver-dns-4.1.69.Final.jar:4.1.69.Final] 	at reactor.netty.transport.NameResolverProvider.newNameResolverGroup(NameResolverProvider.java:455) ~[reactor-netty-core-1.0.12.jar:1.0.12] 	at reactor.netty.tcp.TcpResources.getOrCreateDefaultResolver(TcpResources.java:305) ~[reactor-netty-core-1.0.12.jar:1.0.12] 	at reactor.netty.tcp.TcpClientConfig.defaultAddressResolverGroup(TcpClientConfig.java:104) ~[reactor-netty-core-1.0.12.jar:1.0.12] 	at reactor.netty.transport.ClientTransportConfig.resolverInternal(ClientTransportConfig.java:223) ~[reactor-netty-core-1.0.12.jar:1.0.12] 	at reactor.netty.transport.ClientTransport.connect(ClientTransport.java:59) ~[reactor-netty-core-1.0.12.jar:1.0.12] 	at reactor.netty.tcp.TcpClient.connect(TcpClient.java:192) ~[reactor-netty-core-1.0.12.jar:1.0.12] 	at io.rsocket.transport.netty.client.TcpClientTransport.connect(TcpClientTransport.java:118) ~[rsocket-transport-netty-1.1.1.jar:na] 	at io.rsocket.core.RSocketConnector.lambda$null$6(RSocketConnector.java:551) ~[rsocket-core-1.1.1.jar:na] 	at reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:152) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4384) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:200) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:57) ~[reactor-core-3.4.11.jar:3.4.11] 	at io.rsocket.core.DefaultRSocketClient.doSubscribe(DefaultRSocketClient.java:181) ~[rsocket-core-1.1.1.jar:na] 	at io.rsocket.core.ResolvingOperator.add(ResolvingOperator.java:354) ~[rsocket-core-1.1.1.jar:na] 	at io.rsocket.core.ResolvingOperator.observe(ResolvingOperator.java:105) ~[rsocket-core-1.1.1.jar:na] 	at io.rsocket.core.DefaultRSocketClient$FlatMapMain.onNext(DefaultRSocketClient.java:287) ~[rsocket-core-1.1.1.jar:na] 	at io.rsocket.core.DefaultRSocketClient$FlatMapMain.onNext(DefaultRSocketClient.java:199) ~[rsocket-core-1.1.1.jar:na] 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:220) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:251) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:336) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.MonoCallable.subscribe(MonoCallable.java:62) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4399) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.11.jar:3.4.11] 	at io.rsocket.core.DefaultRSocketClient$RSocketClientMonoOperator.subscribe(DefaultRSocketClient.java:515) ~[rsocket-core-1.1.1.jar:na] 	at reactor.core.publisher.Mono.subscribe(Mono.java:4399) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.Mono.block(Mono.java:1705) ~[reactor-core-3.4.11.jar:3.4.11] 	at com.example.demo.DemoApplication.lambda$runner$0(DemoApplication.java:25) ~[classes/:na] 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:782) ~[spring-boot-2.5.6.jar:2.5.6] 	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:772) ~[spring-boot-2.5.6.jar:2.5.6] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:345) ~[spring-boot-2.5.6.jar:2.5.6] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.6.jar:2.5.6] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.6.jar:2.5.6] 	at com.example.demo.DemoApplication.main(DemoApplication.java:31) ~[classes/:na] Caused by: java.lang.UnsatisfiedLinkError: 'io.netty.resolver.dns.macos.DnsResolver[] io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.resolvers()' 	at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.resolvers(Native Method) ~[netty-resolver-dns-native-macos-4.1.69.Final-osx-x86_64.jar:4.1.69.Final] 	at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.retrieveCurrentMappings(MacOSDnsServerAddressStreamProvider.java:127) ~[netty-resolver-dns-native-macos-4.1.69.Final-osx-x86_64.jar:4.1.69.Final] 	at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.(MacOSDnsServerAddressStreamProvider.java:123) ~[netty-resolver-dns-native-macos-4.1.69.Final-osx-x86_64.jar:4.1.69.Final] 	... 47 common frames omitted ```","open","in: messaging,","joshlong","2021-10-22T21:39:32Z","2021-11-10T09:11:33Z"
"","27764","Update spring-webmvc RequestBodyAdvice.supports method","I found that when the RequestBodyAdvice is working, the supports method will be executed twice to determine whether it is applicable to the beforeBodyRead and afterBodyRead methods, but sometimes such a judgment is not necessary, so I think it should be split for different judgments, so I put RequestBodyAdvice The .supports method is divided into beforeBodySupport and afterBodySupport methods","closed","status: declined,","selfcoders","2021-12-04T01:43:17Z","2021-12-06T08:34:31Z"
"","27372","Invalid JavaBean property 'logoutHandlers' being accessed (warning in the logs for Spring Security's ConcurrentSessionFilter)","I found a warning in my logs, so I created a issue: https://github.com/spring-projects/spring-security/issues/10211  jgrandja closed my issue with this explanation: This issue should be logged in Spring Framework since GenericTypeAwarePropertyDescriptor exists there and is the one logging the warning message. However, I don't see this as an issue. If you want to suppress this warning message you could configure the logging framework to suppress that specific message or all logs in that class.  I think this should be fixed in spring-security, since your GenericTypeAwarePropertyDescriptor just logs similar looking methods, which could be a problem. In this case it is no problem since both methods with the name setLogoutHandlers have similar parameters, but doing the same, at least now.  > 11:54:01,463 WARN org.springframework.beans.GenericTypeAwarePropertyDescriptor [GenericTypeAwarePropertyDescriptor.java:141] - Invalid JavaBean property 'logoutHandlers' being accessed! Ambiguous write methods found next to actually used [public void org.springframework.security.web.session.ConcurrentSessionFilter.setLogoutHandlers(org.springframework.security.web.authentication.logout.LogoutHandler[])]: [public void org.springframework.security.web.session.ConcurrentSessionFilter.setLogoutHandlers(java.util.List)]  **Affects:**  Spring: 5.3.6 Spring-Security: 5.4.6","closed","type: enhancement,","ghost","2021-09-08T17:09:54Z","2021-09-13T16:15:59Z"
"","27105","Fix typo in BeanDefinitionDsl.kt","I found a typo in BeanDefinitionDsl.kt","closed","type: documentation,","takumi34","2021-06-29T16:22:49Z","2021-06-29T19:21:40Z"
"","27722","Avoid unescape when CONNECT and CONNECTED frames","I faced an error that stomp websocket client can not send a header with backslash. Then I found reason.  [StopmEncoder](https://github.com/spring-projects/spring-framework/blob/d84ca2ba90d27a7c63d7b35a6259b5b9cf341118/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompEncoder.java#L129) dose not escape headers when CONNECT and CONNECTED frames, to follow the spec below: https://stomp.github.io/stomp-specification-1.2.html#Value_Encoding However, StompDecoder try to unescape when CONNECT and CONNECTED frames.  StopmDecoder should not unescape when CONNECT and CONNECTED frames, because the frames are not escaped.","closed","type: enhancement,","rygh4775","2021-11-24T06:55:41Z","2021-12-14T07:11:12Z"
"","27890","Run http requests in WebFlux always throw timeout","I defined an interface to download a file  ```java @GetMapping(""/video.mp4"") public Mono video(ServerHttpResponse response) {     ZeroCopyHttpOutputMessage zeroCopyResponse = (ZeroCopyHttpOutputMessage) response;     response.getHeaders().set(HttpHeaders.CONTENT_DISPOSITION, ""attachment; filename=video.mp4"");     response.getHeaders().setContentType(MediaType.parseMediaType(""video/mpeg4""));     File file = new File(""/Users/Shared/video.mp4"");     return zeroCopyResponse.writeWith(file, 0, file.length()); } ```  And I defined a test interface to run http requests  ```java @GetMapping(""test"") public Mono a() throws InterruptedException {     CountDownLatch latch = new CountDownLatch(20);     ExecutorService executorService = Executors.newFixedThreadPool(5);     for (int i = 0; i < 20; i++) {         int index = i;         executorService.execute(() -> {             try {                 Request request = new Request.Builder()                 .url(""http://127.0.0.1:8080/video.mp4"")                 .build();                 Response response = new OkHttpClient().newCall(request).execute();                 if (response.code() == 200) {                     ResponseBody body = response.body();                     if (body == null) {                         throw new DownloadException(""Body is null"");                     }                     System.out.println(""s: "" + index);                 } else {                     System.out.println(""f: "" + index);                 }             } catch (Throwable e) {                 System.out.println(""e: "" + index);                 e.printStackTrace();             } finally {                 latch.countDown();             }         });     }     latch.await();     return Mono.empty(); } ```  But I got timeout exception on several of them  I did some tests  |Test|Result|Conclusion| |-|-|-| |Use `HttpClient` instead of `OkHttp`|Timeout exception|Http client has no problem| |Do not use `CountDownLatch`|Work well|I do not know why| |New `Thread` instead of `ExecutorService`|Timeout exception|ExecutorService has no problem| |Use `MVC` instead of `WebFlux`|Work well|Spring mvc is work well| |`MVC`(run http interface) request `WebFlux`(download file interface)|Timeout exception|The interface to download file has problem| |`WebFlux`(run http interface) request `MVC`(download file interface)|Work well|The interface to download file has problem|  Under the same conditions，use `CountDownLatch` makes timeout？  So I doubt  1. WebFlux bug 2. I write the wrong code to download a file  **spring boot version: 2.6.0**","closed","for: stackoverflow,","Linyuzai","2022-01-05T09:29:55Z","2022-01-05T11:00:53Z"
"","27881","SimpleJdbcInsert attempts to map from bigint(20) to Long and throws exception","I defined an entity class:  ```java class Clazz{     private long id;     private String cityHash;     public Clazz(){}     public Clazz(String cityHash){         this.cityHash = cityHash     } } ```  mysql: table city_hash  ```sql     `id` bigint(20) NOT NULL AUTO_INCREMENT,     `city_hash` bigint(20) unsigned NOT NULL COMMENT'Google city hash64', ```  I use SimpleJdbcInsert to insert data:  ```java     private SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(getJdbcTemplate()).withTableName(""city_hash"").usingGeneratedKeyColumns(""id"");     Clazz clazz = new Clazz(""12040412458563268888"")     Number newId = simpleJdbcInsert.executeAndReturnKey(clazz); ```  Exception:  ``` Caused by: org.springframework.dao.TransientDataAccessResourceException: PreparedStatementCallback; SQL [];  Cannot convert class java.lang.String to SQL type requested due to java.lang.NumberFormatException- For input string: ""12040412458563268888"";  nested exception is java. sql.SQLException: Cannot convert class java.lang.String to SQL type requested due to java.lang.NumberFormatException-For input string: ""12040412458563268888"" ```   I encountered this exception in spring 3+, it can insert data in spring 2.5. I think for database `bigint(20) unsigned` should not be automatically mapped as `Long` in java  Source code: (fun: AbstractJdbcInsert.executeInsertAndReturnKeyHolderInternal(List)) 3+  ```java 		if (this.tableMetaDataContext.isGetGeneratedKeysSupported()) { 			getJdbcTemplate().update( 					new PreparedStatementCreator() { 						public PreparedStatement createPreparedStatement(Connection con) throws SQLException { 							PreparedStatement ps = prepareStatementForGeneratedKeys(con); 							setParameterValues(ps, values, getInsertTypes()); 							return ps; 						} 					}, 					keyHolder); 		} ```  2.5  ```java         if (this.tableMetaDataContext.isGetGeneratedKeysSupported()) {             this.jdbcTemplate.update(new PreparedStatementCreator() {                 public PreparedStatement createPreparedStatement(Connection con) throws SQLException {                     PreparedStatement ps = AbstractJdbcInsert.this.prepareStatementForGeneratedKeys(con);                     AbstractJdbcInsert.this.setParameterValues(ps, values, (int[])null);                     return ps;                 }             }, keyHolder);             return keyHolder;         } ```","open","in: data,","EwainCai","2022-01-04T09:26:43Z","2022-01-29T12:21:50Z"
"","27366","Add an option to search parent MessageSource first for HierarchicalMessageSource","I created https://github.com/spring-projects/spring-security/pull/10235 Use `ApplicationContext` as parent `MessageSource` of `SpringSecurityMessageSource` ```java SpringSecurityMessageSource messageSource = new SpringSecurityMessageSource(); messageSource.setParentMessageSource(parent); messageSource.setUseCodeAsDefaultMessage(true); return new MessageSourceAccessor(messageSource); ``` It will works fine, but we can not customize spring security messages since it always search `org.springframework.security.messages`  first, I think `AbstractMessageSource` should introduce a method to indicate searching from parent first just like class loader.","closed","status: duplicate,","quaff","2021-09-07T01:26:58Z","2021-09-07T06:04:37Z"
"","27654","RFC: resttemplate builder","I created [a library](https://github.com/tomasbjerre/spring-resttemplate-client) and would like to ask if it can be merged into Spring? I only added the production code in this PR to show what would need to be changed. The test cases are still in [the library](https://github.com/tomasbjerre/spring-resttemplate-client).  Would you like me to continue work on this?  ----- Dynamically create Spring RestTemplate (proxy class) client from annotated interface.  Given `MyApiInterface` is a Spring-annotated Java interface.  ```java final MyApiInterface myClient = SpringRestTemplateClientBuilder   .create(MyApiInterface.class)   .setUrl(this.getMockUrl())   .setRestTemplate(restTemplate)         // Optional   .setHeader(""header-name"", ""the value"") // Optional   .setHeaders(HttpHeaders)               // Optional   .build(); ```  Here `myClient` is a dynamically created [Java Proxy object](https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html).  ```java final ResponseEntity response = myClient.getMyDto(); ```  The method invocation (`getMyDto()`) on that object (`myClient`) will be translated to a HTTP request using the annotations of that method in that interface. And `response` will be the result of that HTTP request.","open","in: web,","tomasbjerre","2021-11-08T17:15:50Z","2022-03-11T09:36:41Z"
"","27354","Update copyright date in tests in spring-test","I changed the copyright year of Servlet Test I'd like to be of some help to the spring-framework!","closed","type: task,","leeseojune53","2021-09-03T02:49:06Z","2021-09-03T08:51:06Z"
"","27420","Unable to build spring-framework","I can't build `spring-framework`. I cloned this repository, and runned `./gradlew`. Here are the errors produced by Gradle:  ```FAILURE: Build failed with an exception.  * What went wrong: A problem occurred configuring root project 'spring'. > Could not resolve all artifacts for configuration ':classpath'.    > Could not resolve me.champeau.jmh:jmh-gradle-plugin:0.6.6.      Required by:          project : > me.champeau.jmh:me.champeau.jmh.gradle.plugin:0.6.6       > Could not resolve me.champeau.jmh:jmh-gradle-plugin:0.6.6.          > Could not get resource 'https://plugins.gradle.org/m2/me/champeau/jmh/jmh-gradle-plugin/0.6.6/jmh-gradle-plugin-0.6.6.module'.             > Could not GET 'https://jcenter.bintray.com/me/champeau/jmh/jmh-gradle-plugin/0.6.6/jmh-gradle-plugin-0.6.6.module'.                > Read timed out    > Could not resolve org.jetbrains.kotlin:kotlin-serialization:1.5.30.      Required by:          project : > org.jetbrains.kotlin.plugin.serialization:org.jetbrains.kotlin.plugin.serialization.gradle.plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-serialization:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-serialization/1.5.30/kotlin-serialization-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-serialization/1.5.30/kotlin-serialization-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.5.0.      Required by:          project : > io.spring.nohttp:io.spring.nohttp.gradle.plugin:0.0.10 > io.spring.nohttp:nohttp-gradle:0.0.10       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.5.0.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-stdlib-jdk8/1.5.0/kotlin-stdlib-jdk8-1.5.0.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-stdlib-jdk8/1.5.0/kotlin-stdlib-jdk8-1.5.0.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-gradle-plugin-api:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-gradle-plugin-api:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-gradle-plugin-api/1.5.30/kotlin-gradle-plugin-api-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-gradle-plugin-api/1.5.30/kotlin-gradle-plugin-api-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-gradle-plugin-model:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-gradle-plugin-model:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-gradle-plugin-model/1.5.30/kotlin-gradle-plugin-model-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-gradle-plugin-model/1.5.30/kotlin-gradle-plugin-model-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-util-klib:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-util-klib:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-util-klib/1.5.30/kotlin-util-klib-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-util-klib/1.5.30/kotlin-util-klib-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-klib-commonizer-api:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-klib-commonizer-api:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-klib-commonizer-api/1.5.30/kotlin-klib-commonizer-api-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-klib-commonizer-api/1.5.30/kotlin-klib-commonizer-api-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-tooling-metadata:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-tooling-metadata:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-tooling-metadata/1.5.30/kotlin-tooling-metadata-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-tooling-metadata/1.5.30/kotlin-tooling-metadata-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-project-model:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-project-model:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-project-model/1.5.30/kotlin-project-model-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-project-model/1.5.30/kotlin-project-model-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-compiler-embeddable:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-compiler-embeddable:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-compiler-embeddable/1.5.30/kotlin-compiler-embeddable-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-compiler-embeddable/1.5.30/kotlin-compiler-embeddable-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-annotation-processing-gradle:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-annotation-processing-gradle:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-annotation-processing-gradle/1.5.30/kotlin-annotation-processing-gradle-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-annotation-processing-gradle/1.5.30/kotlin-annotation-processing-gradle-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-android-extensions:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-android-extensions:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-android-extensions/1.5.30/kotlin-android-extensions-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-android-extensions/1.5.30/kotlin-android-extensions-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-compiler-runner:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-compiler-runner:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-compiler-runner/1.5.30/kotlin-compiler-runner-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-compiler-runner/1.5.30/kotlin-compiler-runner-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-scripting-compiler-embeddable:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-scripting-compiler-embeddable:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-scripting-compiler-embeddable/1.5.30/kotlin-scripting-compiler-embeddable-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-scripting-compiler-embeddable/1.5.30/kotlin-scripting-compiler-embeddable-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-scripting-compiler-impl-embeddable:1.5.30.      Required by:          project : > org.jetbrains.kotlin.jvm:org.jetbrains.kotlin.jvm.gradle.plugin:1.5.30 > org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-scripting-compiler-impl-embeddable:1.5.30.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-scripting-compiler-impl-embeddable/1.5.30/kotlin-scripting-compiler-impl-embeddable-1.5.30.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-scripting-compiler-impl-embeddable/1.5.30/kotlin-scripting-compiler-impl-embeddable-1.5.30.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.dokka:dokka-core:1.5.0.      Required by:          project : > org.jetbrains.dokka:org.jetbrains.dokka.gradle.plugin:1.5.0 > org.jetbrains.dokka:dokka-gradle-plugin:1.5.0       > Skipped due to earlier error       > Could not resolve org.jetbrains.dokka:dokka-core:1.5.0.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/dokka/dokka-core/1.5.0/dokka-core-1.5.0.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/dokka/dokka-core/1.5.0/dokka-core-1.5.0.pom'. Received status code 401 from server:     > Could not resolve org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.5.0.      Required by:          project : > org.jetbrains.dokka:org.jetbrains.dokka.gradle.plugin:1.5.0 > org.jetbrains.dokka:dokka-gradle-plugin:1.5.0       > Skipped due to earlier error       > Could not resolve org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.5.0.          > Could not get resource 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-stdlib-jdk8/1.5.0/kotlin-stdlib-jdk8-1.5.0.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/jetbrains/kotlin/kotlin-stdlib-jdk8/1.5.0/kotlin-stdlib-jdk8-1.5.0.pom'. Received status code 401 from server:     > Could not resolve org.ysb33r.gradle:grolifant:0.16.1.      Required by:          project : > org.asciidoctor.jvm.convert:org.asciidoctor.jvm.convert.gradle.plugin:3.3.2 > org.asciidoctor:asciidoctor-gradle-jvm:3.3.2          project : > org.asciidoctor.jvm.pdf:org.asciidoctor.jvm.pdf.gradle.plugin:3.3.2 > org.asciidoctor:asciidoctor-gradle-jvm-pdf:3.3.2       > Skipped due to earlier error       > Could not resolve org.ysb33r.gradle:grolifant:0.16.1.          > Could not get resource 'https://repo.spring.io/plugins-release/org/ysb33r/gradle/grolifant/0.16.1/grolifant-0.16.1.pom'.             > Could not GET 'https://repo.spring.io/plugins-release/org/ysb33r/gradle/grolifant/0.16.1/grolifant-0.16.1.pom'. Received status code 401 from server:     > Could not resolve org.asciidoctor:asciidoctor-gradle-base:3.3.2.      Required by:          project : > org.asciidoctor.jvm.convert:org.asciidoctor.jvm.convert.gradle.plugin:3.3.2 > org.asciidoctor:asciidoctor-gradle-jvm:3.3.2       > Skipped due to earlier error       > Could not resolve org.asciidoctor:asciidoctor-gradle-base:3.3.2.          > Could not get resource 'https://repo.spring.io/plugins-release/org/asciidoctor/asciidoctor-gradle-base/3.3.2/asciidoctor-gradle-base-3.3.2.pom'.             > Could not GET 'https://repo.spring.io/plugins-release/org/asciidoctor/asciidoctor-gradle-base/3.3.2/asciidoctor-gradle-base-3.3.2.pom'. Received status code 401 from server:     > Could not resolve com.thoughtworks.xstream:xstream:1.4.17.      Required by:          project : > com.github.ben-manes.versions:com.github.ben-manes.versions.gradle.plugin:0.39.0 > com.github.ben-manes:gradle-versions-plugin:0.39.0       > Skipped due to earlier error       > Could not resolve com.thoughtworks.xstream:xstream:1.4.17.          > Could not get resource 'https://repo.spring.io/plugins-release/com/thoughtworks/xstream/xstream/1.4.17/xstream-1.4.17.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/com/thoughtworks/xstream/xstream/1.4.17/xstream-1.4.17.pom'. Received status code 401 from server:     > Could not resolve com.gradle.publish:plugin-publish-plugin:0.14.0.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve com.gradle.publish:plugin-publish-plugin:0.14.0.          > Could not get resource 'https://repo.spring.io/plugins-release/com/gradle/publish/plugin-publish-plugin/0.14.0/plugin-publish-plugin-0.14.0.pom'.             > Could not GET 'https://repo.spring.io/plugins-release/com/gradle/publish/plugin-publish-plugin/0.14.0/plugin-publish-plugin-0.14.0.pom'. Received status code 401 from server:     > Could not resolve org.ow2.asm:asm:9.1.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve org.ow2.asm:asm:9.1.          > Could not get resource 'https://repo.spring.io/plugins-release/org/ow2/asm/asm/9.1/asm-9.1.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/ow2/asm/asm/9.1/asm-9.1.pom'. Received status code 401 from server:     > Could not resolve org.ow2.asm:asm-commons:9.1.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve org.ow2.asm:asm-commons:9.1.          > Could not get resource 'https://repo.spring.io/plugins-release/org/ow2/asm/asm-commons/9.1/asm-commons-9.1.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/ow2/asm/asm-commons/9.1/asm-commons-9.1.pom'. Received status code 401 from server:     > Could not resolve commons-io:commons-io:2.8.0.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve commons-io:commons-io:2.8.0.          > Could not get resource 'https://repo.spring.io/plugins-release/commons-io/commons-io/2.8.0/commons-io-2.8.0.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/commons-io/commons-io/2.8.0/commons-io-2.8.0.pom'. Received status code 401 from server:     > Could not resolve org.apache.ant:ant:1.10.9.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve org.apache.ant:ant:1.10.9.          > Could not get resource 'https://repo.spring.io/plugins-release/org/apache/ant/ant/1.10.9/ant-1.10.9.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/apache/ant/ant/1.10.9/ant-1.10.9.pom'. Received status code 401 from server:     > Could not resolve org.codehaus.plexus:plexus-utils:3.3.0.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve org.codehaus.plexus:plexus-utils:3.3.0.          > Could not get resource 'https://repo.spring.io/plugins-release/org/codehaus/plexus/plexus-utils/3.3.0/plexus-utils-3.3.0.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/codehaus/plexus/plexus-utils/3.3.0/plexus-utils-3.3.0.pom'. Received status code 401 from server:     > Could not resolve org.apache.logging.log4j:log4j-core:2.14.1.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve org.apache.logging.log4j:log4j-core:2.14.1.          > Could not get resource 'https://repo.spring.io/plugins-release/org/apache/logging/log4j/log4j-core/2.14.1/log4j-core-2.14.1.pom'.             > Could not GET 'https://repo.spring.io/plugins-release/org/apache/logging/log4j/log4j-core/2.14.1/log4j-core-2.14.1.pom'. Received status code 401 from server:     > Could not resolve org.vafer:jdependency:2.6.0.      Required by:          project : > com.github.johnrengelman.shadow:com.github.johnrengelman.shadow.gradle.plugin:7.0.0 > gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0       > Skipped due to earlier error       > Could not resolve org.vafer:jdependency:2.6.0.          > Could not get resource 'https://repo.spring.io/plugins-release/org/vafer/jdependency/2.6.0/jdependency-2.6.0.pom'.             > Could not HEAD 'https://repo.spring.io/plugins-release/org/vafer/jdependency/2.6.0/jdependency-2.6.0.pom'. Received status code 401 from server:   * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  BUILD FAILED in 1m 36s 6 actionable tasks: 6 up-to-date ```  I guess it is related to https://spring.io/blog/2020/10/29/notice-of-permissions-changes-to-repo-spring-io-fall-and-winter-2020, but I don't understand how I am supposed to fix it.","closed","status: invalid,","reda-alaoui","2021-09-16T13:09:31Z","2021-09-16T13:17:45Z"
"","27255","Link Multiplexing Problem After Reconnection","I am using; * RabbitMQ Websocket with Spring Integration for backend; (spring-boot-starter-parent : 2.3.0.RELEASE, spring-cloud-dependencies : Hoxton.SR5) * **""react-stomp 5.1.0""** at frontend  I am trying to make it work. I installed RabbitMQ cluster with 3 instances.   My issue is : If I close one of the instance in the cluster, my websocket connections get multiplexed.   What's the point I am missing if exists? Can anyone help me?","closed","for: stackoverflow,","omercelikceng","2021-08-10T06:08:22Z","2021-08-10T06:47:53Z"
"","27237","Multipart(one part is JSON and other part is binary) data is getting truncated while reading it by using Flux","I am using Webflux and Netty in my spring boot application.  I am sending the multipart data as a request to my controller class.  Flux is the request body from ServerHttpRequest in my controller class. We are trying to get the data as byte[] format from Flux and then constructing the data as string format. The issue we are facing is the data is truncated.   Please find the code snippet  public class ReactiveController {  @RequestMapping(value = ""/test4"", method = RequestMethod.PUT) 	@RequestScope 	public CompletableFuture> finalRspCompFuture = new CompletableFuture(); 		ResponseEntity rspEntity = new ResponseEntity(HttpStatus.OK); 		finalRspCompFuture.complete(rspEntity); 		return finalRspCompFuture; 	}  	public String fluxToString(Flux fluxRequestBody) { 		StringBuilder sb = new StringBuilder(); 		fluxRequestBody.subscribe(buffer -> { 			byte[] bytes = new byte[buffer.readableByteCount()]; 			buffer.read(bytes); 			DataBufferUtils.release(buffer); 			String bodyString = new String(bytes, StandardCharsets.UTF_8); 			sb.append(bodyString); 		}); 		return sb.toString(); 	} } ### Expected behavior  Content-Disposition: form-data; name=""metadata""; filename=""new.txt"" Content-Type: application/json  test1 --------------------------1a1017604f70f540 Content-Disposition: form-data; name=""content""; filename=""out_bind_data"" Content-Type: application/vnd.3gpp.5gnas .Á¡{'!  ### Actual behavior  Content-Disposition: form-data; name=""metadata""; filena (truncated)...  ### Steps to reproduce  1. Rename the out_bind_data.txt file to out_bind_data and use that file.  2. Please send the request using curl command which is given below  curl -X PUT -v http://localhost:8080/test4 -H ""content-type: multipart/mixed"" -F ""metadata=@new.txt; type=application/json"" -F ""content=@out_bind_data; type=application/vnd.3gpp.5gnas""  ### Environment SpringBootVersion: 2.4.3 java : 16 [new.txt](https://github.com/netty/netty/files/6914651/new.txt) [out_bind_data.txt](https://github.com/netty/netty/files/6914669/out_bind_data.txt)","closed","status: duplicate,","techdeba901","2021-08-03T05:04:32Z","2021-08-03T05:34:40Z"
"","27433","If an @EntityListener class is annotated with @Component then it is instantiated twice","I am trying to take benefit of this: https://github.com/spring-projects/spring-framework/issues/20852,   so I annotate my entity with `@EntityListener(MyListener.class)`  and then use the listener as:  ``` public MyListener {     @Autowired     AnotherDependency anotherDependency;     @PostLoad     public void onRead(Entity entity) {             //     } } ``` with that, it seems we finally can get rid of the nasty static hack and get the bean spring-processed.  But as fine as this works for listener own dependencies, it did not work for me for autowiring the listener itself.   Looks like EntityManagerFactory/Hibernate manages it  as if it were a Spring bean, but it does not exposes it in the context for another bean to inject it.  I checked documentation and I saw someone claimed the listener had to be annotated with `@Component` (although it worked in my case without it in regards to its internal autowires), and after I did this, the bean was managed by Spring and I could inject it, but then, I realized it was instantiated twice:  - LocalEntityManagerFactory reads the @EntityListener annotation and instantiates it and sets up dependencies (and this instance is the only one that handles the events)  - And then Spring seems to parse the @Component and do the operation again (and this instance is the only one that gets injected when you @Autowire the listener in some other bean)  Is this an expected behavior? Do I have a bug in my code? Is it an issue on Hibernate's side perhaps?","open","in: core,","nightswimmings","2021-09-17T20:57:07Z","2021-11-10T11:58:10Z"
"","27761","Spring AOP randomly fails when advising JpaRepository","I am trying to intercept `JpaRepository` methods in my app, but for whatever reason, if I restart my Spring Boot app several times, then one of the aspects doesn't always work.  The advice `onBusinessRelationshipSaveAll` sporadically fails, while `onBusinessRelationshipDeleteAll` seems to be always working.  I've pushed a simplified version of my app here [https://github.com/gkgeorgiev/aop-demo]( https://github.com/gkgeorgiev/aop-demo ).  Be aware that you might have to restart the app 3-4 times since the behavior is unpredictable.  I've also debugged and tried to understand the proxy creation, and I noticed that sometimes in the list of advisors, the pointcut advisor with expression `execution(* com.example.demo.BusinessRelationshipRepository.save*(..))` is missing for whatever reason.  I initially created [Stackoverflow question](https://stackoverflow.com/questions/70189980/spring-data-jparepository-save-advice-doesnt-work) but the more I debugged the more I think there's a problem with the Spring aspects mechanism.  P.S. If you are using IntelliJ .... I've created `requests.http` inside the test folder, to test/reproduce the problem.  ``` C:\dev\git\aop-demo>java -version openjdk version ""11.0.12"" 2021-07-20 OpenJDK Runtime Environment Temurin-11.0.12+7 (build 11.0.12+7) OpenJDK 64-Bit Server VM Temurin-11.0.12+7 (build 11.0.12+7, mixed mode) ```","open","in: core,","gkgeorgiev","2021-12-03T18:24:35Z","2022-03-15T14:58:08Z"
"","27108","Fix cross reference in ref docs for `@Bean` method autowiring","I am still studying spring technology, so perhaps I don't understand this concept. However I think the resolution mechanism is more comparable with constructor mode autowiring than with constructor based dependency injection (argument matching)?","closed","status: declined,","arnovh","2021-06-30T05:38:49Z","2021-06-30T09:07:27Z"
"","27187","Improve ControlFlowPointcut extensibility","I am starting with an issue instead or a PR, because I want to find out if the maintainers are open to this suggestion and discuss how it best be done.  `ControlFlowPointcut` does not support method name patterns like   * `test*` (AspectJ-like syntax) or   * `test.*`, `test[1-3]` (regex syntax).  While the class is extensible and sports two methods to be overridden for improved filtering and it would be possible to override `public boolean matches(Method, Class)` or `public boolean matches(Method, Class, Object...)` in order to add the extra functionality, subclasses do not have access to fields like `private Class clazz`, `private String methodName` and `private volatile int evaluations`. I.e., instead of extending existing functionality users would end up duplicating some things or even copying and extending the whole class like I did when [answering StackOverflow #68431056](https://stackoverflow.com/a/68434674/1082681) - please read and feel free to copy the source code.  I see several options here:   * Extend `ControlFlowPointcut` directly in order to allow for more flexible method name matching, similar to how I did it. Sub-options:     * Add a new `Pattern` field and corresponding constructor, like I did, in order to retain exact `String` matching mode for best performance.     * Always interpret the existing `String` parameter as a regex.   * Improve `ControlFlowPointcut` extensibility by making the fields mentioned above `protected` instead of `private`.  After we have come to a common understanding how this should best be done, the implementation as such should be pretty trivial. I can then create a PR, but the maintainers could also quickly do it by themselves, depending on their preference.","open","in: core,","kriegaex","2021-07-19T03:22:35Z","2021-11-10T09:51:51Z"
"","26906","Spring Webflux Webclient timesout intermittently","I am getting intermittent ReadTimeOut from netty with the below error:    The connection observed an error"",""logger_name"":""reactor.netty.http.client.HttpClientConnect"",""thread_name"":""reactor-http-epoll-3"",""level"":""WARN"",""level_value"":30000,""stack_trace"":""io.netty.handler.timeout.ReadTimeoutException: null  One observation we made is this particular endpoint for which we are getting this issue is a POST with no request body. I am now sending a dummy json in body now which the downstream system ignores and now I don't see this error anymore at all.  Below is my code: ```java protected  Mono sendMonoRequest(HttpMethod method,                                              HttpHeaders headers,                                              T requestBody,                                              URI uri, Class responseClass) throws ApiException, IOException {          log.info(""Calling {} {} {} {}"",                  method.toString(), uri.toString(), headers.toString(), mapper.writeValueAsString(requestBody));          WebClient.RequestBodySpec requestBodySpec = getWebClient().method(method).uri(uri);                  headers.keySet().stream().forEach(headerKey ->                  headers.get(headerKey).stream().forEach(headerValue -> requestBodySpec.header(headerKey, headerValue)));                  return requestBodySpec                 .body(BodyInserters.fromObject(requestBody != null ? requestBody : """"))                 .retrieve()                 .onStatus(HttpStatus::is4xxClientError, this::doOn4xxError)                 .onStatus(HttpStatus::is5xxServerError, this::doOn5xxError)                 .onStatus(HttpStatus::isError, this::doOnError)                 .bodyToMono(responseClass);     }      protected WebClient getWebClient() {          HttpClient httpClient = HttpClient.create().tcpConfiguration(                 client -> client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 20000)                         .doOnConnected(conn -> conn                         .addHandlerLast(new ReadTimeoutHandler(20))                         .addHandlerLast(new WriteTimeoutHandler(20))));          ClientHttpConnector connector = new ReactorClientHttpConnector(httpClient);          return WebClient.builder().clientConnector(connector)                 .filter(logResponse())                 .build();     } }  ```     To resolve the intemrittent timeouts, I have to send a dummy pojo to sendMonoRequest() for request body. Any ideas ?","closed","in: web,","tamanna2702","2021-05-07T10:32:47Z","2021-05-21T13:27:00Z"
"","27781","spring boot redeploy in tomcat causing a permgen memory leak","I am currently trying to resolve an issue we're seeing with redeploying a spring boot application that looks to be a problem in the spring boot end not ours?  Links: - Stack overflow question: https://stackoverflow.com/questions/70174850/spring-boot-tomcat-redeploy-permgen-leak-due-to-logging  - Git repo: https://github.com/webbres/spring-boot-permgen-issue/tree/master/debugging  Config: Java 11 OS: Windows & Centos Spring boot: 2.5 Tomcat: 9.0.27  ----  The problem/bug:  When deploying on tomcat 9 using java 11 reloading an application results in a PermGen memory leak with the classloader for the application not being GCd. After adding additional configuration only weak and soft references are found in the heap.   Summary of findings:  Reloading a spring boot application deployed as a war in tomcat 9 results in a PermGen memory leak (reported by the find leaks check and checked in VisualVM). In our actual application there is a strong reference to a log4j JMX bean which is removed when running tomcat with `-Dlog4j2.disable.jmx=true` though even then the `org.apache.catalina.loader.ParallelWebappClassLoader` for the application is marked as DESTROYED but is not garbage collected.   I attempted to recreate the issue on a simple spring boot starter (see repo linked). Here I found strong references to logging shutdown hooks which are removed when adding `logging.register-shutdown-hook=false` to the application.properties. Though after adding this property like above the classloader still isn't being garbage collected.   Cheers  Sam","open","in: core,","webbres","2021-12-07T15:05:28Z","2022-01-07T13:49:48Z"
"","27123","Spring build failed","I am building Spring from source https://github.com/spring-projects/spring-framework/wiki/Build-from-Source  Build failed with following errors ``` > Task :spring-webflux:test  WebClientIntegrationTests > [1] webClient [org.springframework.http.client.reactive.ReactorClientHttpConnector@5a2cb330] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > [2] webClient [org.springframework.http.client.reactive.JettyClientHttpConnector@61cf40b] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > [3] webClient [org.springframework.http.client.reactive.HttpComponentsClientHttpConnector@2aadb429] FAILED     java.lang.AssertionError at MessageFormatter.java:115  1982 tests completed, 3 failed, 13 skipped  > Task :spring-webflux:test FAILED  FAILURE: Build failed with an exception. ``` Can you help?","closed","","MykolaBova","2021-07-03T12:02:41Z","2021-08-13T18:08:55Z"
"","27164","CorsWebFilter Type Mismatch on Source","I am attempting to use CorsWebFilter in a spring-boot application using Kotlin and webflux. Here is the code:   ``` import org.springframework.web.cors.reactive.CorsWebFilter; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.cors.CorsConfiguration;  @Configuration public class CorsConfiguration {    @Bean     fun corsWebFilter(): CorsWebFilter {         val corsConfig = CorsConfiguration()         corsConfig.addAllowedOrigin(""http://localhost:3000"")         corsConfig.addAllowedMethod(""GET"")         corsConfig.addAllowedMethod(""PUT"")         corsConfig.addAllowedMethod(""POST"")         corsConfig.addAllowedMethod(""OPTION"")         corsConfig.addAllowedMethod(""DELETE"")         corsConfig.addAllowedHeader(""x-requested-with"")         corsConfig.addAllowedHeader(""authorization"")         corsConfig.addAllowedHeader(""Content-Type"")         corsConfig.addAllowedHeader(""credential"")         corsConfig.addAllowedHeader(""X-XSRF-TOKEN"")          val source = UrlBasedCorsConfigurationSource().apply {             registerCorsConfiguration(""/**"", corsConfig)         }         return CorsWebFilter(source) //type mismatch here     } }    ```  The issue is that I have the following error -   `Type mismatch: inferred type is UrlBasedCorsConfigurationSource but CorsConfigurationSource was expected`  However, according to the documentation (https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/cors/UrlBasedCorsConfigurationSource.html)   ``` All Implemented Interfaces: CorsConfigurationSource ```  Reading the source code, it would appear that `UrlBasedCorsConfigurationSource` should be accepted (https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/cors/reactive/CorsWebFilter.java#L54)  The spring documentation found here (https://docs.spring.io/spring-framework/docs/5.0.2.RELEASE/spring-framework-reference/web-reactive.html) also has `UrlBasedCorsConfigurationSource` being passed to `CorsWebFilter` (please see `1.7.4 Cors Web Filter`)   Am I wrong in assuming that since `UrlBasedCorsConfigurationSource` implements `CorsConfigurationSource` that `CorsWebFilter` should accept it? If so, what is the proper way of using the WebFilter?","closed","status: waiting-for-feedback,","patientplatypus6","2021-07-13T16:45:39Z","2021-11-23T07:26:46Z"
"","27744","Upgrade to JUnit 5.8.2","https://junit.org/junit5/docs/5.8.2/release-notes/","closed","type: dependency-upgrade,","sbrannen","2021-11-28T16:45:45Z","2021-11-30T11:31:01Z"
"","27450","Upgrade to JUnit 5.8.1","https://junit.org/junit5/docs/5.8.1/release-notes/","closed","type: dependency-upgrade,","sbrannen","2021-09-22T20:05:42Z","2021-09-22T20:29:15Z"
"","27392","Upgrade to JUnit 5.8","https://junit.org/junit5/docs/5.8.0/release-notes/","closed","type: dependency-upgrade,","sbrannen","2021-09-12T19:59:47Z","2021-09-13T14:39:16Z"
"","26946","Upgrade to JUnit 5.7.2","https://junit.org/junit5/docs/5.7.2/release-notes/","closed","type: dependency-upgrade,","sbrannen","2021-05-16T12:45:12Z","2021-05-16T13:26:24Z"
"","27209","WebSocketMessageBrokerStats.getExecutorStatsInfo() throws exception if Executor is not a ThreadPoolExecutor","https://github.com/spring-projects/spring-framework/blob/d034a1f26d0ea3782f53b8ff7a2a0cea7c825b71/spring-websocket/src/main/java/org/springframework/web/socket/config/WebSocketMessageBrokerStats.java#L209  Hardcoded ""pool"" doesn't work, the class name ThreadPoolExecutor contains capital ""P"" instead of ""p"".","closed","type: bug,","leandrodalbo","2021-07-24T06:12:32Z","2021-07-26T09:48:50Z"
"","27142","Code returns hard instance of HttpURLConnection rather than URLConnection","https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-web/src/main/java/org/springframework/http/client/SimpleClientHttpRequestFactory.java#L187  As documented here : https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistrations.html the code should be able to handle classpath:, file: and http: but since it just uses a RestTemplate.getForObject, which delegates to SimpleClientHttpRequestFactory, there is nothing that will work except a http request. Im not sure where to place this issue, but the offending code error is here and the URLConnection is there for the taking. The actual instance returned for file is ""sun.net.www.protocol.file.FileURLConnection"" which extends URLConnection (https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/net/www/protocol/file/FileURLConnection.java)","open","status: feedback-provided,","richardcs","2021-07-07T17:08:36Z","2021-11-08T11:57:07Z"
"","26957","Incorrect calculation with CronExpression 0 0 0 1 * *","https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-context/src/main/java/org/springframework/scheduling/support/CronExpression.java#L226  If `CronExpression` is `0 0 0 1 * *` and `temporal` is `2021-06-01T00:00`, then the result will be `2021-07-01`, although `2021-06-01` also fits this expression. But in other cases, if in the expression `0 0 0 1 * *` 1 replace with another value from 2 to 31, then the expected result is obtained","closed","in: core,","nozikov","2021-05-19T14:31:51Z","2021-06-09T15:06:31Z"
"","27734","Enforce Future or void return declaration for each asynchronously executed method (e.g. with class-level @Async)","https://github.com/spring-projects/spring-framework/blob/79d3f5c64c94a356831916ec78be4296fba92b18/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java#L113-L127  I have found an odd behaviour working with `@Async`-annotated classes in Spring. Please note that **there is** a fundamental error in my code. Unfortunately, this post has to be long and detailed.  Let's say I have already made a synchronous REST API generated by Swagger generator. Following code omits all documentation-level annotations  ```java  public interface TaxonomiesApi {         ResponseEntity disableItem(Integer idTaxonomyType, String idTaxonomy, String appSource);  } ```  This API is easily implemented via `RestTemplate`, but I won't discuss the inner details.  Now, suppose I want to provide an async version to developers consuming the API. What I have done is to create another interface with some search&replace-fu 🥋🥋  ```java @Async public interface TaxonomiesApiAsync extends TaxonomyApi {         default CompletableFuture disableItemAsync(Integer idTaxonomyType, String idTaxonomy, String appSource) {         try {             return completedFuture(this.disableItem(idTaxonomyType, idTaxonomy, appSource));         } catch (Exception ex) {             return failedFuture(ex);         }     } } ```  With the search&replace, I basically created an async-ish version of every method that should be backed by Spring's `@Async` annotation. My original idea was that synchronous methods can be invoked as they are, but if you instantiate `TaxonomiesApiAsync` you also have access to the async version.  I have discovered I made **a fundamental mistake** by applying the `@Async` annotation at interface level when the class contains both sync and async methods. I found that synchronous `disableItem` was performed in the same `@Async` context. Accoding to design (correctly), Spring found the `@Async` annotation at interface level so **every method**, including inherited ones, was invoked asynchronously.  But the method always returned null. By debugging and looking at the code, I found that Spring tries to resolve the return value of the invoked method **only** if it's a `Future`. What if the returned value is a _Present_ object?  That means that if the returned value is not a `Future` but rather just a `ResponseEntity` Spring neither throws an exception nor returns that value directly.  Example of working calling code (invoking a different method)  ```java     protected CompletableFuture importTaxonomyLegalEntities(int userId) {         TaxonomySearchParameters searchParameters = new TaxonomySearchParameters();         searchParameters.setIdTaxonomyType(amlcProperties.getTaxonomies().getTaxonomyLegalEntitiesId());         searchParameters.setLogicalState(1);         return taxonomiesApiAsync.getAllTaxonomyItemsAsync(searchParameters)                 .thenApply(ResponseEntity::getBody)                 .thenApply(taxonomyLegalEntityMasterDbMapping::toLegalEntity) // Costruisco i DTO che voglio utilizzare                 .whenComplete(traceLoggerConsumer(""Legal entity""))                 .thenApply(dtos -> taxonomyLegalEntityManager.mergeFromMasterDb(dtos, userId))                 .whenComplete((ignored, ex) -> {                     if (ex != null)                         log.error(""Error importing legal entities: "" + ex.getMessage(), ex);                 })                 .thenApply(TaxonomyMasterDbMergeDTO::getSnapshot);     } ```  Example of non-working code; the result of the CompletableFuture is always null. In this code, I decided not to use the executor _embedded_ in the API service, but rather the executor injected in the consuming service. So I ran a sync method in an executor, expecting the same result.  ```java     protected CompletableFuture importTaxonomyLegalEntities(int userId) {         TaxonomySearchParameters searchParameters = new TaxonomySearchParameters();         searchParameters.setIdTaxonomyType(amlcProperties.getTaxonomies().getTaxonomyLegalEntitiesId());         searchParameters.setLogicalState(1);         return CompletableFuture.supplyAsync(() -> taxonomiesApi.getAllTaxonomyItems(searchParameters), taxonomyBatchImportServiceExecutor)                 .thenApply(ResponseEntity::getBody)                 .thenApply(taxonomyLegalEntityMasterDbMapping::toLegalEntity)                 .whenComplete(traceLoggerConsumer(""Legal entity""))                 .thenApplyAsync(dtos -> taxonomyLegalEntityManager.mergeFromMasterDb(dtos, userId))                 .whenComplete((ignored, ex) -> {                     if (ex != null)                         log.error(""Error importing legal entities: "" + ex.getMessage(), ex);                 })                 .thenApply(TaxonomyMasterDbMergeDTO::getSnapshot);     } ```   Since I spent one hour debugging that problem, I decided to spend more of my after-work time to document the issue here.  **Proposed fix**  In the code I linked, if the `instanceof` check fails the returned value is simply null. I don't yet understand the implications, but what about not unwrapping the value from Future if that's not a future? I mean `return result`","closed","type: enhancement,","djechelon","2021-11-25T20:00:52Z","2022-01-04T11:41:30Z"
"","27856","Conditional judgment can be optimized","https://github.com/spring-projects/spring-framework/blob/544e9bb4036965cc4054fba72f2a5690539e44bf/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassUtils.java#L126-L128  Can be optimized  The following code，Optimal condition judgment，Increase readability `if (config != null && Boolean.TRUE.equals(config.get(""proxyBeanMethods""))) { 			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); }`","closed","status: superseded,","1725636955","2021-12-25T06:36:55Z","2021-12-25T08:42:55Z"
"","26994","Documented examples of SessionScope look wrong","https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/core.html#beans-java-scoped-proxy has 2 examples of use of @SessionScope: kotlin and java.   The kotlin version is missing a `)`  Even the java version looks incorrect:  ``` // an HTTP Session-scoped bean exposed as a proxy @Bean @SessionScope public UserPreferences userPreferences() {     return new UserPreferences(); }  @Bean public Service userService() {     UserService service = new SimpleUserService();     // a reference to the proxied userPreferences bean     service.setUserPreferences(userPreferences());     return service; } ``` Why is the implementation of userService invoking the userPreferences method directly? Shouldn't it be like this?:  ``` // an HTTP Session-scoped bean exposed as a proxy @Bean @SessionScope public UserPreferences userPreferences() {     return new UserPreferences(); }  @Bean public Service userService(UserPreferences injectedUserPreferences) {     UserService service = new SimpleUserService();     // a reference to the proxied userPreferences bean     service.setUserPreferences(injectedUserPreferences);     return service; } ```","closed","status: superseded,","jbotuck","2021-05-27T22:40:33Z","2021-06-02T11:55:33Z"
"","27147","Compatibility with HtmlUnit 2.51","HtmlUnit 2.51 interacts differently with its `getWebClient()` method that we're overriding in `WebConnectionHtmlUnitDriver`. Consistently using the base class result and not storing a local `WebClient` instance at all anymore makes our HtmlUnit integration compatible with HtmlUnit 2.51 as well as earlier versions.","closed","type: dependency-upgrade,","jhoeller","2021-07-08T14:56:15Z","2021-07-09T11:27:54Z"
"","26972","How to generate bytecode file of proxy class","How to generate a proxy class to a folder in spring","closed","for: stackoverflow,","huifer","2021-05-25T07:40:49Z","2021-05-25T10:48:48Z"
"","27272","The table of contents for Spring Framework  is missing","Hi~ I found that the The Spring Framework's table of contents  is missing. And that makes it inconvenient to find the specified chapter. And I remember it wasn't like this before. Is that any wrong with this doc page?  https://docs.spring.io/spring-framework/docs/current/reference/html/core.html ![image](https://user-images.githubusercontent.com/19700715/129299505-432d8083-6f50-4bd0-9062-1c54dfa06cc6.png)","closed","status: duplicate,","beWalter","2021-08-13T03:14:09Z","2021-08-13T07:53:10Z"
"","26971","Spring CLI cannot find main class after installing","Hi. I'm new to learn spring. And I learn it with the document on spring.io, which is [the url](https://docs.spring.io/spring-boot/docs/2.5.1-SNAPSHOT/reference/html/getting-started.html#getting-started). I read part `3.2.1. Manual Installation ` and met a problem. I have JDK 1.8, and apache-maven 3.8.1 on Windows 10 Home, 20H2. I download the spring framework spring-2.5.0 and spring-2.5.1-SNAPSHOT. I try both of them. I met some problems with the environment system variables set. I follow the guide but with problems `C:\Users\ASUS>spring Error: Could not find or load main class org.spring framework.boot.loader.JarLauncher`. I try to search for information about this problem but little satisfying result. My problem is similar to the question on StackOverflow [Spring CLI cannot find main class after installing](https://stackoverflow.com/questions/59905353/spring-cli-cannot-find-main-class-after-installing/67680336#67680336) I edit `Path` with `%SPRING_HOME%\bin` on `System Variables`. ![image](https://user-images.githubusercontent.com/62530115/119424837-d0925000-bd38-11eb-85b2-019d9669cd38.png) I also set the Variable `SPRING_HOME` and the Value the path of bin `D:\Downloads\spring-2.5.0\bin`. ![image](https://user-images.githubusercontent.com/62530115/119425000-28c95200-bd39-11eb-8aa2-cd6e33e2438b.png) Thank you!","closed","for: stackoverflow,","RshStone","2021-05-25T01:12:48Z","2021-05-25T07:41:12Z"
"","27117","CronExpression is *still* broken on spring-context-5.3.8","Hi, over a month ago, I opened #26964, and it was pretty promptly resolved... for that one specific cron expression. I pulled in that bugfix (along with the rest of 5.3.8), and more or less immediately found **another** cron line that is still broken in the exact same way: As you move forward in time, the next match of a cron expression moves _backwards_, which it should never ever do.  Instead of just attaching another bug proof with the particular bad cron expression, here is an entire bug proof generator that will give you an infinite number of similarly broken cron lines, with test dates, until this issue is actually fixed.  ```java package com.example;  import org.junit.jupiter.api.Test; import org.springframework.scheduling.support.CronExpression;  import java.time.LocalDateTime; import java.time.ZoneOffset; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.function.BiFunction;   /**  * @author Scott Albertine  */ public class CronExpressionBugProof {  	private static final Random R = new Random(); 	private static final int TWO_YEARS_IN_SECONDS = 63113852; 	private static final LocalDateTime EPOCH = LocalDateTime.ofEpochSecond(0, 0, ZoneOffset.UTC); 	private static final List CRON_SEGMENT_GENERATORS = new ArrayList();  	static { 		CRON_SEGMENT_GENERATORS.add(CronExpressionBugProof::numberSegment); 		CRON_SEGMENT_GENERATORS.add(CronExpressionBugProof::star); 		CRON_SEGMENT_GENERATORS.add(CronExpressionBugProof::starOverNumber); 		CRON_SEGMENT_GENERATORS.add(CronExpressionBugProof::numberDashNumber); 		CRON_SEGMENT_GENERATORS.add(CronExpressionBugProof::numberCommaNumber); 		CRON_SEGMENT_GENERATORS.add(CronExpressionBugProof::numberHashNumber); 	}  	private static CronExpression randomCronExpression() { 		while (true) { //there are bad cron expressions, skip past them 			String cronLine = randomCronLine(); 			try { 				//this will throw IllegalArgumentException on some bad cron lines, but not all of them 				CronExpression cronExpression = CronExpression.parse(cronLine); 				//this will check that the cron line has at least one instance since the epoch 				//to filter out stuff like ""every february 30th"" 				if (cronExpression.next(EPOCH) == null) { 					continue; 				} 				return cronExpression; 			} catch (IllegalArgumentException ignored) { 			} 		} 	}  	private static String randomCronLine() { 		return randomCronSegment(0, 59) + ' ' + //seconds 			   randomCronSegment(0, 59) + ' ' + //minutes 			   randomCronSegment(0, 23) + ' ' + //hours 			   randomCronSegment(1, 28) + ' ' + //days 			   randomCronSegment(1, 12) + ' ' + //months 			   randomWeekdaySegment(); //day of week 	}  	private static String randomCronSegment(int min, int max) { 		return CRON_SEGMENT_GENERATORS.get(R.nextInt(5)).apply(min, max); //don't use numberHashNumber 	}  	private static String randomWeekdaySegment() { 		return CRON_SEGMENT_GENERATORS.get(R.nextInt(6)).apply(0, 6); //include numberHashNumber 	}  	private static String numberSegment(Integer min, Integer max) { 		return Integer.toString(R.nextInt((max - min) + 1) + min); 	}  	private static String star(Integer min, Integer max) { 		return ""*""; 	}  	private static String starOverNumber(Integer min, Integer max) { 		return ""*/"" + (R.nextInt((max - min) / 2) + 2); 	}  	private static String numberDashNumber(Integer min, Integer max) { 		int num1 = R.nextInt((max - min) + 1) + min; 		int num2 = R.nextInt((max - min) + 1) + min; 		if (num1 == num2) { 			return Integer.toString(num1); 		} 		return (num1 > num2) ? (num2 + ""-"" + num1) 							 : (num1 + ""-"" + num2); 	}  	private static String numberCommaNumber(Integer min, Integer max) { 		int num1 = R.nextInt((max - min) + 1) + min; 		int num2 = R.nextInt((max - min) + 1) + min; 		if (num1 == num2) { 			return Integer.toString(num1); 		} 		return (num1 > num2) ? (num2 + "","" + num1) 							 : (num1 + "","" + num2); 	}  	private static String numberHashNumber(Integer min, Integer max) { 		int num1 = R.nextInt((max - min) + 1) + min; 		int num2 = R.nextInt(4) + 1; 		return num1 + ""#"" + num2; 	}  	@Test 	public void proveCronExpressionIsStillBroken() { 		//pick 1000 random times in the next 2 years 		LocalDateTime now = LocalDateTime.now(ZoneOffset.UTC); 		int timesToTest = 1000; 		List times = new ArrayList(); 		for (int i = 0; i < timesToTest; i++) { 			times.add(now.plusSeconds(R.nextInt(TWO_YEARS_IN_SECONDS))); 		} 		//make sure they're sorted, so we can know that the firstResult and secondResult below should be in chronological order too 		times.sort(null);  		//test up to 1000 cron lines 		for (int c = 0; c < 1000; c++) { 			CronExpression cronExpression = randomCronExpression(); //pick a random cron expression 			//iterate through each pair of times to test 			for (int t = 0; t < (timesToTest - 1); t++) { 				LocalDateTime firstTime = times.get(t); 				LocalDateTime secondTime = times.get(t + 1); 				LocalDateTime firstResult = cronExpression.next(firstTime); 				LocalDateTime secondResult = cronExpression.next(secondTime); 				if (firstResult.isAfter(secondResult)) { //check for pairs of results that aren't in the right order 					System.out.println(""Insane CronExpression: "" + cronExpression); 					System.out.println(""It thinks the next match of "" + firstTime + "" is "" + firstResult); 					System.out.println(""And the next match of       "" + secondTime + "" is "" + secondResult); 					System.out.println(""Even though "" + firstResult + "" is after "" + secondResult); 					System.out.println(""Cron lines tested: "" + c); 					throw new RuntimeException(""Insane CronExpression found.""); 				} 			} 		} 	}  } ```  This is by no means an exhaustive test. However, when I run it, I get output like the following:  ``` Insane CronExpression: 4,21 12,58 * */6 3 * It thinks the next match of 2022-02-28T13:32:03.032096 is 2022-03-07T00:12:04 And the next match of       2022-03-01T22:44:31.032096 is 2022-03-01T22:58:04 Even though 2022-03-07T00:12:04 is after 2022-03-01T22:58:04 Cron lines tested: 27 ```  I've never made it to 50 cron lines without finding one that's broken, and I've run this dozens of times.","closed","in: core,","ScottAlbertine","2021-07-01T17:53:53Z","2021-07-07T09:17:48Z"
"","27597","reactor.core.Exceptions$ErrorCallbackNotImplemented: java.util.concurrent.CancellationException when invoking an RSocket endpoint on Apple M1 macOS","Hi, if i use Spring Boot 2.5.x I get an exception when I use `rsc` on an Apple M1 (haven't yet tried it on Intel but I will ) to invoke an Rsocket controller endpoint that i didn't use to get given an application   ```java package com.example.demo;  import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.messaging.handler.annotation.MessageMapping; import org.springframework.messaging.rsocket.RSocketRequester; import org.springframework.stereotype.Controller;  @Controller @SpringBootApplication public class DemoApplication {      @MessageMapping(""hello"")     String hello() {         return ""hello, world!"";     }      @Bean     ApplicationRunner runner() {         return args -> {             Thread.sleep(2_000);             var requester = RSocketRequester.builder().tcp(""localhost"", 8181);             var message = requester.route(""hello"").retrieveMono(String.class).block();             System.out.println(""message: "" + message);         };     }      public static void main(String[] args) {         SpringApplication.run(DemoApplication.class, args);     }  }  ```  with a request   `  rsc tcp://localhost:8181 --route hello  `   i get the following exception immediately after. NB: i also get my response, so it clearly goes end to end and works. but the exception is jarring. would be nice if the logging swallowed that exception or something.   ```java 2021-10-22 14:23:14.332 ERROR 12845 --- [ctor-http-nio-3] reactor.core.publisher.Operators         : Operator called default onErrorDropped  reactor.core.Exceptions$ErrorCallbackNotImplemented: java.util.concurrent.CancellationException: Disposed Caused by: java.util.concurrent.CancellationException: Disposed 	at io.rsocket.internal.UnboundedProcessor.dispose(UnboundedProcessor.java:550) ~[rsocket-core-1.1.1.jar:na] 	at io.rsocket.transport.netty.TcpDuplexConnection.doOnClose(TcpDuplexConnection.java:67) ~[rsocket-transport-netty-1.1.1.jar:na] 	at io.rsocket.internal.BaseDuplexConnection.lambda$new$0(BaseDuplexConnection.java:30) ~[rsocket-core-1.1.1.jar:na] 	at reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.runFinally(FluxDoFinally.java:163) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onComplete(FluxDoFinally.java:146) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.SinkEmptyMulticast$VoidInner.complete(SinkEmptyMulticast.java:238) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.SinkEmptyMulticast.tryEmitEmpty(SinkEmptyMulticast.java:70) ~[reactor-core-3.4.11.jar:3.4.11] 	at reactor.core.publisher.SinkEmptySerialized.tryEmitEmpty(SinkEmptySerialized.java:46) ~[reactor-core-3.4.11.jar:3.4.11] 	at io.rsocket.internal.BaseDuplexConnection.dispose(BaseDuplexConnection.java:51) ~[rsocket-core-1.1.1.jar:na] 	at io.rsocket.transport.netty.TcpDuplexConnection.lambda$new$0(TcpDuplexConnection.java:49) ~[rsocket-transport-netty-1.1.1.jar:na] 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.AbstractChannel$CloseFuture.setClosed(AbstractChannel.java:1182) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.AbstractChannel$AbstractUnsafe.doClose0(AbstractChannel.java:773) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:749) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:620) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.closeOnRead(AbstractNioByteChannel.java:105) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:174) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.69.Final.jar:4.1.69.Final] 	at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]   ```","closed","for: external-project,","joshlong","2021-10-22T21:37:54Z","2021-10-29T11:31:09Z"
"","27726","Clarify that interface-level cache annotations work for target-class proxies as well","Hi, I would like to make some modification for cache annotation tip on reference documentation. Even if using cglib proxy mode, annotations on an interface can be recognized. I made a test case to check that case.  Signed-off-by: Kwangyong Kim","closed","in: core,","bananayong","2021-11-24T07:46:42Z","2021-12-14T12:51:20Z"
"","27818","Allow `@Async` qualifier to be declared with a placeholder or SpEL expression","Hi, I submitted this PR to solve #27775 based on @sbrannen ’s [comment](https://github.com/spring-projects/spring-framework/issues/27775#issuecomment-987670815).  Closes gh-27775","closed","type: enhancement,","terminux","2021-12-15T05:34:21Z","2022-02-19T15:07:17Z"
"","27623","Improve the efficiency of UrlPathHelper.getSanitizedPath()","Hi,  Tiny optimization is possible using the new method (time complexity : O(N)) instead of the old one (time complexity : O(N^2)).  Cheers, William","closed","type: enhancement,","happyWilliam0","2021-10-29T09:48:06Z","2021-11-09T10:27:11Z"
"","26952","Introduce ResponseEntity.internalServerError()","Hi,  this PR introduces a new convenience method `ResponseEntity.internalServerError()`.  In our code we have this sort of construct once in a while:  ```java 		try { 			doSomething(); 		} catch (SomethingNotFoundException ex) { 			return ResponseEntity.notFound().build(); 		} catch (Exception ex) { 			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); 		} 		return ResponseEntity.noContent().build(); ```  That obviously works but I'm always looking for the convenience method to handle the 500 status code, which doesn't exist.  Let me know what you think.  Cheers, Christoph","closed","type: enhancement,","dreis2211","2021-05-18T13:23:49Z","2021-05-18T15:00:36Z"
"","27757","Improve documentation for TestContext events","Hi,  The `BeforeTestClassEvent` is not published by the `EventPublishingTestExecutionListener` since `hasApplicationContext()` returns `false`.  See [here](https://github.com/biergit/beforeclassnotcalled) for a reproducer.  The JavaDoc of [BeforeTestClass](https://github.com/spring-projects/spring-framework/blob/7794606305da37e5efbfeded67eb421208492339/spring-test/src/main/java/org/springframework/test/context/event/annotation/BeforeTestClass.java#L49-L51) only mentions that the `EventPublishingTestExecutionListener` must be registered as `TestExecutionListener` which it is by default (so I also suggest reworking the documentation as normally no `@TestExecutionListeners` annotation is needed).","closed","type: documentation,","biergit","2021-12-01T16:59:19Z","2022-03-12T15:07:50Z"
"","27647","CVE-2021-22096 commit(s)","Hi,  I'm part of the Debian LTS (Long Term Support) Team and I'm reviewing the security issues that affect the versions of Spring Framework shipped by Debian, so as to determine if they are vulnerable, and fix them for Debian users.  I could not identify the patches/commits related to CVE-2021-22096 (including through checking the [official vulnerability report](https://tanzu.vmware.com/security/cve-2021-22096) and the Git 5.2/5.3 history), would you mind pointing me to them?  Regards,","closed","status: invalid,","Beuc","2021-11-06T11:18:21Z","2021-11-18T10:18:40Z"
"","27892","Scan for specific classes rather than just packages with classpath scanning","Hi,  I would like to request for `@EntityScan` to be able to provide the ability to scan for specific entities class, rather than based on package. E.g `@EntityScan(classes={""com.aa.ClassA"", ""com.aa.ClassB""))` will only scan for these 2 classes and other classes in the same package will NOT be scan.   Searching internet shows many people asking for such capabilities and end up having to write some codes to circumvent this. Adding such capabilities made life easy for developers  Likewise, should also provide similar way to configure this in properties/yaml as well. E.g  `spring.jpa.entity-scan-classes=com.aa.ClassA,com.aa.ClassB`","open","type: enhancement,","hanct","2022-01-05T15:05:28Z","2022-01-07T12:15:46Z"
"","27386","Refactor some test code to use lambda expressions and method references","Hi,  I refactored some test codes to use lambda expression and method reference for the sake of conciseness.  Due to an issue of java language itself described in #22509, tests that includes `addConverter` was refactored with input/output type informations.  I checked that build done successfully using `./gradlew check`  Thanks.","closed","in: core,","kth496","2021-09-11T05:45:24Z","2022-01-09T15:20:12Z"
"","27027","Exclude sealed interfaces from auto-proxying (for JDK 17 compatibility)","Hi,  I recently opened an issue to track the needed stuff for Spring-Boot in order to support Java 17. https://github.com/spring-projects/spring-boot/issues/26767. I think it makes sense to have the same for Spring Framework.  Known issues:  1. Sealed interfaces need to be handled e.g. when creating proxies.  ```java @Bean @Scope(proxyMode = ScopedProxyMode.INTERFACES) String alpha() { 	return ""alpha""; } ```  Essentially, under the hood it retrieves all interfaces of `String` here which also includes `ConstantDesc` which is a sealed interface and cannot be used when creating a proxy. See `ScopedProxyFactoryBean.setBeanFactory`:  ```java if (!isProxyTargetClass() || beanType.isInterface() || Modifier.isPrivate(beanType.getModifiers())) {         // This should filter sealed interfaces I guess 	pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader())); } ```  After a first look this probably needs to be handled more centrally and more places are potentially affected by sealed interfaces.  There is likely more to do for Java 17 support, but I wanted to kick this off. Feel free to add to this issue or repurpose it to only handle the specific issue.  Let me know if I can help.  Cheers, Christoph","closed","type: enhancement,","dreis2211","2021-06-06T10:05:41Z","2021-11-23T01:18:41Z"
"","27134","How can i send zip file content to body of webclient","Hi,  I need to send the content of zip to post method. Here byte[] is the binary file i uploaded in postman  public String publishZipFile(byte[] data) {      System.out.println(data.length);  	String channelResp =null; 			webClientBuilder 			.build() 			.post() 			.uri(""/appCatalogs/teamsApps"") 			.headers(httpsHeader -> httpsHeader.addAll(headerMap)) 			.syncBody(data) 			.retrieve() 			.bodyToMono(byte[].class) 			.block(); 	 	 	return  channelResp; 	 } Anything wrong am doing here. Pls help me how i can send zip file content to body of webclient","closed","for: stackoverflow,","ShubhaKV","2021-07-06T08:24:34Z","2021-07-06T08:52:04Z"
"","27805","Unable to start nested/inner transaction with default implementation of AbstractRoutingDataSource","Hi,  I am experiencing strange behavior of `AbstractRoutingDataSource` when I am not able to start new transaction to data-source B inside transaction of data-source A.  What I found is that when I implement `InfrastructureProxy` interface inside my implementation of `AbstractRoutingDataSource`, selection of resource keys inside `TransactionSynchronizationManager` is correct and I am able to query correct data sources/connections.  I have created repository https://github.com/bedla/spring-routing-datasource (see ""What is the problem?"" section) to show exact problem (see README.md and code there) and implementation of both use-cases (when I implement `InfrastructureProxy` interface and when I dont).  Is it bug of `AbstractRoutingDataSource` that it does not implement `InfrastructureProxy` interface by default. Or is it not implemented like this by design? Am I abusing `InfrastructureProxy` interface?  If it is bug, I can create PR with test cases etc.  Thx  Ivos","closed","for: stackoverflow,","bedla","2021-12-12T19:40:05Z","2022-01-30T19:17:45Z"
"","27566","[Spring.io] Link for the javadoc points to a ""404"" page","Hi,  At present, the ""Api doc."" link of the page https://spring.io/projects/spring-framework#learn points to a page containing ""Oops! The page can’t be found.""  The link refers to https://docs.spring.io/spring-framework/docs/current/api/, but it seems the right URL is https://docs.spring.io/spring-framework/docs/current/javadoc-api/  Cheers","closed","for: external-project,","ghostd","2021-10-16T10:59:58Z","2021-10-16T11:59:38Z"
"","27554","Use Charset variants of URLEncoder and URLDecoder methods","Hi,  as the JDK baseline was raised, we can make use of the methods in `URLEncoder` and `URLDecoder` that take a `Charset`. This should save a few cycles and is also less code in some cases because we do not need to catch `UnsupportedEncodingException`s.  Cheers, Christoph","closed","type: task,","dreis2211","2021-10-13T12:41:58Z","2021-11-10T15:12:11Z"
"","27721","Custom SpEL evaluation with StandardBeanExpressionResolver conventions","Hi,  A while ago we provided extended opentracing integration with our spring boot applications. Particularly, we allowed developers to mark their methods with annotations allowing them to add custom data (tags) into opentracing spans. Such annotations may contain SpEL expressions, e.g.: ```java @TracingSpanTag(key = ""pizzaSize"", value = ""#{args[0].pizzaSize}"") public void swallowPizza(Pizza pizza) { ``` We implemented an annotation processor and evaluated expressions there. To do that we created custom `Scope` (`TracingScope`) with annotated method argument values inside: ```java class TracingAspectHelper {      private static final BeanExpressionResolver resolver = new StandardBeanExpressionResolver();     ....     public static Object resolveValue(ConfigurableBeanFactory beanFactory, String value, JoinPoint joinPoint) {             TracingScope tracingScope = new TracingScope();             tracingScope.addToMethodExecutionContext(""args"", joinPoint.getArgs());             String embeddedValue = beanFactory.resolveEmbeddedValue(value);             // BeanExpressionContext is cached forever in a Map inside StandardBeanExpressionResolver             return resolver.evaluate(embeddedValue, new BeanExpressionContext(beanFactory, tracingScope));         }     ...     private static class TracingScope implements Scope {          private final Map methodExecutionContext = new HashMap();          public void addToMethodExecutionContext(String key, Object obj) {             methodExecutionContext.put(key, obj);         }          @Override         public Object get(String name, ObjectFactory objectFactory) {             return this.methodExecutionContext.get(name);         }          @Override         public Object remove(String name) {             return null;         }          @Override         public void registerDestructionCallback(String name, Runnable callback) {             throw new UnsupportedOperationException(""This operation is not supported"");         }          @Override         public Object resolveContextualObject(String key) {             return this.methodExecutionContext.get(key);         }          @Override         public String getConversationId() {             return null;         }     } ``` But after a while we found a memory leak - `StandardBeanExpressionResolver` stores the evaluation context forever: https://github.com/spring-projects/spring-framework/blob/259bcd60fbbc5cdb8b230595a5004707f4c6ff23/spring-context/src/main/java/org/springframework/context/expression/StandardBeanExpressionResolver.java#L165  Also, `BeanExpressionContext` includes `ConfigurableBeanFactory` in the `hashCode` but not the `Scope`: https://github.com/spring-projects/spring-framework/blob/259bcd60fbbc5cdb8b230595a5004707f4c6ff23/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanExpressionContext.java#L84 Therefore, collisions happen and the evaluation cache map not only starts eating memory but also becomes very inefficient in lookups.   The dirty solution that will solve our problem would be to create `BeanExpressionResolver` every time on evaluation, but then we will get performance degradation due to the lack of expression caching that `BeanExpressionResolver` provides in addition to evaluation context cache.   Is this behavior expected?","open","type: enhancement,","tfactor2","2021-11-23T22:08:16Z","2021-11-25T12:45:21Z"
"","27524","Entire Cache replacement/refreshment","Hi Spring team!  I have a requirement on my project for cache  to be replaced/refreshed (entire) by some event (Kafka for example) and population of it is at once by RestAPI call. I prefer to work with cache as a concept of cache, because it looks like a cache, it behaves like a cache and it is a cache. BUT I can not do this with current interface of `org.springframework.cache.Cache ` and I had to replace on custom implementation. So I was curious are any reasons why it should not to be added or may be it's a legacy and we stuck here?   Best regards, Andrew","closed","in: core,","CyberpunkPerson","2021-10-06T13:51:03Z","2021-10-07T12:06:15Z"
"","27282","R2DBC - DatabaseClient - Add bind method to accept an object","Hi R2DBC team,  This is a feature request.  Currently with `DatabaseClient` we can execute any arbitrary SQL statement which is cool. Can we add an additional overloaded method for `bind` ?   If I have to pass multiple parameters, instead of passing them one by one using the current `bind` method like `.bind(""firstName"", ""somename"").bind(""lastName"", ""somename"")...`  can we make the method to accept an object as well as show below? Just an additional method to simply this.   ``` class BindInput {      private String firstName;     private String lastName;     private String email;     ...     ... } ```  `.bind(bindInput); // pass a POJO object`","open","in: data,","kitkars","2021-08-15T20:14:59Z","2021-11-10T12:18:54Z"
"","27192","Missing side menu on Spring Core documentation page","Hi guys,  just in case you haven't noticed. But after the last update, roughly a week ago, Spring Core HTML doc page doesn' have a side menu anymore. (URL: https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core)  The page is pretty long and without a sidemenu, it's quite difficult to navigate on the page at the moment.  ![image](https://user-images.githubusercontent.com/46486968/126335834-e709dac4-2853-4ab0-a040-1c79c87ca928.png)","closed","status: duplicate,","crlikcngroup","2021-07-20T13:52:57Z","2021-07-20T14:38:17Z"
"","27299","Allow customization of pretty printer settings in AbstractJackson2HttpMessageConverter","Hi guys,  I'm currently developing a feature in which I rely on Spring's HttpMessageConverter infrastructure and facing a necessity to have control over the configuration of PrettyPrinter instance used in MappingJackson2HttpMessageConverter. E.g. have different indentation. The PrettyPrinter reference is currently private to converter instance and has no accessors available to sub-classes: https://github.com/spring-projects/spring-framework/blob/4a9c7e631c60a12f3426d42143e9e27be0bf68ab/spring-web/src/main/java/org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter.java#L110 Every other aspect of behavior of MappingJackson2HttpMessageConverter is totally OK to me.  I thought what if you'll start to configure ObjectWriter instance with default pretty printer from Jackson's ObjectMapper settings? I.e. here https://github.com/spring-projects/spring-framework/blob/4a9c7e631c60a12f3426d42143e9e27be0bf68ab/spring-web/src/main/java/org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter.java#L452 instead of tying it to your very own pretty printer do: ` objectWriter = objectWriter.withDefaultPrettyPrinter(); ` and make ssePrettyPrinter to be the default one in org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#init(ObjectMapper), which is protected and therefore allowed to override. Thus you'll preserving current behavior simultaneously with allowing customization of pretty printer by external consumers.  Or propose your own variant for achieving the same!  We're stuck here at Spring Framework 4.3.25 so I'll have to solve my problem in some other way and won't directly benefit from the resolution of this issue. Still, I think the idea is quite interesting, don't you think so?  Thanks,  Dzmitry","closed","type: enhancement,","dzmitry-chuchva","2021-08-19T13:55:39Z","2021-09-21T15:06:37Z"
"","26937","LEAK: ByteBuf.release()","Hi get same error I changed webflux to 2.45 1 actionable task: 1 executed +--- org.springframework.boot:spring-boot-starter-webflux:2.4.2 | --- org.springframework:spring-webflux:5.3.3 -> 5.1.10.RELEASE +--- org.springframework.boot:spring-boot-starter-webflux:2.4.2 (n) +--- org.springframework.boot:spring-boot-starter-webflux:2.4.2 | --- org.springframework:spring-webflux:5.3.3 -> 5.1.10.RELEASE +--- org.springframework.boot:spring-boot-starter-webflux:2.4.2 | --- org.springframework:spring-webflux:5.3.3 -> 5.1.10.RELEASE +--- org.springframework.boot:spring-boot-starter-webflux:2.4.2 | --- org.springframework:spring-webflux:5.3.3 -> 5.1.10.RELEASE  the error i get is :  [ntLoopGroup-2-2] io.netty.util.ResourceLeakDetector : LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information. Recent access records: #1: io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:291) io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) #2: io.netty.buffer.AdvancedLeakAwareByteBuf.forEachByte(AdvancedLeakAwareByteBuf.java:670) io.netty.handler.codec.http.HttpObjectDecoder$HeaderParser.parse(HttpObjectDecoder.java:793) io.netty.handler.codec.http.HttpObjectDecoder.readHeaders(HttpObjectDecoder.java:592) io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:218) io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) #3: io.netty.buffer.AdvancedLeakAwareByteBuf.forEachByte(AdvancedLeakAwareByteBuf.java:670) io.netty.handler.codec.http.HttpObjectDecoder$HeaderParser.parse(HttpObjectDecoder.java:793) io.netty.handler.codec.http.HttpObjectDecoder.readHeaders(HttpObjectDecoder.java:572) io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:218) io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) #4: io.netty.buffer.AdvancedLeakAwareByteBuf.forEachByte(AdvancedLeakAwareByteBuf.java:670) io.netty.handler.codec.http.HttpObjectDecoder$HeaderParser.parse(HttpObjectDecoder.java:793) io.netty.handler.codec.http.HttpObjectDecoder$LineParser.parse(HttpObjectDecoder.java:842) io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:199) io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) #5: Hint: 'reactor.left.httpCodec' will handle the message from this point. io.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:357) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) #6: io.netty.buffer.AdvancedLeakAwareByteBuf.internalNioBuffer(AdvancedLeakAwareByteBuf.java:736) io.netty.handler.ssl.SslHandler.toByteBuffer(SslHandler.java:1485) io.netty.handler.ssl.SslHandler.access$300(SslHandler.java:165) io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:283) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1329) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) #7: io.netty.buffer.AdvancedLeakAwareByteBuf.nioBufferCount(AdvancedLeakAwareByteBuf.java:706) io.netty.handler.ssl.SslHandler.toByteBuffer(SslHandler.java:1485) io.netty.handler.ssl.SslHandler.access$300(SslHandler.java:165) io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:283) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1329) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) Created at: io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:349) io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187) io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:178) io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115) io.netty.handler.ssl.SslHandler.allocate(SslHandler.java:2138) io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1324) io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224) io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271) io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444) io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) java.lang.Thread.run(Thread.java:748) : 12 leak records were discarded because the leak record count is targeted to 4. Use system property io.netty.leakDetection.targetRecords to increase the limit.  'org.springframework.boot' version '2.1.9.RELEASE' ext { set('springCloudVersion', 'Greenwich.SR3') set('springCloudServices', '2.1.4.RELEASE') }  appreciate your help  @rchalicham","closed","status: invalid,","rchalicham","2021-05-12T15:33:10Z","2021-05-19T20:55:38Z"
"","27510","Add annotation to execute MongoDB scripts during integration tests","Hi all. There is a cool annotation [@Sql](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/jdbc/Sql.html), which allows to execute sql script before/after a test.  It may be good to have the same annotation for tests which use MongoDB.  I'm thinking over a new annotation and a new test execution listener, that will run a MongoDB script before/after test, as `@Sql` annotation does.  For example:  ```java @DataMongoTest class MovieRepositoryTest {          @Test     @MongoInsert(scriptLocation = ""movie.json"", collection = ""movies"")     void findById() {       ....     } } ```  movie.json ```json {   ""_id"": {     ""$oid"": ""573a1390f29313caabcd60e4""   },   ""genres"": [     ""Short"",     ""Comedy"",     ""Drama""   ],   ""title"": ""The immigrant"" }  ```  What do you think about it?","open","in: test,","sleepo581","2021-10-02T10:52:05Z","2021-10-02T17:14:20Z"
"","27216","Fix  error message in SynchronossPartHttpMessageReader","Hi @snicoll,  I have the configuration below:  ```java     @Bean     CodecCustomizer multiPartCodecCustomizer() {         return configurer -> {             SynchronossPartHttpMessageReader partReader = new SynchronossPartHttpMessageReader();             partReader.setMaxParts(5);              configurer.customCodecs().register(partReader);             MultipartHttpMessageReader multipartHttpMessageReader = new MultipartHttpMessageReader(partReader);             configurer.customCodecs().register(multipartHttpMessageReader);         };     } ```  When: ```shell curl --location --request POST 'http://localhost:8080/api/v1/test/bulk' \ --header 'Content-Type: multipart/form-data' \ --form 'files=@""/C:/Users/test/payload.csv""' \ --form 'files=@""/C:/Users/test/payload(1).csv""' \ --form 'files=@""/C:/Users/test/payload(2).csv""' \ --form 'files=@""/C:/Users/test/payload(3).csv""' \ --form 'files=@""/C:/Users/test/payload(4).csv""' \ --form 'files=@""/C:/Users/test/payload(5).csv""' \ ```  Actual:  ```json {     ""timestamp"": ""2021-07-27T09:39:55.438+00:00"",     ""path"": ""/api/v1/test/bulk"",     ""status"": 400,     ""error"": ""Bad Request"",     ""message"": ""Failure while parsing part[6]; nested exception is org.springframework.core.codec.DecodingException: Too many parts (6 allowed)"",     ""requestId"": ""17ee076c-1"" } ```  Expected:  ```json {     ""timestamp"": ""2021-07-27T09:39:55.438+00:00"",     ""path"": ""/api/v1/test/bulk"",     ""status"": 400,     ""error"": ""Bad Request"",     ""message"": ""Failure while parsing part[6]; nested exception is org.springframework.core.codec.DecodingException: Too many parts (6/5 allowed)"",     ""requestId"": ""17ee076c-1"" } ```  I checked `DefaultMultipartMessageReader` which seems to be correct. Unfortunately, I'm using an old version of Spring Boot `2.3.x` and I couldn't upgrade.   Thanks","closed","type: task,","aoudiamoncef","2021-07-27T09:59:01Z","2021-07-27T16:42:20Z"
"","27737","charset=UTF-8 appended to application/x-www-form-urlencoded","Hey everyone, So for a top tier telco comnpany I am trying to integrate and set CONTENT_TYPE in my request .. in many ways however server rejects as   application/x-www-form-urlencoded;charset=UTF-8   is sent instead of  application/x-www-form-urlencoded which is all that is accepted ( I have confirmed this with another Java program )   i.e. webflux    .header(HttpHeaders.CONTENT_TYPE, ""application/x-www-form-urlencoded"")                     . contentType(MediaType.APPLICATION_FORM_URLENCODED)  etc. I have tried coding around this. Can you tell me if there is a workaround as I need one urgently   org/springframework/spring-webflux/5.3.9/spring-webflux-5.3.9.jar org/springframework/spring-web/5.3.9/spring-web-5.3.9.jar org/springframework/spring-core/5.3.9/spring-core-5.3.9.jar org/springframework/spring-web/5.3.9/spring-web-5.3.9.jar!/org/springframework/http/codec/FormHttpMessageWriter.class  	protected MediaType getMediaType(@Nullable MediaType mediaType) { 		if (mediaType == null) { 			return DEFAULT_FORM_DATA_MEDIA_TYPE; 		} 		else if (mediaType.getCharset() == null) { 			return new MediaType(mediaType, getDefaultCharset()); 		} 		else { 			return mediaType; 		} 	}  Can you tell me if there is a workaround?  Dave","closed","for: stackoverflow,","DaveDunne","2021-11-26T14:09:54Z","2021-11-29T18:48:20Z"
"","26964","CronExpression is broken on spring-context-5.3.6","Here's a little proof you can run: ```java package com.example;  import org.junit.jupiter.api.Test; import org.springframework.scheduling.support.CronExpression;  import java.time.LocalDateTime; import java.time.ZoneOffset;  public class CronExpressionBugProof {  	@Test 	public void proveCronExpressionIsBroken() { 		CronExpression expression = CronExpression.parse(""0 15 12 */10 1-8 5""); 		LocalDateTime a = LocalDateTime.ofEpochSecond(1619784899L, 0, ZoneOffset.UTC); 		LocalDateTime b = LocalDateTime.ofEpochSecond(1619784900L, 0, ZoneOffset.UTC); 		LocalDateTime nextA = expression.next(a); 		LocalDateTime nextB = expression.next(b); 		System.out.println(""If I ask for the next match of \"""" + expression + ""\"" on "" + a + "", I get "" + nextA); 		System.out.println(""If I ask for the next match of \"""" + expression + ""\"" on "" + b + "", one second later, I get "" + nextB); 		System.out.println(""This is bad.""); 	} } ```  This prints ``` If I ask for the next match of ""0 15 12 */10 1-8 5"" on 2021-04-30T12:14:59, I get 2021-06-11T12:15 If I ask for the next match of ""0 15 12 */10 1-8 5"" on 2021-04-30T12:15, one second later, I get 2021-05-21T12:15 This is bad. ``` As you can see, something is deeply wrong with `CronExpression`. As you move forward in time, the next match of a cron expression should *never* move *backwards*, especially not by 3 whole weeks.  Let me know if you need any more info.","closed","in: core,","ScottAlbertine","2021-05-20T21:54:20Z","2021-05-26T14:50:02Z"
"","27535","Documentation: ""Multipart Filter with CSRF"" is missing the reason explaining why we must use ""web.xml"" for filter ordering for Servlet 3.0 and up.","Here's a link to the latest documentation:  https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations-multipart https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#csrf-multipartfilter  In the section linked above, it's missing a key crucial information about why we must use XML for filter ordering.  According to Baeldung, linked below:  https://www.baeldung.com/java-web-app-without-web-xml#xml-still-needed  We require the usage of `web.xml` mainly because:  > Even, with all the features introduced in Servlet 3.0, there are some use cases where we'll still need a web.xml file, among them: > > * We can't define the filter order with annotations – we still need the  section if we have multiple filters that we need to be applied in a particular order  The Spring documentation needs to explain the `` section in the `web.xml` and the purpose of why we need include `web.xml`. Without this key crucial information, no one would know the reason why we should use this, when everything we're doing is moving towards annotation-based configurations, especially for Spring Framework 6.  I would like to request to add a snippet, or some additional information to the documentation section 19.5.4, so anyone reading them will have a better understanding of the importance of including `web.xml`.","open","in: web,","tommai78101","2021-10-08T15:47:41Z","2021-11-10T12:28:02Z"
"","27880","Issue with Lookup autowire with generic type","Here is my sample code. This was working fine in 5.2 but when I upgraded to 5.3.13 it threw error ""org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'UtilBean< DefaultBeanUtil >' available""   `Interface BaseUtil{} `  ``` @Component Class DefaultBeanUtil implements BaseUtil{ } ``` ``` @Component @Scope(scopeName=ConfigurableBeanFactory.SCOPE_PROTOTYPE) Class UtilBean { } ```  ``` @Component Class MyBean { public void doSomething(){   getUtilBean().doSomething(); }   @Lookup   public UtilBean getUtilBean() {     return null;   } } ```  I can also see we have done some changes in here https://github.com/spring-projects/spring-framework/issues/26998","open","in: core,","vgaur","2022-01-03T14:54:25Z","2022-01-04T13:34:04Z"
"","27077","Conditions to determine if `@ComponentScan` should be applied can be chosen from the wrong class","Here is an example that demonstrates [the problem](https://github.com/snicoll-scratches/demo-condition-parent/blob/3e586697d23af0fe530422aa82c8148146b0efc0/src/main/java/com/example/demo/BaseConfiguration.java#L13): https://github.com/snicoll-scratches/demo-condition-parent  `ConfigurationClassParser` does the following when it determines if a `@ComponentScan` should be applied: https://github.com/spring-projects/spring-framework/blob/df588e030f069dd31997ff747839f1d8d5d8d7c7/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L292  It is processed on the `sourceClass` rather than the configuration class being built. The former can be a parent in the hierarchy. In such a case, the conditions in the parent are going to be considered (and the conditions of the configuration class will be ignored).  I am wondering how useful this condition is though. Considering that we should ignore the conditions on the parent, the conditions on the configuration class could have been evaluated prior to run `@ComponentScan`.  At some point in the history of the project 620c16f5c7bb543b18f71b2848f90461f8646237 was reverted to not process conditions on parent classes.","open","in: core,","snicoll","2021-06-18T12:51:31Z","2021-11-11T09:24:22Z"
"","27693","@RequestBody inject field failed when the field name conform to a form like 'aType'","Here is a example:  ```java // AController.java @PostMapping public String add(@RequestBody @Validated Form form) {         ... } ```  ```java // Form.java @Data public class Form {     private String aType;     private String bAbc;     private Integer cDef; } ```  request: ```json {   ""aType"":""123"",   ""bAbc"":""abc"",   ""cDef"":1 } ``` ![0](https://user-images.githubusercontent.com/59378056/142170402-feea0df3-4614-4ba6-97c8-9b1b111bf475.png)  All of the field in object 'from' will be null.","closed","status: invalid,","CPJIE","2021-11-17T09:08:13Z","2021-11-24T07:54:21Z"
"","27325","Increased memory when a single ```WebClientBuilder``` is used to create multiple ```WebClient```s.","Hello. We upgraded from Spring Boot 2.1.7.RELEASE to 2.3.12.RELEASE.  In our workload we have to make http requests to a huge number of external services (10k+). We use a single ```WebClientBuilder``` to create a ```WebClient``` for each external service when it's needed. With an updated Spring Boot we noticed that heap usage and gc time grew significantly. Some top objects from a heap dump: ``` org.springframework.http.MediaType	3,531,788 (8.2%)	197,780,128 B (9.2%)  n/a org.springframework.core.log.CompositeLog	1,724,850 (4%)	110,390,400 B (5.1%)	n/a org.springframework.util.MimeType[]	2,053,150 (4.8%)	74,241,920 B (3.5%)	n/a etc. ```  Digging into the heap dump I discovered that with SpringBoot 2.1.7.RELEASE we had a single ```DefaultExchangeStrategiesBuilder``` object, that were refferenced by all ```WebClient```s, but now we have 1 builder for each client.  Overridding ```WebClientCodecCustomizer``` to it's previous implementation helped, gc time decreased to the same level as it was in SpringBoot 2.1.7.RELEASE: ``` @Override public void customize(WebClient.Builder webClientBuilder) {     webClientBuilder.exchangeStrategies(ExchangeStrategies.builder()         .codecs((codecs) -> this.codecCustomizers.forEach((customizer) -> customizer.customize(codecs)))         .build()); } ```  As far as I understood, the root cause is that ```DefaultWebClientBuilder.initExchangeStrategies``` creates a new ```ExchangeStrategies.Builder``` for each ```build``` method call, if ```strategiesConfigurers``` list is not empty. Previous ```WebClientCodecCustomizer``` implementation used to set ```strategies``` field directly and thus used a single ```DefaultExchangeStrategiesBuilder``` object. If I'm not mistaken, a possible solution is to cache mutated ```ExchangeStrategies``` in ```initExchangeStrategies``` method.  Thanks.","closed","in: web,","Vorotyntsev","2021-08-26T12:28:35Z","2021-09-21T20:30:59Z"
"","26905","UriComponentsBuilder handles invalid port numbers correctly","Hello. Fixed a bug in the'UriComponentBuilder' class. The bug occurs in'UriComponentBuilder#fromUriString()'. A bug occurs when the port of the argument is not a number.  This issue occurs with the 'PORT_PATTERN' regular expression. If port is not a number, the regular expression is not captured. This is a good regex, but it causes problems.  You can check the issue in the test code below. ``` UriComponents stringPort = UriComponentsBuilder.fromUriString(""http://localhost:port/path"").build(); assertThat(stringPort.getScheme()).isEqualTo(""http""); assertThat(stringPort.getHost()).isEqualTo(""localhost""); assertThat(stringPort.getPath()).isEqualTo(""/path"");  // expected: ""/path"", but was ""port/path"" ```  'PORT' that is not captured is captured by'PATH_PATTERN'. `private static final String PATH_PATTERN = ""([^?#]*)"";`  I have fixed this bug. Thank you.","closed","type: bug,","glqdlt","2021-05-07T10:15:49Z","2021-05-11T12:44:22Z"
"","27499","Avoid duplicate JCacheOperationSource bean registration in","Hello.  In our application we use XML context and `` declaration in combination with JCache API.  Also we disable bean definition overrides by setting `GenericApplicationContext.setAllowBeanDefinitionOverriding(false)` in an `ApplicationContextInitializer`.  Such combination leads to `BeanDefinitionOverrideException` because the bean ""org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"" is registered twice:   ```java String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef); parserContext.registerBeanComponent(new BeanComponentDefinition(sourceDef, sourceName)); ```","closed","in: core,","nivolg","2021-09-30T19:42:09Z","2021-10-12T10:38:30Z"
"","27788","Add CacheErrorHandler implementation that logs exceptions rather than rethrowing them","Hello.  I would like to suggest that the Spring framework provide another `CacheErrorHandler` Implementation. Whenever I build a spring application that uses an external cache, I do write a class that implements CacheErrorHandler for just error logging rather than throwing an exception.  Maybe most developers don't want to fail a method invocation when the cache is not available because the original method can return results.  So, If Spring provides another CacheErrorHandler implementation for just logging, will be very convinient.  Thank you!    ---","closed","status: superseded,","bananayong","2021-12-09T14:19:18Z","2022-01-12T09:57:48Z"
"","27178","How to set DefaultListableBeanFactory#allowEagerClassLoading property","hello, i want to know how to set DefaultListableBeanFactory#allowEagerClassLoading value. I user spring + springmvc. I know have a public method ""setAllowEagerClassLoading"", but i do not know where to use it","closed","in: core,","yaoyuandota","2021-07-15T12:09:00Z","2021-07-31T12:19:15Z"
"","27432","Add isFalse assertion","Hello, everyone!  How about to add `isFalse` assert in `org.springframework.util.Assert` class? I think it would be nice to avoid negative assertions like that code: `Assert.isTrue(!expression, ""assert error"");`  Or tell please, what is your approach to write negative assertions?  Thank you in advance! Your faithfully, springframework user","open","in: core,","tral909","2021-09-17T15:32:06Z","2021-11-11T09:23:00Z"
"","27626","Dependency junit-platform-native and plugin native-maven-plugin not found in Spring Native","Hello, Project generated by _Spring Initialzr_ including _Spring Native_ dependency has _pom.xml_ file in which _junit-platform-native_ and _native-maven-plugin_ are not found. ![issue_Spring_Native](https://user-images.githubusercontent.com/62645728/139512716-76289796-ed00-4ad5-9144-4461e0d8775b.png) This happens only when _Spring Native_ is included in the project. I use Idea IntelliJ as IDE.","closed","status: invalid,","einstein1401","2021-10-30T00:04:14Z","2021-10-31T08:07:04Z"
"","27851","Why does @Cacheable not support configuring expiration time?","hello, I have some confusion when using `spring-cache` For example, when I use method's caching, I hope the results can be cached and the cache expires regularly. Now @Cacheable doesn't seem to support it. If I want to do this, I need to write some code. I don't know why doesn't Spring support cache expiration? It would be even better if it could support scheduled refresh, which could help me reduce some development time and avoid introducing other additional dependencies","closed","for: stackoverflow,","icankeep","2021-12-23T15:37:37Z","2021-12-24T08:42:43Z"
"","27855","@Scheduled cron issue with ""every x and y minute""","Hello, All my cron are working well except this one with ""every x and y minute"" I'm using `Spring Boot 2.5.4`  I tried this : `@Scheduled(cron = ""0 5,10 5-23 * * *"", zone = ""Europe/Paris"")`  The cron task is executed every minute, it's like i wrote ""0 * 5-23 * * *"" So we can use a coma for hours (like I saw in the documentation) but not for minutes ?  The solution I found is to use multiple tasks `@Scheduled(cron = ""0 5 5-23 * * *"", zone = ""Europe/Paris"")` `@Scheduled(cron = ""0 10 5-23 * * *"", zone = ""Europe/Paris"")`  It works but I think it will cause issues if the tasks are too long or too close to eachother","closed","status: feedback-reminder,","10142327","2021-12-23T14:18:30Z","2022-02-18T19:05:44Z"
"","27267","java.lang.NoSuchMethodError HandlerMethod. when migrating from 5.3.8 to 5.3.9","Hello,  I've just upgraded from 5.3.8 to 5.3.9 and the following error has appeared:  Caused by: java.lang.NoSuchMethodError: 'void org.springframework.web.method.HandlerMethod.(java.lang.String, org.springframework.beans.factory.BeanFactory, org.springframework.context.MessageSource, java.lang.reflect.Method)'  It is running on: - Apache Tomcat/9.0.52 - JVM Version: 16.0.1+9-24 - Windows 10  The trace is:  SEVERE: Servlet.init() para servlet [dispatcher] lanzó excepción org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping': Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: 'void org.springframework.web.method.HandlerMethod.(java.lang.String, org.springframework.beans.factory.BeanFactory, org.springframework.context.MessageSource, java.lang.reflect.Method)' 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1786) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) 	at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:702) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:668) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:716) 	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:591) 	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:530) 	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:170) 	at javax.servlet.GenericServlet.init(GenericServlet.java:158) 	at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1143) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1096) 	at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:989) 	at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4957) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5264) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:835) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:263) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:432) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:927) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:772) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:345) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:476) Caused by: java.lang.NoSuchMethodError: 'void org.springframework.web.method.HandlerMethod.(java.lang.String, org.springframework.beans.factory.BeanFactory, org.springframework.context.MessageSource, java.lang.reflect.Method)' 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.createHandlerMethod(AbstractHandlerMethodMapping.java:341) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry.register(AbstractHandlerMethodMapping.java:630) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.registerHandlerMethod(AbstractHandlerMethodMapping.java:328) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(RequestMappingHandlerMapping.java:395) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(RequestMappingHandlerMapping.java:76) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lambda$detectHandlerMethods$2(AbstractHandlerMethodMapping.java:298) 	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:723) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.detectHandlerMethods(AbstractHandlerMethodMapping.java:296) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.processCandidateBean(AbstractHandlerMethodMapping.java:265) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:224) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:212) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:206) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) 	... 49 more  ago 12, 2021 11:13:43 A. M. org.apache.catalina.core.StandardContext loadOnStartup SEVERE: Servlet [dispatcher] in web application [/Intranet] threw load() exception java.lang.NoSuchMethodError: 'void org.springframework.web.method.HandlerMethod.(java.lang.String, org.springframework.beans.factory.BeanFactory, org.springframework.context.MessageSource, java.lang.reflect.Method)' 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.createHandlerMethod(AbstractHandlerMethodMapping.java:341) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry.register(AbstractHandlerMethodMapping.java:630) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.registerHandlerMethod(AbstractHandlerMethodMapping.java:328) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(RequestMappingHandlerMapping.java:395) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(RequestMappingHandlerMapping.java:76) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lambda$detectHandlerMethods$2(AbstractHandlerMethodMapping.java:298) 	at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:723) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.detectHandlerMethods(AbstractHandlerMethodMapping.java:296) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.processCandidateBean(AbstractHandlerMethodMapping.java:265) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:224) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:212) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:206) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1845) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) 	at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:702) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:668) 	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:716) 	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:591) 	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:530) 	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:170) 	at javax.servlet.GenericServlet.init(GenericServlet.java:158) 	at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1143) 	at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1096) 	at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:989) 	at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4957) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5264) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:835) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:263) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:432) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:927) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.startup.Catalina.start(Catalina.java:772) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) 	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:345) 	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:476)  Thank you,  Óscar","closed","for: stackoverflow,","o-frias","2021-08-12T09:33:59Z","2021-08-12T16:38:09Z"
"","27359","WebTestClient.bindToController() fails when binding to a controller with placeholder in path","Hello spring development team.  I've ran across this problem during work and believe that it might be a bug.  Given the following controller: ```java @RestController public class TestController {     @GetMapping(""${test.get}"")     public Mono get() {         return Mono.just(Map.of(""Hello"", ""world""));     } } ``` with the following application.yaml ```yaml test:   get: /test ``` and the following test: ```java @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK) class TestControllerTest {      @Test     void get() {         WebTestClient webTestClient = WebTestClient.bindToController(new TestController()).build();          webTestClient.get()                 .uri(""/test"")                 .exchange()                 .expectStatus().is2xxSuccessful();     } } ```  When running the above test the following exception occurs:  org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'webHandler' defined in org.springframework.web.reactive.config.DelegatingWebFluxConfiguration: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'requestMappingHandlerMapping' defined in org.springframework.web.reactive.config.DelegatingWebFluxConfiguration: Invocation of init method failed; nested exception is org.springframework.web.util.pattern.PatternParseException: Char '.' is not allowed in a captured variable name   However when running the test with RANDOM_PORT webEnvironment as per the following test: ```java @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class TestControllerTest {     @LocalServerPort     private int port;      @Test     void get() {         WebTestClient webTestClient = WebTestClient.bindToServer().baseUrl(""http://localhost:"" + port).build();          webTestClient.get()                 .uri(""/test"")                 .exchange()                 .expectStatus().is2xxSuccessful();     } } ``` The test passed without much fanfare.  The mock web environment also pass if I replace the placeholder with the actual url.  I tested this on spring version 2.5.4","closed","status: feedback-reminder,","EnviableYapper0","2021-09-05T07:50:59Z","2021-11-23T07:26:48Z"
"","27839","MockMvc issue when validating params with custom regex validation","Hello I am no sure if this is a bug or I am not properly using MockMvc for my controller tests.  I have implemented this regex validation for my GetMapping controller which receives two String params with the follow format ""YYYY-MM-DD"".  ```java @Component public class PatterMatcher {      private static Pattern DATE_PATTERN = Pattern.compile(             ""^((19|2[0-9])[0-9]{2})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$"");      public boolean matches(String date) {         return DATE_PATTERN.matcher(date).matches();     } } ```  Then my controller makes the bellow validation before processing the request:  ```java         boolean startDateMatch = patterMatcher.matches(startDate);         boolean endDateMatch = patterMatcher.matches(endDate);          if (!startDateMatch) {             return ResponseEntity                     .status(HttpStatus.BAD_REQUEST)                     .body(new FailResponse(""failed"", ""startDate format is invalid""));         }          if (!endDateMatch) {             return ResponseEntity                     .status(HttpStatus.BAD_REQUEST)                     .body(new FailResponse(""failed"", ""endDate format is invalid""));         } ```  Thing is MockMvc always fails this validation no matters the way I construct the request. The test currently looks like this:  ```java         LinkedMultiValueMap parameters = new LinkedMultiValueMap();         parameters.add(""startDate"", ""2021-11-01"");         parameters.add(""endDate"", ""2021-11-01"");          MvcResult result = mockMvc                 .perform(MockMvcRequestBuilders.get(""/api/tickets"").queryParams(parameters))                 .andExpect(status().isOk()).andReturn();          System.out.println(result); ```  It always returns my custom ResponseEntity from my PatterMatcher regex validation:  ```java ResponseEntity        .status(HttpStatus.BAD_REQUEST)        .body(new FailResponse(""failed"", ""endDate format is invalid"")); ```  This is the complete response:  ``` MockHttpServletRequest:       HTTP Method = GET       Request URI = /api/tickets        Parameters = {startDate=[2021-11-01], endDate=[2021-11-01]}           Headers = []              Body = null     Session Attrs = {}  Handler:              Type = com.assessment.joseassessment.controllers.TicketsController            Method = com.assessment.joseassessment.controllers.TicketsController#getController(String, String)  Async:     Async started = false      Async result = null  Resolved Exception:              Type = null  ModelAndView:         View name = null              View = null             Model = null  FlashMap:        Attributes = null  MockHttpServletResponse:            Status = 400     Error message = null           Headers = [Content-Type:""application/json""]      Content type = application/json              Body = {""status"":""failed"",""reason"":""startDate format is invalid""}     Forwarded URL = null    Redirected URL = null           Cookies = []  ```  I suspect it is because the `[]` brackets on here  `Parameters = {startDate=[2021-11-01], endDate=[2021-11-01]}` but not sure about it.  Update----------------  OK, I just added one initial ""["" and one final ""]"" on my pattern so it matches the result output of the MockHttpServletRequest like ""^\\[((19|2[0-9])[0-9]{2})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])\\]$"" but the validation still fails so no idea why this validation regex patter works everywhere except using MockMvc for testing.  ```java System.out.println(""[2021-11-01]"".matches(                 ""^\\[((19|2[0-9])[0-9]{2})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])\\]$""));  Output = true ```  Thanks the great job you do.","closed","for: stackoverflow,","woodsoul507","2021-12-20T02:29:29Z","2021-12-21T16:21:25Z"
"","27551","`spring-jcl:compileJava` Gradle task fails in build","Hello ,I just install spring environment,But now always block here. I put error code paste under................  ``` Testing started at 12:38 ... > Task :buildSrc:compileJava UP-TO-DATE > Task :buildSrc:compileGroovy NO-SOURCE > Task :buildSrc:pluginDescriptors UP-TO-DATE > Task :buildSrc:processResources UP-TO-DATE > Task :buildSrc:classes UP-TO-DATE > Task :buildSrc:jar UP-TO-DATE > Task :buildSrc:assemble UP-TO-DATE > Task :buildSrc:pluginUnderTestMetadata UP-TO-DATE > Task :buildSrc:compileTestJava NO-SOURCE > Task :buildSrc:compileTestGroovy NO-SOURCE > Task :buildSrc:processTestResources NO-SOURCE > Task :buildSrc:testClasses UP-TO-DATE > Task :buildSrc:test NO-SOURCE > Task :buildSrc:validatePlugins UP-TO-DATE > Task :buildSrc:check UP-TO-DATE > Task :buildSrc:build UP-TO-DATE > Task :spring-beans:processResources UP-TO-DATE > Task :spring-core:cglibRepackJar UP-TO-DATE > Task :spring-beans:processTestFixturesResources NO-SOURCE > Task :spring-core:objenesisRepackJar UP-TO-DATE > Task :spring-core:processResources UP-TO-DATE > Task :spring-core:processTestFixturesResources NO-SOURCE > Task :spring-beans:processTestResources UP-TO-DATE > Task :spring-jcl:compileJava FAILED FAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':spring-jcl:compileJava'. > ��Ч��Դ���а�: 17 * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights. * Get more help at https://help.gradle.org BUILD FAILED in 7s 12 actionable tasks: 1 executed, 11 up-to-date ```","closed","status: invalid,","java-hxza","2021-10-13T04:40:49Z","2021-10-13T11:53:13Z"
"","27712","Add support for bytes literal of spring expression","Google's common expression language supports **bytes literal**, which I think is a good function. I hope spring expression can also expand this capability  `b""\x61\X62\X63""` will be resolved to `abc` `b""abc\x61\x62\x63""` will be resolved to `abcabc`  prefix:`b'` or `b""` suffix: `'` or `""`  Reference: https://github.com/google/cel-spec/blob/master/doc/langdef.md","closed","status: invalid,","BrucessKING","2021-11-21T07:57:12Z","2021-11-21T10:44:53Z"
"","27714","Add support for bytes literal in SpEL expressions","Google's common expression language supports **bytes literal**, which I think is a good function. I hope spring expression can also expand this capability  `b""\\x61\\x62\\x63""` will be resolved to `abc` `b""abc\\x61\\x62\\x63""` will be resolved to `abcabc` `b""\\x61\\x62\\x63"" + b""\\x64\\x65\\x66""` will be resolved to `abcdef` prefix:`b'` or `b""` suffix: `'` or `""`  Reference: https://github.com/google/cel-spec/blob/master/doc/langdef.md#string-and-bytes-values","open","type: enhancement,","BrucessKING","2021-11-21T11:17:11Z","2022-05-11T15:47:04Z"
"","27713","Add support for bytes literal of spring expression","Google's common expression language supports **bytes literal**, which I think is a good function. I hope spring expression can also expand this capability  `b""\\x61\\x62\\x63""` will be resolved to `abc` `b""abc\\x61\\x62\\x63""` will be resolved to `abcabc`  prefix:`b'` or `b""` suffix: `'` or `""`  Reference: https://github.com/google/cel-spec/blob/master/doc/langdef.md","closed","status: invalid,","BrucessKING","2021-11-21T11:01:58Z","2021-11-21T11:19:39Z"
"","27284","Add support for configuring Jackson's default leniency","Given https://github.com/spring-projects/spring-boot/pull/27659, it would be nice the builder and factory bean wrapper expose that setting as well.","closed","status: declined,","snicoll","2021-08-16T07:16:49Z","2021-08-16T14:50:01Z"
"","27888","Clear cache when clearing argument resolvers","Getting a resolver for a parameter does not work correctly after clearing because the cache is not cleared.","closed","type: bug,","demkom58","2022-01-04T23:44:52Z","2022-01-12T09:03:06Z"
"","27102","Simplify Comparator using method reference","Get inspiration from #23098","closed","type: task,","diguage","2021-06-27T09:09:58Z","2021-07-11T01:25:11Z"
"","27211","Merge pull request #1 from spring-projects/master","get","closed","status: invalid,","yvanme","2021-07-26T03:32:38Z","2021-07-26T06:37:20Z"
"","27210","Merge pull request #1 from spring-projects/master","get","closed","status: invalid,","yvanme","2021-07-26T03:31:25Z","2021-07-26T06:37:36Z"
"","27562","mark function resolveType as private","function resolveType() is a internal function usually act as a callee, it is called by other function in ResolveType.java under conditional precondition. it is not a general function for users, we should mark this function as private explicitly, to prevent users from making mistakes","closed","status: invalid,","takeaction21","2021-10-15T03:14:59Z","2021-10-15T07:58:10Z"
"","27475","Fix invalid characters in source files","From the main build on JDK 17:  ``` > Task :spring-beans:compileGroovy /tmp/build/6da1d659/git-repo/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java:355: error: unmappable character (0xC2) for encoding US-ASCII 						throw new IllegalStateException(""No scope name defined for bean ??"" + beanName + ""'""); 						                                                                ^ /tmp/build/6da1d659/git-repo/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java:355: error: unmappable character (0xB4) for encoding US-ASCII 						throw new IllegalStateException(""No scope name defined for bean ??"" + beanName + ""'""); 						                                                                 ^  > Task :spring-expression:javadoc /tmp/build/6da1d659/git-repo/spring-expression/src/main/java/org/springframework/expression/spel/ast/BeanReference.java:29: warning: invalid input: '&foo'  * For a FactoryBean the syntax &foo can be used to access the factory itself.                                     ^ /tmp/build/6da1d659/git-repo/spring-expression/src/main/java/org/springframework/expression/BeanResolver.java:22: warning: invalid input: '&'  * The & variant syntax allows access to the factory bean where relevant.            ^ /tmp/build/6da1d659/git-repo/spring-expression/src/main/java/org/springframework/expression/BeanResolver.java:31: warning: invalid input: '&' 	 * For attempting access to a factory bean, the name needs a & prefix. 	                                                                 ^  > Task :spring-expression:javadoc /tmp/build/6da1d659/git-repo/spring-expression/src/main/java/org/springframework/expression/TypeComparator.java:43: warning: invalid input: '","closed","type: task,","jhoeller","2021-09-27T14:48:42Z","2021-09-27T15:36:03Z"
"","27300","Merge pull request #1 from spring-projects/master","fork spring-projects","closed","status: invalid,","DouglasCui","2021-08-20T07:40:30Z","2021-08-20T07:44:25Z"
"","27076","Implement equals, hashCode, & toString in BeanMethod and *Metadata types","For consistency with `ConfigurationClass` as it would be useful to be able to use these to index additional metadata.","closed","type: enhancement,","snicoll","2021-06-18T07:43:09Z","2021-06-24T14:42:50Z"
"","27812","Remove references to AsyncConfigurerSupport as AsyncConfigurer should be used instead","For consistency with #27811, let's remove any reference to `AsyncConfigurerSupport` as `AsyncConfigurer` has default methods and the support class is no longer necessary..","closed","in: core,","snicoll","2021-12-14T12:54:12Z","2021-12-14T13:06:21Z"
"","27091","Copyright Notice in License is missing","For companies that use this library, it is important to understand who is the copyright holder. In the license file that is attached, the copyright holder is not clearly stated but it is still kept as the template value.  It would be great if you could add the name(s) of the copyright holder such that the legal situation gets clarified properly.","closed","status: invalid,","divyank-vwits","2021-06-22T11:01:52Z","2021-06-22T18:08:35Z"
"","27780","Deprecate ListenableFuture in favor of CompletableFuture","For application facing APIs, we can provide CompletionStage alternatives. For internal usages, we could retain it or phase it out completely.","closed","type: enhancement,","rstoyanchev","2021-12-07T11:26:10Z","2022-07-27T11:03:10Z"
"","27483","Defensive reference to JNDI API for JDK 9+ (optional `java.naming` module)","Following up on https://github.com/spring-projects/spring-framework/issues/26884#issuecomment-929000919, our optional JNDI support for injection points - and therefore the `java.naming` module on JDK 9+ - is being referenced in two common places: `CommonAnnotationBeanPostProcessor` and `StandardServletEnvironment`. Since we're only really referring to JNDI API types such as `javax.naming.NamingException` through our own support classes, we can easily make this defensive with a reflective `jndiPresent` check before touching our actual JNDI support classes.  While `java.naming` is a minor concern on 5.3.x (where the much larger `java.desktop` is still a required module as well), this is easy enough to address there, in preparation for a more significant benefit in 6.0 (#26884).","closed","type: enhancement,","jhoeller","2021-09-28T10:24:14Z","2021-09-28T17:10:59Z"
"","27069","Upgrade to ASM 9.2 (for early Java 18 support)","Following up on #27023, support for Java 18 made it into ASM master in the meantime.","closed","type: dependency-upgrade,","jhoeller","2021-06-16T13:34:23Z","2021-06-28T20:13:40Z"
"","27426","Remove Joda-Time support","Following up on #25736, Joda-Time support will be removed for Spring Framework 6 now.","closed","type: task,","jhoeller","2021-09-16T21:06:42Z","2021-09-17T07:14:56Z"
"","27425","Remove JiBX support","Following up on #22249, JiBX support will be removed for Spring Framework 6 now.","closed","type: task,","jhoeller","2021-09-16T17:11:20Z","2021-09-17T07:14:56Z"
"","27443","Remove support for RxJava 1 and 2","Following up on #19628, we're finally removing RxJava 1.x support from Spring's `ReactiveAdapterRegistry` since it has been superseded not only by RxJava 2.x but even RxJava 3.x in the meantime.  As per a later note, we're also removing RxJava 2.x support right away since RxJava 2 reached EOL itself in February 2021 already.","closed","type: task,","jhoeller","2021-09-21T07:06:13Z","2021-09-27T11:02:37Z"
"","27474","Deprecate RxJava 2 in favor of RxJava 3","Following up on #19628 and preparing for #27443, let's add a deprecation note to the documentation, concerning RxJava 2's own EOL half a year ago: https://github.com/ReactiveX/RxJava/releases/tag/v2.2.19","closed","type: task,","jhoeller","2021-09-27T10:39:17Z","2021-09-27T15:36:02Z"
"","27768","Expose headers from native client request after request is committed","Fixes issues like [that](https://github.com/zalando/logbook/pull/1150#issuecomment-986223607), when public API does not expose headers that have been set by connector implementation.","closed","type: enhancement,","sokomishalov","2021-12-06T09:40:53Z","2022-01-11T18:54:10Z"
"","27262","Emit WebClientResponseException for malformed HTTP response","Fixes an issue that can be triggered in reactive WebClients when the server throws a malformed response chunk.  I picked up on the original issue by using [WireMock](http://wiremock.org/) with the following test case:  ```java         WireMockServer server = new WireMockServer(SocketUtils.findAvailableTcpPort());         server.start();         WebClient client = WebClient             .builder()             .baseUrl(server.baseUrl())             .clientConnector(new ReactorClientHttpConnector(HttpClient.create().wiretap(true)))             .build();          server.givenThat(post(""/"").willReturn(             aResponse()                 .withFault(Fault.MALFORMED_RESPONSE_CHUNK)                 .withHeader(""Response-Header-1"", ""value 1"")                 .withHeader(""Response-Header-2"", ""value 2"")                 .withBody(""{\""message\"": \""Hello, World!\""}""))         );                  Mono result = client             .post()             .retrieve()             .toBodilessEntity();          assertThrows(WebClientException.class, result::block); ```  ...where we see an unhandled exception get thrown.   ``` org.opentest4j.AssertionFailedError: Unexpected exception type thrown ==> expected:  but was:  	at org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:65) 	at org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:37) 	at org.junit.jupiter.api.Assertions.assertThrows(Assertions.java:3007)         .... Caused by: reactor.core.Exceptions$ReactiveException: reactor.netty.http.client.PrematureCloseException: Connection prematurely closed DURING response 	at reactor.core.Exceptions.propagate(Exceptions.java:392) 	at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:97) 	at reactor.core.publisher.Mono.block(Mono.java:1704) 	at org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:55) 	... 71 more 	Suppressed: java.lang.Exception: #block terminated with an error 	at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) 		... 73 more Caused by: reactor.netty.http.client.PrematureCloseException: Connection prematurely closed DURING response 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Body from POST http://localhost:23337 [DefaultClientResponse] Stack trace: ```  (With no additional stacktrace provided by the underlying reactor library).  This exception does not appear to be documented in the most recent documentation for this codepath,  and since the various HTTP client connectors all use their own variants for these exceptions, it makes it  overly difficult for developers to add suitable error handling for components such as in-house libraries for projects relying on Spring WebFlux without hardcoding edge cases for all libraries by default. Therefore, my assumption has been that this is a potential bug as a result.  The issue itself appears to be being caused by the body processing throwing the exception rather than the call to `exchange()` itself. On bodiless entities this appears to defer to be lazy, and the reactor client itself also appears to be only reporting the malformed chunks after the body has been processed, which meant that the existing error handling in ExchangeFunctions was not being hit for these cases.  For some reason, the OKHTTP3 Mock Web Server is not chunking responses properly in such a way that I could simulate this in integration tests, so I resorted to writing a simple thread with a ServerSocket to simulate the same issue. If anyone can think of a nicer way of achieving this, I will be happy to replace it, but for now it appears to cover that test case.  I have also expanded the new test pack that was added on the 8th for WebClient integration tests to cover a couple of other test cases that I was performing on an in-house project in the company I work for that also appear to not have existing cases yet. These are handling scenarios where the server closes the socket before the response has been sent or midway through the request being received. These cases passed already but I added them just to be certain that no other regressions were added in this error handling flow.  ---  I am not aware of any issues that cover this already, but I may have missed some. I did take the time to try and find any that may reference something related to this, but if I have missed anything I will update the  PR accordingly.  Hope what I have added is all okay, as I have only ever contributed documentation changes before now. If there is any feedback or anyone can think of a better way to resolve this; or if there is any reason for this behavior needing to be left how it is, please let me know!","closed","type: enhancement,","ascopes","2021-08-11T19:45:00Z","2021-10-11T16:24:05Z"
"","27303","Fix UrlPathHelper#shouldRemoveSemicolonContent()","Fixes #27256  This PR fixes a bug that renders read-only `UrlPathHelper`s unusable, because `shouldRemoveSemicolonContent()` throws an exception. For example, when using `UrlPathHelper#rawPathInstance`, which is read-only.  The `checkReadOnly()` method should only be called from methods that modify properties to prevent modification of read-only instances.","closed","type: bug,","evpaassen","2021-08-20T15:16:19Z","2021-08-22T12:50:41Z"
"","26913","Fixes Incorrect Assertion check in AbstractBrokerRegistration","Fixes #26896   Fixes the incorrect double assertion check.","closed","status: declined,","lower-case","2021-05-09T08:59:48Z","2021-05-11T06:57:55Z"
"","26914","Resolve Values from Mapping Path for Mvc Uri Builder","Fixes #26795","open","in: web,","lower-case","2021-05-09T11:20:11Z","2021-11-10T11:55:34Z"
"","27567","Fix assertion failure messages in DefaultDataBuffer.checkIndex()","Fixed assertion logs in checkIndex to correctly use the length parameter","closed","in: core,","ebradshaw","2021-10-17T17:21:25Z","2021-10-18T15:56:23Z"
"","27260","Fix typo in DefaultPartHttpMessageReader","Fix typo (`Section 5.2` -> `Section 5.1`)","closed","type: documentation,","joshua-qa","2021-08-11T13:22:06Z","2021-08-11T14:31:31Z"
"","27484","Fix Javadoc typo in PathMatchConfigurer#setUseSuffixPatternMatch","fix the java doc because in 5.3.x the default is set to false  see this issue  https://github.com/spring-projects/spring-framework/issues/27269","closed","type: task,","xixingya","2021-09-28T11:26:06Z","2022-05-09T02:39:03Z"
"","27692","Fix javax.servlet doc to jakarta.servlet","Fix the doc that contains javax.servlet","closed","type: task,","xixingya","2021-11-17T06:41:16Z","2021-11-17T10:50:35Z"
"","26938","Fix punctuation in Custom Cache Resolution section of ref docs","Fix punctuation .","closed","type: task,","chenqimiao","2021-05-13T12:27:36Z","2021-05-14T02:15:03Z"
"","27375","Fix memory leak on AOP Proxy class definition cache","Fix memory leak on AOP Proxy class definition cache.  ## How to reproduce   1. Like `@Validated` annotation with Request scope Controller like bellow  ```java // Annnotation definition @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Controller @Scope(WebApplicationContext.SCOPE_REQUEST) @RequestMapping(method = { RequestMethod.GET, RequestMethod.HEAD }) @Transactional @Validated public @interface MyController { }  @MyController public class RootController {     @ModelAttribute(""requireJs"")     public boolean isRequireJs() {         return true;     }      @RequestMapping(""/search"")     public String search(         Model model,          @RequestParam(value = ""space"", required = false) @Max(value=100) String space) {         // ommit     } } ```  2. Aop class definition cache won't work well, therefore memory leak  ## Why  this bug is intruced by:  - https://github.com/spring-projects/spring-framework/pull/26017/files#diff-8b811560ae60c9f7937f0d378880f1b4366fa67ea7024db018931a26e3b449edL370-L376 - https://github.com/spring-projects/spring-framework/pull/26017/files#diff-dd90aa36a7221a652e04631ac19dcb6693a9c841e43a90d36cc3caa51121630eL945-L947  1. Because `@Validated` annotation added, `AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization` add advice for `@Validated`  2. Before https://github.com/spring-projects/spring-framework/pull/26017/, cache in org.springframework.cglib.core.AbstractClassGenerator  works well. Because org.springframework.aop.framework.AdvisedSupport#getConfigurationOnlyCopy copy org.springframework.aop.framework.AdvisedSupport#advisorsArray for create copy instance.  But after https://github.com/spring-projects/spring-framework/pull/26017/, use same reference of org.springframework.aop.framework.AdvisedSupport#advisors for  create copy instance. and this advitors field update by AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization  3. When Create Aop class instance, try to reuse cache for class definition  Cache key is defined below code:  - org.springframework.cglib.proxy.Enhancer#createClass - org.springframework.cglib.proxy.Enhancer#createHelper  org.springframework.cglib.proxy.Enhancer#filter is registered at https://github.com/spring-projects/spring-framework/blob/main/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L201-L202  4. cache miss for class definition, memory leak happen At AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization, advice object updated and therefore cache key is pollute, cache miss and memory leak happen. ![memoryleak](https://user-images.githubusercontent.com/625124/132629010-389ed075-05ba-427d-85aa-cd4900b618b8.png)  So, When creating copy instance on org.springframework.aop.framework.AdvisedSupport#getConfigurationOnlyCopy, It is good that create new instance of ArrayList and copy all advices.  This bug reported by @hikoma Thanks!","closed","in: core,","yokotaso","2021-09-09T05:40:56Z","2021-09-14T11:04:23Z"
"","27852","Fix typo and use of componentry","Fix lattery and componentry word","closed","type: documentation,","xixingya","2021-12-24T03:16:12Z","2022-01-03T12:43:11Z"
"","27367","Add method AbstractMessageSource.setSearchingParentFirst(boolean)","Fix gh-27366","open","in: core,","quaff","2021-09-07T03:07:11Z","2021-11-11T09:23:00Z"
"","27349","Merge AopTestUtils into AopUtils","Fix gh-27348","open","in: core,","quaff","2021-09-01T07:09:48Z","2022-03-18T10:11:28Z"
"","27324","Resolve handler variable in mapping path","fix gh-27313","closed","","quaff","2021-08-26T10:13:55Z","2021-09-10T09:04:08Z"
"","27151","Fix link to Javadoc API","Fix broken link in Spring Docs section ""3.1. Validation by Using Spring’s Validator Interface"".  > More information about the methods it offers can be found in the javadoc. https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validator","closed","type: documentation,","HubertWo","2021-07-10T09:46:18Z","2021-07-11T07:10:40Z"
"","27836","Fix the issue#27683","fix #27683 . `pathSeparator` should be a complete separator, But in `StringUtils#tokenizeToStringArray`,each of the characters is individually considered as a delimiter. So I try to replace `StringUtils#tokenizeToStringArray` with `StringUtils#delimitedListToStringArray`.","closed","status: declined,","aoyvx","2021-12-18T15:20:21Z","2022-01-05T16:26:52Z"
"","27565","use URLEncoder/URLDecoder new method to simplify the code. Fix #27554","Fix #27554","closed","status: duplicate,","diguage","2021-10-16T09:39:49Z","2021-10-16T10:55:23Z"
"","27560","Use LocalDataSourceJobStore only if one is not specified via Quartz properties","Faced with the problem that I can't set my JobStore via quartz properties: `spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX`  Fixes  -  #23632","closed","type: enhancement,","p-daniil","2021-10-14T14:32:12Z","2021-10-23T14:12:15Z"
"","27523","`TransactionalOperator` should not attempt to rollback after a failed commit","Expected behavior --------------------------------------------------------------------- Using reactive transaction management, when a commit step fails in the `TransactionalOperator`, then the commit failure exception should be propagated. This can be for example a `ConcurrencyFailureException`.  Actual behavior (Spring 5.3.9) ---------------------------------------------------------------------  When a commit fails, the commit exception is logged & dropped in `TransactionalOperatorImpl`, and instead an `IllegalTransactionStateException` is propagated.  Practical case ---------------------------------------------------------------------  When under high concurrency, our application is observing uninformative `IllegalTransactionStateException` like this:  ``` org.springframework.transaction.IllegalTransactionStateException: Transaction is already completed - do not call commit or rollback more than once per transaction 	at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.rollback(AbstractReactiveTransactionManager.java:492) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Assembly trace from producer [reactor.core.publisher.MonoLift] : 	reactor.core.publisher.Mono.error 	org.springframework.transaction.reactive.AbstractReactiveTransactionManager.rollback(AbstractReactiveTransactionManager.java:492) Error has been observed at the following site(s): 	|_          Mono.error ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.rollback(AbstractReactiveTransactionManager.java:492) 	|_     Mono.onErrorMap ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.rollbackOnException(TransactionalOperatorImpl.java:119) 	|_           Mono.then ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.lambda$null$2(TransactionalOperatorImpl.java:83) 	|_  Mono.onErrorResume ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.lambda$null$3(TransactionalOperatorImpl.java:83) 	|_        Mono.flatMap ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.lambda$transactional$4(TransactionalOperatorImpl.java:81) 	|_        Mono.flatMap ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.transactional(TransactionalOperatorImpl.java:75) 	|_   Mono.contextWrite ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.transactional(TransactionalOperatorImpl.java:85) 	|_   Mono.contextWrite ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.transactional(TransactionalOperatorImpl.java:86) ```  The above illegal transaction state seems to be overriding the propagation of this exception: ``` ERROR --- o.s.t.r.TransactionalOperatorImpl : Application exception overridden by rollback exception  java.lang.RuntimeException: Async resource cleanup failed after onComplete 	at reactor.core.publisher.FluxUsingWhen$CommitInner.onError(FluxUsingWhen.java:533) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Assembly trace from producer [reactor.core.publisher.MonoLift] : 	reactor.core.publisher.Mono.usingWhen 	org.springframework.transaction.reactive.TransactionalOperatorImpl.lambda$null$3(TransactionalOperatorImpl.java:81) Error has been observed at the following site(s): 	|_ Mono.usingWhen ⇢ at org.springframework.transaction.reactive.TransactionalOperatorImpl.lambda$null$3(TransactionalOperatorImpl.java:81) Stack trace: 		at reactor.core.publisher.FluxUsingWhen$CommitInner.onError(FluxUsingWhen.java:533) 		... 		at io.r2dbc.postgresql.util.FluxDiscardOnCancel$FluxDiscardOnCancelSubscriber.onComplete(FluxDiscardOnCancel.java:99) 		at io.r2dbc.postgresql.client.ReactorNettyClient$Conversation.complete(ReactorNettyClient.java:719) 		at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.emit(ReactorNettyClient.java:984) 		... Caused by: org.springframework.dao.ConcurrencyFailureException: R2DBC commit; could not serialize access due to read/write dependencies among transactions; 	at org.springframework.r2dbc.connection.ConnectionFactoryUtils.convertR2dbcException(ConnectionFactoryUtils.java:218) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Assembly trace from producer [reactor.core.publisher.MonoLift] : 	reactor.core.publisher.Mono.onErrorMap 	org.springframework.r2dbc.connection.R2dbcTransactionManager.doCommit(R2dbcTransactionManager.java:279) Error has been observed at the following site(s): 	|_    Mono.onErrorMap ⇢ at org.springframework.r2dbc.connection.R2dbcTransactionManager.doCommit(R2dbcTransactionManager.java:279) 	|_                    ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.lambda$processCommit$21(AbstractReactiveTransactionManager.java:445) 	|_         Mono.defer ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.processCommit(AbstractReactiveTransactionManager.java:439) 	|_          Mono.then ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.processCommit(AbstractReactiveTransactionManager.java:439) 	|_          Mono.then ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.processCommit(AbstractReactiveTransactionManager.java:448) 	|_          Mono.then ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.processCommit(AbstractReactiveTransactionManager.java:474) 	|_         Mono.error ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.lambda$processCommit$25(AbstractReactiveTransactionManager.java:480) 	|_          Mono.then ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.lambda$processCommit$25(AbstractReactiveTransactionManager.java:480) 	|_ Mono.onErrorResume ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.processCommit(AbstractReactiveTransactionManager.java:479) 	|_          Mono.then ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.processCommit(AbstractReactiveTransactionManager.java:480) 	|_                    ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.lambda$commit$20(AbstractReactiveTransactionManager.java:420) 	|_       Mono.flatMap ⇢ at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.commit(AbstractReactiveTransactionManager.java:412) Stack trace: 		at org.springframework.r2dbc.connection.ConnectionFactoryUtils.convertR2dbcException(ConnectionFactoryUtils.java:218) 		at org.springframework.r2dbc.connection.R2dbcTransactionManager.translateException(R2dbcTransactionManager.java:439) 		at org.springframework.r2dbc.connection.R2dbcTransactionManager.lambda$doCommit$9(R2dbcTransactionManager.java:279) 		... ```  Investigation of the cause ---------------------------------------------------------------------  The problem described above matches this warning on `ReactiveTransactionManager#rollback`: https://github.com/spring-projects/spring-framework/blob/fb7eea9757222ed52d679a8a93a61a6d9e0b5240/spring-tx/src/main/java/org/springframework/transaction/ReactiveTransactionManager.java#L99-L102  Looking at the current implementation of `TransactionalOperatorImpl`, it looks like indeed this can happen; if `transactionManager::commit` emits an error then a rollback will be attempted by the `onErrorResume`: https://github.com/spring-projects/spring-framework/blob/fb7eea9757222ed52d679a8a93a61a6d9e0b5240/spring-tx/src/main/java/org/springframework/transaction/reactive/TransactionalOperatorImpl.java#L74-L84  Looks related to the discussion in https://github.com/spring-projects/spring-framework/pull/23562  Possible solution ---------------------------------------------------------------------  The operators in `TransactionalOperatorImpl#transactional` could be restructured in such a way that rollbacks are not attempted after a failure to commit. Maybe this could be accomplished by moving the `rollbackOnException` to the `asyncError` parameter in the `usingWhen`. A similar approach should be applied in `TransactionalOperatorImpl#execute`.  Additionally, would it make sense to add the application exception as suppressed when the rollback in `rollbackOnException` emits an exception? This could make it easier to debug this and similar issues because currently the application exception is only linked when the rollback emits an `TransactionSystemException`, but not in other cases like `IllegalTransactionStateException`.","open","in: data,","EnricSala","2021-10-06T07:37:09Z","2021-10-06T09:02:12Z"
"","27084","Clear Statement warnings in ScriptUtils.executeSqlScript()","executeSqlScript use only one Statement to execute sql, so the getWarnings of Statement will contains pre warning  Ps: Maybe creating new Statement for every sql is better","open","status: feedback-provided,","lfz757077613","2021-06-20T10:18:48Z","2021-06-21T02:46:25Z"
"","27606","Support multiple origin pattern injection in @CrossOrigin","example  ```java @CrossOrigin(originPatterns = ""${originPatterns:http://a.b.c:[8088,8089],http://d.e.f}"", methods = {POST, OPTIONS}) ```  I found that when using the above example configuration, it is not possible to configure multiple source addresses through properties, hope to support this function, thank you very much  fixed #24982","open","status: feedback-provided,","a364176773","2021-10-25T06:13:50Z","2022-02-10T15:23:05Z"
"","27569","DefaultResponseErrorHandler update javadoc comment","Error message truncation was removed as part of https://github.com/spring-projects/spring-framework/issues/27552, updating the javadoc comment of the method to reflect that.","closed","in: web,","smilep","2021-10-18T04:59:19Z","2021-11-10T11:21:26Z"
"","27412","Java Config - injection by method parameter name is wrong if multiple beans of same type are available","Environment: JDK: 11 Spring Boot 2.5.4, Spring 5.3.9  Please excuse me, if it is an expected behaviour, or I'm doing something stupid. Consider following java based config ``` @Configuration public class MyConfig { 	@Primary 	@Bean(""dataSource1"") 	@ConfigurationProperties(prefix = ""app.datasource1"") 	public DataSource dataSource1() 	{ 		return DataSourceBuilder.create().build(); 	}  	@Bean(""dataSource2"") 	@ConfigurationProperties(prefix = ""app.datasource2"") 	public DataSource dataSource2() 	{ 		return DataSourceBuilder.create().build(); 	}  	@Bean 	public JdbcTemplate jdbcTemplate1( DataSource dataSource1) 	{ 		JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource1); 		return jdbcTemplate; 	}  	@Bean 	public JdbcTemplate jdbcTemplate2( DataSource dataSource2) 	{ 		JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource2); 		return jdbcTemplate; 	} } ``` and configuration file ``` app:   datasource1:     jdbcUrl: jdbc:postgresql://localhost:5432/postgres     driverClassname: org.postgresql.Driver     username: dbuser     password: dbpass    datasource2:     jdbcUrl: jdbc:h2:mem:2db     driverClassname: org.h2.Driver     username: SA     password: ```  I expect here the dataSource1 (Postgres) to be injected by name for bean jdbcTemplate1 and dataSource2 (h2) to be injected by name for bean jdbcTemplate2. In fact dataSource1 (Postgres) is being injected into both beans (I suppose since it is marked @Primary). I can resolve a problem by using method injection, calling dataSource1() and dataSource2() which works as expected and I guess is the recommended approach for java based configs, I can also add @Qualifier annotations on method parameters and this would work as well, but it not clear to me why the autowiring by name doesn't work out of the box within config. Is it a bug or a feature?","closed","for: stackoverflow,","chpasha","2021-09-15T10:34:26Z","2021-09-15T11:38:59Z"
"","27632","Clarify LogFormatUtils limitLength vs replaceNewlines parameters","During the refactoring of the `LogFormatUtils` a potential bug has been introduced in 5.3.12 in commit 90fdcf88d832eb6d8f635d3aa727c762b273845b.  The parameter `limitLength` in the method`formatValue(...)` is used when calling the overloaded method, but it is used for the parameter `replaceNewlines` that has a totally different meaning. This is on the one hand confusing and on the other hand could affect the fix for CVE-2021-22096","closed","in: core,","mum-viadee","2021-11-02T10:02:18Z","2021-11-09T10:32:26Z"
"","27563","Is it useful for Spring if JDK supports registering user-defined commands and executing the commands by jcmd?","Dear Spring Developers,  I am currently trying to extend the DCmd framework of OpenJDK so that Java developers can register some custom commands, as follows:  ```java Factory.register(""My.Date"", output -> {     output.println(new Date()); });  @Command(name = ""My.Echo"", description = ""Echo description"") class Echo implements Executable {      @Parameter(name = ""text"", ordinal=0, isMandatory = true)     String text;      @Parameter(name = ""repeat"", isMandatory = true, defaultValue = ""1"")     int repeat;      @Override     public void execute(PrintWriter out) {         for (int i = 0 ; i < repeat; i++) {             out.println(text);         }     } }  Factory.register(Echo.class); ```  Users can call custom commands through `jcmd` or `jmx`.  Related discussions can refer to: https://github.com/openjdk/jdk/pull/5938  Do you think this extension is helpful to the Spring framework?  We hope this extension can bring real benefits to some popular frameworks.  Any input is appreciated.  Thanks, Denghui","closed","","D-D-H","2021-10-15T06:03:50Z","2021-10-29T10:34:03Z"
"","27089","Request: Make MultipartFileResource a public class","Currently, MultipartFileResource class is package-private, but it is quite handy in some situations as end user.  For example., when having a Multipart Controller that forwards  the payload to another Controller, wrapping the MultiPartFIle into a MultipartFileResource is quite handy, since we don't need to deal with the setting of the filename, the length or the mediatype, and it fits absolutely nicely when using new contentRequestMatchers.multipartData()","closed","type: enhancement,","nightswimmings","2021-06-21T21:27:36Z","2021-06-21T21:53:35Z"
"","27494","SimpleCacheResolver resolves templated SpEL expressions","Currently, it's expected from the user to provide their own `CacheResolver` if they wish to use SpEL inside `@Cache*(cacheNames=""..."")`. I think it wouldn't hurt if it was implemented out of the box as templated expressions: ``` ""myCache-#{#arg}-#{@bean.something()}"" etc. ``` Especially given the fact that `CacheOperationExpressionEvaluator` is already implemented for `key`, `unless`, and `condition` attributes of `@Cache*` annotations.  And it will behave exactly the same as it does now but also can evaluate a templated expression if there is one: ```java if (!expression.contains(templateParserContext.getExpressionPrefix())) return expression; ``` I decided to put that stuff right into `SimpleCacheResolver` making its factory methods backward-compatible. I don't see a point in creating a second resolver class because it still does the same thing if there's no nested expression in the name, and there's effectively no penalty in simply checking `String#contains` every time.  Example usecase: ```java @Cacheable(cacheNames = ""schemas-#{#vendorId}"", key = ""#entityId"") public Schema getSchema(String vendorId, String entityId){...}  @CacheEvict(cacheNames = ""schemas-#{#vendorId}"", allEntries = true) public void updateVendor(String vendorId, VendorDto newData){...} ``` Here, if I don't have SpEL inside cache names, I can only define a cache named ""schemas"", but whenever I want to update one vendor, I only want its cache to be evicted, not everyone's. An alternative is to manage the cache programmatically or implement my own cache resolver.","closed","in: core,","Sam-Kruglov","2021-09-29T10:27:06Z","2021-12-02T21:56:15Z"
"","27207","Support WebSocketSessionDecorator/WebSocketHandlerDecorator in StandardWebSocketClient","Currently, it seems not to be possible to use any `WebSocketSessionDecorator` or `WebSocketHandlerDecorator` with StandardWebSocketClient. It would be great to use `StandardWebSocketClient` e.g. with a `ConcurrentWebSocketSessionDecorator` or any other decorator.","closed","","x-gnn","2021-07-23T12:45:23Z","2021-08-06T13:04:52Z"
"","27400","Allow the actual value to be rendered to filter producible media types in content negotiation","Currently, content negotiation is completely type-based and doesn't consider the actual value to be rendered.  My use case is as follows: Spring HATEOAS users usually work with `RepresentationModel` instances they return from controllers. Spring Data REST currently does so as well, and it has two different `HttpMessageConverters` registered, one for HAL and one for HAL FORMS. Whether the latter can reasonably be rendered depends *on the state* of the `RepresentationModel` and there is currently no way to filter the list of producible media types based on the value.  I've looked into `ResponseBodyAdvice` as it has access to all the moving parts I need, but I cannot throw a `HttpMediaTypeNotAcceptableException` from that one as the exception is a checked one. I need to be able to produce a `406` in case someone asks for HAL FORMS only but depending on the value to be rendered it cannot be produced properly.","open","in: web,","odrotbohm","2021-09-14T12:58:29Z","2021-11-10T12:31:47Z"
"","27608","Create immutable MultiValueMap wrapper","Currently, `CollectionUtils::unmodifiableMultiValueMap` returns an (unmodifiable) copy of the target map, and therefore allocates extra memory. We cannot use the `Collections.unmodifiableMap` wrapper in said method, because each value of the map should be immutable as well, and thus needs a `Collections.unmodifiableList` wrapper.  We should create a `UnmodifiableMultiValueMap` wrapper, similar to the JDK `Collections`, that wraps entries and values with immutable counterparts where needed.","closed","type: enhancement,","poutsma","2021-10-25T13:22:14Z","2021-10-26T13:33:49Z"
"","27561","Add a new HttpConnector based on Java 11 HttpClient","Currently there are some HTTP connectors existed, but most of them depends on 3rd party libs, such as Apache HttpClientComponets, Reactor/Netty, OKHttp etc.   Java 11 introduced a new Reactive HttpClient based on Java 9 Flow API.  It is better to add a new HTTP Connector based on this client and make it as the default HTTP client when using it in both blocking client and reactive client(eg. RestTemplate, reactive WebClient).","closed","status: duplicate,","hantsy","2021-10-14T14:49:48Z","2021-10-15T08:03:57Z"
"","26926","Improve support for port numbers in allowedOriginPattern of CorsConfiguration","Currently it's not possible to support any port or multiple, specific ports with a single pattern. The workaround is to create two origin patterns such as `""https://*.example.com""` and `""https://*.example.com:*""`.  One idea is to enhance the pattern syntax with a comma separated list of ports or a wildcard: ``` https://*.example.com:[8080] https://*.example.com:[8080,9000] https://*.example.com:[*] ```  This was originally reported in #26892.","closed","status: superseded,","rstoyanchev","2021-05-10T20:35:53Z","2021-05-23T16:04:17Z"
"","27206","Compatibility with Jackson 2.13","Currently in RC1, Jackson 2.13 is likely to go GA around our 5.3.10 release.","closed","type: dependency-upgrade,","jhoeller","2021-07-23T10:00:46Z","2021-07-23T10:24:18Z"
"","27405","DefaultStompSession doesn't fully support @SubscribeMapping","Currently DefaultStompSession just support the subscription for message broker, the subscribe message is sent without payload and the subscription object is kept in DefaultStompSession all the time until unsubscribe it. Obviously it's not suitable for application subscription (A controller method is annotated with @SubscribeMapping).","closed","in: messaging,","yfei-z","2021-09-15T07:41:26Z","2022-03-11T08:30:12Z"
"","27083","Only track DisposableBean targets in ThreadLocalTargetSource","Currently all target objects are added to the targetSet, this looks to be done so when the application is shutdown destroy can be called on each target object. But if the target is not a DisposableBean, then there is nothing to destroy and the object reference is being held on to for no good reason. On app servers that turn over threads often (jboss/undertow) this can lead to a memory leak. Since the thread/threadlocal is gone but the targetSet has still has it's reference for destroying, but there is nothing to destroy.","closed","in: core,","slandrum00","2021-06-19T20:02:43Z","2021-06-20T16:34:23Z"
"","27313","Support resolving `@RequestMapping` path with SpEL expression based on controller instance","Currently `RequestMappingHandlerMapping` shares a global `EmbeddedValueResolver`.  https://github.com/spring-projects/spring-framework/blob/4a9c7e631c60a12f3426d42143e9e27be0bf68ab/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java#L182-L185  It's not possible to extract a base controller path which contains controller specific variables.  ```java import java.io.Serializable;  import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.core.ResolvableType; import org.springframework.data.jpa.domain.AbstractPersistable; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.util.StringUtils; import org.springframework.web.bind.annotation.DeleteMapping;  public abstract class AbstractEntityController 		implements ApplicationContextAware {  	private final Class entityClass;  	private JpaRepository repository;  	@SuppressWarnings(""unchecked"") 	protected AbstractEntityController() { 		entityClass = (Class) ResolvableType.forClass(getClass()).as(AbstractEntityController.class).getGeneric(0) 				.resolve(); 	}  	@SuppressWarnings(""unchecked"") 	@Override 	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { 		repository = (JpaRepository) applicationContext.getBeanProvider( 				ResolvableType.forClassWithGenerics(JpaRepository.class, entityClass, ResolvableType 						.forClass(getClass()).as(AbstractTreeableEntityController.class).getGeneric(1).resolve()), 				false).getIfUnique(); 	}  	public String getEntityName() { 		return StringUtils.uncapitalize(entityClass.getSimpleName()); 	}  	@DeleteMapping(""/#{#this.entityName}/{id}"") 	public void delete(PK id) { 		repository.deleteById(id); 	}  } ```  ``` Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'enityName' cannot be found on object of type 'org.springframework.beans.factory.config.BeanExpressionContext' - maybe not public or not valid? 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:91) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:117) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:308) 	at org.springframework.expression.common.CompositeStringExpression.getValue(CompositeStringExpression.java:108) 	at org.springframework.expression.common.CompositeStringExpression.getValue(CompositeStringExpression.java:43) 	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:166) 	... 57 more ```","closed","type: enhancement,","quaff","2021-08-23T03:15:45Z","2021-09-10T09:03:52Z"
"","26939","Consider returning static DefaultApplicationStartup step","Currently `DefaultApplicationStartup.start` returns a new `DefaultStartupStep` instance on each call. I think the reason is to detect if `end()` has been called so that `IllegalArgumentExceptions` can be thrown. I wonder if we can drop those exceptions for the default implementation and return a single static instance to save object allocations?","closed","type: enhancement,","philwebb","2021-05-13T18:40:25Z","2021-06-01T13:13:48Z"
"","27441","Unable to send Binary message with StompSession and spring-messaging library","Current StompSession send message seems to support sending TextMessage, but does not support BinaryMessage format. Wrapping the message as a TextMessage does not seem to solve the purpose. ByteArray needs to be supported as per Stomp which would then be sent as Binary message.","open","in: messaging,","ShyamalaViswanathan","2021-09-20T11:10:50Z","2021-11-10T12:01:02Z"
"","27544","Use Arrays.hashCode() in ByteArrayResource.hashCode()","Current implementation produces equal hash codes for all instances of `ByteArrayResource` with the same length of underlying array disregarding their contents. This seems to be wrong as hash code should be calculated on the basis of the content of `byte[]`.","closed","type: enhancement,","stsypanov","2021-10-11T07:59:16Z","2021-10-11T19:08:34Z"
"","27286","AntPathMatcher enhancement","Current implementation of the `AntPathMatcher.extractUriTemplateVariables` is not able to handle defined variable if the pattern contains multiple groups (additional inner `(` and `)` )  and I don't think it's necessary. The current code relies on the group indexes, but it's already possible to use group names (since Java 1.7).  This test explains the problem: ```java import org.junit.Test; import org.springframework.util.AntPathMatcher;  import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;  public class AntPathMatcherBug {      static final String PATTERN = ""**/appname{version:(-[0-9]+(\\.[0-9a-zA-Z_+]+)+?)?}-xx.jar"";     static final String PATH = ""somepath/appname-1.0.0-xx.jar"";      @Test     public void testGetVersionVariableFail() {         final AntPathMatcher antPathMatcher = new AntPathMatcher();          assertTrue(antPathMatcher.match(PATTERN, PATH));          // antPathMatcher generates \Qappname\E((-[0-9]+(\.[0-9a-zA-Z_+]+)+?)?)\Q-xx.jar\E         final Map variablesMap = antPathMatcher.extractUriTemplateVariables(PATTERN, PATH);         // throws Exception         // java.lang.IllegalArgumentException: The number of capturing groups in the pattern segment \Qappname\E((-[0-9]+(\.[0-9a-zA-Z_+]+)+?)?)\Q-xx.jar\E         // does not match the number of URI template variables it defines, which can occur if capturing groups are used in a java.net.URI template regex.         // Use non-capturing groups instead.      }      @Test     public void testGetVersionVariableSuccess() {         final Pattern regex = Pattern.compile(""\\Qappname\\E(?(-[0-9]+(\\.[0-9a-zA-Z_+]+)+?)?)\\Q-xx.jar\\E"");         final Matcher matcher = regex.matcher(PATH);         assertTrue(matcher.find());          assertEquals(matcher.group(""version""), ""-1.0.0"");      } } ``` My suggestion is to add group naming (`?` in this case) and not to use group indexes to identify and to get variable value. Using non-capturing groups makes regex more difficult to read and this solution will avoid throwing exception at runtime.  What do you think?","open","in: core,","Vity01","2021-08-13T10:29:37Z","2021-11-10T11:54:15Z"
"","27625","Connection not released when request is cancelled","Current Behavior  This issue was first opened on r2dbc-postgresql, some discussion can be seen there. https://github.com/pgjdbc/r2dbc-postgresql/issues/459  Then it was migrated to r2dbc-pool https://github.com/r2dbc/r2dbc-pool/issues/140  The discussion lead to possible problems on spring implementation.  We are facing some issues related to stuck connections in the pool. After some investigation we could identify the problem happening in our search flow. Our frontend has a combobox with some kind of ""debounce"" which cancel resquests while user keep typing and sends only one request to our server. When these requests gets cancelled right after the validation query have runned establishing the connection as healthy, and before the real SQL query starts the connections never gets released. This is a very specific moment on the chain and its hard to reproduce.  We have found this post, that seems to be related but the suggested answer doesn't really helps, and the posted code sample does not leads to reproduce our problem. https://stackoverflow.com/questions/68407202/r2dbc-pool-connection-not-released-after-cancel  We could reproduce the behavior by calling any endpoint thats fetchs data from database and using a breakpoint after the connection gets established and before the query starts, then we force the request's cancel and release the breakpoint in our application, this way the connection always gets stuck.  The last query runned by the connection is always the validation query, in our case a simple ""SELECT 1"":  ``` new ConnectionPool(        ConnectionPoolConfiguration.builder(connectionFactory)            .maxIdleTime(Duration.ofMillis(Long.parseLong(idleTimeout)))            .initialSize(Integer.parseInt(initialSize))            .maxSize(Integer.parseInt(maxSize))            .acquireRetry(3)            .maxLifeTime(Duration.ofMillis(Long.parseLong(maxLifetime)))            .validationQuery(""SELECT 1"")            .build())            ```             The breakpoint was placed on the class DefaultFetchSpec from org.springframework.r2dbc.core, inside the public Flux all() method, but this is not a consistent way to reproduce it.  Another way we was able to reproduce it was by ""stressing"" the application and simulating several consecutives ""network failures"" forcing the cancel of the request, the log file produced by this approach can de found here https://github.com/jfrossetto/connection-stuck/blob/stress-cancel-pool088/log_connectionStuck2.txt  Analyzing the logs seems that when the connection gets ""stuck"" the FluxDiscardOnCancel does not show up in the logs All connections are stuck with field query filled with value SELECT 1  |pid|datname|usename|application_name|backend_start|query_start|query| |---|-------|-------|----------------|-------------|-----------|-----| |7463|postgres|postgres|sample|2021-10-27 11:51:31.626|2021-10-27 11:51:34.253|SELECT 1| |7464|postgres|postgres|sample|2021-10-27 11:51:31.626|2021-10-27 11:51:34.490|SELECT 1| |7465|postgres|postgres|sample|2021-10-27 11:51:34.505|2021-10-27 11:51:37.468|SELECT 1|","open","in: data,","rogtejada","2021-10-29T10:59:46Z","2021-11-10T12:18:55Z"
"","27236","Improve performance of CompositePropertySource#getPropertyNames","Create LinkedHashSet with a initialCapacity, prevent underhood table resize cost in continuous add operations. Reduce bootstrap time in the situation with large properties.  Micro-Benchmark `CompositePropertySourceBenchmark` result (unit: ns/op):  numberOfPropertySource: 5 numberOfPropertyNamesPerSource: 1000   | Baseline | New -- | -- | --   | 369339 | 265699   | 372184 | 266577   | 375854 | 267332   | 375830 | 266348   | 376366 | 265801 Avg | 373915 | 266352 Cost | 1 | 0.71   numberOfPropertySource: 10 numberOfPropertyNamesPerSource: 1000   | Baseline | New -- | -- | --   | 794450 | 556300   | 793987 | 611713   | 799981 | 577572   | 803261 | 554797   | 807606 | 565953 Avg | 799857 | 573267 Cost | 1 | 0.72","open","in: core,","Shawyeok","2021-08-02T04:13:23Z","2021-11-11T09:22:58Z"
"","27536","Create spring-ex","Create an example spring","closed","status: invalid,","rasarathrilanka","2021-10-08T16:38:45Z","2021-10-08T17:00:49Z"
"","27203","Use MessageSource for @ExceptionHandler methods","Continue https://github.com/spring-projects/spring-framework/commit/bb816c123ca86c6f373ee2bd1632f43c117a8f15 Fix gh-27156","closed","type: enhancement,","quaff","2021-07-23T03:08:50Z","2021-07-29T13:52:02Z"
"","27265","dynamicLoader.loadClass  doesn't seem to be working","ContextTypeMatchClassLoader ，a temporary ClassLoader for type matching（when use ltw） but its loadClass always seems to  parental delegation，OverridingClassLoader‘s  overrideDelegate seems always null","open","in: core,","xjgkd","2021-08-12T09:13:58Z","2021-11-11T09:22:58Z"
"","27671","Change configureAndRefreshWebApplicationContext change to requireNonNullElseGet if use jdk 17","configureAndRefreshWebApplicationContext change to requireNonNullElseGet if use jdk 17","closed","in: core,","xixingya","2021-11-11T02:27:02Z","2021-11-17T12:02:18Z"
"","27369","Compile with parameter names","Compiled code should contain parameter names to avoid the need for class resources to be included in native image builds.","closed","type: task,","sdeleuze","2021-09-07T13:06:30Z","2021-09-07T13:30:44Z"
"","27161","Configure CommonsMultipartResolver to support specific HTTP methods","Commons FileUpload and therefore Spring's `CommonsMultipartResolver` traditionally supports POST requests only. There are several examples on StackOverflow and co where this got extended to e.g. POST and PUT. While `StandardServletMultipartResolver` does not restrict the HTTP method by default and suggests itself as a modern-day alternative, there are still scenarios where the maximum portability of Commons FileUpload (as a library that ships with the application) is desirable. As a consequence, a `supportedMethods` configuration option for enumerating POST, PUT, possibly PATCH or even custom methods is desirable.  This goes along with the new `strictServletCompliance` flag in `StandardServletMultipartResolver` (#26826).","closed","type: enhancement,","jhoeller","2021-07-12T21:06:23Z","2021-07-12T21:20:11Z"
"","27557","Avoid double toString call when joining collections","Commit 8d3e8ca3a2d534f6ee872bb6a65a89c44e987cf6 optimized how the method `cleanPath` normalizes its input path and introduced the method `joinStrings` which pre-allocates a StringBuilder of the correct size to hold the final delimited string.  Commit cc026fcb8ae51172f3d063e7ed07a32927e23d8e removed this method again and merged it with `collectionToDelimitedString`. The merged implementation however now undoes part of the original optimization: `toString()` is called twice on each item of the collection, which will put quite some pressure on the GC for non-string collections. For string collections this is basically a no-op because a string simply returns itself, i.e. `this`, in its `toString` implementation.  This commit introduces a specialization for string collections again. The actual collecting of items into the StringBuilder has now been extracted and the call sites pass a (potentially pre-allocated) StringBuilder instance.  This is a followup to PR #26316","closed","status: declined,","knittl","2021-10-13T19:32:14Z","2021-10-23T08:27:39Z"
"","27643","add CodeFlow#toPrimitiveTargetDesc Nullable","CodeFlow#toPrimitiveTargetDesc do not have a nullable compare","closed","","xixingya","2021-11-05T09:59:10Z","2021-11-08T07:39:13Z"
"","27634","The bean object provides injection options","code:   ```java @Component(value = ""CommonPulsarProducerConfiguration"") @ConfigurationProperties(prefix = ""pulsar.producer"") public class PulsarProducerProperties {     private String topicUrl;     ..... } @Bean public PulsarConsumerProperties  demo1() {      return new PulsarConsumerProperties(); } ```  Question：  I want to inject another bean with empty properties, but `ConfigurationProperties` will take effect.  Is there a configuration that allows automatic injection of properties not to be performed?","closed","for: stackoverflow,","mingyifei","2021-11-03T13:04:23Z","2021-11-03T14:27:34Z"
"","27194","Do not close response for InputStreamResource","Closing underlying stream should be responsibility of InputStreamResource ```java ResponseEntity entity = restTemplate.getForEntity(url, InputStreamResource.class); try (InputStream is = response.getBody().getInputStream()) { 	// do something } ``` ""java.io.IOException: closed"" is fixed after this commit","closed","status: declined,","quaff","2021-07-21T05:52:34Z","2021-07-21T08:37:06Z"
"","27735","DataAccessUtils result accessors with Optional return value","Closes #27728 (https://github.com/spring-projects/spring-framework/issues/27728)  Hi everyone, this is my first PR in any project here on github with the goal of improving my understanding of java. Hope i understood the enhancement request correctly.","open","type: enhancement,","KaidosGH","2021-11-26T00:46:59Z","2022-03-15T14:58:33Z"
"","26893","Fix MethodMatcher API doc description","Chapter *6. Spring AOP APIs*, section *6.1.1. Concepts* contains incorrect API description for *org.springframework.aop.MethodMatcher* interface. Instead of array there should be varargs.","closed","type: task,","hrybs","2021-05-05T07:26:22Z","2021-05-05T10:21:52Z"
"","27703","Change StringUtils trimWhitespace to String.strip()","Change StringUtils trimWhitespace to String.strip()","closed","type: enhancement,","xixingya","2021-11-19T09:35:36Z","2021-12-06T12:40:11Z"
"","27000","Aspectj: @Async with @Transactional doesn't work","Both annotation on same method. ```     @Async     @Transactional     public Future asyncTask() {     .... ```  First the transaction aspect is called, starting the transaction, then the async aspect, spawning a new thread. The order should be inverse.  Sample repo: https://github.com/cdalexndr/spring-boot-issue-26699  **Spring Boot 2.4.4**","open","in: core,","cdalexndr","2021-05-28T20:57:55Z","2021-11-10T09:51:30Z"
"","27594","Issue with AbstractDataBoundFormElementTag.resolveId() in Spring 5.2.12","Below code is added in Spring 5.2.12 for `AbstractDataBoundFormElementTag.resolveId()`, and it is marked as, this method can return `null` value.  Is it really possible that this method will return null in any scenario? Because at the end, it will auto generate id based on property path.  ```java 	@Nullable 	protected String resolveId() throws JspException { 		Object id = evaluate(""id"", getId()); 		if (id != null) { 			String idString = id.toString(); 			return (StringUtils.hasText(idString) ? idString : null); 		} 		return autogenerateId(); 	} ```","closed","status: invalid,","sush4444","2021-10-22T14:42:07Z","2021-10-22T15:31:31Z"
"","27630","Ensure SpEL allows only well formed qualified IDs","Before, expressions like `new java util ArrayList()` or `new .....java..util.ArrayList()` can be treated as `new java.util.ArrayList()`, and can be parsed normally as if they were right. I added some code to ensure that only valid qualified ids are acceptable.  I add a test, and also checked that all the previous test have passed.  See #27133","closed","in: core,","lijinliangyihao","2021-11-02T05:09:04Z","2022-05-22T13:42:29Z"
"","27017","MultipartHttpMessageWriter in WebClient doesn't use custom Jackson Encoder since 5.3.3","Before v5.3.3, when configuring a custom jackson object mapper in WebClient with: ```java 			ObjectMapper mapper = instantiateAndConfigureMyCustomObjectMapper(); 			WebClient client = WebClient.builder().clientConnector(clientConnector) 					// ... 					.exchangeStrategies(ExchangeStrategies.builder().codecs(configurer -> { 						configurer.defaultCodecs().jackson2JsonDecoder(new Jackson2JsonDecoder(mapper, 								MediaType.APPLICATION_JSON, new MediaType(""application"", ""*+json""))); 						configurer.defaultCodecs().jackson2JsonEncoder(new Jackson2JsonEncoder(mapper, 								MediaType.APPLICATION_JSON, new MediaType(""application"", ""*+json""))); 					}).build()) 					// ... 					 .build(); ```  when multipart message is being encoded and contains a part with an object subject to be encoded by jackson, the custom mapper was used.  From v5.3.3 onwards, an empty default unconfigured ObjectMapper is used instead, causing several regressions to existing code that expects JSON configuration to be followed.  Most likely changes in spring-web/src/main/java/org/springframework/http/codec/support/BaseDefaultCodecs.java are related to this, as it seems now initialization of readers and writer is done eagerly just once instead of on-demand  https://github.com/spring-projects/spring-framework/issues/26263 https://github.com/spring-projects/spring-framework/commit/e1385090e4b008236219bbbf6f5e4d635b4a130b","closed","type: regression,","flozano","2021-06-03T13:12:57Z","2021-06-08T19:53:00Z"
"","27462","Spring-RSocket: server channel overflow if request does not respect backpressure","Bad client may send arbitrary (very large, limited only by connection bandwidth) number of channel request messages regardless of server allowed with requestN, which then are blindly accepted by spring-rsocket and delivered to end user's handler.   Usually user's handler is not prepared to receive more messages than requested, and likely either queues messages in memory, or overwhelms its downstream resources.  Trivial reproducer is at [channel-overflow](https://github.com/mostroverkhov/springboot-repros/tree/develop/dos-channel-overflow/src/main/java/example/client) using springboot 2.5.4  `./server.sh`, `./channel_overflow.sh`  Particularly, server reports  ```properties 2021-09-23 22:20:15.039  INFO 5047 --- [     parallel-2] example.service.Service                  : payload requested: 5, received: 49929 2021-09-23 22:20:16.039  INFO 5047 --- [     parallel-2] example.service.Service                  : payload requested: 5, received: 50076 2021-09-23 22:20:17.039  INFO 5047 --- [     parallel-2] example.service.Service                  : payload requested: 5, received: 50042 2021-09-23 22:20:18.039  INFO 5047 --- [     parallel-2] example.service.Service                  : payload requested: 5, received: 49988 2021-09-23 22:20:19.039  INFO 5047 --- [     parallel-2] example.service.Service                  : payload requested: 5, received: 50023 2021-09-23 22:20:20.039  INFO 5047 --- [     parallel-2] example.service.Service                  : payload requested: 5, received: 49975 ```","open","in: messaging,","mostroverkhov","2021-09-23T19:43:02Z","2021-11-10T09:11:32Z"
"","27785","Declare serialVersionUID on DefaultAopProxyFactory","Backport of gh-27784","closed","type: backport,","spring-projects-issues","2021-12-08T12:43:35Z","2021-12-14T17:24:41Z"
"","27783","Possible NPE in Spring MVC LogFormatUtils","Backport of gh-27782","closed","type: backport,","spring-projects-issues","2021-12-08T09:51:50Z","2021-12-14T17:24:35Z"
"","27797","MergedAnnotationReadingVisitor should ignore annotation types that cannot be loaded","Backport of gh-27772","closed","type: backport,","spring-projects-issues","2021-12-10T14:08:52Z","2021-12-15T12:11:35Z"
"","27667","Use ByteArrayDecoder in DefaultClientResponse::createException","Backport of gh-27666","closed","type: backport,","spring-projects-issues","2021-11-10T15:46:41Z","2021-11-10T16:10:45Z"
"","27660","Lazy annotation throws exception if non-required bean does not exist","Backport of gh-27649","closed","type: backport,","spring-projects-issues","2021-11-09T18:27:47Z","2021-11-09T22:02:25Z"
"","27593","UndertowHeadersAdapter's remove() method violates Map contract","Backport of gh-27592","closed","type: backport,","spring-projects-issues","2021-10-22T12:49:17Z","2021-10-22T13:25:12Z"
"","27571","DefaultResponseErrorHandler update javadoc comment","Backport of gh-27569","closed","type: backport,","spring-projects-issues","2021-10-18T08:56:49Z","2021-11-10T11:21:37Z"
"","27577","Fix assertion failure messages in DefaultDataBuffer.checkIndex()","Backport of gh-27567","closed","type: backport,","spring-projects-issues","2021-10-18T15:17:47Z","2021-10-18T16:19:55Z"
"","27581","Incorrect Javadoc in [NamedParameter]JdbcOperations.queryForObject methods regarding exceptions","Backport of gh-27559","closed","type: backport,","spring-projects-issues","2021-10-19T16:39:28Z","2021-10-19T16:47:18Z"
"","27558","Enhance DefaultResponseErrorHandler to allow logging complete error response body","Backport of gh-27552","closed","type: backport,","spring-projects-issues","2021-10-13T19:46:25Z","2021-10-13T20:22:08Z"
"","27549","Performance impact of con.getContentLengthLong() in AbstractFileResolvingResource.isReadable() downloading huge jars to check component length","Backport of gh-27541","closed","type: backport,","spring-projects-issues","2021-10-12T13:58:35Z","2021-10-12T14:19:32Z"
"","27548","Performance impact of ResourceUrlEncodingFilter on HttpServletResponse#encodeURL","Backport of gh-27538","closed","type: backport,","spring-projects-issues","2021-10-12T13:58:16Z","2021-10-12T14:19:31Z"
"","27513","Upgrade to GitHub Changelog Generator 0.0.7 in CI","Backport of gh-27512","closed","type: backport,","spring-projects-issues","2021-10-03T05:08:59Z","2021-10-03T05:10:58Z"
"","27547","Avoid duplicate JCacheOperationSource bean registration in","Backport of gh-27499","closed","type: backport,","spring-projects-issues","2021-10-12T10:29:21Z","2021-10-12T11:20:19Z"
"","27498","Proxy generation with Java 17 fails with ""Cannot invoke ""Object.getClass()"" because ""cause"" is null""","Backport of gh-27490","closed","type: backport,","spring-projects-issues","2021-09-29T18:34:32Z","2021-09-30T16:00:43Z"
"","27476","Fix invalid characters in source files","Backport of gh-27475","closed","type: backport,","spring-projects-issues","2021-09-27T15:08:43Z","2021-09-27T15:50:28Z"
"","27502","Non-escaped closing curly brace in RegEx results in initialization error on Android","Backport of gh-27467","closed","type: backport,","spring-projects-issues","2021-10-01T08:31:15Z","2021-10-12T10:30:10Z"
"","27460","Upgrade CI to github-release resource 1.5.5","Backport of gh-27459","closed","type: backport,","spring-projects-issues","2021-09-23T16:37:20Z","2021-10-12T10:31:58Z"
"","27455","ConcurrentReferenceHashMap's entrySet violates the Map contract","Backport of gh-27454","closed","type: backport,","spring-projects-issues","2021-09-23T10:24:18Z","2021-09-24T11:50:21Z"
"","27457","DefaultMessageListenerContainer does not log an error/warning when consumer tasks have been rejected","Backport of gh-27451","closed","type: backport,","spring-projects-issues","2021-09-23T12:42:51Z","2021-09-24T11:50:21Z"
"","27403","Update GitHub credentials in CI pipeline","Backport of gh-27402","closed","type: backport,","spring-projects-issues","2021-09-15T06:39:47Z","2021-09-24T12:22:32Z"
"","27401","Support char, float, and double primitive default values in BeanUtils.instantiateClass()","Backport of gh-27390","closed","type: backport,","spring-projects-issues","2021-09-14T13:32:23Z","2021-09-14T14:28:51Z"
"","27385","Fix bug fix icon in changelog configuration","Backport of gh-27384","closed","type: backport,","spring-projects-issues","2021-09-10T22:00:43Z","2021-09-12T09:45:29Z"
"","27396","Invalid JavaBean property 'logoutHandlers' being accessed (warning in the logs for Spring Security's ConcurrentSessionFilter)","Backport of gh-27372","closed","type: backport,","spring-projects-issues","2021-09-13T16:16:00Z","2021-09-13T16:51:38Z"
"","27398","CommonsMultipartResolver and DEBUG logging lead to empty fileMap in MultipartHttpServletRequest","Backport of gh-27350","closed","type: backport,","spring-projects-issues","2021-09-14T11:20:55Z","2021-09-14T13:07:34Z"
"","27344","Convenient configuration of type permissions for XStream 1.4.18","Backport of gh-27343","closed","type: backport,","spring-projects-issues","2021-08-31T13:53:41Z","2021-09-02T20:54:28Z"
"","27341","Polish AbstractAspectJAdvisorFactory","Backport of gh-27340","closed","type: backport,","spring-projects-issues","2021-08-31T07:40:42Z","2021-08-31T13:57:15Z"
"","27352","Fix Kotlin example for filtering handler functions","Backport of gh-27337","closed","type: backport,","spring-projects-issues","2021-09-02T21:04:08Z","2021-09-02T21:19:41Z"
"","27312","Document when `prepareTestInstance()` is invoked when using the `SpringMethodRule`","Backport of gh-27305","closed","type: backport,","spring-projects-issues","2021-08-22T13:49:19Z","2021-08-22T14:03:14Z"
"","27310","Fix UrlPathHelper#shouldRemoveSemicolonContent()","Backport of gh-27303","closed","type: backport,","spring-projects-issues","2021-08-22T12:29:26Z","2021-08-22T12:50:07Z"
"","27275","CompositeUriComponentsContributor#hasContributors: method name is not compliant with its intention","Backport of gh-27271","closed","type: backport,","spring-projects-issues","2021-08-13T08:31:01Z","2021-08-18T15:42:49Z"
"","27311","UrlPathHelper: checkReadOnly() called in read method shouldRemoveSemicolonContent()","Backport of gh-27256","closed","type: backport,","spring-projects-issues","2021-08-22T12:42:21Z","2021-09-14T14:36:46Z"
"","27213","WebSocketMessageBrokerStats.getExecutorStatsInfo() throws exception if Executor is not a ThreadPoolExecutor","Backport of gh-27209","closed","type: backport,","spring-projects-issues","2021-07-26T09:47:47Z","2021-07-26T10:04:39Z"
"","27212","ResponseStatusException.initCause always throws IllegalStateException","Backport of gh-27196","closed","type: backport,","spring-projects-issues","2021-07-26T09:20:11Z","2021-09-02T20:54:27Z"
"","27140","BeanCreationException error message should always include declaring class of constructor (or factory method)","Backport of gh-27139","closed","type: backport,","spring-projects-issues","2021-07-07T11:13:33Z","2021-07-13T17:08:00Z"
"","27096","SimpleMethodMetadataReadingVisitor.Source.toString() omits separator for method arguments","Backport of gh-27095","closed","type: backport,","spring-projects-issues","2021-06-24T14:59:17Z","2021-06-24T14:59:18Z"
"","27094","SynchronossPartHttpMessageReader should only create temp directory when needed","Backport of gh-27092","closed","type: backport,","spring-projects-issues","2021-06-23T14:05:27Z","2021-06-23T14:18:05Z"
"","27065","DefaultPathSegment allows shared empty parameters map to be mutated","Backport of gh-27064","closed","type: backport,","spring-projects-issues","2021-06-15T14:07:26Z","2021-06-15T14:07:29Z"
"","27148","AOP auto-proxying with proxyTargetClass=true and introduction advice does not work for JDK proxy targets","Backport of gh-27044","closed","type: backport,","spring-projects-issues","2021-07-08T17:19:19Z","2021-07-13T17:08:01Z"
"","27004","Improve @Transactional docs regarding method visibility","Backport of gh-27003","closed","type: backport,","spring-projects-issues","2021-05-30T15:16:40Z","2021-05-30T15:16:42Z"
"","27005","Fix @Transactional examples regarding method visibility","Backport of gh-27001","closed","type: backport,","spring-projects-issues","2021-05-30T15:16:40Z","2021-05-30T15:16:42Z"
"","26979","Document transactional semantics for `@TransactionalEventListener` after completion methods","Backport of gh-26974","closed","type: backport,","spring-projects-issues","2021-05-26T12:27:43Z","2021-05-26T12:27:45Z"
"","26948","Deprecate internal APIs in ScriptUtils implementations","Backport of gh-26947","closed","type: backport,","spring-projects-issues","2021-05-16T15:37:00Z","2021-05-18T14:02:55Z"
"","26936","Ignore delimiter enclosed in double quotes in ScriptUtils","Backport of gh-26935","closed","type: backport,","spring-projects-issues","2021-05-12T11:13:43Z","2021-05-12T11:17:40Z"
"","26932","Ensure multipart temp directories do not collide","Backport of gh-26931","closed","type: backport,","spring-projects-issues","2021-05-11T16:05:52Z","2021-05-11T19:39:20Z"
"","26942","Ignore comments when searching for SQL statement delimiter in ScriptUtils","Backport of gh-26911","closed","type: backport,","spring-projects-issues","2021-05-14T09:27:11Z","2021-05-14T12:42:07Z"
"","26898","Incorrect check in AbstractBrokerRegistration's constructor","Backport of gh-26896","closed","type: backport,","spring-projects-issues","2021-05-05T17:30:34Z","2021-05-11T15:47:07Z"
"","26888","`@ModelAttribute(binding=false)` is not honored with WebFlux","Backport of gh-26856","closed","type: backport,","spring-projects-issues","2021-05-03T16:56:50Z","2021-05-03T17:26:00Z"
"","26921","Fix Kotlin filter parameter bug in Router DSLs","Backport of gh-26838","closed","type: backport,","spring-projects-issues","2021-05-10T08:01:18Z","2021-05-15T14:59:51Z"
"","26894","InvalidPathException in log when running SpringBootTest with NIO Path property on Windows","Backport of gh-26828","closed","type: backport,","spring-projects-issues","2021-05-05T11:08:23Z","2021-05-11T15:47:05Z"
"","26907","HtmlUnitRequestBuilder can't cope with empty file input (NPE)","Backport of gh-26799","closed","type: backport,","spring-projects-issues","2021-05-07T14:03:35Z","2021-05-07T14:10:55Z"
"","26923","Fix web parameters resolution when injected via constructor","Backport of gh-25200","closed","type: backport,","spring-projects-issues","2021-05-10T10:11:37Z","2021-05-10T10:56:58Z"
"","27817","ProxyFactoryBean getObject called before setInterceptorNames, silently creating an invalid proxy [SPR-7582]","Backport of gh-12238","closed","type: backport,","jhoeller","2021-12-14T16:23:05Z","2021-12-14T17:24:29Z"
"","27063","Avoid unnecessary Map wrapping in DefaultPathSegment","Avoid creating unnessary wrapper for empty map in DefaultPathSegment","closed","type: enhancement,","Dunemaster","2021-06-15T08:20:19Z","2021-06-15T13:20:44Z"
"","27672","fix atomicity operation","atomicity operation for ""assertBeanFactoryActive"" and ""use BeanFactory""","closed","","shenjianeng","2021-11-11T09:22:01Z","2021-11-23T07:26:54Z"
"","27716","Support SQUARE brackets [] around NAMED parameter","At the moment, if sql statement has a variable in square brackets, then the name of the variable will be incorrect. For example: `SELECT ARRAY[:ext];` We'll get ""**ext]**"" instead of ""**ext**"".  But: `SELECT ARRAY[:ext   ]; --with white space` We'll get ""**ext**"".","closed","type: enhancement,","AntonLGVS","2021-11-22T07:05:05Z","2021-12-20T19:53:41Z"
"","27226","Feature request: synchronous processing of StreamingResponseBody","At the moment usage of `StreamingResponseBody` implies asynchronous processing on background thread.  Often the handler function is essentially synchronous and could easily be executed in request handler without spawning async task and all the implied complexity such as more complex exception and timeout handling as well as wasting extra thread.  While it's possible to simply grab ServletResponse and write to output stream, you're then losing the ability to use nice ResponseEntity API and related classes.  A way to configure Synchronous execution would be useful IMHO.","open","in: web,","mwisnicki","2021-07-29T20:02:22Z","2021-11-10T12:12:15Z"
"","27609","Simplify default locale/timezone resolution in cookie/session locale resolvers","At present, the customization of the default locale and timezone resolution in `CookieLocaleResolver` and `SessionLocaleResolver` requires subclassing them and overriding `determineDefaultLocale` and/or `determineDefaultTimeZone` methods.  This PR simplifies resolution of the default locale and timezone resolution by introducing dedicated functions for these purposes, thus allowing the customization without needing to resort to subclassing the locale resolvers.  Additionally, there are also 2 small commits that improve some aspects of the `LocaleResolver` hierarchy: -  Update `AcceptHeaderLocaleResolver` to extend `AbstractLocaleResolver`: This commit updates AcceptHeaderLocaleResolver to extend AbstractLocaleResolver, which allows the removal of defaultLocale managing code in AcceptHeaderLocaleResolver.  - Update `LocaleContextResolver` to implement `LocaleResolver`: This commit updates `LocaleContextResolver` to implement `LocaleResolver` using default methods, which simplifies `AbstractLocaleContextResolver` and aligns it more closely with `AbstractLocaleResolver`.","closed","type: enhancement,","vpavic","2021-10-25T22:53:20Z","2022-06-03T13:03:57Z"
"","27145","Spring Version 2.4.8 does not support PST Time Zone","At present my application running on spring version 2.4.1 and its supporting my application PST Time Zone. Which is running successfully since long time. Now I have upgraded my application spring version to 2.4.8. & its not supporting my application existing PST Time Zone. I think this is Bug in spring version 2.4.8.","closed","status: invalid,","sunilds-repo","2021-07-08T04:04:00Z","2021-07-12T05:37:19Z"
"","27748","ResolvableType should allow to determine matching type argument for generic return type","Assume a declaration like the following where you need to identify the one method parameter where the generic type matches the return type of the method.  ```java interface SomeRepository { 	 T someMethod1(Class arg0, Class arg1, Class arg2); } ```  ```java Method method = ReflectionUtils.findMethod(SomeRepository.class, ""someMethod1"", Class.class, Class.class, Class.class);  ResolvableType returnType = ResolvableType.forMethodReturnType(method, SomeRepository.class);  ResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, SomeRepository.class); // generic[0]=T ResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, SomeRepository.class); // generic[0]=? ResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, SomeRepository.class); // generic[0]=java.lang.Object  assertThat(returnType.isAssignableFrom(arg0.as(Class.class).getGeneric(0))).isTrue(); assertThat(returnType.isAssignableFrom(arg1.as(Class.class).getGeneric(0))).isFalse(); assertThat(returnType.isAssignableFrom(arg2.as(Class.class).getGeneric(0))).isFalse(); ```","open","type: enhancement,","christophstrobl","2021-11-29T10:05:48Z","2021-12-13T09:07:06Z"
"","27740","Upgrade to ASM 9.3 (for early Java 19 support)","ASM master includes acceptance of Java 19 bytecode in the meantime.","closed","type: dependency-upgrade,","jhoeller","2021-11-27T16:13:27Z","2021-12-03T22:08:57Z"
"","27702","Use InputStream's new methods instead of StreamUtils","As Spring Framework 6 uses JDK17 for its baseline, we can make use of the methods `transferTo(OutputStream out)` and `readAllBytes()` supported by `InputStream` in JDK9 instead of `StreamUtils`.","open","type: task,","yaboong","2021-11-19T08:33:43Z","2021-12-14T12:05:53Z"
"","27618","Use toUnmodifiableSet and toList instead of collectingAndThen","As Spring Framework 6 uses JDK17 for its baseline, we can make use of toList() and toUnmodifiableSet() which introduced in JDK 16 and JDK 10 respectively.","closed","in: core,","yujinchoi-94","2021-10-28T06:33:58Z","2021-10-28T14:50:11Z"
"","27680","Use parseInt without substring method","As Spring Framework 6 uses JDK17 for its baseline, `parseInt` method can be used without using `substring` method. - use `parseInt(CharSequence s, int beginIndex, int endIndex, int radix)` - JDK 9  I think this modification can prevent to create unnecessary string object.","closed","type: enhancement,","KimDoubleB","2021-11-12T06:06:11Z","2021-11-25T15:35:58Z"
"","27646","Use 'toString(Charset)' instead of 'toString(String)' for encodings","As Spring Framework 6 uses JDK17 for its baseline,  we can make use of 'toString(Charset)' which was introduced in JDK 10.","closed","type: enhancement,","SungMinHong","2021-11-06T09:01:11Z","2021-11-10T14:13:10Z"
"","27456","Improve mapping function in ExtendedEntityManagerCreator.createProxy()","As soon as there are up to two items in the resulting array we can populate it explicitly which is faster and memory-saving.","closed","type: enhancement,","stsypanov","2021-09-23T11:52:07Z","2021-10-26T07:18:09Z"
"","27032","HttpComponentsClientHttpConnector should close underlying resources","As seen in https://github.com/spring-projects/spring-boot/issues/26214#issuecomment-856009156, the `HttpComponentsClientHttpConnector` can be instantiated with a custom client instance or create a default one. The connector implementation doesn't provide access to the underlying client nor implements the `Closeable`interface.  We should ensure that the connector can close the resources it's using. This should not be done through the `WebClient` interface since client resources can be shared amongst clients or even with the server.  In the case of the `HttpComponentsClientHttpConnector` in Spring Boot, it is created as a Spring bean and will be considered when components are shut down.","closed","type: enhancement,","bclozel","2021-06-07T15:59:32Z","2021-09-06T13:32:14Z"
"","27413","Upgrade to Kotlin 1.6.10","As seen in #27409, this change also implies switching to a JDK17 baseline for compiling Kotlin code.","closed","type: dependency-upgrade,","bclozel","2021-09-15T10:40:02Z","2021-12-14T14:36:24Z"
"","27007","PartFile name lost when building a MultiPart","As requested here is the new issue @poutsma  My server receive a multipart, take the FilePart from the incoming request and rename it in the outgoing request. Something like that:  ```java   public Mono upload(       @RequestBody Mono parts) {     return someServiceClient.upload(parts.map(m -> (FilePart) m.get(""foo"").get(0));    //here I take the foo part     }    public Mono upload(       Mono partsMono) {     return multipartFile.flatMap(file -> {             MultipartBodyBuilder multipartBodyBuilder = new MultipartBodyBuilder();             multipartBodyBuilder.part(""bar"", file); //here I rename it to bar             return webClient.post()                     .uri(""uri"")                     .header(HttpHeaders.CONTENT_TYPE, MediaType.MULTIPART_FORM_DATA.toString())                     .body(BodyInserters.fromMultipartData(multipartBodyBuilder.build()))         });     } ``` I came across this issue when upgrading my spring version : when I do this, in the outgoing request, the part that I wanted to rename ""bar"" is still named ""foo"". It worked in spring 5.2.8 (it renamed the part) but in 5.3.6 the file is not renamed anymore. I think it's related to this commit e537844 and to the issue #26410    Do you have any advice ? Thanks.","closed","type: regression,","AbdelHedhili","2021-05-31T08:43:39Z","2021-05-31T13:39:51Z"
"","27322","Support optional parameters in stored procedures","As per https://stackoverflow.com/questions/13162043/spring-simplejdbccall-default-optional-arguments there seems to be no straightforward way to call stored procedure with optional parameters.  I would expect there to be something like `SqlDefaultParamaterValue` for explicit binding to default value (in SQL Server this would generate `DEFAULT`). Additionally `SimpleJdbcCall` should do it automatically for missing parameters based on metadata (`COLUMN_DEF`)","open","status: pending-design-work,","mwisnicki","2021-08-24T21:20:39Z","2021-08-26T12:30:14Z"
"","27402","Update GitHub credentials in CI pipeline","As passwords are no longer supported","closed","type: task,","snicoll","2021-09-15T06:39:43Z","2021-09-15T06:41:53Z"
"","27424","Support for Jetty 11","As part of our Jakarta EE 9 revision, we need to support Jetty 11 which turns out to be a significant area of work after our previous adaptive support for Jetty 9/10.","closed","type: dependency-upgrade,","jhoeller","2021-09-16T16:59:45Z","2021-09-17T13:55:27Z"
"","27766","Support OGNL's comma operator in SpEL","As OGNL implements, SpEL should also support the comma operator, which is great for multi-paragraph expressions and for defining variables inside expressions and referencing them.  ```java         String mathEl = ""a=3,b=3,(a+1)*(b-1)"";         Object value2 = Ognl.getValue(mathEl, new HashMap());         System.out.println(value2);          SpelExpressionParser parser = new SpelExpressionParser();         Object value1 = parser.parseExpression(mathEl).getValue();         System.out.println(value1); ```  It works fine in OGNL, but not in SpEL.","open","type: enhancement,","timnick-snow","2021-12-06T03:03:57Z","2022-01-05T15:27:00Z"
"","27343","Convenient configuration of type permissions for XStream 1.4.18","As of XStream 1.4.18, the default type permissions are restricted to well-known core JDK types. Since any custom types will require explicit type permissions now, it seems sensible to provide an explicit `typePermissions` property on Spring's `XStreamMarshaller`, as a convenient alternative to overriding the `customizeXStream` method.  On a related note, we should also translate XStream's `ForbiddenClassException` (which is very commonly raised by XStream 1.4.18 now) to our specific `UnmarshallingFailureException` (instead of our fallback `UncategorizedMappingException`).  Since XStream 1.4.18 is a vulnerability-driven update, we may also expect it to be applied to Spring Framework 5.2.x setups, suggesting a backport of this convenience revision as well (at the expense of raising the minimum XStream version from our historic 1.4.5+ to 1.4.7+ which should be acceptable even for the 5.2.x branch since 1.4.5 dates back to Sep 2013 and 1.4.7 to Feb 2014, just a few months later).","closed","type: enhancement,","jhoeller","2021-08-31T13:45:45Z","2021-09-02T20:23:51Z"
"","27205","Spring Framework Documentation directory disappeared","As mentioned in the title, the directory on the left side of the document still existed not long ago, but now it disappears for some reason. This has a great impact on the reading of the document, and I hope it can be fixed","closed","status: duplicate,","innovationmech","2021-07-23T09:16:57Z","2021-07-23T09:22:08Z"
"","27832","Working POST ajax requests sent by HtmlUnit","As I understood when I analysed the behaviour of a POST request in a classic web application (by a form or an ajax request), the HttpServletRequest object must have both his **content** and **parameters** fields filled.  In HtmlUnitRequestBuilder.java, when converting the webRequest object into the MockHttpServletRequest the **content** field is filled only for an ajax request, and the **parameters** field are filled only for a form request. It seems there's a confusion about the meaning of the term _parameters_.  My correction is intended to have the **parameters** field filled for both the form and the ajax request when using an UI/UX unit test (as it is done when using a classic application).","closed","status: declined,","jcaillabet","2021-12-17T11:44:40Z","2022-02-18T20:05:27Z"
"","27640","Hamcrest-free version of `MockMvcResultMatchers`","As documented in the [wiki](https://github.com/spring-projects/spring-framework/wiki/Code-Style#tests), JUnit5 and AssertJ are required to be used, but `MockMvcResultMatchers` drags in Hamcrest, which is an older assertion library.  There should be an alternative/replacement that doesn't drag in a Hamcrest dependency, especially for projects that made efforts to move away from it.","closed","in: web,","soc","2021-11-04T13:49:28Z","2022-07-05T08:54:27Z"
"","27409","Switch CI pipeline to a JDK17 baseline","As announced on the spring.io blog, [Spring Framework 6.0 will require JDK17 as a baseline](https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6).  As a result, the default build pipeline should use JDK17 (with future variants for JDK18+) and the published artifacts should use the Java 17 language level.  This task should refactor the current CI pipeline to: * only ship 17+ JDKs in the CI container image * consistently use Java 17 language level for compiling main and test sources * for now, Kotlin doesn't officially support Java 17, so we'll move to JDK 11 for now","closed","type: task,","bclozel","2021-09-15T10:18:53Z","2021-09-15T10:41:36Z"
"","27497","Determine why we cannot link to JUnit 5 Javadoc APIs using JDK 17","As a follow up to #27480 (see commit 030ba52805a7c513fa196e97d54543b6e3972cae), we need to determine why we cannot configure external Javadoc links to JUnit 5.  Note that code in the `spring-test` module (e.g., the `SpringExtension` for JUnit Jupiter) links to JUnit 5 APIs.  If we uncomment the following...  https://github.com/spring-projects/spring-framework/blob/167e538dd13535c4b7a7cff171cd7a0ae22c9b81/build.gradle#L347-L352  ... we get the following Javadoc warning which fails the build.  ``` warning: The code being documented uses packages in the unnamed module, but the packages defined in https://junit.org/junit5/docs/5.8.1/api/ are in named modules.  ```  ### Related JDK issues   - https://bugs.openjdk.java.net/browse/JDK-8240169 - https://bugs.openjdk.java.net/browse/JDK-8274639","open","type: documentation,","sbrannen","2021-09-29T15:47:07Z","2022-03-15T13:47:56Z"
"","27670","use Arrays.deepToString for toString in SimpleKey","Arrays.deep* is being used in all the other functions, use it in toString as well - this avoids debugging output that just looks like [Ljava.lang.Object;@123456","open","in: core,","asgh","2021-11-11T01:14:50Z","2021-11-11T09:46:22Z"
"","27669","use Arrays.deepToString for toString in SimpleKey","Arrays.deep* is being used in all the other functions, use it in toString as well - this avoid debugging output that just looks like [Ljava.lang.Object;@123456","closed","","asgh","2021-11-11T01:12:41Z","2021-11-23T07:26:53Z"
"","27090","Parallel graceful shutdown for ThreadPoolTaskExecutor and ThreadPoolTaskScheduler","Applications that need to perform graceful shutdown of tasks submitted to `ThreadPoolTaskExecutor` and/or `ThreadPoolTaskScheduler`, may make use of the setting `awaitTerminationMillis` (and possibly `waitForTasksToCompleteOnShutdown`).  However, application may take a very long time to actually finish if these conditions apply: - application uses both `ThreadPoolTaskExecutor` and `ThreadPoolTaskScheduler` (and possibly multiple `ThreadPoolTaskExecutor`s). - submitted tasks are not quick. - there are `SmartLifecycle` beans which implements lenghty stopping.  Real examples are web applications that use such components and make use of the web container ""graceful shutdown"" feature of Spring Boot. The overall termination sequence of an application is:  1. SIGTERM is sent. 2. `SmartLifecycle` asynchronous stopping triggers the web container graceful shutdown. 3. `SmartLifecycle` asynchronous stopping blocks and waits for the web container shutdown. 4. Context closing proceeds, invoking `DisposableBean`/`@PreDestroy` methods, so, say:     1. `ThreadPoolTaskExecutor`'s `destroy()` is called, blocking and awaiting for the tasks to finish. If the application uses multiple `ThreadPoolTaskExecutor`s, for each one of them an awaiting occurs.     2. `ThreadPoolTaskScheduler`'s `destroy()` is called, blocking and awaiting for the tasks to finish.  The proposal here is to create the possibility to have some form to make all the pools to finish their tasks in parallel. Ideally, in parallel with the stopping of other `SmartLifecycle` beans.  In Kubernetes spring web applications that fits in the scenario above, the total time took by a Pod to finish ends up being too high (which is aggravated due to [the need to configure a preStop hook](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/htmlsingle/#cloud-deployment-kubernetes-container-lifecycle) to give time to kubeproxy to note the pod deletion). This has real effects: as, rigthly, in a rollout Kubernetes does not wait for old Pods to actually finish in order to create new ones, applications with a large number of pods and with a large termination time, end up having a large number of Pods actually running in the rollout (new Pods and many still being terminated). We have seen this triggering a cluster auto scale to make the cluster able to handle this large number of Pods that occur during the rollout.","open","in: core,","jgslima","2021-06-22T02:11:00Z","2022-04-06T19:20:20Z"
"","26901","Remove support for deprecated Java SecurityManager","Anticipating https://openjdk.java.net/jeps/411, we should simply remove all of our optional SecurityManager code paths in the core container.","closed","type: enhancement,","jhoeller","2021-05-06T08:34:07Z","2021-09-15T13:30:44Z"
"","27182","AnnotationBasedPersistentProperty.validateAnnotation NullPointerException on project-specific annotations","AnnotationBasedPersistentProperty.validateAnnotation NullPointerException on project-specific annotations.          org.springframework.data.build         spring-data-parent         2.6.0-SNAPSHOT           I hit this when running the tests of spring-data-couchbase project with JDK11 and adding a java-module.java.   I assume there is some sort of introspection failure.  mergedAnnotation passed into validateAnnotation and the NPE occurs when candidate is dereferenced.  https://github.com/spring-projects/spring-data-commons/blob/db8431ee41b3b73dd87364de9c6cff158790452e/src/main/java/org/springframework/data/mapping/model/AnnotationBasedPersistentProperty.java#L125  It's the .orElse((Object)null) that gets returned.       return !AnnotationFilter.PLAIN.matches(annotationType) && !AnnotationsScanner.hasPlainJavaAnnotationsOnly(element) ? (Annotation)getAnnotations(element).get(annotationType, (Predicate)null, MergedAnnotationSelectors.firstDirectlyDeclared()).synthesize(MergedAnnotation::isPresent).orElse((Object)null) : element.getDeclaredAnnotation(annotationType);","open","status: feedback-provided,","mikereiche","2021-07-15T20:05:04Z","2021-11-11T09:22:57Z"
"","27321","Support for @Indexed on Enums","Annotation @Indexed  does not work in enumerations  **Affects:**  5.2.15-RELEASE  ---   ```java @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Indexed public @interface Dict {  }  @Dict public enum MyDict{   }  ```","closed","status: declined,","zhou-hao","2021-08-24T06:21:16Z","2021-08-24T06:57:39Z"
"","27045","fix: Correct the condition about isEnforceReadOnly","Although isEnforceReadOly is true, Statement might be not READ ONLY if definition.isReadOnly is not true. So I replaced && to || to use the flag as named ""Enforced"".","closed","status: invalid,","nurinamu","2021-06-10T10:16:24Z","2021-06-11T15:29:50Z"
"","27511","add ParameterNamesModule to ""well known"" jackson modules","Also, I'm surprised to see that `org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#findModulesViaServiceLoader` is not `true` by default. Why not always just let it scan the classpath, seems like `findWellKnownModules` does the same but manually.","open","in: web,","Sam-Kruglov","2021-10-02T17:52:29Z","2021-11-10T12:44:57Z"
"","27371","Upgrade to Kotlin 1.5.30","Also upgrades related libraries:  - Coroutines upgraded to 1.5.2  - Serialization upgraded to 1.2.2","closed","type: dependency-upgrade,","sdeleuze","2021-09-08T07:31:41Z","2021-09-08T07:34:21Z"
"","27525","@Scheduled functions failed to fire on Daylight Savings Time switch","All of our cron based @Scheduled functions failed to fire on the 3rd of October 2021 when parts of Australia entered Daylight Savings Time. We are using Spring Boot v2.4.2 and Spring Framework v5.3.3. I do not set the zone in the @Scheduled definition. The default timezone is 'Australia/Sydney' which is as far as I can tell a DST enabled timezone.","closed","status: duplicate,","simonreye-4tel","2021-10-07T01:38:01Z","2022-03-28T14:52:26Z"
"","27876","Referencing a @Bean method in a @Configuration class' @PostConstruct method leads to circular reference","After upgrading to spring-boot 2.6.x, it is no longer possible to access a bean in the `@PostConstruct` method of the `@Configuration` class where it was defined. This did work before (tested with 2.1.x, 2.5.6).  Example code that will result in a `BeanCurrentlyInCreationException`, printing ""Application Failed to start"", with ""The dependencies of some of the beans in the application context form a cycle:""  ```java @Configuration public class AppConf {      @Bean     public String getTestBean() {         return """";     }      @PostConstruct     public void init() {         getTestBean();     }  } ```  You can get a full example at https://github.com/BartRobeyns/boot26ConfigPostConstruct (spring-initializer project with only the `@Configuration` class above added) that fails to build.  Changing the spring-boot version to 2.5.x will allow the application to build and run.  Note that I'm totally fine with this behavior (`@PostConstruct` in a `@Configuration` class seems pretty weird to me), but the documentation of `@PostConstruct` does state that the   > The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform **any** initialization. > This annotation must be supported on **all classes that support dependency injection**.  ... so it's easy to expect the sample above to work. An explicit mention that you shouldn't access `@Bean` methods from the `@Configuration` class itself would clear that up.","open","in: core,","BartRobeyns","2022-01-02T00:11:29Z","2022-03-16T18:27:54Z"
"","27030","Default value of StandaloneMockMvcBuilder.useSuffixPatternMatch differs from the same property in RequestMappingHandlerMapping","After upgrading to spring framework 5.3(5.3.7) the useSuffixPatternMatch default value in RequestMappingHandlerMapping was finally changed to false according to https://github.com/spring-projects/spring-framework/issues/23915#issuecomment-616566606 but the default value of useSuffixPatternMatch in StandaloneMockMvcBuilder is still set to true, forcing test cases to explicitly call the deprecated setUseSuffixPatternMatch method of StandaloneMockMvcBuilder to match the default behavior in RequestMappingHandlerMapping. I was expecting that StandaloneMockMvcBuilder should have the same behavior as RequestMappingHandlerMapping and also like to avoid calling deprecated methods in my code.","closed","type: enhancement,","perlan","2021-06-07T07:19:10Z","2021-06-08T16:41:20Z"
"","27246","BeanUtils.copyProperties() consumes large amount of memory","After upgrade from 5.2.x to 5.3.x, we observed large increase in YoungGC caused by huge amount of object created. After test we found that is because BeanUtils.copyProperties().  In 5.3.x, using ResolvableType to increase fitness but there is no cache which would cause there are many ResolvableType objects created and result in large memory consuming. And there is a comparasion:  ``` TestBean testBean1 = new TestBean(""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8""); TestBean testBean2 = new TestBean(); for (int i = 0; i > -1; i++) {     BeanUtils.copyProperties(testBean1, testBean2);     System.out.println(i); } ```  the VM option is `-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xmx512m`, the program will exit when the memory run out.  For 5.2.x, the last i is: ``` 444489 ``` For 5.3.x, the last i is: ``` 27456 ``` That's a huge memory consuming.","open","in: core,","HashZhang","2021-08-06T02:26:10Z","2022-02-23T01:45:18Z"
"","27739","ForwardedHeaderFilter should allow prepend / replace depending on configuration","After seeing discussion put in #18949,  Let's see the following case  Spring boot BOM version 2.5.6 Spring cloud 2020.0.4  * spring gateway with default locator configuration exposed on http://my-gateway.url * a spring boot application with a `server.servlet.context-path` set to `my-local-context-path` and seen by first application as `app-ui` in its discovery client  The second application uses thymeleaf  `@{/js/script.js}` in the template returned by the handler of `/some-mvc-controller`  When accessing on `http://my-gateway.url/app-ui/my-local-context-path/some-mvc-controller`  * spring cloud gateway calls app-ui application on  `/my-local-context-path/some-mvc-controller` with `X-Forwarded-Prefix` set to `/app-ui` * `ForwardedHeaderFilter` replaces http servlet request context path to `/app-ui`, request uri to  `/app-ui/some-mvc-controller` * Thymeleaf resolves js url to `http://my-gateway.url/app-ui/js/script.js` that ends in `404` error as the correct url should have been `http://my-gateway.url/app-ui/my-local-context-path/js/script.js`  Unless I missed something, I think that it is sad that, using all default behaviour of spring tools (but context-path) is not possible.  I would like to provide a way to let application choose between a policy of `REPLACEMENT` or `PREPEND`. If none, something like setting inner classes of `ForwardedHeaderFilter` as `protected` instead of  `private` in order to let application easily implement its own policy.  Before going directly to a pull request, I prefer discussing whether you're ok with that and which would be the prefered solution  * moving inner classes to `protected` without any other change * allowing to switch between replacement and prepend based on `server.framework-forward-header-policy` valued to `REPLACEMENT` by default","closed","status: declined,","antechrestos","2021-11-27T14:01:57Z","2021-12-02T10:06:32Z"
"","27270","DataSource on JpaTransactionManager appears to be switched mid transaction","After running transactions for several hours we're seeing strange behavior where unbind calls in TransactionSynchronizationManager begin to fail. The root of the failure appears to be the DataSource being switched somehow in the JpaTransactionManager. As the get and set methods in JpaTransactionManager don't have much logging I created a sub class to add additional logging.   [LoggingJpaTransactionManager.txt](https://github.com/spring-projects/spring-framework/files/6978400/LoggingJpaTransactionManager.txt)  From what I see in the log sometime after the getDataSource here org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:423)  And after the transaction synchronization clearing here o.s.t.s.TransactionSynchronizationManager[337] txid=0049cb3e-f76d-4cf8-a41f-4495adc3eddf: Clearing transaction synchronization  The DataSource is switched from  net.ttddyy.dsproxy.support.ProxyDataSource@21280cbb to net.ttddyy.dsproxy.support.ProxyDataSource@7ed8b44  I'm not entirely sure how this is possible given there are no logs for setDataSource  Here is the log file. The events are ordered newest to oldest, sorry about this.  [1628797549_573760_88EF00AB-3D62-4624-A314-1B7E606B9101.txt](https://github.com/spring-projects/spring-framework/files/6978379/1628797549_573760_88EF00AB-3D62-4624-A314-1B7E606B9101.txt)","closed","status: duplicate,","bwilsonPaychex","2021-08-12T20:40:15Z","2021-09-16T18:30:25Z"
"","27444","Retain support for legacy JSR-250 javax.annotation.PostConstruct/PreDestroy and JSR-330 javax.inject.Inject in addition to Jakarta EE 9 annotations","After migration to Jakarta EE 9, it's easy to miss that `javax.annotation.PostConstruct` or `javax.inject.Inject` are no longer working when not covered by a test. This can be an easy-to-make bug when these annotations reside on the classpath after migrating to Jakarta EE 9.   It would be neat to support both annotation variants for at least a grace period or to fail fast when these annotations are in use.","closed","type: enhancement,","mp911de","2021-09-21T09:18:37Z","2021-09-22T05:44:40Z"
"","27570","Advisor adapted by quadratic analysis","After bean initialization, execute abstractautoproxycreator post processor. You will get the advisor adapted to the bean. Here, the [pc.getclassfilter(). Matches (targetclass)] method is executed, including the verification of the method. However, when executing the proxy class method, you get the advisor of the bean and verify it again. Why do you need to check twice?? 😊","open","status: feedback-provided,","baojh123","2021-10-18T08:02:11Z","2021-10-31T11:28:36Z"
"","27221","Cannot use AspectJ's `@Aspect` as a meta-annotation","Affects: All Spring Framework versions  I saw that `@Component` can easily be used in any annotation that is meta-annotated with `@Component`, and this custom annotation can be used with Spring's component scanning.  But I can't use `@Aspect` in the custom composed annotation to annotate a class for AOP, and also the pointcut can't find the annotation in the custom merged annotation .  I provide an example here: https://github.com/zzs007/springaoptest","open","in: core,","zzs007","2021-07-29T03:32:24Z","2021-07-30T16:41:39Z"
"","27803","Behavior of ObjectProvider#getIfAvailable() to return null with scoped bean","Affects: 5.3.x  https://github.com/spring-projects/spring-framework/issues/24822 introduced a logic to return `null` from `ObjectProvider#getIfAvailable()` for scoped beans.  After a couple of tries, I found the scoped bean needs to have `proxyMode=NO` to get this behavior.  For example, this works ```java @Bean @RequestScope(proxyMode = ScopedProxyMode.NO)   // need to set ""proxyMode=NO"" public MyBean myBean() {     return new MyBeanImpl(...); }  @Bean              // run on non request bound thread public CommandLineRunner runner(ObjectProvider myBean) {     return (args) -> {         MyBean bean = myBean.getIfAvailable();  // this returns null         ...     }; } ```  If different `proxyMode` is set on the scoped bean, `getIfAvailable()` returns a proxy, not `null`. (The proxy throws `ScopeNotActiveException` when accessed on a non request bound thread.) Therefore, it has to use `proxyMode=NO` in order to get the `null` from `getIfAvailable()` on scoped beans.  This requirement brings a problem.  If I add this bean definition ```java @Bean String foo(MyBean myBean) {     // do not touch myBean     return ""FOO""; } ```  This fails to inject `MyBean` to the `foo` with `ScopeNotActiveException` because it tries to create a `MyBean` instead of a proxy, but the thread is not bound to the request at application context creation. If the `proxyMode` is not `NO`, then a proxy is injected and the application context successfully created. But I cannot get `null` from `getIfAvailable()` because it returns a proxy.  This means, when I make `proxyMode=NO` to get `null` for `ObjectProvider`, everywhere that uses the scoped bean is required to use the `ObjectProvider`. A simple injection of the scoped bean proxy doesn't work because it doesn't create a proxy.   I am not sure it is an ideal or intended behavior of the original change.   If this is the intended behavior, I think it needs a couple of detailed documentation for this corner case behavior.  For example,  - On `getIfAvailable()` and other methods, document when it returns `null` (scoped beans with `ScopedProxyMode.NO`) - On `@RequestScope` and maybe other scope annotations, document the scoped bean cannot directly inject to the non scoped beans(singleton) when `proxyMode=NO`.  ----  From the user's perspective, more intuitive behavior for the request scoped beans would be:  - No need to specify `proxyMode=NO` - `ObjectProvider#getIfAvailable()` returns `null` for scoped bean in case of `ScopeNotActiveException` - Inject a proxy bean when a scoped bean is directly autowired   ```java @Bean @RequestScope   // does not need to specify ""proxyMode=NO"" public MyBean myBean() {     return new MyBeanImpl(...); }  @Bean public CommandLineRunner runner(ObjectProvider myBean) {     return (args) -> {         MyBean bean = myBean.getIfAvailable();  // returns null since request is not bound         ...     }; }  @Bean String foo(MyBean myBean) {  // proxy should be injected     myBean.hello();     // should throw exception since request is not bound     return ""FOO""; } ```","open","in: core,","ttddyy","2021-12-12T02:50:37Z","2022-01-07T12:40:31Z"
"","27085","Response consist of content-length instead of Transfer-encoding","Affects: 5.3.7   Upgraded spring from 5.2.15 to 5.3.7.  In 5.3.7  While trying to hit an api with Accept-encoding as gzip. I get a response with header Content-length set to a value. The content length is set to original file size and since the output is compressed the output file size is lesser than the original value and so the server will try to download the entire size specified in content-length which the response wont send and the request will be waiting for the content to download till the keep-alive time and then terminates. We are able to get the response but it is causing a latency issue. The response header should have transfer-encoding set to chunked.    In 5.2.15.RELEASE While trying to hit an api with Accept-encoding as gzip. I get a response with  header Transfer-encoding set to ""chunked"" instead of the header content-length. So the output is delivered in chunks and the connection closes rightly.","closed","status: invalid,","venkatsaijanumpally","2021-06-21T08:01:29Z","2022-06-24T06:14:53Z"
"","26944","SimpMessagingTemplate.convertAndSend stops sending messages","Affects: 5.3.6  I'm using spring boot 2.4.5 with RabbitMQ as message broker and io.projectreactor.netty. I got an issue when I use convertAndSend from a scheduled job.  ```java @Scheduled(fixedRate=1000) public void sendServerTime() { 	LocalDateTime dateTime = LocalDateTime.now(); 	DateTimeFormatter dtf = DateTimeFormatter.ofPattern(""dd-MM-yyyy HH:mm:ss""); 	this.template.convertAndSend(Constants.SIMPLE_BROKER_SERVER_TIME, ""{\""servertime\"":\"""" + dateTime.format(dtf) + "" EET\""}""); } ```  The message arrives to the clients and stops after a random time. Thank you for your help","closed","status: duplicate,","jbakog","2021-05-14T14:30:46Z","2021-09-07T15:57:32Z"
"","27844","Adding AsyncConfigurer leads to NullPointerException when Sleuth present","Affects: 5.3.14  When upgrading to spring boot 2.6.2 (so upgrading to spring framework 5.3.14) our application broke. Reproduced the problem in an empty spring boot app.  The error happens when a @Async method is called in a spring boot 2.6.2 project with sleuth present. Either removing sleuth or downgrading to 2.6.1 solves the issue.  This is the error. ``` java.lang.NullPointerException 	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1693) 	at org.springframework.cloud.sleuth.instrument.async.LazyTraceExecutor.wrap(LazyTraceExecutor.java:87) 	at org.springframework.cloud.sleuth.instrument.async.LazyTraceAsyncCustomizer.getAsyncExecutor(LazyTraceAsyncCustomizer.java:50) 	at org.springframework.scheduling.annotation.AbstractAsyncConfiguration.lambda$adapt$1(AbstractAsyncConfiguration.java:91) 	at org.springframework.util.function.SingletonSupplier.get(SingletonSupplier.java:97) 	at org.springframework.aop.interceptor.AsyncExecutionAspectSupport.determineAsyncExecutor(AsyncExecutionAspectSupport.java:172) 	at org.springframework.aop.interceptor.AsyncExecutionInterceptor.invoke(AsyncExecutionInterceptor.java:107) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) 	at com.example.demo.DemoApplication$AsyncBean$$EnhancerBySpringCGLIB$$e660002c.async() 	at com.example.demo.DemoApplicationTests.contextLoads(DemoApplicationTests.java:15) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at jdk.proxy1/jdk.proxy1.$Proxy2.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) 	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71) 	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) 	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) ```  [demo.zip](https://github.com/spring-projects/spring-framework/files/7761921/demo.zip)  It seems related to #27808","closed","for: external-project,","runningonfumes","2021-12-22T10:19:44Z","2022-01-03T13:53:33Z"
"","27491","Aop not support Inheritance","Affects: 5.2.12 Cannot execute Aspect function, I guess org.springframework.aop.support.AopUtils line 242 ``` if (!Proxy.isProxyClass(targetClass)) {             classes.add(ClassUtils.getUserClass(targetClass));         }         classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); ``` This order. Unable to trigger ShadowMatch,when I change the order,The condition cannot be met.  org.springframework.aop.aspectj.AspectJExpressionPointcut line 450 ``` if (targetMethod != originalMethod && (shadowMatch == null || 								(shadowMatch.neverMatches() && Proxy.isProxyClass(targetMethod.getDeclaringClass())))) { ```   ``` public interface ILogController {     @PostMapping     String post(); }  @RestController public class LogController implements ILogController {     @Override     public String post() {         return """";     } }  @Slf4j @Aspect public class PostMappingLogAspect {     @AfterReturning(value = ""@annotation(mapping)"", returning = ""returnValue"")     public void afterReturningTask(JoinPoint point, Object returnValue, PostMapping mapping) {         log.info(""enter"");     }  } ```","open","in: core,","delacroix821026","2021-09-29T06:39:58Z","2021-11-10T09:51:30Z"
"","27492","AOP not support Inheritance","Affects: 5.2.12 Cannot execute Aspect function,  ``` public interface ILogController {     @PostMapping     String post(); }  @RestController public class LogController implements ILogController {     @Override     public String post() {         return """";     } }  @Slf4j @Aspect public class PostMappingLogAspect {     @AfterReturning(value = ""@annotation(mapping)"", returning = ""returnValue"")     public void afterReturningTask(JoinPoint point, Object returnValue, PostMapping mapping) {         log.info(""enter"");     }  } ```  I guess org.springframework.aop.support.AopUtils line 242 ``` if (!Proxy.isProxyClass(targetClass)) {             classes.add(ClassUtils.getUserClass(targetClass));         }         classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); ``` This order. Unable to trigger ShadowMatch,when I change the order,The condition cannot be met.  org.springframework.aop.aspectj.AspectJExpressionPointcut line 450 ``` if (targetMethod != originalMethod && (shadowMatch == null || 								(shadowMatch.neverMatches() && Proxy.isProxyClass(targetMethod.getDeclaringClass())))) { ```","closed","status: duplicate,","delacroix821026","2021-09-29T06:40:53Z","2021-09-29T06:53:57Z"
"","27355","SimpleClientHttpRequestFactory.setBufferRequestBody(false) not works with interceptor of RestTemplate","Affects: Spring: 5.3.9 and early version  Problem: SimpleClientHttpRequestFactory.setBufferRequestBody(false) is not working when RestTemplate has interceptor (i.e. BasicAuthenticationInterceptor), OutOfMemoryError occurs while upload large file using RestTemplate with both SimpleClientHttpRequestFactory.setBufferRequestBody(false) and interceptor. ```java Exception in thread ""main"" java.lang.OutOfMemoryError: Java heap space 	at java.util.Arrays.copyOf(Arrays.java:3236) 	at java.io.ByteArrayOutputStream.grow(ByteArrayOutputStream.java:118) 	at java.io.ByteArrayOutputStream.ensureCapacity(ByteArrayOutputStream.java:93) 	at java.io.ByteArrayOutputStream.write(ByteArrayOutputStream.java:153) 	at org.springframework.util.StreamUtils.copy(StreamUtils.java:167) 	at org.springframework.http.converter.ResourceHttpMessageConverter.writeContent(ResourceHttpMessageConverter.java:137) 	at org.springframework.http.converter.ResourceHttpMessageConverter.writeInternal(ResourceHttpMessageConverter.java:129) 	at org.springframework.http.converter.ResourceHttpMessageConverter.writeInternal(ResourceHttpMessageConverter.java:45) 	at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:227) 	at org.springframework.http.converter.FormHttpMessageConverter.writePart(FormHttpMessageConverter.java:541) 	at org.springframework.http.converter.FormHttpMessageConverter.writeParts(FormHttpMessageConverter.java:517) 	at org.springframework.http.converter.FormHttpMessageConverter.writeMultipart(FormHttpMessageConverter.java:497) 	at org.springframework.http.converter.FormHttpMessageConverter.write(FormHttpMessageConverter.java:369) 	at org.springframework.http.converter.FormHttpMessageConverter.write(FormHttpMessageConverter.java:156) 	at org.springframework.web.client.RestTemplate$HttpEntityRequestCallback.doWithRequest(RestTemplate.java:991) 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:774) 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) 	at org.springframework.web.client.RestTemplate.postForObject(RestTemplate.java:437) 	at com.andy.upload.service.RestTemplateService.uploadLargeFile(RestTemplateService.java:34) 	at com.andy.upload.UploadApplicationTests.restTemplateUploadWithInterceptor(UploadApplicationTests.java:44) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor$$Lambda$115/23211803.apply(Unknown Source) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) ```  Root Cause: RestTemplate using SimpleClientHttpRequestFactory.setBufferRequestBody(false) will create SimpleStreamingClientHttpRequest, which is expected result.  RestTemplate with both SimpleClientHttpRequestFactory.setBufferRequestBody(false) and interceptor will use InterceptingClientHttpRequestFactory to create InterceptingClientHttpRequest which is a sub class of AbstractBufferingClientHttpRequest, in other worlds, SimpleClientHttpRequestFactory.setBufferRequestBody(false) is not working and causing OutOfMemoryError.     Expected Behavior:  SimpleClientHttpRequestFactory.setBufferRequestBody(false) should works with interceptor.    Example Application: https://github.com/AndyLvVip/upload.git You can easily reproduce the described Problem with UTs. All Info about how to run the UTs can be found on the project's readme.","closed","status: duplicate,","AndyLvVip","2021-09-03T03:11:29Z","2021-09-03T08:13:13Z"
"","27196","ResponseStatusException.initCause always throws IllegalStateException","Affected versions: From at least 5.2.1.RELEASE to current master (probably even older versions)  Scenario: We use `ResponseStatusException` to cause Spring to return certain status codes in certain scenarios. When instantiating such Exceptions we can use one of three constructors. Two do not supply a `cause`, the third does. For the two constuctors that do not supply a `cause` the third will be called with `null` as value for `cause`.  This bubbles up to `Throwable` where `cause` will be set to either `null` or the provided value.  When now calling `initCause` on the `ResponseStatusException` the implementation from `Throwable` will be executed. This one will thow an `IllegalStateException` if the member variable `cause` doesn't equal the `Throwable` instance itself. Since we previously established that it can only be `null` of the `Throwable` we initially provided it cause this condition will always evaluate to `false` and thus the `IllegalStateException` will always be thrown.  Code example: ``` Exception someException = new Exception(); ResponseStatusException rse = new ResponseStatusException(HttpStatus.BAD_REQUEST); rse.initCause(someException); throw rse; ```  We know that this can be worked around with calling `new ResponseStatusException(status, null, someException)`, still it is bad that there is a method that will always cause unexpected behavior.","closed","type: enhancement,","Deroin","2021-07-22T09:05:03Z","2021-07-26T09:20:10Z"
"","27719","Passing single null value in varargs SpEL expression results in NullPointerException","Affected Version : 5.3.13  Worked in version : 5.3.6  (5.3.7 -> 5.3.12 not tested)  Using a Spring expression (for caching annotations) started failing for us when moving to Spring 5.3.13 from 5.3.6.  I have created a jUnit Java class test to replicate the issue [SpelEvaluation.zip](https://github.com/spring-projects/spring-framework/files/7582415/SpelEvaluation.zip) .","closed","in: core,","richardnewtonoa","2021-11-22T15:46:40Z","2021-12-10T12:19:21Z"
"","27877","Avoid reassignment of catch block parameters","Addresses #27867","closed","in: core,","alidandach","2022-01-03T12:40:49Z","2022-01-03T17:11:34Z"
"","27331","Add SmallRye Mutiny support to ReactiveAdapterRegistry","Addresses #26222","closed","type: enhancement,","hantsy","2021-08-28T03:21:28Z","2021-09-09T16:01:32Z"
"","26984","Add tests for MessageBodyClientHttpResponseWrapper","Adding two test cases to test the correctness of hasEmptyMessageBody in MessageBodyClientHttpResponseWrapper class, which improves the method coverage.","closed","type: task,","Yin-Jui","2021-05-27T08:42:48Z","2021-09-07T12:27:29Z"
"","27122","Added description for HandlerInterceptor","Added description for HandlerInterceptor  I know that the posthandle is not intended to be executed when an error occurs in the handler . But the docs didn't show that. It says that called after HandlerAdapter actually invoked the handler, but it seems not enough. If this explanation is added, I think it will be a better docs for users.  thank you","closed","type: task,","sangyongchoi","2021-07-02T14:37:36Z","2021-07-13T08:19:57Z"
"","27309","Support `TimeUnit` in the `@Scheduled` annotation","Added an option to use `java.util.concurrent.TimeUnit` with `fixedDelay`, `fixedRate` and `initialDelay` in the `@Scheduled` annotation. Using by default milliseconds as before.","closed","type: enhancement,","Axzial","2021-08-21T16:05:05Z","2021-08-25T18:58:41Z"
"","27514","resolve spring-projects/spring-framework#27432. Added Assert.isFalse …","Added `Assert.isFalse(...)` methods with JavaDoc & Unit Tests.  Resolve spring-projects/spring-framework#27432","open","in: core,","Melancholic","2021-10-03T11:06:29Z","2021-10-03T12:40:41Z"
"","27229","Add support for batch operations (R2DBC)","Add support for batch operations to the [DefaultDatabaseClient](https://github.com/spring-projects/spring-framework/blob/main/spring-r2dbc/src/main/java/org/springframework/r2dbc/core/DefaultDatabaseClient.java):  ```java databaseClient.sql(""INSERT INTO legoset (id, name, manual) VALUES(:id, :name, :manual)"") 				.bind(""id"", 42055) 				.bind(""name"", ""SCHAUFELRADBAGGER"") 				.bindNull(""manual"", Integer.class) 				.add() 				.bind(""id"", 2021) 				.bind(""name"", ""TOM"") 				.bindNull(""manual"", Integer.class) 				.fetch().rowsUpdated() ``` Closes [#259](https://github.com/spring-projects/spring-data-r2dbc/issues/259)  Demo app: [springR2dbcBatchExample.tar.gz](https://github.com/spring-projects/spring-framework/files/6906384/springR2dbcBatchExample.tar.gz)","open","type: enhancement,","MarkMarkyMarkus","2021-07-30T09:17:27Z","2022-05-14T11:21:01Z"
"","26982","Add more test cases for SimpleAliasRegistry","Add more test cases for SimpleAliasRegistry to increase coverage test.","closed","in: core,","nhavuong","2021-05-27T06:19:34Z","2021-06-04T13:35:17Z"
"","27642","fix ColumnMapRowMapper.java #apply Method Result KeyValue Not corresponding","add getColumnValue(Row row, String columnName)  Method change apply(Row row, RowMetadata rowMetadata) code # 60 # 63 # 64   Reason for submission: # code 57 (Collection columns = rowMetadata.getColumnNames();) # method apply(Row row, RowMetadata rowMetadata)   The order of the key is not the same as the order of the value, causing the result to be an error. I sent you an email if you can see it. From admin@maxmc.cn","open","in: data,","016K","2021-11-05T02:57:50Z","2022-01-13T07:30:31Z"
"","27696","Apply ""instanceof pattern matching"" in additional locations","Add Feature Pattern Matching for instanceof","closed","status: feedback-provided,","xixingya","2021-11-18T12:14:12Z","2022-01-03T15:59:03Z"
"","27075","Delegate a call to bean for the RequestMappingHandlerAdapter.getLastModifiedInternal(..) method","Add delegation to the bean for the RequestMappingHandlerAdapter.getLastModifiedInternal(..) method if the bean implements the LastModified interface.","closed","status: declined,","omarchenko4j","2021-06-18T05:32:42Z","2021-07-13T11:15:20Z"
"","27034","Cross reference additional Aware interfaces from BeanFactory Javadoc","Add BeanFactory comment","closed","in: core,","Beca-se","2021-06-08T07:32:41Z","2021-06-08T15:55:21Z"
"","27382","Spring version upgrade to 5.3.7 from 5.3.6 gives issues on activemq ""Could not load xbean ""","ACTIVEMQ_HOME: /opt/na/activemq ACTIVEMQ_BASE: /opt/na/activemq ACTIVEMQ_CONF: /opt/na/activemq/conf ACTIVEMQ_DATA: /opt/na/activemq/data Loading message broker from: xbean:activemq.xml?validate=false ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.io.IOException: Could not load xbean factory:java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext java.lang.RuntimeException: Failed to execute start task. Reason: java.io.IOException: Could not load xbean factory:java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext         at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)         at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)         at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)         at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)         at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.apache.activemq.console.Main.runTaskClass(Main.java:262)         at org.apache.activemq.console.Main.main(Main.java:115) Caused by: java.io.IOException: Could not load xbean factory:java.lang.NoClassDefFoundError: org/springframework/context/ApplicationContext         at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)  Is activemq and spring version compatability mentione somewhere ? Or list of any known issues?","closed","for: external-project,","sagga001","2021-09-10T10:58:51Z","2021-09-10T16:08:53Z"
"","27219","`MockHttpServletResponse.characterEncoding` should not be `@Nullable`","According to the Servlet spec, `getCharacterEncoding()` should never return `null`. Consequently, `MockHttpServletResponse.characterEncoding` should not be `@Nullable`.  Similarly, `MockHttpServletResponse.reset()` should set the `characterEncoding` to `WebUtils.DEFAULT_CHARACTER_ENCODING` instead of `null`.  Ensuring that `characterEncoding` is never `null` will also help to simplify the implementation of several methods in `MockHttpServletResponse` that currently have non-null checks for the `characterEncoding`.","closed","type: bug,","sbrannen","2021-07-28T12:55:08Z","2021-07-29T12:42:47Z"
"","27697","Refactor HttpMethod from enum to class","According to [the HTTP specification](https://datatracker.ietf.org/doc/html/rfc2616#section-5.1.1), the HTTP method is not limited to the well known set (GET, HEAD, PUT, POST, etc.), but can also be an ""extension-method"". Well known extensions include [WebDAV](http://www.webdav.org/specs/rfc4918.html#http.methods.for.distributed.authoring), which added methods like LOCK, COPY, and MOVE.  In Spring Framework, HTTP methods are enumerated in `HttpMethod`. Because this type is an Java `enum`, Spring framework needs several workarounds, to allow for HTTP methods not in the enum, such as having both `HttpRequest::getMethod` as well as `HttpRequest::getMethodValue`.  If we change `HttpMethod` from `enum` to `class`, we no longer need these workarounds. If we make sure that the new `class` has the same methods that `java.lang.Enum` exposes, and given that upgrading to 6.0 requires a recompilation anyway, I believe that now is the time to make this long overdue change.  Note that this issue does *not* include support for non-standard HTTP (i.e. WebDAV) methods in Spring MVC and/or WebFlux.","closed","type: enhancement,","poutsma","2021-11-18T14:42:22Z","2021-12-02T09:07:59Z"
"","27891","Dev dsc note annotation","aadfsa","closed","status: invalid,","pierre2017","2022-01-05T11:01:43Z","2022-01-05T11:30:38Z"
"","27099","SpEL FunctionReference could support MethodHandle","A SpEL `FunctionReference` is currently limited to a **static** `Method` object, limiting what it can do drastically.  Oddly enough, the source code seems to imply that it could reference something else than a static Method, but if I'm not mistaken, there is only one code path, failing early with an exception if the method is not a static method:  https://github.com/spring-projects/spring-framework/blob/a2ef6badc4c76790128910851fdde0df55ec15f9/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java#L73-L77  then later: https://github.com/spring-projects/spring-framework/blob/a2ef6badc4c76790128910851fdde0df55ec15f9/spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java#L105-L108   Anyways, it would be nice if `FunctionReference` could actually reference a `MethodHandle`, thus capturing a receiver (or even more context) that wouldn't have to leak in the signature to the ""function"".  Are there any show stoppers for this? AFAIU, compilation to bytecode is optional, so even that shouldn't be a problem (but maybe it is actually possible). Happy to work on a PR for this if deemed acceptable.","open","in: core,","ericbottard","2021-06-25T11:09:22Z","2021-11-10T10:53:14Z"
"","27913","ResourceHttpRequestHandler with PathPatternParser cannot resolve resources with a jsessionid URL","A simple showcase of this error can be found here: https://github.com/bennypi/thymeleaf-and-springboot  ## Expected behaviour The expected behaviour can be seen when changing the spring boot version to 2.5.6. With this version, the linked css  can be retrieved and the form POST is working.  ## Current behaviour Starting with spring boot version 2.6.0 and still present in 2.6.1, requests with the jsessionid parameter are not processed correctly but lead to errors on the server. A call to a CSS-file with the jsessionid parameter leads to a 404, the form POST request with the jsessionid parameter also leads to a 404. The page starts working again when the page is refreshed in the browser because the browser then sends a cookie with in the request which in turn removes the jsessionid parameter in the links in the HTML.  I am not completely sure if this indeed a bug in spring boot or if thymeleaf must make changes so that it is compatible with spring boot 2.6.0 and newer, but I don't see anything in the release notes that could be a reason for this changed behaviour.","closed","type: bug,","bennypi","2021-12-22T08:21:00Z","2022-02-14T20:52:36Z"
"","27454","ConcurrentReferenceHashMap's entrySet violates the Map contract","A quick sanity test of this map using Guava's testlib found some simple violations. For example `entrySet().iterator()` does not throw an exception for the sequence [hasNext, hasNext, next, remove, remove]. In this case `Iterator.remove()` failed to null out the `last` property after the first call, so a subsequent call does not throw an `IllegalStateException`. As the `keySet` and `values` views delegate to `entrySet`, this error is found multiple times in Guava's suite. You might consider using this suite on other custom collections.   Unit Tests  ```java import java.util.Map;  import org.springframework.util.ConcurrentReferenceHashMap;  import com.google.common.collect.testing.ConcurrentMapTestSuiteBuilder; import com.google.common.collect.testing.TestStringMapGenerator; import com.google.common.collect.testing.features.CollectionFeature; import com.google.common.collect.testing.features.CollectionSize; import com.google.common.collect.testing.features.MapFeature;  import junit.framework.Test; import junit.framework.TestCase;  /** Guava testlib map tests. */ public final class ConcurrentReferenceHashMapTests extends TestCase {    public static Test suite() {     var suite = ConcurrentMapTestSuiteBuilder         .using(new TestStringMapGenerator() {           @Override protected Map create(Map.Entry[] entries) {             var map = new ConcurrentReferenceHashMap();             for (var entry : entries) {               map.put(entry.getKey(), entry.getValue());             }             return map;           }         })         .named(""ConcurrentReferenceHashMap"")         .withFeatures(             MapFeature.GENERAL_PURPOSE,             MapFeature.ALLOWS_ANY_NULL_QUERIES,             CollectionFeature.SUPPORTS_ITERATOR_REMOVE,             CollectionSize.ANY);     return suite.createTestSuite();   } } ```","closed","in: core,","ben-manes","2021-09-23T08:24:59Z","2021-09-24T07:41:01Z"
"","27652","Support for Flux and Flux for @RequestMapping handler methods","A handler method returning `Flux` where `T` is ""something that can render a template"" would be quite useful, especially in the light of the popularity and ease of use of things like the [`@hotwired/turbo`](https://turbo.hotwired.dev/reference/streams) and [htmx.org](https://htmx.org/) JavaScript modules. Those client libraries both have support for ""streams"" of HTML elements coming from the server, which get transcluded into the ""main"" page on the client. Turbo also has support for SSE streams containing HTML data. It would be nice to be able to render in both styles.  Webflux and MVC currently have support for SSE. E.g. with Webflux you can return `Flux` or `Flux` from a handler method, but in both cases you have to render the data yourself. It would be handy  to be able to delegate the rendering to a template engine, so `Rendering` (WebFlux) and `ModelAndView` (MVC) seem like a good fit. Thymeleaf also has some native (if a bit clumsy) support via `ReactiveDataDriverContextVariable`, so there is some prior art there. You could see this feature request as a generalization of that.  Simple example for Turbo on Webflux (for MVC just replace `Rendering` with `ModelAndView`) and SSE:  ```java @GetMapping(path = ""/stream"", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux stream() { 	return Flux.interval(Duration.ofSeconds(2)).map(value -> event(value)); }  private Rendering event(long value) { 	return Rendering.view(""stream"").modelAttribute(""value"", value) 		.modelAttribute(""time"", System.currentTimeMillis()).build(); } ```  with a template (e.g. in mustache but could be thymeleaf etc.):  ```  	 		Index: {{value}} Time: {{time}} 	  ```  The result would be an infinite stream, e.g.:  ``` data:  data: ...   data:  data: ...   ... ```  An example with HTMX and the HTML ""stream"" would be the same controller but with a different `produces` media type:  ```java @GetMapping(path = ""/updates"", produces=""text/vnd.turbo-stream.html"") public Flux stream() { 	return Flux.just(event(""one""), event(""two""); }  private Rendering event(String id) { 	return Rendering.view(""update"").modelAttribute(""id"", id) 		.modelAttribute(""time"", System.currentTimeMillis()).build(); } ```  with a template (e.g. in mustache but could be thymeleaf etc.):  ```  	Time: {{time}}  ```  The result would be a concatenation of the 2 divs:  ```  	Time: 1346876956   	Time: 1346876987  ```","open","in: web,","dsyer","2021-11-08T11:26:56Z","2021-11-16T10:42:29Z"
"","27572","Avoid rollback after a commit failure in `TransactionalOperator`","A failure to commit a reactive transaction will complete the transaction and clean up resources. Executing a rollback at that point is invalid, which causes an `IllegalTransactionStateException` that masks the cause of the commit failure.  This change restructures `TransactionalOperatorImpl` and `ReactiveTransactionSupport` to avoid executing a rollback after a failed commit. While there, the `Mono` transaction handling in `TransactionalOperator` is simplified by moving it to a default method on the interface.  See gh-27523","open","in: data,","EnricSala","2021-10-18T10:32:28Z","2021-11-10T12:11:39Z"
"","27449","Provide accessor on externallyManaged RootBeanDefinition attributes","A `RootBeanDefinition` holds the init and destroy methods that are externally managed but there's no accessor for it.","closed","type: enhancement,","snicoll","2021-09-22T14:58:52Z","2021-09-23T14:13:56Z"
"","27446","Avoid early ConversionService determination in StandardBeanExpressionResolver","A `BeanPostProcessor` definition with property values that need conversion may trigger SpEL resolution (even if no expression is being found) which in turn determines and caches the containing BeanFactory's ConversionService at the time of the first evaluation attempt. Since the BeanFactory's ConversionService can change in a later initialization phase, e.g. when the application context discovers a bean with the name ""conversionService"", we need to revise this towards on-demand access to `ConfigurableBeanFactory.getConversionService()` from `StandardBeanExpressionResolver`.","closed","in: core,","jhoeller","2021-09-21T11:44:12Z","2021-09-21T16:00:40Z"
"","27773","Use of RequestPart with String leads to a file descriptor leak","`StringHttpMessageConvertor` is reading the `InputStream` but it's not closing it. This  keeps the file handle open and leaks file handles. I am using `@RequestPart` in rest controller with string parameter. the request is a multipart form data. Other Jackson converters are closing the streams.  The stream is pointing to a temporary file created by servlet api on tomcat.","closed","type: enhancement,","samudra77","2021-12-06T17:10:30Z","2022-01-12T16:09:13Z"
"","27168","StringHttpMessageConverter shouldn't take over APPLICATION_JSON","`StringHttpMessageConverter.canWrite(String.class, APPLICATION_JSON)` shouldn't return true, It will take over before other actual json converters. https://github.com/spring-projects/spring-framework/blob/708e61a7efbe727f91cc385c8d70a31f2fb0e972/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L901-L965  here is test case: ```java @RestController @RequestMapping(""/echo"") public class EchoController { 	@PostMapping(consumes = { TEXT_PLAIN_VALUE, APPLICATION_JSON_VALUE }, produces = { TEXT_PLAIN_VALUE, 			APPLICATION_JSON_VALUE }) 	public String echo(@RequestBody String string) { 		return ""echo:"" + string; 	} }  @SpringBootTest(webEnvironment = WebEnvironment.MOCK) @AutoConfigureMockMvc class EchoControllerTests { 	@Autowired 	MockMvc mockMvc; 	@Test 	void acceptText() throws Exception { 		mockMvc.perform(post(""/echo"").contentType(TEXT_PLAIN).accept(TEXT_PLAIN).content(""test"")) 				.andExpect(status().isOk()).andExpect(content().string(""echo:test"")); 	} 	@Test 	void acceptJson() throws Exception { 		mockMvc.perform(post(""/echo"").contentType(TEXT_PLAIN).accept(APPLICATION_JSON).content(""test"")) 				.andExpect(status().isOk()).andExpect(content().json(""\""echo:test\""""));  		// test failed, content is echo:test, not converted to valid json ""echo:test"" 	} }  ```","closed","status: invalid,","quaff","2021-07-14T04:51:20Z","2021-07-16T08:45:44Z"
"","27753","Revisit SpringFactoriesLoader vs. ServiceLoader infrastructure","`SpringFactoriesLoader` has been added in Spring Framework 3.2 (see 988f376) as a simple and internal factory loading mechanism. At the time, the 3.x generation had a Java 1.5 baseline and could not require `java.util.ServiceLoader`, introduced in Java 1.6.  Over the years, this mechanism has been used more and more by many Spring projects for loading factories. Its contract has also been extended in #15158 for loading factory names and possibly instantiating them ""manually"" using reflection. Third party projects are also expected to use the same infrastructure if they want to provide their own support (for example, [auto-configurations](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.locating-auto-configuration-candidates)).  With this issue, the Spring Framework team should discuss whether we should reconsider the current situation, given that: 1. Spring Framework 6 will have a Java 17 baseline 2. The Java Platform Module System (JPMS) adds new constraints in this field 3. The AOT engine (currently in Spring Native, to be ported to Spring Framework) requires specific support for that    ## Java 17 baseline  `ServiceLoader` is now mature and has been evolved over the years. The `ServiceLoader::stream()` method (added in Java 9) allows to iterate over the types without instantiating them. With that, we could probably replace `SpringFactoriesLoader`.  ## The Java Platform Module System (JPMS)  Again with Java 9, new mechanisms were added to `ServiceLoader` to help with the newly introduced module system. With the JPMS, modules must declare what they export and what they require; without that, they cannot access classes (reflectively or not) if they're not explicitly required by the module descriptor.  With `ServiceLoader`, any module can declare service implementations. By definition, service clients cannot be aware of all of them and are not in a position to declare them in their module descriptor. [`ServiceLoader`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ServiceLoader.html) has been improved with new methods and its own `provides ... with ...` and `uses ...` keywords in the module descriptor.  `SpringFactoriesLoader` will hit the JPMS limitations and doesn't currently have any mechanism to address it.   ## The Spring AOT engine  Spring Native has implemented an AOT engine that pre-processes application configuration and generates Java source files. It greatly helps the GraalVM native compilation phase by making the application startup more explicit and leaner.  Because [dynamic class loading](https://www.graalvm.org/reference-manual/native-image/Limitations/#dynamic-class-loading) and [reflection](https://www.graalvm.org/reference-manual/native-image/Limitations/#reflection) are well-known limitations with native compilation, Spring Native added a specific processing of Spring Factories at build time. This process is listing all factories and their implementations available at build time, and writes a Java source file that explicitly references them so that the GraalVM native static analysis phase discovers them.  Depending on the choice made here, the AOT engine will need to have a `SpringFactoriesLoader`-specific mechanism or possibly extend the existing `ServiceLoader` support in GraalVM native.","open","theme: aot,","bclozel","2021-11-30T21:28:06Z","2022-06-07T13:43:30Z"
"","27173","Messages arriving out-of-order despite setPreservePublishOrder(true)","`setPreservePublishOrder(true)` doesn't seem to guarantee that the client receives messages in the order of publication. I still need to account for server responses arriving out-of-order on the client side by checking for timestamps.  I noticed this issue while running integration tests for my STOMP over WebSocket and SockJS server where I would have up to 70 `WebSocketStompClient` SockJS clients connect and issue requests in quick succession. Although with a low number of clients `setPreservePublishOrder(true)` does seem to eliminate out-of-order messages, as the number of clients increases, the order is no longer guaranteed and client-side ordering via a response timestamp is needed.  The [documentation](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/messaging/simp/config/MessageBrokerRegistry.html#setPreservePublishOrder-boolean-) makes no mention of possible shortcomings when the server is overloaded, so I'm assuming this behavior should not be happening.  I'm using version 2.4.5.","open","in: web,","osharaki","2021-07-14T19:09:21Z","2021-11-10T11:43:12Z"
"","27710","Document URI template support in Javadoc for RestTemplate","`RestTemplate` does some substitutions on URLs passed to `exchange(...)`.   I just spent an hour trying to understand why my GET request worked with cURL but refused to work with RestTemplate.... It turned out that `RestTemplate` modified the query parameters in my URL.  Could you please document this behavior somewhere? I was not able to find any documentation about the syntax of templates at https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#exchange-org.springframework.http.RequestEntity-java.lang.Class-","closed","status: invalid,","sryze","2021-11-20T13:23:08Z","2021-11-29T16:07:53Z"
"","27268","Bugfix/webflux Fix a support method logic of ServerResponseResultHandler .","`org.springframework.web.reactive.function.server.support.ServerResponseResultHandler.java` can NOT handle `Mono or Flux`.  `public boolean supports(HandlerResult result)` always return false. **because it check a returnValue type of HandlerResult .** need to replace a return type with a generic type of it. see below error code. ``` 	@Override 	public boolean supports(HandlerResult result) { 		return (result.getReturnValue() instanceof ServerResponse); 	} ```  fix like below it has to compare with a generic type of returnType ``` 	@Override 	public boolean supports(HandlerResult result) { 		return ServerResponse.class.isAssignableFrom(result.getReturnType().getGeneric().toClass()); 	}  ```  Related: [https://github.com/spring-projects/spring-framework/issues/27266](url)","closed","status: superseded,","hongjunan","2021-08-12T09:43:55Z","2021-09-14T16:03:35Z"
"","27841","Support for parsing duration in @Scheduled annotation with the same way as with StringToDurationConverter","`org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor` class parses durations from fields _fixedDelayString_, _fixedRateString_ and _initialDelayString_ with it's own conversion method `org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#processScheduled`.  How about to use `org.springframework.boot.convert.StringToDurationConverter` (and other converters) to support `org.springframework.boot.convert.DurationStyle#SIMPLE`? It would be great if I can set initial delay (and also other delays) in my `bootstrap.yaml` with something like `10s`.","closed","in: core,","kaifeur","2021-12-21T14:35:17Z","2022-01-05T14:08:53Z"
"","27223","Fix reference to Optional.isPresent() in ObjectUtils.isEmpty()","`ObjectUtils.isEmpty()` Javadoc mentions `Optional.empty()`, whereas `empty()` returns an empty `Optional` and `Optional.isPresent()` checks if `Optional` indeed is not empty.","closed","in: core,","matvs","2021-07-29T08:18:47Z","2021-07-29T09:03:49Z"
"","27622","CGLIB does not allow packages to start with ""java""","`net.sf.cglib.core.DefaultNamingPolicy`, which is also used by the `SpringNamingPolicy` of the Spring Framework checks explicitly for a `java` prefix.  A problem that might occur here is that someone tries to build a `javabeat.net` Spring example. This would cause a crash during any CGLIB define class due to the prepended dollar sign (`$`).  Wouldn't it therefore make sense to check for `java.` as a prefix instead of `java`?","open","status: feedback-provided,","MuellerMP","2021-10-29T09:33:30Z","2022-03-15T13:45:06Z"
"","27495","Remove MediaType::sortByQualityValue","`MediaType::sortByQualityValue` is not used by Spring Framework itself, nor does it appear to be [used by any Spring projects](https://github.com/search?q=org%3Aspring-projects+sortByQualityValue&type=code). Let's remove the method in 6.0 and deprecate it in 5.3.11.","closed","status: invalid,","poutsma","2021-09-29T10:34:01Z","2021-10-27T13:11:33Z"
"","27431","The existence of org.springframework.util.concurrent.ListenableFuture is confusing.","`ListenableFuture` has been created since Spring 4.0. Although Spring 4.0 supported Java 8, the minimum requirement was Java 6, so the existence of `ListenableFuture` is understandable. However, since 5.0, Spring requires Java 8 as a minimum. Java 8 includes `CompletableFuture` which can replace `ListenableFuture`.  Without knowing this history, it can be confusing why `ListenableFuture` exists. What do you think about removing `ListenableFuture`?","closed","in: core,","ghoonch4","2021-09-17T14:49:09Z","2021-09-23T10:14:45Z"
"","27136","Improve Jetty 10 check in JettyClientHttpResponse","`JettyClientHttpResponse` checks for the presence of `org.eclipse.jetty.websocket.server.JettyWebSocketServerContainer` to determine whether it is running on Jetty 10, but that type is not necessarily present when using just the client libraries, without Jetty server.  We should improve `JettyClientHttpResponse`'s Jetty 10 check.","closed","type: enhancement,","poutsma","2021-07-06T08:58:10Z","2021-07-07T09:16:22Z"
"","27080","ImportSelector#getExclusionFilter does not exclude matching candidates with import selector","`ImportSelector#getExclusionFilter` is a way to let an import selector apply an exclude to classes that are imported. We use this in Spring Boot to filter out classes that are about to be imported and that have conditions we can run statically eagerly and to avoid loading unnecessary classes.  `CacheAutoConfiguration` has an import selector that loads the various configuration candidates. That's handled primarily by the following code:  https://github.com/spring-projects/spring-framework/blob/df588e030f069dd31997ff747839f1d8d5d8d7c7/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L581-L583  The candidates for the import selector are as follows:  ``` 0 = ""org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration"" 1 = ""org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration"" 2 = ""org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration"" 3 = ""org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration"" 4 = ""org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration"" 5 = ""org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration"" 6 = ""org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration"" 7 = ""org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration"" 8 = ""org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration"" 9 = ""org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration"" ```  The exclusion filter is going to match for a number of them. As a result the `importSourceClasses` collection is the following:  ``` 0 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@3426} ""org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration"" 1 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 2 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 3 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 4 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 5 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 6 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 7 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@2464} ""java.lang.Object"" 8 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@3427} ""org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration"" 9 = {org.springframework.context.annotation.ConfigurationClassParser$SourceClass@3428} ""org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration"" ```  Those 7 ""configuration classes"" are then later on processed. It leads ultimately to a `java.lang.Object` bean to be defined.   The reason for this is because of a shortcut when the exclude filter matches:  https://github.com/spring-projects/spring-framework/blob/df588e030f069dd31997ff747839f1d8d5d8d7c7/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L684-L686  Perhaps an improvement would be a way to not contribute the `SourceClass` at all so that it's not processed?","open","in: core,","snicoll","2021-06-18T18:49:59Z","2021-11-10T12:35:34Z"
"","27504","Invoke bean-derived (Auto)Closeable.close() method directly","`DisposableBeanAdapter` historically calls everything other than `DisposableBean.destroy()` via reflection, including a `close()` method derived from the standard `Closeable`/`AutoCloseable` interface. This is partly due to `AutoCloseable` being Java 7+ and therefore only reflectively available on the Spring Framework 4.x baseline, partly also due to such a `close()` invocation being suppressible by the user through specifying an empty destroy method name. While the latter effect is worth preserving, the former can be replaced with a direct invocation after an `AutoCloseable` cast now. In addition to being more efficient on the JVM, this also avoids reflection metadata having to be available in a GraalVM native image just for that purpose.","closed","type: enhancement,","jhoeller","2021-10-01T10:26:59Z","2021-10-01T11:36:30Z"
"","27811","Add default methods to CachingConfigurer","`CachingConfigurerSupport` can be replaced with default methods in the main interface.","closed","type: enhancement,","snicoll","2021-12-14T10:59:58Z","2021-12-14T13:05:39Z"
"","27579","invoke BeanFactoryPostProcessors with explicit order","`BeanFactoryPostProcessor` may implement interface `Ordered` or not ,  for example: `CachingMetadataReaderFactoryPostProcessor`, `ConfigurationWarningsPostProcessor`.   If we want to invoke them by order, we need sorting, otherwise the order is depends on the order of their owner `ApplicationContextInitializer`:  the caller:  ```java 	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { 		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());                 // some code 	} ```  ```java class SharedMetadataReaderFactoryContextInitializer 		implements ApplicationContextInitializer, Ordered { 	@Override 	public void initialize(ConfigurableApplicationContext applicationContext) { 		BeanFactoryPostProcessor postProcessor = new CachingMetadataReaderFactoryPostProcessor(applicationContext); 		applicationContext.addBeanFactoryPostProcessor(postProcessor); 	}  	@Override 	public int getOrder() { 		return 0; 	}  	static class CachingMetadataReaderFactoryPostProcessor 			implements BeanDefinitionRegistryPostProcessor, PriorityOrdered { 		@Override 		public int getOrder() { 			// Must happen before the ConfigurationClassPostProcessor is created 			return Ordered.HIGHEST_PRECEDENCE; 		}         } } ```  ```java public class ConfigurationWarningsApplicationContextInitializer 		implements ApplicationContextInitializer { 	@Override 	public void initialize(ConfigurableApplicationContext context) { 		context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks())); 	}  	protected static final class ConfigurationWarningsPostProcessor 			implements PriorityOrdered, BeanDefinitionRegistryPostProcessor {               		@Override 		public int getOrder() { 			return Ordered.LOWEST_PRECEDENCE - 1; 		} } ```","closed","in: core,","takeaction21","2021-10-19T08:11:15Z","2022-06-08T00:29:38Z"
"","27777","Mention explicitly that @EventListener should be put on public methods","`any method` should rather be `any public method` [in this section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-annotation)","closed","status: invalid,","snicoll","2021-12-07T08:59:29Z","2021-12-09T14:20:30Z"
"","27188","Expand relative URI for RestTemplate if possible","```java RestTemplate template = new RestTemplate(); template.setUriTemplateHandler(new DefaultUriBuilderFactory(""http://localhost:8080"")); template.getForObject(""/users/{id}"", String.class, 1); template.getForObject(""/users/1"", String.class); // following will works as above after this commit template.getForObject(URI.create(""/users/1""), String.class);  template.exchange(RequestEntity.method(HttpMethod.GET, ""/users/{id}"", 1).build(), String.class); template.exchange(RequestEntity.method(HttpMethod.GET, ""/users/1"").build(), String.class); // following will works as above after this commit template.exchange(RequestEntity.method(HttpMethod.GET, URI.create(""/users/1"")).build(), String.class); ``` It will make Spring Boot `TestRestTemplate` much more cleaner, save it from ubiquitous `applyRootUriIfNecessary` https://github.com/spring-projects/spring-boot/blob/05a64ecb2ca237d963866665d3a0e7fd1920fee6/spring-boot-project/spring-boot-test/src/main/java/org/springframework/boot/test/web/client/TestRestTemplate.java#L942-L948","open","in: web,","quaff","2021-07-19T09:08:51Z","2021-11-10T11:55:34Z"
"","26956","why the ""build"" method in the  RestTemplateBuilder use a ""Class"" object as parmeter other than a object of ResteTemplate?","```java public RestTemplate build() {     return this.build(RestTemplate.class); }  public  T build(Class restTemplateClass) {     return this.configure((RestTemplate)BeanUtils.instantiateClass(restTemplateClass)); } ```  I find above code in `RestTemplateBuilder`，and this confused me。  Why use reflection to construct a RestTemplate object ?  What's wrong with doing something like this?  ```java //	public RestTemplate build() { //		return this.build(RestTemplate.class); //	}  public RestTemplate build() {     return this.build(new RestTemplate()); } // Use an object directly as a parameter other than a ""Class"" public  T build(T restTemplate) {     return this.configure(restTemplate); } public  T build(Class restTemplateClass) {     return this.configure(BeanUtils.instantiateClass(restTemplateClass)); }  public  T configure(T restTemplate) {     // .....     return restTemplate; } ```","closed","for: stackoverflow,","daimingzhi","2021-05-19T08:29:04Z","2021-05-19T11:55:14Z"
"","27767","springmvc version 5.3.13 @SessionAttribute has bug !","```java package com.ghy.www.controller;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestAttribute; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.SessionAttribute; import org.springframework.web.bind.annotation.SessionAttributes;  @Controller @SessionAttributes(""b"") public class TestController6 {     @RequestMapping(value = ""test51"")     public String test51(Model model) throws Exception {         System.out.println(""test51"");         model.addAttribute(""a"", ""aa"");         model.addAttribute(""b"", ""bb"");         return ""test52"";     }      @RequestMapping(value = ""test52"")     public String test52(@RequestAttribute(""a"") String a, @RequestAttribute(""b"") String b, @SessionAttribute(value = ""a"") String c, @SessionAttribute(""b"") String d) throws Exception {         System.out.println(""test52"");         System.out.println(""request a="" + a);         System.out.println(""request b="" + b);         System.out.println(""session a="" + c);         System.out.println(""session b="" + d);         return ""test1.jsp"";     } } ```  top code run effect is only console print ： `test51 ` no forward test52  but bottom code run effect is ok: ```java package com.ghy.www.controller;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestAttribute; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.SessionAttribute; import org.springframework.web.bind.annotation.SessionAttributes;  @Controller @SessionAttributes(""b"") public class TestController6 {      @RequestMapping(value = ""test51"")     public String test51(Model model) throws Exception {         System.out.println(""test51"");         model.addAttribute(""a"", ""aa"");         model.addAttribute(""b"", ""bb"");         return ""test52"";     }      @RequestMapping(value = ""test52"")     public String test52(@RequestAttribute(""a"") String a, @RequestAttribute(""b"") String b, @SessionAttribute(value = ""a"", required = false) String c, @SessionAttribute(""b"") String d) throws Exception {         System.out.println(""test52"");         System.out.println(""request a="" + a);         System.out.println(""request b="" + b);         System.out.println(""session a="" + c);         System.out.println(""session b="" + d);         return ""test1.jsp"";     } }  ```","closed","for: stackoverflow,","startjava","2021-12-06T06:30:21Z","2021-12-21T08:50:29Z"
"","27156","Reason of @ResponseStatus on handler method is not resolved by MessageSource","```java @ControllerAdvice public class GlobalExceptionHandler {  	@ExceptionHandler(OptimisticLockingFailureException.class) 	@ResponseStatus(code = CONFLICT, reason = ""optimistic.locking.failure"") 	public void handleConflict() { 	}  } ``` If I move `@ResponseStatus` to Exception, It works fine.  https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletInvocableHandlerMethod.java#L147-L149 should keep consistency with https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/annotation/ResponseStatusExceptionResolver.java#L157-L159","closed","type: enhancement,","quaff","2021-07-12T02:27:06Z","2021-07-13T18:39:34Z"
"","26881","DataClassRowMapper doesn't pass generic field information to type conversion","```DataClassRowMapper``` doesn't pass generic field information to internal TypeConverter: https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-jdbc/src/main/java/org/springframework/jdbc/core/DataClassRowMapper.java#L94  As a result any field like this ```List values``` will be populated with ```String``` values (heap pollution).  This problem can be solved by replacing the code above with something like this: ``` args[i] = tc.convertIfNecessary(     getColumnValue(rs, rs.findColumn(name), type),     type,     MethodParameter.forParameter(mappedConstructor.getParameters()[0])) ```  ```mappedConstructor.getParameters()``` should be extracted as a field for performance reason.","closed","type: enhancement,","belovaf","2021-04-30T00:12:52Z","2021-05-28T15:42:18Z"
"","27361","how to  do it","``` 2021-09-05 12:10:14.025 ERROR 7312 --- [ (self-tuning)'] o.s.b.w.s.s.ErrorPageFilter              : Forwarding to error page from request [/stomp/514/kln2hn0s/websocket] due to exception [org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper$HttpSessionWrapper cannot be cast to weblogic.servlet.security.internal.SessionSecurityData]  java.lang.ClassCastException: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper$HttpSessionWrapper cannot be cast to weblogic.servlet.security.internal.SessionSecurityData         at weblogic.servlet.security.internal.SecurityModule.getCurrentUser(SecurityModule.java:197) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.websocket.tyrus.TyrusServletFilter.doFilter(TyrusServletFilter.java:167) ~[com.oracle.weblogic.websocket.jar:12.2.1.3]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113) ~[spring-web-5.3.3.jar:5.3.3]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:218) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212) ~[spring-security-web-5.4.2.jar:5.4.2]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:115) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:81) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:105) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at com.singlee.symphony.security.authtication.validation.JwtValidationTokenFilter.doFilterInternal(JwtValidationTokenFilter.java:55) ~[sl-symphony-security-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:218) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:218) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) ~[spring-security-web-5.4.2.jar:5.4.2]         at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.3.3.jar:5.3.3]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:141) ~[spring-session-core-2.4.1.jar:2.4.1]         at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:82) ~[spring-session-core-2.4.1.jar:2.4.1]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.boot.web.servlet.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:126) ~[spring-boot-2.4.2.jar:2.4.2]         at org.springframework.boot.web.servlet.support.ErrorPageFilter.access$000(ErrorPageFilter.java:64) ~[spring-boot-2.4.2.jar:2.4.2]         at org.springframework.boot.web.servlet.support.ErrorPageFilter$1.doFilterInternal(ErrorPageFilter.java:101) ~[spring-boot-2.4.2.jar:2.4.2]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.boot.web.servlet.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:119) ~[spring-boot-2.4.2.jar:2.4.2]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.3.jar:5.3.3]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.3.jar:5.3.3]         at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:78) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.wrapRun(WebAppServletContext.java:3701) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3667) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:326) ~[com.oracle.weblogic.security.subject.jar:12.2.1.3]         at weblogic.security.service.SecurityManager.runAsForUserCode(SecurityManager.java:197) ~[com.oracle.weblogic.security.subject.jar:12.2.1.3]         at weblogic.servlet.provider.WlsSecurityProvider.runAsForUserCode(WlsSecurityProvider.java:203) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.provider.WlsSubjectHandle.run(WlsSubjectHandle.java:71) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.WebAppServletContext.doSecuredExecute(WebAppServletContext.java:2443) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2291) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2269) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.ServletRequestImpl.runInternal(ServletRequestImpl.java:1703) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1663) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.servlet.provider.ContainerSupportProviderImpl$WlsRequestExecutor.run(ContainerSupportProviderImpl.java:272) ~[com.oracle.weblogic.servlet.jar:12.2.1.3]         at weblogic.invocation.ComponentInvocationContextManager._runAs(ComponentInvocationContextManager.java:352) ~[com.bea.core.utils.full.jar:12.2.1.3]         at weblogic.invocation.ComponentInvocationContextManager.runAs(ComponentInvocationContextManager.java:337) ~[com.bea.core.utils.full.jar:12.2.1.3]         at weblogic.work.LivePartitionUtility.doRunWorkUnderContext(LivePartitionUtility.java:57) ~[com.oracle.weblogic.work.jar:12.2.1.3]         at weblogic.work.PartitionUtility.runWorkUnderContext(PartitionUtility.java:41) ~[com.bea.core.weblogic.workmanager.jar:12.2.1.3]         at weblogic.work.SelfTuningWorkManagerImpl.runWorkUnderContext(SelfTuningWorkManagerImpl.java:644) ~[com.bea.core.weblogic.workmanager.jar:12.2.1.3]         at weblogic.work.ExecuteThread.execute(ExecuteThread.java:415) ~[com.bea.core.weblogic.workmanager.jar:12.2.1.3]         at weblogic.work.ExecuteThread.run(ExecuteThread.java:355) ~[com.bea.core.weblogic.workmanager.jar:12.2.1.3] ```","closed","for: stackoverflow,","ghj1040110333","2021-09-05T11:31:57Z","2021-09-06T08:55:40Z"
"","27092","SynchronossPartHttpMessageReader should only create temp directory when needed","``` 2021-06-22 11:16:31.394 [reactor-http-epoll-4] ERROR reactor.netty.http.server.HttpServer - [id: 0xc8938d6a, L:/10.202.13.109:8080 - R:/10.202.12.128:35570] java.io.UncheckedIOException: java.nio.file.FileSystemException: /tmp/synchronoss-file-upload-2054205257255420694: No space left on device         at org.springframework.http.codec.multipart.SynchronossPartHttpMessageReader.createTempDirectory(SynchronossPartHttpMessageReader.java:202)         at org.springframework.http.codec.multipart.SynchronossPartHttpMessageReader.(SynchronossPartHttpMessageReader.java:96)         at org.springframework.http.codec.support.ServerDefaultCodecsImpl.extendTypedReaders(ServerDefaultCodecsImpl.java:71)         at org.springframework.http.codec.support.BaseDefaultCodecs.getTypedReaders(BaseDefaultCodecs.java:235)         at org.springframework.http.codec.support.BaseCodecConfigurer.getReaders(BaseCodecConfigurer.java:98)         at org.springframework.http.codec.support.DefaultServerCodecConfigurer.getReaders(DefaultServerCodecConfigurer.java:27)         at org.springframework.web.server.adapter.DefaultServerWebExchange.initFormData(DefaultServerWebExchange.java:143)         at org.springframework.web.server.adapter.DefaultServerWebExchange.(DefaultServerWebExchange.java:131)         at org.springframework.web.server.adapter.HttpWebHandlerAdapter.createExchange(HttpWebHandlerAdapter.java:252)         at org.springframework.web.server.adapter.HttpWebHandlerAdapter.handle(HttpWebHandlerAdapter.java:238)         at org.springframework.boot.web.reactive.context.WebServerManager$DelayedInitializationHttpHandler.handle(WebServerManager.java:97)         at org.springframework.http.server.reactive.ReactorHttpHandlerAdapter.apply(ReactorHttpHandlerAdapter.java:65)         at org.springframework.http.server.reactive.ReactorHttpHandlerAdapter.apply(ReactorHttpHandlerAdapter.java:40)         at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64)         at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:537)         at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:278)         at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:475)         at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:96)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)         at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)         at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:191)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)         at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)         at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)         at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)         at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311)         at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432)         at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)         at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)         at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)         at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)         at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)         at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795)         at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:480)         at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)         at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)         at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)         at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)         at java.lang.Thread.run(Thread.java:745) Caused by: java.nio.file.FileSystemException: /tmp/synchronoss-file-upload-2054205257255420694: No space left on device         at sun.nio.fs.UnixException.translateToIOException(UnixException.java:91)         at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)         at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)         at sun.nio.fs.UnixFileSystemProvider.createDirectory(UnixFileSystemProvider.java:384)         at java.nio.file.Files.createDirectory(Files.java:674)         at java.nio.file.TempFileHelper.create(TempFileHelper.java:136)         at java.nio.file.TempFileHelper.createTempDirectory(TempFileHelper.java:173)         at java.nio.file.Files.createTempDirectory(Files.java:991)         at org.springframework.http.codec.multipart.SynchronossPartHttpMessageReader.createTempDirectory(SynchronossPartHttpMessageReader.java:199)         ... 44 common frames omitted ``` I upgrade springboot version to 2.3.12.RELEASE, SpringCloud: Hoxton.SR11, and met error upside. I found `SynchronossPartHttpMessageReader ` default `private Path fileStorageDirectory = createTempDirectory();` create temp dir, and never delete it. So my disk space if full.  Why `SynchronossPartHttpMessageReader` in spring-web-5.2.15.RELEASE doing so? Is it a bug?","closed","type: enhancement,","yechao4j","2021-06-22T12:10:58Z","2021-06-25T07:48:17Z"
"","27162","@Validated - response validation support","`@Validated` is used to declare that arguments should be validated. It'd be great if there was a simple way to declare that method response should be validated too.  In case of Spring MVC, I'd expect such methods to return 500 Internal error.  With easy response validation it'd be easier to declare method and class invariants and valid state specification.","open","in: web,","lpandzic","2021-07-13T05:55:26Z","2021-11-08T11:57:07Z"
"","27485","Add @Sql equivalent support to R2DBC","`@Sql` annotation is from jdbc package (`org.springframework.test.context.jdbc`). Could you please make it more general (from jdbc & r2dbc perspective) so that one can do like this: ``` @DataR2dbcTest @Sql(""scripts/normalize-sheet.sql"") ``` Right now it gives this exception: ``` ... java.lang.IllegalStateException: Failed to execute SQL scripts for test context [DefaultTestContext@32a13034 testClass ... contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]: supply at least a DataSource or PlatformTransactionManager. ```  At the moment one of the workarounds is manual script execution: https://stackoverflow.com/a/64118434/4456087","open","in: data,","yerzhant","2021-09-24T19:31:52Z","2021-11-10T11:38:12Z"
"","27621","Support @PathVariable, @RequestHeader, etc. as meta annotations","`@PathVariable` (and others) should be useable on annotations (like `@RequestMapping`). With that it would be possible to create custom annotations based on that.   Personally, I would like to combine it with annotations from swagger-core. Normally, a REST method on a controller looks like that: ```kotlin @GetMapping(...) fun get(     @Parameter(description = ""My special id"")     @PathVariable      id: Long ): ResponseEntity { ... } ``` The problem is that every method will need at least two kinds of annotations: The spring annotations for the functionality and the documentation for this functionality. In my opinion, I should be able to combine it: ```kotlin @Parameter @PathVariable @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class DocPathVariable(     @get:AliasFor(annotation = PathVariable::class, attribute = ""name"")     val name: String = """",          @get:AliasFor(annotation = Parameter::class, attribute = ""description"")     val description: String = """", )  // used: @GetMapping(...) fun get(     @DocPathVariable(description = ""My special id"")      id: Long ): ResponseEntity { ... } ``` Same goes for: `@RequestHeader`, `@RequestBody`, `@RequestParam` and probably more.","closed","type: enhancement,","Shryne","2021-10-28T10:53:44Z","2021-11-01T13:53:57Z"
"","27130","Could you migrate @MockBean to Spring Framework?","`@MockBean` is a great tool for the test. It helps me to write a lot of more efficient test code. But my company has some projects which do use Spring Boot. So it can not use `@MockBean`.  Could you migrate @MockBean to Spring Framework?","open","in: test,","diguage","2021-07-05T03:04:09Z","2021-11-12T14:20:16Z"
"","27184","@Cacheable caches empty Optionals but documentation states otherwise","`@Cacheable` javadoc states:  > Note that Java8's Optional return types are automatically handled and its content is stored in the cache if present. (...)  This seems to suggest only present optionals are cached, that's not true. English isn't my first lang, so please forgive if I misunderstood, I guess ""if present"" may refer to the cache.  spring-context v5.3.1","closed","in: core,","mwojterski","2021-07-16T10:33:37Z","2021-07-27T13:07:48Z"
"","27775","Allow @Async qualifier to be declared with a placeholder or SpEL expression","`@Async` value attribute cannot be resolved if it is set to a placeholder, such as `@Async(""${thread-pool.name}"")`.","closed","status: superseded,","LovelyJiuJiu","2021-12-07T02:34:16Z","2022-04-09T04:19:13Z"
"","27637","Add method to ClientResponse that returns Mono terminating with createException","[The method `ClientResponse.createException()` returns the `Mono` type.](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ClientResponse.java#L182) `Mono` feels like `Either`. I think that the `Mono` type is actually needed. So, what if there is the `createError` method that returns the `Mono` type in the `ClientResponse` interface?","closed","status: feedback-provided,","jwChung","2021-11-04T04:51:05Z","2021-12-03T01:06:30Z"
"","27224","Should we parse placeholder in beanName in class PlaceholderConfigurerSupport?","[Related question](https://stackoverflow.com/questions/68564250/is-there-any-way-to-resolve-placeholder-in-beanname)  When I look at code in PlaceholderConfigurerSupport#doProcessProperties, I found there is no logic to parse placeholder in beanName, Is it necessary to add this logic?","open","in: core,","kevinw66","2021-07-29T08:19:11Z","2021-11-11T09:22:57Z"
"","27222","Should we parse placeholder in beanName in class PlaceholderConfigurerSupport?","[Related question](https://stackoverflow.com/questions/68564250/is-there-any-way-to-resolve-placeholder-in-beanname)  When I look at code in PlaceholderConfigurerSupport#doProcessProperties, I found there is no logic to parse placeholder in beanName, Is it necessary to add this logic?","closed","status: duplicate,","kevinw66","2021-07-29T08:18:33Z","2021-07-29T09:10:18Z"
"","27545","How can I send a http2 cleartext request by RestTemplate?","[Now that Spring Boot already supports h2c](https://github.com/spring-projects/spring-boot/issues/25856)，but how can I send a http2 cleartext request by RestTemplate?","closed","for: stackoverflow,","FunnyYish","2021-10-11T08:58:26Z","2021-10-18T09:13:55Z"
"","27041","spring-framework-main-code attribute has not been expanded in docs","@abelsromero spotted that https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux has `{spring-framework-main-code}` attributes that have not been expanded.  >Both web frameworks mirror the names of their source modules ({spring-framework-main-code}/spring-webmvc[spring-webmvc] and {spring-framework-main-code}/spring-webflux[spring-webflux]) and co-exist side by side in the Spring Framework. Each module is optional. Applications can use one or the other module or, in some cases, both — for example, Spring MVC","closed","type: documentation,","philwebb","2021-06-08T23:22:27Z","2021-06-09T07:22:48Z"
"","27442","Update AbstractClassGenerator.java","123","closed","status: invalid,","xiebz","2021-09-20T12:01:30Z","2021-09-20T12:15:01Z"
"","27294","1","1","closed","status: invalid,","mengxiaoZzz","2021-08-19T06:44:39Z","2021-08-19T06:56:48Z"
"","27189","1","1","closed","","whalefall541","2021-07-19T13:42:23Z","2021-07-19T13:42:56Z"
"","27752","Update private methods to be protected in AbstractJackson2Decoder to allow extended classes to access the methods","- Changing the methods getObjectReader, getContextClass, logValue, and processException to protected allows the extended classes of AbstractJackson2Decoder to access the methods  - Avoids duplicating the logic","closed","type: enhancement,","sarathkumar6","2021-11-30T16:48:13Z","2021-11-30T20:34:52Z"
"","27755","Update private methods to be protected","- Changing the methods getObjectReader, getContextClass, logValue, and processException to protected allows the extended classes of AbstractJackson2Decoder to access the methods  - Avoids duplicating the logic","closed","status: duplicate,","sarathkumar6","2021-12-01T14:06:35Z","2021-12-01T16:32:45Z"
"","27220","Clarify that ClientRequest.from(..) also copies body","- Add to javadoc that ```ClientRequest.from(..)``` will also copy body from the given request. - Add test to show that the body inserter will be copied over.","closed","in: web,","AlexejTimonin","2021-07-28T19:13:48Z","2021-08-04T09:33:14Z"
"","27024","Create scala.yml","- [ #27017","closed","status: invalid,","Yodag7354","2021-06-04T22:19:17Z","2021-06-05T07:50:48Z"
"","27465","Spring boot Kafka - Kafka Producer can not get manually close","**Version**: 2.5.1 **Class**: org.springframework.kafka.core.DefaultKafkaProducerFactory$CloseSafeProducer  Kafka producer factory provides a closeable interface to close a Kafka producer (the same can be achieved with the close() method).  ```         try (Producer producer = producerFactory().createProducer()) {             ...             producer.flush();         } ``` However, a bug in the code prevents closing and removing a producer.  The close() method, in normal execution runs the following code (line 734): `this.closed = this.removeProducer.test(this, timeout);` The line of code calls a method to remove the current producer and return a 'success' indication to the closed property However, the removeProducer() contains the following code: ```         if (producerToRemove.closed) {             // remove the producer             return true;         } else {             return false;         } ``` The bug seems to be in the if statement which should have been: `if (!producerToRemove.closed) {`  The existing code will always return false from removeProducer() since from line 734 this.closed is always false","closed","for: external-project,","ofirgrm","2021-09-24T19:11:39Z","2021-09-25T07:17:02Z"
"","27040","Blocking call according to BlockHound in spring-tx","**Summary**: When making some transactional insert/update/delete to database I get a blocking call issue (Tracked by Block Hound) This is related with UUID class because SecureRandom uses /dev/random which has block behaviour.  **Alternative:** Replace SecureRandom by /dev/urandom is not an alternative in my case, can you provide a fix for non blocking thread in this case?  ** Source of the problem**: [this line](https://github.com/spring-projects/spring-framework/blob/000b6a7e9500b81986b21c42b72198aff89fe9ae/spring-tx/src/main/java/org/springframework/transaction/reactive/TransactionContext.java#L43)  **Stack trace**: ```` 		at java.io.FileInputStream.readBytes(FileInputStream.java) ~[?:?] 		at java.io.FileInputStream.read(FileInputStream.java:279) ~[?:?] 		at java.io.FilterInputStream.read(FilterInputStream.java:133) ~[?:?] 		at sun.security.provider.NativePRNG$RandomIO.readFully(NativePRNG.java:424) ~[?:?] 		at sun.security.provider.NativePRNG$RandomIO.ensureBufferValid(NativePRNG.java:526) ~[?:?] 		at sun.security.provider.NativePRNG$RandomIO.implNextBytes(NativePRNG.java:545) ~[?:?] 		at sun.security.provider.NativePRNG.engineNextBytes(NativePRNG.java:220) ~[?:?] 		at java.security.SecureRandom.nextBytes(SecureRandom.java:751) ~[?:?] 		at java.util.UUID.randomUUID(UUID.java:150) ~[?:?] 		at org.springframework.transaction.reactive.TransactionContext.(TransactionContext.java:43) ~[spring-tx-5.3.7.jar:5.3.7] 		at org.springframework.transaction.reactive.TransactionContext.(TransactionContext.java:60) ~[spring-tx-5.3.7.jar:5.3.7] 		at org.springframework.transaction.reactive.TransactionContextHolder.createContext(TransactionContextHolder.java:63) ~[spring-tx-5.3.7.jar:5.3.7] 		at org.springframework.transaction.reactive.TransactionContextManager.lambda$getOrCreateContext$2(TransactionContextManager.java:91) ~[spring-tx-5.3.7.jar:5.3.7] ````  **Version:** org.springframework:spring-tx:5.3.7","closed","status: duplicate,","kurt-jadson","2021-06-08T18:01:43Z","2021-06-08T21:20:49Z"
"","27283","Property Placeholder & SpEL support in @Qualifier","**Situation:** Imagine we have an interface named `Formatter`  ``` public interface Formatter {        public String format(); } ```  We have two implementations  ``` @Component(""foo"") public class FooFormatter implements Formatter {       public String format() {         return ""foo"";     } } ```  ``` @Component(""bar"") public class BarFormatter implements Formatter {       public String format() {         return ""bar"";     } } ```  Now, imaging we have a service that uses this Formatter  ``` @Service public class FormatterService {           @Autowired     private Formatter formatter; } ```   Since, we have multiple implementations available, we need to explicitly specify the implementation by bean name with `@Qualifier`  Like this: ``` @Service public class FormatterService {           @Autowired     @Qualifier(""bar"")     private Formatter formatter; } ```  **Task:** the value of the qualifier is present in `application.yml` as `formatter.type`, and we want to read this value and autowire it accordingly.  **Problem:** `@Qualifier` annotation does not support property placeholder or SpEL  **Proposal:** It would be better if it supports those two.  Because without this, we need to   1. Define a `@Configuration` class 2. Expose a `@Bean` method returning `Formatter` which accepts a @Value(""${placeholder}"")  3. Manually creates a bean depending on the argument passed.   Like this:  ``` @Configuration public class FormatterSpi { 	@Bean 	public Formatter formatter(@Value(""${formatter.type:foo}"") String formatterType) { 		switch(formatterType) { 			case ""foo"": 				return new FooFormatter(); 			case ""bar"": 				return new BarFormatter(); 			default: 				throw new NoSuchBeanDefinitionException(""No bean of type"" + formatterType + "" found!""); 		} 	}  } ```","closed","","SujanKumarMitra","2021-08-16T05:45:49Z","2021-11-23T07:26:47Z"
"","27568","In jdk17, creating a new URL object through the URL of the context will cause a path error (the path of the context is missing)","**jdk information:** openjdk version ""17"" 2021-09-14 OpenJDK Runtime Environment Temurin-17+35 (build 17+35) OpenJDK 64-Bit Server VM Temurin-17+35 (build 17+35, mixed mode, sharing) **spring version:**  spring 5.3.9 spring-boot 2.5.3 **spring-code**:  org/springframework/core/io/UrlResource.java  at line 269 (`return new URL(this.url, relativePath);`） **case**:  404 is returned when accessing the local file system mapping URL。 **solution**：org/springframework/core/io/UrlResource.java  at line 269  （return new URL(this.url.getProtocol(), this.url.getHost(), this.url.getPort(), this.url.getPath() + File.separator + relativePath);）","closed","","stotem","2021-10-18T01:59:29Z","2021-11-23T07:26:51Z"
"","27679","fix :  the same method was cached twice in the ""attributeCache"", changed to once","**in  AbstractFallbackTransactionAttributeSource** ``` public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class targetClass) { 	// ... 	Object cacheKey = getCacheKey(method, targetClass); 	TransactionAttribute cached = this.attributeCache.get(cacheKey); 	if (cached != null) { 		//... 	} 	else { 		// We need to work it out. 		TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass); 		//... 	} }  ``` **When using JDK dynamic proxy：** ``` @Configuration @EnableTransactionManagement(mode = AdviceMode.PROXY ) public class EnableTransactionManagementBean {    //... } ``` **For example：** ``` public interface YqleeService {     void  testMethod(); } ```  ``` @Service public class YqleeServiceImpl implements YqleeService {      @Transactional     @Override     public void testMethod() {         //TODO do something     } } ```  when calling before generating the JDK dynamic proxy, the parameter ""method"" belongs to the implementation class(YqleeServiceImpl )：  ![before](https://user-images.githubusercontent.com/13343630/142340627-2ba44b3a-3339-4ff3-ab26-7cb2f4285064.png)  but, when calling after generating the JDK dynamic proxy, the parameter ""method"" belongs to the interface(YqleeService)：  ![after](https://user-images.githubusercontent.com/13343630/142340759-614084b2-10d0-4f0c-8c28-3e81b5081302.png)  **The method ""getTransactionAttribute""  is called twice, but the ""attributeCache"" does not work very well because the ""cacheKey"" is different.because the parameter ""method"" belongs to a different class.**  ``` // First, see if we have a cached value. Object cacheKey = getCacheKey(method, targetClass); ``` It might be better to change to this：  `Object cacheKey = getCacheKey(AopUtils.getMostSpecificMethod(method,targetClass), targetClass);`  **as same as AbstractFallbackCacheOperationSource**","open","in: data,","androiderLee","2021-11-12T03:54:57Z","2021-11-23T07:32:36Z"
"","27013","Regression: ForwardedHeaderFilter no longer support IPv6","**Affects:**: spring-web 5.3.6  After updating from spring 5.2.8 to 5.3.6 we noticed that ForwardedHeaderFilter would throw: ``` java.lang.IllegalArgumentException: Invalid IPv4 address: 2a02:1810:84ae:d800:c8da:d498:64ec:6edb 	at org.springframework.web.util.UriComponentsBuilder.parseForwardedFor(UriComponentsBuilder.java:363) 	at org.springframework.web.filter.ForwardedHeaderFilter$ForwardedHeaderExtractingRequest.(ForwardedHeaderFilter.java:246) ```  The code before: ``` String baseUrl = this.scheme + ""://"" + this.host + (port == -1 ? """" : "":"" + port);     Supplier delegateRequest = () -> (HttpServletRequest) getRequest();     this.forwardedPrefixExtractor = new ForwardedPrefixExtractor(delegateRequest, baseUrl); ```  The code as is: ``` this.remoteAddress = UriComponentsBuilder.parseForwardedFor(request, request.getRemoteAddress());  String baseUrl = this.scheme + ""://"" + this.host + (port == -1 ? """" : "":"" + port); Supplier delegateRequest = () -> (HttpServletRequest) getRequest(); this.forwardedPrefixExtractor = new ForwardedPrefixExtractor(delegateRequest, baseUrl);```  The invocation of UriComponentsBuilder.parseForwardedFor only support IPv4.","closed","status: feedback-provided,","czubin","2021-06-02T10:12:42Z","2022-02-07T16:19:03Z"
"","27011","Transactions are not rolled back when a publisher is returned with error in a suspend function","**Affects:** v5.3.7  ---  I'm using Kotlin Coroutines to build a Spring Webflux application and recently I got an issue working with suspending functions and Project Reactor.  When I return a publisher with an error in a suspend function the transaction is not rolled back.  e.g. ```kotlin @Transactional suspend fun save(name: String): Flux {   repository.save(Employee(name = name)).awaitSingle()   return Flux.error(RuntimeException()) } ```  But when I change the return type to Flow the transaction is rolled back.  e.g. ```kotlin @Transactional suspend fun save(name: String): Flow {   repository.save(Employee(name = name)).awaitSingle()   return Flux.error(RuntimeException()).asFlow() } ```  Idk if I'm missing something here so please let me know.  I've created a small project with some test cases to reproduce this issue [here](https://github.com/hpedrorodrigues/spring-example).","closed","in: kotlin,","hpedrorodrigues","2021-06-01T14:31:10Z","2022-06-01T12:32:17Z"
"","26892","Ignore trailing slash in CorsConfiguration origin patterns","**Affects:** v5.3.6  --- It's connected to https://github.com/spring-projects/spring-framework/issues/24763 - CorsConfiguration based on pattern matching. While feature itself works really well, I found few corner cases where it's difficult to configure such patterns because of limitations that current pattern syntax provides.  1. Sometimes origin contains a trailing slash. I think `https://*.company.domain` should match both `https://test.company.domain` and `https://test.company.domain/`. One workaround would be to add two different patterns, one with trailing slash and one without. 2. Origins could contain port numbers. Currently it's impossible to support generic port with current syntax. As `https://*.company.domain*` could match `https://test.company.domain:80` as well as `https://test.company.domain.some.other.domain` which is not what intended. Workaround here can be also creating two origins patterns: `https://*.company.domain` and `https://*.company.domain:*`. 3. Would be nice to have possibility to support both `http` and `https` in a single pattern.  While there are workarounds as mentioned before, I think this should be supported out of the box (at least 1 & 2). What's more if you want to support 1 & 2 right now you would effectively either would need to create 4 different patterns or if you know how this is working inside spring you would end up with following pattern in your configuration: `https://*.company.domain\\E\(:\\d+)?/?\\Q`. Which is probably not the best approach either.  I see two possible solutions:  1. When doing pattern matching against request origin remove trailing slash and port from it and do pattern matching just on host or schema+host 2. Extend existing pattern syntax, so that it allows to configure patterns with generic port and optional trailing slash.","closed","type: enhancement,","korektur","2021-05-04T21:43:06Z","2021-05-11T07:33:05Z"
"","27578","Bug - ""Attempted read from closed stream"". After extracting the response body in a custom RestTemplate-ErrorHandler","**Affects:** v.5.3.10  Hi, I am using a ""RestTemplate"" with a custom ""error handler"", which shows detailed messages on HTTP-error, including the response body, extracted from the InputStream provided by **Response.getBody()**. Then I call **RestTemplate.postForEntity()** to post some data to another server.  When I get an HTTP error from the other server, my error-handler is triggered and extracts and shows the response body (which containes some error info). The error is shown, and I do not close the InputStream, nor I use a ""try-with-resources"" block. Then the exception shown in the end of this issue, is thrown. The exception is most likely thrown by [""responseExtractor.extractData(response)""](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L778)  The users should be able to use the response body in their error handlers, without getting an exception later by Spring. Spring should recognize tha case where the user have used the InputStream. By the way, I tried to ""reset"" the InputStream after using it, but it said that it does not support it.  `org.springframework.web.client.ResourceAccessException: I/O error on POST request for ""http://:/api/addWorkerReport"": Attempted read from closed stream.; nested exception is java.io.IOException: Attempted read from closed stream. 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:785) 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) 	at org.springframework.web.client.RestTemplate.postForEntity(RestTemplate.java:468) 	at com.server.example.util.AssignmentHandler.postWorkerReport(AssignmentHandler.java:203) 	at com.server.example.util.AssignmentHandler.handleAssignments(AssignmentHandler.java:190) 	at com.server.example.components.ScheduledTasks.handleNewAssignments(ScheduledTasks.java:29) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:84) 	at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at java.lang.Thread.run(Thread.java:823) Caused by: java.io.IOException: Attempted read from closed stream. 	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:131) 	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:118) 	at java.io.FilterInputStream.read(FilterInputStream.java:83) 	at java.io.PushbackInputStream.read(PushbackInputStream.java:139) 	at org.springframework.web.client.MessageBodyClientHttpResponseWrapper.hasEmptyMessageBody(MessageBodyClientHttpResponseWrapper.java:101) 	at org.springframework.web.client.HttpMessageConverterExtractor.extractData(HttpMessageConverterExtractor.java:90) 	at org.springframework.web.client.RestTemplate$ResponseEntityResponseExtractor.extractData(RestTemplate.java:1037) 	at org.springframework.web.client.RestTemplate$ResponseEntityResponseExtractor.extractData(RestTemplate.java:1020) 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:778) 	... 18 more `","closed","status: declined,","LSmyrnaios","2021-10-18T21:01:56Z","2021-11-19T13:14:07Z"
"","26977","spring-webflux filters don't pass CoroutineContext","**Affects:** spring-webflux 5.3.7  I write my filter, pass some parameters to coroutine context via `witchContext` and want to be able use it later in the child coroutines and handlers. The problem is that `CoroutineContext` is lost in filter chain.  For example something like this  ```kotlin     @Bean     fun testRouter(tracingFilter: ITracingFilter) = coRouter {         GET(""/test"") { request ->             val span = coroutineContext[SpanContext] //  is null             someHandler.processRequest()         }         filter{ serverRequest, suspendFunction ->             withContext(SpanContext()) {                 suspendFunction.invoke(serverRequest)             }         }     } ```","open","in: web,","Ghostleg","2021-05-26T09:46:45Z","2021-11-08T11:37:33Z"
"","27733","spring-web UriComponentsBuilder fails to parse URI where domain starts with a digit","**Affects:** spring-web 5.3.13  --- spring-web `UriComponentsBuilder` cannot parse a URI such as `http://my-host.1domain:1234/path` because the domain starts with a digit:  ```java URI uri = new URI(""http"", ""my-host.1domain:1234"", ""/path"", null, null); System.out.println(uri); // parses correctly  UriComponentsBuilder.fromUriString(""http://my-host.1domain:1234/path"")     .build()     .toUri(); ```  ``` java.lang.IllegalStateException: Could not create URI object: Illegal character in hostname at index 15: http://my-host.1domain:1234/path 	at org.springframework.web.util.HierarchicalUriComponents.toUri(HierarchicalUriComponents.java:521) 	at com.thefloow.ephemeral.Cheese.main(Cheese.java:12) Caused by: java.net.URISyntaxException: Illegal character in hostname at index 15: http://my-host.1domain:1234/path 	at java.base/java.net.URI$Parser.fail(URI.java:2974) 	at java.base/java.net.URI$Parser.parseHostname(URI.java:3517) 	at java.base/java.net.URI$Parser.parseServer(URI.java:3358) 	at java.base/java.net.URI$Parser.parseAuthority(URI.java:3277) 	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219) 	at java.base/java.net.URI$Parser.parse(URI.java:3175) 	at java.base/java.net.URI.(URI.java:708) 	at org.springframework.web.util.HierarchicalUriComponents.toUri(HierarchicalUriComponents.java:517) 	... 1 more ```","closed","status: invalid,","hertzsprung","2021-11-25T09:09:43Z","2021-11-26T15:15:17Z"
"","27644","NPE MockHttpServletResponse.doAddHeaderValue","**Affects:** spring-test:5.3.4  ---  Hi, from time to time i get the following exception (Context: MockMvc of Spring):  ``` java.lang.NullPointerException   at org.springframework.mock.web.MockHttpServletResponse.doAddHeaderValue(MockHttpServletResponse.java:682)   at org.springframework.mock.web.MockHttpServletResponse.setHeaderValue(MockHttpServletResponse.java:627)   at org.springframework.mock.web.MockHttpServletResponse.setHeader(MockHttpServletResponse.java:601) ```  The according source (Spring) looks like:  ```java private void doAddHeaderValue(String name, Object value, boolean replace) {     Assert.notNull(value, ""Header value must not be null"");     HeaderValueHolder header = this.headers.computeIfAbsent(name, key -> new HeaderValueHolder());     if (replace) {         header.setValue(value); // NPE here, line 682     }     else {         header.addValue(value);     } } ```  In debugger, `header` is `null`. It seems impossible at the first glance, the only explanation i have is a race condition, since `this.headers` is  ```java private final Map headers = new LinkedCaseInsensitiveMap(); ```  and `LinkedCaseInsensitiveMap` seems to be not thread safe.  Does anyone experienced similar issues and has a solution for that?  The problem is that i don't see an alternative and this makes our tests less stable","open","in: test,","johampel","2021-11-05T12:45:52Z","2021-11-12T12:30:28Z"
"","27395","JVM Metaspace keeps growing with `@RequestScope`, AOP and `@Validated` because of proxying.","**Affects:** spring-framework >= v5.3.1  ---  **Problem:**   The JVM Metaspace keeps growing with each call to a controller and after a while the JVM crashes. It is linked to the fact that new class definitions are created without being deleted for proxies around controllers.  ---  **How to reproduce:**   The problem occurs when you have a controller :  - `@RequestScope` or `@SessionScope` - `@Validated` - with any kind of aspect around it  Here is a sample Spring Boot app that exhibits the problem :  ```kotlin package com.example.demo  import org.aspectj.lang.ProceedingJoinPoint import org.aspectj.lang.annotation.Around import org.aspectj.lang.annotation.Aspect import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.stereotype.Component import org.springframework.validation.annotation.Validated import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController import org.springframework.web.context.annotation.RequestScope  @SpringBootApplication class DemoApplication  fun main(args: Array) {     runApplication(*args) }  @Component @Aspect class MyCustomAspect {      @Around(""execution(* com.example.demo..*(..)))"")     fun before(proceedingJoinPoint: ProceedingJoinPoint): Any {         println(""before"")         return proceedingJoinPoint.proceed()     } }  @RestController @RequestScope @Validated class Controller {      @GetMapping(""/hey"")     fun greet(): String {         return ""Hey!""     } } ```  If you launch a couple of requests to the endpoint, you can witness that a large number of proxy class definitions are added to the Metaspace.  ```bash for i in (seq 0 50); curl -s localhost:8080/hey >> /dev/null ; end ; jmap -clstats (ps aux |grep java | grep ""demo/out"" | tr -s "" "" | cut -d "" "" -f2)| grep -i demo.controller ``` (this is fish shell, but the bash equivalent should be straightforward, I'm just sending 50 requests, then getting the PID of the Spring app and querying the loaded classes definitions)  Result :   ```bash   392  7953       832        656           0     1464           7       484      1544     1160     2704     3864 com.example.demo.Controller$$FastClassBySpringCGLIB$$fdcabab6  1385  4011        48        936           0     6128          52      2159      9808     6880    11352    18232 com.example.demo.Controller$$EnhancerBySpringCGLIB$$4e4beb4d  2433  7953        16        656           0     6072           7      4248      5312     5440     6800    12240 com.example.demo.Controller$$EnhancerBySpringCGLIB$$4e4beb4d$$FastClassBySpringCGLIB$$4bf361ef  2434  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8$$FastClassBySpringCGLIB$$d8727a09  2435  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_10$$FastClassBySpringCGLIB$$31c8c815  2436  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_11$$FastClassBySpringCGLIB$$31c8c816  2437  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_12$$FastClassBySpringCGLIB$$31c8c817  2438  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_13$$FastClassBySpringCGLIB$$31c8c818  2439  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_14$$FastClassBySpringCGLIB$$31c8c819  2440  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_15$$FastClassBySpringCGLIB$$31c8c81a  2441  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_16$$FastClassBySpringCGLIB$$31c8c81b  2442  7953        16        656           0     5712           7      3962      5016     5104     6480    11584 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_17$$FastClassBySpringCGLIB$$31c8c81c // shortened there are 50 definitions for com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_1$$FastClassBySpringCGLIB$$31c8c81c to com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_50$$FastClassBySpringCGLIB$$31c8c81c  4011    13         0        536         112      520           2         8       368      400     1280     1680 com.example.demo.Controller  4012  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8  4013  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_10  4014  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_11  4015  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_12  4016  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_13  4017  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_14  4018  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_15  4019  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_16  4020  4011         0        904           0     5584          48      1947      9000     6184    10464    16648 com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_17 // shortened there are 50 definitions for com.example.demo.Controller$$EnhancerBySpringCGLIB$$e35965c8_1 to _50 ```  We discovered this problem on a large scale application when we updated Spring from `5.2.15.RELEASE` to `5.3.9`. As I said, the phenomenon causes Metaspace to grow until JVM crashes.  I tried with different versions of Spring and found out that `5.3.0` is OK but there is a problem with `5.3.1`. So my guess is that it is linked to this commit : https://github.com/spring-projects/spring-framework/commit/10bff054a9c60d935be5ec854d71b1af9452b928 and this issue : https://github.com/spring-projects/spring-framework/issues/26019. But I might be wrong, my knowledge on this topic is very limited :)  Here is the build.gradle.kts used for the demo project (`spring boot 2.4.0` -> `spring 5.3.1`) :   ```kotlin import org.jetbrains.kotlin.gradle.tasks.KotlinCompile  plugins {     id(""org.springframework.boot"") version ""2.4.0""     id(""io.spring.dependency-management"") version ""1.0.11.RELEASE""     war     kotlin(""jvm"") version ""1.5.21""     kotlin(""plugin.spring"") version ""1.5.21"" }  group = ""com.example"" version = ""0.0.1-SNAPSHOT"" java.sourceCompatibility = JavaVersion.VERSION_11  repositories {     mavenCentral() }  dependencies {     implementation(""org.springframework.boot:spring-boot-starter-web"")     implementation(""org.springframework.boot:spring-boot-starter-aop"")     implementation(""org.springframework.boot:spring-boot-starter-validation"")      implementation(""com.fasterxml.jackson.module:jackson-module-kotlin"")     implementation(""org.jetbrains.kotlin:kotlin-reflect"")     implementation(""org.jetbrains.kotlin:kotlin-stdlib-jdk8"") }  tasks.withType {     kotlinOptions {         freeCompilerArgs = listOf(""-Xjsr305=strict"")         jvmTarget = ""11""     } }  tasks.withType {     useJUnitPlatform() }  ```  Forcing spring to `5.3.0` fixes the behaviour :  ```kotlin val springVersion = ""5.3.1""  dependencies {     implementation(""org.springframework.boot:spring-boot-starter-web"")     implementation(""org.springframework.boot:spring-boot-starter-aop"")     implementation(""org.springframework.boot:spring-boot-starter-validation"")      implementation(""org.springframework:spring-aop"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-beans"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-context"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-core"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-expression"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-jcl"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-web"") { version { strictly(springVersion) } }     implementation(""org.springframework:spring-webmvc"") { version { strictly(springVersion) } }      implementation(""com.fasterxml.jackson.module:jackson-module-kotlin"")     implementation(""org.jetbrains.kotlin:kotlin-reflect"")     implementation(""org.jetbrains.kotlin:kotlin-stdlib-jdk8"") } ```  Gives the following result :  ```bash ❯ for i in (seq 0 50); curl -s localhost:8080/hey >> /dev/null ; end ;and jmap -clstats (ps aux |grep java | grep ""demo/out"" | tr -s "" "" | cut -d "" "" -f2)| grep -i demo.controller   1370  3895        48        920           0     6064          51      2128      9632     6768    11192    17960 com.example.demo.Controller$$EnhancerBySpringCGLIB$$cd82741  1733  7794        32        656           0     1464           7       484      1544     1160     2704     3864 com.example.demo.Controller$$FastClassBySpringCGLIB$$fdcabab6  2425  7794        16        656           0     5624           7      3883      4944     5024     6400    11424 com.example.demo.Controller$$EnhancerBySpringCGLIB$$943709c4$$FastClassBySpringCGLIB$$2f1c737c  2426  7794        16        656           0     5984           7      4169      5240     5360     6720    12080 com.example.demo.Controller$$EnhancerBySpringCGLIB$$cd82741$$FastClassBySpringCGLIB$$7d56a356  3895    13         0        536         112      520           2         8       368      400     1280     1680 com.example.demo.Controller  3896  3895         0        888           0     5528          47      1916      8824     6080    10304    16384 com.example.demo.Controller$$EnhancerBySpringCGLIB$$943709c4 ```  I also tried removing the aspect, or the `@Validated` on the controller, or the `@RequestScope` and each of these modifications fixes the problem. Unfortunately, it is not so simple on our real life application...  Do not hesitate to ask for more info !  Cheers, Julien","closed","status: duplicate,","legzo","2021-09-13T14:36:55Z","2021-09-14T15:20:18Z"
"","27894","Alternative of FullyQualifiedAnnotationBeanNameGenerator in spring-context","**Affects:** spring-context:4.3.25.RELEASE  Team, I am working on a project which uses external jars as dependencies. All these jars are built on top of spring-core. As, I integrate these jars in my application I am running into `DuplicateBeanException`. Now, I do not have control on these third party libraries. In order to resolve this duplicate bean-name, I thought of using `FullyQualifiedAnnotationBeanNameGenerator.class`. But `FullyQualifiedAnnotationBeanNameGenerator.class` is available from `5.2.3.RELEASE`. My application runs on top of our wrapper framework. This wrapper framework internally brings in all the spring dependencies. And we are running lower version of spring. So, I do-not have access to increase the spring version as well. In this scenario, what is the alternative of `FullyQualifiedAnnotationBeanNameGenerator.class` when my spring-context is `4.3.25.RELEASE` or lower","closed","status: declined,","arnabsarkardhn","2022-01-05T23:35:56Z","2022-01-14T17:14:09Z"
"","26949","org.springframework.security.crypto.password.PasswordEncoder is giving BeanCreationException","**Affects:** Spring-boot: 2.4.5  The exception is provided below  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'springSecurityFilterChain' defined in class path resource [org/springframework/security/config/annotation/web/configuration/WebSecurityConfiguration.class]:  Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException:  Failed to instantiate [javax.servlet.Filter]: Factory method 'springSecurityFilterChain' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException:  Error creating bean with name 'daoAuthenticationProvider' defined in class path resource [com/****/***/security/config/WebSecurityConfig.class]:  Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException:  Failed to instantiate [org.springframework.security.authentication.dao.DaoAuthenticationProvider]:  Factory method 'daoAuthenticationProvider' threw exception; nested exception is java.lang.RuntimeException:  java.security.NoSuchAlgorithmException: Error constructing implementation (algorithm: DRBG, provider: SUN, class: sun.security.provider.DRBG) ```","closed","for: stackoverflow,","mritunjayr","2021-05-17T12:47:16Z","2021-05-17T13:22:13Z"
"","27438","java.time.ZoneRegion - illegal reflective access operation","**Affects:** spring-boot-starter-parent 2.5.4 / spring-core 5.3.9 --- **Java** $ java -version java version ""11.0.12"" 2021-07-20 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.12+8-LTS-237) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.12+8-LTS-237, mixed mode)  **OS** Edition: Windows 10 Pro Version: 21H1 Installed on: ‎2020-‎08-‎13 OS build: 19043.1237 Experience: Windows Feature Experience Pack 120.2212.3530.0 ```` WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:.m2/repository/org/springframework/spring-core/5.3.9/spring-core-5.3.9.jar) to method java.time.ZoneRegion.getId() 	at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:573) 	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:703) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:204) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) 	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) 	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:43) 	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:32) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) 	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) 	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) 	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) 	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) 	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) 	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) 	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleStandaloneElement(ProcessorTemplateHandler.java:918) 	at org.thymeleaf.engine.StandaloneElementTag.beHandled(StandaloneElementTag.java:228) 	at org.thymeleaf.engine.Model.process(Model.java:282) 	at org.thymeleaf.engine.Model.process(Model.java:290) 	at org.thymeleaf.engine.IteratedGatheringModelProcessable.processIterationModel(IteratedGatheringModelProcessable.java:367) 	at org.thymeleaf.engine.IteratedGatheringModelProcessable.process(IteratedGatheringModelProcessable.java:221) 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleStandaloneElement(ProcessorTemplateHandler.java:942) 	at org.thymeleaf.engine.StandaloneElementTag.beHandled(StandaloneElementTag.java:228) 	at org.thymeleaf.engine.Model.process(Model.java:282) 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) 	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) 	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ````","closed","","H-Lo","2021-09-19T14:26:40Z","2021-09-20T10:33:55Z"
"","27242","spring bean对象多次替换时会出bug","**Affects:** spring-beans-5.1.16.RELEASE  我使用的包: spring-beans-5.1.16.RELEASE.jar the bug package: spring-beans-5.1.16.RELEASE.jar  场景: 项目中，我想动态的替换bean对象(也就是可以手动替为我想要的bean), 在使用过程中，第一次第二次替换是正常， 当我在第三次替换是不正常，代码截图如下 ![image](https://user-images.githubusercontent.com/1433479/128193628-6044c6d1-a2ce-4a98-b33a-3a3f4dd55edc.png)  多次访问打印时的日志如下： ![image](https://user-images.githubusercontent.com/1433479/128196428-94e6d467-a47b-481d-ae77-08e3b75f3008.png)   我想要的效果是不管我访问多少次testChangeBean方法， applicationContext.getBean(BeanService.class) 与 beanService 值是相等，但是实际结果，是我在第3次执行访问testChangeBean方法时，他们不相等. beanService 一直保留旧的值。   经过代码调试发现, 调用BeanDefinitionRegistry.registerBeanDefinition(String, BeanDefinition)并没有立即初使化完成。是使用懒加载机制，也就是在下一次访问beanService 属性时会去更新到最新的bean对象; 再执行BeanDefinitionRegistry.registerBeanDefinition(String, BeanDefinition)时，再访问beanService时就不再更新它了，这时beanService就一值保留旧的值。有没有什么好的方法可以改变这种状况  ---","closed","status: invalid,","mobile664042","2021-08-04T14:12:03Z","2021-08-04T15:06:49Z"
"","27516","Extend @RequestMapping to be usable on packages","**Affects:** Spring Web 5.3  ---  If a @RequestMapping annotation is used on a package (in package-info.java), then every controller that is in that package will have a root path given in that annotation.  This could be useful in monolithic projects, that have multiple controllers under similar paths. In this case, the root path of these controllers doesn't have to be spelled out separately for every controller class, but only in their respective packages.","closed","type: enhancement,","rolaca11","2021-10-03T19:40:09Z","2021-10-05T10:27:19Z"
"","26966","UriComponentsBuilder/UriComponents doesn't support encoding of semicolon ';' for query parameters","**Affects:** Spring Web 4.3.9 / 5.2.8  `UriComponentsBuilder/UriComponents` doesn't support encoding of "";"".   For example it might be a value like:  ``` Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36 ```  but "";"" is not encoded:  ```java UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(""http://domain.net/q?param0=aaa"");  // param1 is single-value parameter with a complex value builder.queryParam(""param1"", ""bb;%& b"");  // param2 is multi-value parameter with a complex value builder.queryParam(""param2"", ""cc;%& c""); builder.queryParam(""param2"", ""dd;%& d"");  UriComponents components = builder.build(false).encode();  System.out.println(components.getQuery()); // param0=aaa¶m1=bb;%25%26%20b¶m2=cc;%25%26%20c¶m2=dd;%25%26%20d ```  `org.springframework.web.util.UriUtils#encodeQueryParam` works in the same way.  ```java System.out.println(UriUtils.encodeQueryParam(""bb;%& b"", StandardCharsets.UTF_8)); // bb;%25%26%20b ```  Unfortunately W3 recommends to use "";"" as ""&"" which makes this URL unusable with the big number of web servers.  https://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2.2  > We recommend that HTTP server implementors, and in particular, CGI implementors support the use of "";"" in place of ""&"" to save authors the trouble of escaping ""&"" characters in this manner.  Python can't process such a query string  ``` $ python3 Python 3.6.9 (default, Jan 26 2021, 15:33:00)  [GCC 8.4.0] on linux Type ""help"", ""copyright"", ""credits"" or ""license"" for more information. >>> from urllib.parse import parse_qs >>> parse_qs(""param0=aaa¶m1=bb;%25%26%20b¶m2=cc;%25%26%20c¶m2=dd;%25%26%20d"") {'param0': ['aaa'], 'param1': ['bb'], 'param2': ['cc', 'dd']} ```","open","status: feedback-provided,","mazurkin","2021-05-21T22:41:37Z","2021-10-20T17:54:00Z"
"","27345","Support Kotlin value (JvmInline) classes as `suspend` handler method arguments","**Affects:** Spring Framework 5.3.9, Spring Boot 2.5.4  ---  Using a `@JvmInline value class` as a handler method argument fails with the following:  ``` java.lang.IllegalArgumentException: object is not an instance of declaring class ```  My best guess is this happens because, say with the example below:  ```kotlin @JvmInline value class ProductId(val id: String)  @GetMapping(""/product"") suspend fun getProduct(@RequestParam productId: ProductId) { ... } ```  at runtime the getProduct parameter type when viewed from Java reflection is the wrapped value type (`String`) but when viewed from Kotlin reflection, the parameter is the wrapper value class (`ProductId`). The error is thrown when the function is invoked from kotlin reflection with `String` instance arguments (contributed by the RequestParam resolver) but the kotlin reflection API expects the `ProductId` instance (which it automatically unboxes, [exception is thrown here](https://github.com/JetBrains/kotlin/blob/9ceb477523e7febdb0a64019d8bc3aaf92323c85/core/reflection.jvm/src/kotlin/reflect/jvm/internal/calls/InlineClassAwareCaller.kt#L134))","open","in: kotlin,","efemoney","2021-09-01T00:41:53Z","2022-01-19T10:41:20Z"
"","27116","StackOverflowError when context is closed from a bean.","**Affects:** Spring Framework 5.3.8  ---  Having this configuration: ```java @Configuration public class WindowConfiguration {      @Bean     Closeable closeableContext(ConfigurableApplicationContext context) {         return context;     }      @Bean     Window window(Closeable closeableContext) {         return new Window(closeableContext);     }      static class Window implements DisposableBean, InitializingBean {          private final Closeable closeableContext;          Window(Closeable closeableContext) {             this.closeableContext = closeableContext;         }          public void closeWindow() {             try {                 closeableContext.close();             } catch (IOException ioException) {                 ioException.printStackTrace();             }         }          @Override         public void destroy() throws Exception {             System.out.println(""Window closed"");         }          @Override         public void afterPropertiesSet() throws Exception {             System.out.println(""Window opened"");         }     } } ``` this throws: ```java var context = new AnnotationConfigApplicationContext(WindowConfiguration.class); var window = context.getBean(WindowConfiguration.Window.class); window.closeWindow(); ```  --------------  Looks like the problem is in `DefaultLifecycleProcessor#doStop` when the bean in question is the `ConfigurableApplicationContext` (the `AbstractApplicationContext` implementation) https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java#L247  `AbstractApplicationContext#stop()` will try to stop `DefaultLifecycleProcessor` itself https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java#L1426-L1429   Problem is  `DefaultLifecycleProcessor` doesn't set the flag `running` as false before stoping the beans, and thus creating an infinite loop  (`AbstractApplicationContext#isRunning()` still returns true on next `doStop` pass in `DefaultLifecycleProcessor`) https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java#L116-L119","open","in: core,","criske","2021-07-01T09:51:10Z","2021-11-10T11:58:09Z"
"","27790","Implement UriTemplateRequestEntity::getUrl","**Affects:** Spring Framework 5.3.13  ---  When creating a `RequestEntity` with a template and a parameter list, the resulting URL is not available in the created `RequestEntity` object.  For instance, the following code returns a `RequestEntity` with a null URL attribute: ``` RequestEntity r = RequestEntity.post(""http://www.example.com/{path}"", ""myPath"").body(""""); ``` `r.getUrl()` throws an `UnsupportedOperationException`  When looking at the code in `RequestEntity.body(String)`, I see that the returned object is an `UriTemplateRequestEntity` extending `RequestEntity`, but this object seems to always have a `null` URL according to its constructor. Only the `uriTemplate`, `uriVarsArray` and `uriVarsMap` attributes are set. But these attributes are not part of `RequestEntity`.  So, the URL information is lost in the RequestEntity and to retrieve it, the resulting object must be cast to an `UriTemplateRequestEntity`, which breaks the encapsulation principle.  Shouldn't the `getUrl()` method be overridden in `UriTemplateRequestEntity`?  A similar issue exists [here](https://github.com/spring-projects/spring-framework/issues/26500), but it does not seem to fix the root cause.  I also asked a question about that in [Stackoverflow](https://stackoverflow.com/questions/70288604/how-to-retrieve-the-url-of-a-requestentity-obtained-from-requestentity-poststri) but I guess I only will get workarounds.","closed","type: enhancement,","EricC-59","2021-12-09T15:48:46Z","2021-12-13T13:14:03Z"
"","27538","Performance impact of ResourceUrlEncodingFilter on HttpServletResponse#encodeURL","**Affects:** Spring Framework 5.3.10  ---  Prior discussion: https://gitter.im/spring-projects/spring-boot?at=615ffdb17db1e3753e2ba6f9 Repository showcasing the issue: https://github.com/schosin/ResourceUrlEncodingFilterPerformance  When using `ResourceUrlEncodingFilter` with its default configuration, invocations of HttpServletResponse#encodeURL will be wrapped by `ResourceUrlEncodingResponseWrapper`, which resolves URLs according to a `ResourceUrlProvider`.  With `WebJarAssetLocator` present, this will catch all URLs (/**) and test against five different locations whether the URL passed is a static resource:  [class path resource [META-INF/resources/], class path resource [resources/], class path resource [static/], class path resource [public/], ServletContext resource [/]]  For class path resources, this is done by resolving the path against the resource folder and checking calling `Resource#isReadable`, which ultimately throws a FileNotFoundException if the resource is not present. See `PathResourceResolver#getResource(String, HttpServletRequest, List","closed","type: regression,","schosin","2021-10-09T13:40:08Z","2021-11-10T11:12:32Z"
"","27132","{*path} pattern (CaptureTheRestPathElement) includes undocumented leading slash in @PathVariable path","**Affects:** Spring Framework 5.2.15, 5.3.8  ---  In both Web MVC and WebFlux, `@RequestMapping` via `PathPattern` supports a pattern like `foo/bar/{*restOfThePath}`. WebFlux docs [additionally explain](https://docs.spring.io/spring-framework/docs/5.3.8/reference/html/web-reactive.html#webflux-ann-requestmapping-uri-templates):  > The syntax `{*varName}` declares a URI variable that matches zero or more remaining path segments. For example `/resources/{*path}` matches all files under `/resources/`, and the `""path""` variable captures the complete relative path.  and give a specific example:  > `""/resources/{*file}""` matches `""/resources/images/file.png""` and captures `file=images/file.png`  However, this example is wrong.  In reality, `file` is assigned `/images/file.png`, with a leading slash. The pattern matches other request paths like this:  Request path | Captured `file` -|- `/resources/images/file.png` | `""/images/file.png""` `/resources/images/` | `""/images/""` `/resources/images` | `""/images""` `/resources/` | `""/""` `/resources` | `""""`  **This contradicts documentation** and can only be discovered via testing. Either the documentation should be corrected to match the behaviour, or the behaviour should be adjusted to match the documentation.  **Side note:** this behaviour is somewhat unintuitive given that the pattern `/a/{*b}` appears to require a slash after `a` but in reality makes it optional. In particular, it can be surprising or undesirable that this allows a `/a` match at all. However, other people may find this desirable (and likely treat it as an alias for `/a/`), so it should be sufficient simply to document this behaviour.","closed","type: bug,","astiob","2021-07-05T11:59:53Z","2022-04-01T01:25:05Z"
"","27050","Document that any `@Valid*` annotation triggers validation in the reference manual","**Affects:** Spring Framework 4.1.5   https://github.com/spring-projects/spring-framework/blob/20d9a1e84430830edca6cc58680ba74e40a96ca2/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodArgumentResolver.java#L240  AbstractMessageConverterMethodArgumentResolver#validateIfApplicable  I'm trying to custom an annotation whose name is ""Valid"", but this method makes my custom annotation can not work as I expected.","closed","in: web,","lanicc","2021-06-11T05:07:33Z","2021-06-17T03:52:21Z"
"","26999","ServletRequestDataBinder assumes Standard servlet multipart handling","**Affects:** Spring Framework (spring-web) 5.3.7  ---  In our project we have one controller which needs to handle very large file uploads using a streaming solution similar to [this post](https://www.initialspark.co.uk/blog/articles/java-spring-file-streaming.html).  However, since Spring Framework 5.3 (d61c0ee57d11f563e0cbaf78053eb029d05f296a), the `ServletRequestDataBinder`, when it sees a ""multipart/"" content type which is not handled by a `MultipartResolver` yet it tries to resolve it itself by calling `StandardServletPartUtils.bindParts(...)`, which in turn calls `HttpServletRequest.getParts()` which throws an exception because multipart is not configured on servlet level.  Switching to standard servlet multipart wouldn't help in this case, because that would make the request non-streaming.  I'm not entirely sure what a good solution would be, since as far as I know you can't really ask the servlet whether multipart is configured, and `HttpServletRequest.getParts()` throwing an `IllegalStateException` could also be due to exceeding file limitations. Maybe some addition to the `MultipartResolver` interface, or something in `WebMvcConfigurationSupport` to configure it?  ### Extra context Some extra context, in case it matters: we are using the `CommonsMultipartResolver` because we have many controllers which need to handle normal file uploads. For the very large file upload we use a PUT request instead of POST, because `CommonsMultipartResolver.isMultipart(...)` only returns `true` for POST requests, so it doesn't try to process the multipart request yet in the `DispatcherServlet`.  We use multipart instead of just using the file itself as the body, because we also need to include some other information which might not fit the url query parameters.  The `ServletRequestDataBinder` gets triggered (I think) because we also include a model object as a method parameter which gets filled from url query parameters and gets validated. If you want I can include an example of the controller method.","closed","type: regression,","svschouw-bb","2021-05-28T18:02:12Z","2021-07-12T15:56:45Z"
"","27847","Improve error message in ResolvableType.forClassWithGenerics()","**Affects:** Spring Framework","closed","type: enhancement,","a-locatelli","2021-12-23T09:50:26Z","2022-01-09T16:22:47Z"
"","27304","Empty body in ServerHttpRequest on reactive exception handlers, when using @RequestBody","**Affects:** Spring Boot: 2.5.2  ---  I'm unable to get the request body (for logging), when capturing a global exception using `ErrorWebExceptionHandler`, and using  `@RequestBody`.  ``` java @PostMapping(value = ""/item"") public Mono create(Item item) {     // Unable to read Item, but able to get the request's body     // .... } ```  ``` java @PostMapping(value = ""/item"") public Mono create(@RequestBody Item item) {     // Could read Item, but unable to get the request's body     // .... } ```  Here's my `ErrorWebExceptionHandler` handle method  ``` java @Override public Mono handle(ServerWebExchange serverWebExchange, Throwable throwable) {          var reqBodyBuff = serverWebExchange.getRequest().getBody();         ByteArrayOutputStream baos = new ByteArrayOutputStream();          reqBodyBuff.collectList().subscribe(r -> {             r.forEach(buffer -> {                 try {                       Channels.newChannel(baos).write(buffer.asByteBuffer().asReadOnlyBuffer());                       String bodyStr = new String(baos.toByteArray(), StandardCharsets.UTF_8);                       System.out.println(bodyStr);                 } catch (IOException e) {                       e.printStackTrace();                 } finally {                       try {                            baos.close();                       } catch (IOException e) {                            e.printStackTrace();                       }                 }             });         });          // .......... } ```","closed","for: stackoverflow,","MuizMahdi","2021-08-20T15:41:17Z","2021-09-03T11:00:37Z"
"","27404","Error from CompletableFuture not handled correctly in MockMvc test","**Affects:** Spring Boot 2.5.4 / Spring Framework 5.3.9  I recently ran into an issue testing an endpoint of an application using CompletableFutures as a return type. I reproduced it using a minimal application based on the demo project from the Spring Boot Initializer which consists of these two classes:  ```java @SpringBootApplication public class DemoApplication { 	public static void main(String[] args) { 		SpringApplication.run(DemoApplication.class, args); 	} } ```  ```java @RestController public class TestController {     @GetMapping(""/test"")     CompletableFuture test() {         return CompletableFuture.failedFuture(new RuntimeException(""Error""));     } } ```  If I start the application and make a GET call to the endpoint, I receive an internal server error as I would expect:  ``` $ curl -i http://localhost:8080/test                                                                                                                                                HTTP/1.1 500                                                                                                                                                                                                       Content-Type: application/json                                                                                                                                                                                     Transfer-Encoding: chunked                                                                                                                                                                                         Date: Wed, 15 Sep 2021 07:15:37 GMT                                                                                                                                                                                Connection: close  {""timestamp"":""2021-09-15T07:15:37.497+00:00"",""status"":500,""error"":""Internal Server Error"",""path"":""/test""} ```  Then I wrote a simple WebMvcTest to verify the behaviour:  ```java @AutoConfigureMockMvc @WebMvcTest(controllers = TestController.class) class TestControllerTest {     @Autowired     private MockMvc mockMvc;      @Test     void test() throws Exception {         mockMvc           .perform(MockMvcRequestBuilders.get(""/test""))           .andDo(MockMvcResultHandlers.print())           .andExpect(status().isInternalServerError());     } } ```  I would expect the test to pass since the exception thrown in the CompletableFuture should lead to an internal server error there as well, however the result is:  ``` MockHttpServletRequest:       HTTP Method = GET       Request URI = /test        Parameters = {}           Headers = []              Body = null     Session Attrs = {}  Handler:              Type = com.example.demo.TestController            Method = com.example.demo.TestController#test()  Async:     Async started = true      Async result = java.lang.RuntimeException: Error  Resolved Exception:              Type = null  ModelAndView:         View name = null              View = null             Model = null  FlashMap:        Attributes = null  MockHttpServletResponse:            Status = 200     Error message = null           Headers = []      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = []  MockHttpServletRequest:       HTTP Method = GET       Request URI = /test        Parameters = {}           Headers = []              Body = null     Session Attrs = {}  Handler:              Type = com.example.demo.TestController            Method = com.example.demo.TestController#test()  Async:     Async started = true      Async result = java.lang.RuntimeException: Error  Resolved Exception:              Type = null  ModelAndView:         View name = null              View = null             Model = null  FlashMap:        Attributes = null  MockHttpServletResponse:            Status = 200     Error message = null           Headers = []      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = []  java.lang.AssertionError: Status expected: but was: Expected :500 Actual   :200 ```  So the http response is OK thought the controller returns a failed CompletableFuture.","closed","status: invalid,","hoshpak-next","2021-09-15T07:27:13Z","2021-10-29T09:45:12Z"
"","27112","ClassNotFoundException using Jetty 10 and its reactive client","**Affects:** Spring Boot 2.5.2, Spring Framework 5.3.8, Jetty 10.0.5 and Jetty Reactive Client 2.0.3  I tried to use Jetty 10 together with latest Spring Boot/Framework. Unfortunately i run into a ClassNotFoundException in the method org.springframework.http.client.reactive.JettyClientHttpRequest.writeWith because in Jetty Reactive Client 2 the class PublisherContentProvider which is instantiated there does not exist anymore. Most probably now the new class PublisherRequestContent which is quite similar should be used","closed","type: enhancement,","urferr","2021-06-30T15:00:49Z","2021-07-06T09:05:49Z"
"","27358","Spring WebTestClient can't parse body of parameterized type List","**Affects:** Spring Boot 2.5.2  I'm using Spring WebFlux (with Annotations) and have, among other similar (working) controllers:  ``` @Override     public Flux syncAccounts(             @RequestBody List operations,             @PathVariable Instant from,             @AuthenticationPrincipal             Jwt jwt,             ServerWebExchange exchange) {         log.info(""OPERATIONS_AFTER: "" + operations);         return commandHandler                 .syncAccounts(                         new SyncAccountCommand(                                 operations,                                 from,                                 JwtParser.getUsername(jwt),                                 JwtParser.getRoles(jwt),                                 localeService.getLocale(exchange))                 );     } ```  And a test using WebTestClient:  ``` @Test     @DisplayName(""GIVEN /sync/from/{from} endpoint, ""                + ""WHEN post request is made with multiple operations to process in bulk, ""                + ""THEN a flux is returned with synced (including new) records"")     void testSync() {         List operations = AccountFactory                 .createMultipleDomainOperations(10);         log.info(""OPERATIONS_BEFORE: "" + operations);         ParameterizedTypeReference typeRef =                 new ParameterizedTypeReference() {};         webClient.post()                 .uri(""/account/accounts/sync/from/2021-01-01T00:00:01.000000Z"")                 .contentType(MediaType.APPLICATION_JSON)                 .accept(MediaType.APPLICATION_JSON)                 .body(Mono.just(operations), typeRef)                 .header(HttpHeaders.AUTHORIZATION, ""Bearer token"")                 .header(HttpHeaders.ACCEPT_LANGUAGE, Locale.forLanguageTag(""pt-PT"").toString())                 .exchange()                 .expectStatus().isEqualTo(200)                 .expectBody()                 .jsonPath(""$.length()"").isEqualTo(10)                 .jsonPath(""$[0].operation"").isNotEmpty()                 .jsonPath(""$[0].response"").isNotEmpty()                 .jsonPath(""$[0].exception"").isEmpty()                 .jsonPath(""$[0].response.statusCode"").isEqualTo(201)                 .jsonPath(""$[0].response.resourceObject"").isNotEmpty()                 .jsonPath(""$[0].response.resourceObject.name"").isEqualTo(""Account 1"")         ;     } ```  The difference with other controllers resides in the body. In this case, it's a list with a parameterized type: `List`.  WebTestClient seems to extract the body to JSON but it won't convert it to the target POJO. I suspect it's because it's a nested parameterized type, not just `List` but `List`.  Logs from WebTestClient, including body content sent, before failing to convert it to the target POJOs:  ``` 2021-09-04 14:18:55.789 ERROR 55396 --- [           main] o.s.t.w.reactive.server.ExchangeResult   : Request details for assertion failure:  > POST /account/accounts/sync/from/2021-01-01T00:00:01.000000Z > WebTestClient-Request-Id: [1] > Content-Type: [application/json] > Accept: [application/json] > Authorization: [Bearer token] > Accept-Language: [pt_PT] > Content-Length: [6862]  //---> WHAT WAS SENT [{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""66e97b4a-3205-44b4-8c37-6d4e7417a224"",""partyId"":""208410e5-e57e-43f7-b3e3-4fedcb95f4d8"",""recordType"":""account"",""nature"":""account"",""name"":""Account 1"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""0e4eb854-f6d2-4981-b8b7-cede7c590d4d"",""partyId"":""efee517c-9577-4aa9-ac2a-0f577a839621"",""recordType"":""account"",""nature"":""account"",""name"":""Account 2"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""85fcb614-dd59-4a28-8a2e-ec1ed855fb20"",""partyId"":""a2cbc6d8-e6e2-403d-b0ba-9399ac3a0bda"",""recordType"":""account"",""nature"":""account"",""name"":""Account 3"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""860c1492-f40b-4b70-a7db-f4ed8f0fe0d9"",""partyId"":""590e9c15-eed2-4e0f-b573-84a8140bcb7b"",""recordType"":""account"",""nature"":""account"",""name"":""Account 4"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""dbdc9965-afdd-451a-a12b-fb7ed4186179"",""partyId"":""7d9acffb-f8bf-4031-9007-fdf08108aca6"",""recordType"":""account"",""nature"":""account"",""name"":""Account 5"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""ff23d673-a6c5-4c76-92e6-8ff750b46669"",""partyId"":""5161d3ee-ef98-4f5d-9c9d-dcc80227e8f3"",""recordType"":""account"",""nature"":""account"",""name"":""Account 6"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""7ac373db-7228-430a-8402-112c08376de3"",""partyId"":""79248cd0-bac3-4c7d-a6c1-1da1e48b6e3a"",""recordType"":""account"",""nature"":""account"",""name"":""Account 7"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""86b2c51d-ac11-4fbc-935a-f206c7b0f606"",""partyId"":""9eb76084-a44c-4a54-9144-dbc37aab0b11"",""recordType"":""account"",""nature"":""account"",""name"":""Account 8"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""e2f20aa8-88c8-4816-b1fe-6b5fbc32edea"",""partyId"":""af0057ba-1e0f-4d58-a7ac-1e5ec69bd8ed"",""recordType"":""account"",""nature"":""account"",""name"":""Account 9"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}},{""operationType"":""CREATE"",""item"":{""createdBy"":""createusername"",""createdDate"":null,""lastModifiedBy"":""username"",""lastModifiedDate"":null,""lastSource"":""L"",""isDeleted"":false,""purgeDate"":null,""isDuplicate"":0,""etag"":null,""allowedUsers"":[""username""],""id"":""7cd7f75d-cd49-4c51-b1a6-1fbb44e95825"",""partyId"":""c820c21d-909c-49fc-be81-e661473b0e68"",""recordType"":""account"",""nature"":""account"",""name"":""Account 10"",""balance"":{""amount"":0.00,""currency"":""USD"",""roundingMode"":""HALF_EVEN"",""plus"":false,""minus"":false,""zero"":true},""origin"":""manual"",""status"":""active"",""autoClearTransactions"":true,""additionalInfo"":""Just a test"",""useCheckbookRegister"":false,""includeInNetWorth"":true,""translations"":[],""new"":true}}] // WHAT IS SENT TO WEBTESTCLIENT 2021-09-04 14:18:55.634  INFO 55396 --- [           main]  c.t.s.c.a.in.web.rest.RestAdapterIT      : OPERATIONS_BEFORE: [DomainOperation(operationType=CREATE, item=Account(id=66e97b4a-3205-44b4-8c37-6d4e7417a224, partyId=208410e5-e57e-43f7-b3e3-4fedcb95f4d8, recordType=account, nature=ACCOUNT, name=Account 1, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=0e4eb854-f6d2-4981-b8b7-cede7c590d4d, partyId=efee517c-9577-4aa9-ac2a-0f577a839621, recordType=account, nature=ACCOUNT, name=Account 2, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=85fcb614-dd59-4a28-8a2e-ec1ed855fb20, partyId=a2cbc6d8-e6e2-403d-b0ba-9399ac3a0bda, recordType=account, nature=ACCOUNT, name=Account 3, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=860c1492-f40b-4b70-a7db-f4ed8f0fe0d9, partyId=590e9c15-eed2-4e0f-b573-84a8140bcb7b, recordType=account, nature=ACCOUNT, name=Account 4, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=dbdc9965-afdd-451a-a12b-fb7ed4186179, partyId=7d9acffb-f8bf-4031-9007-fdf08108aca6, recordType=account, nature=ACCOUNT, name=Account 5, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=ff23d673-a6c5-4c76-92e6-8ff750b46669, partyId=5161d3ee-ef98-4f5d-9c9d-dcc80227e8f3, recordType=account, nature=ACCOUNT, name=Account 6, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=7ac373db-7228-430a-8402-112c08376de3, partyId=79248cd0-bac3-4c7d-a6c1-1da1e48b6e3a, recordType=account, nature=ACCOUNT, name=Account 7, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=86b2c51d-ac11-4fbc-935a-f206c7b0f606, partyId=9eb76084-a44c-4a54-9144-dbc37aab0b11, recordType=account, nature=ACCOUNT, name=Account 8, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=e2f20aa8-88c8-4816-b1fe-6b5fbc32edea, partyId=af0057ba-1e0f-4d58-a7ac-1e5ec69bd8ed, recordType=account, nature=ACCOUNT, name=Account 9, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[])), DomainOperation(operationType=CREATE, item=Account(id=7cd7f75d-cd49-4c51-b1a6-1fbb44e95825, partyId=c820c21d-909c-49fc-be81-e661473b0e68, recordType=account, nature=ACCOUNT, name=Account 10, balance=$0.00, origin=MANUAL, status=ACTIVE, autoClearTransactions=true, additionalInfo=Just a test, useCheckbookRegister=false, includeInNetWorth=true, translations=[]))] 2021-09-04 14:18:55.746  INFO 55396 --- [     parallel-6]  //---> WHAT IS RECEIVED BY THE CONTROLLER s.c.s.a.i.w.r.ReactiveAccountRestAdapter : OPERATIONS_AFTER: [DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null), DomainOperation(operationType=null, item=null)] 2021-09-04 14:18:55.773 ERROR 55396 --- [     parallel-6] a.w.r.e.AbstractErrorWebExceptionHandler : [b1319997]  500 Server Error for HTTP POST ""/account/accounts/sync/from/2021-01-01T00:00:01.000000Z"" ```  As you can see, it parses `List` but it can't parse the level below.  Any ideas on how to overcome this problem?  Note: I have also created a Stack Overflow issue [here](https://stackoverflow.com/questions/69055800/spring-webtestclient-cant-parse-body-of-parameterized-type-listdomainoperation).","closed","","luissalgadofreire","2021-09-04T15:14:54Z","2021-11-23T07:26:48Z"
"","27082","Lookup method fails to resolve bean by name","**Affects:** Spring Boot 2.5.1  ---  `@Lookup` (`org.springframework.beans.factory.annotation.Lookup`) method fails to find bean by a given name.  Example:    * I have multiple singleton beans implementing an interface    * I have added a lookup method with argument(for bean name)    * when I invoke the lookup method it fails with error ""NoUniqueBeanDefinitionException: No qualifying bean of type    'com.example.pattern.factory.api.Pizza' available: expected single matching bean but found 4: cheesePizza,clamPizza,pepperoniPizza,veggiePizza]""  ```java public abstract class Pizza {}  @Service @Qualifier(""cheesePizza"") @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class CheesePizza extends Pizza {}  @Service @Qualifier(""clamPizza"") @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class ClamPizza extends Pizza {} ```  Lookup method  ```java @Lookup protected Pizza getPizza(String name){ 	return null; };  public Pizza startPreparing(String name){ 	Pizza pizza = getPizza(name); 	return pizza; } ```","closed","for: stackoverflow,","sagarvilas","2021-06-19T13:53:29Z","2021-06-21T05:14:34Z"
"","27276","WebTestClient.post MULTIPART_FORM_DATA causes Blockhound BlockingOperationError","**Affects:** Spring Boot 2.4.5 (Spring Framework 5.3.6)  ---  I am using Spring Boot 2.4.5 (Spring Framework 5.3.6) with `io.projectreactor.tools:blockhound-junit-platform`.   I recently got into a blocking call issue in following code.  ```java String csv = Files.readString(Paths.get(""src/test/resources/sample.csv"")); WebTestClient.bindToRouterFunction(routerFunction).build()                     .post()                     .uri(""/csvUpload"")                     .contentType(MediaType.MULTIPART_FORM_DATA)                     .accept(MediaType.APPLICATION_JSON)                     .body(BodyInserters.fromMultipartData(""csv"", csv))                     .exchange()                     .expectStatus()                     .isNoContent(); ```  And the exception trace is below:  ``` Blocking call! java.io.FileInputStream#readBytes; nested exception is reactor.blockhound.BlockingOperationError: Blocking call! java.io.FileInputStream#readBytes org.springframework.web.reactive.function.client.WebClientRequestException: Blocking call! java.io.FileInputStream#readBytes; nested exception is reactor.blockhound.BlockingOperationError: Blocking call! java.io.FileInputStream#readBytes 	at org.springframework.web.reactive.function.client.ExchangeFunctions$DefaultExchangeFunction.lambda$wrapException$9(ExchangeFunctions.java:141) 	at reactor.core.publisher.MonoErrorSupplied.subscribe(MonoErrorSupplied.java:70) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onError(FluxPeek.java:221) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onError(FluxPeek.java:221) 	at reactor.core.publisher.FluxMap$MapSubscriber.onError(FluxMap.java:132) 	at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.onError(MonoSubscribeOn.java:152) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:270) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 	at reactor.core.publisher.Operators.error(Operators.java:197) 	at reactor.core.publisher.MonoError.subscribe(MonoError.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.MonoWhen$WhenCoordinator.signalError(MonoWhen.java:172) 	at reactor.core.publisher.MonoWhen$WhenInner.onError(MonoWhen.java:288) 	at reactor.core.publisher.SinkEmptyMulticast.subscribe(SinkEmptyMulticast.java:168) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.MonoWhen$WhenCoordinator.subscribe(MonoWhen.java:160) 	at reactor.core.publisher.MonoWhen.subscribe(MonoWhen.java:99) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4150) 	at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:126) 	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84) 	at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.lang.Thread.run(Thread.java:834) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:139) 		at reactor.core.publisher.Mono.block(Mono.java:1727) 		at org.springframework.test.web.reactive.server.DefaultWebTestClient$DefaultRequestBodyUriSpec.exchange(DefaultWebTestClient.java:358) 		at my.group.router.handler.CsvApiHandlerTest.shouldImportCsvSuccessfully(CsvApiHandlerTest.java:76) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 		at java.base/java.lang.reflect.Method.invoke(Method.java:566) 		at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 		at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 		at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 		at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 		at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 		at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 		at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 		at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 		at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 		at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 		at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 		at java.base/java.lang.reflect.Method.invoke(Method.java:566) 		at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 		at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 		at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 		at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 		at com.sun.proxy.$Proxy5.stop(Unknown Source) 		at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:135) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 		at java.base/java.lang.reflect.Method.invoke(Method.java:566) 		at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 		at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 		at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) 		at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) 		at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) 		at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) 		at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) 		at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) 		at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 		at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) 		at java.base/java.lang.Thread.run(Unknown Source) Caused by: reactor.blockhound.BlockingOperationError: Blocking call! java.io.FileInputStream#readBytes 	at java.base/java.io.FileInputStream.readBytes(FileInputStream.java) 	at java.base/java.io.FileInputStream.read(FileInputStream.java:279) 	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:133) 	at java.base/sun.security.provider.NativePRNG$RandomIO.readFully(NativePRNG.java:424) 	at java.base/sun.security.provider.NativePRNG$RandomIO.ensureBufferValid(NativePRNG.java:526) 	at java.base/sun.security.provider.NativePRNG$RandomIO.implNextBytes(NativePRNG.java:545) 	at java.base/sun.security.provider.NativePRNG.engineNextBytes(NativePRNG.java:220) 	at java.base/java.security.SecureRandom.nextBytes(SecureRandom.java:751) 	at java.base/java.security.SecureRandom.next(SecureRandom.java:808) 	at java.base/java.util.Random.nextInt(Random.java:390) 	at org.springframework.util.MimeTypeUtils.generateMultipartBoundary(MimeTypeUtils.java:390) 	at org.springframework.http.codec.multipart.MultipartWriterSupport.generateMultipartBoundary(MultipartWriterSupport.java:104) 	at org.springframework.http.codec.multipart.MultipartHttpMessageWriter.writeMultipart(MultipartHttpMessageWriter.java:185) 	at org.springframework.http.codec.multipart.MultipartHttpMessageWriter.lambda$write$0(MultipartHttpMessageWriter.java:158) 	at reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:152) 	at reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4135) 	at reactor.core.publisher.Mono.subscribeWith(Mono.java:4265) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4121) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4057) 	at org.springframework.test.web.reactive.server.HttpHandlerConnector.doConnect(HttpHandlerConnector.java:112) 	at org.springframework.test.web.reactive.server.HttpHandlerConnector.lambda$connect$0(HttpHandlerConnector.java:79) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44) 	... 9 more ```","closed","in: web,","thanhj","2021-08-13T09:19:27Z","2021-09-21T11:04:23Z"
"","27746","Suggested WebSocket config causes circular bean reference","**Affects:** Spring Boot > 2.6.0, Spring Framework 5.3.10  Hello everyone,  right before the weekend I updated our microservices to Spring Boot 2.6.0. Some of them using websockets for real-time synchronization with the UI. A while ago we set them up using the suggested configuration as seen in:  https://github.com/spring-projects/spring-framework/blob/main/src/docs/asciidoc/web/websocket.adoc#simple-broker   Now, without any changes to our code, our websocket configuration contains a circular dependency which can be fully removed when removing the `TaskScheduler`, which of course isn't the solution, but helps to determine the circular dependency. In my opinion the suggested configuration should not contain a circular dependency when it is not recommended to use them.  One should probably update the documentation to fix this issue.  So far I have found two ways to fix this problem. First being a lazy initialization of the `TaskScheduler` bean:  ```java  @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {  	private TaskScheduler messageBrokerTaskScheduler;          // Note the @Lazy 	@Autowired 	public void setMessageBrokerTaskScheduler(@Lazy TaskScheduler taskScheduler) { 		this.messageBrokerTaskScheduler = taskScheduler; 	}  	@Override 	public void configureMessageBroker(MessageBrokerRegistry registry) {  		registry.enableSimpleBroker(""/queue/"", ""/topic/"") 				.setHeartbeatValue(new long[] {10000, 20000}) 				.setTaskScheduler(this.messageBrokerTaskScheduler);  		// ... 	} } ```   This does not work. The second one is overloading the method `configureMessageBroker`:    ```java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {  	public void configureMessageBroker(MessageBrokerRegistry registry, TaskScheduler messageBrokerTaskScheduler) {  		registry.enableSimpleBroker(""/queue/"", ""/topic/"") 				.setHeartbeatValue(new long[] {10000, 20000}) 				.setTaskScheduler(messageBrokerTaskScheduler);  		// ... 	} } ```      Should the documentation be updated or are there any downsides of using the suggested solutions?","closed","in: web,","MoritzHorch","2021-11-29T07:09:27Z","2021-11-29T17:38:44Z"
"","27885","WebFlux request id should not contain internal IPs","**Affects:** since Release v5.3.5 up to curent v5.3.14  via commit 1ef8cad of issue #26649  If for some reason the production system must be temporarily running at the DEBUG level, there might be a security issue.  If a gateway error occurs in that time while the gateway communicating with the backend server, the API response additionally contains the local IP and remote IP. Thus we are exposing network details to the outside world, which should not be done.  ``` {""timestamp"":1641298126366,""path"":""/api/endpoint"",""status"":504,""error"":""Gateway Timeout"",""requestId"":""b35a8d76-10, L:/10.1.50.20:8080 - R:/10.1.50.10:45686""} ```  The extended log file information is fine for me, there I see the IPs. It's just the API response with too much private details.  As an attacker I obtain details about two systems: 10.1.50.20 == internal gateway IP 10.1.50.10 == internal TLS-Endpoint IP in front of the gateway, not the public one The attacker can now combine this info with other vulnerabilities (maybe in other components), e.g. some SSRF as he knows the internal IP infrastructure. No up-to-date Apache httpd running? --> CVE-2021-40438 No up-to-date Keycloak running? -->  CVE-2020-10770   My Mitigation: My current work around is to set this one log channel to INFO level Logback XML notation: ```  ```  or in application.properties: ``` logging.level.org.springframework.http.server.reactive.ReactorServerHttpRequest=INFO ```  related code is that part: https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorServerHttpRequest.java#L222-L224  To easily reproduce the problem, set up very small timeout values (1 ms) for the gateway as the client: httpclient.connectionTimeout: 1 httpclient.receiveTimeout: 1","closed","type: enhancement,","psytester","2022-01-04T12:40:08Z","2022-01-12T09:03:07Z"
"","27020","YamlPropertiesFactoryBean incorrect flatten nested map to properties when map key contains escaped brackets","**Affects:** since 4.1  ---   Yaml file like bellow:  ```yaml root:   webservices:     ""[domain.test:8080]"":       - username: me         password: mypassword  ```  Yaml's map to json like  ```json {    ""webservices"": {       ""[domain.test:8080]"": [          {             ""username"": ""me"",             ""password"": ""mypassword""          }       ]    } } ```  should equals properties file like:  ```properties root.webservices.[[domain.test\:8080]][0].username=me root.webservices.[[domain.test\:8080]][0].password=mypassword ```  or:  ```properties root.webservices[[domain.test\:8080]][0].username=me root.webservices[[domain.test\:8080]][0].password=mypassword ```  Both properties file is acceptable for Spring Boot [Binding Maps](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config.typesafe-configuration-properties.relaxed-binding.maps)   Reproduce Test Case is  ```java 	@Test 	void loadNestedEscapedProperties() throws Exception {  		String yaml = ""root:\n"" + 				""  webservices:\n"" + 				""    \""[domain.test:8080]\"":\n"" + 				""      - username: me\n"" + 				""        password: mypassword\n""; 		String propsStr = ""root.webservices[[domain.test\\:8080]][0].username=me\n"" + 				""root.webservices[[domain.test\\:8080]][0].password=mypassword""; 		final PropertiesFactoryBean factory = new PropertiesFactoryBean(); 		factory.setLocations(new ByteArrayResource(propsStr.getBytes(StandardCharsets.UTF_8))); 		factory.setSingleton(false); 		final Properties properties = factory.getObject();  		final YamlPropertiesFactoryBean yamlFactory = new YamlPropertiesFactoryBean(); 		yamlFactory.setResources(new ByteArrayResource(yaml.getBytes(StandardCharsets.UTF_8))); 		assertThat(yamlFactory.getObject()).isEqualTo(properties); 	} ```  Current it is failed like bellow  ```log expected: {""root.webservices[[domain.test:8080]][0].password""=""mypassword"", ""root.webservices[[domain.test:8080]][0].username""=""me""} but was : {""root.webservices[domain.test:8080][0].password""=""mypassword"", ""root.webservices[domain.test:8080][0].username""=""me""} org.opentest4j.AssertionFailedError:  expected: {""root.webservices[[domain.test:8080]][0].password""=""mypassword"", ""root.webservices[[domain.test:8080]][0].username""=""me""} but was : {""root.webservices[domain.test:8080][0].password""=""mypassword"", ""root.webservices[domain.test:8080][0].username""=""me""} 	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) 	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) 	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) 	at org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests.loadNestedEscapedProperties(YamlPropertiesFactoryBeanTests.java:270)  ```  It seems there is a bug cause yaml's nested map is flatten incorrectly like  ```properties root.webservices[domain.test:8080][0].username=me root.webservices[domain.test:8080][0].password=mypassword ```","open","in: core,","ian4hu","2021-06-04T03:46:13Z","2021-11-10T12:23:34Z"
"","27022","YamlProcessor does not handle numeric key in Maps properly","**Affects:** since 4.1  ---   I am trying to fix the #27020 , but meet one exists test case failed. But I really think the failed test case is a anti-use of numberic indexed map of Yaml.  https://github.com/spring-projects/spring-framework/blob/58e9b187fedf03da21c4e2270bb5335b941ccf61/spring-beans/src/test/java/org/springframework/beans/factory/config/YamlProcessorTests.java#L108-L115  In the test case, it wrapped the numberic index of yaml as a bracket escaped key and verify the final key.  Problems in code  https://github.com/spring-projects/spring-framework/blob/58e9b187fedf03da21c4e2270bb5335b941ccf61/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlProcessor.java#L230-L252  in Line 248 it wrap all non-string key with bracket. Is it wrong?  https://github.com/spring-projects/spring-framework/blob/58e9b187fedf03da21c4e2270bb5335b941ccf61/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlProcessor.java#L248","open","in: core,","ian4hu","2021-06-04T07:02:56Z","2021-11-10T12:23:34Z"
"","27408","ProtobufMessageConverter fails to parse JSON payload if byte array is used","**Affects:** org.springframework:spring-messaging:5.3.6  ---   We are using org.springframework:spring-messaging:5.3.6 with com.google.protobuf:protobuf-java:3.13.0 and com.google.protobuf:protobuf-java-util:3.13.0 to send and receive protobuf messages as application/json.   ``` static class ProtobufJavaUtilSupport implements ProtobufFormatSupport { ... @Override public void merge(org.springframework.messaging.Message message, Charset charset, 		MimeType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder) 		throws IOException, MessageConversionException {  	if (contentType.isCompatibleWith(APPLICATION_JSON)) { 		this.parser.merge(message.getPayload().toString(), builder); 	} 	else { 		throw new MessageConversionException( 				""protobuf-java-util does not support parsing "" + contentType); 	} } ... } ```  `message.getPayload()` returns a byte array (GenericMessage [payload=**byte[230],** headers={...}]). Calling `toString` on a byte array produces a string similar to ""[B@27fe3806"".   Attempt to parse resulting string as JSON produces the following error:  ``` com.google.protobuf.InvalidProtocolBufferException: java.io.EOFException: End of input at line 1 column 12 path $[1] at com.google.protobuf.util.JsonFormat$ParserImpl.merge (JsonFormat.java:1347) at com.google.protobuf.util.JsonFormat$Parser.merge (JsonFormat.java:477) at org.springframework.messaging.converter.ProtobufMessageConverter$ProtobufJavaUtilSupport.merge (ProtobufMessageConverter.java:265) at org.springframework.messaging.converter.ProtobufMessageConverter.convertFromInternal (ProtobufMessageConverter.java:150) ```  I assume that byte arrays need special handling so that we use String constructor instead of `toString()` call in order to get actual JSON content (i.e. something akin to `new String(message.getPayload(), StandardCharsets.UTF_8)`).","open","in: messaging,","white-sagittarius","2021-09-15T09:13:51Z","2021-11-10T11:47:41Z"
"","27327","Spring WebFlux HATEOAS No Encoder for EntityModel with preset Content-Type 'null'","**Affects:** org.springframework.boot:spring-boot-starter-parent:2.5.2  ---   Currently also an open [stackoverflow question](https://stackoverflow.com/questions/68901191/spring-webflux-hateoas-no-encoder-for-entitymodel-with-preset-content-type-null).  While trying to expose and consume an endpoint which produces `application/x-ndjson` and returns a HAL-JSON some kind of integration is missing, I'm able to return and de-serialize a `Mono` of HAL-JSON, but not a `Flux`.   pom.xml and Pojo class  ``` xml (...) 	 		org.springframework.boot 		spring-boot-starter-parent 		2.5.2 		 	 	 		 			org.springframework.boot 			spring-boot-starter-webflux 		 		(...) 	 (...) ```  ``` java public class Pojo { 	private Integer id; 	private String name;  	public Pojo(Integer id, String name) { 		this.id=id; this.name=name; 	}  	public Integer getId() { return id; } 	public String getName() { return name; } } ```    ``` java @RestController @RequestMapping() public class PojoResource { 	Flux getPojos() { 		return Flux.just(new Pojo(1, ""alpha""), new Pojo(2, ""beta""), new Pojo(3, ""gamma"")); 	} 	 	@GetMapping(value=""/pojoA"", produces = MediaType.APPLICATION_NDJSON_VALUE) 	public Flux getAllPojosAsStream() { 		return getPojos(); 	} 	 	@GetMapping(""/pojoB"") 	public Mono getAllPojosAsHAL() { 		return getAllPojosAsHALStream().collectList(); 	}  	@GetMapping(value=""/pojoC"", produces = MediaType.APPLICATION_NDJSON_VALUE) 	public Flux getAllPojosAsHALStream() { 		return getPojos().map(p -> EntityModel.of(p)); 	} } ```  Calling for Flux of Pojo ``` bash curl -X 'GET' 'http://localhost:8080/pojoA' -H 'accept: application/x-ndjson' ``` Works like a charm: ``` json {""id"":1,""name"":""alpha""} {""id"":2,""name"":""beta""} {""id"":3,""name"":""gamma""} ```  Calling for Mono of List of EntityModel of Pojo ``` bash curl -X 'GET' 'http://localhost:8080/pojoB' -H 'accept: */*' ``` Another gem: ``` json [   {     ""id"": 1,     ""name"": ""alpha"",     ""links"": []   },   {     ""id"": 2,     ""name"": ""beta"",     ""links"": []   },   {     ""id"": 3,     ""name"": ""gamma"",     ""links"": []   } ] ```   But calling for Flux of EntityModel of Pojo ``` bash curl -X 'GET' 'http://localhost:8080/pojoC' -H 'accept: application/x-ndjson' ```  Fails with an exception: ``` org.springframework.http.converter.HttpMessageNotWritableException: No Encoder for [org.springframework.hateoas.EntityModel] with preset Content-Type 'null' (Full stacktrace can be provided if needed) ```  Is this not an intended use case? If you can provide me a little of info about the jackson encoders perhaps I can contribute with my grain of sand.","open","in: web,","Fradantim","2021-08-26T18:28:13Z","2021-11-08T11:37:36Z"
"","27599","Discussion forums not covered in CONTRIBUTING.md","**Affects:** N/A  --- This ticket is a follow-up to #27509. To prevent any misunderstanding of the topic of this report, [CONTRIBUTING.md](https://github.com/spring-projects/spring-framework/blob/main/CONTRIBUTING.md) technically does cover discussion forums in its _Ask questions_ section, but that section is obviously offtopic.  In terms of discussion forums about the development of Spring itself, CONTRIBUTING.md does not say a word. And unfortunately, [the _Community_ page](https://spring.io/community) does not come to the rescue.  As I wrote in the ticket mentioned above:  > I tried searching for forums by myself and only found forum.springframework.org, which was shut down and redirected to [a blog post about that shutdown](https://spring.io/blog/2019/02/06/legacy-forums-will-be-shutdown-february-28), and a few on SourceForge. [The _Open Discussion_ forum on SourceForge](https://sourceforge.net/p/springframework/discussion/250339/) is marked as deprecated, pointing to forum.springframework.org as a replacement. The only one which might remain relevant would be [_springframework-developer_](https://sourceforge.net/p/springframework/mailman/springframework-developer/), except the last mail there was in February, and the last legitimate message goes back to February 2019. >  > If springframework-developer remains a proper forum for discussing Spring development, please mention that on at least one of the above documents. If not, please list the other options.  According to a comment by Brian Clozel:   > The springframework-developer mailing list is not monitored by the Spring team.  ...but I cannot say whether it should be mentioned or not.","closed","status: invalid,","Chealer","2021-10-22T22:37:22Z","2021-10-23T11:56:16Z"
"","27532","ITS: SEARCH IGNORES TICKETS TRACKING OUTSTANDING ISSUES BY DEFAULT","**Affects:** N/A  --- Some of Spring's issue tracking has recently moved from Spring's Jira instance to GitHub. I'm afraid this brought a grave issue with search, which affects at least [Spring Data JPA ticket #2085](https://github.com/spring-projects/spring-data-jpa/issues/2085) and [Spring Data Commons ticket #2458](https://github.com/spring-projects/spring-data-commons/issues/2458). One way to reproduce would be to go to the issue tracker of an affected project and add to the search query a word part of a closed ticket's title, then launch search (press Enter). For example, on [Spring Data JPA's tracker](https://github.com/spring-projects/spring-data-jpa/issues), add ""hints"" to the text field. You will get a result like the following: ![image](https://user-images.githubusercontent.com/486141/136111848-52a42ea6-c0d9-42ae-89c3-c2c9213aef16.png)  This lacks ticket #2085, even if it has that term right in the title:  > 5.3.9. Applying Query Hints unclear about JPA query hints [DATAJPA-1790]  This false negative is in fact caused by a default search criteria which can be seen in the input field's default value:  > is:issue is:open   ""is:open"" excludes closed tickets.  Unless this is the result of a misconfiguration which can be fixed simply, I would recommend at least halting migration.","closed","status: declined,","Chealer","2021-10-07T21:07:36Z","2021-10-14T08:24:15Z"
"","27509","Update CONTRIBUTING.md with regards to discussion forums","**Affects:** N/A  --- [The _Discuss_ section in _Contributing to the Spring Framework_](https://github.com/spring-projects/spring-framework/blob/167e538dd13535c4b7a7cff171cd7a0ae22c9b81/CONTRIBUTING.md#discuss) is confusing.  Its first paragraph points to Stack Overflow, which is not designed to discuss Spring development to my knowledge.  Its second and last paragraph treats issue tracking.  Unfortunately, nothing seems to treat actual discussion about Spring development. And the only other document which should treat that that I can find ([the _Community_ page](https://spring.io/community)) also fails to mention any discussion forum about Spring development.  I tried searching for forums by myself and only found forum.springframework.org, which was shut down and redirected to [a blog post about that shutdown](https://spring.io/blog/2019/02/06/legacy-forums-will-be-shutdown-february-28), and a few on SourceForge. [The _Open Discussion_ forum on SourceForge](https://sourceforge.net/p/springframework/discussion/250339/) is marked as deprecated, pointing to forum.springframework.org as a replacement. The only one which might remain relevant would be [_springframework-developer_](https://sourceforge.net/p/springframework/mailman/springframework-developer/), except the last mail there was in February, and the last legitimate message goes back to February 2019.  If springframework-developer remains a proper forum for discussing Spring development, please mention that on at least one of the above documents. If not, please list the other options.","closed","type: task,","Chealer","2021-10-01T21:58:22Z","2021-10-20T08:29:15Z"
"","27143","mvc: resource with special char not found","**Affects:** master  I'm trying to load a resource with path resolved to:  - path: `file:../../web/node_modules/@fortawesome/fontawesome-free/css/all.css` - encoded resource url: `file:../../web/node_modules/%40fortawesome/fontawesome-free/css/all.css`  The resource exists and is readable. I have configured `spring.web.resources.static-locations=file:../../web/`  During validation, `PathResourceResolver` checks if [isInvalidEncodedPath](https://github.com/spring-projects/spring-framework/blob/fed1a426b6bcb78abeefdbef62077af75e52713c/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java#L294) by checking if it contains encoded `..` or `../`. This check fails, even if my resource doesn't contain those encoded strings, leading to **resource not found**.  The following check is bad, because my path contains `../` in encoded form, so it will still contain `../` when decoded: https://github.com/spring-projects/spring-framework/blob/fed1a426b6bcb78abeefdbef62077af75e52713c/spring-webmvc/src/main/java/org/springframework/web/servlet/resource/PathResourceResolver.java#L298-L301","open","in: web,","cdalexndr","2021-07-08T00:11:39Z","2022-06-05T18:16:26Z"
"","27144","Should InstantiationModelAwarePointcutAdvisorImpl#getAdvice be used to double-check lock?","**Affects:** main  ``` java         @Nullable 	private Advice instantiatedAdvice;  	@Override 	public synchronized Advice getAdvice() { 		if (this.instantiatedAdvice == null) { 			this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut); 		} 		return this.instantiatedAdvice; 	} ```  I think getAdvice() method can be used to double-check lock, please give me more advice, thanks.","closed","status: declined,","mroccyen","2021-07-08T03:44:12Z","2021-07-08T06:18:19Z"
"","27695","ReadOnlyHttpHeaders is package-private that prevents instanceOf","**Affects:** latest 5.3.13  Class org.springframework.http.ReadOnlyHttpHeaders from module spring-web  is package-private that prevents doing `instanceOf` or other interactions.  I suggest making it public-visibility class, which is really helpfull in some cases.  There was a reason doing it package-private or I can follow and make a PR?","closed","status: declined,","muchnik","2021-11-17T17:25:28Z","2021-11-18T13:24:59Z"
"","27201","Would be nice to have some doc on how WebClient handles JSON -> Objects","**Affects:** Current and older doc ---   This is a doc enhancement request that I am also volunteering to write.   The current WebClient doc does not discuss how the Spring Framework uses Jackson to do the binding. It just says it does it and show the example of a Bean which has a 1:1 mapping to the receiving JSON. It would be nice to have an example and discussion like RESTTemplate does since WebClient seems to follow the same binding behavior.   https://spring.io/guides/gs/consuming-rest/ in the ""Fetching a REST Resource"" section.","closed","for: external-project,","thesteve0","2021-07-22T19:24:58Z","2021-11-29T16:24:14Z"
"","27302","AOP !target not negating target pointcut expression","**Affects:** At least 4.2.1 - 5.3.9, probably all versions.  ---  A `!target(class)` pointcut doesn't behave as expected: It seems like the negation implementation is wrong.  From my testing `x  && !target(org.springframework.web.filter.GenericFilterBean)` behaves like `x  || target(org.springframework.web.filter.GenericFilterBean)` instead.  I've created an example project https://github.com/F43nd1r/spring-aop-negation-issue-demo. Just try to run the application. You'll see a stacktrace like this:  ``` java.lang.NullPointerException: Cannot invoke ""org.apache.commons.logging.Log.isDebugEnabled()"" because ""this.logger"" is null 	at org.springframework.web.filter.GenericFilterBean.init(GenericFilterBean.java:241) ``` That means a bean extending GenericFilterBean must've matched the pointcut and thus was proxied (GenericFilterBean implementations cannot be cglib proxied due to its implementation).  Note: This issue was also described in this stackoverflow post nearly six years ago https://stackoverflow.com/questions/33136530/target-negation-not-working-in-spring-aop.","open","in: core,","F43nd1r","2021-08-20T11:14:54Z","2022-01-18T11:18:25Z"
"","27615","Group aware web data binder","**Affects:** All versions; spring-webmvc  This is a feature request for a web data binder that respects (what I call) ""binding groups"" which are similar to (JSR 303) validation groups. Before invocation, the caller can specify the active binding groups. The binder shall only bind the fields that belong to the specified group.  I'm writing this feature request, because it's now the fourth time that we need it. Here are our use cases:  1. It solves security issues: Instead of DTOs (data transfer objects) we could use the binder to exclude entity fields that are not meant to be bound, i.e. changed by the user: ``` public class Order {     public int productId;     public int amount;     // Not meant to be changed by user, but user could easily add an input field by manipulating the HTML form     public Date createdOn; } ``` 2. Wizard-like forms. There is one object with all fields. But the fields are bound step-by-step. E.g. on the first wizard page the fields of the further pages are not required. 3. Conditional binding: E.g. a form that allows to select between two products. Depending on the product there are other fields. If those fields are filled with invalid data (e.g. string in an integer field) and afterwards the user switches the product there are unnecessary binding errors. Here is an example: * User selects product A * User fills integer field `amount` with invalid value `""foo""` * User switches to product B (which has no field `amount`) * Now there is an exception on binding although the field `amount` is not needed at all  I already implemented this and it's in use. The binder can be used with JSR 303 validation groups and additionally provides a new `@BindingGroup` annotation for fields that don't have a validation constraint.  This is what the entity could look like:  ``` public class Order {     // With @BindingGroup     @BindingGroup({OrderStep1.class})     public int productId;          // With JSR303-annotation     @NotNull(groups = OrderStep2.class)     public int amount;          // Not meant to be changed by user, but user could easily add a new input field     // => has no binding group and therefore won't be bound     public Date createdOn; } ```  The binder must be called manually in the controller:  ``` public class MyController {     private final WebBindingInitializer webBindingInitializer;      public MyController(WebBindingInitializer webBindingInitializer) {         this.webBindingInitializer = webBindingInitializer;     }      @RequestMapping(/** ... */)     public string onRequest(HttpServletRequest request) {         MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);         Order order = new Order();         GroupAwareWebRequestDataBinder dataBinder = new GroupAwareWebRequestDataBinder(order, ""order"");         webBindingInitializer.initBinder(dataBinder);                  int step = getCurrentWizardStep();                  if (step == 1) {             dataBinder.bindAndValidate(mpvs, OrderStep1.class);         } else if (step == 2) {             dataBinder.bindAndValidate(mpvs, OrderStep2.class);         } // ...     }          // ... }  ```  This is the binder. Notice that I originally wrote this for Portlet-MVC. I adapted it for Web-MVC and I hope everything is correct.  ``` /**  * binds only fields which belong to a specific group. Fields annotated with either the  * {BindingGroup} annotation or with validation-constraints having the ""groups""-  * parameter set.  * Allows conditional or wizard-like step by step binding.  */ public class GroupAwareWebRequestDataBinder extends WebDataBinder {     /**      * Create a new GroupAwareWebRequestDataBinder instance, with default object name.      * @param target the target object to bind onto (or {@code null}      * if the binder is just used to convert a plain parameter value)      * @see #DEFAULT_OBJECT_NAME      */     public GroupAwareWebRequestDataBinder(Object target) {         super(target);     }      /**      * Create a new GroupAwareWebRequestDataBinder instance.      * @param target the target object to bind onto (or {@code null}      * if the binder is just used to convert a plain parameter value)      * @param objectName the name of the target object      */     public GroupAwareWebRequestDataBinder(Object target, String objectName) {         super(target, objectName);     }      public void bind(WebRequest request, Class group) throws Exception {         bind(new MutablePropertyValues(request.getParameterMap()), group);     }      public void bind(MutablePropertyValues mpvs, Class group) throws Exception {         this.checkFieldDefaults(mpvs);         this.checkFieldMarkers(mpvs);          MutablePropertyValues targetMpvs = new MutablePropertyValues();         BeanWrapper bw = (BeanWrapper) this.getPropertyAccessor();         for (PropertyValue pv : mpvs.getPropertyValues()) {             if (bw.isReadableProperty(pv.getName())) {                 PropertyDescriptor pd = bw.getPropertyDescriptor(PropertyAccessorUtils.getPropertyName(pv.getName()));                  for (final Annotation annot : pd.getReadMethod().getAnnotations()) {                     Class[] targetGroups = {};                     if (BindingGroup.class.isInstance(annot)) {                         targetGroups = ((BindingGroup) annot).value();                     } else if (annot.annotationType().getAnnotation(Constraint.class) != null) {                         try {                             final Method groupsMethod = annot.getClass().getMethod(""groups"");                             groupsMethod.setAccessible(true);                             try {                                 targetGroups = (Class[]) AccessController.doPrivileged(new PrivilegedExceptionAction() {                                     @Override                                     public Object run() throws Exception {                                         return groupsMethod.invoke(annot, (Object[]) null);                                     }                                 });                             } catch (PrivilegedActionException pae) {                                 throw pae.getException();                             }                         }                         catch (NoSuchMethodException ignored) {}                         catch (InvocationTargetException ignored) {}                         catch (IllegalAccessException ignored) {}                     }                     for (Class targetGroup : targetGroups) {                         if (group.equals(targetGroup)) {                             targetMpvs.addPropertyValue(mpvs.getPropertyValue(pv.getName()));                         }                     }                 }             }         }         super.bind(targetMpvs);     }      public void bindAndValidate(WebRequest request, Class group) throws Exception{         bind(request, group);         validate(group);     }         public void bindAndValidate(MutablePropertyValues mpvs, Class group) throws Exception{         bind(mpvs, group);         validate(group);     }      /**      * Treats errors as fatal.      * Use this method only if it's an error if the input isn't valid.      * This might be appropriate if all input is from dropdowns, for example.      */     public void closeNoCatch() throws BindException{         if (getBindingResult().hasErrors()) {             throw new BindException(getBindingResult());         }     } } ```  The `@BindingGroup` annotation:  ``` import java.lang.annotation.*;  @Target({ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface BindingGroup {    Class[] value() default {}; } ```  ---","open","in: web,","fishbone1","2021-10-27T12:17:27Z","2021-11-08T11:41:49Z"
"","27314","Relation between `@Scheduled` and task executors","**Affects:** All versions  Please document the relation between `@Scheduled` annotation and task executors. There is no information if `@Scheduled` is using `org.springframework.scheduling.commonj.WorkManagerTaskExecutor`. In a web container environment this could lead to unwanted unmanged threads.  EDIT: I think this only affects Java EE 6 environments. For Java EE 7 you can configure the `SchedulerExecutorService` provided by the container. Is far as I understood this mechanism replaces task executors.  Please see this SO thread: https://stackoverflow.com/q/68862606/395879","open","in: core,","fishbone1","2021-08-23T06:37:37Z","2021-11-10T12:03:15Z"
"","27167","NestedRuntimeException cannot be logged to JSON","**Affects:** all --- Spring has an exception called NestedRuntimeExcepion. We use log4j2 with a JSON logger. That exception (and its many children) cannot be logged, they blow up the logger because `getMostSpecificCause` returns a self-reference if there is no cause on the exception.  I guess this falls somewhere between a bug report and a feature request. I think that many people use JSON logging and log exceptions, therefore it would be nice if all exceptions could be serialized safely with Jackson.  I just need an annotation on that method to tell Jackson to ignore it.  Thanks!","open","in: core,","adamzr","2021-07-14T01:25:46Z","2021-11-12T14:20:36Z"
"","27332","Loading SQL error codes throws XmlBeanDefinitionStoreException on z/OS","**Affects:** `5.3.9` (and earlier versions)  ---  **Operating system:** `z/OS 2.3` **Java version:**  `Java(TM) SE Runtime Environment (build 8.0.6.26 - pmz6480sr6fp26-20210226_01(SR6 FP26))` `IBM J9 VM (build 2.9, JRE 1.8.0 z/OS s390x-64-Bit Compressed References 20210216_465732 (JIT enabled, AOT enabled)` `OpenJ9   - e5f4f96` `OMR      - 999051a` `IBM      - 358762e)` `JCL - 20210108_01 based on Oracle jdk8u281-b09`  ---  When loading SQL error codes from sql-error-codes.xml on a z/OS system, the following exception is thrown: ``` org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 15 in XML document from class path resource [org/springframework/jdbc/support/sql-error-codes.xml] is invalid; nested exception is org.xml.sax.SAXParseException: cvc-elt.1: Cannot find the declaration of element 'beans'.         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:402) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:338) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:310) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.jdbc.support.SQLErrorCodesFactory.(SQLErrorCodesFactory.java:114) [spring-jdbc-5.3.9.jar!/:5.3.9]         at org.springframework.jdbc.support.SQLErrorCodesFactory.(SQLErrorCodesFactory.java:72) [spring-jdbc-5.3.9.jar!/:5.3.9]         at de.ralphriedel.Application.run(Application.java:17) [classes!/:na]         at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:791) [spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:775) [spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:345) [spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) [spring-boot-2.5.3.jar!/:2.5.3]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) [spring-boot-2.5.3.jar!/:2.5.3]         at de.ralphriedel.Application.main(Application.java:13) [classes!/:na]         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0]         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:90) ~[na:1.8.0]         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55) ~[na:1.8.0]         at java.lang.reflect.Method.invoke(Method.java:508) ~[na:1.8.0]         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) [spring-zos-dtd-issue-0.0.1-SNAPSHOT.jar:na]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) [spring-zos-dtd-issue-0.0.1-SNAPSHOT.jar:na]         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) [spring-zos-dtd-issue-0.0.1-SNAPSHOT.jar:na]         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) [spring-zos-dtd-issue-0.0.1-SNAPSHOT.jar:na] Caused by: org.xml.sax.SAXParseException: cvc-elt.1: Cannot find the declaration of element 'beans'.         at org.apache.xerces.util.ErrorHandlerWrapper.createSAXParseException(Unknown Source) ~[na:na]         at org.apache.xerces.util.ErrorHandlerWrapper.error(Unknown Source) ~[na:na]         at org.apache.xerces.impl.XMLErrorReporter.reportError(Unknown Source) ~[na:na]         at org.apache.xerces.impl.XMLErrorReporter.reportError(Unknown Source) ~[na:na]         at org.apache.xerces.impl.xs.XMLSchemaValidator.handleStartElement(Unknown Source) ~[na:na]         at org.apache.xerces.impl.xs.XMLSchemaValidator.startElement(Unknown Source) ~[na:na]         at org.apache.xerces.impl.dtd.XMLDTDValidator.startElement(Unknown Source) ~[na:na]         at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source) ~[na:na]         at org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher.scanRootElementHook(Unknown Source) ~[na:na]         at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source) ~[na:na]         at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) ~[na:na]         at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) ~[na:na]         at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) ~[na:na]         at org.apache.xerces.parsers.XMLParser.parse(Unknown Source) ~[na:na]         at org.apache.xerces.parsers.DOMParser.parse(Unknown Source) ~[na:na]         at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source) ~[na:na]         at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:77) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadDocument(XmlBeanDefinitionReader.java:432) ~[spring-beans-5.3.9.jar!/:5.3.9]         at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) ~[spring-beans-5.3.9.jar!/:5.3.9]         ... 19 common frames omitted ```  This can be reproduced trivially by getting the error codes for any given database from an instance of `SQLErrorCodesFactory`: ``` SQLErrorCodesFactory.getInstance().getErrorCodes(""DB2"") ``` I have also created a small sample project that does just that in a [personal repo](https://github.com/ralph-riedel/spring-zos-dtd-issue).  The problem seems to occur only on z/OS, my tests on Windows or Linux have resulted in no such behavior. In addition to the admittedly rather exotic platform, the system encoding is an EBCDIC flavor (IBM-1047). Could this cause an issue when the DTD gets read from the classpath?  In any case, since the issue seems with parsing the beans DTD, I replaced the DTD definition with the equivalent XML Schema definition and found that this way, it works fine. **Given that XML Schema-based configuration has been the preferred way of doing things for a while, would the Spring team accept a PR that replaces the beans DTD with the appropriate XML Schema definition in `sql-error-codes.xml`?** If so, I would be happy to submit one to side-step this issue.","open","in: data,","ralph-riedel","2021-08-28T20:02:04Z","2021-11-10T11:38:12Z"
"","27295","Using `@Validated` causes cyclic dependencies between properties","**Affects:** `5.3.9`  Description: An ABean and a BBean have a property interdependency, where the ABean uses the @validate parameter to cause the ABean to return the proxy after calling the initializeBean() method, resulting in Bean inconsistency。  Code: ```java @Validated @Service public class AService {     @Autowired     private BService bService;      public void printA(String value) {         System.out.println(""A print value: ""+ value);     } }   @Service public class BService {      @Autowired     private AService aService;      public void printB(String value) {         System.out.println(""B print value: "" + value);     } } ```  Exception: ``` org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'AService': Bean with name 'AService' has been injected into other beans [BService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example. 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:631) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) ~[spring-beans-5.3.9.jar:5.3.9] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) ~[spring-context-5.3.9.jar:5.3.9] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.9.jar:5.3.9] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.3.jar:2.5.3] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) [spring-boot-2.5.3.jar:2.5.3] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) [spring-boot-2.5.3.jar:2.5.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) [spring-boot-2.5.3.jar:2.5.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) [spring-boot-2.5.3.jar:2.5.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) [spring-boot-2.5.3.jar:2.5.3] 	at com.example.demo.DemoApplication.main(DemoApplication.java:12) [classes/:na] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_271] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_271] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_271] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_271] 	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.5.3.jar:2.5.3] ```  What I saw was:  @validate is executed in initializeBean() Org. Springframework. Validation. Beanvalidation. MethodValidationPostProcessor# afterPropertiesSet (), resulting in PersistenceExcepti execution OnTranslationPostProcessor. PostProcessAfterInitialization isEligible () in () returns true, cause to create a proxy bean","closed","in: core,","jiangdoc","2021-08-19T07:05:01Z","2021-08-19T14:50:11Z"
"","27542","Autowiring a bean of type Map will inject different values for 2 identical JUnit tests","**Affects:** `5.3.10` with Java `11`  I know that Spring Framework has a special relationship in regards to injecting Maps. I have a JUnit test where I am encountering a strange injection behavior, though.  See JUnit test case: https://github.com/ghillert/spring-di-with-maps/blob/main/src/test/java/com/hillert/spring/maps/AutowiredMapInjectionTests.java  I am declaring a single bean of type `Map` (used by 2 tests) that gets injected using `@Autowired` and  `@Qualifier(""myMapBean"")` annotations. Both tests use the same autowired dependency of the map but the injected value of  the dependency is different. The second test should see the injected bean, as does the first test, NOT the value of the underlying map. Thus, when I change the execution order of the tests, they will both fail. Is this somehow expected behavior or possibly an issue?","open","in: core,","ghillert","2021-10-11T01:53:26Z","2022-04-13T18:23:39Z"
"","26934","StackOverflowError from CronSequenceGenerator (100% reproducible)","**Affects:** `5.2.5-RELEASE` and probably others as well  `CronSequenceGenerator.next()` throws a `StackOverflowError` for certain particular combinations of cron pattern, time zone, and date.  This is 100% reproducible, but I have not yet figured out exactly what is going on. Originally I saw the bug happen in production but could not reproduce it, so I wrote a test program to try zillions of combinations and it quickly identified the one below as an example.  One thing that is interesting is it won't happen if the time zone is GMT, or if you change the `*/3` to a `*/2`.  Test program: ```java import java.util.Date; import java.util.TimeZone; import org.springframework.scheduling.support.CronSequenceGenerator;  public class CronBug {     public static void main(String[] args) throws Exception {         final String pattern = ""* * */3 * * *"";         final TimeZone timeZone = TimeZone.getTimeZone(""America/Chicago"");         final CronSequenceGenerator generator = new CronSequenceGenerator(pattern, timeZone);         final Date date = new Date(3225083777139L);         try {             generator.next(date);             System.err.println(""SUCCESS"");         } catch (StackOverflowError e) {             System.err.println(""STACK OVERFLOW"");         }     } } ```  Expected output: ``` SUCCESS ```  Actual output: ``` STACK OVERFLOW ```  Aside: Could this explain the `StackOverflowError` reported in bug #12463 after it was supposedly fixed?  Also: ```bash $ java -version openjdk version ""1.8.0_282"" OpenJDK Runtime Environment (IcedTea 3.18.0) (build 1.8.0_282-b07 suse-lp152.2.9.1-x86_64) OpenJDK 64-Bit Server VM (build 25.282-b08, mixed mode) ```","closed","in: core,","archiecobbs","2021-05-12T02:14:54Z","2021-05-26T13:39:54Z"
"","27118","Occasional ClassNotFoundException on startup on Azure AppService","**Affects:** \~5.3.0.RELEASE - at least 5.3.7  ---  About a year ago we noticed through our monitoring that we get occasional ClassNotFoundException's. If I had to guess I would say about every 50th startup or so. Then it went quite for a few months (which might have been because our monitoring was kinda broken). About 4 months back we noticed it again and even a bit more frequent about every 20th startup.  Until today we were unable to reproduce it locally (which might just be lack of effort). We are working closley with Azure on this issue, but I thought it might be a good idea to open an issue as I was unable to find anything specifically about this on the web.  Please note the log line at `2021-07-01 13:54:50.519` the class thats not found differs from startup to startup What is consistent is the `NoClassDefFoundError: org/apache/logging/log4j/core/impl/ThrowableProxy`, we switched from logback to log4j to see if it makes any difference, but it does not.     Log output 1  ``` 2021-07-01T13:53:29.948258903Z   _____                                2021-07-01T13:53:29.948285404Z   /  _  \ __________ _________   ____   2021-07-01T13:53:29.948290104Z  /  /_\  \___   /  |  \_  __ \_/ __ \  2021-07-01T13:53:29.948294104Z /    |    \/    /|  |  /|  | \/\  ___/  2021-07-01T13:53:29.948297904Z \____|__  /_____ \____/ |__|    \___  > 2021-07-01T13:53:29.948301704Z         \/      \/                  \/  2021-07-01T13:53:29.948305305Z A P P   S E R V I C E   O N   L I N U X 2021-07-01T13:53:29.948308605Z Documentation: http://aka.ms/webapp-linux 2021-07-01T13:53:29.948312105Z  2021-07-01T13:53:29.948315405Z **NOTE**: No files or system changes outside of /home will persist beyond your application's current session. /home is your application's persistent storage and is shared across all the server instances. 2021-07-01T13:53:29.948321605Z  2021-07-01T13:53:29.948324905Z  2021-07-01T13:53:29.948328305Z Setup openrc ... 2021-07-01T13:53:30.990429843Z  * Caching service dependencies ... [ ok ] 2021-07-01T13:53:31.001125061Z Updating /etc/ssh/sshd_config to use PORT 2222 2021-07-01T13:53:31.018362035Z Starting ssh service... 2021-07-01T13:53:33.246392033Z ssh-keygen: generating new host keys: RSA DSA ECDSA ED25519  2021-07-01T13:53:35.989078422Z  * Starting sshd ... [ ok ] 2021-07-01T13:53:36.056129835Z ## Printing build info... 2021-07-01T13:53:36.079171033Z                                            PACKAGE |                             VERSION | COMMIT 2021-07-01T13:53:36.083812814Z        Microsoft.AppService.WebsitesExtensionsJava |        1.0.012910002-alpha-ca976a99 | ca976a99 2021-07-01T13:53:36.083819514Z                                               self |        1.0.012910002-alpha-65e49f85 | 65e49f85 2021-07-01T13:53:36.084121226Z ## Done printing build info. 2021-07-01T13:53:36.137581810Z Add public certificates to keystore if exists... 2021-07-01T13:53:36.138302938Z Add private certificates to keystore if exists... 2021-07-01T13:53:36.138640251Z Configuring max heap = 2761 MB 2021-07-01T13:53:36.171484031Z STARTUP_FILE= 2021-07-01T13:53:36.171638437Z STARTUP_COMMAND=java -Xmx512m -jar -Dspring.profiles.active=sqlserver /home/site/wwwroot/kundenmanagement.jar 2021-07-01T13:53:36.176204415Z No STARTUP_FILE available. 2021-07-01T13:53:36.176526828Z Running STARTUP_COMMAND: java -Xmx512m -jar -Dspring.profiles.active=sqlserver /home/site/wwwroot/kundenmanagement.jar 2021-07-01T13:53:36.781679715Z Picked up JAVA_TOOL_OPTIONS: -Xmx2761M -Djava.net.preferIPv4Stack=true -javaagent:/agents/java/applicationinsights-agent-codeless.jar 2021-07-01T13:53:40.680684989Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:50.759398711Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:50.772178510Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:51.515825336Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:51.534522766Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:51.536305635Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:52.026560730Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:53:52.849019956Z 2021-07-01 13:53:52.841Z INFO  c.m.applicationinsights.agent - ApplicationInsights Java Agent 3.0.4-BETA started successfully 2021-07-01T13:53:52.849043057Z 2021-07-01 13:53:52.843Z INFO  a.extension.diagnostics - Application Insights Codeless Agent 3.0.4-BETA Attach Successful 2021-07-01T13:53:53.230397860Z 2021-07-01 13:53:53.224Z INFO  c.m.a.a.b.d.status.StatusFile - Wrote status to file: /root/LogFiles/ApplicationInsights/status/status_RD0050F2721466_122.json 2021-07-01T13:53:58.105449699Z OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 2021-07-01T13:54:02.192300176Z  2021-07-01T13:54:02.192736593Z   .   ____          _            __ _ _ 2021-07-01T13:54:02.193027005Z  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ 2021-07-01T13:54:02.193332817Z ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ 2021-07-01T13:54:02.193656229Z  \\/  ___)| |_)| | | | | || (_| |  ) ) ) ) 2021-07-01T13:54:02.193935240Z   '  |____| .__|_| |_|_| |_\__, | / / / / 2021-07-01T13:54:02.194194850Z  =========|_|==============|___/=/_/_/_/ 2021-07-01T13:54:02.222154838Z  :: Spring Boot ::                (v2.4.6) 2021-07-01T13:54:02.222417049Z  2021-07-01T13:54:04.180034740Z 2021-07-01 13:54:04.142  INFO 122 --- [           main] c.e.e.KundenmanagementApplicationKt      : Starting KundenmanagementApplicationKt v0.0.1-SNAPSHOT using Java 11.0.7 on 020bc6d29462 with PID 122 (/home/site/wwwroot/kundenmanagement.jar started by root in /) 2021-07-01T13:54:04.230306696Z 2021-07-01 13:54:04.228  INFO 122 --- [           main] c.e.e.KundenmanagementApplicationKt      : The following profiles are active: sqlserver 2021-07-01T13:54:16.404356713Z 2021-07-01 13:54:16.398  INFO 122 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode. 2021-07-01T13:54:18.842346616Z 2021-07-01 13:54:18.840  INFO 122 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 2377 ms. Found 1 JPA repository interfaces. 2021-07-01T13:54:23.567334325Z 2021-07-01 13:54:23.561  INFO 122 --- [           main] o.s.b.w.e.t.TomcatWebServer              : Tomcat initialized with port(s): 80 (http) 2021-07-01T13:54:23.681727192Z 2021-07-01 13:54:23.681  INFO 122 --- [           main] o.a.c.c.StandardService                  : Starting service [Tomcat] 2021-07-01T13:54:23.689397092Z 2021-07-01 13:54:23.682  INFO 122 --- [           main] o.a.c.c.StandardEngine                   : Starting Servlet engine: [Apache Tomcat/9.0.46] 2021-07-01T13:54:23.929447565Z 2021-07-01 13:54:23.924  INFO 122 --- [           main] o.a.c.c.C.[.[.[/]                        : Initializing Spring embedded WebApplicationContext 2021-07-01T13:54:23.929475967Z 2021-07-01 13:54:23.924  INFO 122 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 19135 ms 2021-07-01T13:54:24.060149869Z 2021-07-01 13:54:24.056  INFO 122 --- [           main] i.m.c.i.p.PushMeterRegistry              : publishing metrics for AzureMonitorMeterRegistry every 1m 2021-07-01T13:54:27.833248590Z 2021-07-01 13:54:27.831  INFO 122 --- [           main] o.f.c.i.l.VersionPrinter                 : Flyway Community Edition 7.1.1 by Redgate 2021-07-01T13:54:27.902907309Z 2021-07-01 13:54:27.902  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Starting... 2021-07-01T13:54:32.609608622Z 2021-07-01 13:54:32.609  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Start completed. 2021-07-01T13:54:37.398175782Z 2021-07-01 13:54:37.384  INFO 122 --- [           main] o.f.c.i.d.b.DatabaseType                 : Database: jdbc:sqlserver://emma-netzebw-dev-sql-server.database.windows.net:1433;sendTemporalDataTypesAsStringForBulkCopy=true;delayLoadingLobs=true;useFmtOnly=false;useBulkCopyForBatchInsert=false;cancelQueryTimeout=-1;sslProtocol=TLS;jaasConfigurationName=SQLJDBCDriver;statementPoolingCacheSize=0;serverPreparedStatementDiscardThreshold=10;enablePrepareOnFirstPreparedStatementCall=false;fips=false;socketTimeout=0;authentication=NotSpecified;authenticationScheme=nativeAuthentication;xopenStates=false;sendTimeAsDatetime=true;trustStoreType=JKS;trustServerCertificate=false;TransparentNetworkIPResolution=true;serverNameAsACE=false;sendStringParametersAsUnicode=true;selectMethod=direct;responseBuffering=adaptive;queryTimeout=-1;packetSize=8000;multiSubnetFailover=false;loginTimeout=10;lockTimeout=-1;lastUpdateCount=true;encrypt=false;disableStatementPooling=true;databaseName=emma-netzebw-dev-db;columnEncryptionSetting=Disabled;applicationName=Microsoft JDBC Driver for SQL Server;applicationIntent=readwrite; (Microsoft SQL Server 12.0) 2021-07-01T13:54:40.125759903Z 2021-07-01 13:54:40.119  INFO 122 --- [           main] o.f.c.i.c.DbValidate                     : Successfully validated 6 migrations (execution time 00:01.940s) 2021-07-01T13:54:40.420252450Z 2021-07-01 13:54:40.184  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Current version of schema [kundenmanagement]: 1.0.5 2021-07-01T13:54:40.420271851Z 2021-07-01 13:54:40.206  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Schema [kundenmanagement] is up to date. No migration necessary. 2021-07-01T13:54:40.773094489Z 2021-07-01 13:54:40.766  INFO 122 --- [           main] o.h.j.i.u.LogHelper                      : HHH000204: Processing PersistenceUnitInfo [name: default] 2021-07-01T13:54:42.153271918Z 2021-07-01 13:54:42.123  INFO 122 --- [           main] o.h.Version                              : HHH000412: Hibernate ORM core version 5.4.31.Final 2021-07-01T13:54:44.269000294Z 2021-07-01 13:54:44.268  INFO 122 --- [           main] o.h.a.c.Version                          : HCANN000001: Hibernate Commons Annotations {5.1.2.Final} 2021-07-01T13:54:48.332904278Z 2021-07-01 13:54:48.327  INFO 122 --- [           main] o.h.d.Dialect                            : HHH000400: Using dialect: org.hibernate.dialect.SQLServer2012Dialect 2021-07-01T13:54:50.521236953Z 2021-07-01 13:54:50.519  WARN 122 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is java.lang.NoClassDefFoundError: javax/persistence/OrderColumn 2021-07-01T13:54:50.521264754Z 2021-07-01 13:54:50.520  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Shutdown initiated... 2021-07-01T13:54:50.619502209Z 2021-07-01 13:54:50.619  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Shutdown completed. 2021-07-01T13:54:51.122025030Z Exception in thread ""main"" java.lang.reflect.InvocationTargetException 2021-07-01T13:54:51.124806639Z 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2021-07-01T13:54:51.131244991Z 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 2021-07-01T13:54:51.131510402Z 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 2021-07-01T13:54:51.131693609Z 	at java.base/java.lang.reflect.Method.invoke(Unknown Source) 2021-07-01T13:54:51.132071324Z 	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) 2021-07-01T13:54:51.132283932Z 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) 2021-07-01T13:54:51.132547242Z 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) 2021-07-01T13:54:51.133028661Z 	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) 2021-07-01T13:54:51.133491380Z Caused by: java.lang.NoClassDefFoundError: org/apache/logging/log4j/core/impl/ThrowableProxy 2021-07-01T13:54:51.133672987Z 	at org.apache.logging.log4j.core.impl.Log4jLogEvent.getThrownProxy(Log4jLogEvent.java:629) 2021-07-01T13:54:51.133852294Z 	at org.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverter.format(ExtendedThrowablePatternConverter.java:63) 2021-07-01T13:54:51.134029701Z 	at org.springframework.boot.logging.log4j2.ExtendedWhitespaceThrowablePatternConverter.format(ExtendedWhitespaceThrowablePatternConverter.java:50) 2021-07-01T13:54:51.134207708Z 	at org.apache.logging.log4j.core.pattern.PatternFormatter.format(PatternFormatter.java:38) 2021-07-01T13:54:51.134386615Z 	at org.apache.logging.log4j.core.layout.PatternLayout$PatternSerializer.toSerializable(PatternLayout.java:345) 2021-07-01T13:54:51.134563622Z 	at org.apache.logging.log4j.core.layout.PatternLayout.toText(PatternLayout.java:244) 2021-07-01T13:54:51.134741329Z 	at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:229) 2021-07-01T13:54:51.134994639Z 	at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:59) 2021-07-01T13:54:51.164539798Z 	at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.directEncodeEvent(AbstractOutputStreamAppender.java:197) 2021-07-01T13:54:51.164563099Z 	at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.tryAppend(AbstractOutputStreamAppender.java:190) 2021-07-01T13:54:51.164568799Z 	at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:181) 2021-07-01T13:54:51.164573199Z 	at org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156) 2021-07-01T13:54:51.164577599Z 	at org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129) 2021-07-01T13:54:51.164582000Z 	at org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120) 2021-07-01T13:54:51.164586300Z 	at org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84) 2021-07-01T13:54:51.164590700Z 	at org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:543) 2021-07-01T13:54:51.164594700Z 	at org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:502) 2021-07-01T13:54:51.164598800Z 	at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:485) 2021-07-01T13:54:51.164602800Z 	at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:460) 2021-07-01T13:54:51.164606901Z 	at org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:82) 2021-07-01T13:54:51.164611101Z 	at org.apache.logging.log4j.core.Logger.log(Logger.java:161) 2021-07-01T13:54:51.164615101Z 	at org.apache.logging.log4j.spi.AbstractLogger.tryLogMessage(AbstractLogger.java:2198) 2021-07-01T13:54:51.164619201Z 	at org.apache.logging.log4j.spi.AbstractLogger.logMessageTrackRecursion(AbstractLogger.java:2152) 2021-07-01T13:54:51.164623201Z 	at org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2135) 2021-07-01T13:54:51.164627201Z 	at org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:2011) 2021-07-01T13:54:51.164631102Z 	at org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1983) 2021-07-01T13:54:51.164635202Z 	at org.apache.commons.logging.LogAdapter$Log4jLog.log(LogAdapter.java:263) 2021-07-01T13:54:51.164639102Z 	at org.apache.commons.logging.LogAdapter$Log4jLog.error(LogAdapter.java:215) 2021-07-01T13:54:51.164643102Z 	at org.springframework.boot.SpringApplication.reportFailure(SpringApplication.java:860) 2021-07-01T13:54:51.164647702Z 	at org.springframework.boot.SpringApplication.handleRunFailure(SpringApplication.java:825) 2021-07-01T13:54:51.164651702Z 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:349) 2021-07-01T13:54:51.164664503Z 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1329) 2021-07-01T13:54:51.164668603Z 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1318) 2021-07-01T13:54:51.164672603Z 	at com.enbw.emma.KundenmanagementApplicationKt.main(KundenmanagementApplication.kt:16) 2021-07-01T13:54:51.164676603Z 	... 8 more 2021-07-01T13:54:51.164680703Z Caused by: java.lang.ClassNotFoundException: org.apache.logging.log4j.core.impl.ThrowableProxy 2021-07-01T13:54:51.164684804Z 	at java.base/java.net.URLClassLoader.findClass(Unknown Source) 2021-07-01T13:54:51.164688704Z 	at java.base/java.lang.ClassLoader.loadClass(Unknown Source) 2021-07-01T13:54:51.164692704Z 	at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151) 2021-07-01T13:54:51.164696704Z 	at java.base/java.lang.ClassLoader.loadClass(Unknown Source) 2021-07-01T13:54:51.164700604Z 	... 42 more ```      Log output 2  ``` 2021-07-01T18:06:47.867637445Z   _____                                2021-07-01T18:06:47.867661545Z   /  _  \ __________ _________   ____   2021-07-01T18:06:47.867677546Z  /  /_\  \___   /  |  \_  __ \_/ __ \  2021-07-01T18:06:47.867682446Z /    |    \/    /|  |  /|  | \/\  ___/  2021-07-01T18:06:47.867686446Z \____|__  /_____ \____/ |__|    \___  > 2021-07-01T18:06:47.867690547Z         \/      \/                  \/  2021-07-01T18:06:47.867694647Z A P P   S E R V I C E   O N   L I N U X 2021-07-01T18:06:47.867698247Z Documentation: http://aka.ms/webapp-linux 2021-07-01T18:06:47.867702047Z  2021-07-01T18:06:47.867705647Z **NOTE**: No files or system changes outside of /home will persist beyond your application's current session. /home is your application's persistent storage and is shared across all the server instances. 2021-07-01T18:06:47.867711947Z  2021-07-01T18:06:47.867715448Z  2021-07-01T18:06:47.867935956Z Setup openrc ... 2021-07-01T18:06:48.600991583Z  * Caching service dependencies ... [ ok ] 2021-07-01T18:06:48.653284218Z Updating /etc/ssh/sshd_config to use PORT 2222 2021-07-01T18:06:48.767113948Z Starting ssh service... 2021-07-01T18:06:51.212808215Z ssh-keygen: generating new host keys: RSA DSA ECDSA ED25519  2021-07-01T18:06:53.944253101Z  * Starting sshd ... [ ok ] 2021-07-01T18:06:53.949351799Z ## Printing build info... 2021-07-01T18:06:53.952437319Z                                            PACKAGE |                             VERSION | COMMIT 2021-07-01T18:06:53.952453020Z        Microsoft.AppService.WebsitesExtensionsJava |        1.0.012910002-alpha-ca976a99 | ca976a99 2021-07-01T18:06:53.952458720Z                                               self |        1.0.012910002-alpha-65e49f85 | 65e49f85 2021-07-01T18:06:53.957951134Z ## Done printing build info. 2021-07-01T18:06:53.977600799Z Add public certificates to keystore if exists... 2021-07-01T18:06:53.991389835Z Add private certificates to keystore if exists... 2021-07-01T18:06:53.991566242Z Configuring max heap = 2761 MB 2021-07-01T18:06:54.009072623Z STARTUP_FILE= 2021-07-01T18:06:54.009089724Z STARTUP_COMMAND=java -Xmx512m -jar /home/site/wwwroot/kundenmanagement.jar 2021-07-01T18:06:54.009095424Z No STARTUP_FILE available. 2021-07-01T18:06:54.011410814Z Running STARTUP_COMMAND: java -Xmx512m -jar /home/site/wwwroot/kundenmanagement.jar 2021-07-01T18:06:54.503346556Z Picked up JAVA_TOOL_OPTIONS: -Xmx2761M -Djava.net.preferIPv4Stack=true  2021-07-01T18:07:02.273745543Z  2021-07-01T18:07:02.276051033Z   .   ____          _            __ _ _ 2021-07-01T18:07:02.276135436Z  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ 2021-07-01T18:07:02.283949940Z ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ 2021-07-01T18:07:02.293876726Z  \\/  ___)| |_)| | | | | || (_| |  ) ) ) ) 2021-07-01T18:07:02.294647056Z   '  |____| .__|_| |_|_| |_\__, | / / / / 2021-07-01T18:07:02.294956668Z  =========|_|==============|___/=/_/_/_/ 2021-07-01T18:07:02.304069623Z  :: Spring Boot ::                (v2.4.6) 2021-07-01T18:07:02.304314032Z  2021-07-01T18:07:02.828567625Z 2021-07-01 18:07:02.809  INFO 122 --- [           main] c.e.e.KundenmanagementApplicationKt      : Starting KundenmanagementApplicationKt v0.0.1-SNAPSHOT using Java 11.0.7 on a47a28b639cf with PID 122 (/home/site/wwwroot/kundenmanagement.jar started by root in /) 2021-07-01T18:07:02.861303298Z 2021-07-01 18:07:02.861  INFO 122 --- [           main] c.e.e.KundenmanagementApplicationKt      : No active profile set, falling back to default profiles: default 2021-07-01T18:07:13.209115317Z 2021-07-01 18:07:13.188  INFO 122 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode. 2021-07-01T18:07:14.380734062Z 2021-07-01 18:07:14.380  INFO 122 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 1142 ms. Found 1 JPA repository interfaces. 2021-07-01T18:07:17.977222478Z 2021-07-01 18:07:17.976  INFO 122 --- [           main] o.s.b.w.e.t.TomcatWebServer              : Tomcat initialized with port(s): 80 (http) 2021-07-01T18:07:18.107988972Z 2021-07-01 18:07:18.055  INFO 122 --- [           main] o.a.c.c.StandardService                  : Starting service [Tomcat] 2021-07-01T18:07:18.108020673Z 2021-07-01 18:07:18.057  INFO 122 --- [           main] o.a.c.c.StandardEngine                   : Starting Servlet engine: [Apache Tomcat/9.0.46] 2021-07-01T18:07:18.480554487Z 2021-07-01 18:07:18.461  INFO 122 --- [           main] o.a.c.c.C.[.[.[/]                        : Initializing Spring embedded WebApplicationContext 2021-07-01T18:07:18.490919791Z 2021-07-01 18:07:18.461  INFO 122 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 14970 ms 2021-07-01T18:07:20.270841135Z 2021-07-01 18:07:20.270  INFO 122 --- [           main] o.f.c.i.l.VersionPrinter                 : Flyway Community Edition 7.1.1 by Redgate 2021-07-01T18:07:20.349806911Z 2021-07-01 18:07:20.349  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Starting... 2021-07-01T18:07:21.783929404Z 2021-07-01 18:07:21.783  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Start completed. 2021-07-01T18:07:21.986398800Z 2021-07-01 18:07:21.986  INFO 122 --- [           main] o.f.c.i.d.b.DatabaseType                 : Database: jdbc:h2:mem:1d744965-59e3-4f9b-8429-3b2bc6136b2a (H2 1.4) 2021-07-01T18:07:22.350355293Z 2021-07-01 18:07:22.350  INFO 122 --- [           main] o.f.c.i.c.DbValidate                     : Successfully validated 6 migrations (execution time 00:00.136s) 2021-07-01T18:07:22.421189755Z 2021-07-01 18:07:22.420  INFO 122 --- [           main] o.f.c.i.s.JdbcTableSchemaHistory         : Creating Schema History table ""PUBLIC"".""flyway_schema_history"" ... 2021-07-01T18:07:22.659193636Z 2021-07-01 18:07:22.658  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Current version of schema ""PUBLIC"": > 2021-07-01T18:07:22.687858954Z 2021-07-01 18:07:22.687  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Migrating schema ""PUBLIC"" to version ""1.0.0 - Initial"" 2021-07-01T18:07:22.910783448Z 2021-07-01 18:07:22.908  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Migrating schema ""PUBLIC"" to version ""1.0.1 - Add AppUserFilter KundenId"" 2021-07-01T18:07:23.132132579Z 2021-07-01 18:07:23.108  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Migrating schema ""PUBLIC"" to version ""1.0.2 - Rename AppUserFilter KundeId to KundenId"" 2021-07-01T18:07:23.309238986Z 2021-07-01 18:07:23.280  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Migrating schema ""PUBLIC"" to version ""1.0.3 - Add Kostenstelle"" 2021-07-01T18:07:23.434052653Z 2021-07-01 18:07:23.400  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Migrating schema ""PUBLIC"" to version ""1.0.4 - Make Kostenstelle KundeId Nullable"" 2021-07-01T18:07:23.515268920Z 2021-07-01 18:07:23.487  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Migrating schema ""PUBLIC"" to version ""1.0.5 - Make AppUserFilter KundeId Nullable"" 2021-07-01T18:07:23.685202147Z 2021-07-01 18:07:23.648  INFO 122 --- [           main] o.f.c.i.c.DbMigrate                      : Successfully applied 6 migrations to schema ""PUBLIC"" (execution time 00:01.012s) 2021-07-01T18:07:24.307466913Z 2021-07-01 18:07:24.303  INFO 122 --- [           main] o.h.j.i.u.LogHelper                      : HHH000204: Processing PersistenceUnitInfo [name: default] 2021-07-01T18:07:24.798758672Z 2021-07-01 18:07:24.798  INFO 122 --- [           main] o.h.Version                              : HHH000412: Hibernate ORM core version 5.4.31.Final 2021-07-01T18:07:25.917935216Z 2021-07-01 18:07:25.917  INFO 122 --- [           main] o.h.a.c.Version                          : HCANN000001: Hibernate Commons Annotations {5.1.2.Final} 2021-07-01T18:07:26.675494259Z 2021-07-01 18:07:26.674  INFO 122 --- [           main] o.h.d.Dialect                            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect 2021-07-01T18:07:39.373112947Z 2021-07-01 18:07:39.365  INFO 122 --- [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform] 2021-07-01T18:07:39.476474481Z 2021-07-01 18:07:39.476  INFO 122 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default' 2021-07-01T18:07:52.065407620Z 2021-07-01 18:07:52.061 DEBUG 122 --- [           main] o.s.w.c.RestTemplate                     : HTTP GET https://login.emma-dev.netze-bw.de/.well-known/openid-configuration 2021-07-01T18:07:52.124693746Z 2021-07-01 18:07:52.121 DEBUG 122 --- [           main] o.s.w.c.RestTemplate                     : Accept=[application/json, application/*+json] 2021-07-01T18:07:54.937816800Z 2021-07-01 18:07:54.916  WARN 122 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'webSecurityConfiguration': Unsatisfied dependency expressed through method 'setContentNegotationStrategy' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration': Unsatisfied dependency expressed through method 'setConfigurers' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.security.config.annotation.web.configuration.OAuth2ClientConfiguration$OAuth2ClientWebMvcSecurityConfiguration': Unsatisfied dependency expressed through method 'setClientRegistrationRepository' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'clientRegistrationRepository' defined in class path resource [org/springframework/boot/autoconfigure/security/oauth2/client/servlet/OAuth2ClientRegistrationRepositoryConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.security.oauth2.client.registration.InMemoryClientRegistrationRepository]: Factory method 'clientRegistrationRepository' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/http/client/SimpleClientHttpResponse 2021-07-01T18:07:54.937872902Z 2021-07-01 18:07:54.931  INFO 122 --- [           main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2021-07-01T18:07:54.953147798Z 2021-07-01 18:07:54.952  WARN 122 --- [           main] o.s.b.f.s.DisposableBeanAdapter          : Invocation of destroy method failed on bean with name 'entityManagerFactory': java.lang.NoClassDefFoundError: org/springframework/orm/hibernate5/SpringBeanContainer$SpringContainedBean 2021-07-01T18:07:54.953612817Z 2021-07-01 18:07:54.953  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Shutdown initiated... 2021-07-01T18:07:54.965245471Z 2021-07-01 18:07:54.964  INFO 122 --- [           main] c.z.h.HikariDataSource                   : HikariPool-1 - Shutdown completed. 2021-07-01T18:07:54.995597956Z 2021-07-01 18:07:54.994  INFO 122 --- [           main] o.a.c.c.StandardService                  : Stopping service [Tomcat] 2021-07-01T18:07:55.401809015Z Exception in thread ""main"" java.lang.reflect.InvocationTargetException 2021-07-01T18:07:55.401837516Z 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2021-07-01T18:07:55.401843516Z 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) 2021-07-01T18:07:55.401848117Z 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) 2021-07-01T18:07:55.401852517Z 	at java.base/java.lang.reflect.Method.invoke(Unknown Source) 2021-07-01T18:07:55.401856817Z 	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) 2021-07-01T18:07:55.401861117Z 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) 2021-07-01T18:07:55.401865117Z 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) 2021-07-01T18:07:55.401869117Z 	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) 2021-07-01T18:07:55.402840455Z Caused by: java.lang.NoClassDefFoundError: org/apache/logging/log4j/core/impl/ThrowableProxy 2021-07-01T18:07:55.402891657Z 	at org.apache.logging.log4j.core.impl.Log4jLogEvent.getThrownProxy(Log4jLogEvent.java:629) 2021-07-01T18:07:55.402901058Z 	at org.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverter.format(ExtendedThrowablePatternConverter.java:63) 2021-07-01T18:07:55.402996561Z 	at org.springframework.boot.logging.log4j2.ExtendedWhitespaceThrowablePatternConverter.format(ExtendedWhitespaceThrowablePatternConverter.java:50) 2021-07-01T18:07:55.403039263Z 	at org.apache.logging.log4j.core.pattern.PatternFormatter.format(PatternFormatter.java:38) 2021-07-01T18:07:55.403047463Z 	at org.apache.logging.log4j.core.layout.PatternLayout$PatternSerializer.toSerializable(PatternLayout.java:345) 2021-07-01T18:07:55.403053764Z 	at org.apache.logging.log4j.core.layout.PatternLayout.toText(PatternLayout.java:244) 2021-07-01T18:07:55.403079165Z 	at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:229) 2021-07-01T18:07:55.403087365Z 	at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:59) 2021-07-01T18:07:55.403093565Z 	at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.directEncodeEvent(AbstractOutputStreamAppender.java:197) 2021-07-01T18:07:55.403591185Z 	at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.tryAppend(AbstractOutputStreamAppender.java:190) 2021-07-01T18:07:55.403609385Z 	at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:181) 2021-07-01T18:07:55.403616286Z 	at org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156) 2021-07-01T18:07:55.403622886Z 	at org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129) 2021-07-01T18:07:55.403629086Z 	at org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120) 2021-07-01T18:07:55.403635486Z 	at org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84) 2021-07-01T18:07:55.403641787Z 	at org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:543) 2021-07-01T18:07:55.403648087Z 	at org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:502) 2021-07-01T18:07:55.403654287Z 	at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:485) 2021-07-01T18:07:55.403660487Z 	at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:460) 2021-07-01T18:07:55.403668788Z 	at org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:82) 2021-07-01T18:07:55.403675488Z 	at org.apache.logging.log4j.core.Logger.log(Logger.java:161) 2021-07-01T18:07:55.403681688Z 	at org.apache.logging.log4j.spi.AbstractLogger.tryLogMessage(AbstractLogger.java:2198) 2021-07-01T18:07:55.403687988Z 	at org.apache.logging.log4j.spi.AbstractLogger.logMessageTrackRecursion(AbstractLogger.java:2152) 2021-07-01T18:07:55.403701189Z 	at org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2135) 2021-07-01T18:07:55.403707689Z 	at org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:2011) 2021-07-01T18:07:55.403713889Z 	at org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1983) 2021-07-01T18:07:55.403719990Z 	at org.apache.commons.logging.LogAdapter$Log4jLog.log(LogAdapter.java:263) 2021-07-01T18:07:55.403726190Z 	at org.apache.commons.logging.LogAdapter$Log4jLog.error(LogAdapter.java:215) 2021-07-01T18:07:55.403732290Z 	at org.springframework.boot.SpringApplication.reportFailure(SpringApplication.java:860) 2021-07-01T18:07:55.403738490Z 	at org.springframework.boot.SpringApplication.handleRunFailure(SpringApplication.java:825) 2021-07-01T18:07:55.403744791Z 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:349) 2021-07-01T18:07:55.403750891Z 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1329) 2021-07-01T18:07:55.403757091Z 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1318) 2021-07-01T18:07:55.403763291Z 	at com.enbw.emma.KundenmanagementApplicationKt.main(KundenmanagementApplication.kt:16) 2021-07-01T18:07:55.403769492Z 	... 8 more 2021-07-01T18:07:55.405252249Z Caused by: java.lang.ClassNotFoundException: org.apache.logging.log4j.core.impl.ThrowableProxy 2021-07-01T18:07:55.405271350Z 	at java.base/java.net.URLClassLoader.findClass(Unknown Source) 2021-07-01T18:07:55.405279550Z 	at java.base/java.lang.ClassLoader.loadClass(Unknown Source) 2021-07-01T18:07:55.405286651Z 	at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151) 2021-07-01T18:07:55.405293851Z 	at java.base/java.lang.ClassLoader.loadClass(Unknown Source) 2021-07-01T18:07:55.417326721Z 	... 42 more ```   We are working on a minimal example to reproduce this, I will update the issue as soon as there are any news on this.","closed","for: external-project,","patrick-dedication","2021-07-01T18:26:05Z","2021-07-07T13:44:29Z"
"","27587","spring-web (reactive) ConcurrentModificationException when the response process commitActions","**Affects:** \v5.3.8  ---  - Version : `spring-web` v5.3.8 - Server type : reactive - Java class : `org.springframework.http.server.reactive.AbstractServerHttpResponse` - Method : `protected Mono doCommit(@Nullable Supplier","open","in: web,","libetl","2021-10-21T11:56:15Z","2021-11-04T13:13:08Z"
"","27612","MultipartParser emits DataBufferLimitException about ""Part headers exceeded the memory usage limit"" unexpectedly","**Affects:** \Up to 5.3.12  ---  Here's a web application based on Spring Webflux. When receiving multipart/form-data POST requests from clients, the body parts will be parsed by `org.springframework.http.codec.multipart.MultipartParser`. As reading the source code, we could find that the main logic of the MultipartParser is a state machine. It changes state between the state of header parsing and the state of body parsing for most time. Now take the following request body as an example:  > ------WebKitFormBoundarySOIUhndhpIQUSFc1 > Content-Disposition: form-data; name=""size"" >  > 25015919 > ------WebKitFormBoundarySOIUhndhpIQUSFc1 > Content-Disposition: form-data; name=""parentId"" >  >  > ------WebKitFormBoundarySOIUhndhpIQUSFc1 > Content-Disposition: form-data; name=""file""; filename=""data.zip"" > Content-Type: application/x-zip-compressed >  > (binary data) > ------WebKitFormBoundarySOIUhndhpIQUSFc1--  Upstream provides `DataBuffer`s to MultipartParser sequently. MultipartParser handles these `DataBuffer`s and transit among states. When parsing the body above, PREAMBLE -> HEADERS -> BODY -> HEADERS -> BODY -> HEADERS -> BODY -> DISPOSED should be performed. First, we get header `Content-Disposition: form-data; name=""size""`, then body `25015919`, then header `Content-Disposition: form-data; name=""parentId""`, so far so good.  But here comes up a malformed situation. Let's say if the current `DataBuffer` contains the value of the ""parentId"" part (which is an empty string), and ends with the boundary plus CRLF. i.e. the byte array under the `DataBuffer` should be looked like: `[..., 45, 45, 45, 45, 45, 45, 87, 101, 98, 75, 105, 116, 70, 111, 114, 109, 66, 111, 117, 110, 100, 97, 114, 121, 83, 79, 73, 85, 104, 110, 100, 104, 112, 73, 81, 85, 83, 70, 99, 49, 13, 10]`  Now let's check out the part of codes of `BodyState` about handling the body of the part. ```java int endIdx = this.boundary.match(buffer); if (endIdx != -1) { 	if (logger.isTraceEnabled()) { 		logger.trace(""Boundary found @"" + endIdx + "" in "" + buffer); 	} 	int len = endIdx - buffer.readPosition() - this.boundary.delimiter().length + 1; 	if (len > 0) { 		// buffer contains complete delimiter, let's slice it and flush it 		DataBuffer body = buffer.retainedSlice(buffer.readPosition(), len); 		enqueue(body); 		enqueue(null); 	} 	else if (len < 0) { 		// buffer starts with the end of the delimiter, let's slice the previous buffer and flush it 		DataBuffer previous = this.previous.get(); 		int prevLen = previous.readableByteCount() + len; 		if (prevLen > 0) {                         DataBuffer body = previous.retainedSlice(previous.readPosition(), prevLen);                         DataBufferUtils.release(previous);                         this.previous.set(body);                         enqueue(null); 		} 		else {                         DataBufferUtils.release(previous);                         this.previous.set(null); 		} 	} 	else /* if (sliceLength == 0) */ { 		// buffer starts with complete delimiter, flush out the previous buffer 		enqueue(null); 	}  	DataBuffer remainder = MultipartUtils.sliceFrom(buffer, endIdx); 	DataBufferUtils.release(buffer);  	changeState(this, new HeadersState(), remainder); } else { 	enqueue(buffer); 	requestBuffer(); } ``` Since the current buffer contains the complete boundary, the `endIdx` should be greater than -1. In this example the value of `endIdx` should be the length of the buffer minus 2 (exclude the tail CRLF). As we could see the `remainder` is sliced from the original buffer started from position `endIdx + 1`. That means the `remainder` contains two bytes of CRLF in this example. Next, the state is changed to HEADERS. Let's check out the part of codes of `HeadersState` ```java long prevCount = this.byteCount.get(); long count = this.byteCount.addAndGet(buf.readableByteCount()); if (prevCount < 2 && count >= 2) { 	if (isLastBoundary(buf)) { 		if (logger.isTraceEnabled()) { 			logger.trace(""Last boundary found in "" + buf); 		}  		if (changeState(this, DisposedState.INSTANCE, buf)) { 			emitComplete(); 		} 		return; 	} } else if (count > MultipartParser.this.maxHeadersSize) { 	if (changeState(this, DisposedState.INSTANCE, buf)) { 		emitError(new DataBufferLimitException(""Part headers exceeded the memory usage limit of "" + 				MultipartParser.this.maxHeadersSize + "" bytes"")); 	} 	return; } int endIdx = this.endHeaders.match(buf); if (endIdx != -1) { 	if (logger.isTraceEnabled()) { 		logger.trace(""End of headers found @"" + endIdx + "" in "" + buf); 	} 	DataBuffer headerBuf = MultipartUtils.sliceTo(buf, endIdx); 	this.buffers.add(headerBuf); 	DataBuffer bodyBuf = MultipartUtils.sliceFrom(buf, endIdx); 	DataBufferUtils.release(buf);  	emitHeaders(parseHeaders()); 	changeState(this, new BodyState(), bodyBuf); } else { 	this.buffers.add(buf); 	requestBuffer(); } ``` The `buf` here is just exactly the same as the `remainder` sliced from the `buffer` during the previous state BODY, i.e. contains two bytes of CRLF. For now the value of `prevCount` is 0, `count` is 2, and `this.byteCount` is added to 2. Since the `buf` doesn't contain the `endHeaders`, `endIdx` is -1, and another `DataBuffer` is requested at line 2 count from backward. When new `DataBuffer` is provided, the codes above will be excuted again. This time since the `this.byteCount` is added to 2, the `prevCount` is assigned to 2. By default the `readableByteCount()` of the fresh `DataBuffer` could be (probably) up to 8192 (8KB), so we assume that here the readable byte count of the `buf` is 8192, and the `count` is added to 8194. However, the default value of `MultipartParser.this.maxHeadersSize` is set to 8192, so the condition of the second `if` is matched. `DataBufferLimitException(""Part headers exceeded the memory usage limit of "" + MultipartParser.this.maxHeadersSize + "" bytes"")` is emitted. This is apperently not the expected behavior.   This issue could not be 100% reproduced, but occasionally occurs after serveral (plenty?) attempts. The temporary workaround is set `maxHeadersSize` to 8194. It's an ugly workaround. In my opinion the default setting should be work well for most cases. So probably I'm using it in a wrong way or I've misunderstood something. Correct me if I make a mistake.  Thanks for any help.","closed","type: bug,","Reginald-Yoeng-Lee","2021-10-27T08:49:54Z","2021-11-29T12:47:24Z"
"","27584","HierarchicalUriComponents.verifyUriComponent fails with URIs containing ==","**Affects:** \spring-web-5.3.5 ---  Using example URL below https://greenrockbatteries.com/_static/??-eJydkd1OwzAMRl+ILho/Q1wgXoB3QGniNu5SO4sdSnl6NjSBaIGqu4pifSdf5DOkyjEpkJoUS4skpgNN1u3NC5IzdcHoTQqsTOdj0yNtOrka5qjjOrLbi/EoarrvQWUJe6vIf5FiIx7vlbBDG0/oz8kE0wA9fGVOcQ2YfZVs1tF0hwJ53IAVpPYSsuciMASA5d6UkTPquKpGsyVBXcUMdkyMpLKK6tlDJnzPC3tPnLXhiDx94KitBXlm68H/Yv7/9sCvkPEzeYmGxpIba35b3SslQW5QwiKFNNMwXY3jDDOBXFyQAROc//bUP253N7f3d7vtw/UHBQJGkA==  Webclient throws error java.lang.IllegalArgumentException: Invalid character '=' for QUERY_PARAM in ""="" platform-server |       at org.springframework.web.util.HierarchicalUriComponents.verifyUriComponent(HierarchicalUriComponents.java:416) ~[spring-web-5.3.5.jar:5.3.5]  The URL is base64 encoded and padded at end with double equals. Removing one or both equals from URL, no error thrown.  Referenced https://github.com/spring-projects/spring-framework/blob/785212d67655119a71d3ad700e90c6e09e7c6361/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java#L391","open","in: web,","monstrfolk","2021-10-20T21:58:40Z","2021-11-08T11:17:45Z"
"","27347","spring schedule job is synchronous execute","**Affects:** \5.3.3  I find a strange thing that  schedule job is synchronous execute And hava to config this as below to execute asynchronous:  @Configuration public class ScheduleConfig implements SchedulingConfigurer {     // ==== size for thread     private final int POOL_SIZE = 10;      @Override     public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {         ThreadPoolTaskScheduler threadPoolTaskScheduler = new ThreadPoolTaskScheduler();          threadPoolTaskScheduler.setPoolSize(POOL_SIZE);         threadPoolTaskScheduler.setThreadNamePrefix(""scheduled-task-pool-"");         threadPoolTaskScheduler.initialize();         scheduledTaskRegistrar.setTaskScheduler(threadPoolTaskScheduler);     } }   ============================================================== And synchronous schedule  result in that ,eg.I have 2 job to execute in 11:00,one of jobs cost 30min because of businsess,so other job has to waite ,that is unreasonable? eg：     @Scheduled(cron = ""0 0 11 * * ?"")     public void test01() throws InterruptedException {         System.out.println(""test01 beging......"");         TimeUnit.MINUTES.sleep(30);         System.out.println(""test01 end......"");     }       @Scheduled(cron = ""0 0 11 * * ?"")     public void test02() throws InterruptedException {         System.out.println(""test02 beging......"");         TimeUnit.SECONDS.sleep(3);         System.out.println(""test02 end......"");     }  At second,spring own async function for taskThread,So why not set Schedule Thread?  Looking forward to your reply。  ---","open","in: core,","h-AuD","2021-09-01T02:49:53Z","2021-11-10T12:03:15Z"
"","27743","PartGenerator streaming mode mixing parts content, or part content not properly delivered when downstream part prefetch is 0","**Affects:** \5.2.x **Affects:** \5.3.x ---   When trying to use the `PartGenerator` in steaming mode (streaming = true), the documentation states that part content should be consumed in an ordered and serial fashion. We still end up with a `Flux`, but of course we cannot use the `flatMap` operator to trigger part content consumption since it would break this requirement.  However, when using it, instead of raising an exception stating that parallel consumption of parts has been tried, the generator first silently mixes up the parts content (especially when very small parts are encountered, or when the part consumption is slower that the part reception/production), and a not explicit exception is finally thrown when trying to consume the ultimate or penultimate etc. (depending on how many parts have been silently skipped).  For example, if you have, say, a 20 KB part, then à 1 KB part and finally a 250 KB part, you will probably end up with the content of the 3rd part being sent as the 2nd part content, without notice, and when trying to consume the 3rd part, an exception will be thrown saying ""Could not switch from STREAMING  to STREAMING; current state: STREAMING"".  If you try to use the `concatMap` operator, which is supposed to serialize mapper execution (and thus subscription to part content), the problems still appears because of the default prefetch of the operator (usually 32) : parts are still produced in advance, skipping small ones' content. So if you want to really serialize part content consumption, you have to use `concatMap` with no prefetch.  However, when doing so, you are faced with another problem (which is a bug) : no part's body content (_i.e._ part content's databuffer) are produced at all, even after subscription and unbounded request.   ### My analysis of the problem  This is due to the fact that the current implementation (through the `requestToken()` method) does not account for the correct downstream request (given by `sink.requestedFromDownstream()`) : only the downstream request from the parts' sink is accounted for, whereas when delivering part content, the content sink should be considered and not the part sink. Thus, two distinct `requestToken()` methods (or a parameterized `requestToken(Sink sink)`) should be defined, to distinguish between part demand and content demand : for example, we could define the `requestContent()` and `requestPart()` methods, with conditions pointing to different sinks. And the `requestContent()` method should probably be defined at the `StreamingState` inner class level, in order to point to the correct sink.  Another problem is that a new intermediate state should be defined  : currenty, there is only one state for part chaining and content delivery, the `StreamingState` (that we could rename to `ContentStreamingState`). But a transitional state, that we could call `PartStreamingState`, should be defined to represent the fact that we are waiting for a new part to be requested from downstream, when all previous part content has been exhausted. The former would use `requestContent()` and the latter `requestPart()`.  Also, the part number, and/or a flag stating that the part is already passed or not, should be defined in the `StreamingState` inner class, to be able to produce a correct error message when the serial consumption of parts and part contents is not honored by the downstream subscriber. Whenever a part content is subscribed or requested, the flag or part number should be checked to ensure the consumer is subscribing or requesting the correct part (the current one), an dnot a revious one : if the consumer requests or subscribes too late to a part that has already been streamed, an explicit error message, specifying the part numbers, should be raised, like ""Trying to subscribe a part (number #) that has already been completed (current part: #)"". Also, the `StreamingState` should display the part number in it's `toString()`method.  Finally, the 'ContentStreamingState' should also use an inner queue to deliver the content body, only when content is requested. Currently, when a data buffer comprises multiple parts, the parts content is delivered unconditionnally : it should be enqueued instead and delivered only when requested by part content subscriber.  **_Note_**. We could also consider defining a new `StreamingPartGenerator` class to isolate the steaming behavior from `PartGenerator`, since this is a quite different behavior in nature than the ""normal' one (saving parts to disc or memory before serving them).","open","type: bug,","djouvin","2021-11-28T15:48:07Z","2022-07-11T14:26:48Z"
"","26930","Can't translate sql errorcode if  throws MetaDataAccessException at building SQLErrorCodeSQLExceptionTranslator with DataSource parameter","**Affects:** \5.2.5.RELEASE(spring-jdbc)  mysql-connector-java: 8.0.19 mybatis-spring-boot-starter: 2.1.2 spring-boot-starter-jdbc: 2.2.6.RELEASE  step 1: set mysql to read only $ mysql -uroot -p mysql> set global read_only=ON; mysql> flush tables with read lock;  step 2: write  a test application which inserts a record into the test table. SQLErrorCodeSQLExceptionTranslator object will be built with datasource input parameter, MetaDataAccessException will be triggered at JdbcUtils.extractDatabaseMetaData call, and a new SQLErrorCodes() will be built as the sqlErrorCodes of the SQLErrorCodeSQLExceptionTranslator object.  step 3: set mysql to read/write $ mysql -uroot -p mysql> set global read_only=OFF; mysql> unlock tables;    step4:  continue the test application to insert two same records into the test table which has unique key. the SQLErrorCodeSQLExceptionTranslator object could not do anything but return null because it;s sqlErrorCodes has empty duplicateKeyCodes.","closed","","zrlw","2021-05-11T12:36:35Z","2022-02-18T19:05:40Z"
"","26889","@Cacheable condition passes 'null' instead of method argument into the root.target method","**Affects:** \5.1.5.RELEASE (via Boot 2.1.3.RELEASE)  --- Dear Spring Team!  Spring Cache overall works as expected for a long time in our services, but today I've noticed that there is an issue with a @Cacheable condition passing 'null' instead of a method argument into a `root.target` method.  I'm having the following two methods in a Spring Bean that is marked as `@Component`: ```java @Cacheable(value = CacheConstants.CODE_BY_TITLE_CACHE_NM, key=""#codeSetId + #title + #authority"",         condition=""#root.target.isCodeSetSmall(#codeSetId) && T(com.myOrg.code.CodeConstants).SYSTEM_AUTHORITY.equals(#authority)"") public Code getCodeByTitle(String authority, Long codeSetId, String title) {     // not relevant code }  public boolean isCodeSetSmall(Long codeSetId) {     // codeSetId is null here } ```  The result is that method `isCodeSetSmall` complains about `null` being passed as input argument, while I'm certain that its source `codeSetId` is **not** `null` at the point when cacheable `getCodeByTitle` is called.  I've tried to debug to find where the issue may be and it appears that `org.springframework.expression.spel.ast.MethodReference.getArguments` is the one to blame. It is called from `MethodReference.getValueRef(ExpressionState state)` method. It looks like at that point `ExpressionState` has proper values for all three arguments of my cacheable method `getCodeByTitle`, although `getArguments(state)` returns array of one element which is `null`.  Here you can see I debug `getArguments(state)` and state.relatedContext.arguments has values that I pass to my cacheable `getCodeByTitle` method: ![1](https://user-images.githubusercontent.com/3834742/116933702-e6c55880-ac31-11eb-9a72-d8cc32d7f0c2.png)  Here you can see that `this.children[i].getValueInternal(state).getValue()` returned `null` (see first line in Variables window on the right): ![2](https://user-images.githubusercontent.com/3834742/116933801-0f4d5280-ac32-11eb-87c8-3909a32bf5aa.png)  And here return value is finally array of single `null`: ![3](https://user-images.githubusercontent.com/3834742/116933848-1ecc9b80-ac32-11eb-8812-8b8f078f90fb.png)  Please let me know if I'm doing something wrong here or if I can help with any other debug information.  Thank you very much in advance!","closed","","ykartsev","2021-05-03T21:14:52Z","2021-05-04T06:06:54Z"
"","27114","Using SqlRowSet results in a connection leak","**Affects:** \4.3.28  We have a search facility that returns a SqlRowSet obtained from jdbcTemplate.queryForRowSet.  The row set is returned to a UI that displays the contents of the row set in a grid.  We are experiencing a similar problem to that described in #23718.  Each time the search is used the connection is not being returned to the pool.  We can see the database sessions incrementing over time.  We can reclaim the connections using the abandoned connection timeout.  I have tried the work-around suggested in the linked issue and it appears to be working.  Explicitly closing the result set prevents the number of database sessions from increasing.","open","status: feedback-provided,","chriswightman","2021-07-01T09:25:15Z","2021-07-05T05:47:54Z"
"","27292","Spring HATEOAS results in 406 with Kotlin Coroutine and ResponseEntity in WebFlux","**Affects:** \2.5.3  When migrating a reactive web project (written in Kotlin) from 2.4.x to 2.5.3, I noticed that the HTTP POST Request that was used to create a new entity was failing with HTTP Status 406.   ```json {   ""timestamp"": ""2021-08-18T23:56:17.183+00:00"",   ""path"": ""/api"",   ""status"": 406,   ""error"": ""Not Acceptable"",   ""message"": ""Could not find acceptable representation"" } ```  After investigating, I found out that the error occurs when **all** of the below conditions are fullfilled:  * `EntityModel` from Hateoas is wrapped in a `ResponseEntity` * Controller function is a Coroutine (marked with the suspend `keyword`, the error **does not** happen when using the traditional way with Project Reactor's `Mono`) * Hypermedia Support is enabled * Spring Boot Version is at least 2.5.0  Here is a small repro project created with the Spring Initializr  https://github.com/enolive/spring-hateoas  ```kotlin package com.example.hateoastest  import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.hateoas.EntityModel import org.springframework.hateoas.Link import org.springframework.hateoas.config.EnableHypermediaSupport import org.springframework.http.ResponseEntity import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RequestMapping import org.springframework.web.bind.annotation.RestController import java.net.URI  @SpringBootApplication @EnableHypermediaSupport(type = [EnableHypermediaSupport.HypermediaType.HAL]) class HateoasTestApplication  @RestController @RequestMapping(""/api"") class Controller {   @GetMapping   suspend fun test() =     Greetings(""Hello, World!"")       .withSelfLink()       .wrappedInResponseEntity() }  private fun Greetings.withSelfLink() =   EntityModel.of(this, Link.of(""/api"").withSelfRel())  private fun  EntityModel.wrappedInResponseEntity() =   ResponseEntity.created(URI(""/api"")).body(this)  data class Greetings(val message: String)  fun main(args: Array) {   runApplication(*args) } ```  When switching the parent version back to 2.4.x (say, 2.4.9), everything works fine and I will get the expected output.  ```log GET http://localhost:8080/api  HTTP/1.1 201 Created Location: /api Content-Type: application/hal+json Content-Length: 61  {   ""message"": ""Hello, World!"",   ""_links"": {     ""self"": {       ""href"": ""/api""     }   } } ```  As a side note, explicitly setting the Accept Header to `application/hal+json` removes the error message. However, the hypermedia representation of the returned content seems wrong (`links` instead of `_links`):  ```log GET http://localhost:8080/api Accept: application/hal+json  HTTP/1.1 201 Created Location: /api Content-Type: application/hal+json Content-Length: 66  {   ""message"": ""Hello, World!"",   ""links"": [     {       ""rel"": ""self"",       ""href"": ""/api""     }   ] }  Response code: 201 (Created); Time: 225ms; Content length: 66 bytes ``` Am I doing something wrong?  Please let me know whether I should provide additional information  I used following dependencies in my maven `pom.xml`:  ```xml     4.0.0        org.springframework.boot     spring-boot-starter-parent     2.5.3            com.example   hateoas-test   0.0.1-SNAPSHOT   hateoas-test   hateoas-test        11     1.5.21                  org.springframework.boot       spring-boot-starter-hateoas                           org.springframework.boot           spring-boot-starter-web                                 org.springframework.boot       spring-boot-starter-actuator                 org.springframework.boot       spring-boot-starter-webflux                 com.fasterxml.jackson.module       jackson-module-kotlin                 io.projectreactor.kotlin       reactor-kotlin-extensions                 org.jetbrains.kotlin       kotlin-reflect                 org.jetbrains.kotlin       kotlin-stdlib-jdk8                 org.jetbrains.kotlinx       kotlinx-coroutines-reactor                  org.springframework.boot       spring-boot-devtools       runtime       true                 org.springframework.boot       spring-boot-starter-test       test                 io.projectreactor       reactor-test       test                 ${project.basedir}/src/main/kotlin     ${project.basedir}/src/test/kotlin                     org.springframework.boot         spring-boot-maven-plugin                       org.jetbrains.kotlin         kotlin-maven-plugin                                 -Xjsr305=strict                                   spring                                                     org.jetbrains.kotlin             kotlin-maven-allopen             ${kotlin.version}                                      ```  ---","closed","type: bug,","enolive","2021-08-19T00:34:22Z","2021-10-13T13:58:47Z"
"","27519","STOMP connection not established correctly during application startup","**Affects:** \>=5.3.3  ---   Consider a _Spring Boot_ application with the following websocket configuration class:  	@Configuration 	@EnableWebSocketMessageBroker 	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {  		@Override 		public void configureMessageBroker(MessageBrokerRegistry config) { 			config.setApplicationDestinationPrefixes(""/app""); 			config.enableSimpleBroker(""/topic"", ""/queue""); 			config.setUserDestinationPrefix(""/user""); 		}  		@Override 		public void registerStompEndpoints(StompEndpointRegistry registry) { 			String[] cors= new String[] { ""*"" }; 			registry.addEndpoint(""/server"").setAllowedOriginPatterns(cors).withSockJS(); 		}  	}  This configuration creates a _STOMP_ endpoint `/server` over _SockJS_. During startup, we observe a short time window, in which clients are able to connect to that endpoint (`CONNECT` message), without receiving a `CONNECTED` response from the server. Precisely, the behavior is as follows:  1. The `/info` REST endpoint (_SockJS_ protocol) is available and responds correctly. 2. The websocket over `ws://.../server/.../websocket` is available. 3. The initial message `o` is sent from the server just after the websocket connection is established. 4. The client sends the message `[""CONNECT\naccept-version:1.1,1.0\nheart-beat:10000,10000\n\n\u0000""]`. 5. The server does not respond to that message, however, it sends periodical heartbeat messages `h`. 6. The client (JS frontend library) resides in a not-connected state without trying to reconnect.  Screenshot: ![image](https://user-images.githubusercontent.com/7002180/136035225-456b385e-de7a-4128-b5b4-6ab9689a2e9e.png)  Relevant log output during startup:  ``` 2021-10-05 15:13:13.796  INFO 21428 --- [           main] o.s.b.w.e.t.TomcatWebServer              : Tomcat started on port(s): 8080 (http) with context path '' [...] 2021-10-05 15:14:09.160  INFO 21428 --- [MessageBroker-4] o.s.w.s.c.WebSocketMessageBrokerStats    : WebSocketSession[3 current WS(3)-HttpStream(0)-HttpPoll(0), 3 total, 0 closed abnormally (0 connect failure, 0 send limit, 0 transport error)], stompSubProtocol[processed CONNECT(3)-CONNECTED(0)-DISCONNECT(0)], stompBrokerRelay[null], inboundChannel[pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0], outboundChannel[pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0], sockJsScheduler[pool size = 8, active threads = 1, queued tasks = 4, completed tasks = 5] [...] 2021-10-05 15:14:11.355 DEBUG 21428 --- [pool-4-thread-1] o.s.m.s.b.SimpleBrokerMessageHandler     : Starting... 2021-10-05 15:14:17.349  INFO 21428 --- [           main] o.s.m.s.b.SimpleBrokerMessageHandler     : BrokerAvailabilityEvent[available=true, SimpleBrokerMessageHandler [org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry@134a27c1]] 2021-10-05 15:14:17.350  INFO 21428 --- [           main] o.s.m.s.b.SimpleBrokerMessageHandler     : Started. ```  The log output of `WebSocketMessageBrokerStats` shows three connections already before the `SimpleBrokerMessageHandler` is starting, respectively `SubProtocolWebSocketHandler#start()` has been called.  After `SubProtocolWebSocketHandler#start()` has been called, the server responds correctly.","open","in: web,","trylimits","2021-10-05T14:26:57Z","2021-11-10T11:43:13Z"
"","27429","Spring Framework >= 5.3.8 ASM ClassReader fails to parse class file due to InputStream optimization","**Affects:** \ spring framework >= 5.3.8  In my project, after switching from using spring boot 2.4.4 to 2.4.10 At the very beginning of start I'm getting following exception:  ``` {""@timestamp"":""2021-09-17T13:28:47.395Z"",""logLevel"":""INFO"",""pid"":""10"",""logThread"":""main"",""logger"":""com.tomtom.lns.batch.front.FrontendApp"",""message"":""The following profiles are active: prod,kubernetes""} {""@timestamp"":""2021-09-17T13:28:47.515Z"",""logLevel"":""WARN"",""pid"":""10"",""logThread"":""main"",""logger"":""o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext"",""message"":""Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [com.tomtom.lns.batch.front.FrontendApp]; nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet: class path resource [com/tomtom/lns/batch/health/HealthConfig.class]; nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 21845""} {""@timestamp"":""2021-09-17T13:28:47.538Z"",""logLevel"":""ERROR"",""pid"":""10"",""logThread"":""main"",""logger"":""o.springframework.boot.SpringApplication"",""message"":""Application run failed"",""stack_trace"":""java.lang.IllegalArgumentException: Unsupported class file major version 21845   at org.springframework.asm.ClassReader.(ClassReader.java:199)   at org.springframework.asm.ClassReader.(ClassReader.java:180)   at org.springframework.asm.ClassReader.(ClassReader.java:166)   at org.springframework.asm.ClassReader.(ClassReader.java:287)   at org.springframework.core.type.classreading.SimpleMetadataReader.getClassReader(SimpleMetadataReader.java:57)   ... 39 common frames omitted Wrapped by: org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet: class path resource [com/tomtom/lns/batch/health/HealthConfig.class]; nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 21845   at org.springframework.core.type.classreading.SimpleMetadataReader.getClassReader(SimpleMetadataReader.java:60)   at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:49)   at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103)   at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.createMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:86)   at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.getMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:73)   at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:81)   at org.springframework.context.annotation.ConfigurationClassParser.asSourceClass(ConfigurationClassParser.java:696)   at org.springframework.context.annotation.ConfigurationClassParser$SourceClass.getRelated(ConfigurationClassParser.java:1090)   at org.springframework.context.annotation.ConfigurationClassParser$SourceClass.getAnnotationAttributes(ConfigurationClassParser.java:1071)   at org.springframework.context.annotation.ConfigurationClassParser.collectImports(ConfigurationClassParser.java:549)   at org.springframework.context.annotation.ConfigurationClassParser.getImports(ConfigurationClassParser.java:522)   at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:311)   at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:250)   at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:199)   at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:304)   at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:250)   at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:207)   at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:175)   ... 22 common frames omitted Wrapped by: org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [com.tomtom.lns.batch.front.FrontendApp]; nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet: class path resource [com/tomtom/lns/batch/health/HealthConfig.class]; nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 21845   at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:189)   at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:331)   at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:247)   at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:311)   at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:112)   at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:746)   at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:564)   at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:144)   at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:771)   at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:763)   at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:438)   at org.springframework.boot.SpringApplication.run(SpringApplication.java:339)   at org.springframework.boot.SpringApplication.run(SpringApplication.java:1329)   at org.springframework.boot.SpringApplication.run(SpringApplication.java:1318)   at com.tomtom.lns.batch.front.FrontendApp.main(FrontendApp.java:19)   at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java)   at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   at java.lang.reflect.Method.invoke(Method.java:566)   at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)   at org.springframework.boot.loader.Launcher.launch(Launcher.java:108)   at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)   at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ""} ``` I've unpacked HealthConfig.class from built jar and saw following when reading using linux midnight commander:  ``` compiled Java class data, version 55.0 Compiled from ""HealthConfig.java"" public class com.tomtom.lns.batch.health.HealthConfig {   public com.tomtom.lns.batch.health.HealthConfig();   com.tomtom.lns.batch.health.ShutdownListener shutdownListener(org.springframework.context.ApplicationEventPublisher);   com.tomtom.lns.batch.health.HealthGroupStatusNotifier stateLogger(org.springframework.context.ApplicationEventPublisher, org.springframework.boot.actuate.health.HealthEndpointGroups, org.springframework.boot.actuate.hea } ```  I've tried multiple versions of spring boot and spring framework and found that issue starts in spring 5.3.8. In that version I see that org.springframework.asm.ClassReader was modified in: https://github.com/spring-projects/spring-framework/issues/27023  ---","closed","status: feedback-provided,","MichalKoziorowski-TomTom","2021-09-17T13:34:35Z","2021-09-21T16:00:39Z"
"","27266","ServerResponseResultHandler can NOT handle ""Mono""","**Affects:** \ 5.3.8  ---   `org.springframework.web.reactive.function.server.support.ServerResponseResultHandler.java` can NOT handle `Mono or Flux`.  `public boolean supports(HandlerResult result)` always return false. **because it check a returnValue type of HandlerResult .** need to replace a return type with a generic type of it. see below error code. ``` 	@Override 	public boolean supports(HandlerResult result) { 		return (result.getReturnValue() instanceof ServerResponse); 	} ```  fix like below it has to compare with a generic type of returnType ``` 	@Override 	public boolean supports(HandlerResult result) { 		return ServerResponse.class.isAssignableFrom(result.getReturnType().getGeneric().toClass()); 	}  ```","open","status: feedback-provided,","hongjunan","2021-08-12T09:29:01Z","2021-11-08T11:37:35Z"
"","27197","Method resolveType of GenericTypeResolver lost bounds info of TypeVariableImpl","**Affects:** \ 5.2.4 ![image](https://user-images.githubusercontent.com/32413524/126625860-737041b6-ea54-4e48-bcba-87984eb26654.png) As you can see，after resolve，that method return class named ComApproveRequest  to replace genericType. ComApproveRequest is a class which has generic parameter named ComDealExDTO. But the bounds of genericType is class which is subclass of ComDealExDTO. So this leads to Jackson not being able to correctly convert the json String to type of subclass of ComDealExDTO. Is this a bug ？And how do i deal with it？  ---","open","in: core,","zhanlinfeng","2021-07-22T10:48:08Z","2021-11-11T09:22:57Z"
"","27794","High Spring-JDBC process time under massive SELECT enquiry","**Affects:** \ 5.1.7  ---   We are evaluating Spring-JDBC+ DBCP to communicate with IBM DB2 Server.  However we found the process time of each query increase continuously when use perform massive query with same SQL statement:  ![dbcp_spring_dbcp_compare](https://user-images.githubusercontent.com/95902399/145538098-6bc55237-4f78-4812-8aec-19d558313e6a.png)  It is reasonable to require overhead for connection and statement management, but we would like to know if those overhead costs double process time to pure DBCP?  Sample Project is prepared for reference: [https://github.com/shin779/mybatis-integration](https://github.com/shin779/mybatis-integration)","closed","status: invalid,","shin779","2021-12-10T08:07:04Z","2021-12-24T01:51:03Z"
"","27342","XStreamMarshaller unmarshall failing with xstream version upgrade to 1.4.18","**Affects:** \  We are using XStreamMarshaller from spring-oxm, for unmarshalling. When trying xstream version upgrade to 1.4.18 because of vulnerability we are facing below issue.  ``` ---- Debugging information ---- cause-exception : com.thoughtworks.xstream.security.ForbiddenClassException cause-message : com.our.class class : java.util.ArrayList required-type : java.util.ArrayList converter-type : com.thoughtworks.xstream.converters.collections.CollectionConverter path : /list/com.our.class line number : 1 version : 5.3.4 ``` How we are using the XStreamMarshaller ``` List>();         MarshallingHttpMessageConverter marshallingHttpConverter = new MarshallingHttpMessageConverter(**customizeXStreamMarshaller**());         marshallingHttpConverter.setSupportedMediaTypes(Arrays.asList(MediaType.APPLICATION_XML));         messageConverters.add(marshallingHttpConverter);      private XStreamMarshaller **customizeXStreamMarshaller**() {         return new XStreamMarshaller() {             @Override             protected void customizeXStream(XStream xstream) {                 xstream.denyTypes(new Class[] {void.class, Void.class});             }         };     } ``` Is there any way to resolve this issue?  Thanks, Vijay","closed","in: data,","vijayanandof","2021-08-31T12:10:59Z","2021-09-02T05:57:14Z"
"","27350","CommonsMultipartResolver and DEBUG logging lead to empty fileMap in MultipartHttpServletRequest","**Affects:** \ Spring: 5.3.9 but the error also occurs in earlier Versions (i could also reproduce it with 5.2.6)  **Problem:** If a CommonsMultipartResolver is used to Handle File Upload to a Spring RestController and the LogLevel of the Dispatcher Servlet is set to DEBUG a Request Containing a Multipart File leads to an empty FileMap on the MultipartHttpServletRequest. If eighter the LogLevel is not DEBUG or another Resolver is used the same Request contains a FileMap,.  **Expected Behavior:** The expected behavior would be that he LogLevel and the choice of the MultipartResolver do not change the behavior and the Request should always contain a File on the MultipartHttpServletRequest.  **Example Application:** I created an example Application to check the behavior here: https://gitlab.com/katja_m_franz/springbug It is a really small Application and i hope you can easily reproduce the described Problem. All Info on how to do that can be found on the projects readme.","closed","type: bug,","katja-m-franz","2021-09-02T04:31:48Z","2021-09-14T12:40:56Z"
"","27320","java 1.8 use spring cache enabled sync = true then trigger jdk bug JDK-8062841","**Affects:** \ java version : 1.8.0_261 ---  [https://bugs.openjdk.java.net/browse/JDK-8062841](url) **ConcurrentHashMap.computeIfAbsent stuck in an endless loop** 1. enabled cache @EnableCaching 2. use sync = true @Cacheable(value = ""xxx"" , sync =true) 3. trigger bug at  org.springframework.cache.interceptor.CacheAspectSupport start with: 381 line code : ``return wrapCacheValue(method, cache.get(key, () -> unwrapReturnValue(invokeOperation(invoker))));`` 4. stuck in an endless loop ![560ef7318901bfe1194e708770be75b](https://user-images.githubusercontent.com/25220333/130550905-1c3d4785-9657-4424-8907-b37721d22cf3.png)","closed","status: invalid,","250846434","2021-08-24T03:25:11Z","2021-08-24T11:21:42Z"
"","27362","resttemplate can't invoke webflux service","**Affects:** \ all version  the webflux service can invoke with the content-type without the charset parameter, when invoke with charset it response 504,  even though i was special the content-type without the charset, the client add the charset automatic  the code is here ![image](https://user-images.githubusercontent.com/5616997/132179899-4a5f7bfa-b318-46b2-86c4-35942fcae57d.png) ![image](https://user-images.githubusercontent.com/5616997/132179927-7daad525-4bf5-4169-8f26-736ae78c6dd3.png)  there is no option to config this behavior, so the request aways failed","closed","status: invalid,","cjdxhjj","2021-09-06T07:50:31Z","2021-09-06T12:23:57Z"
"","27121","Jetty10RequestUpgradeStrategy use an old jetty 9 class HandshakeRFC6455","**Affects:** \ 5.3.8 ---  spring framework version 5.3.8  jetty version 10.0.5  jetty dependency ```                      org.eclipse.jetty             jetty-server                               org.eclipse.jetty             jetty-webapp                               org.eclipse.jetty             jetty-servlet                               org.eclipse.jetty.websocket             websocket-jetty-server          ```  class `Jetty10RequestUpgradeStrategy` use an old jetty 9 class `HandshakeRFC6455` following ``` private static final String[] SUPPORTED_VERSIONS = new String[] { String.valueOf(HandshakeRFC6455.VERSION) }; ```  the code should be  ``` private static final String[] SUPPORTED_VERSIONS = new String[] { ""13"" }; ```","closed","type: enhancement,","leonchen83","2021-07-02T04:24:29Z","2021-07-09T19:35:01Z"
"","27120","NoSuchMethodError when invoke JettyWebSocketSession.getRemoteAddress in jetty 10","**Affects:** \ 5.3.8 ---   spring framework version  5.3.8  jetty version 10.0.5  jetty dependency ```                      org.eclipse.jetty             jetty-server                               org.eclipse.jetty             jetty-webapp                               org.eclipse.jetty             jetty-servlet                               org.eclipse.jetty.websocket             websocket-jetty-server          ``` NoSuchMethodError when invoke `JettyWebSocketSession.getRemoteAddress` in jetty 10. ``` 	@Override 	public InetSocketAddress getRemoteAddress() { 		checkNativeSessionInitialized(); 		return getNativeSession().getRemoteAddress(); 	} ``` in jetty 10 `getNativeSession().getRemoteAddress();` return `SocketAddress` not `InetSocketAddress` so we should cast `SocketAddress` to `InetSocketAddress` the method should be  ``` 	@Override 	public InetSocketAddress getRemoteAddress() { 		checkNativeSessionInitialized(); 		return (InetSocketAddress)getNativeSession().getRemoteAddress(); 	} ```","closed","type: bug,","leonchen83","2021-07-02T04:14:44Z","2021-07-12T14:04:43Z"
"","27784","Declare serialVersionUID on DefaultAopProxyFactory","**Affects:** \  the class org.springframework.aop.framework.DefaultAopProxyFactory had implements Serializable , but did't added serialVersionUID,  lead a deserialization exception  please add serialVersionUID to this class  the problem reference: https://github.com/apache/skywalking/issues/2768 ---","closed","type: enhancement,","xhh1314","2021-12-08T11:41:05Z","2021-12-14T16:02:48Z"
"","27149","WebClient: Only one connection receive subscriber allowed","**Affects:** \  I‘m using webclient, and I need to override the response header. ``` @RequestMapping(""/token"") public Mono getToken() {     return wechatService.getWebAuthAccessToken()              .switchIfEmpty(Mono.error(new BizErrorException(""xxxx failed""))); }   public Mono getWebAuthAccessToken() {     commonWebClient.get()     .uri(""xxxxxx"")     .queryParam(""xxx"", xxxx)     .exchangeToMono(clientResponse -> clientResponse.mutate()         // override the content type         .headers(headers -> headers.remove(HttpHeaders.CONTENT_TYPE))         .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)         // copy the body as bytes with no processing         .body(clientResponse.body(BodyExtractors.toDataBuffers()))         .build()         .bodyToMono(WxGetAccessTokenResponse.class))     .onErrorReturn(xxx) } ```  I got error: `Only one connection receive subscriber allowed` ``` java.lang.IllegalStateException: Only one connection receive subscriber allowed. 	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:183) ~[reactor-netty-core-1.0.7.jar:1.0.7] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ Body from GET https://xxxxx [DefaultClientResponse] 	|_ checkpoint ⇢ Body from GET https://xxxxx [DefaultClientResponse] 	|_ checkpoint ⇢ Handler xxxx.controller.TokenController#getToken() [DispatcherHandler] [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ HTTP GET ""xxxxxx"" [ExceptionHandlingWebHandler] Stack trace: 		at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:183) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:144) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:62) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:199) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onSubscribeInner(MonoFlatMapMany.java:150) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onNext(MonoFlatMapMany.java:189) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.SerializedSubscriber.onNext(SerializedSubscriber.java:99) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onNext(FluxRetryWhen.java:173) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:160) ~[reactor-core-3.4.6.jar:3.4.6] 		at reactor.netty.http.client.HttpClientConnect$HttpIOHandlerObserver.onStateChange(HttpClientConnect.java:415) ~[reactor-netty-http-1.0.7.jar:1.0.7] 		at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:654) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.netty.resources.DefaultPooledConnectionProvider$DisposableAcquire.onStateChange(DefaultPooledConnectionProvider.java:202) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.netty.resources.DefaultPooledConnectionProvider$PooledConnection.onStateChange(DefaultPooledConnectionProvider.java:458) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:629) ~[reactor-netty-http-1.0.7.jar:1.0.7] 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.7.jar:1.0.7] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1368) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1234) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1280) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-all-4.1.65.Final.jar:4.1.65.Final] 		at java.base/java.lang.Thread.run(Thread.java:836) ~[na:na]  ```  But when I wrote code like this, everything works fine. ``` public Mono getWebAuthAccessToken() {     commonWebClient.get()     .uri(""xxxxxx"")     .exchange() // deprecated     .flatMap(clientResponse -> ClientResponse.from(clientResponse) // deprecated         // override the content type         .headers(headers -> headers.remove(HttpHeaders.CONTENT_TYPE))         .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)         // copy the body as bytes with no processing         .body(clientResponse.body(BodyExtractors.toDataBuffers()))         .build()         .bodyToMono(WxGetAccessTokenResponse.class))     .onErrorReturn(xxx) } ``` But the `exchange()` and `ClientResponse.from()` method are deprecated.","closed","status: invalid,","aboutZZ","2021-07-09T03:44:20Z","2021-07-11T04:00:48Z"
"","27617","Spring Framework Vulnerable to Log File Injection via Insufficient Input Validation","**Affects:** \  I used Synopsys security vulnerability check tool yesterday  Spring Framework 5.3.10 as follows  We have confirmed that there is a security vulnerability. I want to confirm the authenticity of the security vulnerability.  Black Duck Security Advisory Spring Framework Vulnerable to Log File Injection via Insufficient Input Validation ( BDSA-2021-3236 )  Description Spring Framework is vulnerable to log file injection due to the insufficient validation of user input in an undisclosed component. An attacker could leverage this issue in order to add arbitrary entries to a log file which could impact both the integrity issues and performance issues.","closed","status: invalid,","CHAEJINYOUNG","2021-10-28T03:46:58Z","2021-10-28T05:51:21Z"
"","27029","spring aop advise not applied for methods invoked from same class","**Affects:** \  2.0.5.RELEASE ---  ## Issue  When a method is annotated for Spring AOP, if the method is invoked from the spring bean, the advise would be applied.  ``` class ABC{        @TimeIt     public void processABC(String date) {     }      public void processABC() {      String date = LocalDate.now(zoneId).toString();       return processsABC(date)_;    } } ```  if processABC is directly invoked from the bean, the advise would be applied ``` abc.processABC(""2021-06-07""); //the advise of TimeIt would be invoked. ```   However, if the method is invoked by another method in the same class, the advise is not applied. ``` abc.processABC(); //which subsequently call processABC(String date) //however the advise of TimeIt is not invoked. ```","closed","for: stackoverflow,","1zg12","2021-06-07T04:01:45Z","2021-06-07T06:02:21Z"
"","27663","The spring-framework 5.3.12 does not support the servicecomb address like cse://appId:microserviceName/xxx/xxxx/xxxx","**Affects:** \  --- When I using RestTemplate to send a servicecomb request like ""cse://appId:microserviceName/xxx/xxxx/xxxx"" after upgrading spring-framework from 5.2.15 to 5.3.12, NumberFormatException is reported. That's because the microservice name after the colon is parsed to a port.  Caused by: java.lang.NumberFormatException: For input string: ""Aserver"" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[?:1.8.0_212] at java.lang.Integer.parseInt(Integer.java:580) ~[?:1.8.0_212] at java.lang.Integer.parseInt(Integer.java:615) ~[?:1.8.0_212] at org.springframework.web.util.HierarchicalUriComponents.getPort(HierarchicalUriComponents.java:195) ~[spring-web-5.3.12.jar:5.3.12] at org.springframework.web.util.HierarchicalUriComponents.toUriString(HierarchicalUriComponents.java:482) ~[spring-web-5.3.12.jar:5.3.12] at org.apache.servicecomb.provider.springmvc.reference.CseUriTemplateHandler.createUri(CseUriTemplateHandler.java:79) ~[provider-springmvc-2.1.5.jar:2.1.5] at org.apache.servicecomb.provider.springmvc.reference.CseUriTemplateHandler.expandInternal(CseUriTemplateHandler.java:75) ~[provider-springmvc-2.1.5.jar:2.1.5] at org.springframework.web.util.AbstractUriTemplateHandler.expand(AbstractUriTemplateHandler.java:111) ~[spring-web-5.3.12.jar:5.3.12] at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:710) ~[spring-web-5.3.12.jar:5.3.12]","closed","status: invalid,","Jefferson-Sun","2021-11-10T08:48:15Z","2021-11-11T09:02:12Z"
"","26922","Invalid packet in WebSocket ping","**Affects:** \  ---  When setting server ping in Spring WebSocket, a text packet (opcode 1) with payload '\n' (0xA) is sent to the client. As a result the client doesn't understand the packet and doesn't send pong. I think the packet opcode should be 0x9 (ping).  Background info:  There was also another issue: ping sent by client does not update session timeout (doesn't push timeout timestamp further). I'm getting session expiration despite of client sending pings. But because of this problem, I'm now trying out server pings.   My session maximum idle interval is 30 seconds.  I'm establishing the session through a separate REST login endpoint. I use the received session cookie in the header when establishing a WebSocket connection. I've tried using embedded Hazelcast session repository and embedded Redis, too.  This is my WebSocket configuration:  ```java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractSessionWebSocketMessageBrokerConfigurer {     @Override     public void configureMessageBroker(MessageBrokerRegistry config) {         ThreadPoolTaskScheduler pingScheduler = new ThreadPoolTaskScheduler();         pingScheduler.setPoolSize(1);         pingScheduler.setThreadNamePrefix(""wss-heartbeat-thread-"");         pingScheduler.initialize();          config.enableSimpleBroker(""/topic"").setHeartbeatValue(new long[]{10000, 0}).setTaskScheduler(pingScheduler);         config.setApplicationDestinationPrefixes(""/messages"");         config.setUserDestinationPrefix(""/user"");     }      @Override     protected void configureStompEndpoints(StompEndpointRegistry registry)     {         registry.addEndpoint(""/stomp"").withSockJS();     }      @Override     public void configureClientInboundChannel(ChannelRegistration registration) {         super.configureClientInboundChannel(registration);         registration.interceptors(new TopicSubscriptionInterceptor());     } } ```","closed","in: web,","mmikkone","2021-05-10T08:41:44Z","2021-09-07T15:54:38Z"
"","26924","HttpServletRequest doesn't contain attribute UrlPathHelper.PATH_ATTRIBUTE in AccessDecisionVoter.vote() method","**Affects:** \  ---  When register a customer `AccessDecisionVoter` in  a project that using springboot 2.4.5, I found that `HttpServletRequest` doesn't contain attribute `UrlPathHelper.PATH_ATTRIBUTE` in `AccessDecisionVoter.vote()` method.  ```java public class AbacAccessVoter implements AccessDecisionVoter {  	@Override 	public boolean supports(ConfigAttribute attribute) { 		return true; 	}  	@Override 	public boolean supports(Class clazz) { 		return true; 	} 	 	@Override 	public int vote(Authentication authentication, FilterInvocation object, Collection attributes) { 		FilterInvocation fi = (FilterInvocation) object;		 		System.out.println(fi.getHttpRequest().getAttribute(UrlPathHelper.PATH_ATTRIBUTE)); // this code get result : null  		return AccessDecisionVoter.ACCESS_GRANTED; 	}  } ```  But `HttpServletRequest` can get value in the Controller method, For example:  ```java @Controller @RequestMapping(""/test"") public class TestController { 	 	@GetMapping(""/demo"") 	@ResponseBody 	public String demo(HttpServletRequest request, Model model) throws Exception { 		System.out.println(request.getAttribute(UrlPathHelper.PATH_ATTRIBUTE));  // this code can get result : /test/demo 		return ""true""; 	} } ```","closed","status: declined,","litao11046","2021-05-10T11:56:38Z","2021-05-26T09:24:38Z"
"","27515","Publish event after transaction completed in Spring webflux","**Affects:** \  ---  Spring webflux does not support @TransactionalEventListener to publish event after transaction completed. So what i need to do to publish event only when transaction completed in Spring webflux?","open","in: web,","hoangshiva","2021-10-03T15:02:53Z","2021-11-08T11:37:36Z"
"","27152","spring (not spring boot) doesn't respect jackson settings in application.properties","**Affects:** \  ---  see https://stackoverflow.com/questions/68310198/difference-in-conversion-between-spring-and-spring-boot  test script  application.properties:     spring.jackson.serialization.write_dates_as_timestamps=false  Myspring.java:     import java.util.Date;     import org.springframework.stereotype.Controller;     import org.springframework.web.bind.annotation.GetMapping;     import org.springframework.web.bind.annotation.ResponseBody;     import org.springframework.web.servlet.config.annotation.EnableWebMvc;      @Controller     @EnableWebMvc     public class Myspring {          @GetMapping(path=""/oops"")          public @ResponseBody Date oops () {                return new Date();          }     }   expected: curl http://localhost:8080/oops  ""2021-07-05T18:22:43.364+00:00""  actual: curl http://localhost:8080/oops 1625506637687","closed","for: stackoverflow,","aliber4079","2021-07-10T16:26:39Z","2021-07-11T06:09:30Z"
"","27838","Spring PathMatchConfigurer#setUseSuffixPatternMatch method is Deprecated, how to enable it?","**Affects:** \  ---  In 5.3.13, Spring PathMatchConfigurer#setUseSuffixPatternMatch method is Deprecated and default to be false, but we need this to be enabled, is there a solution or workaround?","closed","status: invalid,","RayBan2012","2021-12-20T02:07:32Z","2022-01-04T09:11:42Z"
"","27467","Non-escaped closing curly brace in RegEx results in initialization error on Android","**Affects:** \  ---  I am trying to use `UriComponentsBuilder.newInstance() `in my android application. But I keep getting this exception upon initialization. This happens starting from version 5.2.4.RELEASE.  ``` java.lang.ExceptionInInitializerError         at org.springframework.web.util.UriComponentsBuilder.newInstance(UriComponentsBuilder.java:172)  Caused by: java.util.regex.PatternSyntaxException: Syntax error in regexp pattern near index 96     ^(([^:/?#]+):)?(//(([^@\[/?#]*)@)?(\[[\p{XDigit}:.]*[%\p{Alnum}]*]|[^\[/?#:]*)(:(\d*(?:\{[^/]+?})?))?)?([^?#]*)(\?([^#]*))?(#(.*))? ```","closed","in: core,","manuel2295","2021-09-25T15:56:32Z","2021-10-01T14:57:39Z"
"","27682","expose 'highlight_sql' Hibernate option to show colourized SQL statements in console","**Affects:** \  ---  Hibernate exposed the fancy 'SQL highlight' feature since v5.5 (see the PR at https://github.com/hibernate/hibernate-orm/pull/3553). It uses ANSI escape codes to make the logged SQL statements more readable. Below is an example (the SQL keywords are highlighted with special colors)    It seems a good idea to expose this Hibernate option, together with 'show_sql' and 'format_sql' options we have exposed already.","open","in: data,","NathanQingyangXu","2021-11-12T20:22:52Z","2021-11-15T17:41:15Z"
"","27111","AbstractMessageConverterMethodProcessor unconditional exception logic","**Affects:** \  ---  1. I have set up the /actuator/prometheus endpoint 2. It returns 500 error in any cases 3. the exception is here https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java#L306  you can see, that if the body is not null then the code will produce the exception in any case...  obviously, it is a bug, isn't it?  PS I checked it in debugger - the body contains metrics of my application as I expected, but I can't get it due to unconditional exception throwing:  ![image](https://user-images.githubusercontent.com/6061777/123946341-c4d52180-d9a7-11eb-95c2-7d1576739b7c.png)","closed","status: invalid,","bogdanovmn","2021-06-30T10:37:47Z","2021-06-30T18:18:14Z"
"","27060","Could not refresh JMS Connection for destination 'wfQueue', authentication failed javax.jms.JMSSecurityException: authentication failed","**Affects:** \  ---   When I'm trying to listen through command line it works fine, but using Spring Boot it throws below error:  ERROR [org.springframework.jms.listener.DefaultMessageListenerContainer] (DefaultMessageListenerContainer-1) Could not refresh JMS Connection for destination 'wfQueue' - retrying using FixedBackOff{interval=5000, currentAttempts=44, maxAttempts=unlimited}. Cause: authentication failed javax.jms.JMSSecurityException: authentication failed This is my app class  @SpringBootApplication(scanBasePackages = {""com.source.lbm""}) public class EMSConsumerApp {      public static main(String[] args){         run(EMSConsumerApp.class, args);              } } This class configures definitions for JMS consumer  @EnableJMS @EnableTransactionManagement public abstract class SubscriberConfiguration {     private final String url;     private final String clientId;     private final String username;     private final String password;      public SubscriberConfiguration(String url, String clientId, String username, String password) {         this.url = url;         this.clientId = clientId;         this.username = username;         this.password = password;     }          @Bean     public DefaultJmsListenerContainerFactory jsmListenerContainerFactory(ConnectionFactory connectionFactory) {         DefaultJmsListenerContainerFactory containerFactory = new DefaultJmsListenerContainerFactory();         containerFactory.setconnectionFactory(connectionFactory);         containerFactory.setPubSubDomain(true);         containerFactory.setSubscriptionDurable(true);         containerFactory.setSessionTransacted(true);         containerFactory.setAutoStartup(true);              return connectionFactory;     }              @Bean     public ConnectionFactory jmsConnectionFactory() throws JMSException{         TibjmsXATopicConnectionFactory connectionFactory = new TibjmsXATopicConnectionFactory();         connectionFactory.setServerUrl(url);         connectionFactory.setClientId(clientId);         connectionFactory.setUserName(username);         connectionFactory.setUserPassword(password);         return connectionFactory;             }          } This sets configs for a subscriber  @Configuration public class LbmSubConfiguration extends SubscriberConfiguration {      public LbmSubConfiguration(         @Value(""${ems.lbm.sub.url}"") String emsUrl;         @Value(""${ems.lbm.sub.clientId}"") String subClientId;         @Value(""${ems.lbm.sub.username}"") String subUsername;         @Value(""${ems.lbm.sub.password}"") String subPasword) {     super(emsUrl,subClientId,subUsername,subPasword);     } } This class listenes to ems and consumes messages  @Component public class LbmEventConsumer {     @JmsListener(destination = ""${ems.lbm.sub.destination}"", containerFactory = ""jmsListenerContainerFactory"")     public void onMessage(BytesMessage message){       System.out.println(""Message "" + message);     } } Since these credentials work fine on command line there shouldn't be an issue with credentials. Possibly it's because I'm missing some configs (not sure though). Can you please help me figure out what's wrong with this?","closed","for: stackoverflow,","sksahitya","2021-06-14T17:07:06Z","2021-06-15T05:59:57Z"
"","27394","Seems like XmlBeans has risen from the grave - so should XmlBeansMarshaller be reintroduced?","**Affects:** \  ---   Seems like XmlBeansMarshaller was first deprecated and then removed. But now that XmlBeans seems to have risen from the grave, should XmlBeansMarshaller then also be reintroduced?","closed","status: duplicate,","rasmuslund","2021-09-13T09:27:36Z","2021-09-13T13:16:18Z"
"","27059","Support Inject middleware in Spring Webflux","**Affects:** \  ---   I am trying to define all cross cutting concerns i.e exception, authorisation etc. in a project/repo and inject in more than one separate and independent spring-webflux project. Can anyone suggest how to accomplish this?","closed","for: stackoverflow,","ghost","2021-06-14T10:43:52Z","2021-06-14T12:30:58Z"
"","27364","Expose verify method in UriComponent interface","**Affects:** \  ---   Hi there,  I have a small enhancement to propose - how about exposing [verify()](https://github.com/spring-projects/spring-framework/blob/9cf8cca96d9c8280eac87595a7933aa338ec5599/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java#L376) method in the interface?  Use case: say, there is a webhooks service that exposes API to create webhoook subscriptions providing URLs; working with different systems some do provide already encoded URL and others expect URL yet to be encoded. Having the kind of method in interface would allow validating provided URL string before building [UriComponent](https://github.com/spring-projects/spring-framework/blob/9cf8cca96d9c8280eac87595a7933aa338ec5599/spring-web/src/main/java/org/springframework/web/util/UriComponents.java#L48).  Workaround: try to build UriComponent [w/o encoding](https://github.com/spring-projects/spring-framework/blob/9cf8cca96d9c8280eac87595a7933aa338ec5599/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L471) and catch IAE and build with encoding along the way. Not perfect.  ```java  private UriComponents buildAndValidateUriComponents(String url, String sig) {         var builder = UriComponentsBuilder.fromHttpUrl(url); // https://example.com/?code=56fJrWyfsNa5alHt95mc5S6ViiUUKYuTQUmGImaoWl8eTartOitEMQ==         try {             return builder.build(true);         } catch (IllegalArgumentException ex) {             return builder.build().encode();         }  } ```  Wdyt?","open","in: web,","rilaby","2021-09-06T12:13:16Z","2021-11-10T12:17:58Z"
"","27202","Webflux does not serve static files from default locations","**Affects:** \  ---   Have a project, docs say that /public /static /resources /META-INF/resources are all by default checked for static resources.  with what i have in this repo https://github.com/gerethd/webflux-example they do not and a 404 is received.  I have a copy of the static files in each of the specified folders on each level of the project that would even remotely make sense.  i.e. the files exist inside  ``` ./resources/index.html ./resources/resources/index.html ./resources/META_INF/resources/index.html ./resources/public/index.html ./resources/static/index.html ./META_INF/resources/index.html ./src/main/resources/index.html ./src/main/resources/resources/index.html ./src/main/resources/META_INF/resources/index.html ./src/main/resources/public/index.html ./src/main/resources/static/index.html ./src/main/META_INF/resources/index.html ./src/main/public/index.html ./src/main/static/index.html ./public/index.html ./static/index.html ```  The intended functionality is when i run this project and go to http://localhost:8080/index.html I should get the index page but instead i get a 404.  Referenced documentation: https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.developing-web-applications.spring-webflux.static-content","closed","status: invalid,","gerethd","2021-07-22T21:01:14Z","2021-07-22T22:22:59Z"
"","27706","Expose getHandlerMapping() as public for interceptor overrides","**Affects:** \  ---   After [Spring commit ](https://github.com/spring-projects/spring-framework/commit/1356bd4359ee74a5c93630349d76ced142b994d9) by default all interceptors will applied to static resource which result in pollute application's log a lot by un-related interceptors warnings.    In [resourceHandlerMapping](https://github.com/spring-projects/spring-framework/blob/1356bd4359ee74a5c93630349d76ced142b994d9/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java#L474) the API provided to override is addResourceHandlers. Since registry.[getHandlerMapping](https://github.com/spring-projects/spring-framework/blob/1356bd4359ee74a5c93630349d76ced142b994d9/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ResourceHandlerRegistry.java#L137)() is protected method there is no way to override default behavior, such like override setInterceptors().   Is there any concern about why don't make getHandlerMapping() as public method and enable users override the default behavior?","closed","status: declined,","hangdong123","2021-11-19T19:17:26Z","2021-12-02T08:42:48Z"
"","27850","org.gradle.api.artifacts.result.ComponentSelectionReason.getDescription()Ljava/lang/String;","**Affects:** \  ---","closed","status: invalid,","cnet2014","2021-12-23T12:52:56Z","2021-12-23T13:04:48Z"
"","27843","Are there any tasks that novices can participate in?","**Affects:** \  ---","closed","","li-xiao-shuang","2021-12-22T04:55:07Z","2022-01-05T11:28:37Z"
"","27831","Cors Preflight request without auth header started giving 403 after upgrade to spring framework 5.3.13","**Affects:** \  ---","closed","status: invalid,","skpandey91","2021-12-17T07:55:44Z","2022-01-06T15:05:40Z"
"","27655","Hi Team, how can i run spring core apps *without importing jar* but by using directly spring framework folder so i can see implementation  also side by side please help","**Affects:** \  ---","closed","for: stackoverflow,","ilewies","2021-11-09T07:24:38Z","2021-11-09T07:50:26Z"
"","27329","@Valid + @JsonView is not working together.","**Affects:** \  ---","closed","for: stackoverflow,","mupezzuol","2021-08-27T19:21:01Z","2021-08-27T20:36:42Z"
"","27235","websocket.js:6 WebSocket connection to 'ws://localhost:8080/test-info/442/nlflwasu/websocket' failed: Error during WebSocket handshake: Unexpected response code: 200","**Affects:** \  ---","closed","for: stackoverflow,","ghj1040110333","2021-08-01T23:26:51Z","2021-08-02T06:13:33Z"
"","27690","Update ServletContainerInitializer filename with old `javax` prefix to `jakarta`.","**Affects:** 6.0.0-SNAPSHOT  When implementing the `WebApplicationInitializer` interface, the implementation is never called. This was caused because [this file](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/resources/META-INF/services/javax.servlet.ServletContainerInitializer) is still named with the old `javax` namespace.   As a workaround, I just added the file with the `jakarta.servlet.ServletContainerInitializer` to my app.  Found that problem while working with Spring Security samples that use the [custom `WebApplicationInitializer` implementation](https://github.com/spring-projects/spring-security/blob/e398fbf2a7585c745a6a8d9d4ae6e980dff33462/web/src/main/java/org/springframework/security/web/context/AbstractSecurityWebApplicationInitializer.java#L74).","closed","type: task,","marcusdacoregio","2021-11-16T18:41:03Z","2021-11-17T11:41:14Z"
"","27868","Support Bean Validation in record constructors","**Affects:** 6.0.0-M1  ---   I tried to add bean validation annotations on a record type, but it does not work as expected.  ```java public record CreatePostCommand(@NotEmpty @Size(min = 5) String title, @NotEmpty String content) { } ```  And write a controller test with `MockMvc`.  ```java   @Test   public void testCreatePost_validationFailed() throws Exception {       var id = UUID.randomUUID();       when(this.posts.save(any(Post.class)))               .thenReturn(Post.builder().id(id).title(""test"").build());        var data = new CreatePostCommand(""a"", ""a"");       this.rest.perform(post(""/posts"").content(objectMapper.writeValueAsBytes(data)).contentType(MediaType.APPLICATION_JSON))               .andExpect(status().isUnprocessableEntity())               .andExpect(jsonPath(""$.code"", is(""validation_failed"")));        verify(this.posts, times(0)).save(any(Post.class));       verifyNoMoreInteractions(this.posts);   } ```  The test failed because the response always returned 201 status instead of the expected 422.","open","type: enhancement,","hantsy","2022-01-01T05:10:59Z","2022-06-07T13:40:33Z"
"","27487","AbstractJpaVendorAdapter refers to JPA 2.1 but requires JPA 3.0","**Affects:** 6.0 snapshots  `AbstractJpaVendorAdapter` refers to JPA 2.1 but it now requires JPA 3.0. Similarly, `HibernateJpaVendorAdapter` describes support for Hibernate 5.2, 5.3, and 5.4. I believe it now requires a minimum of 5.5 as that's the earliest version that has `-jakarta` variants of its modules and supports JPA 3.0.","closed","type: task,","wilkinsona","2021-09-28T16:11:30Z","2021-09-28T17:10:59Z"
"","27751","Extending CachingConfigurerSupport results in at least one log message about not being eligible for full post-processing","**Affects:** 5.3.x  This was originally reported in a [Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/28840). While diagnosing the problem, I observed that even when a `CachingConfigurerSupport` has no dependencies, a log message about being ineligible for full post-processing is still logged. I discussed this with @snicoll and he asked me to raise an issue.  [This minimal Boot app](https://github.com/spring-projects/spring-framework/files/7625917/caching-post-processing.zip) can be used to reproduce the problem:  ``` $ ./gradlew bootRun  > Task :bootRun    .   ____          _            __ _ _  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.5.7)  2021-11-30 13:06:48.868  INFO 46167 --- [           main] c.e.d.CachingPostProcessingApplication   : Starting CachingPostProcessingApplication using Java 1.8.0_302 on wilkinsona-a01.vmware.com with PID 46167 (/Users/awilkinson/dev/workspaces/spring-projects/spring-boot/2.6.x/caching-post-processing/build/classes/java/main started by awilkinson in /Users/awilkinson/dev/workspaces/spring-projects/spring-boot/2.6.x/caching-post-processing) 2021-11-30 13:06:48.869  INFO 46167 --- [           main] c.e.d.CachingPostProcessingApplication   : No active profile set, falling back to default profiles: default 2021-11-30 13:06:49.214  INFO 46167 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'cachingPostProcessingApplication.CachingConfig' of type [com.example.demo.CachingPostProcessingApplication$CachingConfig$$EnhancerBySpringCGLIB$$4121c366] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) 2021-11-30 13:06:49.372  INFO 46167 --- [           main] c.e.d.CachingPostProcessingApplication   : Started CachingPostProcessingApplication in 0.719 seconds (JVM running for 0.962)  BUILD SUCCESSFUL in 1s 4 actionable tasks: 4 executed ```  Note the third INFO message:  ``` 2021-11-30 13:06:49.214  INFO 46167 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'cachingPostProcessingApplication.CachingConfig' of type [com.example.demo.CachingPostProcessingApplication$CachingConfig$$EnhancerBySpringCGLIB$$4121c366] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) ```","closed","in: core,","wilkinsona","2021-11-30T13:08:14Z","2021-12-15T10:00:38Z"
"","27172","Disable allowCircularReferences on a bean-by-bean basis","**Affects:** 5.3.x  In Spring Boot we have some bean factory post-processors that ensure that a bean that initialises the database (such as Flyway or Liquibase) is depended on by beans that access the database (such as JdbcTemplate or EntityManagerFactory). We do this by adding bean names to the definition's `dependsOn`.  We've recently had [an issue](https://github.com/spring-projects/spring-boot/issues/27231) raised by a user who was trying to use JPA witinh a custom Liquibase changeset implementation. To our surprise, this works some of the time as the bean factory's eager caching of a bean allows it to break the cycle. I say some of the time as the breaking of the cycle was successful in the user's attempt at reproducing the problem but it does not succeed in their actual application.  This inconsistent behaviour coupled with our desire to guarantee that the database will have been initialized before anything tries to access it resulted in me wondering if it would be possible to disable the eager caching of a bean on a bean-by-bean basis. Perhaps via an attribute on the bean definition that we could set at the same time as we're configuring the dependencies?  We may also experiment with settings `allowCircularReferences` to `false` by default, similar to what we did earlier in 2.x where we disabled bean definition overriding by default.","open","in: core,","wilkinsona","2021-07-14T15:39:30Z","2021-11-10T12:10:48Z"
"","27796","Provide a variant of ListableBeanFactory.findAnnotationOnBean(String, Class) that does not initialize factory beans","**Affects:** 5.3.x  `DefaultListableBeanFactory`'s implementation of `findAnnotationOnBean` calls `getType(String)` which allows factory bean init. Assuming that it's intentional for `findAnnotationOnBean` to initialize factory beans, would it be possible to overload the method with a variant that does not do so? This would help to fix https://github.com/spring-projects/spring-boot/issues/28977 where we're looking for an annotation in a bean factory post-processor.","closed","type: enhancement,","wilkinsona","2021-12-10T12:45:23Z","2022-01-25T22:21:39Z"
"","27323","Support `Result` return types for `@Transactional` Kotlin functions","**Affects:** 5.3.9 (and earlier versions)   Motivation: Error Handling is a controversial topic. Java primarily uses exceptions to show that something went wrong. For database interactions, Spring provides the `@Transactional` Annotation so the configured transaction manager automatically rolls back any pending changes whenever an exception is thrown. It also supports reactive execution flows (Mono/Flow) and Kotlin coroutines.  Now the following is the controversial part: Do you show the possibility of something going wrong in the declaration of the function, or do you hide it and only refer to possible failure modes in the documentation? Java gives you a choice: - Use **checked exceptions** which also show up in the function declaration via the `throws` declaration. Callers of the function are **forced** to either handle the exception or to pass it up to their caller (and retain the `throws` declaration in case the exception is not wrapped in an unchecked exception - Use **unchecked exceptions**, which do not show up in the function declaration. Developers **have to remember** that somewhere up the stack the exception has to be handled in a graceful way if they want to keep their application running.  From my personal experience, checked exceptions were looked upon as verbose and annoying in the 2000-2015 timeframe, but have seen a resurgence in recent years to make identifying potentially failing functions easier. This is especially true in other communities with functional programming influences, e.g. Typescript, Haskell, Scala or Rust. Since these languages don't have checked exceptions, they use the **return type** of a function to signify potentially failing operations, often using something akin to the `Either` Monad (Also known as `Result` in Rust). As an example: In Rust a `Result` shows that the function either completes without an error, returning a `MyEntity` value, or yields a `DomainSpecificError`, which can then be handled (or passed further up the stack).  Kotlin does not feature checked exceptions. It does however include a `Result` type in its standard library. Sadly, it does not allow specifying an explicit type for the error case (It just requires the error value to be a `Throwable`). There is also another library which implements a Result type for Kotlin, which does allow the user to specify the error type (https://github.com/michaelbull/kotlin-result/), which is what we use in our projects.  In recent years, Spring has added many Kotlin-specific features / enhancements. I'd love to be able to mark my Kotlin functions which return a Result (be it the stdlib version or the version from Michael Bull) with `@Transactional` and have pending DB changes rolled back in case the function returns the error variant of the respective Result type. There is however no consensus in the Kotlin community regarding error handling, at least as far as I know. Some people use regular unchecked exceptions, some people use the stdlib Result, some people use the Result from Michael Bull.  To sum it all up, here are my final questions: - What is your opinion on introducing a compatibility layer between `@Transactional` and a Result type in general, in case a consensus is found in the Kotlin community? - Could someone point me in the right direction so I could try to implement this myself as a proof of concept, e.g. as an aspect which is applied to Bean functions marked as `@Transactional` which return a `Result`? The documentation on Spring AOP features I have found online isn't the most helpful for someone who hasn't dipped his toes into AOP territory yet.","closed","type: enhancement,","Nimelrian","2021-08-25T13:31:33Z","2021-12-17T09:28:04Z"
"","27458","@MessageMapping is not registered when bean is created by hand","**Affects:** 5.3.9  I was messing with RSocket and have noticed that if I created bean with `@MessageMapping` with `@Bean` in `@Configuration` it wasn't registered but it works just fine if I add `@Controller` and let component scan create it.  I think both ways should work the same way.","open","in: messaging,","delor","2021-09-23T14:19:27Z","2021-11-10T09:11:32Z"
"","27452","Spring @AliasFor not working for @Profile annotation","**Affects:** 5.3.9  --- > Environment: Kotlin 1.5.30, SpringBoot 2.5.4(Spring 5.3.9)  I'm trying to create a composed annotation to simplify similar template annotation codes. The annotation class is like this:  ```Kotlin @Profile(""default"")   //NOTE1 annotation class ProfileAware(     @get: AliasFor(annotation = Profile::class, attribute = ""value"")     val profiles: Array,     //properties delegated for other annotations ) ```  expected usage:  ```Kotlin @Component @ProfileAware(profiles = [""dev""]) //NOTE2 class TheBean ```  But  after the application starts, TheBean is not registered as expected.   After multiple times tries and investigation(For more detail see [The StackOverflow Question](https://stackoverflow.com/questions/69280914/spring-aliasfor-not-working-for-profile-annotation)), it looks like that spring just parses **original hardcoded value** (`default`, at *NOTE1* in above code snippet), but what I want is the **dynamic value from the call place**(at *NOTE2*).","closed","in: core,","Muyangmin","2021-09-23T06:14:05Z","2021-11-23T07:26:49Z"
"","27232","kotlinx.serialization not used for serializing collections","**Affects:** 5.3.9  ---  With kotlinx.serialization and Jackson (because of actuator) on the classpath, if a collection such as a `List` is serialized as _the_ response, Jackson will be used instead of kotlinx.serialization. This can cause problems if using `@SerialName`  since Jackson will ignore those.  This only applies if the collection itself is intended to be the response body, so if a `@Serializable` class _contains_ a collection it will still be serialized normally using kotlinx.serialization.","open","in: web,","dellisd","2021-07-30T18:21:15Z","2021-11-12T14:21:13Z"
"","27254","HTTP requests with malformed form url encoded data result in HTTP 500, not 400","**Affects:** 5.3.9  ---  HTTP requests with malformed form url encoded data result in HTTP 500, not 400. I observed that in a WebFlux application when form data is mapped into my object using built-in mapping or when accessed via `ServerWebExchange.formData`. Exception is raised in [FormHttpMessageReader](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/codec/FormHttpMessageReader.java#L168-L169) and maps to HTTP 500. It should be 4xx error as the input is malformed  Example HTTP requests body causing problems: ``` username=test%%%invalid ```","open","in: web,","tmszdmsk","2021-08-10T05:12:14Z","2021-11-08T11:37:35Z"
"","27257","Still no reliable way to serve single-page applications directly from Spring?","**Affects:** 5.3.8  --- The problem was previously discussed in #21328, but as @danbim pointed out, it's not a reliable solution as it overrides other routes in the application.  I tried to annotate the static resource bean with `@Order(Ordered.LOWEST_PRECEDENCE)`, but that seems to only make it the lowest of the annotated beans, not lowest of all beans like it would need to be for this to work. I checked the documentation for ways to specify a custom error page instead of the white label one, and the only thing I could find was a static `404.html` file, but as far as I can tell there is no way to change the status to `200`.  This has been asked for countless of times on StackOverflow and similar places, and the answers range from completely wrong to completely ridiculous, like using regexes or explicit routes to catch everything that the front end might conceivably want to handle.   I'm suggesting that Spring as a back-end for SPAs is a common enough use case to warrant a reliable solution.","open","in: web,","gschjetne","2021-08-11T07:51:10Z","2021-11-10T11:55:34Z"
"","27247","Error with formatMapping method in AbstractMethodMessageHandler.java","**Affects:** 5.3.8  --- Issue happens only if log level for org.springframework is set to DEBUG  This is the stack trace for error -  ``` caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'queueMessageHandler' defined in class path resource [org/springframework/cloud/aws/messaging/config/annotation/SqsConfiguration.class]: Invocation of init method failed; nested exception is java.lang.StringIndexOutOfBoundsException: String index out of range: 1 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1786) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:218) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.resolveBeanReference(ConfigurationClassEnhancer.java:361) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:334) 	at org.springframework.cloud.aws.messaging.config.annotation.SqsConfiguration$$EnhancerBySpringCGLIB$$321a8abf.queueMessageHandler() 	at org.springframework.cloud.aws.messaging.config.annotation.SqsConfiguration.simpleMessageListenerContainer(SqsConfiguration.java:78) 	at org.springframework.cloud.aws.messaging.config.annotation.SqsConfiguration$$EnhancerBySpringCGLIB$$321a8abf.CGLIB$simpleMessageListenerContainer$0() 	at org.springframework.cloud.aws.messaging.config.annotation.SqsConfiguration$$EnhancerBySpringCGLIB$$321a8abf$$FastClassBySpringCGLIB$$79a177e6.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) 	at org.springframework.cloud.aws.messaging.config.annotation.SqsConfiguration$$EnhancerBySpringCGLIB$$321a8abf.simpleMessageListenerContainer() 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) 	... 29 more Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 1 	at java.lang.String.substring(String.java:1963) 	at org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler.lambda$formatMappings$2(AbstractMethodMessageHandler.java:323) ``` It seems like it breaks for empty string.  This part of code seems to be problematic -","closed","type: bug,","rhishirajnema","2021-08-06T22:15:40Z","2021-09-10T10:23:41Z"
"","27133","InternalSpelExpressionParser allows any number of contiguous dots when recognizing QualifiedId","**Affects:** 5.3.8  ---  You can create an Object like this  ```java     @Test     public void test() {         SpelExpressionParser parser = new SpelExpressionParser();         System.out.println(parser.parseRaw(""new java..util......ArrayList()"").getValue());     } ```  because in org.springframework.expression.spel.standard.InternalSpelExpressionParser, line 722:  ```java private SpelNodeImpl eatPossiblyQualifiedId() {         Deque qualifiedIdPieces = new ArrayDeque();         Token node = peekToken();          // this loop allows any number of dots         while (isValidQualifiedId(node)) { 	        nextToken(); 	        if (node.kind != TokenKind.DOT) { 		        qualifiedIdPieces.add(new Identifier(node.stringValue(), node.startPos, node.endPos)); 	        } 	        node = peekToken();         }         ... }  // this method treats both DOT and IDENTIFIER as qualifiedId private boolean isValidQualifiedId(@Nullable Token node) {         if (node == null || node.kind == TokenKind.LITERAL_STRING) { 	        return false;         }         if (node.kind == TokenKind.DOT || node.kind == TokenKind.IDENTIFIER) { 	        return true;         }         String value = node.stringValue();         return (StringUtils.hasLength(value) && VALID_QUALIFIED_ID_PATTERN.matcher(value).matches()); } ```  This doesn't cause any problem, but I think it lacks preciseness.","closed","in: core,","lijinliangyihao","2021-07-06T07:19:07Z","2022-05-22T13:41:54Z"
"","27053","StreamingResponseBody endpoint returns an invalid object in case of 500 error code.","**Affects:** 5.3.8  ---  When a `StreamingResponseBody` endpoint throws an exception, and it's handled by the `RestControllerAdvice` which handles as a 500 error, something strange happens. The endpoint returns the custom object and the default Spring WhiteLabel Error object together, resulting in an invalid JSON object.  I think that the problem is caused by this line https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/StreamingResponseBodyReturnValueHandler.java#L111  **Steps to reproduce:** 1. MyRestController class ```Java @RestController public class MyRestController {     @GetMapping(""/whiteLabelError"")     public StreamingResponseBody whiteLabelError() {         return out -> {             throw new RuntimeException();         };     } ``` 2. RestControllerAdvice class ```java import static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;  @RestControllerAdvice public class MyRestControllerAdvice extends ResponseEntityExceptionHandler {      @ExceptionHandler(value = {RuntimeException.class})     private ResponseEntity handleRestRuntimeException(final RuntimeException ex, final WebRequest request) {         return handleExceptionInternal(ex, INTERNAL_SERVER_ERROR, new HttpHeaders(), INTERNAL_SERVER_ERROR, request);     } } ```  **The endpoint's response:**  ```json ""INTERNAL_SERVER_ERROR""{     ""timestamp"": 1623421573315,     ""status"": 500,     ""error"": ""Internal Server Error"",     ""path"": ""/exceptions/whiteLabelError"" } ```","open","status: feedback-provided,","feco16","2021-06-11T14:32:34Z","2021-06-17T11:27:57Z"
"","27271","CompositeUriComponentsContributor#hasContributors: method name is not compliant with its intention","**Affects:** 5.3.8  ---  This method named `hasContributors()` has a body that returns `true` when there are no contributors.  ```java public boolean hasContributors() {    return this.contributors.isEmpty(); } ```","closed","type: bug,","lijinliangyihao","2021-08-13T02:14:27Z","2021-08-18T15:34:16Z"
"","27256","UrlPathHelper: checkReadOnly() called in read method shouldRemoveSemicolonContent()","**Affects:** 5.3.8  ---  Method `checkReadOnly` is called in read method UrlPathHelper#shouldRemoveSemicolonContent, line 149. If we want to know whether we should `removeSemicolonContent` when `this.readOnly` is true, an error will be thrown. ``` public boolean shouldRemoveSemicolonContent() {     checkReadOnly();     return this.removeSemicolonContent; } ```","closed","status: superseded,","lijinliangyihao","2021-08-10T14:04:29Z","2021-08-22T12:42:21Z"
"","27204","DefaultPathContainer#parsePathParamValues should decode and test name once in outer loop","**Affects:** 5.3.8  ---  In method parsePathParamValues, line 164: should  name be decoded and tested once in outer loop? ``` private static void parsePathParamValues(String input, Charset charset, MultiValueMap output) {   if (StringUtils.hasText(input)) {   	int index = input.indexOf('=');   	if (index != -1) {   	  String name = input.substring(0, index);   	  String value = input.substring(index + 1);   	  for (String v : StringUtils.commaDelimitedListToStringArray(value)) {   	     	  	// should `name` be decoded and tested once in outer loop?   	  	name = StringUtils.uriDecode(name, charset);   	  	if (StringUtils.hasText(name)) {   	  	  output.add(name, StringUtils.uriDecode(v, charset));   	  	}   	  }   	}   	else {   	  String name = StringUtils.uriDecode(input, charset);   	  if (StringUtils.hasText(name)) {   	  	output.add(input, """");   	  }   	}   } } ```","closed","type: task,","lijinliangyihao","2021-07-23T07:42:25Z","2021-07-23T16:02:16Z"
"","27531","UriTemplateRequestEntity doesn't override hashCode() and equals()","**Affects:** 5.3.8  ---  Hi developers!  To fix a memory leak caused by the micrometer metrics used in the RestTemplate I need to switch to the usage of the uri template to build a `RequestEntity` instance. To test the produced instance from one of the internal implementation in my project I use `assertThat` from the `Asserj` library.  The problem is that the test is failing because of the not overridden `equals()` method in the `UriTemplateRequestEntity` class that is used internally by the `Assertj`. In fact both calls - `equals()` and `hashCode()` throws an exception on the instances of the `UriTemplateRequestEntity` that should never be the case if the instance of the latter is built correctly.  The following test fails because of the mentioned issue.  ```java     @Test     void test() {         final Map vars = new HashMap();         vars.put(""id"", 1);          final RequestEntity requestEntity1 =             RequestEntity.method(HttpMethod.GET, ""http://test.api/path/{id}"", vars).build();          final RequestEntity requestEntity2 =             RequestEntity.method(HttpMethod.GET, ""http://test.api/path/{id}"", vars).build();          org.assertj.core.api.Assertions.assertThat(requestEntity1)             .isEqualTo(requestEntity2);     } ```  with the following stack trace  ``` java.lang.UnsupportedOperationException 	at org.springframework.http.RequestEntity.getUrl(RequestEntity.java:165) 	at org.springframework.http.RequestEntity.equals(RequestEntity.java:198) 	at java.base/java.util.Arrays.deepEquals0(Arrays.java:4654) 	at java.base/java.util.Objects.deepEquals(Objects.java:90) 	at org.assertj.core.internal.StandardComparisonStrategy.areEqual(StandardComparisonStrategy.java:77) 	at org.assertj.core.internal.Objects.areEqual(Objects.java:361) 	at org.assertj.core.internal.Objects.assertEqual(Objects.java:337) 	at org.assertj.core.api.AbstractAssert.isEqualTo(AbstractAssert.java:359) ```  Could you please have a look? To workaround this issue I need to implement a very cumbersome test accessing internal fields one by one.","closed","type: bug,","abryantsev","2021-10-07T20:41:35Z","2021-10-11T11:07:54Z"
"","27307","Reactive Transaction when applied to Kotlin Coroutines doesn't pass the `CoroutineContext`","**Affects:** 5.3.8  ---  #### Problem: * Reactive transaction when applied to coroutines doesn't pass the caller's `CoroutineContext`. ```kotlin // in whatever caller.. start coroutine with custom context. val user = User(role = ""admin"") // custom coroutine context GlobalScope.launch(user) {     val hasUser1 = transaction1() // return false     val hasUser2 = transaction2() // return false, too. }  @Transactional suspend fun transaction1(): Boolean {     return coroutineContext[User] != null }  suspend fun transaction2(): Boolean = transactionalOperator.executeAndAwait {     coroutineContext[User] != null }  ```  #### Cause: * [CoroutinesUtils#invokeSuspendingFunction](https://github.com/spring-projects/spring-framework/blob/v5.3.9/spring-core/kotlin-coroutines/src/main/kotlin/org/springframework/core/CoroutinesUtils.kt#L62) and [TransactionalOperatorExtension#executeAndAwait](https://github.com/spring-projects/spring-framework/blob/v5.3.9/spring-tx/src/main/kotlin/org/springframework/transaction/reactive/TransactionalOperatorExtensions.kt) overwrites caller's coroutine context while converting coroutines into a `Publisher` by doing...: ```kotlin mono(Dispatchers.Unconfined) { ... } ```  #### Fix: * Passing the `CoroutineContext` of the caller may fix the problem. ```kotlin // in `TransactionalOperatorExtension` suspend fun  TransactionalOperator.executeAndAwait(f: suspend (ReactiveTransaction) -> T): T = {     val ctx = Dispatchers.Unconfined + coroutineContext.minusKey(Job) // combine the caller's context     return execute { status -> mono(ctx) { f(status) } }.map { value -> Optional.of(value!!) }         .defaultIfEmpty(Optional.empty()).awaitLast().orElse(null) }  // in `CorotuinesUtils` fun invokeSuspendingFunction(method: Method, target: Any, vararg args: Any?): Publisher {     val function = method.kotlinFunction!!     val ctx = Dispatchers.Unconfined + ((args[args.size - 1] as Continuation?)?.context?.minusKey(Job) ?: EmptyCoroutineContext) // combine the caller's context     val mono = mono(ctx) {         function.callSuspend(target, *args.sliceArray(0..(args.size-2))).let { if (it == Unit) null else it }     }.onErrorMap(InvocationTargetException::class.java) { it.targetException }     return if (function.returnType.classifier == Flow::class) {         mono.flatMapMany { (it as Flow).asFlux() }     }     else {         mono     } } ```","closed","status: superseded,","ks-yim","2021-08-21T05:45:32Z","2021-08-22T10:43:43Z"
"","27153","ResourceHandlerRegistry#getHandlerMapping should initialize handler once in outer loop","**Affects:** 5.3.8  ---   the code fragment below in method getHandlerMapping, line 168 ```     Map urlMap = new LinkedHashMap();     for (ResourceHandlerRegistration registration : this.registrations) { 	for (String pathPattern : registration.getPathPatterns()) {              // 1. we get the 'handler' here from the outer loop variable 'registration',              //    set it's properties all with bean fields             ResourceHttpRequestHandler handler = registration.getRequestHandler();             if (this.pathHelper != null) { 	      handler.setUrlPathHelper(this.pathHelper);             }             if (this.contentNegotiationManager != null) { 	      handler.setContentNegotiationManager(this.contentNegotiationManager);             }             handler.setServletContext(this.servletContext);             handler.setApplicationContext(this.applicationContext);             try { 	      handler.afterPropertiesSet();             }             catch (Throwable ex) { 	      throw new BeanInitializationException(""Failed to init ResourceHttpRequestHandler"", ex);             }              // 2.  and here, we put it in a map, with inner loop's element as the key             urlMap.put(pathPattern, handler); 	}     } ``` Can't we move the code fragment in the inner loop between comment 1 and 2 to the outer loop?","closed","type: enhancement,","lijinliangyihao","2021-07-11T08:23:13Z","2021-07-13T11:14:18Z"
"","27281","DeferredResultInterceptorChain#triggerAfterTimeout: should we test deferredResult's state out of the loop?","**Affects:** 5.3.8  ---   In method `triggerAfterTimeout`, line 74: We test deferredResult's state inside the loop. Can we move it out? ``` public void triggerAfterTimeout(NativeWebRequest request, DeferredResult deferredResult) throws Exception {     for (DeferredResultProcessingInterceptor interceptor : this.interceptors) {          // Can we move this test out of the loop? The invocation is timeout after all. 	if (deferredResult.isSetOrExpired()) { 		return; 	} 	if (!interceptor.handleTimeout(request, deferredResult)){ 		break; 	}     } }  ```","closed","status: invalid,","lijinliangyihao","2021-08-15T13:39:19Z","2021-09-21T15:07:36Z"
"","27135","Blockhound: Blocking call when getting static resource from a Jar","**Affects:** 5.3.8  # The problem When adding blockhound to a webflux project you cannot get static resources from Jar. Instead blockhound will throw an error:  ```2021-07-06 10:27:19.539 ERROR 13612 --- [ctor-http-nio-2] a.w.r.e.AbstractErrorWebExceptionHandler : [eaee4b8f-1]  500 Server Error for HTTP GET ""/webjars/swagger-ui/3.49.0/index.html""  reactor.blockhound.BlockingOperationError: Blocking call! java.io.RandomAccessFile#readBytes         at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[na:na]         Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: Error has been observed at the following site(s):         |_ checkpoint ? HTTP GET ""/webjars/swagger-ui/3.49.0/index.html"" [ExceptionHandlingWebHandler] Stack trace:                 at java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java) ~[na:na]                 at java.base/java.io.RandomAccessFile.read(RandomAccessFile.java:406) ~[na:na]                 at java.base/java.io.RandomAccessFile.readFully(RandomAccessFile.java:470) ~[na:na]                 at java.base/java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1304) ~[na:na]                 at java.base/java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:998) ~[na:na]                 at java.base/java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:1013) ~[na:na]                 at java.base/java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:468) ~[na:na]                 at java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:159) ~[na:na]                 at java.base/java.io.InputStream.readNBytes(InputStream.java:490) ~[na:na]                 at java.base/java.util.jar.JarFile.getBytes(JarFile.java:807) ~[na:na]                 at java.base/java.util.jar.JarFile.checkForSpecialAttributes(JarFile.java:1007) ~[na:na]                 at java.base/java.util.jar.JarFile.isMultiRelease(JarFile.java:390) ~[na:na]                 at java.base/java.util.jar.JarFile.getEntry(JarFile.java:509) ~[na:na]                 at java.base/sun.net.www.protocol.jar.URLJarFile.getEntry(URLJarFile.java:131) ~[na:na]                 at java.base/sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:137) ~[na:na]                 at java.base/sun.net.www.protocol.jar.JarURLConnection.getContentLengthLong(JarURLConnection.java:182) ~[na:na]                 at org.springframework.core.io.AbstractFileResolvingResource.isReadable(AbstractFileResolvingResource.java:109) ~[spring-core-5.3.8.jar:5.3.8]                 at org.springframework.web.reactive.resource.PathResourceResolver.getResource(PathResourceResolver.java:117) ~[spring-webflux-5.3.8.jar:5.3.8]                 at org.springframework.web.reactive.resource.PathResourceResolver.lambda$getResource$1(PathResourceResolver.java:99) ~[spring-webflux-5.3.8.jar:5.3.8]                 at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:374) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:218) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:164) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:73) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:281) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:860) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:127) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2397) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:169) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2193) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:2067) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:96) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:448) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:218) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:164) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.Mono.subscribe(Mono.java:4150) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) ~[reactor-core-3.4.7.jar:3.4.7]                 at reactor.netty.http.server.HttpServer$HttpServerHandle.onStateChange(HttpServer.java:915) ~[reactor-netty-http-1.0.8.jar:1.0.8]                 at reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:654) ~[reactor-netty-core-1.0.8.jar:1.0.8]                 at reactor.netty.transport.ServerTransport$ChildObserver.onStateChange(ServerTransport.java:478) ~[reactor-netty-core-1.0.8.jar:1.0.8]                 at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:533) ~[reactor-netty-http-1.0.8.jar:1.0.8]                 at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:94) ~[reactor-netty-core-1.0.8.jar:1.0.8]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:209) ~[reactor-netty-http-1.0.8.jar:1.0.8]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]                 at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar:4.1.65.Final]                 at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na] ```  # Expected behavior Getting static resources from a jar should be handled without blockhound complaining, just as static resource within the application itself  # Reproduce 1) Checkout https://github.com/sickan90/blockhoundAndStaticResourceFromJar 2) Run with `./mvnw spring-boot:run` 3) Navigate to http://localhost:8080/webjars/swagger-ui/3.49.0/index.html","closed","status: duplicate,","sickan90","2021-07-06T08:39:00Z","2021-07-06T08:53:58Z"
"","27146","JettyHttpHandlerAdapter is not aware of Server[Request|Response]Wrapper","**Affects:** 5.3.7  In `JettyServerHttpRequest#createHeaders`, it is assumed that the given `HttpServletRequest` is a `org.eclipse.jetty.server.Request`, while it could be a `HttpServletRequestWrapper`. Similarly, `JettyServerHttpResponse#createHeaders` assumes that the given response is a `org.eclipse.jetty.server.Response`, while it could be a `HttpServletResponseWrapper`.  Similar to https://github.com/spring-projects/spring-framework/issues/22143, but just for Jetty.","closed","type: bug,","migedt","2021-07-08T11:52:14Z","2021-07-08T14:40:38Z"
"","26985","DateTimeFormatterRegistrar should use ISO formats by default","**Affects:** 5.3.7  Currently `DateTimeFormatterRegistrar` behavior is different from default JDK  For example, given `OffsetDateTime.parse(XXX)`, if XXX can be parsed this way, it should be parsed by `DateTimeFormatterRegistrar` too.","open","status: pending-design-work,","abccbaandy","2021-05-27T10:59:54Z","2022-06-07T13:37:49Z"
"","27068","Improve docs for getContentAsByteArray method of ContentCachingRequestWrapper","**Affects:** 5.3.7  ---  Java Doc in `org.springframework.web.util.ContentCachingRequestWrapper` says that ""wrapper that caches **all** content"" wihtout any information that only request with `POST` method and content type `application/x-www-form-urlencoded` are cached (`isFormPost` method is responsible for that).  IMHO it is misleading that you have to see class internals to see for what requests content is cached.  Am I right or I am missing something? :)  PS. I can provide PR with docs update if you agree with me.","closed","type: documentation,","ziebamarcin","2021-06-16T08:29:43Z","2021-07-10T09:28:17Z"
"","27010","Spring Webflux: CoRouterFunctionDsl should expose the used CoroutineContext","**Affects:** 5.3.7  ---  I am using the `CoRouterFunctionDsl` to build a Spring Webflux application with `suspend` handlers in Kotlin. Recently I wanted to add some SLF4J `MDC` values (e.g. an AWS X-Ray Trace id) which requires the usage of https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/. `MDC` is `ThreadLocal` based which does not play well with coroutines.  Adding such a `ThreadContextElement`  can be done in a generic way (so it doesn't have to be repeated in each handler) in the private method `asHandlerFunction` in the class `CoRouterFunctionDsl`:  ```kotlin mono(Dispatchers.Unconfined) {     init(it) } ```  but there is no way of doing that. For now I copied the class and changed the function myself. The data I need there is based on the subscriber context of the Mono (coming from a `WebFilter`) and the `ServerRequest`, so it would be neat to inject something like `coroutineContextProvider: (req: ServerRequest) -> Mono` into the DSL:  ```kotlin private val contextProvider = (req: ServerRequest) ->   Mono.deferContextual { ctx ->     // Extract data from req and ctx     // Return a coroutine context   }  coRouter(contextProvider) {   GET(""/info"", ...) }  // In CoRouterFunctionDsl  private fun asHandlerFunction(init: suspend (ServerRequest) -> ServerResponse) = HandlerFunction { req ->     contextProvider(req)       .flatMap { coroutineContext ->               mono(coroutineContext) {                   init(req)               }       } } ```  I hope that makes sense. If there is an easier solution that I oversaw I am of course also open to that.","open","in: kotlin,","FrontierPsychiatrist","2021-06-01T06:27:39Z","2022-03-15T08:12:20Z"
"","27049","Disconnected client results in HTTP 500 after reactor-netty upgrade to 1.0.7","**Affects:** 5.3.7  ---   With the upgrade from spring-boot from 2.3.x to 2.4.x & reactor-netty-http from 0.9.20 to 1.0.7 client disconnected errors are causing 500 http responses to be produced (and therefore reported to logs & metrics).  My scenario is simple client -> server call where server is a Spring-boot based app with Webflux and Reactor. After the upgrade I noticed increase in http 500 responses. Logs report `500 Server Error for HTTP POST ""/endpoint""` from `org.springframework.web.server.adapter.HttpWebHandlerAdapter` with stack trace ``` reactor.netty.channel.AbortedException: Connection has been closed 	at reactor.netty.http.server.HttpServerOperations.onInboundClose(HttpServerOperations.java:568) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): ... ```  I think the culprit is [change](https://github.com/reactor/reactor-netty/commit/8a1188eeb27e31bfdccb478308f96f42e4f732b1) in `reactor-netty` which started raising AbortedException on client connection close. However, despite `AbortedException` being [on the list of known exception caused by connection closed](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java#L73) it results in HTTP 500 response (obviously, client won't even consume it) because in [HttpWebHandlerAdapter](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java#L292)   ``` if (response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR)) { 			logger.error(logPrefix + ""500 Server Error for "" + formatRequest(request), ex); 			return Mono.empty(); 		}  else if (isDisconnectedClientError(ex)) { 			if (lostClientLogger.isTraceEnabled()) { 				lostClientLogger.trace(logPrefix + ""Client went away"", ex); 			} 			else if (lostClientLogger.isDebugEnabled()) { 				lostClientLogger.debug(logPrefix + ""Client went away: "" + ex + 						"" (stacktrace at TRACE level for '"" + DISCONNECTED_CLIENT_LOG_CATEGORY + ""')""); 			} 			return Mono.empty(); 		} ```  the first `if` (`setStatusCode`) returns true.   Looks like the root cause is the integration point (couldn't track it) between HttpResponse and Reactor Netty as it allows to set status code on a response that won't be returned to client (I guess `state` is not updated).","open","status: feedback-provided,","tmszdmsk","2021-06-10T23:48:14Z","2021-11-08T11:37:34Z"
"","27131","Provide GSON-base org.springframework.core.codec.Encoder/Decoder","**Affects:** 5.3.6 (coming from Spring Boot 2.4.5)   **Requirement**: Provide **GSON**-base `Encoder/Decoder` by analogy with `Jackson2JsonEncoder/Jackson2JsonDecoder` (in webflux world) and `GsonHttpMessageConverter` (in mvc world).  **Issue found** (status closed): https://github.com/spring-projects/spring-boot/issues/9166  **Workaround found**: https://stackoverflow.com/questions/60854660/set-custom-encoder-decoder-or-typeadapter-for-webclient-using-gson  Let me know if I need to provide more details.","open","type: enhancement,","asavov","2021-07-05T10:13:29Z","2022-03-22T07:50:26Z"
"","26886","RSocketRequester disposal of underlying RSocketClient","**Affects:** 5.3.6  When using `RSocketRequester.builder().transport()` a new underlying RSocketClient is created (which is hidden from the user of this API). The RSocketClient must be disposed to free the underlying resources (or not?).  Imho the current API design totally hides that there are resources allocated and must be disposed - it is nowhere stated in the docs and also the RSocketRequester has not `dispose()` method or similar.","closed","type: enhancement,","joshiste","2021-05-03T12:39:43Z","2021-05-10T06:22:00Z"
"","27198","UriComponents does not escape ""/"" in path parameters in ""expand""","**Affects:** 5.3.6  ---   I would like to create a URL that uses path parameters, such as `/foo/{fooId}/details`. Any characters with special meaning in `fooId` such as `/` will need URL escaping in such context.  I had expected that `UriComponents` with the `expand()` method would do that escaping for me, but it does not:  ```     @Test     public void testUriComponentsPathVariableEscaping() {         String url = UriComponentsBuilder.newInstance()             .path(""/foo/{fooId}/details"")             .build()             .expand(""x/y"")             .toUriString();         assertThat(url).isEqualTo(""/foo/x%2Fy/details"");     } ... org.opentest4j.AssertionFailedError:  expected: ""/foo/x%2Fy/details"" but was : ""/foo/x/y/details"" ```  I notice that ""/"" is indeed listed as not ""allowed"" in `org.springframework.web.util.HierarchicalUriComponents.Type#PATH`, so something is being lost in the long path between expand and there.  I am using `org.springframework:spring-web:5.3.6`  Thanks,   Rich","closed","for: stackoverflow,","RichardBradley","2021-07-22T11:42:50Z","2021-07-23T15:34:40Z"
"","27808","AsyncConfigurer implementations are loaded too early","**Affects:** 5.3.3  We use an `AsyncConfigurer` that needs some beans. Spring wants to create a BeanPostProcessor `asyncAdvisor` at `org.springframework.scheduling.annotation.ProxyAsyncConfiguration`. This bean post processor uses the instance variables `this.executor` and `this.exceptionHandler`  all AsyncConfigurer are autowired to ProxyAsyncConfiguration via the following method   `org.springframework.scheduling.annotation.AbstractAsyncConfiguration`  ``` 	@Autowired(required = false) 	void setConfigurers(Collection configurers) { 		if (CollectionUtils.isEmpty(configurers)) { 			return; 		} 		if (configurers.size() > 1) { 			throw new IllegalStateException(""Only one AsyncConfigurer may exist""); 		} 		AsyncConfigurer configurer = configurers.iterator().next(); 		this.executor = configurer::getAsyncExecutor; 		this.exceptionHandler = configurer::getAsyncUncaughtExceptionHandler; 	} ``` This leads to a prelimary instance creation of all asyncConfigurer and its dependent beans.  IMHO this should be changed to use an ObjectProvider instead: ```     protected ObjectProvider configurersProvider;      @Autowired(required = false)     void setConfigurers(ObjectProvider configurers) {         this.configurersProvider = configurers;     }      protected void evaluateAsyncConfigurer() {         List configurers = configurersProvider.orderedStream().collect(Collectors.toList());         if (CollectionUtils.isEmpty(configurers)) {             return;         }         if (configurers.size() > 1) {             throw new IllegalStateException(""Only one AsyncConfigurer may exist"");         }         AsyncConfigurer configurer = configurers.iterator().next();         this.executor = configurer::getAsyncExecutor;         this.exceptionHandler = configurer::getAsyncUncaughtExceptionHandler;     } ```  method evaluateAsyncConfigurer() should be called before access to this.executor and this.exceptionHandler in child classes.","closed","in: core,","ipavkovic","2021-12-13T15:22:02Z","2021-12-15T10:00:38Z"
"","27899","ArrayIndexOutOfBoundsException with STOMP and Jetty 10","**Affects:** 5.3.14 ---  Jetty10RequestUpgradeStrategy throws ArrayIndexOutOfBoundsException if STOMP (or any other WS subprotocol) is used; the offending code is the block starting at https://github.com/spring-projects/spring-framework/blob/ccf95413ed41c7016bc57f92676716fc5c44e286/spring-websocket/src/main/java/org/springframework/web/socket/server/jetty/Jetty10RequestUpgradeStrategy.java#L159 which tries to reference the third argument to an invocation that only has two (classic off-by-one error).","closed","type: bug,","espenhw","2022-01-06T16:54:40Z","2022-01-12T15:06:40Z"
"","27806","Spring Websockets: Cannot send message directly to user with connection on another host","**Affects:** 5.3.13 Spring Websockets --- Issue: trying to send direct message to user established websockets session on another host of cluster does not send the message to this user websocket sessions on different host, only on the current one. Works only if we identify user NOT by session id Reproduce steps: Run two copies of app in a cluster. Setup broker relay (like activemq). Establish websocket session for user1 on server1. Some client app also should subscribe to the topic ""/user/topic/sometopic"" to server1 as user1. From server2 send message to user1 as convertAndSendToUser(""user1"", ""/topic/sometopic""). Message is not received by the subscribed client. Try to connect client to server1 and repeat - message will be received. Works only when we are sending message not to session id as a user, but to some principal name like `user1` Hint: Seems like the issue could be in the architecture - topics on broker receive the name like /topic/sometopic-user321321 and Spring Websockets use internal mapping registry    to determine to what topics to send messages. But as registry is not distributed, Spring Websockets is not aware of the session ids for this user on another host.","closed","status: feedback-reminder,","vitali-kviatkouski","2021-12-12T21:25:36Z","2022-02-18T19:05:44Z"
"","27809","When returning a ResponseEntity with a Flux while the function is suspended, it fails to encode the body","**Affects:** 5.3.13  When returning a ResponseEntity when the function is suspended it unnests to Flux (tested: 5.3.13) while it previously unnested to [some class] (tested: 5.3.11).  ### Example ```kotlin @RestController class Controller(val service: SomeService) {   @GetMapping(""/"")   suspend fun getStrings(): ResponseEntity {     val strs: Flux = service.getStrings()     // some coroutine function is called     val headers = HttpHeaders()     // Set headers     return ResponseEntity.ok().headers(headers).body(strs)   } }  /**  *","closed","in: kotlin,","emilwihlander","2021-12-13T17:27:00Z","2022-03-11T11:26:16Z"
"","27715","""IllegalArgumentException: Expected lookupPath in request attribute"" in UrlPathHelper during MockMvc integration test (regression in 5.3.13 from 5.3.12?)","**Affects:** 5.3.13  When I run this [MockMvc integration test](https://github.com/qaware/openapi-generator-for-spring/blob/master/openapi-generator-for-spring-test/src/test/java/de/qaware/openapigeneratorforspring/test/app44/App44Test.java#L23) after upgrading from Spring Boot 2.5.6 to 2.6.0 (which upgrades Spring Framework from 5.2.12 to 5.3.13), I get the following stacktrace  ``` org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.IllegalArgumentException: Expected lookupPath in request attribute ""org.springframework.web.util.UrlPathHelper.PATH"".  	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) 	at org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:72) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) 	at org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:167) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.boot.web.servlet.filter.ErrorPageSecurityFilter.doFilter(ErrorPageSecurityFilter.java:62) 	at javax.servlet.http.HttpFilter.doFilter(HttpFilter.java:57) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:122) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:116) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:109) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.csrf.CsrfFilter.doFilterInternal(CsrfFilter.java:117) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:199) 	at de.qaware.openapigeneratorforspring.test.AbstractOpenApiGeneratorWebMvcBaseIntTest.performApiDocsRequest(AbstractOpenApiGeneratorWebMvcBaseIntTest.java:26) 	at de.qaware.openapigeneratorforspring.test.AbstractOpenApiGeneratorWebMvcIntTest.getOpenApiAsJson(AbstractOpenApiGeneratorWebMvcIntTest.java:14) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.lang.IllegalArgumentException: Expected lookupPath in request attribute ""org.springframework.web.util.UrlPathHelper.PATH"". 	at org.springframework.util.Assert.notNull(Assert.java:201) 	at org.springframework.web.util.UrlPathHelper.getResolvedLookupPath(UrlPathHelper.java:213) 	at org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getMatchingCondition(PatternsRequestCondition.java:280) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfo.getMatchingCondition(RequestMappingInfo.java:406) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:109) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:67) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.addMatchingMappings(AbstractHandlerMethodMapping.java:448) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:405) 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:383) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:125) 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:67) 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:498) 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1261) 	at org.springframework.test.web.servlet.TestDispatcherServlet.getHandler(TestDispatcherServlet.java:122) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1043) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	... 123 more ```  The above linked integration test does nothing weird, only a simple request against an endpoint, essentially something like: ```         String specJson = mockMvc.perform(get(""/v3/api-docs""))                 .andExpect(status().isOk())                 .andReturn().getResponse().getContentAsString(); ```  The only special thing I'm doing within those integration tests is that I have WebMvc AND WebFlux as a dependency at the same time.   Maybe that's a hint what might be causing this? I have no clue at the moment why that exception happens. When I revert to 5.2.12, the issue is gone and my test runs again.   Googling only brought up #26415 which seems unrelated.   Let me know if you need any further information.","closed","status: superseded,","neiser","2021-11-21T18:21:55Z","2022-01-18T23:22:28Z"
"","27771","Base64 problem when I Override ""configureMessageConverters""","**Affects:** 5.3.13  --- I'm using [fusionauth-jwt](https://github.com/FusionAuth/fusionauth-jwt), when I override configureMessageConverters like this: ```java     @Override     public void configureMessageConverters(List","closed","status: invalid,","rasa-app","2021-12-06T14:26:43Z","2021-12-08T10:01:52Z"
"","27837","StrictHttpFirewall rejects request when HtmlUnit WebClient is called with encoded URL","**Affects:** 5.3.13  ---  I'm trying to run a unit test on my spring boot project using the HtmlUnit Webclient.  The test does a POST Request submitting form data to the Controller which will create a database entry and send a redirect to the client. The response will contain a URL in the Location header which will be encoded if necessary.  Everything works fine until the HtmlUnit Webclient tries to follow the redirect and the `org.springframework.security.web.firewall.StrictHttpFirewall.getFirewalledRequest(HttpServletRequest)` method is called which prevents the request from being processed. It complains about the % in the URL (see stack trace).  But when running the application and using an actual browser the problem does not occur. Searching the web I found #16067 which first looked familiar.  So I wrote a small [project](https://github.com/thuri/encoded-uri-test) to reproduce the issue, and I think that the problem with HtmlUnit WebClient is a little bit different.   When running the `webClientTestStringWithEncoding` test method and debugging into `org.springframework.security.web.firewall.StrictHttpFirewall#rejectedBlocklistedUrls(HttpServletRequest)`, one can see that `request.getServletPath()` still contains the encoded path while the called method `decodedUrlContains` seems to expect that it has been decoded.  If you run the `mockMvcTestURI` test method and debug the same line you can see that `request.getServletPath()` is empty but `request.getPathInfo()` contains an decoded path. `request.getRequestURI()` contains the encoded path in both cases.  In case you're wondering why the first test uses the webclient and the other one the mockMvc: I didn't find a way to pass either the encoded URL or the unencoded version (with spaces and an Umlaut) to the HtmlUnit Webclient (as you can see by the other test methods)  Perhaps the problem lies in the `org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder.buildRequest(ServletContext)` where the `servletPath` is set on the request and should be decoded.   I think I can work around that issue in my test but would be happy if you could have a look at this.   Thanks in advance, Michael  ```stacktrace java.io.IOException: org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the URL contained a potentially malicious String ""%"" 	at org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection.getResponse(MockMvcWebConnection.java:152) 	at org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection.getResponse(MockMvcWebConnection.java:134) 	at org.springframework.test.web.servlet.htmlunit.DelegatingWebConnection.getResponse(DelegatingWebConnection.java:79) 	at com.gargoylesoftware.htmlunit.WebClient.loadWebResponseFromWebConnection(WebClient.java:1596) 	at com.gargoylesoftware.htmlunit.WebClient.loadWebResponse(WebClient.java:1518) 	at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:493) 	at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:413) 	at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:548) 	at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:529) 	at io.gitlab.thuri.spring.htmlunit.TestWithEncodedUriIssue.webClientTestStringWithEncoding(TestWithEncodedUriIssue.java:63) 	// cut junit and eclipse stacktrace entries Caused by: org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the URL contained a potentially malicious String ""%"" 	at org.springframework.security.web.firewall.StrictHttpFirewall.rejectedBlocklistedUrls(StrictHttpFirewall.java:463) 	at org.springframework.security.web.firewall.StrictHttpFirewall.getFirewalledRequest(StrictHttpFirewall.java:429) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:196) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:199) 	at org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection.getResponse(MockMvcWebConnection.java:149) 	... 78 more ```","closed","type: bug,","thuri","2021-12-18T18:09:44Z","2022-01-11T14:54:38Z"
"","27840","ClassPathResource getFile returns null for a resource packed inside the Boot JAR","**Affects:** 5.3.13  ---  `ClasspathResource.getFile()` returns `null` when called from inside a Boot Jar and referencing a file inside that Jar. It works fine when the unpacked App is launched.   It would be nice to have consistent behaviour here - perhaps `getFile()` should simply throw an exception in this case?  (also, perhaps it's time to add a `getPath()` to the API, which could return a `jar:file:` `java.nio.Path` in this scenario, and deprecate the `getFile()` method? The suggested replacement being `getPath().toFile()`)","closed","status: invalid,","crizzis","2021-12-21T09:28:29Z","2021-12-21T15:07:12Z"
"","27759","AntPathMatcher and PathPatternParser have different behavior with regexp","**Affects:** 5.3.13  ---   After upgrading an application to Spring Boot 2.6.x we noticed a problem when using the `path_pattern_parser` which is configured by default (instead of the ""legacy"" `ant_path_matcher`).  Not sure if it's a bug or a bug fix .... but it's a different behavior and it wasn't so obvious to me at the origin that the Path Matching Strategy change was the root cause ( thx @bclozel )  Let's say you have a controller with these 2 methods:  ```     @GetMapping(value = ""/api/test/{fileId:^(?!%25).*}"")     public ResponseEntity shouldNotMatch(@PathVariable String fileId) {         return ResponseEntity.badRequest().build();     }      @GetMapping(value = ""/api/test/{ticketId:[0-9]+}%2F{filename}"")     public ResponseEntity shouldMatch(@PathVariable String ticketId, @PathVariable String filename) {         return ResponseEntity.ok().build();     } ```  If the path called is `/api/test/12345%252Ffoo.zip` then using the `ant_path_matcher` the dispatcher goes to `shouldMatch`. But if using `path_pattern_parser` it goes to `shouldNotMatch`  To demo the issue I created a project : https://github.com/aheritier/path_pattern_parser  The controller : https://github.com/aheritier/path_pattern_parser/blob/main/src/main/java/com/example/demo/AController.java  The test: https://github.com/aheritier/path_pattern_parser/blob/main/src/test/java/com/example/demo/AControllerTestBase.java  It's ok with `ant_path_matcher`: https://github.com/aheritier/path_pattern_parser/blob/main/src/test/java/com/example/demo/AControllerWithAntPathMatcherTest.java  It's ko with `path_pattern_parser`: https://github.com/aheritier/path_pattern_parser/blob/main/src/test/java/com/example/demo/AControllerWithPathPatternParserTest.java","closed","status: declined,","aheritier","2021-12-02T13:39:30Z","2021-12-03T14:26:51Z"
"","27629","Webflux fails to apply the rule for controller methods returning void to kotlin suspend functions returning Unit","**Affects:** 5.3.12  Webflux fails to apply the [rule for controller methods returning void](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-return-types) to suspend functions returning Unit. Code like the example below causes error messages in log: `ERROR o.s.w.s.a.HttpWebHandlerAdapter - [882bce24-1] Error [java.lang.UnsupportedOperationException] for HTTP POST ""/some/api/path"", but ServerHttpResponse already committed (200 OK)`  ```kotlin @PostMapping suspend fun doSomething(response: ServerHttpResponse): Unit {     // ...     response.writeWith(/* ... */).awaitSingleOrNull() } ```  *Cause*  `InvocableHandlerMethod::invoke` wraps coroutine results with either mono or flux using `CoroutinesUtils.invokeSuspendingFunction`, but `getReturnType` simply returns `Void.class`. This in turn causes `reactiveAdapterRegistry.getAdapter` to return `null` and `isAsyncVoidReturnType` to return `false`  *Workaround*  Remove suspend modifier and replicate `CoroutinesUtils.invokeSuspendingFunction` wrapping manually:  ```kotlin @PostMapping fun doSomething(response: ServerHttpResponse) = mono(Dispatchers.Unconfined) {     // ...     response.writeWith(/* ... */).awaitSingleOrNull() }     .filter { false }     .onErrorMap(InvocationTargetException::class.java, InvocationTargetException::getTargetException)     .cast(Void.TYPE) ```","open","in: web,","rogeriomgatto","2021-11-01T21:05:08Z","2021-11-08T11:37:37Z"
"","27651","Cannot use any value as parameter to the Content-Type header for the WebClient","**Affects:** 5.3.12  I'm using Spring to integrate towards a third party API. This API validates the Content-Type header and requires it to be exactly application/json;profile=https://se.digitalreceipts.net/schemas/json/retail/v1.0  When executing this request an exception is thrown:  org.springframework.http.InvalidMediaTypeException: Invalid mime type ""application/json;profile=https://se.digitalreceipts.net/schemas/json/retail/v1.0"": Invalid token character ':' in token ""https://se.digitalreceipts.net/schemas/json/retail/v1.0""     at org.springframework.http.MediaType.parseMediaType(MediaType.java:620) ~[spring-web-5.3.10.jar:5.3.10]  The content type is parsed to a MimeType and the parameter is validated, failing on colon and forward slash. I understand that this parameter might not follow the specification, but as it is a sendable value (required by some third party API:s) there should be a way to send it if necessary. Currently there is no way for me to use the WebClient and this parameter.","closed","status: declined,","Kristoffer-Smedlund","2021-11-08T07:24:57Z","2022-01-18T09:52:16Z"
"","27649","Lazy annotation throws exception if non-required bean does not exist","**Affects:** 5.3.12  --- A bean is defined in a `@Configuration` class that has a `@Profile` annotation, so the bean only exists under certain conditions.  In another bean a setter is annotated with `@Autowired(required = false)` for that bean. If the bean exists it should be injected. If not, then not much to do about that. The code will check if the bean is injected (not null) and take appropriate actions.  Now for the problem. If the bean does exist, it needs to be lazy loaded to avoid circular dependency issues. So, the setter is annotated with `@Lazy` annotation. The lazy annotation causes exception ""Optional dependency not present for lazy injection point"" if the non-required bean does not exist.  The exception says exactly whats happening, so perhaps this is by design then? I cannot tell from the documentation if this is a use case that is expected to work or not.  > In addition to its role for component initialization, you can also place the @Lazy annotation on injection points marked with @Autowired or @Inject. In this context, it leads to the injection of a lazy-resolution proxy   Perhaps this behaviour can be changed to lazy load the injection of the non-required bean if it is actually available, and if not then just ignore the `@Lazy` annotation since the `@Autowired` annotation itself did nothing?  The problem is reproduced in this GitHub project: https://github.com/nytro77/spring-lazy-bug","closed","in: core,","nytro77","2021-11-06T21:17:16Z","2021-11-09T21:45:39Z"
"","27658","PathPattern matches with wrong pattern","**Affects:** 5.3.12  ---  In my Spingboot app, I use @GetMapping and @RequestMapping to map the url path to the controller method which I expect Spring to do exact match  ``` @Controller @RequestMapping(""/api"") class BlogController {      @GetMapping(""/method1"")     fun method1(model: Model):String {         return ""template1""     }      @GetMapping(""/method2"")     fun method2(model: Model):String {         return ""template2""     }  } ```  However, when I try visit this application with the url like `http://localhost:8080/api;somethingelse/method1` which I expect it to return not found (404), Springboot return me the `method1` result which I'm not expected.  I tried debug and found that the issue is with `PathPattern` that matches `/api;somethingelse/method1` with `/api/method1`. Here are sample small code that I use to test this problem.  ``` fun main(args: Array) {     val patternMatcher = PathPatternParser().parse(""/api/method1"")     // I expect this to not match     println(patternMatcher.matches(PathContainer.parsePath(""/api;something-else/method1"")))     // This matches correctly     println(patternMatcher.matches(PathContainer.parsePath(""/api/method1"")))     // This is not matched     println(patternMatcher.matches(PathContainer.parsePath(""/api1/method1""))) } ```","closed","status: invalid,","llun","2021-11-09T12:26:05Z","2021-11-09T13:33:52Z"
"","27661","NullPointerException in Smile encoder when encoding empty publisher","**Affects:** 5.3.12  ---   NullPointerException in Smile encoder in case of empty publisher:  ``` 23:01:06.221 ERROR reactor.core.publisher.Operators [elastic-2]: Operator called default onErrorDropped java.lang.NullPointerException: null         at com.fasterxml.jackson.core.util.ByteArrayBuilder.write(ByteArrayBuilder.java:245) ~[jackson-core-2.12.5.jar:2.12.5]         at com.fasterxml.jackson.dataformat.smile.SmileGenerator._flushBuffer(SmileGenerator.java:2596) ~[jackson-dataformat-smile-2.12.5.jar:2.12.5]         at com.fasterxml.jackson.dataformat.smile.SmileGenerator.close(SmileGenerator.java:1854) ~[jackson-dataformat-smile-2.12.5.jar:2.12.5]         at org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$2(AbstractJackson2Encoder.java:173) ~[spring-web-5.3.12.jar:5.3.12]         at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:282) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:150) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxDoOnEach$DoOnEachSubscriber.onComplete(FluxDoOnEach.java:223) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:846) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:608) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxFlatMap$FlatMapMain.innerComplete(FluxFlatMap.java:894) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxFlatMap$FlatMapInner.onComplete(FluxFlatMap.java:997) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:498) ~[reactor-core-3.4.11.jar:3.4.11]         at reactor.core.publisher.MonoCompletionStage.lambda$subscribe$0(MonoCompletionStage.java:86) ~[reactor-core-3.4.11.jar:3.4.11]         at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]         at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837) ~[?:?]         at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506) ~[?:?]         at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073) ~[?:?] ```","closed","","fedortche","2021-11-09T23:48:46Z","2021-11-23T07:26:53Z"
"","27473","Leading whitespaces are removed while reading SSE response","**Affects:** 5.3.10.RELEASE and current main (30efa4d)  ---   I'm making a SSE request to another server using WebClient w/ WebFlux, and the response from the WebClient always shows the results with leading whitespaces removed as well as trailing ones. I think it is due to `ServerSentEventHttpMessageReader::buildEvent` trimming every line: ``` data.append(line.substring(5).trim()).append('\n'); ``` Is there any reason that leading whitespaces must be removed from the SSE response data? I wanted to use tabs at the start of each line to indent the text. I've tried other clients like `curl` but they show responses with the leading whitespaces preserved. Thanks in advance.","closed","type: bug,","yunjae2","2021-09-27T02:10:19Z","2021-09-28T13:06:52Z"
"","27530","ExchangeFunctions wraps java.lang.Error instances and not only exceptions","**Affects:** 5.3.10 (and previous)  `ExchangeFunctions.wrapException()` is called when the following predicate evaluates as true:  ```java t -> !(t instanceof WebClientException) && !(t instanceof CodecException); ``` This predicate will return true on any `java.lang.Error` instance such as `OutOfMemoryError`, causing the error to be wrapped inside a `WebClientRequestException`.   Given that throwing an unhandled Error can cause the JVM to shutdown, allow developers to add hooks to them, etc. I'm just wondering if this predicate should evaluate as false when an Error is thrown.","closed","","rubasace","2021-10-07T08:49:12Z","2021-11-23T07:26:50Z"
"","27596","Support SameSite attribute in CookieGenerator","**Affects:** 5.3.10 ---  Context: I'm using `CookieLocaleResolver`, and I have a requirement to have explicit `SameSite` policies on all cookies.  It would be nice if [`CookieGenerator`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/CookieGenerator.html) let the `SameSite` attribute be set.  Spring Session has [`CookieSerializer`](https://docs.spring.io/spring-session/docs/current/api/org/springframework/session/web/http/DefaultCookieSerializer.html) which is nice and covers the session cookie.  Thank you.","closed","in: web,","ldap4life","2021-10-22T19:54:49Z","2022-03-15T20:22:15Z"
"","27576","Not receiving message sent from Subscription event processor using convertAndSendToUser","**Affects:** 5.3.10  When subscribing to SessionSubscribeEvent and in handler sending message back to this user only using convertAndSendToUser, it is not sent to the channel. Code worked fine in versions 5.2.x. But after rewrite DefaultSubscriptionRegistry seems to stop working.  Example of handler:           @EventListener private void handleSessionSubscribeEvent(SessionSubscribeEvent event) {               String sessionId = (String) event.getMessage().getHeaders().get(""simpSessionId"");               SimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);               headerAccessor.setSessionId(sessionId);               headerAccessor.setLeaveMutable(true);               tpl.convertAndSendToUser(sessionId, ""/auctions/final"", ""Something changed at "" + LocalDateTime.now(),                headerAccessor.getMessageHeaders());           }  Config is following:      @Configuration     @EnableWebSocketMessageBroker     public class WebsocketConfig implements WebSocketMessageBrokerConfigurer {         @Override         public void registerStompEndpoints(StompEndpointRegistry registry) {             registry.addEndpoint(""/websocket"").withSockJS();         }          @Override         public void configureMessageBroker(MessageBrokerRegistry registry) {             registry.enableSimpleBroker(""/topic"", ""/queue"", ""/user"", ""/auctions"");             registry.setApplicationDestinationPrefixes(""/app"");         }     }  Example project can be found here: https://github.com/vitali-kviatkouski/spring-websocket-subscription","open","in: web,","vitali-kviatkouski","2021-10-18T13:59:59Z","2021-11-24T18:36:09Z"
"","27500","Redirected calls should filter out bearer tokens","**Affects:** 5.3.10  When a call is redirected to AWS, the following message is given: ``` InvalidArgumentOnly one auth mechanism allowed; only the X-Amz-Algorithm query parameter, Signature query string parameter or the Authorization header should be specifiedAuthorizationBearer 89QdsFtUXcgUKuMOgOVeCBXFJWT7AF8Q87Q5JCjofrQNGeH1bj2v5KrmcD0BBlqpy78iXk0D80Q1sI6oBl4TUXvFIzbV138t0V7Ua2T4Ms555aWuk= ``` ---  The reason for this is that the original call is using a bearer token and when the call is redirected to AWS, the header with the bearer token gets copied.","closed","for: external-project,","pasi-paasiala","2021-10-01T06:09:48Z","2021-10-05T07:03:30Z"
"","27479","Transaction event listeners","**Affects:** 5.3.10  Please provide a method to register a listener to be notified when a transaction is created/committed/rolledback/finished.","open","status: feedback-provided,","cdalexndr","2021-09-27T22:47:48Z","2022-06-05T18:00:09Z"
"","27411","`StringUtils.collectionToDelimitedString(…)` fails with `NullPointerException` when the collection contains `null`","**Affects:** 5.3.10  After #26316, `StringUtils.collectionToDelimitedString(…)` behaves slightly different than the previous implementation in 5.3.9.  Calling `StringUtils.collectionToDelimitedString(Collections.singleton(null), "","")` in version 5.3.10 fails with:  ``` java.lang.NullPointerException 	at org.springframework.util.StringUtils.collectionToDelimitedString(StringUtils.java:1304) 	at org.springframework.util.StringUtils.collectionToDelimitedString(StringUtils.java:1326) ```  whereas version 5.3.9 returned the string `""null""`.  This ticket is to clarify which behavior is the correct one.  See also spring-projects/spring-data-redis#2167","closed","status: superseded,","mp911de","2021-09-15T10:33:17Z","2021-09-17T13:13:42Z"
"","27434","Wrong Spring Framework apidoc link on spring.io website","**Affects:** 5.3.10  ---  On the https://spring.io/projects/spring-framework#learn site, the api doc of Spring Framework version 5.3.10. The apidoc link points to https://docs.spring.io/spring-framework/docs/current/api/, but I believe the right link is https://docs.spring.io/spring-framework/docs/current/javadoc-api/  Reproduction * Open https://spring.io/projects/spring-framework#learn. * Select API Doc. of version 5.3.10.  Expected * I see the apidoc of Spring Framework 5.3.10.  Actual * I see a ""404 Oops! The page can’t be found."" message","closed","for: external-project,","boszormenyip","2021-09-18T06:16:38Z","2021-09-18T07:47:26Z"
"","27521","[spring-orm] HibernateTransactionManager does not seem to work with @RefreshScope from spring-cloud","**Affects:** 5.3.10  ---  It looks like `HibernateTransactionManager` does not support when an underlying `DataSource` is annotated with `@RefreshScope` and then refreshed, when the transaction is in progress.  Having following configuration:  ```java     @Bean     @RefreshScope     @ConfigurationProperties(""app.jdbc"")     public HikariDataSource theDataSource() {         return new HikariDataSource();     }      @Bean     public LocalSessionFactoryBean sessionFactory(DataSource ds) {         LocalSessionFactoryBean localSessionFactoryBean = new LocalSessionFactoryBean();         localSessionFactoryBean.setDataSource(ds);         localSessionFactoryBean.setPackagesToScan(...);         return localSessionFactoryBean;     }      @Bean     public HibernateTransactionManager transactionManager(SessionFactory sessionFactory) {         return new HibernateTransactionManager(sessionFactory);     } ```  when the refresh is triggered and a transaction is currently running, this transaction fails with an exception:  ``` java.lang.IllegalStateException: No value for key [HikariDataSource (null)] bound to thread 	at org.springframework.transaction.support.TransactionSynchronizationManager.unbindResource(TransactionSynchronizationManager.java:198) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.orm.hibernate5.HibernateTransactionManager.doCleanupAfterCompletion(HibernateTransactionManager.java:717) ~[spring-orm-5.3.10.jar:5.3.10] 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.cleanupAfterCompletion(AbstractPlatformTransactionManager.java:992) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:790) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:711) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:654) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:407) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) ~[spring-tx-5.3.10.jar:5.3.10] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.10.jar:5.3.10] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:750) ~[spring-aop-5.3.10.jar:5.3.10] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:692) ~[spring-aop-5.3.10.jar:5.3.10] ```  Everything works correctly, when I trigger the refresh when no transaction is currently open, further transactions properly use new, reconfigured datasource created by `@RefreshScope` functionality. Am I missing something in `HibernateTransactionManager` configuration?   Expected behavior would be to finish the transaction using `DataSource` present at that time and for all new transactions that start afterwards, use refreshed `DataSource`. It seems to be the case, except that `HibernateTransactionManager` does some cleanup that causes the exception and the transaction to fail.  Already tried Hikari and c3p0, this produces the same behavior.","open","in: data,","walczakp","2021-10-05T17:06:26Z","2021-11-10T11:38:12Z"
"","27641","ConfigurableWebBindingInitializer takes system locale and doesn't allow me to force ISO dates","**Affects:** 5.3.10  ---  I am having a problem **testing** an argument resolution service I wrote on my own. Long story short, there seems not to be a simple, one-liner way to parse a complex nested object from query string in MVC (I'll recall the SO answer link if needed, I need to Google again for it).  So, long story short, I wrote my own `ArgumentResolver` and now I am unit-testing it for correct parsing of dates 😱😱. The dreaded ISO date/times.  I took inspiration from [RequestParamMapMethodArgumentResolverTests](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/test/java/org/springframework/web/method/annotation/RequestParamMapMethodArgumentResolverTests.java) for the tests, and from `RequestParamMethodArgumentResolver` for the implementation of my component, of which I won't paste the entire code in the main post for sake fo brevity.   ```java  @BeforeEach     public void setUp() throws Exception {         LocaleContextHolder.resetLocaleContext();         mavContainer = mock(ModelAndViewContainer.class);         parameter = new MethodParameter(getClass().getMethod(""handleExampleTestFilter"", ExampleTestFilter.class), 0);         httpRequest = new MockHttpServletRequest();         webRequest = new ServletWebRequest(httpRequest);          ConfigurableWebBindingInitializer bindingInitializer = new ConfigurableWebBindingInitializer();         bindingInitializer.setConversionService(new DefaultFormattingConversionService());         bindingInitializer.setAutoGrowNestedPaths(true);         binderFactory = new DefaultDataBinderFactory(bindingInitializer);          uut = new FilterArgumentResolver();         // Expose request to the current thread (for SpEL expressions)         RequestContextHolder.setRequestAttributes(webRequest);     }      /**      * Sample no-op function      */     public void handleExampleTestFilter(ExampleTestFilter filter) {         //NOOP     }     @Test     void resolveArgument() {         OffsetDateTime value = OffsetDateTime.of(1986, 06, 02, 15, 55, 24, 0, ZoneOffset.UTC);         httpRequest.setParameter(""filter.exampleOffsetDateTime.eq"", ""1986-06-02T15:55:24Z"");         Object resolved = assertDoesNotThrow(() -> uut.resolveArgument(parameter, mavContainer, webRequest, binderFactory));          assertAll(                 () -> assertThat(resolved, is(notNullValue())),                 () -> assertThat(resolved, is(instanceOf(ExampleTestFilter.class))),                 () -> assertThat(resolved, hasProperty(""exampleOffsetDateTime"", is(notNullValue()))),                 () -> assertThat(resolved, hasProperty(""exampleOffsetDateTime"", hasProperty(""eq"", is(notNullValue())))),                 () -> assertThat(resolved, hasProperty(""exampleOffsetDateTime"", hasProperty(""eq"", comparesEqualTo(value))))         );      }       @Data     public static class ExampleTestFilter implements Filter {          private OffsetDateTimeFilter exampleOffsetDateTime;          private LocalDateFilter exampleLocalDate;      } ```  Exception is  ``` org.springframework.beans.TypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.time.OffsetDateTime'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.OffsetDateTime] for value '1986-06-02T15:55:24Z'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] 	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:79) 	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:45) 	at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:688) 	at it.orbit.common.web.filtering.FilterArgumentResolver.convertArg(FilterArgumentResolver.java:152) 	at it.orbit.common.web.filtering.FilterArgumentResolver.resolveArgument(FilterArgumentResolver.java:125) 	at it.orbit.common.web.filtering.FilterArgumentResolverTest.lambda$resolveArgument$1(FilterArgumentResolverTest.java:94) 	at org.junit.jupiter.api.AssertDoesNotThrow.assertDoesNotThrow(AssertDoesNotThrow.java:72) 	at org.junit.jupiter.api.AssertDoesNotThrow.assertDoesNotThrow(AssertDoesNotThrow.java:59) 	at org.junit.jupiter.api.Assertions.assertDoesNotThrow(Assertions.java:3120) 	at it.orbit.common.web.filtering.FilterArgumentResolverTest.resolveArgument(FilterArgumentResolverTest.java:94) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy5.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) 	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71) 	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) 	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) Caused by: org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.OffsetDateTime] for value '1986-06-02T15:55:24Z'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] 	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:47) 	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192) 	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:129) 	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73) 	... 92 common frames omitted Caused by: java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] 	at org.springframework.format.support.FormattingConversionService$ParserConverter.convert(FormattingConversionService.java:223) 	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41) 	... 95 common frames omitted Caused by: java.time.format.DateTimeParseException: Text '1986-06-02T15:55:24Z' could not be parsed at index 2 	at java.base/java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:2046) 	at java.base/java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1948) 	at java.base/java.time.OffsetDateTime.parse(OffsetDateTime.java:402) 	at org.springframework.format.datetime.standard.TemporalAccessorParser.doParse(TemporalAccessorParser.java:126) 	at org.springframework.format.datetime.standard.TemporalAccessorParser.parse(TemporalAccessorParser.java:85) 	at org.springframework.format.datetime.standard.TemporalAccessorParser.parse(TemporalAccessorParser.java:50) 	at org.springframework.format.support.FormattingConversionService$ParserConverter.convert(FormattingConversionService.java:217) 	... 96 common frames omitted ```  # Isolating  Let's take a reproducible example. It takes the previously-created `binderFactory` (which is an argument of every `HandlerMethodArgumentResolver`)  ```java      protected  T convertArg(WebDataBinderFactory binderFactory, NativeWebRequest webRequest, String propertyName, Class propertyType, String propertyStringValue) throws ConversionNotSupportedException, TypeMismatchException {         WebDataBinder binder;         try {             binder = binderFactory.createBinder(webRequest, null, propertyName);         } catch (Exception e) {             throw new RuntimeException(""Error creating WebDataBinder: "" + e.getMessage(), e);         }         return binder.convertIfNecessary(propertyStringValue, propertyType);     }        @Test     void testParseDateTime() {         String propertyStringValue = ""1986-06-02T15:55:24Z"";         OffsetDateTime dateTime = OffsetDateTime.parse(propertyStringValue);         OffsetDateTime dateTime1 = uut.convertArg(binderFactory, webRequest, ""offsetDateTime"", OffsetDateTime.class, propertyStringValue);         assertThat(dateTime1, comparesEqualTo(dateTime));     }   ```  This method should convert an ISO string in an OffsetDateTime  ```  Failed to convert value of type 'java.lang.String' to required type 'java.time.OffsetDateTime'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.OffsetDateTime] for value '1986-06-02T15:55:24Z'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] org.springframework.beans.TypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.time.OffsetDateTime'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.OffsetDateTime] for value '1986-06-02T15:55:24Z'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] 	at app//org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:79) 	at app//org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:45) 	at app//org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:688) 	at app//it.orbit.common.web.filtering.FilterArgumentResolver.convertArg(FilterArgumentResolver.java:152) 	at app//it.orbit.common.web.filtering.FilterArgumentResolverTest.testParseDateTime(FilterArgumentResolverTest.java:110) 	at java.base@11.0.12/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base@11.0.12/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base@11.0.12/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base@11.0.12/java.lang.reflect.Method.invoke(Method.java:566) 	at app//org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:688) 	at app//org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at app//org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at app//org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at app//org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at app//org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at app//org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at app//org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at app//org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:210) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:206) 	at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:131) 	at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:65) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at app//org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base@11.0.12/java.util.ArrayList.forEach(ArrayList.java:1541) 	at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at app//org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at java.base@11.0.12/java.util.ArrayList.forEach(ArrayList.java:1541) 	at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129) 	at app//org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127) 	at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126) 	at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84) 	at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at app//org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at app//org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base@11.0.12/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base@11.0.12/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base@11.0.12/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base@11.0.12/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy5.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) 	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71) 	at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) 	at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) Caused by: org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.OffsetDateTime] for value '1986-06-02T15:55:24Z'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] 	at app//org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:47) 	at app//org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192) 	at app//org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:129) 	at app//org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73) 	... 87 more Caused by: java.lang.IllegalArgumentException: Parse attempt failed for value [1986-06-02T15:55:24Z] 	at org.springframework.format.support.FormattingConversionService$ParserConverter.convert(FormattingConversionService.java:223) 	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41) 	... 90 more Caused by: java.time.format.DateTimeParseException: Text '1986-06-02T15:55:24Z' could not be parsed at index 2 	at java.base/java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:2046) 	at java.base/java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1948) 	at java.base/java.time.OffsetDateTime.parse(OffsetDateTime.java:402) 	at org.springframework.format.datetime.standard.TemporalAccessorParser.doParse(TemporalAccessorParser.java:126) 	at org.springframework.format.datetime.standard.TemporalAccessorParser.parse(TemporalAccessorParser.java:85) 	at org.springframework.format.datetime.standard.TemporalAccessorParser.parse(TemporalAccessorParser.java:50) 	at org.springframework.format.support.FormattingConversionService$ParserConverter.convert(FormattingConversionService.java:217) 	... 91 more  ``` # Debug    Digging into debug, we end at a point in [`org.springframework.format.datetime.standard.TemporalAccessorParser`](https://github.com/spring-projects/spring-framework/blob/main/spring-context/src/main/java/org/springframework/format/datetime/standard/TemporalAccessorParser.java#L126) where there is a formatter, which happens to be  ``` result = {DateTimeFormatter@4506} ""Localized(SHORT,SHORT)""  printerParser = {DateTimeFormatterBuilder$CompositePrinterParser@4518} ""(Localized(SHORT,SHORT))""  locale = {Locale@4387} ""it_IT""  decimalStyle = {DecimalStyle@4388} ""DecimalStyle[0+-.]""  resolverStyle = {ResolverStyle@4519} ""SMART""  resolverFields = null  chrono = {IsoChronology@4390} ""ISO""  zone = null  ```  Note that the locale is `it_IT` by default. The date should be formatted as `02/06/1986` according to locale rules.  # Problem  At least without instantiating the full stack of Spring Boot, copying the test from the RequestParamMapResolver stuff, there **seems** to be no way to set the locale/format for the `WebDataBinderFactory`, which likely takes, somewhere, the default system language.  This has the derimental effect that when you need to be language-neutral (e.g. in parsing a GET request), you end up using the system language in parsing dates.  By exploring the code used to initialize the `ConfigurableWebBindingInitializer` there doesn't _seem_ to be a way to exclude language from consideration when converting formattable values.  # Possible solutions  TBD??  Well, at least by default add a language neutral formatter like ISO 8601 **along** with more language-specific formatters?","open","in: web,","djechelon","2021-11-04T17:29:59Z","2021-11-08T11:57:08Z"
"","27760","Resolving generic enum types (Enum) in fields when resolving MVC GET argument parameters","**Affects:** 5.3.10  ---  I am experiencing a problem with MVC method argument resolving in GET invocations. I have already reduced my problem to a bunch of classes and a reproducible example using Spring Test.  The idea is that I have a Filter Framework that heavily relies on generics. The first part of the FF, the one we are dealing with, is MVC argument resolution. The second part is translation into ORM predicates, which is out of scope.  ```java @Data public class SimpleFilter {      /**      * Requires the property to be equal to the value      */     protected T eq;     /**      * Requires the property to be different from the value      */     protected T ne;     /**      * Requires the property to be any of the supplied values      */     protected T[] in;     /**      * Requires the property not to be any of the supplied values      */     protected T[] notIn;      /**      * Requires the property to be either not null or null.      * The property can be used as:      *       * - Unspecified: null check is ignored      * - True: the property must be null      * - False: the property must be not null      */     protected Boolean isNull;  }  ```  Let's not talk about `IntegerFilter` and `LongFilter`, let's focus on a generic `EnumFilter`  ```java public class EnumFilter extends SimpleFilter { } ```  I know that Java **erases** generic types to the lower bound (`java.lang.Enum`), but the generic information is preserved in Java 11 when applied to a field.  Consider this particular filter  ```java @Data public class ExampleTestFilter implements Filter {       private AmlObjectTypeFilter exampleObjectTypeEnum;      private EnumFilter exampleObjectTypeEnumGeneric;      private SimpleFilter exampleObjectTypeSimple;      public static class AmlObjectTypeFilter extends SimpleFilter {      } } ```  Consider the following controller:  ```java @RestController @RequestMapping(""/exampleFiltering"") @Data public class FilteringArgumentResolverTestController {      private ExampleTestFilter filter;      /**      * Sample no-op function      */     @GetMapping     @ResponseStatus(HttpStatus.NO_CONTENT)     public void handleExampleTestFilter(@ModelAttribute(""filter"") ExampleTestFilter filter) {         this.filter = filter;     } } ```  Now consider the following tests  ```java @SpringBootTest(classes = AmlControlliBeApplication.class) @ComponentScan(basePackageClasses = FilterArgumentResolverWeb2Test.class) class FilterArgumentResolverWeb2Test extends AbstractOrbitE2eTest {      private final FilteringArgumentResolverTestController controller;      @Autowired     FilterArgumentResolverWeb2Test(ConfigurableApplicationContext applicationContext, PlatformTransactionManager transactionManager, DataSource dataSource, MockMvc mockMvc, ObjectMapper objectMapper, FilteringArgumentResolverTestController controller) {         super(applicationContext, transactionManager, dataSource, mockMvc, objectMapper);         this.controller = controller;     }       @Test     void resolveArgument_amlObjectTypeEnum_ok() {         String value = ""CONTROL"";          assertDoesNotThrow(() -> getMockMvc().perform(get(""/exampleFiltering"")                         .queryParam(""exampleObjectTypeEnum.eq"", value))                 .andExpect(status().isNoContent())         );          assertAll(                 () -> assertThat(controller.getFilter(), is(notNullValue())),                 () -> assertThat(controller.getFilter(), is(instanceOf(ExampleTestFilter.class))),                 () -> assertThat(controller.getFilter(), hasProperty(""exampleObjectTypeEnum"", is(notNullValue()))),                 () -> assertThat(controller.getFilter(), hasProperty(""exampleObjectTypeEnum"", hasProperty(""eq"", equalTo(AmlObjectType.CONTROL))))         );     }      @Test     void resolveArgument_amlObjectTypeSimple_ok() {         String value = ""CONTROL"";          assertDoesNotThrow(() -> getMockMvc().perform(get(""/exampleFiltering"")                         .queryParam(""exampleObjectTypeSimple.eq"", value))                 .andExpect(status().isNoContent())         );         assertAll(                 () -> assertThat(controller.getFilter(), is(notNullValue())),                 () -> assertThat(controller.getFilter(), is(instanceOf(ExampleTestFilter.class))),                 () -> assertThat(controller.getFilter(), hasProperty(""exampleObjectTypeSimple"", is(notNullValue()))),                 () -> assertThat(controller.getFilter(), hasProperty(""exampleObjectTypeSimple"", hasProperty(""eq"", equalTo(AmlObjectType.CONTROL))))         );     } }  ```   # The problems here  If I declare (even as a static class) a boilerplate filter class bound to the `AmlObjectType` enum, it works. But if I declare a field as `EnumFilter` Spring is unable to resolve the property as it thinks the property value should be cast to `Enum`, which is the generic bound of `EnumFilter`.   E.g. using `GET /api?exampleObjectTypeEnum.eq=CONTROL` works, using `GET /api?exampleObjectTypeEnumGeneric.eq=CONTROL` or `GET /api?exampleObjectTypeSimple.eq=CONTROL` does not.  It would not happen using JSON POST with Jackson Object Mapper.   ---   ```   assertDoesNotThrow(() -> getMockMvc().perform(get(""/exampleFiltering"")                         .queryParam(""exampleObjectTypeSimple.eq"", value))                 .andExpect(status().isNoContent())         ); ```  ``` Caused by: java.lang.AssertionError:  Expected: hasProperty(""exampleObjectTypeSimple"", hasProperty(""eq"", ))      but:  property 'exampleObjectTypeSimple'  property 'eq' was ""CONTROL"" 	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20) 	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6) 	at it.orbit.common.web.filtering.FilterArgumentResolverWeb2Test.lambda$resolveArgument_amlObjectTypeSimple_ok$44(FilterArgumentResolverWeb2Test.java:195) 	at org.junit.jupiter.api.AssertAll.lambda$assertAll$1(AssertAll.java:68) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$11$1.accept(ReferencePipeline.java:442) 	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913) 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) 	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578) 	at org.junit.jupiter.api.AssertAll.assertAll(AssertAll.java:77) 	... 87 more  ```  In this case, using `SimpleFilter` results in Spring setting the value CONTROL (String) as an Object into the property, which fails the assertion because I am comparing an enum with a string.  ---  ```   assertDoesNotThrow(() -> getMockMvc().perform(get(""/exampleFiltering"")                         .queryParam(""exampleObjectTypeEnumGeneric.eq"", value))                 .andExpect(status().isNoContent())         ); ```  ``` 2021-12-02 16:40:48.514 DEBUG 2248 --- [    Test worker] o.s.t.web.servlet.TestDispatcherServlet  : GET ""/exampleFiltering?exampleObjectTypeEnumGeneric.eq=CONTROL"", parameters={masked} 2021-12-02 16:40:48.520  WARN 2248 --- [    Test worker] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors Field error in object 'filter' on field 'exampleObjectTypeEnumGeneric.eq': rejected value [CONTROL]; codes [typeMismatch.filter.exampleObjectTypeEnumGeneric.eq,typeMismatch.exampleObjectTypeEnumGeneric.eq,typeMismatch.eq,typeMismatch.java.lang.Enum,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [filter.exampleObjectTypeEnumGeneric.eq,exampleObjectTypeEnumGeneric.eq]; arguments []; default message [exampleObjectTypeEnumGeneric.eq]]; default message [Failed to convert property value of type 'java.lang.String' to required type 'java.lang.Enum' for property 'exampleObjectTypeEnumGeneric.eq'; nested exception is java.lang.IllegalArgumentException: The target type java.lang.Enum does not refer to an enum]] ```  In this case, Spring detects the target type as `Enum`, and can't cast CONTROL to the root Enum class  ---  ```   assertDoesNotThrow(() -> getMockMvc().perform(get(""/exampleFiltering"")                         .queryParam(""exampleObjectTypeEnum.eq"", value))                 .andExpect(status().isNoContent())         ); ```  This succeeds because target property is of type `AmlObjectTypeFilter` which is bound directly to `AmlObjectType`  # Debugging  ``` org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessException details (1) are: PropertyAccessException 1: org.springframework.beans.TypeMismatchException: Failed to convert property value of type 'java.lang.String' to required type 'java.lang.Enum' for property 'exampleObjectTypeEnumGeneric.eq'; nested exception is java.lang.IllegalArgumentException: The target type java.lang.Enum does not refer to an enum 	at org.springframework.beans.AbstractNestablePropertyAccessor.convertIfNecessary(AbstractNestablePropertyAccessor.java:600) 	at org.springframework.beans.AbstractNestablePropertyAccessor.convertForProperty(AbstractNestablePropertyAccessor.java:609) 	at org.springframework.beans.AbstractNestablePropertyAccessor.processLocalProperty(AbstractNestablePropertyAccessor.java:458) 	at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:278) 	at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:266) 	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:104) 	at org.springframework.validation.DataBinder.applyPropertyValues(DataBinder.java:851) 	at org.springframework.validation.DataBinder.doBind(DataBinder.java:747) 	at org.springframework.web.bind.WebDataBinder.doBind(WebDataBinder.java:198) 	at org.springframework.web.bind.ServletRequestDataBinder.bind(ServletRequestDataBinder.java:118) 	at org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor.bindRequestParameters(ServletModelAttributeMethodProcessor.java:158) 	at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:171) 	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) 	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:179) 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:146) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) 	at org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:72) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) 	at org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:167) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:115) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:81) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:121) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:115) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:105) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter.doFilterInternal(BearerTokenAuthenticationFilter.java:121) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:91) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) 	at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:134) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) 	at org.springframew ```   I also found that Spring **could** be aware of the actual generic type of a field at some point. I was spelunking deep into `Introspector` and found the below  ![Screenshot debugging](https://user-images.githubusercontent.com/3042285/144455965-84857744-a2eb-45a0-9d07-dcb831a5b591.png)  This shows that the generic type is known for the field, but then looks like Spring ignores the property generic binding and works only on the (raw....) type.   At [`AbstractNestablePropertyAccessors#`](https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java#L458-L459) variable ph has now lost any information about the generic binding of the filter class's property.  And at line 590 the ""target class"" is now just `Enum`.   # Porkarounds  - Use HTTP POST to deserialize the filter object - Define a subclass for each Enum you want to use in a filter","open","status: feedback-provided,","djechelon","2021-12-02T15:59:35Z","2021-12-13T16:07:14Z"
"","27683","AntPathMatcher with a custom separator doesn't match correctly a specific String","**Affects:** 5.3.10  ---  **Background:**  I assume the [AntPathMatcher](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html) matches (among othersú a path against a pattern if all below apply: - `pattern` and `path` are equal - they both contain only alphanumeric characters (no Ant-specific characters such as `*`, `?` or `{` with `}` and no slashes `/` and `\`)  **Reproducible sample:**  The following code reproduces a strange behavior:  ```java new AntPathMatcher().match(""consent"", ""consent"");             // true new AntPathMatcher().match(""consentreg"", ""consentreg"");       // true  new AntPathMatcher(""\\t"").match(""consent"", ""consent"");        // true new AntPathMatcher(""\\t"").match(""consentreg"", ""consentreg"");  // false ```  Do I assume the behavior wrongly? If so, would you describe the behavior and how to fix my use case?  **Workaround:**   As of now, I must check whether the `pattern` is not Ant pattern and check the equality first:  ```java String string = ""consentreg""; String pattern = ""consentreg""; AntPathMatcher matcher = new AntPathMatcher(""\\t""); boolean result = (!matcher.isPattern(pattern) && pattern.equals(string)) || getAntPathMatcher().match(pattern, string); // true ```","closed","in: core,","Nikolas-Charalambidis","2021-11-12T22:14:40Z","2022-01-09T09:18:59Z"
"","26983","Issue #24395 broke ""user"" destinations","**Affects:** 5.3  User destinatinations are registered using the subscription-id and therefore they get ignored in SessionInfo in case the related ""topic"" destination has been registered before. The optimisation performed in https://github.com/spring-projects/spring-framework/issues/24395 has removed such support by trying to optimise cache lookup, expecting that the subscription-id was unique for a destination, which is not. The same submission-id can be used for multiple destination, that is.","closed","","alienisty","2021-05-27T07:34:56Z","2022-02-18T19:05:41Z"
"","27289","Make it possible to determine if circular references are prohibited or if the cycle just couldn't be broken","**Affects:** 5.3  In Spring Boot 2.6, we intend to [prohibit circular references by default](https://github.com/spring-projects/spring-boot/issues/27652) with a configuration property and Java API to turn it back on again. As part of this, I'd like to update our [`BeanCurrentlyInCreationFailureAnalyzer`](https://github.com/spring-projects/spring-boot/blob/60e57f7a3f8e3e92fb1d5b413b892d981e9e40fb/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/diagnostics/analyzer/BeanCurrentlyInCreationFailureAnalyzer.java) to suggest that, as a last resort, circular references could be turned back on again to possibly break the cycle. I'd like to only suggest this if `AbstractAutowireCapableBeanFactory.allowCircularReferences` is `false`. Unfortunately, without resorting to reflection, I can't get the flag's value. Could an accessor please be added?","closed","type: enhancement,","wilkinsona","2021-08-17T11:53:58Z","2021-08-17T15:20:58Z"
"","26950","High CPU during model validation","**Affects:** 5.2.3 **Environment:** K8s, EC2, Tomcat 9.0.33, JDK 11, Spring Boot 2.2.3, JPA, Hibernate Validator 6.0.18  --- We're running a Spring Boot REST service in a high load environment. Recently it happened, that after a pod startup, it claimed all CPU resources on that node and JVM CPU usage went up to 100% constantly. Looking at the tomcat HTTP busy threads they were at 147 (out of 200) and constantly increasing. All other pods were fine with 1-5 threads.  After taking a thread dump on the problematic pod, it showed, that all HTTP threads were interrupted at the very same codeplace seen below. After googling a bit, I stumbled across this existing ticket:  https://hibernate.atlassian.net/browse/HV-1779  which is going into the same direction. Taking a look at the comments, it seems to have something todo with concurrent access to specific parts in Hibernate.   Now I'm wondering is Spring handling concurrency in this regard properly? Especially during model validation?  UPDATE:   Looking at `SpringValidatorAdaptor`, it calls a validation method on the JSR `Validator` interface - which states that implementations must be thread safe. So I guess the ball is on Hibernate side? ``` ""http-nio-8080-exec-1"" - Thread t@42    java.lang.Thread.State: RUNNABLE         at java.base@11.0.6/java.util.WeakHashMap.get(WeakHashMap.java:404)         at org.hibernate.jpa.internal.util.PersistenceUtilHelper$MetadataCache.getClassMetadata(PersistenceUtilHelper.java:422)         at org.hibernate.jpa.internal.util.PersistenceUtilHelper.isLoadedWithReference(PersistenceUtilHelper.java:214)         at org.hibernate.jpa.HibernatePersistenceProvider$1.isLoadedWithReference(HibernatePersistenceProvider.java:186)         at javax.persistence.Persistence$PersistenceUtilImpl.isLoaded(Persistence.java:155)         at org.hibernate.validator.internal.engine.resolver.JPATraversableResolver.isReachable(JPATraversableResolver.java:52)         at org.hibernate.validator.internal.engine.resolver.CachingJPATraversableResolverForSingleValidation.lambda$isReachable$0(CachingJPATraversableResolverForSingleValidation.java:43)         at org.hibernate.validator.internal.engine.resolver.CachingJPATraversableResolverForSingleValidation$$Lambda$653/0x00007f1b99237db0.apply(Unknown Source)         at java.base@11.0.6/java.util.HashMap.computeIfAbsent(HashMap.java:1133)         at org.hibernate.validator.internal.engine.resolver.CachingJPATraversableResolverForSingleValidation.isReachable(CachingJPATraversableResolverForSingleValidation.java:43)         at org.hibernate.validator.internal.engine.ValidatorImpl.isReachable(ValidatorImpl.java:1323)         at org.hibernate.validator.internal.engine.ValidatorImpl.isValidationRequired(ValidatorImpl.java:1308)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateMetaConstraint(ValidatorImpl.java:546)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateConstraintsForSingleDefaultGroupElement(ValidatorImpl.java:515)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateConstraintsForDefaultGroup(ValidatorImpl.java:485)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateConstraintsForCurrentGroup(ValidatorImpl.java:447)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateInContext(ValidatorImpl.java:397)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedAnnotatedObjectForCurrentGroup(ValidatorImpl.java:626)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedConstraints(ValidatorImpl.java:587)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateInContext(ValidatorImpl.java:406)         at org.hibernate.validator.internal.engine.ValidatorImpl.access$300(ValidatorImpl.java:85)         at org.hibernate.validator.internal.engine.ValidatorImpl$CascadingValueReceiver.doValidate(ValidatorImpl.java:712)         at org.hibernate.validator.internal.engine.ValidatorImpl$CascadingValueReceiver.indexedValue(ValidatorImpl.java:678)         at org.hibernate.validator.internal.engine.valueextraction.ListValueExtractor.extractValues(ListValueExtractor.java:26)         at org.hibernate.validator.internal.engine.valueextraction.ListValueExtractor.extractValues(ListValueExtractor.java:16)         at org.hibernate.validator.internal.engine.valueextraction.ValueExtractorHelper.extractValues(ValueExtractorHelper.java:42)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedContainerElementsForCurrentGroup(ValidatorImpl.java:648)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedConstraints(ValidatorImpl.java:595)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateInContext(ValidatorImpl.java:406)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedAnnotatedObjectForCurrentGroup(ValidatorImpl.java:626)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedConstraints(ValidatorImpl.java:587)         at org.hibernate.validator.internal.engine.ValidatorImpl.validateInContext(ValidatorImpl.java:406)         at org.hibernate.validator.internal.engine.ValidatorImpl.validate(ValidatorImpl.java:173)         at org.springframework.validation.beanvalidation.SpringValidatorAdapter.validate(SpringValidatorAdapter.java:117)         at org.springframework.validation.DataBinder.validate(DataBinder.java:889)         at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.validateIfApplicable(AbstractMessageConverterMethodArgumentResolver.java:266)         at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:137)         at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)         at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)         at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)         at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888)         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)         at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)         at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)         at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)         at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)         at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)         at javax.servlet.http.HttpServlet.service(HttpServlet.java:660)         at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)         at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)         at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)         at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilterInternal(BasicAuthenticationFilter.java:203)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)         at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)         at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)         at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)         at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)         at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:103)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.springframework.boot.web.servlet.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:128)         at org.springframework.boot.web.servlet.support.ErrorPageFilter.access$000(ErrorPageFilter.java:66)         at org.springframework.boot.web.servlet.support.ErrorPageFilter$1.doFilterInternal(ErrorPageFilter.java:103)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.springframework.boot.web.servlet.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:121)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at acme.OrderLoggingContextCleanupFilter.doFilterInternal(OrderLoggingContextCleanupFilter.java:30)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at datadog.trace.instrumentation.springweb.HandlerMappingResourceNameFilter.doFilterInternal(HandlerMappingResourceNameFilter.java:47)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at acme.RequestIdFilter.doFilterInternal(RequestIdFilter.java:27)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)         at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)         at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)         at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)         at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)         at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)         at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)         at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594)         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)         - locked  (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)         at datadog.trace.bootstrap.instrumentation.java.concurrent.Wrapper.run(Wrapper.java:25)         at java.base@11.0.6/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)         at java.base@11.0.6/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)         at java.base@11.0.6/java.lang.Thread.run(Thread.java:834)     Locked ownable synchronizers:         - locked  (a java.util.concurrent.ThreadPoolExecutor$Worker) ```","closed","","vguna","2021-05-17T14:11:54Z","2022-02-18T19:05:40Z"
"","27453","ForwardedHeaderFilter and RelativeRedirectFilter redirect with code 303 instead of 302?","**Affects:** 5.2.16  [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303) says that 303 usually used for  PUT or POST request. Why not use 302 here?","open","in: web,","xiaoxiyao","2021-09-23T07:05:27Z","2021-11-10T12:14:31Z"
"","27782","Possible NPE in Spring MVC LogFormatUtils","**Affects:** 5.2.15  When using Spring Boot (2.3.12) and when I activate `debug: true` in application.yml, I can get a NullPointerException thrown by LogFormatUtils.formatValue(LogFormatUtils.java:62).  Sample stacktrace:  ``` java.lang.NullPointerException: null     at org.springframework.core.log.LogFormatUtils.formatValue(LogFormatUtils.java:62)     at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.lambda$writeWithMessageConverters$0(AbstractMessageConverterMethodProcessor.java:274)     at org.springframework.core.log.LogFormatUtils.traceDebug(LogFormatUtils.java:86)     at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:273)     at org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:219)     at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82)     at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:123)     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)     at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ```  Looking at the code of LogFormatUtils, the error can happen if value.toString() returns null. Which is the case in my situation (value is an instance if InMemoryResource in my sample)  ``` 	public static String formatValue(@Nullable Object value, boolean limitLength) { 		if (value == null) { 			return """"; 		} 		String str; 		if (value instanceof CharSequence) { 			str = ""\"""" + value + ""\""""; 		} 		else { 			try { 				str = value.toString(); 			} 			catch (Throwable ex) { 				str = ex.toString(); 			} 		} 		return (limitLength && str.length() > 100 ? str.substring(0, 100) + "" (truncated)..."" : str); 	} ```","closed","in: core,","gonzalad","2021-12-08T09:32:28Z","2021-12-14T16:02:48Z"
"","27552","Enhance DefaultResponseErrorHandler to allow logging complete error response body","**Affects:** 5.2.14.RELEASE  ---  This enhancement request is related to following Stack Overflow question. https://stackoverflow.com/questions/69475757/how-to-print-complete-error-message-when-logging-an-exception/69527775  **Problem Statement:** When using `RestTemplate` to call any REST API and it returns any 4xx or 5xx HTTP error code along with message body, complete message body is not getting logged if we simply catch and log the `Exception` object.  Here is a minimum reproducible example:  ```java import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.web.client.HttpClientErrorException; import org.springframework.web.client.RestTemplate;  @Slf4j public class RestTemplateTest {      @Test     void shouldPrintErrorForRestTemplate() {         RestTemplate restTemplate = new RestTemplate();         try {             restTemplate.getForEntity(""http://hellosmilep.free.beeceptor.com/error/notfound"", String.class);         } catch (Exception e) {             log.error(""Error calling REST API"", e);         }     } } ``` Output: ``` 10:28:11.347 [main] ERROR com.smilep.java.webapp.RestTemplateTest - Error calling REST API org.springframework.web.client.HttpClientErrorException$NotFound: 404 Not Found: [{   ""glossary"": {     ""title"": ""example glossary"",     ""GlossDiv"": {       ""title"": ""S"",       ""GlossList"": {         ""GlossEntry"": {           ""ID"": ""SGML"",           ""SortAs"": ""SGML"",           ""Glo... (593 bytes)]     at org.springframework.web.client.HttpClientErrorException.create(HttpClientErrorException.java:113)     at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:184)     at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:125)     at org.springframework.web.client.ResponseErrorHandler.handleError(ResponseErrorHandler.java:63)     at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:780)     at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:738)     at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:672)     at org.springframework.web.client.RestTemplate.getForEntity(RestTemplate.java:340)     at com.smilep.java.webapp.RestTemplateTest.shouldPrintErrorForRestTemplate(RestTemplateTest.java:15)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:498)     at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)     at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)     at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)     at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)     at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)     at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)     at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)     at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)     at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)     at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)     at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)     at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)     at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)     at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)     at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:212)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:208)     at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)     at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     at java.util.ArrayList.forEach(ArrayList.java:1257)     at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     at java.util.ArrayList.forEach(ArrayList.java:1257)     at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)     at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)     at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)     at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)     at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)     at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)     at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)     at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)     at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)     at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)     at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)     at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)     at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71)     at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)     at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235)     at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) ``` You can notice response message is truncated with `""Glo... (593 bytes)]` in above stack trace.  **Benefits of the enhancement:** Though, we can catch `HttpClientErrorException` and use `getResponseBodyAsString()` to read response body but I think we should be able to configure the size of error message to be logged before truncation kicks in when logging `Exception` object.   1. This would be helpful in those cases where we are not interested in catching specific exceptions when using `RestTemplate`. 2.  It will also reduce the boilerplate code to read the complete error response body from exception and log it.  **Root Cause of this issue:** Currently, `DefaultResponseErrorHandler` class has hardcoded size of 200 after which it truncates the error response body.  https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-web/src/main/java/org/springframework/web/client/DefaultResponseErrorHandler.java#L145  Rather than the consumers writing custom response error handlers, it would be much better if this hardcoded `maxChars` size can be made configurable.","closed","type: enhancement,","smilep","2021-10-13T06:32:42Z","2021-10-13T20:22:59Z"
"","27611","WebTestClient fails with large bodyValue sizes","**Affects:** 5.2.13.RELEASE  ---  When running the following test in Kotlin, everything runs fine and succeeds:  ```kotlin class MyTest @Autowired constructor(val testClient: WebTestClient) {   @Test   fun myTest() {     val payloadSize = 1024     testClient.post()       .uri(""..."")       .bodyValue(ByteBuffer.wrap(Random.nextBytes(payloadSize))       .exchange()       .expectStatus().isOk   } } ```  If I change `payloadSize` to a larger number like `4000000`, the same test fails with a `500 Internal Server Error` response and no message.  If I make a call to that same endpoint directly on a running instance of my service, it handles my request properly.  Calling my controller method directly from my test seems to suffice as a stable workaround for now, but this seems like a bug with `WebTestClient`.","closed","status: invalid,","AlexVulaj","2021-10-26T19:13:02Z","2021-10-28T15:03:07Z"
"","27338","If an exception occurs during Pre-Flight request processing, @ExceptionHandler fails to handle it.","**Affects:** 5.2.12  ---   Hi, I have used interceptor to verify something. And an exception occurred in the interceptor while processing the Pre-Flight request. However, since `PreFlightHandler` is not a child of `HandlerMethod`, the exception that occurs during the Pre-Flight process is not handled by the `ExceptionHandler`.(Since `AbstractHandlerMethodExceptionResolver` only apply to `HandlerMethod`). So, response status becomes 500 not status I intended. Is this intended or just a bug?","closed","in: web,","ddaaac","2021-08-30T14:14:06Z","2021-10-08T14:28:56Z"
"","26883","getBeansOfType does not find some beans which are wrapped into a proxy","**Affects:** 5.2.11.RELEASE, 5.3.6  Issue: If the bean is wrapped by aop (for example if it was marked with @Transactional somewhere) into a proxy AND signleton instance was precreated (injected into some @Autowired field) already then ListableBeanFactory.getBeansOfType will not find it.  What i am trying to achieve: I have a bunch of services implementations which all extend CrudService abstract generic class and I want find all implementations automatically.  Possible fix - change ResolvableType.isInstance(Object obj) implementation from: return (obj != null && isAssignableFrom(obj.getClass())); to: return (obj != null && isAssignableFrom(obj.getClass())) || (checkSomehowIsItAProxy(obj) && isInstance(getWrappedObjectSomehow(obj)));","open","in: core,","Raigedas","2021-04-30T07:36:39Z","2021-11-10T10:03:04Z"
"","27296","Problem of ThreadPoolTaskExecutor when using @Bean","**Affects:** 5.2.0  ---  When I use @Bean annotation to create a thread pool(ThreadPoolTaskExecutor) in my project,  the thread pool will be created repeatedly  if I use Initialize() at the same time. Code is shown below: ```java @Bean(""myThreadPool"") public ThreadPoolTaskExecutor getTaskExecutor() {         ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();           taskExecutor.setKeepAliveSeconds(300);           taskExecutor.setAllowCoreThreadTimeOut(true);         taskExecutor.setAwaitTerminationSeconds(60);         taskExecutor.setWaitForTasksToCompleteOnShutdown(true);         taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());         taskExecutor.setThreadNamePrefix(""my-thread-pool-"");         taskExecutor.setCorePoolSize(8);         taskExecutor.setMaxPoolSize(16);         taskExecutor.setQueueCapacity(100);         taskExecutor.initialize();         return taskExecutor; } ``` then I use this function in my service: ```java public class myService{       @Autowired     @Qualifier(""myThreadPool"")     private ThreadPoolTaskExecutor taskExecutor; } ``` When the program start, the executor(thread pool) will be created twice. The log is :  Initializing ExecutorService Initializing ExecutorService 'myThreadPool'  The reason is that  I call initizlize() in function getTaskExecutor and a thread pool will be created. After that, Bean 'myThreadPool'  injects into myService, and function afterPropertiesSet() in class ThreadPoolTaskExecutor also call initizlize(). So the second thread pool will be created. I want to know whether this condition is reasonable. What is the design idea of calling initizlize() in function afterPropertiesSet()? Or I shouldn't call initialize() in this case?  Code in Spring： https://github.com/spring-projects/spring-framework/blob/4a9c7e631c60a12f3426d42143e9e27be0bf68ab/spring-context/src/main/java/org/springframework/scheduling/concurrent/ExecutorConfigurationSupport.java#L172-L187 In line 182 in function initialize(), I think it is more appropriately to verify that whether this.executor is null before calling initializeExecutor()","closed","status: invalid,","tk1996amaranth","2021-08-19T10:17:47Z","2021-08-19T14:36:48Z"
"","27306","`JdbcTemplate.queryForList` maps `SMALLINT` to `Integer` instead of `Short`","**Affects:** 5.1.9  ---  For some reason the `Map` objects returned by `JdbcTemplate.queryForList()` use `java.lang.Integer` to represent database fields defined as `SMALLINT`. The appropriate mapping would be `java.lang.Short`. It creates extra code to accept an `Integer` and then convert to `Short`. So at best this is a usability issue, but it feels more like a bug.  Database is Db2 11.1.4.4.","closed","status: declined,","jrickard27","2021-08-21T04:10:03Z","2021-08-25T10:43:49Z"
"","27451","DefaultMessageListenerContainer does not log an error/warning when consumer tasks have been rejected","**Affects:** 5.1.2, 5.3.9  _Background:_ We experienced an issue due to `DefaultMessageListenerContainer` no longer receiving messages. This was because of a misunderstanding on our part how `ThreadPoolExecutorFactoryBean` works. We used following settings for the executor:  corePoolSize=5 maximumPoolSize=10 queueCapacity=1  which was injected into a `DefaultMessageListenerContainer` with these parameters:  concurrentConsumers=1 maxConcurrentConsumers=10 maxMessagesPerTask=1  The goal was to have a dynamic scaling of threads aligned with the scaling of consumers; however we shouldn't have set neither a queue capacity nor a maximum pool size and rather used something like `Executors.newCachedThreadPool()`; after all, the container will take care of not scheduling more than maxConcurrentConsumers * 2 threads in the worst case (since each task reschedules itself if all are busy).  Our problem was reproducible given [this test](https://github.com/grubeninspekteur/defaultmessagelistenercontainer/blob/master/src/test/java/com/example/demo/MessageListenerTest.java), the log is available [here](https://github.com/grubeninspekteur/defaultmessagelistenercontainer/blob/master/experiment.log) (I killed the process after no more messages were being received).  _The issue:_ There are some rejected task debug level log entries due to the executor misconfiguration, but no warn or error entries. I would expect at least the error ""All scheduled consumers have been paused, probably due to tasks having been rejected. Check your thread pool configuration! Manual recovery necessary through a start() call."" at [DefaultMessageListenerContainer.java#L1180-L1183](https://github.com/spring-projects/spring-framework/blob/main/spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java#L1180-L1183) to appear. I don't understand why it didn't, since everything happens inside locks held on the `lifecycleMonitor`.  On a side note, why is the rejection of tasks logged only at debug level (not even info)? After all, dropping below `concurrentConsumers` raises a warning (this works in the test if I set `concurrentConsumers` to 2). Is there any use case of configuring an executor that occasionally rejects tasks?","closed","type: enhancement,","grubeninspekteur","2021-09-22T20:27:50Z","2021-09-23T14:38:10Z"
"","27061","SimpleJdbcInsert gets confused with the same table names across different schemas","**Affects:** 4.3.14.RELEASE  --- Within the same database we have several (almost) duplicate schemas (dev, test, uat,  etc).   `SimpleJdbcInsert` seems to get confused with having the same table names in different schemas.  It seems to get metadata from all tables with the matching name across all schemas and whichever table it processes last is the one it keeps in its map of columns.  This causes problems when the table schemas do not match - columns that are in one schema but not another get skipped at random when inserting values.  It should only be getting the table metadata for the active schema.","open","status: feedback-provided,","davidhedley","2021-06-15T06:38:37Z","2021-06-16T07:02:41Z"
"","27893","Generic error when invalid json parsing/decoding happens in webflux","**Affects:** 2.6.1  I'm using starter-webflux, and when invalid json is sent to my service I get a super generic error:  ``` {   ""timestamp"": ""2022-01-05T20:33:32.425+00:00"",   ""path"": ""/pets"",   ""status"": 400,   ""error"": ""Bad Request"",   ""message"": ""Failed to read HTTP message"", } ```  notes: - `spring-boot-devtools` is active - traces in responses is turned off - I would like to avoid all the package - info leaving my API  If I include a stacktrace in my response I see that this is a `org.springframework.core.codec.DecodingException`. It seems like when webflux is used the message of this exception is not being mapped to the error response from spring.   Is this something that I can fix in my app? Or is this something that is could be improved in springboot?  --- I've done some additional reading, and it seems like this still open ticket is very similar: https://github.com/spring-projects/spring-boot/issues/18815","closed","status: duplicate,","ahatzz11","2022-01-05T22:21:28Z","2022-01-06T13:41:21Z"
"","27718","Property values not properly loaded when method is annotated @ConditionalOnExpression","**Affects:** 2.5.4  Not all the properties are loaded when the bean is loaded based on the condition present in the configuration. Without the condition the values are loaded correctly.         ``` 	@Bean 	@ConditionalOnExpression(""#{appProperties.approach2 eq false}"") 	public String approch2(AppProperties properties) { 		System.out.println(properties.message); //prints null 		System.out.println(properties.degree); //prints 0 		return """"; 	} ```  application.properties ``` application.message=""some message"" application.degree=5 application.approach1=true application.approach2=false ``` ---","open","in: core,","vvijayv","2021-11-18T19:27:31Z","2021-11-24T19:46:04Z"
"","27380","RestTemplate ResponseErrorHandler cannot handle 404 FileNotFound","**Affects:** 2.5.2  ---  I'm making a call to an API which returns 404 with a detailed message in body. If I do the request, I get something like `Caused by: java.io.FileNotFoundException: https://exanple.com/fancy-api/request`.  So, I tried to use `DefaultResponseErrorHandler` but after going through the code with the debugger I noticed that the I/O exception is thrown before the `ResponseErrorHandler` can handle it.  https://github.com/spring-projects/spring-framework/blob/41ab2687338c6419cb0f04c1bf79a9c52157a861/spring-web/src/main/java/org/springframework/web/client/RestTemplate.java#L765-L792  The exception is thrown in 776 but the handler is called in 777. It would be nice if I can also get the body of I/O Exceptions like `FileNotFoundException`.  Might also want to refer #15589.","closed","for: stackoverflow,","rala72","2021-09-10T08:53:14Z","2021-09-13T08:09:59Z"
"","27486","Support generics (and POJO object mapper) for jsonPath ResultMatcher","**Affects:** 2.4.1  ---  When asserting JSON content in a MockMvc, the provided `MockMvcResultMatchers.jsonPath` functions support automatic type deduction or an explicit `Class` parameter (via #23141), but there is an additional version in JsonPath that supports a `TypeRef` generic and is not exposed. It would be very useful if it was, especially for `containsInAnyOrder` assertions of POJOs.  For this purpose, it would furthermore be useful if a POJO mapper was configured since afaics it isn't currently.  [JsonPath Documentation](https://github.com/json-path/JsonPath#what-is-returned-when)  ```java var configuration = Configuration.defaultConfiguration().mappingProvider(new JacksonMappingProvider()); var document = JsonPath.using(configuration).parse(JSON_DOCUMENT); var typeRef = new TypeRef() {}; List titles = document.read(""$.store.book"", typeRef); ```","open","in: test,","FichteFoll","2021-09-28T15:28:27Z","2021-11-10T11:50:24Z"
"","27166","EntityManagerFactoryUtils.closeEntityManager() exceptions are not being thrown.","**Affects:** 2.3.3  If there is bad code, say that doesn't rollback or commit a transaction, when the Entity Manager tries to close, it will simply log the error, and in my case leaves a DB connection tied up with a bad state.   I am using JPA, along with accessing the DB connection to mix nested (NEW) transactions. And if the EntityManager close fails then the connection becomes unusable with the following error:  **org.springframework.transaction.IllegalTransactionStateException: Pre-bound JDBC Connection found! JpaTransactionManager does not support running within DataSourceTransactionManager if told to manage the DataSource itself. It is recommen ded to use a single JpaTransactionManager for all transactions on a single DataSource, no matter whether JPA or JDBC access.**  Here is the code in question:  	/** 	 * Close the given JPA EntityManager, 	 * catching and logging any cleanup exceptions thrown. 	 * @param em the JPA EntityManager to close (may be {@code null}) 	 * @see javax.persistence.EntityManager#close() 	 */ 	public static void closeEntityManager(@Nullable EntityManager em) { 		if (em != null) { 			try { 				if (em.isOpen()) { 					em.close(); 				} 			} 			catch (Throwable ex) { 				logger.error(""Failed to release JPA EntityManager"", ex); 			} 		} 	}  So - my question is this: shouldn't this exception be thrown, and not just logged? Because it is not thrown there is no way to detect the method that forgot to commit/rollback the transaction. No way to recover.  I would think it would be much better to log, and then throw it.","open","in: data,","byoder7","2021-07-13T23:57:19Z","2021-11-10T11:38:11Z"
"","27171","Request parameters as null,  but queryString is not","**Affects:** 2.2.4.RELEASE  ---  There is  strange behavior in Spring controller. Once per some amount of requests (even identical request), Spring Controller (GET) gets all input request parameters as null, ParameterMap of HttpServletRequest is empty, but queryString (HttpServletRequest.getQueryString) is not null (has expected value). Metric shows that error occurs  in about 0.1 - 0.7% of case in high load, and can't reproducible locally.  In tcpdump request string looks correct, so likely middle-ware is not involved.   **Any idea what could be the cause/make some influence that lead to such behavior?**   **Example**   Request: https:some-host/version/endpoint?prm1=Value1&prm2=2&prm3=Value3 Response: mostly 200, but in ~0.5%  204  Controller code: ```java import io.micrometer.core.instrument.MeterRegistry; import io.swagger.v3.oas.annotations.Operation; import io.swagger.v3.oas.annotations.media.Schema; import io.swagger.v3.oas.annotations.tags.Tag; import lombok.AllArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.apache.logging.log4j.util.Strings; import org.springframework.http.ResponseEntity; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController;  import javax.servlet.http.HttpServletRequest; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import java.util.Objects;  @RestController @RequestMapping(""version"") @AllArgsConstructor @Schema(name = ""Swagger schema"") @Tag(name = ""Swagger tag"") @Validated @Slf4j public class SomeService {      private final MeterRegistry meterRegistry;    //other dependencies      @Operation(description = ""Swagger description"")     @GetMapping(value = ""endpoint"")     public ResponseEntity find(             @RequestParam(required = false, name = ""prm1"") String parameter1,             @RequestParam(required = false, name = ""prm2"", defaultValue = ""1"") @Min(1) @Max(2) @Schema(description = ""Some description for prm2"") Integer parameter2,             @RequestParam(required = false, name = ""prm3"") @Schema(description = ""Some description for prm3"") String parameter3,             HttpServletRequest request) {          String queryString = request.getQueryString();         //Issue: queryString=prm1=Value1&prm2=2&prm3=Value3         //but parameter1=null parameter2=null parameter3=null         if (Strings.isNotBlank(queryString) && queryString.contains(""prm1"") && Objects.isNull(parameter1)) {             meterRegistry.counter(""issue_total"").increment();         }          //...         if(Objects.isNull(parameter1)){             return ResponseEntity.noContent().build();         }else {             return ResponseEntity.ok(""OK"");         }     } } ```","open","in: web,","olgakorichkovskaya","2021-07-14T08:34:57Z","2021-11-08T11:46:11Z"
"","27488","MediaType.sortBySpecificityAndQuality throws java.lang.IllegalArgumentException: Comparison method violates its general contract","**Affects:**  spring-web:5.3.9 [Original Problem](https://stackoverflow.com/questions/69363790/java-rest-template-throws-java-lang-illegalargumentexception-comparison-method) from stackoverflow  Implementation of [QUALITY_VALUE_COMPARATOR ](https://github.com/spring-projects/spring-framework/blob/v5.3.9/spring-web/src/main/java/org/springframework/http/MediaType.java#L788) seems violate general contract of comparator.  The issue can be reproduced by below program. OS: _Window 10_  JDK: _openjdk version ""16"" 2021-03-16_ ``` import org.springframework.http.MediaType;  import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.Map;  public class TestMediaTypeSort {     public static void main(String[] args) {         demonstrateViolation();         reproducibleExample();     }      private static void reproducibleExample() {         Map mapSize1 = Map.of(""a"", ""b"");         Map mapSize2 = Map.of(""a"", ""b"", ""c"", ""d"");         Map mapSize3 = Map.of(""a"", ""b"", ""c"", ""d"", ""e"", ""f"");         List mediaTypeList = new ArrayList();         for (int i = 0; i < 20; i++) {             mediaTypeList.add(new MediaType(""c"", ""a"", mapSize1));             mediaTypeList.add(new MediaType(""c"", ""a"", mapSize2));             mediaTypeList.add(new MediaType(""c"", ""a"", mapSize3));             mediaTypeList.add(new MediaType(""b"", ""a"", mapSize1));             mediaTypeList.add(new MediaType(""b"", ""a"", mapSize2));             mediaTypeList.add(new MediaType(""b"", ""a"", mapSize3));             mediaTypeList.add(new MediaType(""b"", ""a"", mapSize2));         }         MediaType.sortBySpecificityAndQuality(mediaTypeList);     }      private static void demonstrateViolation() {         Map mapSize1 = Map.of(""a"", ""b"");         Map mapSize2 = Map.of(""a"", ""b"", ""c"", ""d"");         Map mapSize3 = Map.of(""a"", ""b"", ""c"", ""d"", ""e"", ""f"");         MediaType a = new MediaType(""c"", ""a"", mapSize1);         MediaType b = new MediaType(""b"", ""a"", mapSize2);         MediaType c = new MediaType(""b"", ""a"", mapSize3);         System.out.println(""Compare a with b:"" + QUALITY_VALUE_COMPARATOR.compare(a, b));         System.out.println(""Compare a with c:"" + QUALITY_VALUE_COMPARATOR.compare(a, c));         System.out.println(""Compare b with c:"" + QUALITY_VALUE_COMPARATOR.compare(b, c));     }      // Copied from MediaType.java     public static final Comparator QUALITY_VALUE_COMPARATOR = (mediaType1, mediaType2) -> {         double quality1 = mediaType1.getQualityValue();         double quality2 = mediaType2.getQualityValue();         int qualityComparison = Double.compare(quality2, quality1);         if (qualityComparison != 0) {             return qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3         } else if (mediaType1.isWildcardType() && !mediaType2.isWildcardType()) {  // */* < audio/*             return 1;         } else if (mediaType2.isWildcardType() && !mediaType1.isWildcardType()) {  // audio/* > */*             return -1;         } else if (!mediaType1.getType().equals(mediaType2.getType())) {  // audio/basic == text/html             return 0;         } else {  // mediaType1.getType().equals(mediaType2.getType())             if (mediaType1.isWildcardSubtype() && !mediaType2.isWildcardSubtype()) {  // audio/* < audio/basic                 return 1;             } else if (mediaType2.isWildcardSubtype() && !mediaType1.isWildcardSubtype()) {  // audio/basic > audio/*                 return -1;             } else if (!mediaType1.getSubtype().equals(mediaType2.getSubtype())) {  // audio/basic == audio/wave                 return 0;             } else {                 int paramsSize1 = mediaType1.getParameters().size();                 int paramsSize2 = mediaType2.getParameters().size();                 return Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic             }         }     }; }  ``` ---","closed","type: bug,","samabcde","2021-09-28T16:27:14Z","2021-10-19T10:18:46Z"
"","27104","Add ability to resolve parameters in the TestContext framework","**Affects:**  Spring 5.3.8  ---  My scenario:  I'm using Spring Session in my application and the user is required to login (which generates a session) before any API can be called. To simulate this in my unit/integration test, I use a `TestExecutionListener ` to create a session in `beforeTestClass`/`beforeTestMethod` and then delete the session in `afterTestClass`/`afterTestMethod`. However to actually call the API with the session, I need to access the session ID in the test method itself, but I realized there is no (straightforward) way to pass the session ID from my `TestExecutionListener` implementation to my test method (do let me know if there is such a way).  So I have switched to use JUnit 5's Extension mechanism instead so I can use `ParameterResolver` to pass the session ID to the test method by using the method parameter. However using JUnit 5 Extension creates another issue: I can't control the order of my Extension relative to other built-in `TestExecutionListener` implementations -- for example, I wish to run my Extension after the `SqlScriptsTestExecutionListener` so the changes from the script specified in `@Sql` are visible to my Extension.  So I hope the TestContext framework can add the ability to resolve parameters, but I'm not sure if this is possible since not all test frameworks that the TestContext framework supports have the ability to resolve parameters like JUnit Jupiter.","closed","in: test,","dicksonleong","2021-06-29T11:41:03Z","2022-01-17T15:37:57Z"
"","27287","Serialization Inclusion Enhancement for nested empty objects","**Affects:**  org.springframework.boot:spring-boot-starter-web:2.5.3  Problem:  I have a requirement to output object values. All null values should be included, but nested object should be replaced by nulls if it's empty (consists from only null fields).  For instance, this is wrong answer  ```json {   ""name"" : null,   ""age"" : null,   ""objectGroup1"" : {     ""id"" : null,     ""name"" : null   },   ""objectGroup2"" : null } ```  This is correct answer, that I must respond with:  ```json {   ""name"" : null,   ""age"" : null,   ""objectGroup1"" : null,   ""objectGroup2"" : null } ```  objectGroup1 was set to null.  I tried to create a Value Filter but I realized that I can't mark certain objects as null if it is empty. I also tried to write recursive ResponseBodyAdvice, and it worked, it recursively set null for empty objects, but it looks a bit ugly.  I want somehow to be able to override non simple object serialization of any kind of class (for any DTO class) to be able to set nested objects as null if its ""empty"" inside.","closed","for: stackoverflow,","ailjushkin","2021-08-16T23:21:27Z","2021-11-11T09:18:34Z"
"","27556","No method of type AbstractJackson2Decoder::customizeReader","**Affects:**  All spring versions  Why does `AbstractJackson2Encoder` have a method `customizeWriter()`, but `AbstractJackson2Decoder` does not have a similar method `customizeReader()`.  If you look at the `getObjectReader()` method at https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java#L205 and similarly, the `getObjectWriter()` method at https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Encoder.java#L297 , they are fairly similar, but `createObjectReader()` seems to have a call to `customizeWriter()`.  My understanding is possibly the difference between the `get` and `create` in the method names, but both of them essentially still call `mapper.writerFor(...)` or `mapper.readerFor(...)` type calls. Is there a specific reason why such a method is not available? Also any workarounds available to be able to customize the reader as part of the `decode` flow.","closed","in: web,","rohanprabhu-jm","2021-10-13T14:44:59Z","2021-10-27T19:33:43Z"
"","27867","Enhance the assignment in a catch block","**Affects:**  all  Changing a catch block parameter is very discouraged.  The change will affect **two methods** into **two different classes**.  In `buildNativeEntityManagerFactory()` in `org.springframework.orm.jpa.AbstractEntityManagerFactoryBean` and in `processLocalProperty(PropertyTokenHolder, PropertyValue)` in `org.springframework.beans.AbstractNestablePropertyAccessor`.  For example the method *buildNativeEntityManagerFactory()* must be like this:  ```java 	private EntityManagerFactory buildNativeEntityManagerFactory() { 		EntityManagerFactory emf; 		try { 			emf = createNativeEntityManagerFactory(); 		} 		catch (PersistenceException ex) { 			PersistenceException persistenceException = ex; 			if (persistenceException.getClass() == PersistenceException.class) { 				// Plain PersistenceException wrapper for underlying exception? 				// Make sure the nested exception message is properly exposed, 				// along the lines of Spring's NestedRuntimeException.getMessage() 				Throwable cause = persistenceException.getCause(); 				if (cause != null) { 					String message = persistenceException.getMessage(); 					String causeString = cause.toString(); 					if (!message.endsWith(causeString)) { 						persistenceException = new PersistenceException(message + ""; nested exception is "" + causeString, cause); 					} 				} 			} 			if (logger.isErrorEnabled()) { 				logger.error(""Failed to initialize JPA EntityManagerFactory: "" + persistenceException.getMessage()); 			} 			throw persistenceException; 		}  		JpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter(); 		if (jpaVendorAdapter != null) { 			jpaVendorAdapter.postProcessEntityManagerFactory(emf); 		}  		if (logger.isInfoEnabled()) { 			logger.info(""Initialized JPA EntityManagerFactory for persistence unit '"" + getPersistenceUnitName() + ""'""); 		} 		return emf; 	} ```","closed","status: superseded,","alidandach","2021-12-31T14:05:15Z","2022-01-03T13:00:15Z"
"","27616","Spring web-flux crashes occasionally with AccessControlException","**Affects:**  5.3.9  ``` Caused by: com.fasterxml.jackson.databind.JsonMappingException: access denied (""java.lang.RuntimePermission"" ""accessDeclaredMembers"") (through reference chain: java.util.LinkedHashMap[""timestamp""]) 	at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:390) 	at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:349) 	at com.fasterxml.jackson.databind.ser.std.StdSerializer.wrapAndThrow(StdSerializer.java:316) 	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeFields(MapSerializer.java:811) 	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeWithoutTypeInfo(MapSerializer.java:764) 	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:720) 	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:35) 	at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480) 	at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:400) 	at com.fasterxml.jackson.databind.ObjectWriter$Prefetch.serialize(ObjectWriter.java:1510) 	at com.fasterxml.jackson.databind.ObjectWriter.writeValue(ObjectWriter.java:1006) 	at org.springframework.http.codec.json.AbstractJackson2Encoder.encodeValue(AbstractJackson2Encoder.java:222) 	at org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$0(AbstractJackson2Encoder.java:150) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2398) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:162) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.MonoSingle$SingleSubscriber.doOnRequest(MonoSingle.java:103) 	at reactor.core.publisher.Operators$MonoInnerProducerBase.request(Operators.java:2731) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2194) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:2068) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.MonoSingle$SingleSubscriber.onSubscribe(MonoSingle.java:115) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:92) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:55) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:210) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:74) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:82) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onNext(FluxConcatArray.java:178) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2398) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:2194) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:2068) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:55) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:209) 	at reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:81) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.Operators.error(Operators.java:198) 	at reactor.core.publisher.MonoError.subscribe(MonoError.java:53) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.Operators.error(Operators.java:198) 	at reactor.core.publisher.MonoError.subscribe(MonoError.java:53) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onError(FluxPeekFuseable.java:234) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxDoOnEach$DoOnEachSubscriber.onError(FluxDoOnEach.java:195) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onError(FluxContextWrite.java:121) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:172) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:172) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onError(FluxMapFuseable.java:140) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2063) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:270) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.Operators.error(Operators.java:198) 	at reactor.core.publisher.MonoError.subscribe(MonoError.java:53) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2063) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:129) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:74) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:127) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.complete(MonoIgnoreThen.java:284) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onNext(MonoIgnoreThen.java:187) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:398) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:299) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:398) 	at reactor.core.publisher.MonoRunnable.subscribe(MonoRunnable.java:50) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:255) 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51) 	at reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:64) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:157) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 	at reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:251) 	at reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:336) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:180) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:101) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2398) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.request(FluxDefaultIfEmpty.java:77) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.request(MonoPeekTerminal.java:139) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:498) 	at reactor.core.publisher.MonoZip$ZipInner.onSubscribe(MonoZip.java:325) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onSubscribe(MonoPeekTerminal.java:152) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onSubscribe(FluxDefaultIfEmpty.java:91) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:482) 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:55) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4338) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:393) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:129) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:127) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:388) 	at reactor.core.publisher.MonoPublishOn$PublishOnSubscriber.run(MonoPublishOn.java:181) 	at reactor.core.scheduler.ExecutorScheduler$ExecutorPlainRunnable.run(ExecutorScheduler.java:132) 	at .ExceptionHandlingAsyncTaskExecutor.lambda$createWrappedRunnable$1(ExceptionHandlingAsyncTaskExecutor.java:82) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.lang.Thread.run(Thread.java:834)  ```","closed","status: waiting-for-feedback,","eltonkent","2021-10-27T14:30:06Z","2021-11-23T07:26:53Z"
"","27533","Links in Core Technologies docs chapter 1.4.2 returns 404","**Affects:**  5.3.10  --- Links in \ tag : http://www.springframework.org/schema/p and http://www.springframework.org/schema/c Links can be found in chapter 1.4.2 sections in sections **XML Shortcut with the p-namespace** and also **XML Shortcut with the c-namespace**.","closed","status: invalid,","rprominski","2021-10-08T06:31:30Z","2021-10-08T14:58:50Z"
"","27087","Performance degradation when using SSL with WebFlux","**Affects:**   spring-boot-starter-webflux:2.4.6 spring-boot-starter-reactor-netty:2.4.6  **Description**  I have a small WebFlux app that, for the sake of this issue, just logs stuff when it receives a request from a HTTP endpoint. This endpoint is being hit by a load test performed by Gatling on my laptop.  The app runs on a Docker container (limited to 1 CPU and 2 GB of RAM) and using 150 netty IO workers. With SSL off (plain HTTP) the container can handle 100 requests per second: ``` ================================================================================ ---- Global Information -------------------------------------------------------- > request count                                      90000 (OK=90000  KO=0     ) > min response time                                    110 (OK=110    KO=-     ) > max response time                                  81107 (OK=81107  KO=-     ) > mean response time                                  3562 (OK=3562   KO=-     ) > std deviation                                       8615 (OK=8615   KO=-     ) > response time 50th percentile                        199 (OK=199    KO=-     ) > response time 75th percentile                        338 (OK=338    KO=-     ) > response time 95th percentile                      21932 (OK=21905  KO=-     ) > response time 99th percentile                      42839 (OK=42841  KO=-     ) > mean requests/sec                                 99.889 (OK=99.889 KO=-     ) ---- Response Time Distribution ------------------------------------------------ > t < 800 ms                                         73446 ( 82%) > 800 ms < t < 1200 ms                                 650 (  1%) > t > 1200 ms                                        15904 ( 18%) > failed                                                 0 (  0%) ================================================================================  ``` If I add SSL, the load test for 100 req/s fails with a bunch of ""SSLException: handshake timed out"". Notice I see this error on the load test output, not on the container. I have to decrease the load to **just 15 req/s** to avoid the handshake errors. I know that SSL will impose some overhead but I wasn't expecting this degradation. By the way, this is my netty server configurer: ```     @Bean     public NettyServerCustomizer nettyServerCustomizer()     {         return httpServer -> httpServer.idleTimeout(Duration.ofMinutes(10))                                    .option(ChannelOption.SO_BACKLOG, 65535)                                    .option(ChannelOption.SO_REUSEADDR, true)                                    .childOption(ChannelOption.TCP_NODELAY, true)                                    .childOption(ChannelOption.SO_KEEPALIVE, true);     } ```  Please let me know if I should raise this directly on the reactor-netty project or if more details are needed.  Thanks!","closed","for: stackoverflow,","jonathannaguin","2021-06-21T13:53:31Z","2021-06-22T15:22:11Z"
"","27819","javax.servelet.http.Part field cannot be resolved with StandardMultipartHttpServletRequest.","**Affects: 5.3.2**  **Related issue: #15220**  Hello, I'm trying to upload a file via multipart/form-data request. The handler method requires one object parameter, which contains a field of type `javax.servelet.http.Part`. As `MultipartFile` typed field can be resolved with parts, I've expected the same from `Part`.  ```java   @Setter   @Getter   @AllArgsConstructor   @NoArgsConstructor   public class UserHavingPartVO {       private String name;       private int age;        private Part file;   }    @Controller   public class FileUploadController {        @PostMapping(""/vopart"")       public ResponseEntity bindVOHavingPart(UserHavingPartVO userVo){           if (userVo.getFile() == null)               return ResponseEntity.noContent().build();           return ResponseEntity.ok().build();       }   } ```  As described in **senario 7** (from related issue https://github.com/spring-projects/spring-framework/issues/15220),  `Part` field could not be bind with values, as `StandardMultipartHttpServletRequest` wraps `Part` into private class `StandardMultipartHttpServletRequest.StandardMultipartFile`.  In turn, conversion from `StandardMultipartFile` to `Part` had occured but failed.  Test and generated logs are below. I hope available approaches are found for this scenario. ```java @SpringJUnitWebConfig(classes = {WebConfig.class}) public class FileUploadControllerTests {      MockMvc mvc;      FileUploadController controller = new FileUploadController();      MockPart mockPart = new MockPart(""file"", ""filename.png"", ""file"".getBytes());      @BeforeEach     public void setup() {         this.mvc = MockMvcBuilders.standaloneSetup(controller).build();     }      @DisplayName(""params + Part -> VO Having Part : 400 Error"")     @Test     void bindVOHavingPart() throws Exception {         MultipartHttpServletRequest request = (MultipartHttpServletRequest)                 mvc.perform(multipart(""/vopart"")                         .part(mockPart)                         .param(""name"", ""jaebin-joo"")                         .param(""age"", ""11""))                     .andExpect(status().is4xxClientError()) // StandardMultipartFile 타입을 Part로 변환할 수 없기 때문에                     .andReturn().getRequest();          assertThat(request.getParts().size()).isEqualTo(1);         assertThat(request.getMultiFileMap().size()).isEqualTo(0);     } } ``` ``` main] DEBUG org.springframework.web.method.HandlerMethod - Could not resolve parameter [0] in public org.springframework.http.ResponseEntity org.binchoo.study.spring.multipart.profileservice.controller.FileUploadControllerTests$FileUploadController.bindVOHavingPart(org.binchoo.study.spring.multipart.profileservice.controller.FileUploadControllerTests$UserHavingPartVO): org.springframework.validation.BeanPropertyBindingResult: 1 errors Field error in object 'userHavingPartVO' on field 'file': rejected value [org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@4e974b9e]; codes [typeMismatch.userHavingPartVO.file,typeMismatch.file,typeMismatch.javax.servlet.http.Part,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [userHavingPartVO.file,file]; arguments []; default message [file]]; default message [Failed to convert value of type 'org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile' to required type 'javax.servlet.http.Part'; nested exception is java.lang.IllegalStateException: Cannot convert value of type 'org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile' to required type 'javax.servlet.http.Part': no matching editors or conversion strategy found] ```","closed","status: superseded,","binchoo","2021-12-15T16:19:32Z","2021-12-19T08:37:43Z"
"","27541","Performance impact of con.getContentLengthLong() in AbstractFileResolvingResource.isReadable() downloading huge jars to check component length","**Affects**: Spring Framework 5.2.9  Change causing the issue:  https://github.com/spring-projects/spring-framework/commit/69f14a20380e8353cdfdea706ca4e4d415011e5e  The above change added content length check to the `AbstractFileResolvingResource.isReadable()` method. That introduced performance impact on using webstart.  For URL connections over Internet (and not on file system), if the context-scan involves component scan for certain packages, and those packages are inside a  jar then that blocks the thread. Jar is downloaded as many times as there are components appearing in packages meant to be scanned in XML file.  **EXAMPLE:**   Consider this:  ``  Now if I have a 1gb jar (say, test.jar) with the above package in my application, I have a jnlp file with ``, and `test.jar` has lets say 50 classes in the package `com.spring,test`;  then when starting the jnlp application for the first time, spring scans for components and as the jar is hosted over the internet (not available in cache for the first time) , spring downloads it 50 times and the thread is in runnable state for a long time thus not allowing other applications to connect to the server hosting the webstart application.   **_Can we make the con.getContentLengthLong() optional??_**   **SAMPLE RUNNABLE THREAD:**  ``` ""com.test.TestApp$2"" #174 prio=5 os_prio=0 tid=0x0000000027a0f000 nid=0x38f4 runnable [0x000000002d0ec000]    java.lang.Thread.State: RUNNABLE 	at java.net.SocketInputStream.socketRead0(Native Method) 	at java.net.SocketInputStream.socketRead(Unknown Source) 	at java.net.SocketInputStream.read(Unknown Source) 	at java.net.SocketInputStream.read(Unknown Source) 	at java.io.BufferedInputStream.fill(Unknown Source) 	at java.io.BufferedInputStream.read1(Unknown Source) 	at java.io.BufferedInputStream.read(Unknown Source) 	- locked  (a java.io.BufferedInputStream) 	at sun.net.www.http.HttpClient.parseHTTPHeader(Unknown Source) 	at sun.net.www.http.HttpClient.parseHTTP(Unknown Source) 	at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(Unknown Source) 	- locked  (a sun.net.www.protocol.http.HttpURLConnection) 	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(Unknown Source) 	- locked  (a sun.net.www.protocol.http.HttpURLConnection) 	at sun.net.www.protocol.http.HttpURLConnection.getHeaderField(Unknown Source) 	at java.net.URLConnection.getHeaderFieldLong(Unknown Source) 	at java.net.URLConnection.getContentLengthLong(Unknown Source) 	at sun.net.www.protocol.jar.JarURLConnection.getContentLengthLong(Unknown Source) 	at org.springframework.core.io.AbstractFileResolvingResource.isReadable(AbstractFileResolvingResource.java:109) 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:427) 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:315) 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:276) 	at org.springframework.context.annotation.ComponentScanBeanDefinitionParser.parse(ComponentScanBeanDefinitionParser.java:90) 	at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:74) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1391) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1371) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:179) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:149) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:96) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:511) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:391) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:338) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:310) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257) 	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128) 	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94) 	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:130) 	at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:638) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:523) 	- locked  (a java.lang.Object) 	at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:144) 	at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:109) ```","closed","in: core,","manisha-shetty","2021-10-10T21:22:40Z","2021-10-12T14:23:12Z"
"","27582","SpEL vararg method invocation fails if string literal contains a comma","**Affects**: 4.1.2 and up  I'm trying to use my own matching functions with spring-expression, but I came across a possible bug.  Here's some code for context:  ```java import org.springframework.expression.spel.support.StandardEvaluationContext;  public class RuleEvaluationContext extends StandardEvaluationContext {  	public RuleEvaluationContext(Object rootObject) { 		super(rootObject); 		registerFunctions(); 	}  	public RuleEvaluationContext() { 		super(); 		registerFunctions(); 	}  	private void registerFunctions() { 		for (Functions fun : Functions.values()) { 			this.registerFunction(fun.funcName(), fun.method()); 		} 	}  } ``` ```java enum Functions { /* Functions commented for the sake of simplicity  	CONTAINS(Contains.FUNC_NAME, 		getDeclaredMethod(Contains.class, Contains.FUNC_NAME, String.class, String[].class)),  	STARTS_WITH(StartsWith.FUNC_NAME, 		getDeclaredMethod(StartsWith.class, StartsWith.FUNC_NAME, String.class, String[].class)), */  	MATCHES(Matches.FUNC_NAME, 		getDeclaredMethod(Matches.class, Matches.FUNC_NAME, String.class, String[].class)), /* 	EQUALS(Equals.FUNC_NAME, 		getDeclaredMethod(Equals.class, Equals.FUNC_NAME, String.class, String.class)),  	GREATER(GreaterThan.FUNC_NAME, 		getDeclaredMethod(GreaterThan.class, GreaterThan.FUNC_NAME, String.class, String.class)),  	LESS_THAN(LessThan.FUNC_NAME, 		getDeclaredMethod(LessThan.class, LessThan.FUNC_NAME, String.class, String.class)); */  	private final String funcName; 	private final Method method;  	Functions(String funcName, Method method) { 		this.funcName = funcName; 		this.method = method; 	}  	public String funcName() { 		return funcName; 	}  	public Method method() { 		return method; 	}  	private static Method getDeclaredMethod(Class c, String name, Class... parameterTypes) { 		try { 			return c.getDeclaredMethod(name, parameterTypes); 		} catch (NoSuchMethodException e) { 			throw new FunctionsException(e); 		} 	}  } ``` This is one of the registered functions:  ```java public class Matches {  	public static final String FUNC_NAME = ""matches"";  	private Matches() { 		super(); 	}  	public static boolean matches(String text, String... regexps) { 		if (text != null) { 			for (String regex : regexps) { 				Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE); 				Matcher matcher = pattern.matcher(text); 				if (matcher.find()) { 					return true; 				} 			} 		} 		return false; 	} } ```  ```java @Test public void test() { 	final RuleEvaluationContext context = new RuleEvaluationContext(new FakeObject()); 	String originalRule = ""#matches(prop, 'xyz,xyz')""; 	Expression expression = parser.parseExpression(originalRule); 	Boolean result = expression.getValue(context, Boolean.class); 	assertThat(result, is(false)); }  private final ExpressionParser parser = new SpelExpressionParser();  private static class FakeObject { 	private String prop = ""xyz"";  	public String getProp() { 		return prop; 	} } ```  This test fails when it should pass. Upon further inspection I've found that the problem is that spring-expression breaks the 'xyz,xyz' into [""xyz"", ""xyz""] as can be seen below.  ![libnova](https://user-images.githubusercontent.com/87673443/138116783-39259105-6013-4285-9889-74b85661db2a.png)  However I've also found that using old versions of the library (pre 4.1.2), this doesn't happen.  ![libantiga](https://user-images.githubusercontent.com/87673443/138117054-022273f4-d6f6-4fde-995c-469c7e6daead.png)  As does putting more strings inside the argument:  ```java @Test public void test() { 	final RuleEvaluationContext context = new RuleEvaluationContext(new FakeObject()); 	String originalRule = ""#matches(prop, 'abc', 'xyz,xyz')""; 	Expression expression = parser.parseExpression(originalRule); 	Boolean result = expression.getValue(context, Boolean.class); 	assertThat(result, is(false)); } ```  ![libnovasembug](https://user-images.githubusercontent.com/87673443/138119080-55ba227c-ffa5-4a23-97e6-184a790adb75.png)","closed","in: core,","bmoraes-axur","2021-10-20T15:05:45Z","2022-01-22T04:45:08Z"
"","26900","fix aop @target bug","**1. Problem Describe** I found spring will proxy some classes without the designated annotation , when I use @target in the pointcut expression.  For example:      //this is my annotation     @Target({ElementType.METHOD, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     public @interface PrivilegeCheck {         int[] roleTypes() default {};     }          //this is my aop      @Component     @Aspect     public class AopTest {         @Around(""@target(com.cxh.PrivilegeCheck)"") 	    public Object around(ProceedingJoinPoint joinPoint) throws Throwable { 		    System.out.println(""before aop""); 		    return joinPoint.proceed(); 	    }     }          //this is my target class     @Component     @PrivilegeCheck     public class Father { 	    public int id = 1; 	    public int getId() { 		    return id; 	    }     }          //this is a normal final class without @PrivilegeCheck     @Component     public final class FinalClz { 	  public int get(){ 		  return 1; 	  }     }  The FinalClz class with also proxy, when i use the @target(com.cxh.PrivilegeCheck). But there isn't @PrivilegeCheck on the FinalClz class.  If FinalClz is not a final class, the problem just wast a little time. But if the FinalClz class is a final class, as we known the cglib can not proxy final class, so the project will start fail.  **2. My Solution**     Because of the method findResidueInternal in ThisOrTargetAnnotationPointcut.class set the var  to shadow.getTargetVar() instead of shadow.getTargetAnnotationVar, the method visit(HasAnnotation hasAnn) of the SubtypeSensitiveVarTypeTestVisitor class in RuntimeTestWalker.class in the spring source code has an error.     So I use the method hasAnnotation(UnresolvedType ofType) of ReferenceType to solve this problem.","closed","","caoxuhao","2021-05-06T06:54:36Z","2021-05-07T07:22:13Z"
"","27280","Improve the fluency of the ResponseCreator API","* Added utility methods to DefaultResponseCreator      This enables the ability to fluently add single headers like you can   already with the mock request specification APIs by chaining   `.header(name, value)` repeatedly. This reduces code clutter within   test cases.        Added the ability to add cookies as this simplifies tests that work   with sessions.        Added the ability to override the character encoding used for setting   a string body on a response, as this is useful when working in   environments that do not automatically assume UTF-8, such as   integrating with legacy applications from a new Spring one.    * Added unit tests for DefaultResponseCreator        These were already *partially* tested by the MockRestResponseCreator, but some   existing calls prior to this PR were missing, and this was also an opportunity   for me to directly test the changes I added.    * Added common response statuses to MockRestResponseCreators        It appears that a couple of the more commonly used HTTP status codes   were missed out from the default methods in MockRestResponseCreators.   The methods included are common enough that most test packs will probably   have at least one case that uses one of these calls, so it enables   keeping the fluent API tidy.        I added a couple of additional edge cases for common response   statuses that will occur when working in cloud environments, such as   AWS, CloudFlare, or using gateways such as Kong, where resillient   applications should be able to respond to ratelimits, gateway errors,   and gateway timeouts (which may occur if a remote service is down).        Added test cases for any changes made.   These changes allow for cases to be written like so:  ```java server     .expect(requestTo(""/api/v1/users""))     .andExpect(method(POST))     .andExpect(header(""Content-Type"", APPLICATION_JSON_VALUE))     .andExpect(header(""Accept"", APPLICATION_JSON_VALUE))     .andExpect(jsonPath(""$.name"").value(""Ashley""))     .andExpect(jsonPath(""$.username"").value(""ascopes""))     .andExpect(jsonPath(""$.password"").value(""12345""))     .andRespond(withRequestConflict()         .header(""X-Request-ID"", ""12345"")         .header(HttpHeaders.PRAGMA, ""no-cache"")         .cookie(ResponseCookie.from(""anon-session-id"", ""12345"").build())         .body(""Entity already exists"", StandardCharsets.US_ASCII)); ``` which should be more fluent and easy to read than what would be needed on the existing API:  ```java HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.add(""X-Request-ID"", ""12345""); responseHeaders.add(HttpHeaders.PRAGMA, ""no-cache""); responseHeaders.add(HttpHeaders.SET_COOKIE, ResponseCookie.from(""anon-session-id"", ""12345"").build().toString());   server     .expect(requestTo(""/api/v1/users""))     .andExpect(method(POST))     .andExpect(header(""Content-Type"", APPLICATION_JSON_VALUE))     .andExpect(header(""Accept"", APPLICATION_JSON_VALUE))     .andExpect(jsonPath(""$.name"").value(""Ashley""))     .andExpect(jsonPath(""$.username"").value(""ascopes""))     .andExpect(jsonPath(""$.password"").value(""12345""))     .andRespond(withStatus(HttpStatus.CONFLICT)         .headers(responseHeaders)         .body(""Entity already exists"".getBytes(StandardCharsets.US_ASCII))); ```","open","in: web,","ascopes","2021-08-14T16:17:40Z","2021-11-10T11:47:56Z"
"","27231","Support Charset for character encoding in MockMvc","#27230 introduced support for configuring the default character encoding in the underlying `MockHttpServletResponse` used in `MockMvc`, using a `Charset`.  However, methods for supplying character encoding in `MockHttpServletRequestBuilder` and `ContentResultMatchers` currently accept a `String`.  To improve the developer experience and avoid the use of String literals, we should provide overloaded support via `Charset` for character encoding in `MockHttpServletRequestBuilder` and `ContentResultMatchers`.","closed","type: enhancement,","sbrannen","2021-07-30T12:54:40Z","2021-07-30T13:27:35Z"
"","27308","Propagate `CoroutineContext` in reactive transaction","#### Motivation: * Fixes #27307   #### Modifications: * Propagate caller's `CoroutineContext` when converting coroutines into `Mono`.   - In `CoroutinesUtils#invokeSuspendingFunction`   - In `TransactionalOperatorExtensions`     + `Flow.transactional(...)`     + `TransactionalOperator.executeAndAwait(...)` * Change `TransactionalOperator.executeAndAwait(...)`'s type parameter upper bound from `Any` to `Any?`   - For better usability.","open","in: kotlin,","ks-yim","2021-08-21T11:47:04Z","2022-05-27T00:37:19Z"
"","27650","AspectJ core dumps (ajcore.*.txt) for spring-aspects","### Preface  When using `spring-aspects` with native AspectJ LTW, the AspectJ weaving agent core-dumps, at least in some Spring Boot playground projects I am using in order to answer AOP-related StackOverflow questions. I am not sure if this is is specific to Spring Boot (did not try without it) and ought to be fixed there, or if it is a Spring Core (spring-aspects) problem. Maybe, it even needs some work in AspectJ. Probably the best person to answer that is @aclement, who I had a private conversation with about this issue already.  Either way, it is an issue that needs to be tracked here, because it affects Spring users.  ### Issue description  As discussed in [StackOverflow question #69800420](https://stackoverflow.com/a/69800420/1082681), running a minimal Spring Boot application with JVM parameters (parameter in a single line, of course, and the first one only necessary for JDK 16+)  ```text --add-opens java.base/java.lang=ALL-UNNAMED -javaagent:.../aspectjweaver-1.9.7.jar -javaagent:.../spring-instrument-5.3.12.jar ```  yields `ajcore.*.txt` core dump files created by AspectJ. Corresponding stack traces featuring `MissingResolvedTypeWithKnownSignature` are logged to the console. The missing resolved type varies between Spring Boot versions and is e.g. `org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer` for Boot 2.3.3 and `org.springframework.boot.jdbc.DataSourceBuilder.OraclePoolDataSourceProperties` for Boot 2.5.6.  ### How to reproduce  * Clone the repository found at https://github.com/kriegaex/SO_AJ_SpringTransactionalNotApplied_69789179 * Check out branch `aspectj` if you prefer Gradle and branch `aspectj-with-maven` for Maven. The code in both branches is equivalent, only the build tool differs. * Build and run the sample application, currently based on Spring Boot 2.5.6, adding the JVM parameters mentioned above to the command line. Because the Git repository already contains a workaround configration in a custom `aop.xml` file, you are not going to see any problems. * In order to reproduce the problem, simply either delete the `aop.xml` file or comment out the `` tags.  ### Workaround  The [default `aop.xml` for `spring-aspects`](https://github.com/spring-projects/spring-framework/blob/ebfec822cbc728d3f28f96261952812cc933866d/spring-aspects/src/main/resources/META-INF/aop.xml) simply declares aspects and no further weaving options.  A simple way to avoid the core dumps is to exclude problematic target classes from weaving. Even if a future AspectJ release would contain a fix avoiding the core dumps, until then Spring Core could avoid weaving unwanted classes and/or packages by excluding them like I have shown in my [custom `aop.xml` file](https://github.com/kriegaex/SO_AJ_SpringTransactionalNotApplied_69789179/blob/aspectj-with-maven/src/main/resources/org/aspectj/aop.xml):  ```xml                                                       ```  These weaver options could be merged into the upstream `aop.xml` for `spring-instruments`. Otherwise, all users would have to create a custom `aop.xml` by themselves like I did, just so as to avoid an upstream problem.  BTW, the weaver by default prints lots of `[Xlint:cantFindType]` warnings, which do no harm but clutter the console log. You might also want to consider adding the `-Xlint:ignore` weaver option. Another helpful default option is `-showWeaveInfo`, because it would show to the user by default all woven joinpoints. I think the latter is more desireable than the Xlint messages. But both options are unrelated to the workaround for this issue, I am just mentioning them as ideas for improvement.","open","in: core,","kriegaex","2021-11-07T09:55:15Z","2021-11-10T09:51:30Z"
"","27520","Upgrade to spring-javaformat 0.0.29","### Overview  `spring-javaformat` 0.0.29 has been [released](https://github.com/spring-io/spring-javaformat/releases/tag/v0.0.29).  ### Related Issues  -  #27481","closed","type: task,","sbrannen","2021-10-05T16:17:24Z","2021-10-06T10:27:22Z"
"","27791","Cannot serve static resources with spaces from ""file:"" location when using `PathPattern` and UrlPathHelper is set to not decode","### Description After upgrading from Spring Boot 2.5.6 to 2.6.1, I've detected a behaviour change affecting access to static files with ""special chars"" in file names(spaces, accents, etc.)  I believe this is related to the change from AntPathMatcher to PathPattern introduced in Spring Boot 2.6.0-M3.  When I try to serve static files from a custom location from my filesystem (outside the default static paths configured by Spring Boot), I can not access files with spaces (or accents) in file names.  I've prepared a sample project to demonstrate this behavior. My only customization is adding a new resource handler to be able to access static files under the `/tmp/repo` directory:  ```java @Configuration public class MyCustomConfig implements WebMvcConfigurer {     @Override     public void addResourceHandlers(ResourceHandlerRegistry registry) {         registry.addResourceHandler(""/repo/**"").addResourceLocations(""file:/tmp/repo/"");     } } ``` ### Steps to reproduce  ```bash git clone https://github.com/aaguilera/test-static-files.git    cd test-static-files cp -r src/main/resources/static /tmp/repo    # copy sample files to external directory ./mvnw spring-boot:run ``` Once the app is running, try to access the static file `foo bar.txt` under resources/static and /tmp/repo:  http://localhost:8080/foo%20bar.txt            (this works fine) http://localhost:8080/repo/foo%20bar.txt    (this returns error 404)  The only difference is that the first URL is getting a file located at `src/main/resources/static/` (this directory is preconfigured by default via Spring Boot to serve static files), and the second URL is trying to get a file located at `file:/tmp/repo`, configured manually via my @Configuration class using `addResourcehandler`/`addResouceLocations`.  The interesting thing is that this second URL works perfectly (returns the file) when using Spring Boot 2.5.7 instead of 2.6.1 (you can try changing the version in `pom.xml` and restarting the app).  ### Workaround  As a workaround, I can force the old behavior by setting the following property in my `application.properties`:      spring.mvc.pathmatch.matching-strategy=ant-path-matcher  With this configuration, the second URL works fine again, as it did with Spring Boot 2.5.x.","closed","type: bug,","aaguilera","2021-12-09T12:07:19Z","2022-05-23T10:30:00Z"
"","27263","A few small questions","## The first ```  location:  org.springframework.transaction.interceptor.TransactionInterceptor#invoke /** 	 * 	 * @param invocation the method invocation joinpoint 	 * @return 	 * @throws Throwable 	 */ 	@Override 	@Nullable 	public Object invoke(MethodInvocation invocation) throws Throwable { 		// Work out the target class: may be {@code null}. 		// The TransactionAttributeSource should be passed the target class 		// as well as the method, which may be from an interface. 		Class targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);  		// Adapt to TransactionAspectSupport's invokeWithinTransaction... 		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed); 	}        protected Object invokeWithinTransaction(Method method, @Nullable Class targetClass, 			final InvocationCallback invocation) throws Throwable {           ....       } ```  why the invokeWithinTransaction method we need a InvocationCallback , this increases the complexity of the code?  in the InvocationCallback, there is no need for complicated logic  ## The second  location: org.springframework.transaction.interceptor.TransactionAspectSupport#determineTransactionManager    ``` /** 	 * Determine the specific transaction manager to use for the given transaction. 	 */ 	@Nullable 	protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) { 		// Do not attempt to lookup tx manager if no tx attributes are set 		if (txAttr == null || this.beanFactory == null) { 			return getTransactionManager(); 		}  		String qualifier = txAttr.getQualifier(); 		if (StringUtils.hasText(qualifier)) { 			return determineQualifiedTransactionManager(this.beanFactory, qualifier); 		} 		else if (StringUtils.hasText(this.transactionManagerBeanName)) { 			return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName); 		} 		else { 			TransactionManager defaultTransactionManager = getTransactionManager(); 			if (defaultTransactionManager == null) { 				defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY); 				if (defaultTransactionManager == null) { 					defaultTransactionManager = this.beanFactory.getBean(TransactionManager.class); 					this.transactionManagerCache.putIfAbsent( 							DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager); 				} 			} 			return defaultTransactionManager; 		} 	} ```   Are containers for storing beans , BeanFactory has cache, transactionManagerCache whether excess?","closed","for: stackoverflow,","zhb-github","2021-08-12T02:04:40Z","2021-08-12T07:06:38Z"
"","27750","annotated with both `@Component` and `@conditionalonmissingBean`，condition matching error","## problem For classes annotated with both `@Component` and `@conditionalonmissingBean`  The corresponding Beandifinition will be registered by `@ComponentScan`,  Then be `onfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass` removed,  This will cause some problems.  ## sample  full example code：https://github.com/Hccake/demo-condition  Some sample code is shown below:   ```java @Component @ConditionalOnMissingBean(AService.class) public class AService{ } ```  ```java @Configuration public class DemoConfiguration {     @Bean     @ConditionalOnBean(AService.class)     public AController aController(AService aService){         return new AController(aService);     } } ```  ## error log ```java Positive matches: -----------------    DemoConfiguration#aController matched:       - @ConditionalOnBean (types: com.example.biz.service.AService; SearchStrategy: all) found bean 'AService' (OnBeanCondition)  Negative matches: -----------------    AService:       Did not match:          - @ConditionalOnMissingBean (types: com.example.biz.service.AService; SearchStrategy: all) found beans of type 'com.example.biz.service.AService' AService (OnBeanCondition)  Parameter 0 of method aController in com.example.demo.condition.DemoConfiguration required a bean of type 'com.example.biz.service.AService' that could not be found. ```  It can be seen that the matching judgment of **AController** and **Aservice** for the same bean `Aservice` has completely different results    ## The problem code ```java class ConfigurationClassBeanDefinitionReader {            private void loadBeanDefinitionsForConfigurationClass( 			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {  		if (trackedConditionEvaluator.shouldSkip(configClass)) { 			String beanName = configClass.getBeanName(); 			if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) { 				this.registry.removeBeanDefinition(beanName); 			} 			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); 			return; 		}             //  Omit some ....................... 	} } ``` When the condition check fails, the original beanDefinition is deleted ,   Whether can make a judgement here, if the current configurationClass is original beanDefinition beanClass, don't delete?","open","in: core,","Hccake","2021-11-30T12:30:56Z","2021-12-02T09:45:20Z"
"","27795","Convert single `null` argument to `Optional.empty()` in SpEL varargs expression","## Overview  While testing the regression raised in #27719, I noticed that our support for `java.util.Optional` is inconsistent when invoking a method or function that accepts a varargs array of type `Optional` in a SpEL expression.  As can be seen in `MethodInvocationTests`, if `null` is supplied along with other values, each `null` value gets converted to `Optional.empty()`; whereas, a `null` value supplied by itself gets passed through as `null` to the invoked method.  https://github.com/spring-projects/spring-framework/blob/62f480adc3090453946c4de4919aae7af7e906bf/spring-expression/src/test/java/org/springframework/expression/spel/MethodInvocationTests.java#L305-L310  Although this is a very specific use case that potentially does not even exist in a real project, we would like to ensure consistent semantics for `Optional` arguments in SpEL expressions.","closed","type: enhancement,","sbrannen","2021-12-10T12:29:24Z","2021-12-10T12:55:54Z"
"","26947","Deprecate/Remove internal APIs in ScriptUtils implementations","## Overview  Various utility methods in the `ScriptUtils` implementations in `spring-jdbc` and `spring-r2dbc` are `public` but should not be since they are effectively internal APIs that no external client should call.  ## Public due to historical reasons in `spring-jdbc`  Some of these utility methods are public because of historical reasons -- for example, many of the public methods in `ScriptUtils` in `spring-jdbc` are only public because they were once invoked from `JdbdTestUtils` in `spring-test`, which is no longer the case.  ## Public by accident in `spring-r2dbc`  Some of these utility methods are public by accident -- for example, many of the public methods in `ScriptUtils` in `spring-r2dbc` are only public because they were copied from `ScriptUtils` in `spring-jdbc` without changing the visibility.  ## Methods to deprecate  - `splitSqlScript(...)` - `readScript(...)` - `containsSqlScriptDelimiters()`","closed","type: enhancement,","sbrannen","2021-05-16T15:31:10Z","2021-05-18T13:45:00Z"
"","27772","MergedAnnotationReadingVisitor should ignore types that cannot be loaded","## Overview  This came up in the context of Spring Native, when the exception below was thrown.  `TypeAccess` is an enum used in the `org.springframework.nativex.hint.TypeHint` annotation.  `@TypeHint` is declared in the user code but is not present on the classpath at runtime.  ``` java.lang.IllegalArgumentException: Could not find class [org.springframework.nativex.hint.TypeAccess] 	at org.springframework.util.ClassUtils.resolveClassName(ClassUtils.java:334) 	at org.springframework.core.type.classreading.MergedAnnotationReadingVisitor.visitEnum(MergedAnnotationReadingVisitor.java:103) 	at org.springframework.core.type.classreading.MergedAnnotationReadingVisitor$ArrayVisitor.visitEnum(MergedAnnotationReadingVisitor.java:169) 	at org.springframework.asm.ClassReader.readElementValue(ClassReader.java:3081) 	at org.springframework.asm.ClassReader.readElementValues(ClassReader.java:3006) 	at org.springframework.asm.ClassReader.readElementValue(ClassReader.java:3180) 	at org.springframework.asm.ClassReader.readElementValues(ClassReader.java:3000) 	at org.springframework.asm.ClassReader.accept(ClassReader.java:610) 	at org.springframework.asm.ClassReader.accept(ClassReader.java:426) 	at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:49) 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103) 	at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:132) 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:81) 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.addCandidateComponentsFromIndex(ClassPathScanningCandidateComponentProvider.java:387) 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:313) 	at org.springframework.boot.test.context.AnnotatedClassFinder.scanPackage(AnnotatedClassFinder.java:90) 	at org.springframework.boot.test.context.AnnotatedClassFinder.findFromPackage(AnnotatedClassFinder.java:82) 	at org.springframework.boot.test.context.AnnotatedClassFinder.findFromClass(AnnotatedClassFinder.java:68) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getOrFindConfigurationClasses(SpringBootTestContextBootstrapper.java:235) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:152) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:392) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:309) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:262) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:107) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:102) 	at org.springframework.test.context.TestContextManager.(TestContextManager.java:137) 	at org.springframework.test.context.TestContextManager.(TestContextManager.java:122) ```  ## Proposal  Introduce try-catch blocks in `MergedAnnotationReadingVisitor`'s `visitEnum(String, String, Consumer)` and `visitAnnotation(String, Consumer)` methods, and ignore types that cannot be loaded via `ClassUtils.resolveClassName(...)`.","open","in: core,","sbrannen","2021-12-06T15:14:49Z","2022-03-15T14:58:09Z"
"","26969","Introduce soft assertions for WebTestClient","## Overview  It happens very often that `WebTestClient` is used in heavyweight integration tests. It's no use to waste time to check if another condition has been fixed or not. Soft assertions could help a lot to check all conditions at once even if one of them fails.  ## Proposal  New API would look like as follows:  ```java client.get().uri(""/test"") 	.exchange() 	.expectAllSoftly( 		exchange -> exchange.expectStatus().isOk(), 		exchange -> exchange.expectBody(String.class) 			.isEqualTo(""It works!"") 	); ```  ## Related Issues  - #26917","closed","type: enhancement,","wyhasany","2021-05-23T11:32:12Z","2021-09-06T12:57:17Z"
"","27317","Introduce Kotlin DSL for `ResultActions.andExpectAll()`","## Overview  Commit dd9b99e13d6b30462fb168799e6bbca1456123da introduced `ResultActions.andExpectAll()` to support _soft assertions_ in `MockMvc`.  `ResultActionsDsl.kt` already has support for `andExpect()`.   ## Related Issues  - #27318  ## Deliverables  - [ ] Introduce Kotlin support for `ResultActions.andExpectAll()` in `ResultActionsDsl.kt`. - [ ] Add a Kotlin example using `andExpectAll()` in the reference manual alongside the Java example introduced in dd9b99e13d6b30462fb168799e6bbca1456123da.","open","in: kotlin,","sbrannen","2021-08-23T14:08:07Z","2022-01-19T10:42:39Z"
"","27318","Investigate Kotlin DSL options for `expectAll()` in `WebTestClient`","## Overview  Commit 3c2dfebf4ec5e9d791c1f3c9fa0ad35a5a9fcd6b introduced a new `expectAll()` method in `WebTestClient` in order to support _soft assertions_.  We should investigate options for improving the developer experience with a Kotlin DSL.  ## Related Issues  - #27317","open","in: kotlin,","sbrannen","2021-08-23T17:23:27Z","2022-01-19T10:41:30Z"
"","27537","Upgrade to AspectJ 1.9.8-RC3","## Overview  AspectJ 1.9.8 RC1 was [released](https://github.com/eclipse/org.aspectj/issues/79#issuecomment-938499393) today, so we'll start testing against that and upgrade to 1.9.8 GA once it's been released.  ## Resources  - preliminary [release notes](https://htmlpreview.github.io/?https://github.com/eclipse/org.aspectj/blob/29b024efe4cb4db803103aa099d60b9bc85bac6c/docs/dist/doc/README-198.html)  ## Deliverables  - Upgrade to AspectJ 1.9.8 GA - Add note to reference manual regarding changes to LTW support (see AspectJ 1.9.8 release notes for details)","closed","type: dependency-upgrade,","sbrannen","2021-10-08T17:24:46Z","2022-02-16T08:50:02Z"
"","27464","Change default driver in XStreamMarshaller from XppDriver to DomDriver","## Overview  As explained in commit a247b83cd9c9aefd3c329d493c5ce7cd11d0cdfa, the `XppDriver` from XStream relies on the XPP3 library which publishes `javax.xml.namespace.QName` as part of its JAR. The `QName` type is also published by the `java.xml` system module in modular JREs (i.e., Java 9 or higher).  This results in a _split package_ between the `unnamed` module and the `java.xml` system module, which the Java Language Specification defines as illegal (see [§6.5.5.2](https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.5.5.2) and [§7.4.3](https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-7.4.3)).  Most Java compilers do not currently enforce this rule; however, the Eclipse compiler does. This makes it impossible to use `spring-oxm` out-of-the-box in the Eclipse IDE. In addition, if bug [JDK-8215739](https://bugs.openjdk.java.net/browse/JDK-8215739) is fixed in a future version of OpenJDK, this rule will affect all users of `spring-oxm`.  In light of that, the team has decided to switch the default driver in `XStreamMarshaller` from `XppDriver` to `DomDriver`. Users can naturally switch back to the `XppDriver` if they wish, since the `defaultDriver` is configurable.  ## Deliverables  - [x] Change default driver in `XStreamMarshaller` from `XppDriver` to `DomDriver`. - [x] Revert related changes in a247b83cd9c9aefd3c329d493c5ce7cd11d0cdfa.","closed","type: enhancement,","sbrannen","2021-09-24T13:19:49Z","2021-09-25T13:08:56Z"
"","27540","Allow default CacheAwareContextLoaderDelegate configuration via a system property","## Overview  As a follow up to #17282, we should allow the default `CacheAwareContextLoaderDelegate` in the _Spring TestContext Framework_ (TCF) to be configured via a JVM system property or _Spring Property_.  This will allow third parties to intercept context loading in order to load the context in a different manner -- for example, to make use of ahead of time (AOT) techniques for implementing a different type of `ApplicationContext` at build time.  ## Deliverables  - [x]  Allow default `CacheAwareContextLoaderDelegate` configuration via a system property.","closed","type: enhancement,","sbrannen","2021-10-10T20:01:07Z","2021-10-11T13:10:34Z"
"","27407","Revise Eclipse IDE support","## Overview  After the upgrade to Gradle 7.2 (#26870), I noticed that we can likely greatly simplify our custom Gradle configuration for Eclipse IDE.  ## Example Warnings  ``` > Task :spring-core:eclipseSettings Execution optimizations have been disabled for task ':spring-core:eclipseSettings' to ensure correctness due to the following reasons:    - Gradle detected a problem with the following location: '/spring-framework/spring-core/.settings'. Reason: Task ':spring-core:eclipseJdt' uses this output of task ':spring-core:eclipseSettings' without declaring an explicit or implicit dependency. This can lead to incorrect results being produced, depending on what order the tasks are executed. Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#implicit_dependency for more details about this problem. Gradle detected a problem with the following location: '/spring-framework/spring-core/.settings'. Reason: Task ':spring-core:eclipseJdt' uses this output of task ':spring-core:eclipseSettings' without declaring an explicit or implicit dependency. This can lead to incorrect results being produced, depending on what order the tasks are executed. Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#implicit_dependency for more details about this problem. This behaviour has been deprecated and is scheduled to be removed in Gradle 8.0. Execution optimizations are disabled to ensure correctness. See https://docs.gradle.org/7.2/userguide/more_about_tasks.html#sec:up_to_date_checks for more details.  > Task :spring-core:eclipseWstComponentSettings Execution optimizations have been disabled for task ':spring-core:eclipseWstComponentSettings' to ensure correctness due to the following reasons:    - Gradle detected a problem with the following location: '/spring-framework/spring-core/.settings'. Reason: Task ':spring-core:eclipseJdt' uses this output of task ':spring-core:eclipseWstComponentSettings' without declaring an explicit or implicit dependency. This can lead to incorrect results being produced, depending on what order the tasks are executed. Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#implicit_dependency for more details about this problem. Gradle detected a problem with the following location: '/spring-framework/spring-core/.settings'. Reason: Task ':spring-core:eclipseJdt' uses this output of task ':spring-core:eclipseWstComponentSettings' without declaring an explicit or implicit dependency. This can lead to incorrect results being produced, depending on what order the tasks are executed. Please refer to https://docs.gradle.org/7.2/userguide/validation_problems.html#implicit_dependency for more details about this problem. This behaviour has been deprecated and is scheduled to be removed in Gradle 8.0. Execution optimizations are disabled to ensure correctness. See https://docs.gradle.org/7.2/userguide/more_about_tasks.html#sec:up_to_date_checks for more details.  Execution optimizations have been disabled for 2 invalid unit(s) of work during this build to ensure correctness. Please consult deprecation warnings for more details. ```  ## Deliverables  - [x] Fix deprecation warnings in the build for the `eclipse` Gradle task. - [x] Simplify `ide.gradle` -- for example, by removing support for Eclipse web tools which we no longer need. - [x] Update `import-into-eclipse.md` for `5.3.x`    - [x] Verify Java support    - [x] Verify Groovy support    - [x] ❌ Verify Kotlin support    - [x] ❌ Verify AJDT support - [x] Update `import-into-eclipse.md` for `main` (6.0)    - [x] Verify JDK 17 support    - [x] ❌ Verify Groovy support    - [x] ❌ Verify Kotlin support    - [x] ❌ Verify AJDT support","closed","type: task,","sbrannen","2021-09-15T09:08:59Z","2021-10-12T15:24:45Z"
"","27225","Apply default `ResultHandler`s before default `ResultMatcher`s in `MockMvc`","## Overview  `MockMvc.applyDefaultResultActions(MvcResult)` currently applies default `ResultMatcher`s before default `ResultHandler`s. Consequently, if a `ResultMatcher` fails, no `ResultHandler` will be applied.  For example, in the following test, if `alwaysExpect(content().string(""Boom!""))` results in an exception, `alwaysDo(print(System.err))` will never be applied, and the user will never see the expected debug output to help diagnose the problem.  ```java @Test void test() throws Exception { 	standaloneSetup(new SimpleController()) 		.alwaysDo(print(System.err)) 		.alwaysExpect(content().string(""Boom!"")) 		.build() 		.perform(get(""/"")); } ```  ## Deliverables  - [x] Ensure that default `ResultHandler`s are applied before default `ResultMatcher`s.","closed","type: bug,","sbrannen","2021-07-29T17:07:41Z","2021-07-29T17:21:02Z"
"","27230","Support default character encoding for response in MockMvc","## Overview  #27214 introduced support for setting the default character encoding in `MockHttpServletResponse`, and the focus of this issue is to make that configurable when building an instance of `MockMvc`.  ## Deliverables  - [x] Introduce `defaultResponseCharacterEncoding(Charset)` in `ConfigurableMockMvcBuilder` and use it to configure the default character encoding in the underlying `MockHttpServletResponse`.","closed","type: enhancement,","sbrannen","2021-07-30T12:07:25Z","2021-07-30T12:43:28Z"
"","27522","Make coroutine dispatcher(coroutine context) changeable in WebFlux","## Motivation  There are cases where the coroutine dispatcher is changed when performing blocking processing.  ```kotlin @GetMapping(""/sample"") suspend fun sample(): String {     // do non-blocking call      withContext(blockingDispatcher) {         // do blocking call     }      // do non-blocking call      ... } ```  But now WebFlux uses Unconfined dispatcher. https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-core/src/main/java/org/springframework/core/CoroutinesUtils.java#L74  So once we change the dispatcher, subsequent processing will also be executed by that dispatcher. For example, in the following example, it will be executed by blockingExecutor thread even after withContext.  ```kotlin @GetMapping(""/test/hello1"") suspend fun hello1(): String {     // reactor-http-nio-N thread     log.info(""thread={}"", Thread.currentThread().name)      withContext(blockingDispatcher) {         // blockingExecutor-N thread         log.info(""thread={}"", Thread.currentThread().name)          // do blocking call     }      // blockingExecutor-N thread     log.info(""thread={}"", Thread.currentThread().name)      return ""hello"" } ```  We can work around this issue by using the default dispatcher instead of the Unconfined dispatcher.  ```kotlin @GetMapping(""/test/hello2"") suspend fun hello2(): String {     return withContext(Dispatchers.Default) {         // DefaultDispatcher-worker-N thread         log.info(""thread={}"", Thread.currentThread().name)          withContext(blockingDispatcher) {             // blockingExecutor-N thread             log.info(""thread={}"", Thread.currentThread().name)              // do blocking call         }          // DefaultDispatcher-worker-N thread         log.info(""thread={}"", Thread.currentThread().name)          ""hello""     } } ```  However, writing `withContext(Dispatchers.Default)` on all controller methods can be tedious. So I want to be able to change the coroutine dispatcher used by WebFlux.  ## How  How about making it possible to change by registering a class such as CoroutinesDispatchersProvider in the bean?  ```kotlin interface CoroutinesDispatchersProvider {     fun provide(request: ServerHttpRequest): CoroutineDispatcher } ```  For example, a framework called armeria allows we to specify a dispatcher https://armeria.dev/docs/server-annotated-service#coroutine-dispatcher","open","in: kotlin,","be-hase","2021-10-06T05:36:58Z","2022-04-08T16:54:29Z"
"","27887","Duplicated content-type response header on error response","# version * Spring Boot 2.6.2  # code ```Kotlin @SpringBootApplication class FluxErrorHandlingApplication  fun main(args: Array) {     runApplication(*args) }  @Configuration class Config {     @Bean     fun router(handler: Handler) =         org.springframework.web.reactive.function.server.router {             GET(""/error"", handler::handle)         } }  @Component class Handler {     fun handle(request: ServerRequest): Mono {         throw RuntimeException()     } } ```  # result ``` curl -v localhost:8080/error                                                                                                                                                                             master ✭ ✚ ✱ *   Trying 127.0.0.1:8080... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > GET /error HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.68.0 > Accept: */* >  * Mark bundle as not supporting multiuse < HTTP/1.1 500 Internal Server Error < Content-Type: application/json < Content-Type: application/json < Content-Length: 131 ```","closed","type: bug,","siosio","2021-12-28T10:30:47Z","2022-01-10T10:06:28Z"
"","27787","@Async  each method(or class)  have a threadpool","# Suggestion * org.springframework.scheduling.annotation.Async **enhancement**   ```java @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Async {  	String value() default """";  	/** 	 * limit and control the concurrent thread num to avoid OOM  , outer-interface QPS limited and so on 	 *  	 * if null , use global threadpool 	 * if not null，create a threadpool , when method or class is invoked ，use the current threadpool 	 */         Integer threadNum() default null; } ```  i will not need to definite threadpools for each scene ，just only definite  @Async  on the method   consider it ?","closed","status: declined,","szd1993","2021-12-09T09:00:42Z","2021-12-09T09:09:59Z"
"","27711","Enable a properties journal","# Problem  I have multiple applications running within same environment. They share some property files.  It is hard to figure out what properties are actually being used by each application. Not only what properties are available.  # Proposed solution  Enable a properties journal. Something that:   * Prints all used properties on startup.  * Allow users to configure a callback whenever a property is read.  This would allow note all used properties, in something like InfluxDB or whatever.  I have implemented this by listening for beans being created, using reflection to find usage of `@Value`, resolving values of those annotations... but would be nice if this was a feature in Spring.","open","type: enhancement,","tomasbjerre","2021-11-20T13:42:32Z","2021-11-22T13:09:22Z"
"","26933","Exception in Tomcat when SockJS top URL is a WebSocket upgrade","# Creating simple websocke/sompt server   Spring fails to parse HTTP request header, although it sends 200 response to the client and close the connection immediately.  # How to reproduce  Download sample code from official [guides](https://spring.io/guides/gs/messaging-stomp-websocket/), then set log level to debug `logging.level.root=debug` on **application.properties**. Run the server, and try connecting with simple JS client code.  **JS client** ```const WebSocket = require('ws');   const ws = new WebSocket('ws://dev.contabo:8080/gs-guide-websocket') ws.on('open', () => {   console.log(""connection opened""); })  ws.on('message', () => {   console.log('message recieved'); })  ws.on('close', () => {   console.log('connection closed'); })  ws.on('error', (item) => {   console.log(item) }) ```  It gives the following error on the log:  ``` 2021-05-11 16:07:12.682 DEBUG 12588 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : GET ""/chatspace"", parameters={} 2021-05-11 16:07:12.687 DEBUG 12588 --- [nio-8080-exec-1] o.s.w.s.s.s.WebSocketHandlerMapping      : Mapped to org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler@4a68cc76 2021-05-11 16:07:12.693 DEBUG 12588 --- [nio-8080-exec-1] o.s.w.s.s.t.h.DefaultSockJsService       : Processing transport request: GET http://localhost:8080/chatspace 2021-05-11 16:07:12.696 DEBUG 12588 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK 2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] o.a.coyote.http11.Http11InputBuffer      : Before fill(): parsingHeader: [true], parsingRequestLine: [true], parsingRequestLinePhase: [0], parsingRequestLineStart: [0], byteBuffer.position(): [0], byteBuffer.limit(): [0], end: [232] 2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] o.a.tomcat.util.net.SocketWrapperBase    : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Read from buffer: [0] 2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] org.apache.tomcat.util.net.NioEndpoint   : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Read direct from socket: [0] 2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] o.a.coyote.http11.Http11InputBuffer      : Received [] 2021-05-11 16:07:12.702 DEBUG 12588 --- [nio-8080-exec-1] o.apache.coyote.http11.Http11Processor   : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Status in: [OPEN_READ], State out: [OPEN] 2021-05-11 16:07:12.702 DEBUG 12588 --- [nio-8080-exec-1] org.apache.tomcat.util.net.NioEndpoint   : Registered read interest for [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]] 2021-05-11 16:07:12.707 DEBUG 12588 --- [nio-8080-exec-2] o.a.coyote.http11.Http11InputBuffer      : Before fill(): parsingHeader: [true], parsingRequestLine: [true], parsingRequestLinePhase: [0], parsingRequestLineStart: [0], byteBuffer.position(): [0], byteBuffer.limit(): [0], end: [232] 2021-05-11 16:07:12.707 DEBUG 12588 --- [nio-8080-exec-2] o.a.tomcat.util.net.SocketWrapperBase    : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Read from buffer: [0] 2021-05-11 16:07:12.707 DEBUG 12588 --- [nio-8080-exec-2] o.apache.coyote.http11.Http11Processor   : Error parsing HTTP request header  java.io.EOFException: null 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.fillReadBuffer(NioEndpoint.java:1345) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1255) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:794) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:359) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:261) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]  2021-05-11 16:07:12.708 DEBUG 12588 --- [nio-8080-exec-2] o.apache.coyote.http11.Http11Processor   : Error state [CLOSE_CONNECTION_NOW] reported while processing request  java.io.EOFException: null 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.fillReadBuffer(NioEndpoint.java:1345) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1255) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:794) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:359) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:261) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.45.jar:9.0.45] 	at java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]  2021-05-11 16:07:12.708 DEBUG 12588 --- [nio-8080-exec-2] o.apache.coyote.http11.Http11Processor   : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Status in: [OPEN_READ], State out: [CLOSED] 2021-05-11 16:07:12.709 DEBUG 12588 --- [nio-8080-exec-2] o.apache.tomcat.util.threads.LimitLatch  : Counting down[http-nio-8080-exec-2] latch=1 2021-05-11 16:07:12.709 DEBUG 12588 --- [nio-8080-exec-2] org.apache.tomcat.util.net.NioEndpoint   : Calling [org.apache.tomcat.util.net.NioEndpoint@2a267286].closeSocket([org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]]) 2021-05-11 16:07:24.104 DEBUG 12588 --- [)-192.168.1.109] sun.rmi.transport.tcp                    : RMI TCP Connection(8)-192.168.1.109: (port 42343) connection closed  ```","closed","type: enhancement,","ablil","2021-05-11T16:25:57Z","2021-05-26T10:28:50Z"
"","27119","Pointcut ""target"" and ""not @annotation"" combination does not work as expected","""target"" and ""not @annotation"" combination not works as expected, but ""target"" and ""@annotation"" combination works fine. ```java 	// works as expected 	@Around(""execution(public * *(..)) and target(repository) and @annotation(org.springframework.transaction.annotation.Transactional)"") 	public Object interceptPositive(ProceedingJoinPoint pjp, Repository repository) throws Throwable { 		Method method = ((MethodSignature) pjp.getSignature()).getMethod(); 		if (!method.isAnnotationPresent(Transactional.class)) 			throw new RuntimeException(""annotation should present here""); 		return pjp.proceed(); 	}  	// not works as expected 	@Around(""execution(public * *(..)) and target(repository) and not @annotation(org.springframework.transaction.annotation.Transactional)"") 	public Object interceptNegative(ProceedingJoinPoint pjp, Repository repository) throws Throwable { 		Method method = ((MethodSignature) pjp.getSignature()).getMethod(); 		if (method.isAnnotationPresent(Transactional.class)) 			throw new RuntimeException(""annotation should not present here""); 		return pjp.proceed(); 	} ``` [test-pointcut.zip](https://github.com/spring-projects/spring-framework/files/6751811/test-pointcut.zip) is a test project","open","status: feedback-provided,","quaff","2021-07-02T03:09:58Z","2022-01-18T11:18:43Z"
"","27897","Upgrade to Reactor 2020.0.15","","closed","type: dependency-upgrade,","snicoll","2022-01-06T15:39:43Z","2022-01-12T08:40:27Z"
"","27884","Replace use of StringBuffer with StringBuilder","","closed","in: core,","xixingya","2022-01-04T11:30:52Z","2022-01-04T12:15:23Z"
"","27883","Replace use of StringBuffer with StringBuilder","","closed","","xixingya","2022-01-04T11:25:51Z","2022-01-04T11:26:03Z"
"","27882","test","","closed","status: invalid,","zyzhuaidan","2022-01-04T10:59:35Z","2022-01-04T11:13:06Z"
"","27879","Upgrade to Kotlin serialization 1.3.2","","closed","type: dependency-upgrade,","sdeleuze","2022-01-03T14:48:02Z","2022-01-03T15:13:37Z"
"","27878","Upgrade to Kotlin Coroutines 1.6.0","","closed","type: dependency-upgrade,","sdeleuze","2022-01-03T14:31:46Z","2022-01-03T15:13:20Z"
"","27874","0103-5.3-canUse","","closed","status: invalid,","LuckerCxd","2022-01-02T16:18:52Z","2022-01-02T18:15:15Z"
"","27865","Add countOccurrencesIgnoreCase method to StringUtils","","closed","status: declined,","Mikhail2048","2021-12-28T21:07:14Z","2021-12-29T09:39:12Z"
"","27825","Upgrade to Log4j2 2.16.0","","closed","type: dependency-upgrade,","snicoll","2021-12-16T09:57:01Z","2021-12-16T09:57:40Z"
"","27822","Replace use of StringBuffer with StringBuilder","","closed","type: task,","mdeinum","2021-12-16T06:05:29Z","2022-01-04T12:15:13Z"
"","27821","update code","","closed","status: invalid,","Dynasty-develop","2021-12-16T05:14:27Z","2021-12-16T14:06:51Z"
"","27793","Upgrade to Reactor 2020.0.14","","closed","type: dependency-upgrade,","snicoll","2021-12-10T06:47:22Z","2021-12-14T14:36:35Z"
"","27725","Adjust to match the order of message converters(see #27724)","","closed","status: declined,","scruel","2021-11-24T07:18:17Z","2021-11-29T07:35:49Z"
"","27705","rr","","closed","status: invalid,","fenglingne","2021-11-19T17:27:16Z","2021-11-19T17:48:12Z"
"","27704","Bump up Gradle enterprise plugin to 3.7.2","","closed","type: task,","jprinet","2021-11-19T13:37:22Z","2021-11-19T14:20:17Z"
"","27700","Apply ""instanceof pattern matching"" in spring-beans","","closed","type: task,","dramatist","2021-11-19T06:37:58Z","2021-12-15T12:14:42Z"
"","27699","Fix typo","","closed","type: documentation,","quaff","2021-11-19T00:59:11Z","2021-11-22T09:32:13Z"
"","27645","Fix incorrect example of error handling in WebClient Javadoc","","closed","in: web,","filiphr","2021-11-05T16:14:39Z","2021-12-03T09:59:25Z"
"","27636","Upgrade to Reactor 2020.0.13","","closed","type: dependency-upgrade,","jhoeller","2021-11-03T14:27:38Z","2021-11-09T19:06:04Z"
"","27635","Upgrade to Reactor Dysprosium-SR25","","closed","type: dependency-upgrade,","jhoeller","2021-11-03T14:26:14Z","2021-11-09T19:05:44Z"
"","27614","modfiy invokeBeanFactoryPostProcessors method","","closed","in: core,","78356052","2021-10-27T08:58:33Z","2021-10-27T14:05:35Z"
"","27607","Add JDK18 build variant to CI pipeline","","closed","type: task,","bclozel","2021-10-25T07:57:42Z","2021-10-25T08:02:51Z"
"","27589","Fix typo in HeaderAssertions","","closed","type: task,","Xxpain","2021-10-22T07:48:56Z","2021-10-22T13:30:19Z"
"","27588","111","","closed","status: invalid,","vapourdown","2021-10-22T03:23:03Z","2021-10-22T07:03:39Z"
"","27555","Upgrade to SmallRye Mutiny 1.1.1","","closed","type: dependency-upgrade,","hantsy","2021-10-13T12:59:24Z","2021-10-13T18:41:27Z"
"","27527","Upgrade to Reactor 2020.0.12","","closed","type: dependency-upgrade,","snicoll","2021-10-07T06:42:21Z","2021-10-12T15:31:40Z"
"","27526","Upgrade to Reactor Dysprosium-SR24","","closed","type: dependency-upgrade,","snicoll","2021-10-07T06:41:54Z","2021-10-12T11:20:18Z"
"","27512","Upgrade to GitHub Changelog Generator 0.0.7 in CI","","closed","type: task,","snicoll","2021-10-03T05:08:47Z","2021-10-03T05:10:54Z"
"","27501","Remove remark about missing caching API.","","closed","type: documentation,","schauder","2021-10-01T07:33:47Z","2021-10-01T11:07:51Z"
"","27469","修改更新","","closed","status: invalid,","Jervis-Miao","2021-09-26T08:45:42Z","2021-09-26T10:35:24Z"
"","27463","test","","closed","status: invalid,","waiteryang","2021-09-24T11:50:35Z","2021-09-24T11:52:08Z"
"","27459","Upgrade CI to github-release resource 1.5.5","","closed","type: task,","snicoll","2021-09-23T16:37:15Z","2021-10-11T14:22:08Z"
"","27415","Add HTTP response status to request logging.","","open","in: web,","selalerercapitolis","2021-09-15T13:56:43Z","2021-11-10T12:44:57Z"
"","27410","spring-framework","","closed","status: invalid,","pengcuiit","2021-09-15T10:20:58Z","2021-09-15T10:35:20Z"
"","27399","Upgrade to Reactor 2020.0.11","","closed","type: dependency-upgrade,","bclozel","2021-09-14T11:51:55Z","2021-09-14T12:25:22Z"
"","27391","update","","closed","status: invalid,","xiezhangbing","2021-09-12T17:16:38Z","2021-09-12T17:21:37Z"
"","27378","Upgrade to Reactor Dysprosium-SR23","","closed","type: dependency-upgrade,","bclozel","2021-09-09T17:01:40Z","2021-09-14T14:31:46Z"
"","27377","Fix typo in core-beans.adoc","","closed","type: task,","GrantFleming","2021-09-09T10:09:39Z","2021-09-09T11:27:11Z"
"","27360","Minor corrections in reference documentation","","closed","type: task,","manish-in-java","2021-09-05T10:15:11Z","2021-09-06T08:58:11Z"
"","27357","Wonder of the deference between ""spring-framework/spring-r2dbc""  and  ""spring-data-r2dbc""","","closed","for: stackoverflow,","zhaowenxishi","2021-09-04T04:00:25Z","2021-09-14T11:49:24Z"
"","27351","Origin/comeon","","closed","status: invalid,","zhangxiansheng123","2021-09-02T15:11:30Z","2021-09-02T15:15:27Z"
"","27336","Remove unused private loggers","","closed","type: task,","marschall","2021-08-30T11:26:34Z","2021-08-30T14:52:03Z"
"","27330","chore: add map params variants to update method","","open","in: data,","hantsy","2021-08-28T02:34:37Z","2021-11-10T12:22:18Z"
"","27298","Fix grammatical errors in Javadoc","","closed","type: task,","juchanei","2021-08-19T12:48:28Z","2021-08-19T14:21:24Z"
"","27297","Fix typo in comments in RecordComponentWriter","","closed","","juchanei","2021-08-19T11:45:40Z","2021-08-19T13:18:03Z"
"","27250","Upgrade to Reactor 2020.0.10","","closed","status: superseded,","snicoll","2021-08-09T07:59:24Z","2021-09-15T07:50:20Z"
"","27248","Polish test classes","","closed","type: task,","Syuziko","2021-08-07T12:12:56Z","2021-08-08T09:40:51Z"
"","27163","Upgrade to Reactor Dysprosium-SR21","","closed","type: dependency-upgrade,","rstoyanchev","2021-07-13T09:22:39Z","2021-07-13T17:08:00Z"
"","27158","Upgrade to Reactor 2020.0.9","","closed","type: dependency-upgrade,","snicoll","2021-07-12T07:29:40Z","2021-07-13T12:41:07Z"
"","27157","Upgrade to Kotlin Coroutines 1.5.1","","closed","type: dependency-upgrade,","snicoll","2021-07-12T07:08:51Z","2021-07-12T07:12:16Z"
"","27129","ok","","closed","status: invalid,","kong0827","2021-07-04T15:58:01Z","2021-07-04T17:21:14Z"
"","27128","New main","","closed","status: invalid,","kong0827","2021-07-04T15:54:12Z","2021-07-04T17:21:03Z"
"","27113","Fix typo in core-beans.adoc","","closed","type: documentation,","devorio","2021-06-30T16:57:47Z","2021-06-30T18:29:45Z"
"","27110","Upgrade to Kotlin 1.5.21","","closed","type: dependency-upgrade,","sdeleuze","2021-06-30T08:25:53Z","2021-07-13T12:55:56Z"
"","27109","Upgrade to Mockk 1.11.0","","closed","type: dependency-upgrade,","sdeleuze","2021-06-30T08:22:36Z","2021-06-30T09:05:34Z"
"","27107","5.2.14","","closed","status: invalid,","clsj","2021-06-30T02:43:03Z","2021-06-30T04:34:22Z"
"","27100","Improve performance of iteration in GroovyBeanDefinitionReader","","closed","in: core,","diguage","2021-06-25T13:59:45Z","2021-07-11T01:24:39Z"
"","27093","将地址改为阿里云的地址，","","closed","status: invalid,","jiezhouRay","2021-06-23T13:24:10Z","2021-06-23T14:26:38Z"
"","27062","5.2.x","","closed","status: declined,","ghost","2021-06-15T08:04:19Z","2021-06-15T08:37:02Z"
"","27058","Fix assertion in XmlBeanFactoryTests","","closed","type: task,","duan847","2021-06-14T06:40:33Z","2021-06-15T01:16:55Z"
"","27051","Fix master->main in contribution guide","","closed","type: task,","Dunemaster","2021-06-11T10:39:42Z","2021-06-11T16:34:23Z"
"","27035","Upgrade to Kotlin 1.5.10","","closed","type: dependency-upgrade,","sdeleuze","2021-06-08T09:37:45Z","2021-06-08T09:45:55Z"
"","26995","Add missing "")"" in Kotlin example","","closed","type: task,","jbotuck","2021-05-28T03:03:55Z","2021-06-02T15:26:58Z"
"","26973","Fix typo","","closed","type: documentation,","dregimbal","2021-05-25T20:30:41Z","2021-05-26T13:22:52Z"
"","26908","Fix findAnnotationOnBean Kotlin extension return type","","closed","in: kotlin,","danthonywalker","2021-05-07T16:18:37Z","2022-03-15T17:40:40Z"
"","26897","Upgrade to Coroutines 1.5.0","","closed","type: dependency-upgrade,","sdeleuze","2021-05-05T17:21:04Z","2021-05-17T09:45:46Z"
"","26891","Upgrade to Reactor Dysprosium-SR20","","closed","type: dependency-upgrade,","rstoyanchev","2021-05-04T15:13:21Z","2021-05-11T13:36:54Z"
"","26890","Upgrade to Reactor 2020.0.7","","closed","type: dependency-upgrade,","rstoyanchev","2021-05-04T15:11:24Z","2021-05-11T13:35:32Z"
"","26887","Upgrade to Kotlin Serialization 1.2.0","","closed","type: dependency-upgrade,","sdeleuze","2021-05-03T15:39:39Z","2021-05-03T15:48:36Z"