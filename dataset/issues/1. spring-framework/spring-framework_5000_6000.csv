"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","23217","creating a branch to support http://jira.springframework.org/browse/S…","…PR-7123gfgrfvhgfd65yhtjn g hdfgsagsdrf","closed","status: invalid,","jbp198669","2019-07-01T10:31:05Z","2019-07-09T11:51:53Z"
"","23377","Issue-13568: Make PropertySourcesPlaceholderConfigurer call a convert…","…perty method when resolving properties  See https://github.com/spring-projects/spring-framework/issues/13568.  The idea here is to provide a new `convertProperty` method for people to implement as a replacement for the ones in `PropertyResourceConfigurer`. The methods in that class are a poor fit for `PropertySourcesPlaceholderConfigurer`, as they only support String-type values.  This PR implements and deprecates the methods that should not be used, and provides a new `convertProperty` that the configurer will actually call.  I think a cleaner way to do this would be to make `PropertySourcesPlaceholderConfigurer` not subclass `PropertyResourceConfigurer`, but I did it this way to avoid breaking the API.","closed","in: core,","srdo","2019-07-27T16:19:28Z","2022-02-15T09:01:09Z"
"","23732","ClientRequest show mutable ,because HttpMessageWriter need add a head…","…er(eg: xxx-signatureOfBody)","closed","in: web,","qinarmy-zoro","2019-09-30T18:39:05Z","2019-10-02T16:19:09Z"
"","22896","DefaultListableBeanFactory.destroySingleton(s) not thread-safe for manual singletons","Within class `org.springframework.beans.factory.support.DefaultListableBeanFactory` field `manualSingletonNames` almost correctly synchronized. But in method `destroySingleton` and `destroySingletons` directly modify the Set, there should be an immutable-like reference override as in case other modifications e.g.: `registerBeanDefinition`.","closed","in: core,","lmagyar89","2019-05-06T08:42:01Z","2019-05-06T23:02:02Z"
"","23679","Upgrade to Spring Doc Resources 0.1.3","With this release, we need to change the code snippet theme from a dark color palette to a light one, see spring-io/spring-doc-resources#14","closed","type: dependency-upgrade,","bclozel","2019-09-23T14:53:06Z","2019-09-26T12:29:01Z"
"","23591","Add opt-in build scan integration with Gradle Enterprise","With thanks to @etiennestuder for his guidance, this pull request adds opt-in build scan integration with Gradle Enterprise. When the GRADLE_ENTERPRISE_URL environment variable is set on a developer's machine or on CI, a build scan will be automatically uploaded to Gradle Enterprise at the end of the build.  This initial integration will establish a baseline for Spring Framework builds. Once that has happened we can use the build scans to identify ways in which the build can be optimized and updated to make use of Gradle's build caching which should reduce build times, significantly so for changes that only affect tasks near the leaf nodes of the task graph.","closed","type: task,","wilkinsona","2019-09-05T14:17:34Z","2019-09-10T19:53:54Z"
"","23663","Upgrade to Coroutines 1.3.2","With stable `Flow` to `Flux` conversion methods in order to allow us to remove remaining `@ExperimentalCoroutinesApi` from our API.","closed","type: dependency-upgrade,","sdeleuze","2019-09-18T14:48:13Z","2019-09-25T19:54:31Z"
"","22954","Remove charset parameter from Spring MVC JSON content type","With #22788, `MediaType#APPLICATION_JSON_UTF8` is deprecated an WebFlux default content type for JSON is `Content-Type: application/json` but based on my tests with Spring MVC it is still `Content-Type: application/json;charset=UTF-8`. I suspect it is caused by https://github.com/spring-projects/spring-framework/blob/73dbd06361c5b902857d3dae68b770523318288d/spring-web/src/main/java/org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter.java#L255 .","closed","in: web,","sdeleuze","2019-05-13T09:59:31Z","2019-05-27T16:18:46Z"
"","23590","spring container new instance question","why private constructor class   spring container new instance this class why not  throw Exception","closed","for: stackoverflow,","hulvyou","2019-09-05T13:44:46Z","2019-09-05T14:20:23Z"
"","23025","HierarchicalUriComponents Url Encode removed char +","why HierarchicalUriComponents,  QUERY_PARAM removed char ""+"" for encode。 when I used TestRestTemplate，In my case, i hava param key=ab+12, server accept is ""ab 12"".  when i use param key=ab%2B12，and the sever accept is ""ab%2B12"", because char ""%"" will be encode。  1.  spring-web-4.3.4.RELEASE ```java  QUERY_PARAM { 			@Override 			public boolean isAllowed(int c) { 				if ('=' == c || '+' == c || '&' == c) { 					return false; 				} 				else { 					return isPchar(c) || '/' == c || '?' == c; 				} 			} 		} ``` 2. spring-web-5.0.7.RELEASE ```java QUERY_PARAM { 			@Override 			public boolean isAllowed(int c) { 				if ('=' == c || '&' == c) { 					return false; 				} 				else { 					return isPchar(c) || '/' == c || '?' == c; 				} 			} 		} ```","closed","status: invalid,","wusthuke","2019-05-24T08:42:14Z","2019-05-24T13:47:36Z"
"","23786","the spring framework documentation doesn't not have a chinese version or other languages version ?why","why does the large project don't have a chinese version documentation? It's difficult to read for chinese students","closed","status: declined,","m1zukii","2019-10-12T09:24:27Z","2019-10-14T10:10:42Z"
"","23235","Use System.nanoTime() instead of System.currentTimeMillis() in StopWatch","why does not StopWatch   use System.nanoTime()","closed","type: enhancement,","shenjianeng","2019-07-04T09:45:22Z","2019-08-09T09:03:55Z"
"","22994","DefaultNamespaceHandlerResolverTests.testResolveInvalidHandler doesn't pass","Whilst migrating `DefaultNamespaceHandlerResolverTests.testResolveInvalidHandler` to AssertJ I discovered the current tests doesn't fail as expected.  ```java @Test public void testResolveInvalidHandler() throws Exception { 	String mappingPath = ""org/springframework/beans/factory/xml/support/invalid.properties""; 	try { 		new DefaultNamespaceHandlerResolver(getClass().getClassLoader(), mappingPath); 		fail(""Should not be able to map a class that doesn't implement NamespaceHandler""); 	} 	catch (Throwable expected) { 	} } ```  The constructor does not actually throw an exception, the `fail` method is called but the `AssertionError` is then swallowed by the catch block so the test passes.","closed","in: core,","philwebb","2019-05-20T05:08:03Z","2019-05-20T15:50:52Z"
"","23216","Improve performance of FormContentFilter","Whilst looking at the fix for #23215 it struck me that we would be better off checking directly that `getContentType` is `null` rather than needing to throw then catch an exception.","closed","type: enhancement,","philwebb","2019-06-30T05:25:19Z","2019-06-30T05:48:01Z"
"","23556","Have MockMCV's content method convert object to JSON","While using springs mock mcv class to handle tests in a spring boot API it is **necessary** to send JSON content with the request body.  Eg. ```java mockMvc.perform(post(""/api/v1/user_registration/phone_code/resend"").content(jsonBody).contentType(MediaType.APPLICATION_JSON_UTF8))                 .andDo(print())                 .andExpect(MockMvcResultMatchers.status().isOk());  ``` Unfortunately, the only way I can do this is by first converting the object that I wish to send in the request body to JSON and then pass it as an argument to the ```MockHttpServletRequestBuilder.content()``` method.   This usually adds extra noise to tests to handle the object to JSON serialization.  It would be very handy for those of us writing tests for APIs to have a content() method that  excepts a plain old java object and does the conversion to JSON for us as well as define the content-type to ""application/js"" since it is obvious by the context that we will be sending JSON in the request body.","closed","status: superseded,","AlexJuca","2019-08-31T23:33:52Z","2019-09-01T13:33:50Z"
"","23557","Introduce MockMvc content() method to convert object to JSON","While using springs mock mcv class to handle tests in a spring boot API it is **necessary** to send JSON content with the request body.  Eg. ```java mockMvc.perform(post(""/api/v1/user_registration/phone_code/resend"").content(jsonBody).contentType(MediaType.APPLICATION_JSON_UTF8))                 .andDo(print())                 .andExpect(MockMvcResultMatchers.status().isOk());  ``` Unfortunately, the only way I can do this is by first converting the object that I wish to send in the request body to JSON and then pass it as an argument to the ```MockHttpServletRequestBuilder.content()``` method.   This usually adds extra noise to tests to handle the object to JSON serialization.  It would be very handy for those of us writing tests for APIs to have a ```content(Object content)``` method that  accepts a plain old java object and does the conversion to JSON for us as well as define the content-type to ""application/js"" since it is obvious by the context that we will be sending JSON in the request body.","closed","status: declined,","AlexJuca","2019-08-31T23:36:22Z","2019-09-05T19:39:56Z"
"","23486","Explore ways to publish useful dependency metadata","While refactoring the Spring Framework build in #23282, we've found that the optional dependencies published with the POMs are misleading. As seen in #23234, some developers consider this information as: * telling how a Spring application should consume Framework dependencies, * recommendations about versions * how to enable support for a particular library, etc.  As describe in https://github.com/spring-projects/spring-framework/issues/23234#issuecomment-521153626 we've found that many published optional dependencies are misleading in that sense. The [Maven reference documentation](https://maven.apache.org/pom.html#Dependencies) states that `optional` means:  > In the shortest terms, optional lets other projects know that, when you use this project, you do not require this dependency in order to work correctly.  Instead of providing information that is misinterpreted by developers, the team decided to not publish that information. Note that the Spring Framework project not only still publishes a valid POM, but also that it's being built with Gradle and that mapping a custom Gradle configuration to a Maven optional scope was dubious in the first place.  The Spring Framework team will explore other ways to publish useful metadata for consumer projects.","closed","status: declined,","bclozel","2019-08-19T18:23:52Z","2020-04-01T19:27:47Z"
"","22947","Deprecate AopUtils.isCglibProxy","While I was poking around how to handle deprecated methods in `ClassUtils` i.e. `isCglibProxyClass`:  https://github.com/spring-projects/spring-framework/blob/73dbd06361c5b902857d3dae68b770523318288d/spring-core/src/main/java/org/springframework/util/ClassUtils.java#L855-L860  As `AopUtils.isCglibProxy` is effectively using same deprecated concept, it should probably get deprecated as well.  https://github.com/spring-projects/spring-framework/blob/73dbd06361c5b902857d3dae68b770523318288d/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.java#L93-L96","closed","in: core,","jvalkeal","2019-05-12T15:37:16Z","2019-05-13T08:34:06Z"
"","23636","Mention Ordered and @Order support for components in Javadoc","While debugging `PostProcessorRegistrationDelegate`, I realized `BeanFactoryPostProcessor` works with `Ordered`(and `PriorityOrdered`) interface but not `@Order` annotation.  It would be great that such information is documented on `BeanFactoryPostProcessor` javadoc.  In general, for ordering, it would be great to have a mention in javadoc that whether the component works with `Ordered` interface and/or `@Order` annotation.","closed","status: feedback-provided,","ttddyy","2019-09-13T16:29:45Z","2019-09-26T12:26:18Z"
"","23631","Wait for complete disposal of Reactor Netty resources in ReactorResourceFactory","While chatting with @violetagg about #23594, we noticed that `ReactorResourceFactory`, when disposing of HTTP resources, is using the ""void returning"" variants of the APIs (for example, see `ConnectionProvider.dispose()` in reactor-netty).  Those variants are returning a `void` type but aren't synchronous and are not waiting for the operation to complete. Under the hood, they're calling the reactive version and subscribing to it, even sometimes in an elastic scheduler.  Spring Framework should in this case use `disposeLater().block();` to ensure that resources have been cleaned up before the method returns. This might explain part of the problem in #23594 if the resources aren't cleaned completely before the server shuts down.","closed","type: bug,","bclozel","2019-09-12T16:02:24Z","2019-09-25T07:58:00Z"
"","23419","Spring Session, web socket, and WebLogic 12.2.1.3 error","When using web sockets and Spring Session on WL 12.2.1.3, an error occurs in WebLogicRequestUpgradeStrategy because the request passed to the WebLogic code has a wrapped session.  Note that this really shouldn't require Spring Session. If you put any filter that replaces or wraps the original session, you should see the same results.  The following stack trace comes from v4.3.17.RELEASE, but the code is the same in in v.4.3.25.RELEASE and in master.  ``` Caused By: java.lang.reflect.InvocationTargetException -- at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy$SubjectHelper.getSubject(WebLogicRequestUpgradeStrategy.java:239) Truncated. see log file for complete stacktrace Caused By: java.lang.ClassCastException: org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper$HttpSessionWrapper cannot be cast to weblogic.servlet.security.internal.SessionSecurityData at weblogic.servlet.security.internal.SecurityModule.getCurrentUser(SecurityModule.java:197) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) Truncated. see log file for complete stacktrace ```  I have been able to patch this locally by changing WebLogicRequestUpgradeStrategy.SubjectHelper.getSubject() from  ```java Object subject = currentUserMethod.invoke(null, securityContext, request); ```  to  ```java Object subject = currentUserMethod.invoke(null, securtyContext, getNativeRequest(request)); ```  I put the change here because I wanted to localize it as much as possible to reduce the chance of side effects. I'm not really sure if this is the appropriate change though.","open","in: web,","jshobe-inetsoft","2019-08-05T15:29:01Z","2021-11-10T11:43:09Z"
"","23261","Spring 5.1.7 application with enabled SecurityManager on Java 11 wont start","When using the Spring 5.1.7 application with enabled Java SecurityManager on Java 11, the application wont start - on Java 8 everything works.   The problem is how class ZipFile changed from 8 to 11. When loading class resource from jar file and using security manager, JDK checks the jar LOC header.  ```java static JarFile checkJar(JarFile jar) throws IOException {             if (System.getSecurityManager() != null &&                  !DISABLE_JAR_CHECKING &&                  !zipAccess.startsWithLocHeader(jar) <------                ) {                 IOException x = new IOException(""Invalid Jar file"");                 try {                     jar.close();                 .... ```  On Java 8 this information is stored as boolean field directly on ZipFile class, but on 11 this field has moved to the inner static class `Source` of another inner static class `CleanableResource`.   ```java // Java 8 // https://github.com/bpupadhyaya/openjdk-8/blob/master/jdk/src/share/classes/java/util/zip/ZipFile.java public class ZipFile implements ZipConstants, Closeable {     ...     private final boolean locsig; <--------     ... } // Java 11 // https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/zip/ZipFile.java public class ZipFile implements ZipConstants, Closeable {     private final String name;     // zip file name     ...     private final @Stable CleanableResource res; <--------     ...     private static class CleanableResource implements Runnable {        final Set istreams;        ...        Source zsrc; <-------        ...        private static class Source {            private final Key key;               // the key in files            ...            private final boolean startsWithLoc; <--------            ...        }     } } ```  Now for some reason, when Spring looks for a jar resource via class `PathMatchingResourcePatternResolver` and method `doFindPathMatchingJarResources` it closes that jar in finally block, which dereferences the zsrc (`Source`) field on CleanableResource - https://github.com/openjdk/jdk/blob/3c214ff134e5b8b922eaf695a2a113c829ef74a1/src/java.base/share/classes/java/util/zip/ZipFile.java#L800   Afterwards, when JDK is checking for LOC header during class resource loading, the NPE is thrown, class is not loaded and the whole application crashes.  Im not really sure if this is even Spring bug, but would like to hear an opinion of a Spring developer.","open","in: core,","horca","2019-07-09T15:13:33Z","2021-11-11T10:12:40Z"
"","23114","provide `.queryParam(String name, Collection items)` to provide multiValued query parameters","When using the `UrlBuilder` (via the `WebClient`) you can pass a collection as the query parameter value like:  ```java webClient.get().uri(uriBuilder -> uriBuilder.path(""/find"")   .queryParam(""items"", List.of(""dogs"", ""cats""))                   //                closedstatus: superseded,                 bjconlan-fc                2019-06-12T05:51:20Z               2019-06-17T15:30:59Z                                             23113               MappingMediaTypeFileExtensionResolver ConcurrentModificationException               Backport of gh-23064               closedtype: backport,                 spring-projects-issues                2019-06-11T22:41:42Z               2019-07-16T08:05:33Z                                             23112               Guard against ConcurrentModificationExceptions in the systemProperties PropertySource               Backport of gh-23063               closedtype: backport,                 spring-projects-issues                2019-06-11T22:41:25Z               2019-07-16T08:05:22Z                                             23111               Add MultiValueMap.addIfAbsent method               `MultiValueMap` would benefit from an `addIfAbsent` method, similar to `putIfAbsent` that's available in `Map`. This would be especially helpful when working with `HttpHeaders`.               closedtype: enhancement,                 philwebb                2019-06-11T18:44:40Z               2019-06-11T19:47:22Z                                             23110               Allow Printers and Parsers to be registered individually to FormatterRegistry               Currently `FormatterRegistry` has a `registerFormatter` method but no `registerPrinter` or `registerParser` methods. This makes [this Spring Boot pull-request](https://github.com/spring-projects/spring-boot/pull/17064) a little more verbose than it should be because it's copied the private `PrinterConverter` and `ParserConverter` classes.               closedtype: enhancement,                 philwebb                2019-06-11T16:55:03Z               2021-09-04T07:55:02Z                                             23109               Strange behavior of WebMvcConfigurer (it stops calling)               I use the same pattern in a few project to log income requests (just the url and ip address) That is:  ``` public class RequestHandlerInterceptor extends HandlerInterceptorAdapter {      @Override     public boolean preHandle(HttpServletRequest request,                              HttpServletResponse response, Object handler) throws Exception {                  log.info(""""); //logging required information here         return super.preHandle(request, response, handler);         } } ```  And WebMvcConfigurer implementaition ``` @Configuration public class WebConfig implements WebMvcConfigurer {      @Override     public void addInterceptors(InterceptorRegistry registry) {         registry.addInterceptor(new RequestHandlerInterceptor());     } } ```  And today I noticed that this interceptor doesn't triggers, I mean `addInterceptors` doesn't fire. The only difference I found is `spring-boot` version. I took one working project (with 2.1.2 version) and changed it to 2.1.5 and it stopped working. But when I changed it back to 2.1.2 it didn't start working again... Also downgrading 2.1.5 version to 2.1.2 didn't help. What do I do wrong? P.S. `@EnableWebMvc` added to AppConfig               closedstatus: invalid,                 frankiedrake                2019-06-11T14:17:44Z               2019-06-17T09:42:34Z                                             23108               How can I specify the order for handler interceptors?               I want to use two handler interceptors in my spring project. First interceptor to authenticate token. Second interceptor to store authenticated token in spring context. I am using XML interceptor configuration. How to specify order for handler interceptors.               closedfor: stackoverflow,                 akshaybande81                2019-06-11T05:37:37Z               2019-06-11T15:59:56Z                                             23107               Turn MethodArgumentNotValidException into subclass of BindException               When creating a REST controller with Spring Boot it's possible to use [Bean Validation](https://docs.oracle.com/javaee/6/tutorial/doc/gircz.html) to validate the methods arguments annotating the class with `@Validated`.  Then Bean Validation annotations can be used directly on the argument or, if the argument is a complex class with properties that must be validated (such as the request body), using `@Valid`.  The inconsistency I found was while handling violation on those validations.   While using the annotations from `javax.validation.constraints` (the validations from the Bean Validation API) the violations are handled by the `@Validated` handler (`MethodValidationInterceptor`) and throws `ConstraintViolationException`.   When using `@Valid` the violation is handled by `ModelAttributeMethodProcessor` and throws `MethodArgumentNotValidException`.  See the problem?  The `@Validated`, a **Spring** annotation that says it is a ""Variant of JSR-303's Valid"" and ""Designed for convenient use with Spring's JSR-303 support but not JSR-303 specific"" (see it [here](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/annotation/Validated.html)), throws `ConstraintViolationException`, an exception from the **Bean Validation API** (JSR-303).   And the opposite also is true, the `@Valid` (from **Bean Validation API**) throws `MethodArgumentNotValidException` (**Spring** exception).  I think it would be more concise if their behavior changed between them.   Does it makes sense?               closedtype: enhancement,                 rafafael03                2019-06-10T16:00:47Z               2020-07-28T09:35:04Z                                             23106               JdbcTemplate does not call handleWarnings in case of exception.               Affects: **4.2.4**  The JdbcTemplate class allows statement warnings to be processed, see the **JdbcTemplate# handleWarnings(Statement)** method. However, the warnings are only processed on successful execution of the statement, though warnings may be generated even if the statement fails.   See the methods: **execute(StatementCallback) execute(PreparedStatementCreator , PreparedStatementCallback) execute(CallableStatementCreator , CallableStatementCallback )**  All these should probably call handleWarnings in their catch block before closing the statement.                opentype: enhancement,                 jMediaConverter                2019-06-10T14:27:12Z               2020-11-27T10:14:19Z                                             23105               Improve FreeMarker macro support in spring-webflux               ## Overview  This issue is a followup to gh-23002.  The documentation for `spring.ftl` in `spring-webflux` states the following.  > To take advantage of these macros, the ""requestContextAttribute"" property of the FreeMarkerView class must be set to ""springMacroRequestContext"". This will expose a RequestContext under the name ""springMacroRequestContext"", as needed by the macros in this library.  Although this technically works, it is not as user-friendly as the analogous support in `spring-webmvc`. Specifically, `AbstractTemplateView` (in `spring-webmvc`) provides a dedicated `exposeSpringMacroHelpers` flag for automatically exposing the `RequestContext` as a model attribute for consumption in FreeMarker templates. Since this boolean flag defaults to `true`, users do not have to configure anything special in `FreeMarkerView` to use all supported macros.  In contrast, users of `FreeMarkerView` in `spring-webflux` cannot use all supported macros unless they explicitly set the `requestContextAttribute` property of the `FreeMarkerView` to `""springMacroRequestContext""`.  I think this is cumbersome and should be improved.  ## Deliverables  - [ ] Consider introducing a dedicated `exposeSpringMacroHelpers` flag in template-based views in `spring-webflux` analogous to the support in `spring-webmvc`.                closedtype: enhancement,                 sbrannen                2019-06-10T13:36:07Z               2019-06-12T23:01:19Z                                             23104               Ordered messages within a STOMP session               When sending `UNSUBSCRIBE` and then `SUBSCRIBE` to the same destination with minimal delay, sometimes first subscription is not removed from cache which results in duplicating each message sent to this destination. This subscription will stay in cache until websocket disconnect.  Screenshot:  ![Websocket](https://user-images.githubusercontent.com/2173775/59192874-8b48d800-8b8c-11e9-84bd-414253b8aaf4.jpg)  Minimal project to reproduce:  [WebsocketBug.zip](https://github.com/spring-projects/spring-framework/files/3271868/WebsocketBug.zip)  How to reproduce:  1. Launch `server.App`. 2. Open `index.html` in any browser that supports showing websocket frames. 3. See websocket frames.  This doesn't work all the time, but has a pretty high change of reproducing. If it didn't reproduce once - just refresh the page. For me it didn't took more than 5-6 refreshes each time I tried.  `spring-messaging` versions I reproduced this for: 5.0.10, 5.1.7               opentype: enhancement,                 Amartel1986                2019-06-10T11:38:25Z               2020-03-13T09:30:38Z                                             23103               Use try with resources                              closedstatus: superseded,                 ielatif                2019-06-09T12:17:13Z               2019-06-12T11:03:00Z                                             23102               Simplify String concatenation                              closedin: core,                 stsypanov                2019-06-09T09:15:46Z               2019-06-19T08:21:40Z                                             23101               PathPatternParser does not allow any non-Java characters in variables like ""-""               Spring WebFlux doesn't allow a path parameter with a character that is not a valid identifier character. For example in traditional MVC you can do: ```	@RequestMapping(""/number-details/{mobile-number}"") 	public String numberDetails(@PathVariable(name = ""mobile-number"") String number) { 		return ""Number: "" + number; 	} ``` But in webflux stack this throws an exception. ``` org.springframework.web.util.pattern.PatternParseException: Char '-' is not allowed in a captured variable name 	at org.springframework.web.util.pattern.InternalPathPatternParser.parse(InternalPathPatternParser.java:178) 	at org.springframework.web.util.pattern.PathPatternParser.parse(PathPatternParser.java:100) ```               closedtype: enhancement,                 tony-clarke-amdocs                2019-06-07T21:01:29Z               2022-05-20T06:50:53Z                                             23100               @Scheduled(fixedDelay) doesn't works with @Async               **Affects:** 5.1.7  **Code to reproduce issue:** ``` @SpringBootApplication @EnableAsync @EnableScheduling public class SpringAsyncTestApplication { 	private static final Logger LOG = LoggerFactory.getLogger(SpringAsyncTestApplication.class);  	public static void main(String[] args) 	{ 		SpringApplication.run(SpringAsyncTestApplication.class, args); 	}  	@Async 	@Scheduled(fixedDelay = 1000) 	public void test1() throws InterruptedException 	{ 		LOG.info(String.format(""Test 1 start: %s"", Thread.currentThread().getName())); 		Thread.sleep(1100); 		LOG.info(String.format(""Test 1 end: %s"", Thread.currentThread().getName())); 	}  	@Async 	@Scheduled(fixedDelay = 1000) 	public void test2() throws InterruptedException 	{ 		LOG.info(String.format(""Test 2 start: %s"", Thread.currentThread().getName())); 		Thread.sleep(1100); 		LOG.info(String.format(""Test 2 end: %s"", Thread.currentThread().getName())); 	} } ```  **Expected result**: Each test1() method is started 1 second after previous test1() method ends. Each test2() method is started 1 second after previous test2() method ends. test1() and test2() methods are running in parallel;  **Actual result**: Each test1() method is started before previous test1() method ends. Each test2() method is started before previous test2() method ends.  Actual output: ``` 2019-06-07 18:46:32.651  INFO 26930 --- [         task-1] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 start: task-1 2019-06-07 18:46:32.651  INFO 26930 --- [         task-2] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 start: task-2 2019-06-07 18:46:33.647  INFO 26930 --- [         task-3] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 start: task-3 2019-06-07 18:46:33.648  INFO 26930 --- [         task-4] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 start: task-4 2019-06-07 18:46:33.751  INFO 26930 --- [         task-2] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 end: task-2 2019-06-07 18:46:33.751  INFO 26930 --- [         task-1] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 end: task-1 2019-06-07 18:46:34.647  INFO 26930 --- [         task-5] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 start: task-5 2019-06-07 18:46:34.648  INFO 26930 --- [         task-6] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 start: task-6 2019-06-07 18:46:34.747  INFO 26930 --- [         task-3] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 end: task-3 2019-06-07 18:46:34.749  INFO 26930 --- [         task-4] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 end: task-4 2019-06-07 18:46:35.648  INFO 26930 --- [         task-7] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 start: task-7 2019-06-07 18:46:35.649  INFO 26930 --- [         task-8] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 start: task-8 2019-06-07 18:46:35.748  INFO 26930 --- [         task-5] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 end: task-5 2019-06-07 18:46:35.749  INFO 26930 --- [         task-6] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 end: task-6 2019-06-07 18:46:36.648  INFO 26930 --- [         task-2] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 start: task-2 2019-06-07 18:46:36.649  INFO 26930 --- [         task-1] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 start: task-1 2019-06-07 18:46:36.748  INFO 26930 --- [         task-7] c.g.ne0sight.SpringAsyncTestApplication  : Test 1 end: task-7 2019-06-07 18:46:36.749  INFO 26930 --- [         task-8] c.g.ne0sight.SpringAsyncTestApplication  : Test 2 end: task-8 ```               closed                nE0sIghT                2019-06-07T15:59:59Z               2021-01-08T13:09:09Z                                             23099               Illegal reflective access warning for ExecutorBeanPostProcessor proxy creation                **Affects:** 5.1.7.RELEASE  ---  On a Spring Boot **2.1.5.RELEASE** application with Spring Cloud **Greenwich.SR1** running with OpenJDK 11.0.2, we get the following warning:   ``` WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (file:/.../org/springframework/spring-core/5.1.7.RELEASE/spring-core-5.1.7.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:525) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:582) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:569) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:416) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:57) 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205) 	at org.springframework.aop.framework.ProxyFactoryBean.getProxy(ProxyFactoryBean.java:378) 	at org.springframework.aop.framework.ProxyFactoryBean.getSingletonInstance(ProxyFactoryBean.java:330) 	at org.springframework.aop.framework.ProxyFactoryBean.getObject(ProxyFactoryBean.java:254) 	at org.springframework.cloud.sleuth.instrument.async.ExecutorBeanPostProcessor.getObject(ExecutorBeanPostProcessor.java:199) 	at org.springframework.cloud.sleuth.instrument.async.ExecutorBeanPostProcessor.getProxiedObject(ExecutorBeanPostProcessor.java:186) 	at org.springframework.cloud.sleuth.instrument.async.ExecutorBeanPostProcessor.createAsyncTaskExecutorProxy(ExecutorBeanPostProcessor.java:169) 	at org.springframework.cloud.sleuth.instrument.async.ExecutorBeanPostProcessor.wrapAsyncTaskExecutor(ExecutorBeanPostProcessor.java:147) 	at org.springframework.cloud.sleuth.instrument.async.ExecutorBeanPostProcessor.postProcessAfterInitialization(ExecutorBeanPostProcessor.java:92) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:429) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1782) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ```","closed","status: superseded,","pandrez","2019-06-07T14:50:41Z","2021-01-23T12:12:41Z"
"","23005","WebFlux: When using jetty-reactive-httpclient calling retry on WebClient.exchange throws CancellationException","When using the `jetty-reactive-httpclient` client connector with WebClient, whenever we call `retry` after WebClient.exchange (to retry the HTTP request), a `CancellationException` is thrown instead of the request being retried. When using `reactor-netty` client, the WebClient HTTP request is retried as expected.  It is unclear to us whether this is a Spring issue, or one with Reactor or Jetty. Please feel free to redirect us to the correct project.  Versions: Spring up to 5.1.7.RELEASE Spring Boot up to 2.1.4.RELEASE Jetty 9.4.18.v20190429 Reactor 3.2.8.RELEASE  See this sample repository for a full demonstration of the problem: https://github.com/scottjohnson/webclient-retry-repro  In part:  ``` webClient.get()                 .uri(""https://postman-echo.com/status/404"")                 .exchange()                 .flatMap(cr -> {                     if (!cr.statusCode().is2xxSuccessful()) {                         throw new ResponseStatusException(HttpStatus.BAD_GATEWAY, ""Didn't get a 200, retrying..."");                     }                     else return cr.bodyToMono(String.class);                 })                 .retry(2); ```  We would expect this code to retry the requested URI two more times. This happens as expected when using the `reactor-netty` client.  When using `jetty-reactive-http-client`, the original request is made, but on retry instead of retrying the following exception is thrown:  ``` java.util.concurrent.CancellationException: null 	at org.eclipse.jetty.reactive.client.internal.AbstractSinglePublisher.subscribe(AbstractSinglePublisher.java:54) ~[jetty-reactive-httpclient-1.0.3.jar:na] 	at reactor.core.publisher.MonoFromPublisher.subscribe(MonoFromPublisher.java:43) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3710) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.FluxRetry$RetrySubscriber.resubscribe(FluxRetry.java:109) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.FluxRetry$RetrySubscriber.onError(FluxRetry.java:93) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:122) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onNext(MonoIgnoreThen.java:296) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at org.eclipse.jetty.reactive.client.internal.AbstractSingleProcessor.downStreamOnNext(AbstractSingleProcessor.java:110) ~[jetty-reactive-httpclient-1.0.3.jar:na] 	at org.eclipse.jetty.reactive.client.internal.ResponseListenerPublisher.onNext(ResponseListenerPublisher.java:130) ~[jetty-reactive-httpclient-1.0.3.jar:na] 	at reactor.core.publisher.StrictSubscriber.onNext(StrictSubscriber.java:89) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.StrictSubscriber.onSubscribe(StrictSubscriber.java:77) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3710) ~[reactor-core-3.2.8.RELEASE.jar:3.2.8.RELEASE] 	at org.eclipse.jetty.reactive.client.internal.ResponseListenerPublisher.onHeaders(ResponseListenerPublisher.java:72) ~[jetty-reactive-httpclient-1.0.3.jar:na] 	at org.eclipse.jetty.client.ResponseNotifier.notifyHeaders(ResponseNotifier.java:98) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.ResponseNotifier.notifyHeaders(ResponseNotifier.java:90) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.HttpReceiver.responseHeaders(HttpReceiver.java:267) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.headerComplete(HttpReceiverOverHTTP.java:256) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.http.HttpParser.parseFields(HttpParser.java:1218) ~[jetty-http-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:1502) ~[jetty-http-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.parse(HttpReceiverOverHTTP.java:172) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:135) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:73) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:133) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:155) ~[jetty-client-9.4.18.v20190429.jar:9.4.18.v20190429] 	at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:305) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:427) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:321) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:159) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117) ~[jetty-io-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:333) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:310) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:168) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:126) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:366) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:765) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:683) ~[jetty-util-9.4.15.v20190215.jar:9.4.15.v20190215] 	at java.base/java.lang.Thread.run(Thread.java:844) ~[na:na] ```","closed","for: external-project,","scottjohnson","2019-05-20T23:24:14Z","2020-01-28T19:05:14Z"
"","23130","DefaultMultipartMessageReader.FilePart.transferTo fails occasionally","When using the `DefaultMultipartMessageReader` to parse multipart file uploads, the `FilePart.transferTo` fails.","closed","type: bug,","poutsma","2019-06-13T12:42:28Z","2019-06-14T12:22:12Z"
"","23367","WebClient's retrieve doesn't support custom HTTP status code","When using Spring WebFlux 5.1.8.RELEASE consider having the following code  ```java this.webClient.get() 			.uri(""http://localhost:"" + this.port + ""/customstatuscode"").retrieve() 			.bodyToMono(String.class) 			.block(); ```  and the controller looks like this  ```java @RequestMapping(value = ""/customstatuscode"", method = RequestMethod.GET) public ResponseEntity customStatusCode() { 	return ResponseEntity.status(499).build(); } ```  whenever this code is called, an exception is thrown (the stacktrace contains Spring Cloud Sleuth's logic)  ``` org.springframework.web.reactive.function.client.UnknownHttpStatusCodeException: Unknown status code [499]  	at org.springframework.web.reactive.function.client.DefaultWebClient$DefaultResponseSpec.lambda$createResponseException$13(DefaultWebClient.java:506) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:100) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onNext(ScopePassingSpanSubscriber.java:96) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onComplete(FluxDefaultIfEmpty.java:100) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:144) 	at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onComplete(FluxContextStart.java:122) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:144) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onComplete(FluxFilterFuseable.java:166) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1516) 	at reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onComplete(MonoCollectList.java:121) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:112) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) 	at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:390) 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:197) 	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:338) 	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:350) 	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:399) 	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:555) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:323) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:297) 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at java.base/java.lang.Thread.run(Thread.java:834) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:93) 		at reactor.core.publisher.Mono.block(Mono.java:1494) 		at org.springframework.cloud.sleuth.instrument.web.client.integration.WebClientTests.shouldNotBreakWhenCustomStatusCodeIsSetViaWebClient(WebClientTests.java:390) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 		at java.base/java.lang.reflect.Method.invoke(Method.java:566) 		at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) 		at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 		at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) 		at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 		at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) 		at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27) 		at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) 		at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) 		at org.springframework.test.context.junit4.statements.RunPrepareTestInstanceCallbacks.evaluate(RunPrepareTestInstanceCallbacks.java:64) 		at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) 		at org.springframework.test.context.junit4.statements.SpringFailOnTimeout.evaluate(SpringFailOnTimeout.java:87) 		at org.springframework.test.context.junit4.statements.ProfileValueChecker.evaluate(ProfileValueChecker.java:103) 		at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) 		at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) 		at junitparams.JUnitParamsRunner.runChild(JUnitParamsRunner.java:449) 		at junitparams.JUnitParamsRunner.runChild(JUnitParamsRunner.java:393) 		at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 		at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 		at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 		at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 		at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 		at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 		at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 		at org.springframework.test.context.junit4.statements.ProfileValueChecker.evaluate(ProfileValueChecker.java:103) 		at org.springframework.test.context.junit4.rules.SpringClassRule$TestContextManagerCacheEvictor.evaluate(SpringClassRule.java:190) 		at org.junit.rules.RunRules.evaluate(RunRules.java:20) 		at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 		at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 		at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) 		at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 		at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 		at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ```  somewhat related issue (https://github.com/spring-projects/spring-framework/issues/23366)","closed","type: enhancement,","marcingrzejszczak","2019-07-26T10:02:24Z","2019-07-30T13:48:36Z"
"","23366","Can't wrap a ClientResponse with a custom status code in a builder","When using Spring WebFlux 5.1.8.RELEASE consider having the following code  ```java ClientResponse response = ...; ClientResponse wrapped = ClientResponse.from(response) 					.body(response.bodyToFlux(DataBuffer.class) 					.transform(this.scopePassingTransformer)) 					.build() ```  when `response` contains a custom status code e.g. `499` the `DefaultClientResponseBuilder` in the constructor uses `statusCode(other.statusCode());` and `statusCode()` throws an exception since it's a custom status code.","closed","type: enhancement,","marcingrzejszczak","2019-07-26T09:40:31Z","2019-07-30T16:06:26Z"
"","23483","Spring 5 - JDBC gets column names from other schema in MySQL","When using Spring MVC 5.1.8.RELEASE along with JdbcTemplate, JDBC and MySQL Workbench, the query which is automatically created does not look for tables only in the current schema defined in the JDBC URL, but it also looks for tables in other schemas. So, if I have 2 schemas: _app1_ and _app2_ and each one has a table named ""table"" then the field names are returned from app2, even if app1 appears in the JDBC URL.   I tried debugging the application and found out that the issue comes from the class **GenericTableMetaDataProvider** from the package **org.springframework.jdbc.core.metadata** and the method is **locateTableAndProcessMetaData()**...The thing is that this method parses the whole database and uses a HashMap to store the table where the key is just a part of the jdbc URL(not the whole one). So, in the first iteration, the correct table is stored there but after that, the table is overriden by the table in the other schema.  The MySQL - JDBC URL used was: **jdbc:mysql://localhost:3306/app1** The same thing can be observed when using H2 database, but usually that is used only with integration tests and only one schema is used....  I attached 2 screenshots, one with the value of the key in the HashMap when using H2 database and one with MySQL. Also, I observed that this only happens when inserting data, not retrieving. The JdbcTemplade code that reproduced this is quite simple: ```java SimpleJdbcInsert insert = new SimpleJdbcInsert(jdbcTemplate); insert.setTableName(""table""); insert.usingGeneratedKeyColumns(""id""); Map map = new HashMap<>();  //...populate map  //insert new object, the query created will contain incorrect field names int id = insert.executeAndReturnKey(map).intValue(); ```  **H2:**   ![h2](https://user-images.githubusercontent.com/37183688/63228608-2057f500-c1fe-11e9-87a2-46998d38245b.png)  **MySQL:**   ![mysql](https://user-images.githubusercontent.com/37183688/63228607-1f26c800-c1fe-11e9-9565-c2b312ef7186.png)","closed","status: duplicate,","csabagabor","2019-08-18T18:32:02Z","2019-08-19T05:23:43Z"
"","23412","【infra 38】","When using org.springframework.util.CollectionUtils#hasUniqueObject such as   public void test() {     List list = new ArrayList<>();     list.add(1);     list.add(2);     System.out.println(CollectionUtils.hasUniqueObject(list)); } From the function name, the result should be true,because there are different objects, but it is actually false.  another example  public void test() {     List list = new ArrayList<>();     list.add(1);     list.add(1);     System.out.println(CollectionUtils.hasUniqueObject(list)); } From the function name, the result should be false,because there are same*objects, but it is actually true.  I believe the author may reversed the return.","closed","status: declined,","xjhxjhxjhxjh","2019-08-03T14:52:13Z","2019-08-05T12:39:50Z"
"","22990","When using Configuration annotation BeanDefinitionRegistryPostProcessor, the instance type of dependency injection is inconsistent with getBeanClassName in BeanDefinition","When using Configuration annotation BeanDefinitionRegistryPostProcessor, the instance type of dependency injection is inconsistent with getBeanClassName in BeanDefinition. The code is as follows  ```java @Configuration public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {      @Override     public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {         System.out.println();     }      @Override     public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {         System.out.println();     }  } ```  ```java @RunWith(SpringRunner.class) @SpringBootTest(classes = {DemoApplication.class}) public class DemoApplicationTests {      @Autowired     private ConfigurableApplicationContext context;      @Autowired     private MyBeanDefinitionRegistryPostProcessor myBeanDefinitionRegistryPostProcessor;      @Test     public void beanClassTest() {          String beanClass = myBeanDefinitionRegistryPostProcessor.getClass().getName();          String beanDefinitionBeanClass = context.getBeanFactory()                 .getBeanDefinition(""myBeanDefinitionRegistryPostProcessor"")                 .getBeanClassName();          System.out.println(beanClass);         System.out.println(beanDefinitionBeanClass);          Assert.assertEquals(""beanClass should equals beanDefinitionBeanClass"", beanClass, beanDefinitionBeanClass);     } } ```   ![image](https://user-images.githubusercontent.com/13413715/57965808-ace2e500-797b-11e9-8c6e-db9365cd3ec5.png)  The reasons are as follows:  The method enhanceConfigurationClasses in org.springframework.context.annotation.ConfigurationClassPostProcessor ,as long as beanDef is a full configuration, it will be added to configBeanDefs and then generated by cglib into the new class, resulting in updating the beanClassName in BeanDefinition. The code should be changed to the following  ![image](https://user-images.githubusercontent.com/13413715/57965932-dbfa5600-797d-11e9-8dae-eef8e3850c70.png)","closed","status: feedback-provided,","brucelwl","2019-05-18T07:02:34Z","2021-01-08T13:09:08Z"
"","22986","Spring Webflux 5.2.0.M2 - Kotlin coroutines - ServerRequest.awaitPrincipal always null","When using a suspend HandlerFunction `req.awaitPrincipal()` always returns null for me.  I created a new application with Spring Boot 2.2.0.M3 and the spring-webflux and spring-security starters. It has one coroutine based handler function and a ""classic"" one, both using the principal. The coroutine always gets null when calling `req.awaitPrincipal()`, but `req.principal()` works in the ""classic"" handler.  ```kotlin package com.example  import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.context.annotation.Bean import org.springframework.web.reactive.function.server.* import reactor.core.publisher.Mono  suspend fun coroutineHandler(req: ServerRequest): ServerResponse {     val principal = req.awaitPrincipal()     return ServerResponse.ok().bodyAndAwait(principal!!) }  fun classicHandler(req: ServerRequest): Mono =         req.principal()                 .flatMap { ServerResponse.ok().syncBody(it) }  @SpringBootApplication open class Application {      @Bean     open fun router(): RouterFunction {         val co = coRouter {             GET(""/co"", ::coroutineHandler)         }         val classic = router {             GET(""/classic"", ::classicHandler)         }         return co.and(classic)     }  }  fun main(args: Array) {     runApplication(*args) } ```  Using curl: ```bash curl localhost:8080/classic --user user:test # Returns Principal curl localhost:8080/co --user user:test # NPE, 500 status code ```  Is there some misunderstanding on my side or is this a bug?  Full example application is attached: [principal-coroutine-null.zip](https://github.com/spring-projects/spring-framework/files/3190278/principal-coroutine-null.zip)   For completeness, here is the stacktrace:    ``` 2019-05-17 09:03:10.599 ERROR 23470 --- [     parallel-3] a.w.r.e.AbstractErrorWebExceptionHandler : [d8098331] 500 Server Error for HTTP GET ""/co""  kotlin.KotlinNullPointerException: null 	at com.example.AppKt.coroutineHandler(App.kt:11) ~[main/:na] 	at com.example.Application$router$co$1$1.invoke(App.kt:24) ~[main/:na] 	at com.example.Application$router$co$1$1.invoke(App.kt:19) ~[main/:na] 	at org.springframework.web.reactive.function.server.CoRouterFunctionDsl$asHandlerFunction$1$1.invokeSuspend(CoRouterFunctionDsl.kt:440) ~[spring-webflux-5.2.0.M2.jar:5.2.0.M2] 	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) ~[kotlin-stdlib-1.3.31.jar:1.3.31-release-198 (1.3.31)] 	at kotlinx.coroutines.DispatchedKt.resumeCancellable(Dispatched.kt:447) ~[kotlinx-coroutines-core-1.2.1.jar:na] 	at kotlinx.coroutines.intrinsics.CancellableKt.startCoroutineCancellable(Cancellable.kt:25) ~[kotlinx-coroutines-core-1.2.1.jar:na] 	at kotlinx.coroutines.CoroutineStart.invoke(CoroutineStart.kt:109) ~[kotlinx-coroutines-core-1.2.1.jar:na] 	at kotlinx.coroutines.AbstractCoroutine.start(AbstractCoroutine.kt:154) ~[kotlinx-coroutines-core-1.2.1.jar:na] 	at kotlinx.coroutines.reactor.MonoKt$mono$1.accept(Mono.kt:38) ~[kotlinx-coroutines-reactor-1.2.1.jar:na] 	at kotlinx.coroutines.reactor.MonoKt$mono$1.accept(Mono.kt) ~[kotlinx-coroutines-reactor-1.2.1.jar:na] 	at reactor.core.publisher.MonoCreate.subscribe(MonoCreate.java:57) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2126) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1934) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1808) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoPeek.subscribe(MonoPeek.java:71) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:141) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onNext(FluxFilter.java:107) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:92) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1570) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:92) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onNext(FluxFilterFuseable.java:113) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:331) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1570) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onNext(FluxFilterFuseable.java:113) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2126) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.request(FluxFilterFuseable.java:185) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onSubscribe(MonoFlatMap.java:103) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onSubscribe(FluxFilterFuseable.java:82) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoCurrentContext.subscribe(MonoCurrentContext.java:35) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilterFuseable.subscribe(MonoFilterFuseable.java:47) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilterFuseable.subscribe(MonoFilterFuseable.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:56) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilterFuseable.subscribe(MonoFilterFuseable.java:47) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefaultIfEmpty.subscribe(MonoDefaultIfEmpty.java:37) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onNext(FluxFilterFuseable.java:113) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2126) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.request(FluxFilterFuseable.java:185) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onSubscribe(MonoFlatMap.java:103) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onSubscribe(FluxFilterFuseable.java:82) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilterFuseable.subscribe(MonoFilterFuseable.java:47) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefaultIfEmpty.subscribe(MonoDefaultIfEmpty.java:37) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2128) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1934) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1808) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:265) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:201) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:335) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter.subscribe(FluxFilter.java:53) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1570) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onComplete(FluxDefaultIfEmpty.java:100) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onComplete(FluxMap.java:262) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1571) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoProcessor.onNext(MonoProcessor.java:316) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1570) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSupplier.subscribe(MonoSupplier.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:360) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onComplete(FluxConcatMap.java:269) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators.complete(Operators.java:132) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:122) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoPeek.subscribe(MonoPeek.java:71) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoProcessor.add(MonoProcessor.java:456) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoProcessor.subscribe(MonoProcessor.java:369) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefaultIfEmpty.subscribe(MonoDefaultIfEmpty.java:37) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2128) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1934) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1808) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:265) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:201) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:335) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter.subscribe(FluxFilter.java:53) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2128) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1934) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1808) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:265) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:201) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:335) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter.subscribe(FluxFilter.java:53) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:174) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2128) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1934) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1808) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3711) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:75) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onComplete(FluxFilter.java:160) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:265) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:201) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:335) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter.subscribe(FluxFilter.java:53) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFilter.subscribe(MonoFilter.java:46) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoSubscriberContext.subscribe(MonoSubscriberContext.java:47) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1570) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxFilter$FilterSubscriber.onNext(FluxFilter.java:107) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.publisher.FluxSubscribeOnValue$ScheduledScalar.run(FluxSubscribeOnValue.java:178) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:50) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:27) ~[reactor-core-3.3.0.M1.jar:3.3.0.M1] 	at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) ~[na:1.8.0_212] 	at java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:1.8.0_212] 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[na:1.8.0_212] 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) ~[na:1.8.0_212] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_212] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[na:1.8.0_212] 	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_212] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	|_ checkpoint ⇢ org.springframework.security.web.server.authorization.AuthorizationWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.authorization.ExceptionTranslationWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.authentication.logout.LogoutWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.savedrequest.ServerRequestCacheWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.context.SecurityContextServerWebExchangeWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.ui.LogoutPageGeneratingWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.ui.LoginPageGeneratingWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.authentication.AuthenticationWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.authentication.AuthenticationWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.context.ReactorContextWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.csrf.CsrfWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.header.HttpHeaderWriterWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.config.web.server.ServerHttpSecurity$ServerWebExchangeReactorContextWebFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.security.web.server.WebFilterChainProxy [DefaultWebFilterChain] 	|_ checkpoint ⇢ org.springframework.boot.web.reactive.filter.OrderedHiddenHttpMethodFilter [DefaultWebFilterChain] 	|_ checkpoint ⇢ HTTP GET ""/co"" [ExceptionHandlingWebHandler] ```","closed","type: bug,","FrontierPsychiatrist","2019-05-17T07:08:16Z","2019-09-11T08:40:34Z"
"","23584","Kotlin data class constructor params working differently to properties declared in the class body with a @ModelAttribute","When using a Kotlin data class with a list (or set) param in the constructor and as a field in the body: ```kotlin data class ParamQuery(val ids1: Set = setOf()) {     var ids2: Set = setOf() } ```  When using the class as a `@ModelAttribute` of a RestController method: ```kotlin     @GetMapping     @ResponseStatus(HttpStatus.OK)     fun query(@ModelAttribute query: ParamQuery) = query.ids1 + query.ids2 ```  The value of the ids is different when sent as a comma separated list to the method: ```kotlin             MockMvcRequestBuilders.get(""/v1"")                 .param(""ids1"", ""A,B"") // comma-separated param values                 .param(""ids2"", ""C,D"") // comma-separated param values                 .contentType(MediaType.APPLICATION_JSON) ```  Gives a body content of `[""A,B"",""C"",""D""]` which seems wrong it should be `[""A"",""B"",""C"",""D""]` which is what is returned when sending the params multiple times.  ```kotlin             MockMvcRequestBuilders.get(""/v1"")                 .param(""ids1"", ""A"", ""B"") // vararg param values                 .param(""ids2"", ""C"", ""D"") // vararg param values                 .contentType(MediaType.APPLICATION_JSON) ```  Gived a body content of  `[""A"",""B"",""C"",""D""]` which is correct.  For some reason the constructor param `ids1` isn't being expanded out unlike the field `ids2`  I have recreated the issue in a small project [here](https://github.com/LtTempletonPeck/multiple-params)  Versions: spring-boot 2.1.7 spring-web 5.1.9 kotlin 1.3.50","closed","","LtTempletonPeck","2019-09-04T12:51:07Z","2022-02-18T19:07:10Z"
"","24724","Mockito cannot mock @Async method","When trying to mock an `@Async` method from a `@SpyBean` I get the following error:  ``` org.mockito.exceptions.misusing.InvalidUseOfMatchersException:  Misplaced or misused argument matcher detected here:  -> at package.TestClass.init_aroundBody0(File.java:79) -> at package.TestClass.init_aroundBody0(File.java:79)  You cannot use argument matchers outside of verification or stubbing. Examples of correct usage of argument matchers:     when(mock.get(anyInt())).thenReturn(null);     doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());     verify(mock).someMethod(contains(""foo""))  This message may appear after an NullPointerException if the last matcher is returning an object  like any() but the stubbed method signature expect a primitive argument, in this case, use primitive alternatives.     when(mock.get(any())); // bad use, will raise NPE     when(mock.get(anyInt())); // correct usage use  Also, this error might show up because you use argument matchers with methods that cannot be mocked. Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode(). Mocking methods declared on non-public parent classes is not supported. ```  This error only appears when I run the test without debugger attached. When I try to debug, the error doesn't show up, and everything works fine. When I remove the `@Async`, then it works also without the debugger attached.  This error started showing up after I upgraded from spring 4 to spring 5. Using **spring-boot-starter-test 2.1.6.RELEASE** (mockito-core:2.23.4, spring-test:5.1.8.RELEASE)","open","in: test,","cdalexndr","2019-07-20T09:56:04Z","2021-11-11T09:43:20Z"
"","23318","Invalid hibernate proxy entity id","When trying to delete an entity, nothing happens because spring is accessing the id directly, and because it is a hibernate proxy object, the member has default 0 value, thus it thinks it is a new entity and skips altogether the delete.  From debugging, this is the relevant part of the callstack:  ``` getField:674, ReflectionUtils (org.springframework.util) getPropertyValue:63, DirectFieldAccessFallbackBeanWrapper (org.springframework.data.util) getId:154, JpaMetamodelEntityInformation (org.springframework.data.jpa.repository.support) isNew:42, AbstractEntityInformation (org.springframework.data.repository.core.support) isNew:233, JpaMetamodelEntityInformation (org.springframework.data.jpa.repository.support) delete:170, SimpleJpaRepository (org.springframework.data.jpa.repository.support) ```  At the top, in `ReflectionUtils::getField(Field,Object)` method, the `target` variable is of type class `package.Class$HibernateProxy$HWnaDQWN`, and field is `private int package.Class.id`.  Note that accessing the `id` by method `target.getId()` returns non-zero id, as expected.  The `id` is defined inside the entity as follows:  ```java     @Id @GeneratedValue(strategy = GenerationType.IDENTITY)     private int id; ```  **Spring Boot 2.1.6.RELEASE**  - Spring-core 5.1.8.RELEASE - Hibernate-core 5.3.10.Final - Spring-data-commons 2.1.9.RELEASE - Spring-data-jpa 2.1.9.RELEASE","closed","for: external-project,","cdalexndr","2019-07-19T15:30:58Z","2019-07-19T19:23:58Z"
"","23306","ForwardedHeaderTransformer tries to build a URI from a decoded path when X-Forwarded-Prefix is set","When setting an _X-Forwarded-Prefix_ and having an request URI that contains escape sequences like `%23` an `URISyntaxException` exception is thrown from `java.net.URI$Parser.parse` in `ForwardedHeaderTransformer` as the path is decoded in `ForwardedHeaderTransformer`:  ``` exception: ""java.lang.IllegalStateException: Invalid URI path: ""[...]/api/redeliveries/SN23#23232323#23"" 	at org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder.getUriToUse(DefaultServerHttpRequestBuilder.java:172) 	at org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder.build(DefaultServerHttpRequestBuilder.java:134) 	at org.springframework.web.server.adapter.ForwardedHeaderTransformer.apply(ForwardedHeaderTransformer.java:104) 	at org.springframework.web.server.adapter.HttpWebHandlerAdapter.handle(HttpWebHandlerAdapter.java:227) 	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext$ServerManager.handle(ReactiveWebServerApplicationContext.java:205) 	at org.springframework.http.server.reactive.ReactorHttpHandlerAdapter.apply(ReactorHttpHandlerAdapter.java:65) 	at org.springframework.http.server.reactive.ReactorHttpHandlerAdapter.apply(ReactorHttpHandlerAdapter.java:40) 	at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:63) [snip] Caused by: java.net.URISyntaxException: Illegal character in fragment at index 102: [...]/api/redeliveries/SN23#23232323#23 	at java.base/java.net.URI$Parser.fail(Unknown Source) 	at java.base/java.net.URI$Parser.checkChars(Unknown Source) 	at java.base/java.net.URI$Parser.parse(Unknown Source) 	at java.base/java.net.URI.(Unknown Source) 	at org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder.getUriToUse(DefaultServerHttpRequestBuilder.java:169) 	... 34 common frames omitted ```  PR: #23305","closed","status: superseded,","AndreasKl","2019-07-17T13:53:49Z","2019-07-18T09:40:34Z"
"","23599","MockClientHttpResponse loses original HttpStatus code","When server replies with non-standard Http Code, e.g. 250, this information is swallowed and 200 code is returned.  https://github.com/spring-projects/spring-framework/blob/35b967a8016f3798502c56b7a7f9dbd700b5e23b/spring-test/src/main/java/org/springframework/test/web/reactive/server/HttpHandlerConnector.java#L124","closed","type: enhancement,","skrser","2019-09-06T13:26:20Z","2019-09-16T07:53:16Z"
"","23263","Improve documentation for @Autowired constructors","When multiple constructors are marked by `@Autowired`, it doesn't work. Although [Spring documentation](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation) clearly says that it should:  > Only one annotated constructor per class can be marked as required, but multiple non-required constructors can be annotated. In that case, each is considered among the candidates and Spring uses the greediest constructor whose dependencies can be satisfied — that is, the constructor that has the largest number of arguments. The constructor resolution algorithm is the same as for non-annotated classes with overloaded constructors, just narrowing the candidates to annotated constructors.  I get this error when I mark multiple constructors with @Autowired with one being `required = true` and other being marked as `required = false`:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'constructorInjectComponent': Invalid autowire-marked constructors: [public com.example.demo.ConstructorInjectComponent(com.example.demo.InjectionServiceThree)]. Found constructor with 'required' Autowired annotation: public com.example.demo.ConstructorInjectComponent(com.example.demo.InjectionServiceOne,com.example.demo.InjectionServiceTwo) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:322) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors(AbstractAutowireCapableBeanFactory.java:1269) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1184) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:845) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE] 	at com.example.demo.MultipleConstructionInjectionApplication.main(MultipleConstructionInjectionApplication.java:10) [main/:na] ```  This is the code:  ```java @Component @EnableScheduling public class ConstructorInjectComponent {  	private InjectionServiceOne injectionServiceOne;  	private InjectionServiceTwo injectionServiceTwo; 	 	private InjectionServiceThree injectionServiceThree;   	@Autowired(required = true) 	public ConstructorInjectComponent(InjectionServiceOne injectionServiceOne, 			InjectionServiceTwo injectionServiceTwo) { 		this.injectionServiceOne = injectionServiceOne; 		this.injectionServiceTwo = injectionServiceTwo; 	}  	@Autowired(required = false) 	public ConstructorInjectComponent(InjectionServiceThree injectionServiceThree) { 		this.injectionServiceThree = injectionServiceThree; 	} 	 	@Scheduled(fixedRate = 1000L) 	public void allFieldsConstructorInjectionTest() { 		System.err.println(""constructorInjection "" + injectionServiceOne.method() + "" "" + injectionServiceTwo.method() + injectionServiceThree.method()); 	} } ```  I have created a simple [github repo](https://github.com/farazdurrani/MultipleConstructorInjectionNotWorking) to reproduce the issue.  OS: Ubuntu 18.04 JDK 8.  Spring Boot version 2.1.6","closed","in: core,","farazdurrani","2019-07-09T18:58:12Z","2020-04-01T16:36:35Z"
"","23043","Spring MVC custom argument resolvers order","When I want to custom one argument Resolver in ：    WebMvcConfigurerAdapter#addArgumentResolvers，and try to override parameter type of ServletRequest ; but I found it that caught low priority after ServletRequestMethodArgumentResolver (same parameter type of ServletRequest) ； review source RequestMappingHandlerAdapter#getDefaultArgumentResolvers  discover  below :                 `// Type-based argument resolution 		resolvers.add(new ServletRequestMethodArgumentResolver()); 		resolvers.add(new ServletResponseMethodArgumentResolver()); 		resolvers.add(new HttpEntityMethodProcessor(getMessageConverters())); 		resolvers.add(new RedirectAttributesMethodArgumentResolver()); 		resolvers.add(new ModelMethodProcessor()); 		resolvers.add(new MapMethodProcessor()); 		resolvers.add(new ErrorsMethodArgumentResolver()); 		resolvers.add(new SessionStatusMethodArgumentResolver()); 		resolvers.add(new UriComponentsBuilderMethodArgumentResolver());  		// Custom arguments 		if (getCustomArgumentResolvers() != null) { 			resolvers.addAll(getCustomArgumentResolvers()); 		} `  I think that custom  arguments resolver  should be  before the default argument ,so that can  get  highly priority to handle my logic; Thanks .","closed","status: feedback-provided,","victorkevin2","2019-05-28T02:44:35Z","2021-01-08T13:09:08Z"
"","23574","HandlerMethodArgumentResolver Invalid","When I used `HandlerMethodArgumentResolver,` I suddenly found that it had failed.  My `HandlerMethodArgumentResolver`: ```java public class LoginUserHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver {     @Override     public boolean supportsParameter(MethodParameter parameter) {         return parameter.hasParameterAnnotation(LoginUser.class);     }     @Override     public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer container,                                   NativeWebRequest request, WebDataBinderFactory factory) throws Exception {         return new Integer(1);     } } ```  My configuration file: ```java @Configuration public class WebMvcConfiguration implements WebMvcConfigurer {     @Override     public void addArgumentResolvers(List argumentResolvers) {         argumentResolvers.add(new LoginUserHandlerMethodArgumentResolver());     } } ```  Usage method:    ```java @PostMapping(value = ""/login"") public String login(@LoginUser Integer userId, @RequestBody String body) {     log.info(""userId {} ，body {}"", userId, body);     return ""success""; } ``` But the output `userId null` I don't know what's wrong. Please help me.  My spring-framework version is:5.1.9.RELEASE","closed","status: invalid,","Ziyear","2019-09-03T13:26:16Z","2019-09-05T11:23:23Z"
"","23592","Spring-web compatibility issues after upgrading from 2.1.3 to 2.1.7","When I upgraded the spring-boot version from 2.1.3 to 2.1.7, I found that the `spring-web` version was upgraded from 5.1.5 to 5.1.9. However, when I deployed the project to the server and started tomcat, an error occurred:  ``` org.xml.sax.SAXParseException; systemId: jar:file:/opt/apache-tomcat-8.5.33_1/webapps/.../WEB-INF/lib/spring-web-5.1.9.RELEASE.jar!/META-INF/web-fragment.xml; lineNumber: 5; columnNumber: 41; schema_reference.4: Failed to read schema document 'https://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd', because  1) could not find the document;  2) the document could not be read;  3) the root element of the document is not . at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203) at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.warning(ErrorHandlerWrapper.java:99) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:392) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:327) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:284) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.findSchemaGrammar(XMLSchemaValidator.java:2451) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.handleStartElement(XMLSchemaValidator.java:1768) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:741) at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:374) at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl$NSContentDriver.scanRootElementHook(XMLNSDocumentScannerImpl.java:613) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:31 ```   The pom.xml file starts like this:  ```xml  The < project XMLNS = ""http://maven.apache.org/POM/4.0.0"" XMLNS: xsi = ""http://www.w3.org/2001/XMLSchema-instance"" Xsi: schemaLocation = ""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"" > ```  What is the reason for this, or how can I change it to upgrade correctly?","closed","for: external-project,","1988andy","2019-09-05T07:04:31Z","2019-12-05T12:34:42Z"
"","22828","Spring MVC @Responsebody triggers lazy loading","When I serialize the Page object that I query using JPA using Spring MVC's @Responsebody, the associated Z object in T will be triggered lazy loading. If I don't want the associated Z object to trigger lazy loading, then I'll have to use the @Jsonignore provided by Jackson to mark the object associated with T and ignore the serialization of the Z object when serializing T. Sometimes I want the associated Z object in T to trigger lazy loading, but sometimes I don't want the associated Z object in T to trigger lazy loading. How can I solve this problem","closed","for: stackoverflow,","C644753271","2019-04-23T09:08:08Z","2019-04-28T03:31:31Z"
"","23199","what is recommended log level for org.springframework packages","when I destroy bean, I can not check error log.  *my logback configuration is* ```xml            ```  *bean destroy method* ```java @PreDestroy void destory() {   throw new RuntimeException(""message""); } ``` *console log* ```shell 09:27:45.932 [Thread-8] INFO  o.s.b.f.s.DisposableBeanAdapter - Destroy method 'destroy' on bean with name 'sqsReceiver' threw an exception: java.lang.RuntimeException: message ```  I couldn't see logs because  my  configuration of 'org.springframework' is 'ERROR'. I waste lots of time on debugging.  would you explain spring logging rules?  and i think configuration for log level might be ""warn"" or ""error"" rather than log lovel ""info"".(**DisposableBeanAdapter** invokeCustomDestroyMethod)  I pull requested to https://github.com/spring-projects/spring-framework/pull/23200","open","in: core,","boojongmin","2019-06-27T00:44:50Z","2019-06-27T10:11:38Z"
"","23597","Tweak detection of Bamboo","When exposed as an environment variable Bamboo's `bamboo.resultsUrl` is mapped to `bamboo_resultsUrl`. This PR updates the build scan user data script to look for the latter rather than the former.","closed","type: task,","wilkinsona","2019-09-06T09:15:27Z","2019-09-06T15:18:45Z"
"","22988","Document that SimpleCacheManager requires caches to be initialized when not used as a bean","When creating a `org.springframework.cache.support.SimpleCacheManager` and explicitly adding caches to it, the configured object does not maintain the contract of the `org.springframework.cache.CacheManager` interface.   Specifically, `getCacheNames()` and `getCache(String name)` do not behave as one would expect, returning an empty collection and `null` respectively.  This issue is reproducible with version 5.1.7.RELEASE.  This issue is demonstrated with the following test:   	package com.ak; 	import static org.junit.Assert.assertEquals; 	import static org.junit.Assert.assertNotNull; 	import static org.junit.Assert.assertTrue;  	import java.util.Collection; 	import java.util.Collections;  	import org.junit.Test; 	import org.springframework.cache.Cache; 	import org.springframework.cache.concurrent.ConcurrentMapCache; 	import org.springframework.cache.support.SimpleCacheManager;  	public class TestSimpleCacheManager {  	    private static final String CACHE_NAME = ""this is a cache""; 	     	    @Test 	    public void testGetCacheNames() { 	        SimpleCacheManager simpleCacheManager = setUpSimpleCacheManager(); 	         	        Collection cacheNames = simpleCacheManager.getCacheNames(); 	        assertEquals(1, cacheNames.size()); 	        assertTrue(cacheNames.contains(CACHE_NAME)); 	    } 	     	    @Test 	    public void testGetCache() { 	        SimpleCacheManager simpleCacheManager = setUpSimpleCacheManager(); 	         	        Cache cache = simpleCacheManager.getCache(CACHE_NAME); 	         	        assertNotNull(cache); 	    }  	    private SimpleCacheManager setUpSimpleCacheManager() { 	        Cache cache = new ConcurrentMapCache(CACHE_NAME); 	         	        SimpleCacheManager simpleCacheManager = new SimpleCacheManager(); 	        simpleCacheManager.setCaches(Collections.singleton(cache)); 	        return simpleCacheManager; 	    } 	}  using the following pom file:  	 	  4.0.0 	  com.ak 	  ak-testing 	  0.0.1-SNAPSHOT 	  ak-testing 	   	       	          org.springframework 	          spring-context 	          5.1.7.RELEASE 	       	       	          junit 	          junit 	          4.11 	          test 	       	   	   I'd be happy to take a crack at creating a patch for this issue, should this be something that is desired to be fixed.  Thanks","closed","type: documentation,","akokskis","2019-05-17T19:14:57Z","2020-08-24T16:18:30Z"
"","23718","Unable to (explicitly) close ResultSet within SqlRowSet","When calling jdbcTemplate.queryForRowSet(...), the corresponding SqlRowSet does not provide a method to close the underlying ResultSet resulting in a memory leak.  The workaround is to check if SqlRowSet is an instance of (https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/support/rowset/ResultSetWrappingSqlRowSet.html) and then cast it to that, then call getResultSet().close().  Either provide a close() method or a getResultSet() method on the SqlRowSet interface.  This is reproducible in Spring 5.1.9","closed","status: feedback-provided,","walterjwhite","2019-09-26T10:12:27Z","2021-01-19T12:53:48Z"
"","23701","Run webflux's tests in parallel to shorten long tail of builds","When built in an environment where many Gradle build workers are available, `:spring-webflux:test` is regularly the only task running at the end of the build. Therefore, the build's overall execution time can be reduced by running its tests in parallel, spreading the tests' execution across the available workers. The configured number of forks is a maximum with Gradle reducing this as necessary for environments with low numbers of cores where multiple workers will not improve build performance.","closed","type: task,","wilkinsona","2019-09-25T11:19:25Z","2019-09-25T11:44:15Z"
"","22920","@Configuration(proxyBeanMethods = false) cannot implement ImportAware","When a configuration class is annotated with `@Configuration(proxyBeanMethods = false)` and also implements `ImportAware`, the method `setImportMetadata` never gets called.  I have created a sample that demonstates this behaviour through a failing test https://github.com/eleftherias/spring-import-aware-no-proxy/blob/master/src/test/java/com/example/importawarenoproxy/ImportAwareNoProxyApplicationTests.java  It seems to be cause by this line https://github.com/spring-projects/spring-framework/blob/c366e205e5b9f4834eb8e4420705c183e7282ac4/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java#L463  When a configuration class e.g `BasicConfig` is annotated with `@Configuration` the bean class is `BasicConfig$$EnhancerBySpringCGLIB` and the superclass name is `BasicConfig`. However, when the class is annotated with `@Configuration(proxyBeanMethods = false)` the bean class is `BasicConfig` and the superclass is `Object`, which causes the `importingClass` to be null.","closed","in: core,","eleftherias","2019-05-07T18:47:39Z","2019-05-07T21:53:06Z"
"","23276","@TransactionalEventListener should not receive an event if no transaction is active","when a component method is annotated with `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`, no event should be received from a code block annotated with           `@Transactional(propagation = Propagation.NOT_SUPPORTED)`  I made a very small spring boot project that shows the issue: 2 Test methods in that project:  `@Test public void notTransactional()` --> WORKS OK (no transactional event is received) `@Test  public void notSupported()`  --> (KO: an event is received and it should not be because the block from witch the event is send is a propagation=NOT_SUPPORTED block)  [com.cbo.transac.zip](https://github.com/spring-projects/spring-framework/files/3382332/com.cbo.transac.zip)","closed","type: bug,","clembo590","2019-07-11T13:56:01Z","2019-07-12T13:40:10Z"
"","23350","Inconsistent array binding when using bracket notation","When `POST`ing array data to a Spring MVC annotated controller method, I get inconsistent results when I use a square-bracket notation.  The `POST` data looks like this: ``` foo[0] = 1 foo[1] = 2 ``` We're intentionally using the bracket notation so that we can build multi-demensional arrays (but this bug does not require multi-dimensional arrays to reproduce). The bug does not occur if you drop the brackets and just send duplicate URI parameter names.  When I bind it to a controller method that looks like the following, the resulting variable is null which is not expected: ``` @PostMapping public void myController(Long[] foo) {    // foo == null  } ```  But when I bind it inside a more complex bean then it works as expected; the array is not null and populated with values: ``` class MyBean {   private Long[] foo; }  @PostMapping public void myController(MyBean bean) {    // bean.foo !== null && bean.foo.length == 2 } ```  After some digging around, I [read this line in the documentation](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web.html#mvc-ann-arguments) regarding how method arguments are handled:  > If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by BeanUtils#isSimpleProperty, it is a resolved as a @RequestParam. Otherwise, it is resolved as a @ModelAttribute.  - I think in the first scenario where it does not work as expected, there is an implicit `@RequestParam` annotation on the argument and `RequestParamMethodArgumentResolver` [fails to find the parameter values](https://github.com/spring-projects/spring-framework/blob/2bb510588d3e4fb28cbdf6e8965f6cf81b50c094/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java#L180) (because of the brackets) and therefore constructs a null array. - I think in the second scenario there is an implicit `@ModelAttribute` annotation, I'm assuming the code path is a little different (I'm guessing it goes through `ServletModelAttributeMethodProcessor`?) and therefore it works.  Ultimately, I'm guessing the solution (if I'm understanding the codebase well enough) is to beef up `RequestParamMethodArgumentResolver` to handle the bracket notation?","open","in: web,","mbosecke","2019-07-24T16:00:59Z","2021-11-10T11:54:51Z"
"","23622","Improper UTF-8 handling in MockMvc for JSON response","When `MediaType.APPLICATION_JSON_UTF8` was deprecated, the content type of JSON that gets sent from a `@RestController` changed to `application/json` (without charset).   This breaks `MockMvc` tests that use `.andExpect(content().json())`. Here is a sample test:  ```java @Test public void returnsTheExpectedResponse() throws Exception {     mockMvc.perform(get(""/""))         .andExpect(status().isOk())         .andExpect(content().json(""{\""name\"":\""Jürgen\""}"")); } ```  The test runs fine with Spring 5.1.9 but fails with Spring 5.2.0.RC2  ``` java.lang.AssertionError: name Expected: Jürgen      got: JÃ¼rgen ```  You can find a sample Spring Boot project to reproduce the problem at https://github.com/sgybas/mockmvc-json-utf8  There was a similar issue for `jsonPath()` (#23219).","closed","type: regression,","sgybas","2019-09-11T11:30:31Z","2019-10-23T13:05:10Z"
"","23658","Avoid ArrayIndexOutOfBoundsException in SpEL's Indexer","When `index == arrayLength`, the array index is also out of bounds.  For this use case, a `SpelEvaluationException` should be thrown instead of `ArrayIndexOutOfBoundsException`.","closed","status: feedback-provided,","JoyceZhan","2019-09-18T11:12:00Z","2021-04-27T11:32:31Z"
"","23259","Support Jackson XML Parser for blocking Mono","Webflux should allow SYNC xml parsing with jackson mapper:  ```			 ObjectMapper mapper = new Jackson2ObjectMapperBuilder()       .createXmlMapper(true)       .modules(new JavaTimeModule())       .build();  this.webClient = WebClient.builder()         .baseUrl(""/"")         .exchangeStrategies(ExchangeStrategies.builder().codecs((configurer) -> { 		configurer.defaultCodecs().jackson2JsonDecoder(new Jackson2JsonDecoder(mapper)); 		}).build())           .build(); 			 webClient.post().uri(url).syncBody(req).retrieve().bodyToMono(MyResponse.class).block(); ```  Jackson in general supports sync parsing, so this should work in webflux. But result is an exception: ``` java.lang.UnsupportedOperationException: Non-blocking source not (yet?) support for this format (XML) 	at com.fasterxml.jackson.core.JsonFactory._requireJSONFactory(JsonFactory.java:1618) ~[jackson-core-2.9.9.jar:2.9.9] 	at com.fasterxml.jackson.core.JsonFactory.createNonBlockingByteArrayParser(JsonFactory.java:962) ~[jackson-core-2.9.9.jar:2.9.9] 	at org.springframework.http.codec.json.Jackson2Tokenizer.tokenize(Jackson2Tokenizer.java:188) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.http.codec.json.AbstractJackson2Decoder.decodeToMono(AbstractJackson2Decoder.java:98) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.http.codec.DecoderHttpMessageReader.readMono(DecoderHttpMessageReader.java:105) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.reactive.function.BodyExtractors.lambda$readToMono$14(BodyExtractors.java:211) ~[spring-webflux-5.1.8.RELEASE.jar:5.1.8.RELEASE] ```  It might be sufficient to detect that the request is blocking, and therefore not calling `jsonFactory.createNonBlockingByteArrayParser()` in `Jackson2Tokenizer`?  Maybe related to https://github.com/spring-projects/spring-framework/issues/20256","open","in: web,","membersound","2019-07-09T12:16:14Z","2022-06-30T07:26:08Z"
"","22820","Support suspending functions returning Flow","WebFlux Coroutines support does not handle correctly suspending functions that returns Coroutines `Flow` which is a valid use case when for example using `WebClient` ""2 stage"" API.  ``` @GetMapping(""/flow-via-webclient"") suspend fun flowViaWebClient() = 		client.get() 			.uri(""/flow"") 			.accept(MediaType.APPLICATION_JSON) 			.awaitExchange() 			.bodyToFlow() ```  This use case is valid and should be supported.","closed","type: bug,","sdeleuze","2019-04-19T13:15:33Z","2019-04-23T09:39:57Z"
"","22815","Support for Reactor Flux with spring-jms","WebFlux allows for reactive HTTP client and server operations, and does a fantastic job at that. However, it seems like the spring-jms module doesn't provide similar functionality for listening and publishing to JMS brokers using reactive streams. Given the close match between the JMS messaging model of a stream of messages and Reactor's model of a stream of events, this seems like a real missed opportunity.","closed","status: declined,","Diagoras","2019-04-17T16:59:12Z","2020-04-01T19:00:41Z"
"","23383","Spring transaction info is not cleaned","We use Platform transaction management of Spring , the below example is how we use it. DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition(); transactionStatus  = transactionManager.getTransaction(transactionDefinition); //do some datasource staff transactionManager.commit(transactionStatus); In situations where we do not commit or rollback the transaction ; the transaction status is attached to thread and not removed on returning the thread to pool.  next time when the same thread is reused. any new transaction in case on TransactionDefinition.PROPAGATION_REQUIRED gives older transaction status and the current function calling the tx Manager doesn't become owner. So when the work is done and the function tries to commit or rollback , the transaction is not actually commited. Beacause we use the websphere jndi datasource，it finds that we use a connection and start a transaction but forget to commit，so it decide to rollback back the transaction and print a log like WLTC0033W： Resource XXX rolled back in cleanup of Local TransactionContainment One or more local transaction resources were rooled back during the clean up of a LocalTransactionContainment.  In my option, when I forget to commit the transaction,it should only influence the current transaction,but not any transaction handled by the same thread.Can spring offer some filter or interceptor to clean up the transaction information at the end of the http request.","open","in: data,","gxgmy521","2019-07-30T03:28:00Z","2021-11-10T12:11:39Z"
"","23314","Improvements to RSocketStrategies","We should try and use the `PathPatternRouteMatcher` as a default `RouteMatcher` implementation in the RSocket infrastructure if it is available (i.e. if `spring-web` is on the classpath).","closed","type: enhancement,","bclozel","2019-07-18T11:41:16Z","2019-07-24T12:16:13Z"
"","22884","Expose MergedAnnotations from meta-data classes","We should now be able to expose `MergedAnnotations` from `AnnotatedTypeMetadata` to allow the new API to be used directly. Many of the existing methods can also be implemented with delegating class to `MergedAnnotations`.  We can probably also simplify the ASM reading code and lean on standard reflection to provide meta-data support.","closed","type: enhancement,","philwebb","2019-05-04T01:09:25Z","2019-05-07T21:13:48Z"
"","23657","Document WebMvc.fn","We should add a section to the reference documentation on WebMvc.fn.","closed","in: web,","poutsma","2019-09-18T10:20:07Z","2019-09-23T13:29:42Z"
"","23004","Make Spring web configuration classes use proxyBeanMethods=false by default","We originally discussed this in #22596 but we discarded that because we felt it would make the task harder for people to extend those configuration classes (`DelegatingWebFluxConfiguration` and `DelegatingWebMvcConfiguration`).  After discussing that with @wilkinsona , it seems that it's actually the opposite. If a developer extends one of those with an `@Configuration` class, that new config class will use proxying, even if the parent class has the `proxyBeanMethods=false` option. On the other hand, a developer looking at these infrastructure classes can't guess that they can be used with a `proxyBeanMethods=false` setup, or at least they won't get any guarantee on that while reading the source code.  We should add the `proxyBeanMethods=false` option on these classes because:  1. This will improve the performance for non-Spring Boot users 2. This will provide hints to developers extending those classes, telling them that it's safe to use without proxying 3. This won't break existing use cases are this is opt-in only","closed","type: task,","bclozel","2019-05-20T19:35:27Z","2019-05-28T17:13:27Z"
"","22911","Replace signal materialization in TransactionAspectSupport with usingWhen","We now use `Flux.usingWhen()` instead materialize/dematerialize operators to reuse Reactor's resource closure.  Until `usingWhen()` accepts a BiFunction to consume error signals, we need to map error signals outside of `usingWhen` which requires re-wrapping of the ReactiveTransaction object.  Also, reuse the current `TransactionContext` to leave Transaction creation/propagation entirely to ReactiveTransactionManager instead of creating new TransactionContexts.","closed","type: enhancement,","mp911de","2019-05-07T09:11:08Z","2019-05-07T09:35:53Z"
"","23345","Introduce interface cache for proxied EntityManager and Query types","We now reuse interfaces for `EntityManager` and `Query` classes that are proxied through `ExtendedEntityManagerCreator` and `SharedEntityManagerCreator`.  These caches prevent excessive object allocations through `ClassUtils.getAllInterfacesForClass(…)` and `ClassUtils.getAllInterfacesForClassAsSet(…)`.  Example benchmark:  ```java @State(Scope.Benchmark) @Fork(value = 1) public class EmBenchmark {  	EntityManager em;  	@Setup 	public void prepare() {  		EntityManagerFactory emf = …; 		em = SharedEntityManagerCreator.createSharedEntityManager(emf, null); 	}  	@Benchmark 	public void measure(Blackhole voodoo) { 		voodoo.consume(em.createQuery(""SELECT p FROM Person p"")); 	} } ```  Measurement:  ``` Before: Benchmark                Mode  Cnt       Score        Error  Units EmBenchmark.measureJpa  thrpt    5  650483,423  ± 29876,924  ops/s  After: Benchmark                Mode  Cnt       Score        Error  Units EmBenchmark.measureJpa  thrpt    5  734358,219  ± 74288,478  ops/s ```","closed","type: enhancement,","mp911de","2019-07-23T13:53:37Z","2019-08-01T16:48:10Z"
"","22918","Fix suspend/resume in AbstractReactiveTransactionManager","We now correctly unwrap suspended resources instead of capturing the `Mono` emitting suspended resources.  We also properly continue resume by chaining resume Mono's instead of terminating eagerly.","closed","type: bug,","mp911de","2019-05-07T13:44:25Z","2019-05-07T15:24:05Z"
"","23665","Upgrade to Reactor Dysprosium GA","We need to upgrade to the GA version once it's released.","closed","type: dependency-upgrade,","bclozel","2019-09-18T19:35:35Z","2019-09-26T09:24:46Z"
"","22878","Review usage of collectList with DataBuffers","We have to make sure that, when using collectList on a `Flux`, we add a `doOnDiscard` hook for the `List` as well as data buffers.","closed","","poutsma","2019-05-03T09:39:09Z","2019-05-06T18:49:04Z"
"","23065","Allow for alternative JdbcOperations implementations","We have our own implementation of `JdbcOperations` that offer logging and tracing functionality. Unfortunately some JDBC support classes require `JdbcTemplate` instead of `JdbcOperations`.  This is similar to #8440 and I exclude `JdbcDaoSupport` for that reason.","closed","status: superseded,","marschall","2019-05-30T20:35:14Z","2020-07-19T15:30:10Z"
"","23514","Provide a method to get the original bean name from a scoped target's bean name","We have a case in Spring Boot's `@SpyBean` support where we need to get the original bean name from a scoped target. `ScopedProxyUtils` provides a method to go from the original to the scoped target name but not the other way around. Could such a method be added please?   For the time being, we'll probably do something like this:  ```java if (ScopedProxyUtils.isScopedTarget(beanName)) { 	beanName = beanName.substring(""scopedTarget."".length()); } ```","closed","type: enhancement,","wilkinsona","2019-08-23T17:05:34Z","2019-08-27T14:03:50Z"
"","23348","Support escape chars in PropertyPlaceholderHelper","We have [a Spring Boot pull request](https://github.com/spring-projects/spring-boot/pull/17530) open that uses `PropertyPlaceholderHelper` to resolve `{variable}`  items in a message source. We'd like to also support escaping so that user can write `\{notreplaced}` to bypass expansion.","closed","status: declined,","philwebb","2019-07-24T11:05:54Z","2021-04-23T16:46:13Z"
"","23267","Avoid unnecessary boxing where primitives can be used","We don't need to box primitives with `valueOf` when `parseXxx` can be used.","closed","type: task,","stsypanov","2019-07-10T08:42:10Z","2019-07-16T17:27:46Z"
"","23390","Reactive Transaction commit asynchronously","We discover strange behavior when to come commit of reactive transaction. It seems that it is commit asynchronously after the Mono complete.   We have simple service to store and get users using Spring Data R2DBC. We have simple test: ``` var location = webTestClient   .post()   .uri(""/api/v1/users"")   .syncbody(....)   .exchange()   .getResponseHeaders()   .getLocation();  webTestClient.   .get()   .uri(location)   .exchange()   .expectStatus()   .isOk(); ```  This simple test randomly failed. We have be able to trace that transaction commit is done asynchronously. I would expect that transaction is committed before Rest call returns.  I think the problem is in `org.springframework.transaction.interceptor.TransactionAspectSupport.ReactiveTransactionSupport.invokeWithinTransaction(Method, Class, InvocationCallback)` implementation. Where `Mono.usingWhen` is using to execute commit when the underlying Mono complete. But according to documentation (and implementation) the `Function> asyncComplete` is subcribed asynchronously, not depending on the resource flow. Similar code is also in `org.springframework.transaction.reactive.TransactionalOperatorImpl`  Log from the test, showing that the transaction is commit after the Rest call ends.  ``` // WebTestClient.post - create user 2019-07-31 08:59:48.144 DEBUG [lift-users,44ad5717394fb955,44ad5717394fb955,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Creating new transaction with name [cz.my2n.lift.user.service.impl.UserServiceImpl.createUser]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2019-07-31 08:59:48.145 DEBUG [lift-users,44ad5717394fb955,44ad5717394fb955,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Acquired Connection [MonoLift] for R2DBC transaction // calling 3th party service via WebClient // saving user to DB 2019-07-31 08:59:48.190 DEBUG [lift-users,44ad5717394fb955,44ad5717394fb955,false] 9286 --- [or-http-epoll-1] o.s.d.r2dbc.core.DefaultDatabaseClient   : Executing SQL statement [INSERT INTO user (id, first_name, last_name, email, company_id, group_id, role) VALUES ($1, $2, $3, $4, $5, $6, $7)] // REST call ends // WebTestClient.get - get created user 2019-07-31 08:59:48.201 DEBUG [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Creating new transaction with name [cz.my2n.lift.user.service.impl.UserServiceImpl.getUserFromCompany]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2019-07-31 08:59:48.201 DEBUG [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Acquired Connection [MonoLift] for R2DBC transaction 2019-07-31 08:59:48.204 DEBUG [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] o.s.d.r2dbc.core.DefaultDatabaseClient   : Executing SQL statement [SELECT user.id, user.first_name, user.last_name, user.email, user.company_id, user.group_id, user.role FROM user WHERE user.id = $1 AND user.company_id = $2]  // this is commit of create user, see spanId  2019-07-31 08:59:48.210 DEBUG [lift-users,44ad5717394fb955,44ad5717394fb955,false] 9286 --- [or-http-epoll-1] o.s.d.r.c.R2dbcTransactionManager        : Initiating transaction commit 2019-07-31 08:59:48.210 DEBUG [lift-users,44ad5717394fb955,44ad5717394fb955,false] 9286 --- [or-http-epoll-1] o.s.d.r.c.R2dbcTransactionManager        : Committing R2DBC transaction on Connection [io.r2dbc.pool.PooledConnection@3c008990] 2019-07-31 08:59:48.211 DEBUG [lift-users,44ad5717394fb955,44ad5717394fb955,false] 9286 --- [or-http-epoll-1] o.s.d.r.c.R2dbcTransactionManager        : Releasing R2DBC Connection [io.r2dbc.pool.PooledConnection@3c008990] after transaction 2019-07-31 08:59:48.213 DEBUG [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Initiating transaction rollback // rolling back because we throw excpetion that is transalted to 404 error code 2019-07-31 08:59:48.214 DEBUG [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Rolling back R2DBC transaction on Connection [io.r2dbc.pool.PooledConnection@68212a18] 2019-07-31 08:59:48.215 DEBUG [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] o.s.d.r.c.R2dbcTransactionManager        : Releasing R2DBC Connection [io.r2dbc.pool.PooledConnection@68212a18] after transaction // Get user ends with error 2019-07-31 08:59:48.225  WARN [lift-users,4e4b65963c68693a,4e4b65963c68693a,false] 9286 --- [           main] c.m.l.u.c.a.AbstractExceptionHandler     : User with uuid 12e5ac53-2a97-4335-b793-2611a1c5671d not found in company d99c4a9d-d120-4e54-8d55-382c08159939 [UUID: 4e4b65963c68693a] ```  Spring 5.2.0.M2 Spring Boot 5.2.0.M2 Spring Data R2DBC  1.0.0.M2","closed","status: invalid,","Delorien84","2019-07-31T07:25:26Z","2019-11-05T13:48:22Z"
"","22810","Reduce unnecessary memory waste in PostProcessorRegistrationDelegate's registerBeanPostProcessors()","We can delete list orderedPostProcessorNames AND nonOrderedPostProcessorNames which are unnecessary here, cause we can put these operations into the same for loop, both lists waste time and space, and make the code hard to understand.","closed","in: core,","hecenjie","2019-04-17T05:56:33Z","2020-12-30T15:02:03Z"
"","23654","Failed to evaluate Jackson deserialization for type [[simple type, class void]]","Warning log is as follows: WARN o.s.h.c.json.MappingJackson2HttpMessageConverter - Failed to evaluate Jackson deserialization for type [[simple type, class void]] com.fasterxml.jackson.databind.JsonMappingException: Internal error: can't find deserializer for void","closed","status: invalid,","jianhaifeng","2019-09-18T08:55:15Z","2020-04-01T19:30:34Z"
"","23363","WebFlux Client Hangs indefinitely on Mono.block()","Versions: org.springframework.boot:spring-boot-starter:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-actuator:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-data-mongodb:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-data-jpa:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-log4j2:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-web:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-webflux:2.1.1.RELEASE org.springframework.boot:spring-boot-starter-test:2.1.1.RELEASE org.springframework.cloud:spring-cloud-starter-sleuth:2.1.1.RELEASE org.springframework.security:spring-security-test:5.1.2.RELEASE  So I am having a very strange issue where Mono.block() hangs indefinitely and it only seems to occur when spring-boot-start-actuator is included as a dependency **and** the service being called returns an error status.  Not sure what the relation is or if I am doing something wrong.  Below is the code being used: `Mono aMono = webClient.get().uri().retrieve().bodyToMono(A.class).cache()` `aMono.subscribe()` `aMono.block()`  If if the service returns a successful response, the aMono.block() returns without issue. If spring-boot-starter-actuator:2.1.1.RELEASE dependency is removed, aMono.block() returns without issues for successful and errors responses. Below is where the thread hangs:  > http-nio-8080-exec-1"" #42 daemon prio=5 os_prio=0 tid=0x0000000035c5c800 nid=0x4bb4 waiting on condition [0x000000003e679000]    java.lang.Thread.State: WAITING (parking)         at sun.misc.Unsafe.park(Native Method)         - parking to wait for  <0x000000076ec549d0> (a java.util.concurrent.CountDownLatch$Sync)         at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)         at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)         at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)         at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)         at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)         at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:81)         at reactor.core.publisher.Mono.block(Mono.java:1493 .. ..        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)         at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)         at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)         at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490)         at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)         at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)         at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)         at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)         at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408)         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:791)         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1417)         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)         - locked <0x000000075bd66538> (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)         at java.lang.Thread.run(Thread.java:748)    Locked ownable synchronizers:         - <0x000000075769f570> (a java.util.concurrent.ThreadPoolExecutor$Worker)","closed","status: invalid,","bfrisoni","2019-07-26T02:33:53Z","2020-12-02T20:28:38Z"
"","23440","Method-level @RequestMapping is inconsistent regarding trailing slashes with request params","Version: Spring Boot v2.1.6.RELEASE  A class-level `@RequestMapping` paired with a method-level `@RequestMapping` with `value=""""` and `@RequestParam` requires a trailing slash in the URI; whereas, any other string works as expected. Removing the `value` attribute also works as expected.  For example in the following:  ```Java @RestController @RequestMapping(""/foo"") public class controller {     @GetMapping("""")     public String bar1(@RequestParam String bazz) {         return ""this doesn't work"";     }      @GetMapping(""/test"")      public String bar2(@RequestParam String bazz) {         return ""but this does work"";      } } ```  A request such as ``/foo?bazz=x`` will not match, requiring `/foo/?bazz=x`; however, `/foo/test?bazz=x` will.  This seems like an inconsistency.  Replacing `@GetMapping("""")` with `@GetMapping` works correctly.","closed","in: web,","AdamBeddoe","2019-08-09T13:50:46Z","2019-09-04T12:35:23Z"
"","23791","Jackson2Decoder fails to determine correct target type from default interface method with a generic type","version: `5.2.0-RELEASE`  https://github.com/spring-projects/spring-framework/blob/d1aee0e8691c41753621332ff69b17be3f7c8ba2/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java#L132   ![image](https://user-images.githubusercontent.com/7791838/66743729-22140100-eead-11e9-8695-3ceaac691bd1.png)   ![image](https://user-images.githubusercontent.com/7791838/66743709-16c0d580-eead-11e9-8d84-2ef181326ede.png)","closed","type: enhancement,","zhou-hao","2019-10-14T10:06:44Z","2020-01-23T12:48:10Z"
"","23821","Server sent events (SSE) endpoint causing HttpMediaTypeNotAcceptableException","Using Spring Boot version 2.2.0 RC1 we get error org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation when trying to use endpoint that returns SseEmitter  Using Spring Boot version 2.1.9.RELEASE same endpoint works as expected.  Sample project to reproduce  https://github.com/jukkasi/spring-boot-sse","closed","type: regression,","jukkasi","2019-10-16T14:14:27Z","2019-12-19T18:24:55Z"
"","23293","spring boot 2.1.5.REALSE  build war ,run in tomcat with xsd:schema  error","Using Spring Boot 2.1.5.RELEASE, then build a app.war, finally running in tomcat.  With tomcat, I have modified the default configuration in conf/catalina.properties `org.apache.catalina.STRICT_SERVLET_COMPLIANCE=true`; the default is `false`; its affects, you can find in this web [address](https://tomcat.apache.org/tomcat-7.0-doc/config/systemprops.html) ;  Tomcat run with error:  ![image](https://user-images.githubusercontent.com/12171262/61266861-4be35c00-a7c8-11e9-9310-272bfbe117fc.png)  According the error, I find the URI in `org.springframework:spring-webmvc:5.1.7.RELEASE/META-INF/spring-form.tld`  ![image](https://user-images.githubusercontent.com/12171262/61267032-bac0b500-a7c8-11e9-894a-1c5f0aa620d1.png)   It is `https`, but not `http`?  But in `servlet-api.jar` it's `http` ...   ![image](https://user-images.githubusercontent.com/12171262/61267103-05423180-a7c9-11e9-9501-b97b5b229ad0.png)  So , I want to know  it's a bug  or am I wrong !  Thank You !!!","closed","in: web,","huang7230468","2019-07-16T04:58:09Z","2021-01-08T13:24:07Z"
"","23088","Netty4ClientHttpRequest waiting forever for SettableListenableFuture$SettableTask","Using Spring 4.3.12.RELEASE (provided by Spring Boot 1.5.18), I came across an issue that after heavy network instabilities, instead of timing out after some time (triggering my retry behaviour), my threads would all get stuck indefinitely with the following thread dump:  ``` ""pool-128-thread-5"" #34046 prio=5 os_prio=0 tid=0x00007fe37c3cf590 nid=0x13cd waiting on condition [0x00007fe3458cd000]    java.lang.Thread.State: WAITING (parking) 	at sun.misc.Unsafe.park(Native Method) 	- parking to wait for  <0x00000000ac08fd30> (a org.springframework.util.concurrent.SettableListenableFuture$SettableTask) 	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) 	at java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429) 	at java.util.concurrent.FutureTask.get(FutureTask.java:191) 	at org.springframework.util.concurrent.SettableListenableFuture.get(SettableListenableFuture.java:112) 	at org.springframework.http.client.Netty4ClientHttpRequest.execute(Netty4ClientHttpRequest.java:86) 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:660) 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:636) 	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:610)         [...] ```  I am using the `Netty4ClientHttpRequestFactory` (together with Netty 4.1.36.Final) for my `RestTemplate`:  ``` 	@Bean 	public RestTemplate restTemplate() throws SSLException {  		final SslContext context = SslContextBuilder.forClient() 			.trustManager(InsecureTrustManagerFactory.INSTANCE) 			.build();  		final Netty4ClientHttpRequestFactory factory = new Netty4ClientHttpRequestFactory(); 		factory.setConnectTimeout(CONNECT_TIMEOUT_MILLIS); // Value is > 0 		factory.setReadTimeout(READ_TIMEOUT_MILLIS); // Value is > 0 		factory.setSslContext(context); 		return new RestTemplate(factory); 	} ```  Any thoughts on this?","closed","status: invalid,","markusa380","2019-06-05T14:22:07Z","2022-02-18T21:06:54Z"
"","23290","Fix the bug for method mergeProperties().","Using CollectionFactory.createStringAdaptingProperties() instead of new Properties().Using method getProperty() will get null after mergeProperties() when the value is non-string type, .","open","status: feedback-provided,","LiuMenghan","2019-07-14T12:56:26Z","2021-04-27T05:06:10Z"
"","23131","DefaultMultipartMessageReader.FilePartPart.content not available under Reactor Netty","Using `DefaultMultipartMessageReader` to parse file parts and subsequently posting the part `contents()` to another endpoint with the `WebClient` results in an `IllegalReferenceCountException`.","closed","type: bug,","poutsma","2019-06-13T12:49:03Z","2019-06-21T09:22:35Z"
"","23098","Simplify comparison of primitives","Use utility method `compare()` to compare numbers.","closed","type: task,","stsypanov","2019-06-07T12:42:45Z","2019-06-08T15:06:17Z"
"","23316","Use Kotlin BOM","Use Kotlin BOM to manage Kotlin dependency versions.","closed","type: task,","sdeleuze","2019-07-19T08:43:46Z","2019-07-19T08:45:34Z"
"","23326","Upgrade to Coroutines 1.3.0-RC","Uprade to Coroutines 1.3.0-RC, use the new Coroutines BOM and refine Coroutines detection in `ReactiveAdapterRegistry`.","closed","type: task,","sdeleuze","2019-07-21T09:12:56Z","2019-07-21T09:29:47Z"
"","23182","Merge pull request #1 from spring-projects/master","update from origin","closed","","terryrao","2019-06-24T01:44:40Z","2022-02-18T19:10:16Z"
"","23012","Ensure access to configured mime types in client-side RSocket requester or responder","Until https://github.com/rsocket/rsocket-java/pull/636, `RSocketFactory` supported only `Function` for client side responders, which meant they had no access to the `MimeType` for the connection unless they were a) anonymous (or otherwise session scoped), and b) the `MimeType` was passed to them.   In the latest snapshots `RSocketFactory` provides access to the `ConnectionSetupPayload` on the client side too via a `BiFunction`. We can now change `MessageHandlerAcceptor` to get the data `MimeType` for the connection regardless of where it's used (client or server).","closed","type: enhancement,","rstoyanchev","2019-05-21T17:58:23Z","2019-05-29T21:10:24Z"
"","23447","Simplify the code","Unnecessary 'null' check before 'instanceof' expression","closed","status: declined,","NB216ers","2019-08-10T20:31:54Z","2019-08-12T09:09:06Z"
"","23673","CGLIB enhanced bean class loses method annotations","Trying to find bean methods that have an annotation: ```   for (String beanName : applicationContext.getBeanDefinitionNames()) {             Object bean = applicationContext.getBean( beanName );             for (Method method : bean.getClass().getMethods()) {                     if (method.isAnnotationPresent( MyAnnotation.class )) {                     ................ ``` The expected bean method is not found because the bean class is enhanced and method annotations are missing. Class has name pattern: `package.ComponentClass$$EnhancerBySpringCGLIB$$2d05df3d`  --------------------- Spring boot 2.1.7.RELEASE","closed","status: invalid,","cdalexndr","2019-09-21T18:07:59Z","2019-09-23T11:03:44Z"
"","23798","Updates Tomcat to 9.0.27","Tomcat should be updated to version 9.0.27 as it cannot load a ssl key-store without exception.   See: [Stackoverflow Question](https://stackoverflow.com/questions/58189855/spring-boot-2-embed-tomcat-9-0-26-can-not-load-jks-file-stream-closed)  Affects all spring-framework 5.x versions.","closed","status: declined,","mgmeiner","2019-10-15T14:19:47Z","2019-10-21T07:39:42Z"
"","23761","Provide orNull extensions for WebFlux ServerRequest","To be consistent with the Servlet variant and allow idiomatic Kotlin API.","closed","type: enhancement,","sdeleuze","2019-10-05T12:52:29Z","2019-11-13T17:03:58Z"
"","23506","Use the 'io.freefair.aspectj' gradle plugin","This simplifies the ajc configuration by using the external `io.freefair.aspectj` gradle plugin.  This should be in line with the optimizations in https://github.com/spring-projects/spring-framework/issues/23282  The same plugin is already used by spring-security: https://github.com/spring-projects/spring-security/pull/7183","closed","type: task,","larsgrefer","2019-08-22T23:34:19Z","2019-08-23T08:57:51Z"
"","23700","Enable local build cache for buildSrc and main project","This pull request enables Gradle's local [build cache](https://docs.gradle.org/current/userguide/build_cache.html) for both `buildSrc` and the main project. Cacheable task output will be written to `~/.gradle/caches/build-cache-1/` from where it will be reused by subsequent clean builds when a task's inputs have not changed.  This change is the first step towards enabling remote caching which will allow task output produced on CI to be reused when building locally. Before that happens there are some [unwanted cache misses to be resolved](https://ge.spring.io/s/tpvnvnrjizipq/timeline?cacheableFilter=CACHEABLE&outcomeFilter=SUCCESS). This PR should address those in `:buildSrc` (`buildSrc` caching was not enabled for that build). https://github.com/freefair/gradle-plugins/issues/111 should help with those related to AspectJ and could be worked around locally. `:checkstyleNoHttp` will require some local changes. I'll follow up on these in separate PRs in due course.","closed","type: task,","wilkinsona","2019-09-25T11:08:26Z","2019-10-21T08:40:42Z"
"","23702","Improve exclusions of checkstyleNoHttp task","This pull request adds the following exclusions to the source of the `checkstyleNoHttp` task for each project in the build and for `buildSrc`:  - `bin/` directory (created by Eclipse Buildship) - `.settings/` directory (created by Eclipse) - `.classpath` file (created by Eclipse) - `.project` file (created by Eclipse)  An exclusion for the `build/` directory is also configured as the NoHttp plugin does not exclude it by default for `buildSrc`.","closed","type: task,","wilkinsona","2019-09-25T12:06:28Z","2019-09-25T13:29:20Z"
"","23297","Treat null path as non-matching pattern in AntPathMatcher","This PR supersedes gh-943.  I noticed that the MVC Test `redirectedUrl` matcher fails with a `NullPointerException` if there happens to be no ""Redirected URL"" on the response (the test should still fail, but with a proper assertion error).  One way to fix this would be to `assertNotNull` in the respective `MockMvcResultMatchers` method before calling the `AntPathMatcher`, but I thought it would be more appropriate to fix the underlying null-safety issues. You may disagree.","closed","type: enhancement,","rs017991","2019-07-16T13:09:04Z","2019-07-17T15:00:09Z"
"","23239","Rename PathPatternRouteMatcherTest to PathPatternRouteMatcherTests","This PR renames `PathPatternRouteMatcherTest` to `PathPatternRouteMatcherTests` to align its name with the names of the other test classes.","closed","type: task,","izeye","2019-07-04T21:30:54Z","2019-07-07T15:50:35Z"
"","23382","Remove duplicate assertion in matchWithNullPath()","This PR removes a duplicate assertion in `AntPathMatcherTests.matchWithNullPath()`.","closed","type: task,","izeye","2019-07-30T00:09:33Z","2019-07-30T07:42:17Z"
"","23191","Remove duplicate assertion in AnnotatedElementUtilsTests","This PR removes a duplicate assertion in `AnnotatedElementUtilsTests.nullableAnnotationTypeViaFindMergedAnnotation()`.","closed","type: task,","izeye","2019-06-25T00:13:57Z","2019-06-25T07:16:56Z"
"","23158","Polish YamlProcessorTests.flattenedMapIsSameAsPropertiesButOrdered()","This PR polishes `YamlProcessorTests.flattenedMapIsSameAsPropertiesButOrdered()` simply by replacing `List` with `List`.","closed","type: task,","izeye","2019-06-19T21:47:20Z","2019-06-20T06:43:36Z"
"","23145","Polish MappingMediaTypeFileExtensionResolver.addFileExtension()","This PR polishes `MappingMediaTypeFileExtensionResolver.addFileExtension()`.","closed","in: core,","izeye","2019-06-17T14:07:18Z","2019-06-18T07:17:29Z"
"","22926","Polish LinkedCaseInsensitiveMap","This PR polishes `LinkedCaseInsensitiveMap`.","closed","in: core,","izeye","2019-05-08T13:51:46Z","2019-05-08T22:22:26Z"
"","23685","Polish ImportOrderCheck Checkstyle rule","This PR polishes `ImportOrderCheck` Checkstyle rule.","closed","type: task,","izeye","2019-09-24T05:12:32Z","2019-09-24T12:28:37Z"
"","23013","Polish ImportAwareTests","This PR polishes `ImportAwareTests` by removing unused code.","closed","in: core,","izeye","2019-05-22T02:50:06Z","2019-05-24T21:27:10Z"
"","23780","Polish HttpWebHandlerAdapter.handleUnresolvedError()","This PR polishes `HttpWebHandlerAdapter.handleUnresolvedError()`.","closed","type: task,","izeye","2019-10-11T11:33:25Z","2019-10-24T22:26:59Z"
"","23162","Polish FormattingConversionServiceTests","This PR polishes `FormattingConversionServiceTests`.","closed","type: task,","izeye","2019-06-20T03:40:55Z","2019-06-20T06:53:19Z"
"","23265","Polish DisposableBeanAdapter","This PR polishes `DisposableBeanAdapter`.","closed","in: core,","izeye","2019-07-10T05:52:46Z","2021-12-01T04:15:30Z"
"","23813","Polish AbstractResource","This PR polishes `AbstractResource`.","closed","in: core,","izeye","2019-10-16T01:08:49Z","2021-11-30T13:38:05Z"
"","22909","MergedAnnotation meta-data support","This PR is primarily for #22884 but it also covers a few more issues. Since it's quite a large set of changes it feels better to have a PR that we can review, rather than just merging.  I've run a full Spring Framework and Spring Boot build locally with these changes applied without any obvious issues being found.","closed","type: enhancement,","philwebb","2019-05-06T23:40:31Z","2019-05-07T21:12:44Z"
"","23485","Fix ""array index out of bounds"" problem reported by LGTM.com","This PR is a follow-on to https://github.com/spring-projects/spring-framework/issues/23461.  Specifically the problem that this PR fixes is https://lgtm.com/projects/g/spring-projects/spring-framework/snapshot/fb09647cbd34d6a540dc6e9b7e86aa7bcbe8e223/files/spring-web/src/main/java/org/springframework/http/ContentDisposition.java#xcfd962975fb7b533:1.  Feedback and other thoughts are welcome!","closed","type: enhancement,","jbduncan","2019-08-19T18:20:36Z","2019-09-03T17:54:53Z"
"","23458","Use lambda expressions instead of anonymous classes in spring-aop tests","this PR for simplify some code","closed","in: core,","lijunyzzZ","2019-08-13T13:15:43Z","2019-08-28T15:56:10Z"
"","22998","Fix typo","This PR fixes typos.","closed","","izeye","2019-05-20T14:30:23Z","2022-02-18T19:10:11Z"
"","23682","Fix DataSize class according to ISO/IEC 80000","This PR fixes DataSize class according to ISO/IEC 8000 spec (see [Binary prefix](https://en.wikipedia.org/wiki/Binary_prefix))","closed","status: declined,","newzubakhin","2019-09-23T19:41:01Z","2022-05-25T18:13:55Z"
"","23681","Fix DataSize class according to ISO/IEC 80000","This PR fixes DataSize class according to ISO/IEC 8000 spec (see [Binary prefix](https://en.wikipedia.org/wiki/Binary_prefix))","closed","status: duplicate,","newzubakhin","2019-09-23T19:31:56Z","2019-09-24T06:19:44Z"
"","23719","Fix an assertion in a test","This PR fixes an assertion in the `AnnotationConfigApplicationContextTests.individualBeanWithFactoryBeanObjectTypeAsTargetTypeAndLazy()`.","closed","type: task,","izeye","2019-09-26T14:31:40Z","2019-09-26T14:37:42Z"
"","22917","Fix typo","This PR fixes a typo.","closed","","izeye","2019-05-07T12:21:30Z","2022-02-18T19:10:10Z"
"","22883","Use HttpHeaders constants where possible","This PR changes to use `HttpHeaders` constants where possible.","closed","","izeye","2019-05-04T00:50:19Z","2022-02-18T19:10:09Z"
"","23051","Fix Javadoc for HttpHeaders.setContentLanguage()","This PR changes `set()` to `addAll()` in Javadoc for `HttpHeaders.setContentLanguage()` as `set()` for the parameter types doesn't seem to exist and `addAll()` seems most suitable to the following description around available methods.","closed","in: web,","izeye","2019-05-29T06:54:49Z","2019-05-29T09:59:45Z"
"","22836","Add missing fail() calls in MockRestServiceServerTests","This PR adds missing `fail()` calls in `MockRestServiceServerTests`.","closed","type: task,","izeye","2019-04-25T08:56:17Z","2019-04-25T14:39:22Z"
"","23128","Add since for JettyClientHttpConnector change","This PR adds Javadoc since info for constructor change on `JettyClientHttpConnector`.","closed","in: web,","izeye","2019-06-13T09:47:21Z","2019-06-14T20:54:00Z"
"","23519","Add @since for getCacheFilter and setCacheFilter","This PR adds Javadoc `@since` tags for `getCacheFilter()` and `setCacheFilter()` in `AbstractCachingViewResolver`.","closed","type: documentation,","izeye","2019-08-26T12:36:48Z","2019-08-26T13:52:36Z"
"","23353","Add Javadoc since for Jaxb2XmlDecoder(MimeType...)","This PR adds Javadoc `@since` tag for the `Jaxb2XmlDecoder(MimeType...)` constructor.","closed","type: documentation,","izeye","2019-07-25T02:14:25Z","2019-07-25T06:44:48Z"
"","23364","Add since tag for ClientResponse.Builder.request()","This PR adds Javadoc `@since` tag for `ClientResponse.Builder.request()`.","closed","type: documentation,","izeye","2019-07-26T06:03:29Z","2019-07-26T09:22:53Z"
"","23042","Add constants for application/cbor to MediaType","This PR adds constants for `application/cbor` to `MediaType` and changes to use them where possible.","closed","type: enhancement,","izeye","2019-05-28T02:25:22Z","2019-05-28T17:06:32Z"
"","22953","Add a missing single quote in assertion message","This PR adds a missing single quote in assertion message.","closed","type: task,","izeye","2019-05-13T09:59:01Z","2019-05-13T10:06:14Z"
"","23703","Upgrade to io.freefair.aspectj 4.1.1","This new version of the plugin addresses one of the caching problems described in https://github.com/spring-projects/spring-framework/pull/23700#issue-321189415.","closed","type: task,","wilkinsona","2019-09-25T13:53:51Z","2019-09-25T14:09:51Z"
"","23621","Reserved query parameter characters ampersand and equals sign aren't encoded as expected.","This looks like a bug.  ```java   @Test   public void ampersandGetEncoded() {     String paramValue = ""&"";      URI uri = UriComponentsBuilder.fromUriString("""").queryParam(""test"", paramValue).build().toUri();      assertEquals(""?test=%26"", uri.toString());   }    @Test   public void equalsSignGetEncoded() {     String paramValue = ""="";      URI uri = UriComponentsBuilder.fromUriString("""").queryParam(""test"", paramValue).build().toUri();      assertEquals(""?test=%3D"", uri.toString());   }    @Test   public void hashSignGetEncoded() {     String paramValue = ""#"";      URI uri = UriComponentsBuilder.fromUriString("""").queryParam(""test"", paramValue).build().toUri();      assertEquals(""?test=%23"", uri.toString());   } ```  Test 1 fails: Expected :?test=%26 Actual   :?test=&  Test 2 fails: Expected :?test=%3D Actual   :?test==  Test 3 passes.  I expected the query parameter would encode these characters since they can be used to break out of a value into a new parameter, e.g. if `key=test` and `value=foo&bar=x`, the final value should be `?test=foo%26bar%3Dx` not `?foo&bar=x`","closed","status: invalid,","andrewe123","2019-09-11T11:17:58Z","2019-09-11T14:23:05Z"
"","23151","Forbid null HttpMessageConverter in RestTemplate and HttpMessageConverterExtractor","This issue supersedes #23123 and #23140 with the intention of forbidding `null` `HttpMessageConverter` references supplied directly to `RestTemplate` and `HttpMessageConverterExtractor`.  Note, however, that we will not seek to prevent users from inserting `null` values into the list returned by `RestTemplate#getMessageConverters()`. If a user modifies the list returned by `getMessageConverters()` so that it contains `null` values, that will still lead to a `NullPointerException` when the converters are accessed.  See https://github.com/spring-projects/spring-framework/pull/23140#issuecomment-502757494 for further details.","closed","type: enhancement,","sbrannen","2019-06-18T11:53:00Z","2019-06-18T13:20:58Z"
"","23475","Migrate to AssertJ in Kotlin tests","This issue picks up where gh-23022 and gh-23451 left off.","closed","type: task,","sbrannen","2019-08-17T10:13:05Z","2019-09-02T14:04:43Z"
"","22899","Refine WebFlux Kotlin extensions","This issue bring following changes to WebFlux Kotlin extensions.  `ServerRequest`: - `awaitPrincipalOrNull` is renamed to `awaitPrincipal` since there is no non-nullable variant  `ServerResponse`: - new `BodyBuilder.sse()` extension - `BodyBuilder.bodyToServerSentEvents` is deprecated in favor of `sse().body()` - `BodyBuilder.bodyAndAwait(flow: Flow)` is renamed to `bodyFlowAndAwait` to avoid shadowing of `BodyBuilder.bodyAndAwait(body: Any)` - `BodyBuilder.bodyToServerSentEventsAndAwait` is removed, `sse().bodyAndAwait()` should be used instead","closed","in: web,","sdeleuze","2019-05-06T08:57:55Z","2019-05-06T09:45:35Z"
"","23759","Add option to log HTTP method to AbstractRequestLoggingFilter","This is the same as #18818, except that it concerns the HTTP method instead of the headers.  `AbstractRequestLoggingFilter` has options to include various parts of the request, including the URL, request headers, and the payload. It would be nice if it also had a standard option to log the HTTP method.  I imagine it could be something like `AbstractRequestLoggingFilter.setIncludeHttpMethod()`.  The rationale here is that sometimes it is helpful or necessary to know what the request headers were in order to troubleshoot an issue.  I recently came across such an issue where the client was troubleshooting an issue where it eventually turned out that they were making the request with the wrong HTTP method.  It was still technically a valid request returning `200 OK`, so they didn't initially notice that call was incorrect.  A workaround is to override the `createMessage` method to append the header information:  ``` @Bean public Filter logFilter() {     CommonsRequestLoggingFilter filter = new CommonsRequestLoggingFilter() {         @Override         protected String createMessage(HttpServletRequest request, String prefix, String suffix) {             return super.createMessage(request, prefix, "";method="" + request.getMethod() + suffix);         }     };     return filter; } ```  Note though that since the name of the logger that is used is based on the name of the class, the logging configuration has to be set to log the new subclass to DEBUG, not e.g. `CommonsRequestLoggingFilter`.","closed","status: duplicate,","mjustin","2019-10-04T19:49:25Z","2019-10-07T16:59:17Z"
"","22961","Support for direct path lookups in WebFlux","This is something Spring MVC already does but WebFlux does not. It maintains a lookup by path for mappings that don't have any pattern syntax. For a given request path, if the lookup contains a match then we don't need to check all patterns.","closed","type: enhancement,","rstoyanchev","2019-05-13T15:23:29Z","2020-07-09T12:44:31Z"
"","23094","Provide mechanism to map request parameters to fields of DTO object","This is more of a feature request:  If I have a bunch of request parameters in my service method, I would like all of them to be grouped in a DTO object. For instance, if I have a following method: ```java @GetMaping public ResponseEntity listEntities(         @RequestParam(value = ""page-number"", defaultValue = ""0"") @Min(0) Integer pageNumber,         @RequestParam(value = ""page-size"", defaultValue = ""100"") @Min(1) Integer pageSize, ... ) ```  Disregard the names of the parameters. What is important here, that there could be plenty of those and some of them might be mutually exclusive. Since they might be mutually exclusive, I would like to validate the state of so-called `RequestParamsDTO`. Ideally, I would like to create a custom validator (using hibernate validator) and then annotate the argument of type `RequestParamsDTO` with the proper validation annotation.  I know that there is a mechanism that even without the `@RequestParam` annotation spring will make its best to match arguments to the properties of a bean, in this case, `RequestParamsDTO` object.  But the problem lays in the naming of my request parameters: some of them have dashes in the name, like `page-number`. I cannot create a field in my `RequestParamsDTO` with that name for the obvious reasons.  And it seems there is no mechanism to map those request parameters to the fields of the DTO.   It would be nice to have a mapping mechanism for such case or allow `@RequestParam` annotation on class fields.","closed","status: superseded,","imochurad","2019-06-06T19:55:32Z","2019-12-09T12:50:09Z"
"","23035","Should it add a another way to get the bean [jmsListenerContainerFactory] ?","This is a proposition of enhancement. In spring 5, it seems that the bean [jmsListenerContainerFactory], referring to asynchronous message handling, can **only** be registered in Configuration class successfully when specify the bean's name as ""jmsListenerContainerFactory"". If we use other bean name, then we will have an initialization error.  for example, if we use the following way to register bean, it won't work.  ` @Configuration @EnableJms public class conf { 	 	@Bean 	public DefaultJmsListenerContainerFactory getListenerContainerFactory() {  		DefaultJmsListenerContainerFactory factory=new DefaultJmsListenerContainerFactory(); 		factory.setConnectionFactory(getMQfactory()); 		return factory; 	} } `  It means this bean has to be registered with a proper bean name.  But generally, like any other customized beans,  Lots of them can be accessed without specifying a bean name as long as the object type information is correct.  I think an additional way to access this bean should be enhanced. Because the error mentioned above is quite difficult to locate, especially for those who are used to access bean by  `getBean(Class clazz)`  rather than `getBean(String beanName)`","closed","status: invalid,","MaxNgai","2019-05-26T15:12:31Z","2019-05-27T14:28:40Z"
"","23282","Reorganize Gradle build","This is a much needed follow up issue for #20440.  Currently the Spring Framework build is mixing scripts, conventions and dependency information in `.gradle` files, some of them externalized in a gradle folder. The goal of this issue is to refactor the current build to scripts and conventions into build plugins. Each project/subproject should then selectively apply those plugins and only describe the specific dependencies in their build file.  Since our last efforts, Gradle had significant improvements and lots of new features that could be useful to Spring Framework.  Here is the list of the tasks for this issue:  - [x] Rewrite the ""test source sets"" plugin from Groovy to Java - [x] Do not use the propdeps plugin and replace `provided`/`optional` with `compileOnly` and a custom `optional` configuration (see #23234) - [x] Do not publish optional/provided dependencies in published POMs - [x] Move the Java compilation configuration to a convention. The Kotlin one is short and comes with the Kotlin plugin declaration, so we're letting that part in the main build file for now. - [x] Remove Gradle wrapper customization as script and move it to gradle.properties if necessary - [x] Move the JDiff to a separate plugin and use Japicmp instead - [x] Move integration tests to a separate module - [x] Reorganize tasks and scripts to selectively apply them to one of: root project, framework module, internal module (BOM, coroutines, integration-tests) - [x] Download the ""spring-docs-resources"" zip as an URL and do not resolve it as a dependency (see #23124) - [x] Use `""spring-*""` as a project name only for Spring Framework published modules. Rename internal modules accordingly (""spring-framework-bom"", ""spring-core-coroutines""...) - [x] Use Gradle Platform features for publishing the Spring Framework BOM - [x] Use the standard Gradle ""Maven Publish plugin"" - [x] Apply and configure the artifactory publish plugin directly (instead of delegating that to the CI server). This allows us to really control which artifacts are published, without workarounds.","closed","type: task,","bclozel","2019-07-12T12:39:12Z","2019-08-30T12:31:19Z"
"","23434","Please publish PGP signing keys publicly","This is a follow-up to issue gh-20182.  Could Spring please publish the **public** PGP keys used to create artifact signatures so that they are available via https download from an official Spring site?  That way users have a way to reliably verify the authenticity of downloaded artifacts.","open","status: waiting-for-triage,","EricPetersonIBKR","2019-08-08T15:08:35Z","2020-11-13T17:51:23Z"
"","23133","Document WebFlux FreeMarker macro support in Reference Manual","This is a follow up to gh-23002.","closed","in: web,","sbrannen","2019-06-13T14:37:17Z","2019-06-13T14:41:55Z"
"","23644","LinkedCaseInsensitiveMap does not track removals via keySet, entrySet, or values","This is a backport of #22821","closed","type: backport,","sbrannen","2019-09-16T10:00:11Z","2019-09-16T10:52:03Z"
"","23141","Support target type in MockMvcResultMatchers.jsonPath()","This introduces an helper method to specify a type to coerce into for MockMvcResultMatchers. New signature: MockMvcResultMatchers#jsonPath(String, Class, Matcher)  Solves #23121  Signed-off-by: RustyTheClone <21066051+rustytheclone@users.noreply.github.com>","closed","type: enhancement,","fodil-a","2019-06-15T18:43:07Z","2019-06-18T16:06:59Z"
"","23628","Fix OkHttp3ClientHttpRequestFactory shutdown flow","This fix now triggers closing and removing all idle connections inside the connection pool used by OkHttpClient.  The problem was discovered after switching from Java 8 to Java 11 and consequently to HTTP/2.  The recommendation from OkHttp developer was a proper shutdown: https://github.com/square/okhttp/issues/5446  Problem can be reproduced with this snippet of code: https://github.com/alexey-anufriev/okhttpclient-shutdown-problem/commit/29abbda198dc2ad9aa2714141c0b17a573490d34#diff-70a5fa50b52c03a98de3a02c98de30a1","closed","type: enhancement,","alexey-anufriev","2019-09-12T13:27:42Z","2019-11-01T12:30:40Z"
"","22921","Extend MultipartBodyBuilder methods so they accept a filename parameter","This fix allows passing a filename to MultipartBodyBuilder methods and sets the proper value of the content disposition header based on it.  Closes gh-22616","closed","status: superseded,","koziolk","2019-05-07T20:11:10Z","2019-06-04T18:52:24Z"
"","23033","Enforce the use of BDDMockito","This commit modifies the existing Checkstyle rule for Mockito to enforce the use of BDDMockito for all interactions with the core Mockito APIs.  In addition, this commit migrates to consistent use of the MockitoRule for JUnit 4.","closed","status: superseded,","sbrannen","2019-05-25T12:12:08Z","2019-05-28T12:08:05Z"
"","23073","Improve FreeMarker tests in spring-webmvc and spring-context-support","This commit improve FreeMarkerConfigurerTests in spring-webmvc by testing against FreeMarkerConfigurer instead of FreeMarkerConfigurationFactoryBean and move FreeMarkerConfigurationFactoryBean tests to spring-context-support in org.springframework.ui.freemarker.FreeMarkerConfigurationFactoryBeanTests. Closes #23055","closed","type: task,","ielatif","2019-06-03T09:30:14Z","2019-06-09T20:49:42Z"
"","23441","Do not override BeanPostProcessor default methods unnecessarily","This commit also makes `InstantiationAwareBeanPostProcessorAdapter` somewhat obsolete.","closed","","sbrannen","2019-08-09T14:03:06Z","2019-08-10T12:44:27Z"
"","23432","JDK 11 HttpClient integration with WebClient","This a simple implementation of ClientHttpResponse that levrage JDK 11 HttpClient.  Closes gh-21014","closed","type: enhancement,","Julien-Eyraud","2019-08-07T19:04:23Z","2021-11-22T12:24:32Z"
"","23450","Fix data access documentation typo","There was missing 'p' letter","closed","type: documentation,","wyhasany","2019-08-12T06:54:44Z","2019-08-12T09:22:04Z"
"","23782","Fixing 22325 issue application listeners logic","There was an issue #22325 and @jhoeller has fixed it, but now I have the following problem: on the application startup there is a call of prepareRefresh(), so it works like that `this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);` `this.applicationListeners` is an empty collection. Then it's needed to refresh the Application Context, app provokes the refresh() at AbstractApplicationContext, then Spring calls prepareRefresh and then checks `this.earlyApplicationListeners == null,` but it's an empty LinkedHashSet, not null, it's zero size set, so then it comes to `this.applicationListeners.clear();` and all the listeners are removed, but they were created, so I'm loosing all of applicationListeners there. Application listeners collection was filled by CXF Servlet [code](https://github.com/apache/cxf/blob/ec4423437bd7d6b63e3464761394cfafb50cacfa/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/CXFServlet.java#L90)","open","in: core,","platonovr","2019-10-11T12:13:19Z","2021-11-11T09:40:13Z"
"","23779","Fixing 22325 issue application listeners logic","There was an issue #22325 and @jhoeller has fixed it, but now I have the following problem: on the application startup there is a call of prepareRefresh(), so it works like that `this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);` `this.applicationListeners` is an empty collection. Then it's needed to refresh the Application Context, app provokes the refresh() at AbstractApplicationContext, then Spring calls prepareRefresh and then checks `this.earlyApplicationListeners == null,` but it's an empty LinkedHashSet, not null, it's zero size set, so then it comes to `this.applicationListeners.clear();` and all the listeners are removed, but they were created, so I'm loosing all of applicationListeners there. Application listeners collection was filled by CXF Servlet [code](https://github.com/apache/cxf/blob/ec4423437bd7d6b63e3464761394cfafb50cacfa/rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/CXFServlet.java#L90)","closed","","platonovr","2019-10-11T09:44:29Z","2022-02-18T19:07:13Z"
"","23437","Fix typo in testing documentation","There was a simple typo 'bu' intead of 'by'","closed","type: task,","wyhasany","2019-08-08T20:43:37Z","2019-08-09T07:40:53Z"
"","23452","@EnableWebFlux Javadoc references nonexistent WebFluxConfigurer API","There is no configureMessageWriters method in WebFluxConfigurer,  but javadoc for EnableWebFlux annotation suggests use it.","closed","type: documentation,","niksergey","2019-08-12T14:48:20Z","2019-08-13T08:23:21Z"
"","23020","Fix code example for validation on functional endpoints","There is an error on code example provided. The validate function uses the `body` parameter instead of `person`, thus making the code invalid.","closed","type: documentation,","diegocastro","2019-05-23T18:28:59Z","2019-05-24T07:41:28Z"
"","23120","Provide a more optimized way to do flushing on WebFlux without nested publishers","There are some upcoming Reactor Netty changes that are coming on flushing behavior. `NettyOutbound#sendGroups` may be potentially removed (not sure yet) and `NettyOutbound#send` could be potentially usable by default for streaming use case. But we need to keep a consistent behavior across all engines, so not sure yet what we should do but this will require an update on Spring side. cc @smaldini @violetagg","open","type: enhancement,","sdeleuze","2019-06-12T14:10:20Z","2019-07-11T15:50:33Z"
"","23340","Use static final constants for common zero length arrays","There are a few places (most notably in `*Utils` classes) where we often return zero length arrays. It might be beneficial if instead of returning a new instance for each of these calls, we instead use a shared static final constant.","closed","in: core,","philwebb","2019-07-23T10:10:27Z","2019-07-31T10:23:29Z"
"","23812","SpEL cannot invoke Kotlin synthetic classes","The test-case to reproduce:  ````kotlin import assertk.assertThat import assertk.assertions.isEqualTo import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Value import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.test.context.junit.jupiter.SpringJUnitConfig  @SpringJUnitConfig class SpELFromKotlinTests {  	@Value(""#{kotlinSupplier.invoke()}"") 	private lateinit var testValue: String  	@Test 	fun `test SpEL with Kotlin`() { 		assertThat(this.testValue).isEqualTo(""test"") 	}  	@Configuration 	class Config {  		@Bean 		fun kotlinSupplier(): () -> String { 			return { ""test"" } 		}  	}  } ````  An exception:  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.**.SpELFromKotlinTests': Unsatisfied dependency expressed through field 'testValue'; nested exception is org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.expression.spel.SpelEvaluationException: EL1029E: A problem occurred when trying to execute method 'invoke' on object of type 'org.springframework.**.SpELFromKotlinTests$Config$kotlinSupplier$1': 'Problem invoking method: public abstract java.lang.Object kotlin.jvm.functions.Function0.invoke()'  	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:116) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:397) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1429) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireBeanProperties(AbstractAutowireCapableBeanFactory.java:393) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:119) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:244) 	at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:98) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$5(ClassBasedTestDescriptor.java:337) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.executeAndMaskThrowable(ClassBasedTestDescriptor.java:342) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$6(ClassBasedTestDescriptor.java:337) 	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) 	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) 	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382) 	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) 	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) 	at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743) 	at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742) 	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestInstancePostProcessors(ClassBasedTestDescriptor.java:336) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:259) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$2(ClassBasedTestDescriptor.java:252) 	at java.util.Optional.orElseGet(Optional.java:267) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$3(ClassBasedTestDescriptor.java:251) 	at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:29) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:106) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:105) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:69) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:107) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:107) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:75) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at java.util.ArrayList.forEach(ArrayList.java:1257) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229) 	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197) 	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.expression.spel.SpelEvaluationException: EL1029E: A problem occurred when trying to execute method 'invoke' on object of type 'org.springframework.**.SpELFromKotlinTests$Config$kotlinSupplier$1': 'Problem invoking method: public abstract java.lang.Object kotlin.jvm.functions.Function0.invoke()' 	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:164) 	at org.springframework.beans.factory.support.AbstractBeanFactory.evaluateBeanDefinitionString(AbstractBeanFactory.java:1566) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1231) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:636) 	... 66 more Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1029E: A problem occurred when trying to execute method 'invoke' on object of type 'org.springframework.**.SpELFromKotlinTests$Config$kotlinSupplier$1': 'Problem invoking method: public abstract java.lang.Object kotlin.jvm.functions.Function0.invoke()' 	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:146) 	at org.springframework.expression.spel.ast.MethodReference.access$000(MethodReference.java:55) 	at org.springframework.expression.spel.ast.MethodReference$MethodValueRef.getValue(MethodReference.java:386) 	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:267) 	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:161) 	... 70 more Caused by: org.springframework.expression.AccessException: Problem invoking method: public abstract java.lang.Object kotlin.jvm.functions.Function0.invoke() 	at org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:134) 	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:139) 	... 76 more Caused by: java.lang.UnsupportedOperationException: This class is an internal synthetic class generated by the Kotlin compiler, such as an anonymous class for a lambda, a SAM wrapper, a callable reference, etc. It's not a Kotlin class or interface, so the reflection library has no idea what declarations does it have. Please use Java reflection to inspect this class: class org.springframework.**.SpELFromKotlinTests$Config$kotlinSupplier$1 	at kotlin.reflect.jvm.internal.KClassImpl.reportUnresolvedClass(KClassImpl.kt:307) 	at kotlin.reflect.jvm.internal.KClassImpl.access$reportUnresolvedClass(KClassImpl.kt:43) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$descriptor$2.invoke(KClassImpl.kt:53) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$descriptor$2.invoke(KClassImpl.kt:44) 	at kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:92) 	at kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:31) 	at kotlin.reflect.jvm.internal.KClassImpl$Data.getDescriptor(KClassImpl.kt) 	at kotlin.reflect.jvm.internal.KClassImpl.getDescriptor(KClassImpl.kt:179) 	at kotlin.reflect.jvm.internal.KClassImpl.getMemberScope$kotlin_reflection(KClassImpl.kt:188) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$declaredNonStaticMembers$2.invoke(KClassImpl.kt:159) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$declaredNonStaticMembers$2.invoke(KClassImpl.kt:44) 	at kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:92) 	at kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:31) 	at kotlin.reflect.jvm.internal.KClassImpl$Data.getDeclaredNonStaticMembers(KClassImpl.kt) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$allNonStaticMembers$2.invoke(KClassImpl.kt:168) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$allNonStaticMembers$2.invoke(KClassImpl.kt:44) 	at kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:92) 	at kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:31) 	at kotlin.reflect.jvm.internal.KClassImpl$Data.getAllNonStaticMembers(KClassImpl.kt) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$allMembers$2.invoke(KClassImpl.kt:174) 	at kotlin.reflect.jvm.internal.KClassImpl$Data$allMembers$2.invoke(KClassImpl.kt:44) 	at kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:92) 	at kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:31) 	at kotlin.reflect.jvm.internal.KClassImpl$Data.getAllMembers(KClassImpl.kt) 	at kotlin.reflect.jvm.internal.KClassImpl.getMembers(KClassImpl.kt:192) 	at kotlin.reflect.full.KClasses.getFunctions(KClasses.kt:90) 	at kotlin.reflect.jvm.ReflectJvmMapping.getKotlinFunction(ReflectJvmMapping.kt:134) 	at org.springframework.core.MethodParameter$KotlinDelegate.getGenericReturnType(MethodParameter.java:909) 	at org.springframework.core.MethodParameter$KotlinDelegate.access$000(MethodParameter.java:865) 	at org.springframework.core.MethodParameter.getGenericParameterType(MethodParameter.java:509) 	at org.springframework.core.SerializableTypeWrapper$MethodParameterTypeProvider.getType(SerializableTypeWrapper.java:292) 	at org.springframework.core.SerializableTypeWrapper.forTypeProvider(SerializableTypeWrapper.java:107) 	at org.springframework.core.ResolvableType.forType(ResolvableType.java:1400) 	at org.springframework.core.ResolvableType.forMethodParameter(ResolvableType.java:1321) 	at org.springframework.core.ResolvableType.forMethodParameter(ResolvableType.java:1303) 	at org.springframework.core.ResolvableType.forMethodParameter(ResolvableType.java:1270) 	at org.springframework.core.convert.TypeDescriptor.(TypeDescriptor.java:82) 	at org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:131) 	... 77 more ```","closed","in: core,","artembilan","2019-10-15T18:16:16Z","2019-11-13T13:24:23Z"
"","23023","More flexible binding for enums","The standard enum binding basically accepts the name of the enums.  We have controller that accept enums as path variables, and it would be great if String was more tolerant, and accept lowercase and hyphens in enums.   So if we have:  ```java     enum CustomerType {TAXABLE, NON_TAXABLE}     @GetMapping(""/customers/{type}/{id}"") ```  we can access it with `/customers/non-taxable/3333` besides `/customers/NON_TAXABLE/3333`.  It is trivial to implement as a custom converter, so this is not really important. but I think it would be a nice default option  Thanks for your awesome work","closed","status: declined,","pablogrisafi1975","2019-05-24T01:33:19Z","2019-06-28T09:44:59Z"
"","23418","Fix spring-core generic type variable resolving for complex cases","The spring-core GenericTypeResolver does not resolve generic type variables correctly in more complex scenarios like renamed transitive type variables and partial specialization of classes.","open","in: core,","Syquel","2019-08-05T13:28:54Z","2021-11-11T09:52:31Z"
"","23428","Reference documentation for @Autowired's required attribute is misleading","The Spring Framework 5 reference [documentation for `@Autowired`](https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation) states: > The required attribute of `@Autowired` is recommended over the `@Required` annotation on setter methods. The required attribute indicates that the property is not required for autowiring purposes. The property is ignored if it cannot be autowired.  I think it should be ""`required=false` indicates that the property is not required..."".  Please update it if you think I am correct.","closed","type: documentation,","aCodeRancher","2019-08-07T14:39:34Z","2019-08-09T09:40:26Z"
"","23384","Add status code 425 (""Too Early"") to HttpStatus enum","The recent RFC 8470 (https://tools.ietf.org/html/rfc8470) defines a new status code 425 which we should expose on our `HttpStatus` enum.","closed","type: enhancement,","jhoeller","2019-07-30T11:37:03Z","2019-07-30T14:11:18Z"
"","22893","Misleading javadoc for  ServerRequest param and params method","The reactive version of `ServerRequest` has `queryParam` and `queryParams` methods, while the servlet version has `param` and `params` methods.   It is true that with a servlet container, a request parameter can come from the request body if the content-type is `application/x-www-form-urlencoded`.  However is the method names remains different, the javadoc for the `params` method ( _Get the first query parameter with the given name, if present._) should be updated since the parameter can also come from the request body if the content type is `application/x-www-form-urlencoded`. Javadoc could also reference the original methods in `HttpServletRequest` (`getParameter`, `getParameterMap`).","closed","type: task,","ah1508","2019-05-05T12:09:32Z","2019-05-07T13:29:20Z"
"","23248","Hibernate Query.list() is not included in SharedEntityManagerCreator.queryTerminatingMethods set, causing database connection not to be unreleased when query is proxied","The queryTerminatingMethods of the SharedEntityManagerCreator class does not contain the ""list"" method：  ![image-2019-07-06-14-41-13-148](https://user-images.githubusercontent.com/6783771/60795173-c810ea80-a19d-11e9-926e-aaad47551d97.png)   In the DeferredQueryInvocationHandler class, when the EntityManager is closed, it is determined whether the method name is in ""queryTerminatingMethods""：   ![image-2019-07-06-14-43-21-734](https://user-images.githubusercontent.com/6783771/60795195-d3fcac80-a19d-11e9-979e-f2696d9aa55e.png)     When org.hibernate.query.Query.list() is used, and QueryImpl and NativeQueryImpl are delegated by DeferredQueryInvocationHandler, the database connection is not released：  ![image-2019-07-06-14-56-26-274](https://user-images.githubusercontent.com/6783771/60795212-da8b2400-a19d-11e9-9caf-3da36905ae31.png)","closed","type: enhancement,","wcandml","2019-07-08T08:33:42Z","2019-07-17T21:37:37Z"
"","23766","change methods of ParsedSql to public","The ParsedSql could be used for JDBC customization","open","in: data,","siminture","2019-10-08T08:20:00Z","2021-11-10T11:38:07Z"
"","23691","Capture maxParallelForks of Test tasks in build scans","The parallel forks configuration of `Test` tasks can have a big impact on their execution time. This pull request updates the build scan configuration to capture each `Test` task's `maxParallelForks` configuration as custom values in the build scan. This will make this data available when comparing scans which will be useful as we experiment with different parallel fork settings to reduce the build's overall execution time.","closed","type: task,","wilkinsona","2019-09-24T15:59:29Z","2019-09-24T16:25:25Z"
"","23030","RestTemplateXhrTransport fails for a StreamingHttpOutputMessage type request","The org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport.XhrRequestCallback relies on the request.getBody() method, which is not supported if the request is an instance of StreamingHttpOutputMessage.  The result is that the request will fail in this case.   The request may be a StreamingHttpOutputMessage if the underlying request factory is configured as a streaming request in order to use chunked encoding.  To fix the issue the code should check whether the request is an instance of StreamingHttpOutputMessage and in this case use the StreamingHttpOutputMessage.setBody() method to write to the request body.","closed","type: enhancement,","jkranes","2019-05-24T15:20:06Z","2019-06-07T20:41:59Z"
"","23596","Infinite loop due to doFilterNestedErrorDispatch() method in OncePerRequestFilter","The new doFilterNestedErrorDispatch() method in OncePerRequestFilter in Spring 5.1.9, causes an infinite loop and stack overflow when dealing with an error dispatch.  Unless I'm misreading it, it seems this method is only provided as an extension point.  I am assuming the **following method should actually be invoking filterChain.doFilter()** and not the local doFilter() method:  ```java protected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     doFilter(request, response, filterChain); } ```  Stack trace illustration:  ``` Caused by: java.lang.StackOverflowError         at java.base/java.util.HashMap.hash(HashMap.java:339)         at java.base/java.util.HashMap.get(HashMap.java:552)         at org.apache.catalina.connector.Request.getAttribute(Request.java:866)         at org.apache.catalina.connector.RequestFacade.getAttribute(RequestFacade.java:282)         at org.apache.catalina.core.ApplicationHttpRequest.getAttribute(ApplicationHttpRequest.java:245)         at org.apache.catalina.core.ApplicationHttpRequest.getAttribute(ApplicationHttpRequest.java:245)         at org.springframework.web.context.request.async.WebAsyncUtils.getAsyncManager(WebAsyncUtils.java:48)         at org.springframework.web.filter.OncePerRequestFilter.isAsyncDispatch(OncePerRequestFilter.java:147)         at org.springframework.web.filter.OncePerRequestFilter.skipDispatch(OncePerRequestFilter.java:128)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:99)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)         at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250)","closed","type: regression,","hugolumsdon","2019-09-06T08:50:59Z","2019-09-12T21:13:47Z"
"","23639","RequestSpec.metadata(Consumer) not intuitive name","The name for `RSocketRequester` [RequestSpec.metadata(Consumer)](https://github.com/spring-projects/spring-framework/blob/957f0fac7a0dd1f0a7a5742fbeb8c40b7da439f0/spring-messaging/src/main/java/org/springframework/messaging/rsocket/RSocketRequester.java#L258) is not very intuitive since it can modify the entire `RequestSpec`. I wonder if we should modify the name or change the argument?","closed","status: superseded,","rwinch","2019-09-13T20:19:48Z","2019-09-20T10:11:34Z"
"","23811","Improve the performance of the method MethodParameter.getParameterType","The method ResolvableType.forMethodParameter can be unused in some cases. See #23792.","closed","","lgxbslgx","2019-10-15T18:08:03Z","2022-02-18T19:07:14Z"
"","23541","DispatcherServlet does not invoke triggerAfterCompletion with dispatch exception","The method `processDispatchResult` in `DispatcherServlet` receives an `exception` argument if some exception was thrown when invoking the handler, but the exception is not passed as an argument when invoking the `triggerAfterCompletion` method.  Thus a registered `HandlerInterceptor` cannot properly implement `org.springframework.web.servlet.HandlerInterceptor.afterCompletion(HttpServletRequest, HttpServletResponse, Object, Exception)` without knowing if some exception was thrown.","closed","status: invalid,","wq409813230","2019-08-29T03:55:51Z","2019-08-29T12:44:22Z"
"","22987","SimpleMessageListenerContainer - add possibility to disable manual recovery","The method _SimpleMessageListenerContainer#onException(JMSException)_  starts recovery process. In my opinion it should be configurable, because many JMS Providers can recover automatically, for example ActiveMQ.   This gest even more interesting - in our case we have observed dropped connections to JMS Listeners. After some debugging I've discovered, that ActiveMQ will throw JMS Exception in like 99% cases, but sometimes it's just not comming. The _SimpleMessageListenerContainer_ starts recovery, closes connection pool and relies of fact, that each not successful reconnection attempt will throw JMSException, but sometimes it does not.  So far we are using such workaround: ``` public static class ActiveMqMessageListenerContainer extends SimpleMessageListenerContainer {     @Override    public void onException(JMSException ex) {    } } ```  But I would prefer a possibility to disable manual Failover in _SimpleMessageListenerContainer_","closed","type: enhancement,","maciejmiklas","2019-05-17T12:02:27Z","2019-05-20T16:30:40Z"
"","23403","spring-webmvc-4.3.16.RELEASE: MediaType 'application/hal+json' is not included in '*/*' or 'application/*'","The Mediatype `application/hal+json` is not compatible with the Wildcard MediaType `*/*`  This will cause a `HttpMediaTypeNotAcceptableException` in `org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters` of the libary spring-webmvc-4.3.16.RELEASE when an error message with `application/hal+json` is written, even if the client accepts it.","closed","status: invalid,","Farix1337","2019-08-01T13:46:54Z","2019-08-12T09:23:07Z"
"","23651","Proposition: a restructuring of MailSender and JavaMailSender, with additional decorator","The mail sending API is structured around the two interfaces `MailSender` and `JavaMailSender`, together with the class `JavaMailSenderImpl` which implements the two aforementioned interfaces. The numerous overloads of `send(..)`-methods in the interfaces makes it a bit cumbersome and errorprone to extend these interfaces directly.  Default methods introduced with Java 8 can to a large degree resolve this issue by moving from JavaMailSenderImpl to default methods in the interfaces. For methods which is ""piping"" to another method of the public API, this is a trivial refactoring (a820753). But `JavaMailSenderImpl.send(SimpleMailMessage...)` can not be refactored in such a trivial manner, as this method delegates to the internal `doSend`-method of `JavaMailSenderImpl`. To rectify, this pull-request also contains a suggested change to allow passing SimpleMailMessages contained in SmartMimeMessages further down the method stack, and allow the `doSend` to resolve the original message instances in case of errors, so existing behaviour is preserved. (f95659b168d479db3711d64ff02f533f437d0418)  The interfaces are now simpler to extend directly, and this also allows for more clean composable decorators, as demonstrated with the new `JavaMailSenderDecorator` class in 39724cdb0150b3894b23276bb1f287bdccc35af8. It ""seals"" the default methods as `final`, allowing decorating an arbitrary JavaMailSender with only overriding _one_ method, which is part of the public API. It is simple to wrap several layers of JavaMailSenderDecorators, if one should need to, and eventually end in a JavaMailSenderImpl.  I have used this structure for a client to separately implement a whitelisting `JavaMailSenderDecorator`, and a performance monitoring ""aspect"" `JavaMailSenderDecorator`, which are composed together, and ultimately wrapping an instance of `JavaMailSenderImpl`.  This also may yield some advantages when testing, as one would only have to intercept the _one_ `send(..)`-method which is not provided by the interfaces, and tests does not need to know which overload is used by the main code. `JavaMailSenderImpl` instances can be separated strictly away from testing. For instance, if using mock libraries as Mockito, mocking a `JavaMailSenderDecorator`, it will ensure that all real `final` methods are invoked, and one may verify invocations of only one method regardless of which overloaded method is invoked by the main code.  I hope this can be a relevant contribution, and I am very open for any feedback and discussion on this design!   Thank you :)","open","in: core,","runeflobakk","2019-09-17T22:37:47Z","2021-11-11T09:43:55Z"
"","22925","DefaultCacheAwareContextLoaderDelegate should log which application context instance was stored or retrieved from cache","The log output in `DefaultCacheAwareContextLoaderDelegate.loadContext(…)` currently logs details about the cache key used to store or obtain an `ApplicationContext` instance, but not the object identifier of the context stored or obtained.  If you try to debug a caching issue, it would be helpful if the context identifier was logged as well so that you can find out at what point (or rather: by which test case) the instance retrieved was originally created.  I locally tweaked the log statements to:  ```java logger.debug(String.format(""Storing ApplicationContext %s in cache under key [%s]"", System.identityHashCode(context), mergedContextConfiguration)); ```","closed","type: enhancement,","odrotbohm","2019-05-08T12:26:15Z","2019-05-08T15:49:11Z"
"","22812","NullPointerException in Base64Utils.encodeToString","The JavaDoc says `@param src the original byte array (maybe {@code null})` but the implemetation  does not allow `null` -> `if (src.length == 0) {`. Either documentation or the implementation should be fixed.","closed","in: core,","latuszek","2019-04-17T12:56:25Z","2019-04-17T13:57:57Z"
"","22976","HttpHeaders#setContentLanguage javadoc refers to non-existing method","The javadoc on `HttpHeaders#setContentLanguage` appears to be referring to a non-existing vararg variant of `HttpHeaders#set`:  https://github.com/spring-projects/spring-framework/blob/e0654a5b3dcf55a7840cd29d25c55854a071202c/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L874-L883","closed","type: task,","vpavic","2019-05-14T20:40:53Z","2019-05-15T21:34:18Z"
"","23205","AbstractMessageConverterMethodProcessor results in 406 even when ResponseEntity presets content type","The fixes introduced in #20720 and #20798 added ability to return `ResponseEntity` with defined `ContentType` header. Like this:  ```     @GetMapping(""/test"")     public ResponseEntity test() {         return ResponseEntity.ok().contentType(MediaType.APPLICATION_XML).body(new MyModel());     } ```  `AbstractMessageConverterMethodProcessor` now takes into account provided `Content-Type` header and uses it instead of `Accept` header from request. So it just ignores `Accept` header. It is ok and good.  But in this case, when no `HttpMessageConverter` found that can write the response with selected `Content-Type`, then `AbstractMessageConverterMethodProcessor` throws `HttpMediaTypeNotAcceptableException`.  ``` 		if (body != null) { 			throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes); 		} ```  I think this is not right, because it leads to 406 response, like if no **acceptable** representation was found, while the real reason of this error is that no converter found for selected representation (and `Accept` header was ignored altogether). So, this clearly indicates a server misconfiguration (server tries to return a response using provided content type without registering proper `HttpMessageConverter`, that supports this content type with this response body type). So it should lead to error 500 and should throw `HttpMessageNotWritableException`.  It should do this only when `selectedMediaType` is selected based on `outputMessage.getHeaders().getContentType()` (the `Accept` header was not taken into account), of course. In other cases `HttpMediaTypeNotAcceptableException` is still good.  ### Affected version: Spring 5.1.8.RELEASE","closed","type: enhancement,","xak2000","2019-06-27T13:56:29Z","2019-07-13T10:07:19Z"
"","23210","SpEL ReflectivePropertyAccessor: ConversionService missing annotations on concrete implementations","The fix for https://github.com/spring-projects/spring-framework/issues/22242 is causing this.   Baiscally, the ReflectivePropertyAccessor is now looking for an interface for a method if it exists, and returning the interface method instead of the concrete one.  In doing this, if the implementer has an annotation(in my case DateTimeFormat) it gets ignored, as the TypedValue returned is now based solely on the interface.","closed","in: core,","laoseth","2019-06-28T16:26:49Z","2019-07-05T16:23:48Z"
"","23091","Side effect from ProducesRequestCondition cache with multiple RequestMappingHandlerMapping beans","The fix for #22644 introduces an optimization by storing the calculated accept headers in a request attribute for later lookups. If a `HandlerMapping` implementation decorates the request hoping that Accept headers would be looked up through that decorator, this fails as the cached values get used.  I suggest to reset the cache per `HandlerMapping` so that it's able to tweak thhe request early in the processing cycle but still benefit from the cache.","closed","type: enhancement,","odrotbohm","2019-06-05T20:35:41Z","2019-06-11T17:58:00Z"
"","23068","Fix duplicate invoke method of transformedBeanName","The first sentence of `doGetBean` method of `AbstractBeanFactory` class already invoke `transformedBeanName`method to convert `name` to `beanName` and `beanName` is passed as a parameter to the method of `getObjectForBeanInstance`. So, I think there is no necessary to twice invoke `transformedBeanName`.","closed","in: core,","chenqimiao","2019-05-31T07:37:39Z","2019-06-07T20:48:20Z"
"","23751","Add @EnableRSocket Configuration","The current recommendation to add a reactive messaging `HandlerMethodArgumentResolver` is to [add a preProcess hook](https://github.com/spring-projects/spring-boot/issues/18356#issuecomment-537604973).   Spring MVC provides `WebMvcConfigurer.addArgumentResolvers` which allows configuring `HandlerMethodArgumentResolver`. WebFlux provides `WebFluxConfigurer.configureArgumentResolvers` which allows configuring `HandlerMethodArgumentResolver`. These were provided, presumably, because there were enough people customizing them that Framework decided to provide a first class hook to modify it. I believe the same support should be added to reactive messaging.","closed","type: enhancement,","rwinch","2019-10-02T19:32:25Z","2020-09-14T14:14:52Z"
"","23048","Add copyright and authors list to reference manual","The copyright and authors list are both missing from the current versions of the Spring Framework reference manual.  https://docs.spring.io/spring/docs/5.2.0.M2/spring-framework-reference/  https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/","closed","status: superseded,","sbrannen","2019-05-28T15:00:17Z","2019-05-28T21:30:36Z"
"","23427","Confusion in contribution guidelines regarding PR vs Issue","The contribution guidelines and the default Issue template on GitHub are inconsistent and confusing in regard to whether to create a Pull Request and / or a GitHub Issue.  While the default template for new issues states > Issue or Pull Request? Create only one, not both.  the [CONTRIBUTING.md](https://github.com/spring-projects/spring-framework/blob/master/CONTRIBUTING.md#submit-a-pull-request) in the section ""Submit a Pull Request"" states > For all but the most trivial of contributions, please create a ticket.  It would be great to have that consistent, because I don't know if I should create an issue for my pending pull requests and rewrite my commits to include the ticket number or not.","closed","type: task,","Syquel","2019-08-07T11:19:55Z","2019-09-11T15:17:03Z"
"","23212","Generalize ServerResponse and WebClient body methods","The commit is a follow-up of d6b5c2005849e0676781ec1086bf8fc994e1a2c4 which applies the same principle to ServerResponse, WebClient.RequestBodySpec and WebTestClient.RequestBodySpec body methods.  It introduces a body(Object) method where the parameter can be:  - Concrete value  - Publisher of value(s)  - Any other producer of value(s) that can be adapted to a    Publisher via ReactiveAdapterRegistry  Variants with Class and ParameterizedTypeReference parameters are also provided and syncBody(Object) is deprecated.  With this change, in Kotlin it is now mandatory to specify explicitly the generic type (for example body>(body)) in order to invoke the ParameterizedTypeReference shortcut. If it is not specified, the extension is shadowed by the Java body(Object) method which is not able to use Kotlin type inference to resolve the generic type.","closed","","sdeleuze","2019-06-28T22:17:58Z","2021-04-28T09:57:28Z"
"","23720","i hava to ask the question that one class which is annotaed with @Configuration has a lot of methods that those have the same method name and were annotated with @Bean","the code is below:     @Bean(""test"")     @ConditionOnProperties(properties = ""user.age"")     public InnerClass test() {         return new InnerClass(""1"");     }      @Bean(""test2"")     public InnerClass test(@Qualifier(""test"") InnerClass innerClass) {         System.out.println(innerClass);         return new InnerClass(""2"");     }  Q: If the @ConditionOnProperties is effective that the bean named as ""test"" will be passed,the Other Bean named ""test2"" can be added into the Bean Container?  the question is tested when i saw the source code from the spring framework,and the source code is below: 		// Do we need to mark the bean as skipped by its condition? 		if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) { 			configClass.skippedBeanMethods.add(methodName); 			return; 		} 		if (configClass.skippedBeanMethods.contains(methodName)) { 			return; 		} that is in the ConfigurationClassBeanDefinitionReader class file,the concrete position is from 186 line to 193 line.","closed","for: stackoverflow,","535431135","2019-09-27T06:52:39Z","2019-09-27T08:26:27Z"
"","23063","Guard against ConcurrentModificationExceptions in the systemProperties PropertySource","The `StandardEnvironment` currently adds a `MapPropertySource` containing `System.getProperties()` to allow them to be used from the `Environment`. Since the underlying `Properties` can be changed in other threads, it's possible that calls to `propertySource.getPropertyNames()` will throw a `ConcurrentModificationException`.  This can be seen in [the following Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/17013). Although we can add guards in the Spring Boot code, It might be useful if these exceptions could be handled transparently by the property source.","closed","type: enhancement,","philwebb","2019-05-30T15:53:54Z","2019-06-20T22:56:24Z"
"","23819","Support Forwarded with fallback to X-Forwarded-Host","The `ForwardedHeaderFilter` supports already Forwarded headers as defined in: https://tools.ietf.org/html/rfc7239#section-5.2  **Improvement:**  Implement fallback to **X-Forwarded-Host** and **X-Forwarded-Port** header if `host` is not defined in **Forward** header.  **Background:** The **Forwarded** header can contain some or all of the parameters: `by, for, host, proto`. `ForwardedHeaderFilter` uses `UriComponentsBuilder` to adjust URI parts. The implementation in `UriComponentsBuilder#adaptFromForwardedHeaders` right now is not really symetric. First it checks if there is a **Forwarded** header, if yes it tries to take the parameters proto, host from this.   Only for `proto` there is a fallback implemented. Meaning that if proto is not found in **Forwarded** header, the **X-Forwarded-Ssl** is checked additionally. This is not done for `host`. So if there is a **Forwarded** header but if this does not contain host-parameter, host and port are not extracted at all.  Wouldn't it be better to also fallback to the **X-Forwarded-Host** and **X-Forwarded-Port** header if they exist?  **Scenario:** When using spring application behind a [fabio proxy](https://fabiolb.net/feature/http-headers/) this problem occurs.  The headers that fabio sets are:  `forwarded: ""for=100.93.64.162; proto=http; by=192.168.30.12; httpproto=http/1.1""`  `x-forwarded-host: ""10.65.250.31:9999""`  `host` is not defined in **Forwarded**, so the `host` is not extracted in current implementation.","closed","status: waiting-for-feedback,","hlang","2019-10-16T12:35:59Z","2021-01-08T13:09:14Z"
"","23260","Support for X-Forwarded-For and Forwarded for=""...""","The `ForwardedHeaderFilter` seems to ignore the `X-Forwarded-For` header and it's `Forwarded` complement: https://tools.ietf.org/html/rfc7239#section-5.2  As user of this filter, I would expect `X-Forwarded-For` or `Forwarded for=` to be handled and removed from the request. If there is a reason to not handle `X-Forwarded-For` this should be documented.","closed","status: superseded,","larsgrefer","2019-07-09T12:56:25Z","2019-11-20T14:40:36Z"
"","23748","EventPublishingTestExecutionListener is not included in JUnit 4 and TestNG base classes","The `EventPublishingTestExecutionListener` introduced in Spring Framework 5.2 is not registered automatically for the following base test classes.  - `AbstractJUnit4SpringContextTests` - `AbstractTransactionalJUnit4SpringContextTests` - `AbstractTestNGSpringContextTests` - `AbstractTransactionalTestNGSpringContextTests`","closed","type: enhancement,","sbrannen","2019-10-02T12:27:17Z","2019-12-02T12:40:39Z"
"","23177","ConnectionMapping annotation for handling of RSocket connection-level frames","The `ConnectionSetupPayload` at the start of on an RSocket connection is currently handled with a `@MessageMapping` method like any subsequent stream on the same connection. The client then must include a route in the metadata of the SETUP frame, or else the `ConnectionSetupPayload` would have to be handled with an empty mapping, which is not ideal and could also catch subsequent streams without a route. One could use a wildcard mapping but that makes it even more likely to match subsequent streams on the connection, likely not intentionally.  Furthermore, the handling of `ConnectionSetupPayload` is optional, so if there is no matching handler, no error is raised, unlike subsequent streams on the same connection for which an error is raised if there is no matching handler.  We should introduce a `ConnectionMapping` annotation for use with RSocket handlers that would be used to process connection-level frames, the initial SETUP and subsequent METADATA_PUSH. That would separate clearly the handling of four stream request types from connection-level events.","closed","type: enhancement,","rstoyanchev","2019-06-21T16:05:40Z","2019-07-08T17:05:12Z"
"","23125","AntPathMatcher should compare prefix patterns by literal length","The `AntPathMatcher.getPatternComparator(String path)` javadoc states:  > ThisComparator will sort a list so that more specific patterns (without uri templates or wild cards) come before generic patterns.   Given a url (for example, to stay close to the javadoc):  - `""/hotels/123/bookings/1/name""`  And the following paths:  - `""/hotels/**""` - `""/hotels/*/bookings/**""`  I expect that `""/hotels/*/bookings/**""` will be more specific, thus, ends up in the list before the generic one. (i.e. it is 'smaller').  However, the following snippet prints:  > true > true > /hotels/** is smaller (more specific) than /hotels/*/bookings/**  ```java     public class Demo {         public static void main(String[] args) {                  AntPathMatcher antPathMatcher = new AntPathMatcher();                  final String pathToTest = ""/hotels/123/bookings/1/name"";             final String pattern1 = ""/hotels/**"";             final String pattern2 = ""/hotels/*/bookings/**"";                  System.out.println(antPathMatcher.match(pattern1, pathToTest));             System.out.println(antPathMatcher.match(pattern2, pathToTest));                  Comparator patternComparator = antPathMatcher.getPatternComparator(pathToTest);             int compare = patternComparator.compare(pattern1, pattern2);             if (compare > 0) {                 System.out.println(pattern1 + "" is larger (less specific) than "" + pattern2);             } else if (compare == 0) {                 System.out.println(pattern1 + "" is equal to "" + pattern2);             } else {                 System.out.println(pattern1 + "" is smaller (more specific) than "" + pattern2);                  }         }     } ```  This is because eventually the `PatternInfo.getTotalCount()` evaluates to a higher number, because there are more wildcards.  However, the fact that there are more wildcards doesn't necessarily mean that it's less specific, right? Although I agree upfront that the word 'specific' is a bit vague and might be the cause of this issue/ wrong expectation.","closed","in: core,","robinvandenberg","2019-06-13T07:42:56Z","2019-07-05T10:03:07Z"
"","23337","Cache isFactoryBean detection","The `AbstractBeanFacory.isFactoryBean` method would benefit from caching the result of `isFactoryBean` since it's called at least once per-bean for each call to `getBeanNamesForType`.","closed","type: enhancement,","philwebb","2019-07-23T09:50:22Z","2019-07-31T10:23:28Z"
"","23498","Document Tradeoffs on How to Consume WebClient body","The [documentation](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web-reactive.html#webflux-client-exchange) states:  > When you use exchange(), you must always use any of the body or toEntity methods of ClientResponse to ensure resources are released and to avoid potential issues with HTTP connection pooling. You can use bodyToMono(Void.class) if no response content is expected. However, if the response does have content, the connection is closed and is not placed back in the pool.  This leaves some confusion to the reader. If I don't want the connection removed from the pool, what should I do? Are there other choices with different tradeoffs?  It would be nice if something like this https://stackoverflow.com/a/51321602/5861829 was added to the Javadoc and reference that explained the choices developers have with the tradeoffs. I think the samples should probably use `exchange()`rather than retrieve to illustrate how to consume the body. Something like this would be valuable:  ```java HttpStatus status = HttpStatus.resolve(response.rawStatusCode()); if (status == null || && !status.is2xxSuccessful()) { 	// extract the contents of this into a method named oauth2AccessTokenResponse but has an argument for the response 	return response.bodyToFlux(DataBuffer.class) 		.map(DataBufferUtils::release) 		.then(Mono.error(new RuntimeException(""oops""))); } return response.bodyToMono(String.class) ```  I think it is also valuable to point out it is important to avoid having an exception occur in the code to avoid a leak. Something that has surprised us is that `ClientResponse.statusCode()` can throw an `IllegalArgumentException` if the status is unknown. Calling this out explicitly and demonstrating how to use `HttpStatus.resolve(response.rawStatusCode())` might help others.","closed","type: task,","rwinch","2019-08-21T15:30:46Z","2021-12-14T01:21:23Z"
"","22826","Allow collapsing the menu of the reference documentations","Thanks on the continuous enhancements in the spring documentation.  One thing I myself miss - and had to work on the DOM to achieve it - is to have the ability to hide/show the left menu. ![Annotation 2019-04-23 110622](https://user-images.githubusercontent.com/1086049/56565008-0132b900-65b8-11e9-8239-30b5ca4fb144.jpg)","closed","status: declined,","mhewedy","2019-04-23T08:08:23Z","2019-05-02T07:32:55Z"
"","23568","Provide support for disabling cron-based scheduled jobs registered via SchedulingConfigurer","Support for special cron value of `-` (as defined in `Scheduled#CRON_DISABLED`) was introduced in #21397 however this is limited to use of `@Scheduled`.  For scheduled jobs registered via `SchedulingConfigurer` this is not supported which means there's no way to disable scheduled job by supplying the cron value.  This can be demonstrated using a simple Spring Boot based sample application:  ```java @SpringBootApplication @EnableScheduling public class SampleApplication implements SchedulingConfigurer {      private static final Logger logger = LoggerFactory.getLogger(SampleApplication.class);      public static void main(String[] args) {         SpringApplication.run(SampleApplication.class, args);     }      @Scheduled(cron = ""${ticker1.cron:* * * * * ?}"")     public void ticker1() {         logger.info(""ticker1"");     }      public void ticker2() {         logger.info(""ticker2"");     }      @Value(""${ticker2.cron:* * * * * ?}"")     private String ticker2Cron;      @Override     public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {         taskRegistrar.addCronTask(this::ticker2, this.ticker2Cron);     }  } ```  This works equally well for all cases, except for `-` which will blow up with `java.lang.IllegalArgumentException: Cron expression must consist of 6 fields (found 1 in ""-"")` when supplied for `ticker2.cron`.","closed","type: enhancement,","vpavic","2019-09-02T20:09:14Z","2019-09-12T14:35:26Z"
"","23534","sendBufferSizeLimit exceeded should be logged at warn level","SubProtocolWebSocketHandler catches SessionLimitExceededException exceptions, logs them at debug level and closes the session. The client sees a randomly closed socket and there is nothing in the server logs. These exceptions should be logged as a warning as they indicate a serious issue with the application that needs to be addressed.      catch (SessionLimitExceededException ex) {         try {             if (logger.isDebugEnabled()) {                 logger.debug(""Terminating '"" + session + ""'"", ex); 	    }             this.stats.incrementLimitExceededCount();             clearSession(session, ex.getStatus()); // clear first, session may be unresponsive             session.close(ex.getStatus());  [SubProtocolWebSocketHandler.java](https://github.com/spring-projects/spring-framework/blob/14558844bc4dba5586f6f9e27731bf52e802dcc5/spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java#L368-L379)","closed","type: enhancement,","davidtinker","2019-08-28T10:44:30Z","2019-09-25T07:50:31Z"
"","23047","Tiny improvements regarding usage of ArrayList","subj","closed","type: task,","stsypanov","2019-05-28T11:50:11Z","2019-05-28T14:54:39Z"
"","22982","Simplify iteration over a map","subj","closed","type: task,","stsypanov","2019-05-16T12:38:14Z","2019-05-21T08:44:20Z"
"","23160","Reliable detection of user change from interceptor in StompSubProtocolHandler","StompSubProtocolHandler.java - handleMessageFromClient Send connection type messages ```   SimpAttributesContextHolder.setAttributesFromMessage(message); // Messages connected are forwarded through multiple threads. boolean sent = outputChannel.send(message); if (sent) {     if (isConnect) {    // After successful forwarding, add the user to Map , In case of slow execution，     Principal user = headerAccessor.getUser(); 	if (user != null && user != session.getPrincipal()) { 		this.stompAuthentications.put(session.getId(), user); 	    }        }  } ``` StompSubProtocolHandler.java - handleMessageToClient   Receive connection type messages ...  ```java // get user Principal user = getUser(session); // is null  publishEvent(new SessionConnectedEvent(this, (Message) message, user));  private Principal getUser(WebSocketSession session) {        // Get the user just connected from the Map above , But in case the Map above hasn't been completed by Put, it's null. 	Principal user = this.stompAuthentications.get(session.getId()); 	return user != null ? user : session.getPrincipal(); } ``` There is a certain probability that after the message forwarding is completed, the user has not been added to the Map, resulting in no registration in the DefaultSimpUserRegistry object.  Can you help me to have a look? Thank you.","closed","type: bug,","liukaixiong","2019-06-20T02:34:42Z","2019-10-16T10:04:32Z"
"","23669","PathPatternParserTests#regexPathElementPatterns() fails on Java 13","Stacktrace:  ``` org.opentest4j.AssertionFailedError: [/{var:a{{1,2}}}         ^ Exception occurred in regex pattern compilation]  Expecting:  <8> to be equal to:  <6> but was not. 	at jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) 	at jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) 	at jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) 	at java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:500) 	at org.springframework.web.util.pattern.PathPatternParserTests.lambda$checkError$3(PathPatternParserTests.java:441) 	at org.springframework.web.util.pattern.PathPatternParserTests.checkError(PathPatternParserTests.java:440) 	at org.springframework.web.util.pattern.PathPatternParserTests.regexPathElementPatterns(PathPatternParserTests.java:121) 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:567) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675) ```","closed","type: bug,","snicoll","2019-09-19T12:39:01Z","2019-09-21T15:35:17Z"
"","23677","ServerRequestExtensionsTests#`remoteAddressOrNull with value()` fails on Java 13","Stacktrace  ``` java.lang.NullPointerException 	at java.net.InetSocketAddress.equals(InetSocketAddress.java:398) 	at org.assertj.core.util.Objects.areEqual(Objects.java:41) 	at org.assertj.core.internal.StandardComparisonStrategy.areEqual(StandardComparisonStrategy.java:76) 	at org.assertj.core.internal.Objects.areEqual(Objects.java:354) 	at org.assertj.core.internal.Objects.assertEqual(Objects.java:330) 	at org.assertj.core.api.AbstractAssert.isEqualTo(AbstractAssert.java:269) 	at org.springframework.web.servlet.function.ServerRequestExtensionsTests.remoteAddressOrNull with value(ServerRequestExtensionsTests.kt:45) 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:567) ```","closed","type: bug,","snicoll","2019-09-23T07:21:10Z","2019-09-24T07:48:48Z"
"","23380","@ExceptionHandler to keep nesting beyond the first cause","spring-web exception handling considers only the first cause of an exception to determine the applicable `@ExceptionHandler`. This patch makes the resolver search through the full exception hierarchy.","closed","type: enhancement,","Syquel","2019-07-29T14:05:06Z","2020-05-13T11:33:56Z"
"","23507","Gradle build fails on MS Windows","spring-framework : v5.2.0.RC1 Gradle  and JVM version:  ![image](https://user-images.githubusercontent.com/39401478/63576059-0a5f8100-c5be-11e9-8328-6732fd573999.png)  1.. when i clone the project, i execute the 'gradlew :spring-oxm:compileTestJava' in the cmd . And the result is **successful**  ![image](https://user-images.githubusercontent.com/39401478/63576345-85c13280-c5be-11e9-84af-3496732277df.png)  2. The i use Idea import the project , gradle build is **fail** ![image](https://user-images.githubusercontent.com/39401478/63576616-257ec080-c5bf-11e9-81a1-2015d68b832a.png)  and i try to solve this problem，but unsatisfactory  Thanks!","closed","status: invalid,","QBH-insist","2019-08-23T08:02:19Z","2020-02-20T13:57:18Z"
"","23738","Consider defaulting to UTF-8 in RestClientResponseException","Spring version: 5.2.0.RELEASE  Related to https://github.com/spring-projects/spring-framework/issues/22954 and the ```UTF-8``` charset removal, the ```RestClientResponseException``` now defaults to ```ISO_8859_1``` here https://github.com/spring-projects/spring-framework/blob/3a0f309e2c9fdbbf7fb2d348be861528177f8555/spring-web/src/main/java/org/springframework/web/client/RestClientResponseException.java#L105 instead of ```UTF-8``` previously.  To mitigate this issue, we are now forced to create a custom ```ResponseErrorHandler``` and forcing ```UTF-8```","closed","status: superseded,","ask4gilles","2019-10-01T12:39:37Z","2019-10-15T10:14:54Z"
"","23241","Accept header with trailing comma produces HTTP ""406 Not Acceptable""","Spring version: 5.1.8.RELEASE  Send a http request with header like this, containing `, ` at the end.  ```http Accept: application/json,  ```  `HeaderContentNegotiationStrategy` will produce a `HttpMediaTypeNotAcceptableException`.  ``` org.springframework.web.HttpMediaTypeNotAcceptableException: Could not parse 'Accept' header [application/json,]: Invalid mime type """": 'mimeType' must not be empty 	at org.springframework.web.accept.HeaderContentNegotiationStrategy.resolveMediaTypes(HeaderContentNegotiationStrategy.java:59) ~[spring-web-5.1.8.RELEASE.jar!/:5.1.8.RELEASE] 	at org.springframework.web.accept.ContentNegotiationManager.resolveMediaTypes(ContentNegotiationManager.java:124) ~[spring-web-5.1.8.RELEASE.jar!/:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.getAcceptableMediaTypes(AbstractMessageConverterMethodProcessor.java:391) ~[spring-webmvc-5.1.8.RELEASE.jar!/:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:229) ~[spring-webmvc-5.1.8.RELEASE.jar!/:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:225) ~[spring-webmvc-5.1.8.RELEASE.jar!/:5.1.8.RELEASE] 	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82) ~[spring-web-5.1.8.RELEASE.jar!/:5.1.8.RELEASE] ```  That http request works before 5.1.2.RELEASE.  Maybe the cause of this is the parsing method refactoring in this commit [f4b05dc](https://github.com/spring-projects/spring-framework/commit/f4b05dc2e730ca667daf8861c6eb2d9a6b83d534#diff-47ef64129825b0e047375d409c7d95a9L260).  `StringUtils.tokenizeToStringArray(mimeTypes, "","")` will trim tokens and ignore empty tokens by default, but now, the replacement method not support that anymore.","closed","type: regression,","j3r0lin","2019-07-05T06:05:43Z","2019-12-20T16:37:36Z"
"","22859","compile spring source code throws compile error ""cannot find symbol""","Spring Framework version: 5.2.0.BUILD-SNAPSHOT mac 10.14.3  ideaJ:191.6707.61  1、I clone the code from git: git clone https://github.com/spring-projects/spring-framework.git 2、cd  spring-framework && ./gradlew :spring-oxm:compileTestJava 3、 ./gradlew build -x test 4、Import into IntelliJ (File -> New -> Project from Existing Sources -> Navigate to directory -> Select build.gradle) 5、ererything is ok,then i create a module named mytest build.gradle: ```java plugins {     id 'java' } group 'org.springframework' version '5.2.0.BUILD-SNAPSHOT' sourceCompatibility = 1.8 repositories {     mavenCentral() } dependencies {     compile(project("":spring-beans""))     compile(project("":spring-core""))     compile(project("":spring-expression""))     compile(project("":spring-context""))     compile(project("":spring-instrument""))     testCompile group: 'junit', name: 'junit', version: '4.12' } ``` applicationContext.xml ```xml   	  ``` LoginService ```java public class LoginService { 	public String login(String username){ 		System.out.println(username + ""login...""); 		return ""success""; 	} } ``` Test ```java public class Test { 	public static void main(String[] args) { 		ApplicationContext context = new ClassPathXmlApplicationContext(""applicationContext.xml""); 		LoginService service = (LoginService)context.getBean(""loginService""); 		service.login(""admin""); 	} } ``` when i run this test, this module throws error cannot find symbol:  > Error:(347, 51) java: 找不到符号   符号:   变量 CoroutinesUtils   位置: 类 org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar  how could i solve this problem, i am search answers for days thanks!","closed","for: stackoverflow,","xiaodin1","2019-04-30T09:28:07Z","2019-07-08T13:08:34Z"
"","22951","Which spring framework release version do we plan to support GraalVM with native image?","Spring Framework can work in [GraalVM](https://www.graalvm.org/) mode will be excited. And Which spring framework release version do we plan to support GraalVM with native image? 5.X Or ? Thanks","closed","status: duplicate,","guanchao-yang","2019-05-13T09:11:28Z","2020-07-27T10:27:44Z"
"","22930","Upgrade to Reactor Dysprosium-M1","Spring Framework 5.2 M2 moves up to Reactor Dysprosium, picking up its first milestone.","closed","type: dependency-upgrade,","jhoeller","2019-05-08T23:43:01Z","2019-09-18T19:35:09Z"
"","22969","AnnotationTypeMapping mirror sets do not resolve in openfeign","Spring Cloud openfeign project is currently failing due to the following exception:  ``` Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Different @AliasFor mirror values for annotation [org.springframework.cloud.openfeign.FeignClient] declared on org.springframework.cloud.openfeign.invalid.FeignClientValidationTests$NameAndValueConfiguration$Client, attribute 'name' and its alias 'value' are declared with values of [bar] and [foo].     at org.springframework.core.annotation.AnnotationTypeMapping$MirrorSets$MirrorSet.resolve(AnnotationTypeMapping.java:649)     at org.springframework.core.annotation.AnnotationTypeMapping$MirrorSets.resolve(AnnotationTypeMapping.java:604)     at org.springframework.core.annotation.TypeMappedAnnotation.(TypeMappedAnnotation.java:137)     at org.springframework.core.annotation.TypeMappedAnnotation.(TypeMappedAnnotation.java:120)     at org.springframework.core.annotation.TypeMappedAnnotation.of(TypeMappedAnnotation.java:633)     at org.springframework.core.annotation.MergedAnnotation.of(MergedAnnotation.java:584)     at org.springframework.core.type.classreading.MergedAnnotationReadingVisitor.visitEnd(MergedAnnotationReadingVisitor.java:96)     at org.springframework.asm.ClassReader.readElementValues(ClassReader.java:2775)     at org.springframework.asm.ClassReader.accept(ClassReader.java:572)     at org.springframework.asm.ClassReader.accept(ClassReader.java:400)     at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:50)     at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103)     at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:123)     at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:430)     ... 45 more ```  Initial analysis looks like 3b145a5a73ae4418d7d5ad2b0f10b0dd48ab3fcf might be to blame, but we didn't get any framework or boot test failures so we must have a scenario that we've not properly covered.","closed","status: declined,","philwebb","2019-05-14T00:16:51Z","2019-05-21T21:34:12Z"
"","22948","Kotlin fails with ""Parameter specified as non-null is null"" when method with default parameter defined in constructor is called","Spring Boot with Kotlin fails with ""Parameter specified as non-null is null"" when you specify default parameters for method arguments and these arguments are passed from class constructor and constructor arguments are private.  ```kotlin import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.stereotype.Repository import javax.annotation.PostConstruct  data class Token(val value: String)  @Configuration class TokenConfig {     @Bean fun getToken() = Token(""1952f7d5a300"") }  @Repository // if you remove private, all works fine class TokenRepo(private val defaultToken: Token) {     fun getToken(token: Token = defaultToken) = token }  @SpringBootApplication class Application(private val tokenRepo: TokenRepo) {     @PostConstruct     fun start() {         val token = tokenRepo.getToken()         println(""My token: $token"")     } }  fun main(args: Array) {     runApplication(*args) } ```  Stacktrace  ``` Caused by: java.lang.IllegalArgumentException: Parameter specified as non-null is null: method com.example.app.TokenRepo.getToken, parameter token 	at com.example.app.TokenRepo.getToken(Main.kt) 	at com.example.app.TokenRepo$$FastClassBySpringCGLIB$$edca23c2.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:750) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) 	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) 	at com.example.app.TokenRepo$$EnhancerBySpringCGLIB$$ccfc06be.getToken() 	at com.example.app.TokenRepo.getToken$default(Main.kt:52) 	at com.example.app.Application.start(Main.kt:59) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:567) 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:389) 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:333) 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:157) 	... 23 common frames omitted ```  Spring Boot version: 2.2.0.M2 Kotlin version: 1.3.31","open","in: kotlin,","denyshorman","2019-05-12T18:49:00Z","2022-01-19T11:00:37Z"
"","23069","Spring Boot: @ConditionalOnMissingBean does not work correctly in conjunction with @ImportResource","Spring Boot version: 2.1.5.RELEASE  I have a `@Bean` definition in Java configuration class which is loading to application context via xml. I also have an auto-configuration with `@ConditionalOnMissingBean` condition.   **Expected result:** - Single bean is created  **Actual result:** - Two beans were created  If I load Java configuration using `@Import` annotation or if I add it by `sources()` method of `SpringApplicationBuilder` it works as expected.  Test case: ```java package com.example;  import org.junit.Test; import org.springframework.boot.autoconfigure.AutoConfigurations; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.boot.context.annotation.UserConfigurations; import org.springframework.boot.test.context.runner.ApplicationContextRunner; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.ImportResource;  import static org.assertj.core.api.Assertions.assertThat;  public class ConditionalOnMissingBeanTests {     private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();      @Test     public void testOnMissingBeanConditionWithConfigurationBeanInXml() {         this.contextRunner                 .withConfiguration(AutoConfigurations.of(ExampleBeanAutoConfiguration.class))                 .withConfiguration(UserConfigurations.of(ExampleBeanXmlConfiguration.class))                 .run(context -> {                     assertThat(context).hasSingleBean(ExampleBean.class); // <-- FAILING HERE                     assertThat(context.getBean(ExampleBean.class).value).isEqualTo(""foo"");                 });     }      @Test     public void testOnMissingBeanConditionWithConfigurationBeanInJava() {         this.contextRunner                 .withConfiguration(AutoConfigurations.of(ExampleBeanAutoConfiguration.class))                 .withConfiguration(UserConfigurations.of(ExampleBeanJavaConfiguration.class))                 .run(context -> {                     assertThat(context).hasSingleBean(ExampleBean.class);                     assertThat(context.getBean(ExampleBean.class).value).isEqualTo(""foo"");                 });     }      @Test     public void testOnMissingBeanConditionWithAutoconfiguration() {         this.contextRunner                 .withConfiguration(AutoConfigurations.of(ExampleBeanAutoConfiguration.class))                 .run(context -> {                     assertThat(context).hasSingleBean(ExampleBean.class);                     assertThat(context.getBean(ExampleBean.class).value).isEqualTo(""bar"");                 });     } }  class ExampleBean {     final String value;      ExampleBean(String value) {         this.value = value;     } }  @Configuration class ExampleBeanJavaConfiguration {     @Bean     public ExampleBean exampleBeanFoo() {         return new ExampleBean(""foo"");     } }  @Configuration @ImportResource(locations = ""classpath:/com/example/config.xml"") class ExampleBeanXmlConfiguration { }  @Configuration @ConditionalOnMissingBean(ExampleBean.class) class ExampleBeanAutoConfiguration {     @Bean     public ExampleBean exampleBeanBar() {         return new ExampleBean(""bar"");     } }  ```  Xml configuration: ```xml           ```  I debugged code, and found that in `testOnMissingBeanConditionWithConfigurationBeanInXml` test case `exampleBeanBar` (xml) bean definition is loaded after `exampleBeanFoo` (auto-config).","open","in: core,","ahrytsiuk","2019-05-31T10:45:22Z","2021-11-11T09:26:55Z"
"","23056","Provide functionality similar to Spring Boot's BeanTypeRegistry","Spring Boot currently has an internal class called [`BeanTypeRegistry`](https://github.com/spring-projects/spring-boot/blob/e481eccd577fd7dcee9c02c20fd10c60b762bf7d/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/BeanTypeRegistry.java#L68) that is used by `@ConditionalOnBean` and `@ConditionalOnMissingBean`. We've have a [recent issue](https://github.com/spring-projects/spring-boot/pull/16615#discussion_r278441383) where we need something similar, but rather than make it public in Spring Boot it might be better if Spring Framework could offer methods that we could use.  What we specifically need is a way to predict the bean type in a way that's very fast to call during condition evaluation and doesn't cause any early initialization of any beans (including `FactoryBeans`).  ---  After some analysis, I'm going to split this issue up into a number of smaller parts: - [x] Add missing ResolvableType variants of getBeanNamesForType (#23335) - [x] Retain merged bean definition caches during post processing (#23336) - [x]  Cache isFactoryBean detection (#23337) - [x] Consider generics when predicting FactoryBean types (#23338) - [x] Add attribute support for FactoryBean bean definitions (#23339) - [x] Use static final constants for common zero length arrays (#23340)","closed","type: enhancement,","philwebb","2019-05-29T16:42:43Z","2019-07-31T10:23:42Z"
"","23339","Add attribute support for FactoryBean bean definitions","Spring Boot [currently supports](https://github.com/spring-projects/spring-boot/blob/v2.1.6.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/BeanTypeRegistry.java#L308-L311) the use of a `BeanDefinition` attribute for defining the `ResolableType` that a `FactoryBean` will ultimately return.  This is used in Spring Boot itself and also [Spring Data](https://github.com/spring-projects/spring-data-commons/blob/2.1.9.RELEASE/src/main/java/org/springframework/data/repository/config/RepositoryConfigurationDelegate.java#L171) so that we can obtain sensible results without creating the `FactoryBean`. For #23056, we will need a say to support this in the Spring Framework call so that methods such as `getBeanNamesForType` work correctly.","closed","type: enhancement,","philwebb","2019-07-23T10:06:35Z","2019-07-31T10:24:20Z"
"","23576","Invalid partial content requests possible with start byte = resource-byte-count","Spring Boot 2.1.7 / Spring Framework 5.1.9  Because ResourceRegion (HttpRange.toResourceRegion) allows regions with a length of 0, it is possible to request the following range.  ```Range: bytes=-```  This will return the following invalid Content-Range Header:  ```Content-Range: length-(length_minus_1)/length```  For example: ```Content-Range: 37623133-37623132/37623133```  Length: 0 Bytes  Such a request should return 416 like other requests outside of the valid range","closed","type: enhancement,","gbrehmer","2019-09-03T23:58:24Z","2019-09-04T17:06:50Z"
"","23236","RouterFunction does not respect path matching set in WebFluxConfigurer","Spring Boot 2.1.4.Release  Trying to get the Webflux functional endpoints (RouterFunction) to ignore cases and trailing slashes when matching routes. There does not appear to be a documented way of doing this.  Would like a way of matching .GET(""/user/"", handler) to match ""/User"" irrespective of casing or trailing slashes.  Overriding configurePathMatching in an implementation of WebFluxConfigurer does not work.","closed","type: enhancement,","smwhit","2019-07-04T09:45:25Z","2020-06-30T09:39:36Z"
"","23810","DefaultListableBeanFactory and GenericApplicationContext#registerBean issue","Spring Boot (2.1.9) Spring Beans (5.1.10) Java 12  I want to discuss issue that is related to _registerBean()_ and _getIfAvailable()_ methods.  **Short version** ``` objectProvider.getIfAvailable(); applicationContext.registerBean(String name, Class classType) applicationContext.getBean(Class) -> no such bean definition exception ```  ``` applicationContext.registerBean(String name, Class classType) applicationContext.getBean(Class) -> returns bean ```  **Long version** Let us take a look at the example: ``` private GenericApplicationContext applicationContext;  public  T getOrCreateBean(Class classType, String name) {     T reader;     ObjectProvider readerProvider = applicationContext.getBeanProvider(classType);      if (Objects.isNull(readerProvider.getIfAvailable())) {         applicationContext.registerBean(name, classType);         reader = applicationContext.getBean(name, classType);     } else {         reader = readerProvider.getIfAvailable();     }     return reader; } ``` General idea is to find already registered bean or create a new one if it does not exist.  The problem is that ObjectProvider#getIfAvailable eventually calls this method: _org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeanNamesForType(java.lang.Class, boolean, boolean)_  which will put this class into _cache_ ``` Map, String[]> cache =  (includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType); // ... if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {     cache.put(type, resolvedBeanNames); } ```  Later when I want this T class that I registered inject in constructor in my case:  ``` public Writer (MyRegisteredService myRegisteredServiceBeanName) {     this.service = myRegisteredServiceBeanName; } ```  I will receive _NoSuchBeanDefinitionException_ despite it is registered!  That is because _org.springframework.beans.factory.support.DefaultListableBeanFactory#allBeanNamesByType_ does not contain bean name or in another words: empty String[].  genericApplicationContext.getBean(String name) will successfully return that bean that could not be autowired by class.  This code works pretty well by the way: ``` public  T createBean(Class classType, String name) {     applicationContext.registerBean(name, classType);     return applicationContext.getBean(name, classType); } ```   Is such behavior expected?","closed","status: duplicate,","dgray16","2019-10-15T15:32:21Z","2020-07-19T14:29:59Z"
"","23723","5.1.x","sorry, I accidentally pressed the wrong key","closed","status: invalid,","xunqirui","2019-09-28T04:24:06Z","2019-09-28T05:46:09Z"
"","23317","Add DataBuffer::toString(Charset)","Since we now have `Databuffer::write(String, Charset)`, we should also add the reverse: `DataBuffer::toString(Charset)`.","closed","type: enhancement,","poutsma","2019-07-19T10:39:20Z","2019-07-19T10:52:31Z"
"","23181","SpringValidatorAdapter's ObjectError subclass is not Serializable","Since 5.1.7.RELEASE `SerializationFailedException` happens when storing `BindingResult.getAllErrors() `with Redis.  In [a1efe3c](https://github.com/spring-projects/spring-framework/commit/a1efe3cfe58c6ab59c9b45887fc034d5af17be76#diff-8c280f6bcc1645484a02d04889167010) `SpringValidatorAdapter` was changed to use anonymous class for `ObjectError`. But such the implementation should be avoided because `ObjectError` implements Serializable.  --- **Affects:** 5.1.7.RELEASE [SEI CERT Oracle Coding Standard for Java](https://wiki.sei.cmu.edu/confluence/display/java/SER05-J.+Do+not+serialize+instances+of+inner+classes)","closed","in: core,","nai2","2019-06-24T00:57:20Z","2019-07-05T16:23:47Z"
"","22867","Update postProcessBeforeInstantiation comment","Since 4.1.x, `postProcessBeforeInstantiation` has started to support ""factory-method"":  we can see that the `determineTargetType` method has been added to support ""factory-method"" in `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation`","closed","in: core,","huitu1991","2019-05-01T16:03:23Z","2019-05-02T15:53:33Z"
"","23092","Allow separator configuration in PathPatternParser","Since #22642, the new `RouteMatcher` interface allows to choose various implementation for matching routes in the MVC, WebFlux and Messaging infrastructures.  This issue is a follow up of #22642 and prepares `PathPatternParser` for spring-projects/spring-boot#16865: in order to use `PathPatternParser` in a messaging context, we need to change the default path separator `""/""` to something appropriate for messaging paths, usually the `"".""` separator.  This issue should provide a way to configure the path separator with `PathPatternParser`.","closed","type: enhancement,","bclozel","2019-06-06T07:57:17Z","2019-06-06T10:11:22Z"
"","23142","Fix typo","Simply fixes a typo.","closed","type: task,","ielatif","2019-06-17T09:30:24Z","2019-06-17T09:42:28Z"
"","23478","Use Collections.addAll where feasible","Simplifed some if statement and use Collection.addAll instead of iterator to improve the  efficiency","closed","type: task,","OLPMO","2019-08-17T14:31:17Z","2019-08-29T12:04:55Z"
"","23256","ExchangeFilterFunctions.basicAuthentication(String, String) should cache the encoded credentials","Similar to gh-23204, `ExchangeFilterFunctions.basicAuthentication(String, String)` should also cache the encoded credentials.  At present, a new encoding takes place for any web request made through a `WebClient` configured with `.filter(ExchangeFilterFunctions.basicAuthentication(user, pass))`.","closed","type: enhancement,","membersound","2019-07-09T09:46:39Z","2019-07-09T16:04:32Z"
"","23630","Provide access to non-standard status codes from ExchangeResult","Similar to #22872 and #23547 it would be useful for `ExchangeResult` to provide support for and access to non-standard status codes as an `int`.","closed","type: task,","wilkinsona","2019-09-12T14:31:44Z","2019-09-24T12:40:19Z"
"","23420","Deprecate AnnotationConfigApplicationContext { } Kotlin extension","Similar to #22692.","closed","type: task,","sdeleuze","2019-08-06T09:27:24Z","2019-08-07T00:38:18Z"
"","23019","Fix ScriptUtils for MS Windows line ending","Shamelessly copied from https://github.com/testcontainers/testcontainers-java/pull/1467  Since Testcontainers copied ScriptUtils from this repo, the same bug exists here too.","closed","type: bug,","strawberry-choco","2019-05-23T18:26:43Z","2019-05-24T16:39:12Z"
"","22842","Streamline ReactiveAdapterRegistry.getAdapter usage","Several interactions with `ReactiveAdapterRegistry` check `hasAdapters` before calling `getAdapter.` This can be streamlined to just `getAdapter` through immediately backing out there internally if no adapters are available, removing the onus from the caller.","closed","type: enhancement,","jhoeller","2019-04-26T11:02:55Z","2019-04-26T15:23:26Z"
"","23744","Controller throws 404 for all endpoints when implementing interface and adding @Secured to method","See sample code in branch (feature/secured-interface-bug) to reproduce issue: https://github.com/caspianb/SpringBootTest/tree/feature/secured-interface-bug  I reproduced this issue in Spring Boot 2.1.0, 2.1.4, and 2.1.8.  Spring Controllers seem to be getting confused when implementing an interface and adding `@Secured` to an `@Override` method:  ```java @RestController public class UserController implements BaseController {      @Override     @RequestMapping(method = RequestMethod.GET)     public ResponseEntity getData() {         return ResponseEntity.ok(""You have access! Protected Access? | Logout"");     }      @Override     @Secured(""ROLE_ADMIN"")     @RequestMapping(path = ""api"", method = RequestMethod.GET)     public ResponseEntity getProtectedData() {         return ResponseEntity.ok(""You have protected access! Logout"");     } } ```  The above example will always throw a 404 on either endpoint. Simply removing either the `@Secured` annotation or the `implements BaseController` will eliminate the 404.  The same occurs if I define the mappings on the interface itself. Ideally, I would like to define the mappings on the interface and then explicitly mark `@Secured` on implementing classes, but it seems odd that simply implementing an interface in conjunction with `@Secured` breaks the entire controller.  Note that trying to utilize either `@RolesAllowed` or`@PreAuthorize`  has the same outcome as `@Secured` as described above.","closed","status: declined,","caspianb","2019-10-01T20:06:58Z","2019-10-02T14:53:32Z"
"","23178","Consider generics on ApplicationListener `@Bean` methods","See https://github.com/spring-projects/spring-boot/pull/17291 for background.  Currently using this pattern to define an ApplicationListener:  ```java @Bean public ApplicationListener  someListener() {     // ... } ```  Will result in a lot of cast class exception because the listener is called for every event. It would be nice if we could consider the generic signature of the bean method and only call listeners that match it.","closed","type: enhancement,","philwebb","2019-06-21T16:23:42Z","2019-07-20T13:07:14Z"
"","22977","Add JettyClientHttpConnector that accepts a HttpClient instance and a JettyResourceFactory","See https://github.com/spring-projects/spring-boot/issues/16810 for background.  Currently `JettyClientHttpConnector` has the following constructor:  ```java public JettyClientHttpConnector( 		JettyResourceFactory resourceFactory, @Nullable Consumer customizer) { 	HttpClient httpClient = new HttpClient(); 	httpClient.setExecutor(resourceFactory.getExecutor()); 	httpClient.setByteBufferPool(resourceFactory.getByteBufferPool()); 	httpClient.setScheduler(resourceFactory.getScheduler()); 	if (customizer != null) { 		customizer.accept(httpClient); 	} 	this.httpClient = httpClient; } ```  This allows us to apply settings to the `HttpClient` from the `resourceFactory` and apply additional customization. Unfortunately, the only way we can change the `sslContextFactory` is when constructing the `HttpClient` (we can't use the customizer). This means we're forced to copy/paste the code that applies the`resourceFactory` items.  Could we please have an additional constructor that takes a `HttpClient` instance and still applies the `JettyResourceFactory` settings.","closed","type: enhancement,","philwebb","2019-05-15T02:09:04Z","2019-05-28T15:01:09Z"
"","22834","Consider logging classcast exceptions caused by lambdas at trace level","See https://github.com/spring-projects/spring-boot/issues/16631 for background.  Currently lambda based listeners get debug logging if they don't accept the argument type. For example:  ``` java.lang.ClassCastException: class org.springframework.boot.context.event.ApplicationReadyEvent cannot be cast to class org.springframework.boot.devtools.classpath.ClassPathChangedEvent (org.springframework.boot.context.event.ApplicationReadyEvent and org.springframework.boot.devtools.classpath.ClassPathChangedEvent are in unnamed module of loader 'app') 	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ```  I wonder if trace level logging might be more appropriate.","closed","type: enhancement,","philwebb","2019-04-24T15:35:57Z","2019-04-25T12:57:02Z"
"","23697","Clarify units handling in DataSize javadoc","See https://en.wikipedia.org/wiki/Binary_prefix and #23682","closed","type: documentation,","snicoll","2019-09-25T08:05:11Z","2019-09-26T14:10:59Z"
"","23223","[WIP] Discover test config on enclosing class for nested test class","See gh-19930","closed","status: declined,","Golf1122","2019-07-01T18:11:48Z","2019-07-03T07:14:27Z"
"","23374","Provide a way to predict bean types without initializing FactoryBeans","See [this comment](https://github.com/spring-projects/spring-framework/pull/23341#issuecomment-515168796) for details.  I don't think we currently have a way to tell the predicted type of a bean without initializing it. It might be nice if we could either surface a `getType(String name, boolean allowEagerInit)` or perhaps add a callback based approach similar to the existing `getBeanNames...` methods:  ```java  void doWithBeanNamesForType(@Nullable Class type, boolean includeNonSingletons, boolean allowEagerInit, BiConsumer> consumer); ```  We should wait until #23341 is merged before taking this on.","closed","type: enhancement,","philwebb","2019-07-27T06:58:27Z","2019-09-03T22:07:11Z"
"","23153","Fix Jackson documentation broken links","See [related discussion](https://twitter.com/sdeleuze/status/1140990385185013760) with Jackson project lead.","closed","type: documentation,","sdeleuze","2019-06-19T11:59:20Z","2019-06-19T12:06:14Z"
"","23315","Prevent @Conditional from ignoring subsequent bean definition with same name","See #23307 for reason of this PR.  I removed the check, whether a bean is already in the skippedBeanMethods collection.  This collection only stores the method name, which leads to the undesired behavior as mentioned in #23307.  After this change, bean methods are only skipped, if they are annotated with a condition which evaluates to false.","open","in: core,","tobisinghania","2019-07-18T15:00:44Z","2021-04-27T05:06:10Z"
"","23305","ForwardedHeaderTransformer preserves escape sequences when applying X-Forwarded-Prefix","See #23306 for the cause.","closed","type: bug,","AndreasKl","2019-07-17T13:41:41Z","2019-07-19T09:59:33Z"
"","23002","Add FreeMarker macro support in spring-webflux","See #22950 for details.","closed","type: enhancement,","ielatif","2019-05-20T16:35:35Z","2019-06-10T14:47:49Z"
"","23721","Add support for MockRestServiceServer to verify that a header does not exist","See #15397 for background information.  See also: 4bf5a0234c6c5c5d6591eb0fa52db3bf09573d9f","closed","type: enhancement,","sbrannen","2019-09-27T15:03:56Z","2019-09-27T15:49:14Z"
"","23570","SimpleReactiveMongoRepository saveAll method and changestreams do not work if custom id is defined","Scenairo is as follows, Consider an object which has a autogenerated id with `""@ID""` annotation. This gets converted to mongo ObjectId and it works correctly with changestreams. However when calling saveAll, instead of updating the object, it inserts new object. This is expected as the logic is based on id and id is always new.  My problem is, if i change the id to be a unique identifier based on my code, changestreams functionality stops working. Say for example, i make the id as firstName+postCode, then saveAll works perfectly. The name of the field is id, and is annotated with `""@Id""` but has the value of firstName+postCode. This fixes the saveAll issue. However it breaks changestreams.  Please could you let me know if i am doing anything incorrectly. I prefert to use Spring's reactive mongo repository save method instead of  findAndModify or mongoReativeTemplate.  Thank you.    Details on the jars used mongodb-driver-reactivestreams  1.11.0  spring-data-mongodb  2.1.9.RELEASE  spring-boot-starter-data-mongodb-reactive  2.1.6.RELEASE     2.0.9.RELEASE     **Affects:** \2.0.9.RELEASE  ---","closed","for: external-project,","ashrnair","2019-09-03T08:29:52Z","2021-11-12T13:41:17Z"
"","23049","Reintroduce author list and copyright notice","Sam Brannen noticed that we had lost the author list and the copyright notice. I have replaced that content by re-creating it from the most recent author list and copyright notice that I could find. Thanks for noticing, Sam.","closed","type: documentation,","Buzzardo","2019-05-28T18:56:19Z","2019-06-04T09:03:55Z"
"","23208","Compatibility with RxJava 3.0","RxJava 3.0.0-RC0 is out now, and it turns out that it is entirely backwards-compatible with RxJava 2.2 for our purposes. However, there are several tests that use outdated/deprecated methods which we should revise as a preparation for upgrading our build to RxJava 3.0 eventually.","closed","in: core,","jhoeller","2019-06-28T12:41:14Z","2019-07-05T14:28:21Z"
"","23640","RSocketRequestSpec handling metadata values that is a Publisher type","RSocketRequester already handles `Publisher` for the body. It would be very nice if it could do the same for `metadata` values. For example right now a user needs to do something like this:  ```java public Mono findRadar(String iata) { 	return this.requesterMono.flatMap(req -> 		token().flatMap(token -> 			req.route(""find.radar.{iata}"", iata) 					.metadata(jwt(token)) 					.data(Mono.empty()) 					.retrieveMono(AirportLocation.class) 		) 	); }  private Mono token() { 	return ReactiveSecurityContextHolder.getContext() 			.map(SecurityContext::getAuthentication) 			.map(Authentication::getPrincipal) 			.cast(Jwt.class) 			.map(Jwt::getTokenValue); }  private Consumer jwt(String token) { 	return r -> r.metadata(token, BearerTokenMetadata.BEARER_AUTHENTICATION_MIME_TYPE); }  ```  If `metadata` could accept a publisher this can be simplified quite a bit:  ```java public Mono findRadar(String iata) { 	return this.requesterMono.flatMap(req -> 		req.route(""find.radar.{iata}"", iata) 				.metadata(jwt()) 				.data(Mono.empty()) 				.retrieveMono(AirportLocation.class) 	); }  private Mono token() { 	return ReactiveSecurityContextHolder.getContext() 			.map(SecurityContext::getAuthentication) 			.map(Authentication::getPrincipal) 			.cast(Jwt.class) 			.map(Jwt::getTokenValue); }  private Consumer jwt() { 	return r -> r.metadata(token(), BearerTokenMetadata.BEARER_AUTHENTICATION_MIME_TYPE); }  ```  Notice that the user no longer needs to subscribe to the `Mono` which decreases the number of mappings necessary. The user is also able to only consume a single method now `Consumer jwt()`.","closed","type: enhancement,","rwinch","2019-09-13T20:26:08Z","2019-11-20T19:42:17Z"
"","23054","Improve FreeMarkerConfigurationFactory to mutate its configuration","Right now `FreeMarkerConfigurationFactory` can only be used to set settings with no way to know what the currently configured settings are. We'd like to use it as a source for a customizer in Spring Boot but the current API does not allow us to do that.  For instance, we'd like to add a variable or know variables are currently configured but the API does not allow us to know what the current variables are.  See https://github.com/spring-projects/spring-boot/issues/8965","open","status: pending-design-work,","snicoll","2019-05-29T15:09:37Z","2021-11-12T12:13:36Z"
"","23735","Resolves conflicts for pr #23255","Resolves conflicts for pr [#23255 ](https://github.com/spring-projects/spring-framework/pull/23255) that closes gh [#23254 ](https://github.com/spring-projects/spring-framework/issues/23254)","closed","status: declined,","ze12augusto","2019-10-01T11:05:35Z","2019-10-01T12:22:02Z"
"","23736","Resolves conflicts for pr [#2063 ]","Resolves conflicts for pr [#2063 ](https://github.com/spring-projects/spring-framework/pull/2063)","closed","status: declined,","ze12augusto","2019-10-01T11:08:55Z","2019-10-01T12:21:41Z"
"","23767","Regression: attribute override configured via @AliasFor no longer honored in annotation hierarchy","Reproduced in  https://github.com/flozano/spring-framework-issues/commit/bbc160d93adc3e3a11acceeadae23246a4732e12  We use meta-annotations for using different transaction managers in different areas of the app.  During the upgrade to 5.2.0.RELEASE, we found that the wrong transaction manager was being used in many cases.  I haven't investigated deep enough, but I have put together a reproducing project that works well in Spring 5.1.9 but fails in 5.2.0.  What I have observed is that the behaviour of `AnnotatedElementUtils#findMergedAnnotationAttributes` is different than it was for 5.1.9.RELEASE when `@AliasFor` appears, basically not propagating the value that I set in the meta-annotations to `@Transactional`.  What I have is: ```java @Transactional @Retention(RetentionPolicy.RUNTIME) public @interface MyTransactional {  	@AliasFor(annotation = Transactional.class, attribute = ""value"") 	String value() default ""defaultTransactionManager"";  	@AliasFor(annotation = Transactional.class, attribute = ""isolation"") 	Isolation isolation() default Isolation.DEFAULT;  } ``` and ```java @MyTransactional(value = ""anotherTransactionManager"") @Retention(RetentionPolicy.RUNTIME) public @interface AnotherMyTransactional {  } ```  and when I try to use `@AnotherMyTransactional`, `findMergedAnnotationAttributes` gets an empty value for `value` field (transaction manager qualifier) , whereas in 5.1.9.RELEASE it obtains the right one.","closed","in: core,","flozano","2019-10-08T10:05:00Z","2019-10-22T10:59:04Z"
"","23614","Update the AspectJ Gradle Plugin to 4.1.0","replaces #23540","closed","status: superseded,","larsgrefer","2019-09-09T15:35:49Z","2019-09-28T07:11:27Z"
"","23444","replace anonymous type with lambda","replace anonymous type with lambda which is new feature of Java 8.","closed","status: declined,","zhuzhuman978","2019-08-09T21:17:28Z","2019-08-09T21:28:31Z"
"","23057","Update kotlin.adoc","remove warning about @ConfigurationProperties binding for immutable POJOs fixed in https://github.com/spring-projects/spring-boot/issues/8762","closed","","hexetia","2019-05-30T00:00:05Z","2019-05-31T12:18:30Z"
"","23477","Remove unnecessary semicolon","Remove unnecessary semicolon after the nested class.","closed","type: task,","andrey4623","2019-08-17T13:04:34Z","2019-08-17T13:23:49Z"
"","23530","Remove redundant code and simplify the code of invokeBeanFactoryPostProcessors method","Remove redundant code and simplify the code","closed","in: core,","tswstarplanet","2019-08-27T18:24:21Z","2019-09-06T16:12:57Z"
"","23662","Upgrade to Jackson 2.10.0","Release expected September 26th, tests with Jackson `2.10.0.pr3` are all green on `master`.","closed","type: dependency-upgrade,","sdeleuze","2019-09-18T14:26:45Z","2019-09-27T20:44:13Z"
"","23200","Raise log level when bean destruction fails","related to  this issue https://github.com/spring-projects/spring-framework/issues/23199   logger runned on `org.springframework.beans.factory.support`  package. but InvocationTargetException was makes by my code. I want to check my error log.","closed","in: core,","boojongmin","2019-06-27T00:48:08Z","2019-07-05T16:23:47Z"
"","23505","mono.block() hangs on nested webclient calls","related stackoverflow question: https://stackoverflow.com/questions/57510391/how-can-i-call-a-rest-service-while-processing-another-rest-service-in-the-react  Spring Boot Version: 2.1.6 Sring Framework Version: 5.1.8   I'm trying to make a nested WebClient on a restful service, but it gets blocked on the last mono.block() response.  I believe this should be enough to reproduce this issue:  ``` package feluso;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.http.MediaType; import org.springframework.web.reactive.function.client.ClientResponse; import org.springframework.web.reactive.function.client.WebClient; import reactor.core.publisher.Mono;  import java.util.function.Function;  @Configuration @EnableAutoConfiguration @ComponentScan(""feluso"") public class Application {      public static void main(String[] args) {         SpringApplication.run(Application.class, args);         WebClient client = WebClient.create(""https://pokeapi.co/api/v2/"");         Mono result = client.get()                 .uri(""/pokemon/ditto"")                 .accept(MediaType.APPLICATION_JSON)                 .exchange();          Function> callSpecies = species -> WebClient.create(species.getUrl()).get().uri(""/"")                 .accept(MediaType.APPLICATION_JSON)                 .exchange()                 .flatMap(response -> response.bodyToMono(Object.class));          Mono pkmnMono = result.flatMap(response -> response.bodyToMono(Pokemon.class))                 .map(pokemon -> pokemon.getSpecies())                 .flatMap(callSpecies)                 .doOnEach(lastStep ->                         System.out.println(lastStep));          pkmnMono.block();      } } ```   ```package feluso;  import lombok.Data;  @Data public class Pokemon {     public String name;     public Species species; } ```  build.gradle ``` buildscript {     ext {         springBootVersion = '2.1.1.RELEASE'     }     repositories {         mavenCentral()     }     dependencies {         classpath(""org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"")     } }  plugins {     id 'java'     id 'idea' }  apply plugin: 'org.springframework.boot' apply plugin: 'io.spring.dependency-management'  group 'pokemonwebflux' version '1.0-SNAPSHOT'  bootJar {     baseName = 'pkmnreactive'     version =  '0.1.0' } sourceCompatibility = 1.8  repositories {     mavenCentral() }  dependencies {     compile 'org.springframework.boot:spring-boot-starter-webflux'     testCompile group: 'junit', name: 'junit', version: '4.12'     testCompile('org.springframework.boot:spring-boot-starter-test')     compileOnly 'org.projectlombok:lombok:1.18.8'     annotationProcessor 'org.projectlombok:lombok:1.18.8' } ```  as the person that replied in my stack overflow question made me realize, seems like its a problem with the version, when I change my spring boot version in my `build.gradle` file to 2.1.1 (and dependency management changes the version of spring framework to 5.1.3) the code does work (the expected result is a print of the last call), but I'm unsure as the SO commenter does say my code worked on his 2.1.6 run, that's why I've added the build gradle file.  Thank you for any help!","closed","status: invalid,","feluso","2019-08-22T21:32:40Z","2019-08-27T19:34:37Z"
"","22886","Unify standard and ASM AnnotatedTypeMetadata retention behavior","Reflection based `AnnotatedTypeMetadata` implementations only support `@RetentionPolicy(RetentionPolicy.RUNTIME)` annotations. ASM implementations however currently ignore the `visible` attribute and will read both `RetentionPolicy.CLASS` and `RetentionPolicy.RUNTIME` annotations.  I would like to unify the two implementations if possible.","closed","in: core,","philwebb","2019-05-04T05:15:38Z","2019-11-03T14:17:29Z"
"","23817","Cache bean does not inject in a bean which created using FactoryBean.","Redis cache bean does not inject in a bean which created using FactoryBean.  But another cache which created does not via FactoryBean is success.  Example: https://github.com/DmitryevichD/BugWithBeanFactoryCache","closed","status: invalid,","DmitryevichD","2019-10-16T09:59:21Z","2019-10-16T15:40:17Z"
"","23742","3.0.x","pull it","closed","status: invalid,","Dev-Aman7","2019-10-01T18:18:50Z","2019-10-01T19:02:43Z"
"","23595","pull","pull","closed","","huhuixin","2019-09-06T07:59:06Z","2022-02-18T19:07:15Z"
"","23344","Support element arrays with MergedAnnotations.from","Provide an overloaded version of `MergedAnnotations.from` that takes an array of elements. This shortcut is particularly useful in property situations where an annotation may be used on a getter, setter or field.  Closes gh-23327","open","in: core,","philwebb","2019-07-23T13:02:28Z","2021-11-11T09:52:30Z"
"","23355","Build fails on MS Windows for distZip Gradle task","Problem： FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':distZip'. > Failed to create MD5 hash for file 'E:\spring-framework-master\build\distributions\spring-framework-5.2.0.BUILD-SNAPSHOT-schema.zip' as it does not exist.","closed","status: duplicate,","husterchen","2019-07-25T04:45:53Z","2019-11-11T14:44:25Z"
"","23521","Use dependency management in Framework build","Prior to this commit, the Spring Framework build would partially use the dependency management plugin to import and enforce BOMs.  This commit applies the dependency management plugin to all Java projects and regroups all version management declaration in the root `build.gradle` file (versions and exclusions).  Some versions are overridden in specific modules for backwards-compatibility reasons or extended support.","closed","type: task,","bclozel","2019-08-26T19:29:11Z","2022-01-31T20:15:34Z"
"","23140","Ignore null HttpMessageConverter in RestTemplate and HttpMessageConverterExtractor","Prior to this commit, if a `null` `HttpMessageConverter` was configured in the `RestTemplate`, this would lead to a `NullPointerException` once the list of converters was accessed.  This commit avoids such exceptions by ignoring `null` converters.  See gh-23123","closed","type: enhancement,","fodil-a","2019-06-15T18:23:02Z","2019-06-18T11:54:28Z"
"","23132","Ignore null HttpMessageConverter in RestTemplate and HttpMessageConverterExtractor","Prior to this commit, if a `null` `HttpMessageConverter` was configured in the `RestTemplate`, this would lead to a `NullPointerException` once the list of converters was accessed.  This commit avoids such exceptions by ignoring `null` converters.  See gh-23123","closed","type: enhancement,","fodil-a","2019-06-13T13:21:51Z","2019-06-16T15:25:44Z"
"","23645","Allow registration of RSocket metadata extractors","Prior to this commit, customizing the extraction of RSocket metadata from frames would require developers to override the default `MetadataExtractor` while configuring `RSocketStrategies`. This touches on many infrastructure parts, whereas the goal is just to configure an extra metadata entry extractor using already configured codecs.  This commit adds a way to register metadata entry extractors on the `RSocketStrategies` builder with a `Consumer`-based API.","closed","type: enhancement,","bclozel","2019-09-16T13:41:18Z","2022-01-31T20:16:00Z"
"","23704","Allow genJaxb's output to be cached when checkout locations differ","Previously, the `genJaxb` task's input files were compared using absolute paths. This would result in a cache miss for two builds with identical files contents and different root directories.  This PR updates the path sensitivity of the input to be relative to the build's root directory, thereby allowing caching to work irrespective of the source checkout location.","closed","type: task,","wilkinsona","2019-09-25T14:15:07Z","2019-09-25T14:44:02Z"
"","23642","Fix race condition in sendBlockingMessage","Previously, tests in `ConcurrentWebSocketSessionDecoratorTests` that use the BlockingSession would fail intermittently. This appears to have been due to a race condition in `sendBlockingMessage` where the call to `getSentMessageLatch()` that stores a latch in `nextMessageLatch` on the main thread may happen after the call to `sendMessage` that counts down the latch if it is non-null occurs on the executor's thread.  This pull request updates `sendBlockingMessage` to call `getSentMessageLatch()` (and therefore store the latch) before it sumbmits the task to the executor. This ensures that the latch will be available when the exeuctor's thread attempts to retrieve and decrement it. `BlockingSession`'s `AtomicReference` fields have also been made `final` to eliminate the possibility of any visibility problems across threads.","closed","type: task,","wilkinsona","2019-09-16T09:23:31Z","2019-09-24T11:25:07Z"
"","23623","Move jmx.log beneath build/ to avoid up-to-date pollution","Previously, some tests in spring-context wrote a file named jmx.log into spring-context/. This led to the file being included in the sources of the Checkstyle NoHTTP tasks, breaking that task's up-to-date checks and causing it to execute unnecessarily.  This PR updates the tests to write the jmx.log file beneath spring-context/build/ so that it is not included in the sources of the Checkstyle NoHTTP task.","closed","type: task,","wilkinsona","2019-09-11T16:24:15Z","2019-09-12T09:44:22Z"
"","23616","Disable caching of changing modules (snapshots) and dynamic versions","Previously, changing modules (snapshots) and dynamic versions were cached for Gradle's default period of 24 hours and `--refresh-dependencies` was used to pick up the latest artifacts. This approach has a notable downside. `--refresh-dependencies` causes all dependencies to be refreshed, irrespective of whether they are expected to change. At a minimum, this results in a HEAD request for every dependency in the build. Running an up-to-date build without `--refresh-dependencies` takes in the region of 6 seconds:  ``` $ ./gradlew build  BUILD SUCCESSFUL in 6s 203 actionable tasks: 203 up-to-date ```  The same build with --refresh-dependencies takes almost ten times as long:  ``` $ ./gradlew build --refresh-dependencies  BUILD SUCCESSFUL in 58s 203 actionable tasks: 203 up-to-date ```  This commit replaces the manual usage of `--refresh-dependencies` on the command line with a 0 second caching period for changing modules and dynamic versions. This should remove the need to use `--refresh-dependencies` both locally and on CI, saving almost 1 minute per full build.  /cc @etiennestuder","closed","type: task,","wilkinsona","2019-09-10T16:22:53Z","2019-09-11T08:01:05Z"
"","23457","Modify the javadoc of @EnableWebFlux annotation","Previously the Javadoc of EnableWebFlux referred to `configureMessageWriters()` method in `WebFluxConfigurer` which wasn't there. Now it has been modified to give an example of the `configureHttpMessageCodecs()` method which is present  This fixes the [issue 23452](https://github.com/spring-projects/spring-framework/issues/23452)","closed","in: web,","Sauhardstark","2019-08-13T05:40:13Z","2019-08-13T08:27:49Z"
"","23493","Detect ClientHttpConnector to use by checking classpath","Previously DefaultWebClientBuilder always defaulted the ClientHttpConnector with ReactorClientHttpConnector. This worked fine if reactor was used. However, it would break if the user was trying to leverage Jetty.  This commit defaults to use Reactory Netty HttpClient if it is present. If it is not present it then Jetty's HttpClient  is used if present.  Closes gh-23491","closed","type: enhancement,","rwinch","2019-08-20T16:12:28Z","2019-08-21T10:42:24Z"
"","23803","Add option to use charset in RestClientResponseException","Partial backport of gh-23764.   The default is not switched to UTF-8. However an additional convenience method is provided with a charset argument.","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:33Z","2019-10-30T09:56:45Z"
"","22942","JDiff report does not contain HTML report anymore","Our release process includes a command to run to be able to generate the binary diff between two releases.   First step is to get a repo with the previous release, e.g.  ```shell cd /tmp mkdir spr-5.2.0.M1 cd spr-5.2.0.M1 git clone https://github.com/spring-projects/spring-framework/ cd spring-framework git fetch origin --tags git checkout v5.2.0.M1 ```  Then, from the repo at the target (about to release version) we can run the following:  ```shell ./gradlew jdiff -D OLD_VERSION=5.2.0.M1 -D OLD_VERSION_ROOT=/tmp/spr-5.2.0.M1 ```  This generates a report with the diff (here's [an example for 5.1](https://docs.spring.io/spring-framework/docs/5.1.0.RC1_to_5.1.0.RC2/)). Running that command on `master` does not generate the `changes.html` file anymore.","closed","type: task,","snicoll","2019-05-10T09:38:42Z","2019-08-19T08:22:32Z"
"","23792","Autowiring performance degradation due to 5.2's MethodParameter.getParameterType() implementation","Our applications makes considerable use of programmatic autowiring of beans via org.springframework.beans.factory.config.AutowireCapableBeanFactory#autowire.  Therefore we have a couple of performance tests, which directly and indirectly measure the throughput of the underlying Spring implementation. All those tests degraded by about 20 to 25 percent, after only updating the Spring dependencies from version 5.1.9 to version 5.2.0.  We did a bit of work to pinpoint the changes in Spring, which resulted in this performance drop and thought it would be a good idea to report it here so you can verify, whether you like to accept this or have an idea how to achieve both, improved code robustness while maintaining performance.  The root of the actual performance degradation seems to originate from changes to org.springframework.core.MethodParameter#getParameterType to use org.springframework.core.ResolvableType (in our case itself used from org.springframework.beans.factory.support.ConstructorResolver#resolveAutowiredArgument).  The relevant issue motivating this change seems to be https://github.com/spring-projects/spring-framework/issues/23385  I quickly verified that it is enough to use 5.1.9 as base and only change the above mentioned two core classes, to observe the performance drop. I have not yet checked the Spring project for own performance tests.","closed","in: core,","e-hubert","2019-10-14T12:51:33Z","2019-10-30T08:20:04Z"
"","23356","I've got AbstractNamedValueMethodArgumentResolver exception","our API Spec like this - PUT method - method parameter - @ReqeustBody  but someone's API call unusually, so I got this error message   ``` For input string: ""price"" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:589) at java.lang.Long.valueOf(Long.java:803) at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:214) at org.springframework.beans.propertyeditors.CustomNumberEditor.setAsText(CustomNumberEditor.java:115) at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:429) at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:402) at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:155) at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73) at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53) at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:693) at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:124) at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:126) at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:166) at  ``` weird things is we made API method only use @RequestBody but as you can see, occur  `AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:124)` this exception   to do solve this problem, I want to reproduce this exception , but I can't find it If you guys know to do solve this problem plz comment!","closed","for: stackoverflow,","umanking","2019-07-25T09:19:15Z","2019-07-25T09:22:21Z"
"","22892","Review CONTRIBUTING.md with the move to github issues","Our `CONTRIBUTING.md` document is still describing the process when we used Jira issues. It should be reviewed and our process reflected accordingly.","closed","type: task,","snicoll","2019-05-05T07:14:27Z","2019-11-26T16:36:14Z"
"","23586","Update IntelliJ IDEA codestyle with new import structure","Our [codestyle.xml](https://github.com/spring-projects/spring-framework/blob/master/src/idea/spring-framework.xml) should be upgraded with regards to #23539","closed","","snicoll","2019-09-05T10:05:38Z","2019-09-05T12:28:24Z"
"","23232","Support 'default' option in StringToTimeZoneConverter","Originally raised in [in Spring Boot](https://github.com/spring-projects/spring-boot/issues/17414#issuecomment-508000948) it would be nice if our `StringToTimeZoneConverter` could support ""default"" -> `TimeZone.getDefault()`.","open","in: core,","philwebb","2019-07-03T19:02:28Z","2021-11-11T10:12:39Z"
"","23733","cannot readOnly, developer need add HttpHeader in org.springframework…","org.springframework.web.reactive.function.client.DefaultClientRequestBuilder.BodyInserterRequest   cannot readOnly, developer need add HttpHeader in org.springframework.http.codec.HttpMessageWriter,eg: add a HttpHeader xxx-bodyOfSignature","closed","status: invalid,","qinarmy-zoro","2019-09-30T19:03:35Z","2019-10-15T11:31:23Z"
"","22846","Validated expand","org.springframework.validation.annotation.Validated,I hope can support the value is of type String [], sometimes we don't want to define a Class in the development process to as grouping validation scenarios, can use simple String grouping do check","open","in: core,","609844066","2019-04-28T03:19:13Z","2021-11-12T13:49:07Z"
"","23139","Binder  Nesting of the same entity class is not supported","org.springframework.boot.context.properties.bind.Binder  Nesting of the same entity class is not supported !!! please see my demo  https://github.com/brucelwl/demo.git  ![image](https://user-images.githubusercontent.com/13413715/59524158-bf622700-8f05-11e9-943e-5df31bb34b2c.png) ![image](https://user-images.githubusercontent.com/13413715/59524203-d9036e80-8f05-11e9-8b32-ddc5f2afae59.png)","closed","status: duplicate,","brucelwl","2019-06-14T16:33:24Z","2019-06-15T13:22:09Z"
"","23773","Feauture 20191009 fix log","optimize the info log","closed","status: invalid,","wycm","2019-10-09T13:08:41Z","2019-10-15T11:20:07Z"
"","23626","Optimize test code with lambdas where feasible","Optimize code with lambda where feasible","closed","type: task,","OLPMO","2019-09-12T05:16:01Z","2019-09-14T08:42:04Z"
"","23698","Upgrade to RSocket 1.0.0.RC5","Once the RSocket BOM format is fixed, we should use it instead of managing dependencies ourselves.","closed","type: dependency-upgrade,","bclozel","2019-09-25T10:19:52Z","2019-09-30T05:57:24Z"
"","23558","WebFluxTest and GlobalScope.Launch","On a coroutine-based Webflux app, there is a difference in behavior between making HTTP requests via `WebFluxTest` and making requests directly to the server if `GlobalScope.Launch() `is used in the handler function. This difference can yield false-positives on tests.   For example, if we create an HTTP POST using `WebTestClient` and in the corresponding handler function we `GlobalScope.Launch()` a coroutine that attempts to access the ServerRequest body then we will successfully be able to retrieve it. However, if we perform the same operation against the same handler function using a direct HTTP request against a fully running server, then, we will not be able to retrieve the body and get null as a result.   Please see the reproducer code in the repo below and read the `DemoApplication.kt` file along with `DemoApplicationTests` file for a concrete demonstration.  https://github.com/PedroAlvarado/webflux-globalscope-issue  It is not clear whether this behavior is intended and we need some additional documentation with regards to the risks/gotchas of using `WebFluxTest` and Coroutines or whether there is an actual bug in behavior.   **Affects:** Spring Framework 5.2","closed","status: feedback-provided,","PedroAlvarado","2019-09-01T03:54:17Z","2019-11-02T16:12:36Z"
"","22871","HttpHeaders cause NPE in use with RestTemplate","Occasionally I'm getting NPEs wehn using `RestTemplate.postForObject()`. I could not manually reproduce the issues, as I don't know the case when the headers ""seem"" to be null.   All I know is that the `ClientHttpResponse` is *not* null in those cases and correctly filled with header+body data. The next request with the exact same parameters then works again.  Maybe this has to do with https://github.com/spring-projects/spring-framework/issues/22821, because `new HttpHeaders()` is initialized with `LinkedCaseInsensitiveMap`?  Anyways I think adding (or getting) the `HttpHeaders` should never result in an NPE, this should be caught somewhere down the stack.  ``` java.util.concurrent.CompletionException: java.lang.NullPointerException 	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314) ~[?:?] 	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319) ~[?:?] 	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1702) ~[?:?] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[?:?] 	at java.lang.Thread.run(Thread.java:834) [?:?] Caused by: java.lang.NullPointerException 	at org.springframework.util.CollectionUtils$MultiValueMapAdapter.add(CollectionUtils.java:460) ~[spring-core-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.http.HttpHeaders.add(HttpHeaders.java:1565) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.http.client.HttpComponentsClientHttpResponse.getHeaders(HttpComponentsClientHttpResponse.java:71) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.http.client.BufferingClientHttpResponseWrapper.getHeaders(BufferingClientHttpResponseWrapper.java:65) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.client.MessageBodyClientHttpResponseWrapper.getHeaders(MessageBodyClientHttpResponseWrapper.java:115) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.client.MessageBodyClientHttpResponseWrapper.hasMessageBody(MessageBodyClientHttpResponseWrapper.java:66) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.client.HttpMessageConverterExtractor.extractData(HttpMessageConverterExtractor.java:87) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:737) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:670) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.client.RestTemplate.postForObject(RestTemplate.java:414) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE]         at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1700) ~[?:?] ```","closed","status: duplicate,","membersound","2019-05-02T13:54:25Z","2020-04-01T19:03:15Z"
"","22938","Spelling fix in `core-expressions.adoc`","Obvious Fix","closed","type: task,","crewmanmud","2019-05-09T21:49:24Z","2019-05-10T23:06:19Z"
"","23467","Upgrade spring-test to Hamcrest to 2.1","Now the version of hamcrest which spring depends is 1.3, some new features in hamcrest 2.x cannot be applied in our self project, such as `matchesPattern`. If we upgrade it in our pom, then spring-test cannot find some  methods.  ``` java.lang.NoSuchMethodError: org.hamcrest.Matcher.describeMismatch(Ljava/lang/Object;Lorg/hamcrest/Description;)V 	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:18) 	at org.springframework.test.web.client.match.MockRestRequestMatchers$2.match(MockRestRequestMatchers.java:72) 	at org.springframework.test.web.client.RequestMatcherClientHttpRequest.executeInternal(RequestMatcherClientHttpRequest.java:75) 	at org.springframework.mock.http.client.MockClientHttpRequest.execute(MockClientHttpRequest.java:93) 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:591) 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:552) 	at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:259) 	at com.cisco.edsartapi.v3.client.RequestClient.getLastApprover(RequestClient.java:54) 	at com.cisco.edsartapi.v3.client.RequestClientTest.testGetLastApprover_Success(RequestClientTest.java:57) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37) 	at org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62) 	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)  ```","closed","type: task,","unxia","2019-08-16T07:53:30Z","2019-08-19T13:37:17Z"
"","23431","RSocket data decoding for per payload support","Now RSocketRequester uses global data MimeType for Payload data decoding,  for some cases,  the applications want to mix multi data mime types, it means that some payloads will include data mime type information in CompositeMetadata of payload.  Now MetadataExtractor can extract route from per payload,  any idea to add dataMimeType of decoding for per payload. If dataMimeType is null, please use global data MimeType for payload data decoding.    Code as following:   ``` interface MetadataExtractor {     String ROUTE_KEY = ""route"";    // data mime type for per payload     String DATA_MIME_KEY=""dataMimeType""; } ```","closed","for: external-project,","linux-china","2019-08-07T17:29:59Z","2019-08-23T10:09:33Z"
"","23157","RSocket Metadata Mimetype ""text/plain"" and ""application/json"" support","Now RSocket adopts ""message/x.rsocket.composite-metadata.v0"" and ""message/x.rsocket.routing.v0"" as metadata MimeType.  Please consider add ""text/plain"" as metadata Mime type, some cases, the text just as route key.  If possible, could ""application/json""  be added as metadata Mime type and routing key is ""routing"" field like following:   ``` {   ""routing"": ""chat_room"",   .... } ```  Both ""text/plain"" and ""application/json"" are friendly and easy for Javascript in browser.  https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/rsocket/MessagingRSocket.java  ``` private String getDestination(Payload payload) { 		if (this.metadataMimeType.equals(DefaultRSocketRequester.COMPOSITE_METADATA)) { 			CompositeMetadata metadata = new CompositeMetadata(payload.metadata(), false); 			for (CompositeMetadata.Entry entry : metadata) { 				String mimeType = entry.getMimeType(); 				if (DefaultRSocketRequester.ROUTING.toString().equals(mimeType)) { 					return entry.getContent().toString(StandardCharsets.UTF_8); 				} 			} 			return """"; 		} 		else if (this.metadataMimeType.equals(DefaultRSocketRequester.ROUTING)) { 			return payload.getMetadataUtf8(); 		} 		// Should not happen (given constructor assertions) 		throw new IllegalArgumentException(""Unexpected metadataMimeType""); 	} ```","closed","type: enhancement,","linux-china","2019-06-19T21:27:19Z","2019-06-28T21:06:37Z"
"","23135","RSocket Functional route & Kotlin DSL","Now functional route is useful feature for Spring WebFlux and SpringMVC, and it's possible to add this feature for RSocket?  Functional route is very convenient with functional style, especially for Kotlin, and all are functions and messages/events.   ```     @Bean     public RouterFunction locateRoutes() {         return RouterFunctions                 .route(RPC(""findId""), payload -> Mono.just(DefaultPayload.create(""hello"")))                 .andRoute(FIRE(""notifyLogin""), payload -> Mono.empty())                 .andRoute(STREAM(""accounts""), payload -> Flux.empty());     } ```  Two hard things: MessageMapping and payload data serialization. I like following style, and it's very useful sometimes.  ```     @MessageMapping(""users.{user}.info"")     Mono getUserInfo(@DestinationVariable String user, Body body) {         // ...     } ```","open","type: enhancement,","linux-china","2019-06-13T16:54:16Z","2019-06-20T08:46:26Z"
"","23082","nice to have : add empty value check","nice to have : add empty value check","closed","status: invalid,","liquanchen9","2019-06-04T12:24:02Z","2019-10-05T06:32:55Z"
"","23031","pull request","new pull request","closed","","husancode","2019-05-24T16:48:50Z","2022-02-18T19:10:15Z"
"","23422","Add a new RequestEntity$HeadersBuilder method","New `headers(MultiValueMap headers)` in RequestEntity$HeadersBuilder. Just like in ResponseEntity$HeadersBuilder.  In addition, made wider argument type: `headers(MultiValueMap headers)` instead of `headers(HttpHeaders headers)` on both Builders, for better polymorphism.  Issue: #23404","closed","status: superseded,","andluu","2019-08-06T14:40:23Z","2019-08-23T11:40:18Z"
"","23072","aop interception JpaRepository.findAll() is invalid","MyRepository extends JpaRepository my Aop Pointcut all MyRepository Method all method is ok, except JpaRepository.findAll() method is invalid","closed","for: stackoverflow,","jerryil","2019-06-03T01:51:12Z","2019-06-05T08:43:41Z"
"","23059","WebSocketStompClient exceed ping interval","My WebSocketStompClient created with default heart-beat (10000,10000). But without activity it can send ping sometimes with 15 seconds +- N ms. So stomp server just disconnected me after 15 sec without pings  The problem in this code ``` public void onWriteInactivity(final Runnable runnable, final long duration) {     Assert.state(getTaskScheduler() != null, ""No TaskScheduler configured"");     this.lastWriteTime = System.currentTimeMillis();     this.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {         if (System.currentTimeMillis() - this.lastWriteTime > duration) {             try {                 runnable.run();             }             catch (Throwable ex) {                 if (logger.isDebugEnabled()) {                     logger.debug(""WriteInactivityTask failure"", ex);                 }             }         }     }, duration / 2)); } ```  It rechecks inactivity with half-period... So client can exceed even 15 sec recheck period + network time.  It's far enough from target 10 sec Specification part: https://stomp.github.io/stomp-specification-1.2.html#Heart-beating  > the sender MUST send new data over the network connection at least every < n > milliseconds","open","in: messaging,","arkaev","2019-05-30T10:13:05Z","2021-11-10T12:01:02Z"
"","23373","Set up a server. The servlet. ContextPath = / my interceptor is based on the/my/began to intercept","Mr Ma set up a server. The servlet. ContextPath = / my The interceptor starts intercepting based on /my/ Such as: Registry. AddRedirectViewController (""/"", ""/ my/index. The HTML"") SetStatusCode (HttpStatus. PERMANENT_REDIRECT); Enter 127.0.0.1:8080/ cannot jump to /my/index.html properly","closed","for: stackoverflow,","purgeyao","2019-07-27T03:27:22Z","2019-07-29T10:26:41Z"
"","23670","Set name for shutdown hook Thread","Method `org.springframework.context.support.AbstractApplicationContext#registerShutdownHook` register shutdown hook Thread to close context on JVM shutdown, https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java#L941 But it doesn't set name for this Thread. It's common good practice to set proper names for java thread to make diagnostic and troubleshooting easier. I propose to set some name for shutdown hook Threads. For example `SpringContextShutdownHook-N` instead of current `Thread-N`.  This is how such threads look in Eclipse MAT ![image](https://user-images.githubusercontent.com/741251/65257232-96a38c00-db09-11e9-9c74-615335b9ebeb.png)","closed","type: enhancement,","turbanoff","2019-09-19T15:16:35Z","2019-09-20T11:18:39Z"
"","23413","Merge pull request #1 from spring-projects/master","merge spring-projects/spring-framework code","closed","status: invalid,","kiansoung","2019-08-03T15:25:26Z","2019-08-03T15:31:11Z"
"","23176","Merge pull request #1 from spring-projects/master","merge","closed","status: invalid,","xuanyhi","2019-06-21T14:40:23Z","2019-06-21T14:45:22Z"
"","23371","Make getters public in NamedParameterJdbcTemplate and ParsedSql","Make getters public in two public classes.","open","status: feedback-provided,","garydgregory","2019-07-26T15:08:56Z","2021-04-27T05:06:10Z"
"","23281","Use computeIfAbsent in LocalVariableTableParameterNameDiscoverer","Make `LocalVariableTableParameterNameDiscoverer` more atomic by using `computeIfAbsent`.","closed","in: core,","mfeng-ya","2019-07-12T06:20:01Z","2019-07-12T11:33:05Z"
"","23292","Fix dataMimeType and metadataMimeType mixup in precondition check","Mainly raising the issue I think I hit in debugging, so don't mind if someone takes this over.","closed","type: task,","yschimke","2019-07-15T20:27:22Z","2019-07-16T09:14:30Z"
"","23166","Use proxyBeanMethods=false in ProxyTransactionManagementConfiguration","Like in #23004 I find that `ProxyTransactionManagementConfiguration` probably could (should?) use `proxyBeanMethods` but doesn't.","closed","type: task,","dsyer","2019-06-20T14:36:19Z","2020-02-12T14:08:57Z"
"","23061","Add support for escaped delimiter in StringUtils when splitting strings","Let `StringUtils` read the values with delimiter inside, but escaping such delimiter with backward slash.","closed","status: declined,","fmcejudo","2019-05-30T13:08:38Z","2019-08-27T10:30:30Z"
"","23034","Tiny simplifications regarding usage of Iterator","Just a couple of simplifications","closed","type: task,","stsypanov","2019-05-25T18:24:40Z","2019-05-25T18:33:45Z"
"","23565","Use getAvailableExtensionNames from JettyWebServerFactory","Jetty 9.4.20 changed `ExtensionFactory` from abstract class to interface, causing a binary compatibility issue in our `JettyRequestUpgradeStrategy`. This was fixed with #23500, but in 9.4.21 Jetty [is reverting](https://github.com/eclipse/jetty.project/pull/4026/commits/6bcfa2dc6ef409ce0ef55b81d7765f63e4cd5b86) `ExtensionFactory` back to an abstract class while also deprecating `ExtensionFactory` and introducing a new `WebSocketServerFactory#getAvailableExtensionNames()` method to use instead.  We should switch to this new method after the 9.4.21 upgrade, and also keep the reflection based callback from #23500 to remain comatible with versions prior to 9.4.21.","closed","type: task,","rstoyanchev","2019-09-02T14:42:32Z","2019-10-23T16:33:57Z"
"","23333","In contrast to the Javadoc, ServerHttpRequest.Builder implementation does not override headers","Javadoc of `ServerHttpRequest.Builder` clearly says: https://github.com/spring-projects/spring-framework/blob/5190eaf503bf1c280a9b9671252f15b77d72defc/spring-web/src/main/java/org/springframework/http/server/reactive/ServerHttpRequest.java#L140  which is part of the `header(String, String)` method (signature can be seen below).  ``` /**  * Set or override the specified header.  */ Builder header(String key, String value); ``` but the default implementation (`DefaultServerHttpRequestBuilder`) uses an instance of `HttpHeaders`, which internally uses a `MultiValueMap` to store headers. So, calling the said method does not override the header, but adds it in the `MultiValueMap`.  Check the following links:  https://github.com/spring-projects/spring-framework/blob/5190eaf503bf1c280a9b9671252f15b77d72defc/spring-web/src/main/java/org/springframework/http/server/reactive/DefaultServerHttpRequestBuilder.java#L48  https://github.com/spring-projects/spring-framework/blob/5190eaf503bf1c280a9b9671252f15b77d72defc/spring-web/src/main/java/org/springframework/http/server/reactive/DefaultServerHttpRequestBuilder.java#L115  https://github.com/spring-projects/spring-framework/blob/5190eaf503bf1c280a9b9671252f15b77d72defc/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L417  https://github.com/spring-projects/spring-framework/blob/5190eaf503bf1c280a9b9671252f15b77d72defc/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L1622","closed","type: enhancement,","juanmbellini","2019-07-23T04:38:38Z","2019-07-25T12:12:49Z"
"","23075","Error in javadoc for o.s.web.servlet.function.ServerResponse","Javadoc for `writeTo` method of `org.springframework.web.servlet.function.ServerResponse` is not correct:  > Returns: Mono to indicate when writing is complete","closed","in: web,","ah1508","2019-06-03T12:58:51Z","2019-06-04T13:38:54Z"
"","23546","`@Autowired lateinit var` throw `kotlin.UninitializedPropertyAccessException` in custom validator when persistent  data by Jpa.","java version:11 kotlin version:1.3.41 springboot version: 2.1.6.RELEASE spring version: 5.1.8.RELEASE  Success when validate params in controller, throw `UninitializedPropertyAccessException` when validate entity classes before persistent data by jpa.  Use java also throws NPE.  ``` /**用户名的校验器。*/ open class UsernameValidator : ConstraintValidator { 	@Autowired private lateinit var validationProperties: ValidationProperties 	 	override fun isValid(value: String, context: ConstraintValidatorContext): Boolean { 		//6~16位的字母、数字和下划线。 		return value.matches(validationProperties.username.toRegex()) 	} } ```  //No problems in Controller  ``` //Service 	override fun registerByEmail(form: EmailRegisterForm): User { 		val savedUser = User( 			nickname = form.nickname, 			username = form.username, 			email = form.email, 			password = passwordEncoder.encode(form.password) 		) 		savedUser.activateCode = UUID.randomUUID().toString()                //throws `UninitializedPropertyAccessException` Here!!! 		return userRepository.save(savedUser) 	} ```  IU-191.8026.42, JRE 11.0.2 9-b159.64x64 JetBrains s.r.o, OS Windows 10(amd64) v10.0 , screens 1366x768","open","in: kotlin,","DragonKnightOfBreeze","2019-08-30T05:23:44Z","2022-01-19T10:55:48Z"
"","23678","AnnotationConfigurationException during @AliasFor processing on Java 14","Java version: 14-ea+15-621  Trying to evaluate `ConditionalOnMissingFilterBean` by running a Spring Boot application using JPA fails on Java 14 with the following exception:  Stack trace:  ``` org.springframework.core.annotation.AnnotationConfigurationException: @AliasFor declaration on attribute 'value' in annotation [org.springframework.boot.autoconfigure.web.servlet.ConditionalOnMissingFilterBean] declares an alias for attribute 'value' in annotation [org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean] which is not meta-present. 	at org.springframework.core.annotation.AnnotationTypeMapping.validateAllAliasesClaimed(AnnotationTypeMapping.java:335) 	at org.springframework.core.annotation.AnnotationTypeMapping.afterAllMappingsSet(AnnotationTypeMapping.java:322) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1510) 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:62) 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:217) 	at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:213) 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:181) 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:168) 	at org.springframework.core.annotation.TypeMappedAnnotation.of(TypeMappedAnnotation.java:632) 	at org.springframework.core.annotation.MergedAnnotation.of(MergedAnnotation.java:593) 	at org.springframework.core.type.classreading.MergedAnnotationReadingVisitor.visitEnd(MergedAnnotationReadingVisitor.java:96) 	at org.springframework.asm.ClassReader.readElementValues(ClassReader.java:2775) 	at org.springframework.asm.ClassReader.accept(ClassReader.java:572) 	at org.springframework.asm.ClassReader.accept(ClassReader.java:400) 	at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:50) 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:103) 	at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.createMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:86) 	at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.getMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:73) 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:81) 	at org.springframework.context.annotation.ConfigurationClassParser.asSourceClass(ConfigurationClassParser.java:686) 	at org.springframework.context.annotation.ConfigurationClassParser$SourceClass.getMemberClasses(ConfigurationClassParser.java:977) 	at org.springframework.context.annotation.ConfigurationClassParser.processMemberClasses(ConfigurationClassParser.java:347) 	at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:266) 	at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) 	at org.springframework.context.annotation.ConfigurationClassParser.processImports(ConfigurationClassParser.java:587) 	... 46 common frames omitted ```  Links:  * Reproducer: https://github.com/spring-projects/spring-data-examples/blob/master/jpa/example/src/test/java/example/springdata/jpa/custom/UserRepositoryCustomizationTests.java * CI job: https://travis-ci.org/spring-projects/spring-data-examples/jobs/586895698 * [full-trace.txt](https://github.com/spring-projects/spring-framework/files/3641066/full-trace.txt)","closed","in: core,","mp911de","2019-09-23T07:39:47Z","2022-06-27T12:38:33Z"
"","23655","AbstractResource causes early log4j initialization","It's similar to https://github.com/spring-projects/spring-framework/issues/16934 and https://github.com/spring-projects/spring-framework/issues/10645, introduced by https://github.com/spring-projects/spring-framework/issues/23116 with commit https://github.com/spring-projects/spring-framework/commit/049437e11106f45b7fdc155225b06680aeb165cb#diff-080763d75126bdb9900ccb3abd85fa0b , `logAccessor` should be created on demand.","closed","in: core,","quaff","2019-09-18T09:35:31Z","2019-09-20T19:56:34Z"
"","22956","Iteration over a map using EntrySet","It's not necessary to call Map::get when traversing the map using Map::keyset while Map::entrySet can be used intead.","closed","","stsypanov","2019-05-13T12:54:39Z","2022-02-18T19:10:11Z"
"","23391","Remove MergedAnnotations.SearchStrategy.EXHAUSTIVE","It's deprecated for RC1 but since it was only introduced in 5.2 we can remove it.","closed","in: core,","philwebb","2019-07-31T14:06:10Z","2019-08-07T10:35:40Z"
"","23455","Avoid storing unnecessary beanName in ApplicationListenerDetector","it would store name that implementation of the **ApplicationListener** rather than store all names","closed","","GungnirLaevatain","2019-08-13T02:22:12Z","2022-02-18T19:07:10Z"
"","23016","Allow to retrieve the total number of subscriptions from DefaultSubscriptionRegistry","It would be nice if `org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry` allowed to retrieve the number of currently active subscriptions. Sending that value periodically to a metrics aggregation system would allow to have alerts when the number of subscriptions becomes inconsistent with expectations.","closed","in: messaging,","bgK","2019-05-22T08:54:10Z","2021-09-07T14:48:37Z"
"","23491","DefaultWebClientBuilder default ClientHttpConnector by classpath","It would be nice if [DefaultWebClientBuilder#initExchangeFunction](https://github.com/spring-projects/spring-framework/blob/aa6e762dcfc5250bd6cffe84cef9e3003b6797ce/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClientBuilder.java#L237) was smart enough to select the default `ClientHttpConnector` based upon classpath. This would make it so that it worked with both Netty and Jetty based `ClientHttpConnector` without needing to explicitly configure the `ClientHttpConnector`.","closed","status: superseded,","rwinch","2019-08-20T15:17:56Z","2019-08-20T18:17:29Z"
"","23774","Variant of ObjectProvider.orderedStream() which provides name/value pairs","It would be great if there was a variation of ObjectProvider.orderedStream() which provides not just the beans themselves, but the beans paired with their bean names.  Use case:  In writing frameworks for internal services, quite often it's important to pull in a series of beans of the same type, and ordering is important.  We use orderedStream() for many situations, but there are a number which require the bean name as well.  While we can use getBeansOfType().entrySet().stream() from the application context, it's not as clean as using ObjectProvider.orderedStream().  Most importantly, I'd prefer from a clean code perspective to not inject GenericApplicationContext everywhere, but be explicit in the types we need by using ObjectProvider.","closed","in: core,","blake-bauman","2019-10-09T13:16:54Z","2022-08-02T19:34:50Z"
"","23338","Consider generics when predicting FactoryBean types","It would be beneficial if we could consider generics when trying to predict the result of `FactoryBean.getObjectType()`. We currently have difficulty with `getBeanNamesForType` if the bean being considered is a factory bean and we don't want to initialize it early.  It's possible that we can still deduce the type using generics of the factory method, or the class itself. For example:  ```java @Bean public FactoryBean myBean() {     ... } ```  ```java public class MyFactoryBean implements FactoryBean {     ... } ```  We have logic to do this already as part of `DefaultListableBeanFactory.getTypeForFactoryBean`, however, in its current form that method  may also cause early initialization of the bean.","closed","type: enhancement,","philwebb","2019-07-23T09:57:07Z","2019-08-01T07:02:54Z"
"","23600","ProxyTransactionManagementConfiguration is not eligible for getting processed by all BeanPostProcessors","It seems that it was initialized too early #### steps to reproduce this issue: - download simple code from start.spring.io - add the following dependencies: `spring-boot-starter-cache`,`spring-boot-starter-data-jpa`,`spring-boot-starter-web` - add `@EnableCaching` to the startup class - then run the application *** Next, you will see the output on the console. `Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)`","closed","status: feedback-provided,","liaozan","2019-09-06T16:07:09Z","2019-09-11T16:03:49Z"
"","23003","DefaultMultipartMessageReader Not Parsing MultiPart Form Message Correctly","It seems like the introduction of `DefaultMultipartMessageReader` may not be parsing the message correctly.  https://github.com/spring-projects/spring-framework/commit/fb642ce7235d390323081d6b158a7a74b623a595  After the introduction of this class, a test in Spring Cloud Gateway that was working started failing.  All the test does is use WebClient to create a multipart form request.  When Netty receives this request it fails with   ``` java.lang.IllegalArgumentException: text is empty (possibly HTTP/0.9) 	at io.netty.handler.codec.http.HttpVersion.valueOf(HttpVersion.java:65) ~[netty-codec-http-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.handler.codec.http.HttpRequestDecoder.createMessage(HttpRequestDecoder.java:87) ~[netty-codec-http-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:210) ~[netty-codec-http-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder.decode(HttpServerCodec.java:103) ~[netty-codec-http-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) ~[netty-codec-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) ~[netty-codec-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) ~[netty-codec-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:682) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:617) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:534) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) [netty-transport-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) [netty-common-4.1.36.Final.jar:4.1.36.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.36.Final.jar:4.1.36.Final] 	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91] ```  The test can be found here  https://github.com/spring-cloud/spring-cloud-gateway/blob/master/spring-cloud-gateway-core/src/test/java/org/springframework/cloud/gateway/test/FormIntegrationTests.java#L73","closed","in: web,","ryanjbaxter","2019-05-20T18:40:19Z","2019-05-28T09:14:11Z"
"","23254","Simple method for converting lists","It might be good a simple method in Conversion Service to easily convert generic lists to some other target list. Like:  ```java var List newItems = conversionService.convertList(items, MyTargetPojo.class); ```","closed","in: core,","firatkucuk","2019-07-09T08:49:07Z","2021-11-16T13:26:05Z"
"","23745","spring 5.2 dist.zip naming issue","It looks like the spring-5.2.0.RELEASE-dist.zip release file has some misformed folder name in it. See attached. ![spring52dist](https://user-images.githubusercontent.com/46605044/66018538-7c749100-e4ad-11e9-8340-ade89c8768a7.jpg)","closed","type: bug,","JohnZ1385","2019-10-02T04:42:57Z","2019-10-02T08:08:46Z"
"","22932","HeaderResultMatchers should not import org.junit.Assert","It looks like `HeaderResultMatchers` is accidentally importing `org.junit.Assert.assertNotNull` rather than our own `org.springframework.test.util.AssertionErrors`.  I wonder if we can put a checkstyle rule to prevent junit imports in src/main","closed","type: regression,","philwebb","2019-05-09T00:28:45Z","2019-05-13T15:45:13Z"
"","22916","Add a space in the documentation index file","It just hurt my eyes, a missing space on the first page you see when you start reading the documentation.  Have a nice day :)","closed","type: task,","Nicofisi","2019-05-07T11:17:11Z","2019-05-07T11:30:26Z"
"","23618","Allow @RequestParam, @PathVariable, and their siblings on fields","It is common to use abbreviated names for query parameters in `GET` requests.   For example:  ```text GET /search?q=java&y=2019&l=eng ```  Where `q` means query, `y` means year, and `l` means language.  This can then be handled using a controller method:  ```java public SomeResponse search(SearchRequest request) { ... } ```  where:  ```java public class SearchRequest {    private String q;    private String y;    private String l; } ```  However if we could apply `@RequestParam` on fields, then we could make `SearchRequest` more readable:  ```java public class SearchRequest {    @RequestParam(""q"")    private String query;     @RequestParam(""y"")    private String year;     @RequestParam(""l"")    private String language; } ```  As shown in the linked SO post, it is possible to customize Spring to do this using a custom annotation (e.g. `@ParamName`), but I think it would be cleaner and more elegant to allow `@RequestParam` (and `@PathVariable`, etc.) on POJO fields.  #### References  1. [StackOverflow: How to customize parameter names when binding Spring MVC command objects](https://stackoverflow.com/questions/8986593/how-to-customize-parameter-names-when-binding-spring-mvc-command-objects).","open","type: enhancement,","behrangsa","2019-09-11T08:30:33Z","2021-04-27T09:38:25Z"
"","23435","Avoid unnecessary processing in ApplicationContextAwareProcessor","It could return bean that do not meet the requirements immediately to avoid subsequent operations","closed","in: core,","GungnirLaevatain","2019-08-08T15:34:55Z","2019-08-09T13:17:15Z"
"","23335","Add missing ResolvableType variants of getBeanNamesForType","Issue [SPR-12147](https://github.com/spring-projects/spring-framework/issues/16761) added the following method to `ListableBeanFactory`:  ```java String[] getBeanNamesForType(ResolvableType type); ```  With #23056 we now have a need for the `includeNonSingletons` and `allowEagerInit` boolean parameters that are available on the `Class` variant.","closed","type: enhancement,","philwebb","2019-07-23T09:43:20Z","2019-07-31T10:23:28Z"
"","23385","Deprecate mutable aspects of MethodParameter","Issue #23352 has shown that the mutable nature of `MethodParameter` can cause problems. One particularly unusual aspect is that `getContainingClass()` can change as a side effect of calling `GenericTypeResolver.resolveParameterType()`.  Internally, we don't actually mutate `MethodParameter` instances that often so it's possible that we could deprecate the mutation methods in favor of calls that return a new instance.","closed","type: enhancement,","philwebb","2019-07-30T14:21:29Z","2019-08-01T07:31:06Z"
"","23302","Problem with configure DefaultFormattingConversionService","Is there any method can configure DefaultFormattingConversionService? I can`t find any method to configure the default Formatters. The default DefaultFormattingConversionService created by BackgroundPreinitializer(spring-boot), and i can`t override it with bean or configure it.","closed","status: duplicate,","zsword","2019-07-17T01:03:13Z","2019-07-17T05:06:51Z"
"","23772","Multipart request support in MockRestServiceServer","Introduce `MultipartFormDataRequestMatchers` for `MockRestServiceServer`. Handles **ONLY** `multipart/form-data` requests.  E.g. ``` MockRestServiceServer mockServiceServer = MockRestServiceServer.createServer(restTemplate); MultiValueMap filesMultiMap = new LinkedMultiValueMap<>(); filesMultiMap.add(foo.getName(), foo.getResource()); filesMultiMap.add(bar.getName(), bar.getResource());  MultiValueMap paramsMultiMap = new LinkedMultiValueMap<>(); paramsMultiMap.add(""fooParam"", ""foo value""); paramsMultiMap.add(""barParam"", ""bar value"");  mockServiceServer.expect(ExpectedCount.once(), requestTo(""/foobar""))                 .andExpect(method(POST))                 .andExpect(content().multipart().param(""foo"", ""bar""))                 .andExpect(content().multipart().param(""foo"", ""bar"", ""baz""))                 .andExpect(content().multipart().params(paramsMultiMap))                  .andExpect(content().multipart().file(""fooFile"",  foo.getBytes()))                 .andExpect(content().multipart().file(""fooBarFile"",  fooResource, barResource))                 .andExpect(content().multipart().file(""bazFile"",  customResourceMatcher))                 .andExpect(content().multipart().files(""fooBarFile"",  filesMultiMap))                  .andRespond(withSuccess().location(URI.create(""/foobar/123""))); ```  Related to https://github.com/spring-projects/spring-framework/pull/23671 which handles `x-www-form-urlencoded` requests","closed","type: enhancement,","spac-valentin","2019-10-09T09:46:45Z","2020-06-18T07:11:22Z"
"","22989","OncePerRequestFilter does not work properly on Error Dispatch on Jetty","Instances of `OncePerRequestFilter` do not get invoked for error dispatch types on Jetty (works on Tomcat) even when the following conditions are true:  - The Filter is configured to dispatch on error dispatch types - The Filter returns `false` for `shouldNotFilterErrorDispatch`  # Sample  https://github.com/rwinch/onceperrequest-error-dispatch","closed","type: enhancement,","rwinch","2019-05-17T22:49:06Z","2019-06-07T20:09:48Z"
"","23018","Provide utility for writing Properties to a file in a repeatable manner","Instances of `java.util.Properties` are typically written to file using `Properties#store`. Since this method also writes a timestamp in a comment, its use is problematic in projects that need to have [reproducible builds](https://reproducible-builds.org/).  If Spring Framework could provide utility for writing `Properties` to a file in a repeatable manner, this would IMO be of great benefit to all Spring projects. There are already several issues/PRs that are blocked due to the shortcomings of `Properties#store`:  - spring-projects/spring-boot#14494 - #22383  /cc @dsyer @wilkinsona","closed","type: enhancement,","vpavic","2019-05-23T16:14:10Z","2019-05-28T10:40:20Z"
"","23646","Provide a Kotlin DSL for CORS","Inspired from https://github.com/spring-projects/spring-fu/commit/c360bab5c0f62cda2ebd85e8c0adc3aadc1f63c6.  ```kotlin cors { 	""/api/**"" { 		allowedOrigins = listOf(""first.example.com"", ""second.example.com"") 		allowedMethods = listOf(""GET"", ""PUT"", ""POST"", ""DELETE"") 	} 	""/static/**"" { 		allowedOrigins = listOf(""full.config.example.com"") 		allowedMethods = listOf(""GET"") 		allowedHeaders = listOf(""*"") 		exposedHeaders = listOf(""Content-Location"") 		allowCredentials = true 		maxAge = 3600 	} 	path(""/public/**"") // Enable CORS with permit default values } ```","open","type: enhancement,","sdeleuze","2019-09-17T10:22:15Z","2020-08-10T12:47:55Z"
"","23116","Log exception when closing InputStream in AbstractResource","Inspired by [this dicussion](https://github.com/spring-projects/spring-framework/pull/23103/files#r291836618), let's log exceptions at DEBUG level for exceptions thrown when closing an `InputStream` in `AbstractResource`.","closed","type: enhancement,","sbrannen","2019-06-12T10:35:55Z","2019-06-12T11:08:45Z"
"","23117","Thread-safe removal of destruction callbacks in web scopes","Inspired by #22929, it turns out that our web scope implementations remove the destruction callbacks after removing the instance attribute themselves. This exposes a potential race condition where we might remove a newly registered destruction callback from some other thread that triggered re-creation of the same scoped bean in the meantime. It is safer and in line with the semantics of scoped destruction callbacks to remove the destruction callbacks first so that once the instance is being removed, some other thread may immediately register a new destruction callback.  That aside, as pointed out in #22929, `ServletContextScope` should use synchronization for its `destructionCallbacks` data structure for immediate thread-safe visibility of the current state in case of lazy bean initialization at runtime (beyond the startup thread).","closed","type: enhancement,","jhoeller","2019-06-12T10:55:26Z","2019-06-12T12:20:40Z"
"","23341","Provide functionality similar to Spring Boot's BeanTypeRegistry","Initial attempt at fixing the issues raised from #23056. Since these changes are quite core, careful review is required.","closed","type: enhancement,","philwebb","2019-07-23T11:24:57Z","2019-07-31T10:22:05Z"
"","22882","encoding in wrong place","In this piece of code, the encoding is done after build method so having no effect over the call.  https://github.com/spring-projects/spring-framework/blob/83046531da12dde914fb677b65c2d2b449e039df/spring-test/src/main/java/org/springframework/test/web/client/match/MockRestRequestMatchers.java#L100","closed","status: declined,","leassis","2019-05-03T15:44:10Z","2019-05-15T17:52:29Z"
"","22827","Fix suspending handler method type handling","In Spring Framework 5.2 M1, suspending handler methods type is `Any` (Kotlin equivalent of `Object`) because [they are unwrapped](https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageWriterResultHandler.java#L125). This should be fixed.","closed","type: bug,","sdeleuze","2019-04-23T08:58:43Z","2019-04-23T09:39:57Z"
"","22995","Open a hook point to further customize how @ComponentScan works","In Spring Boot 2, we've introduced a custom scan of `@ConfigurationProperties` types and we're not sure if that's a good idea as we've noticed our test slicing feature is broken. We customize the classpath filters in that case and our special handling does not kick because of the custom scan code.  We are wondering how we could integrate this feature in the ""regular"" component scan. The following features are needed:  * Declare an include filter for `@ConfigurationProperties` annotated type as they are not meta-annotated with `@Component` at the moment * Being able to further tune the bean name when such annotation is found (for backward compatibility reason) * Being able to customize the `BeanDefinition`, including returning a custom sub-class  A `ConfigurationProperties` type can use JavaBeans properties injection or constructor injection for the immutable version. As such, flagging it as a `@Component` won't work as the core container would try to identify the beans it has to use to create the instance.   We have [a custom bean definition with a Supplier](https://github.com/spring-projects/spring-boot/blob/6998b7c30c2541ee913ffaa6450a81acbf478209/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/ConfigurationPropertiesBeanDefinition.java) that does all the heavy lifting. We also have a post-processor to bind beans that have been contributed via java config and the subclass is the way of checking binding already occurred.  Looking at `ComponentScanAnnotationParser` I wonder if opening up the API to offer a way to tune those things would be desirable. Any other recommendations for this?","closed","in: core,","snicoll","2019-05-20T07:58:02Z","2019-07-15T13:51:14Z"
"","23762","Fix typo in rsocket doc","In rsocket.adoc, there is a typo in a Java code snippet   This typo is only affecting master (5.2).","closed","type: documentation,","revfactory","2019-10-06T13:40:03Z","2019-10-06T14:34:35Z"
"","23328","Publish STOMP WebSocket client as single artifact","In our project (embedded java application), we need a standalone STOMP websocket client without additional dependencies (such as spring-messaging and spring-web) to avoid jar hell with client code.  As a ""workaround"", we use such an ugly hack in our pom. ![image](https://user-images.githubusercontent.com/47082582/61622998-8e9cac80-ac7e-11e9-8948-f31a585df3d3.png)  Thank you for the awesome spring! :)","closed","status: declined,","somjik-api","2019-07-22T09:49:49Z","2019-07-23T15:08:16Z"
"","23667","In spring-mvc module doDispatch method, should we move getHandler method in front of checkMultipart method","In our production environment, abusers try to request invalid urls, but the urls are not exist in our controller so we want to return a 404, but the attackers build invalid file-upload requests, spring call the checkMultipart first then the program encounter an exception in the checkMultipart method because of invalid file-upload requests and return a 500, so should we move getHandler method in front of checkMultipart method to avoid this.","closed","status: invalid,","liu316484231","2019-09-19T05:24:22Z","2019-09-26T10:59:43Z"
"","23289","Add multi-prefix comment support for SQL scripts","In order to [fix this Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/17435) we'd like to be able to process quartz SQL scripts that contain comments starting with `#` or `--`. Currently our support is limited to just a single prefix.  This pull request adds multi-prefix support to both `ResourceDatabasePopulator` and `ScriptUtils`.","closed","type: enhancement,","philwebb","2019-07-14T11:19:37Z","2019-07-22T19:40:41Z"
"","23405","InitializeDatabaseBeanDefinitionParser sets a non-null DatasourceInitialier.databaseCleaner even if there are no cleanup scripts","In my project, we define database initialization scripts via `jdbc:initialize-database` element.  ```                                             ```  There are no cleanup scripts (no entries with `execution=""DESTROY""`), yet the `DataSourceInitializer` bean tries to open a database connection when the context is shutting down. This slows down the shutdown process, especially when the connection times out.  The source code of `DataSourceInitializer` contains a null check on `this.databaseCleaner`: ``` 	@Override 	public void destroy() { 		execute(this.databaseCleaner); 	}  	private void execute(DatabasePopulator populator) { 		Assert.state(this.dataSource != null, ""DataSource must be set""); 		if (this.enabled && populator != null) { 			DatabasePopulatorUtils.execute(populator, this.dataSource); 		} 	} ```  However, `DatabasePopulatorConfigUtils.setDatabasePopulator` always creates a non-null value for `databaseCleaner`, even if the object is effectively a no-op.  The problem happens in spring-jdbc 4.3.14 and 5.1.7","open","in: data,","MateuszStefek","2019-08-02T13:37:55Z","2021-11-10T11:38:07Z"
"","23473","allow global settings for rollbackFor and noRollbackFor fo @Transactional","In Kotlin all exceptions are effectively unchecked. Therefore, transactions will not be rolled back for functions like this:  ``` @Transactional fun example(): Unit {   runQuery()   throw MyCheckedException()   runQuery() } ```  to achieve a correct behavior, the above code needs to be refactored as follows:  ``` @Transactional(rollbackFor = [Exception::class]) fun example(): Unit {   runQuery()   throw MyCheckedException()   runQuery() } ```  this isn't very intuitive and can lead to unexpected results. Furthermore, even if a developer is aware of this, he/she should not forget to specify `rollbackFor` for every `@Transactional` annotation.  **It should be possible to configure application-wide defaults for `rollbackFor` and `noRollbackFor`**","open","in: data,","ilyastam","2019-08-16T18:52:36Z","2021-11-10T09:27:05Z"
"","22888","Rename PayloadArgumentResolver to PayloadMethodArgumentResolver","In alignment with the new reactive packages introduced in #21987, let's rename `PayloadArgumentResolver` to `PayloadMethodArgumentResolver` (also aligning it with the other `HandlerMethodArgumentResolver` implementation names in its own package).","closed","type: task,","jhoeller","2019-05-04T15:24:39Z","2019-05-04T15:36:42Z"
"","23547","Provide access to non-standard status codes from ServerHttpResponse","In a similar vein to https://github.com/spring-projects/spring-framework/issues/22872, it would be useful to have access to the raw status code rather than `null` when dealing with a response with a status code that is not known to `HttpStatus`.","closed","type: enhancement,","wilkinsona","2019-08-30T08:01:47Z","2019-09-18T09:41:06Z"
"","23739","Fix typo in web-uris doc","In `web-uris.adoc`, there is a typo in a Java code snippet that builds a `URI`: `RI` when it should be `URI`.  This typo is only affecting master (5.2).","closed","type: documentation,","drumonii","2019-10-01T13:06:55Z","2019-10-01T13:10:57Z"
"","22933","WebFlux AbstractView does not update BindingResult for resolved async attributes","In `ViewResolutionResultHandler.handleResult()` we have   ```java 	updateBindingContext(result.getBindingContext(), exchange);  	return viewsMono.flatMap(views -> render(views, model.asMap(), exchange)); ```  so the binding context is updated before rendering starts. Later as part of rendering, `AbstractView` calls `resolveAsyncAttributes` to resolve Mono and Flux attributes in the model to concrete values, but the `BindingResult` for each of those attributes are not updated accordingly.  This means that any `View` that inspects the `BindingResult` to find out about field errors etc. will break, e.g.  ``` Caused by: org.springframework.beans.NotReadablePropertyException: Invalid property 'firstName' of bean class [reactor.core.publisher.MonoOnAssembly]: Bean property 'firstName' is not readable or has an invalid getter method: Does the return type of the getter match the parameter type of the setter?     at org.springframework.beans.AbstractNestablePropertyAccessor.getPropertyValue(AbstractNestablePropertyAccessor.java:622)     at org.springframework.beans.AbstractNestablePropertyAccessor.getPropertyValue(AbstractNestablePropertyAccessor.java:612)     at org.springframework.validation.AbstractPropertyBindingResult.getActualFieldValue(AbstractPropertyBindingResult.java:104)     at org.springframework.validation.AbstractBindingResult.getFieldValue(AbstractBindingResult.java:228)     at org.springframework.web.reactive.result.view.BindStatus.(BindStatus.java:127)     at org.springframework.web.reactive.result.view.RequestContext.getBindStatus(RequestContext.java:442)     at org.thymeleaf.spring5.context.webflux.SpringWebFluxThymeleafRequestContext.getBindStatus(SpringWebFluxThymeleafRequestContext.java:227)     at org.thymeleaf.spring5.util.FieldUtils.getBindStatusFromParsedExpression(FieldUtils.java:306)     at org.thymeleaf.spring5.util.FieldUtils.getBindStatus(FieldUtils.java:253) ... ```","closed","type: bug,","dsyer","2019-05-09T07:14:17Z","2019-05-17T00:51:22Z"
"","23039","StompSubProtocolHandler does not close the connection after sending an ERROR frame","In `StompSubProtocolHandler`, when handling a message received from the client, if an exception is thrown when sending the message to the output `MessageChannel`, the default error handler sends an ERROR frame to the client.  According to the STOMP 1.2 specification, the broker must close the connection after sending an ERROR frame: https://stomp.github.io/stomp-specification-1.2.html#ERROR  This is what I have been observing: * Before the client connects ``` $ netstat -tnp | grep 25833 | wc -l 5 ```  * With a breakpoint in `StompSubProtocolHandler` before the error is sent: ``` $ netstat -tnp | grep 25833 | wc -l 6 ```  * After the error is sent: ``` $ netstat -tnp | grep 25833 | wc -l 6 ```  * After closing the client: ``` $ netstat -tnp | grep 25833 | wc -l 5 ```  This is an issue for me because I'm checking a JWT token in an interceptor for the CONNECT frame. If the server says the token is expired, the client is supposed to renew it and re-try connecting. However, as the connection is never closed by the server, the client never re-tries connecting.  Maybe `ExceptionWebSocketHandlerDecorator` was supposed to close the connection, but as the exception is caught in `StompSubProtocolHandler`, it never has a chance to do so.  Edit: This happens only when `StompSubProtocolHandler.errorHandler` is null. When using `StompSubProtocolErrorHandler` the behavior is correct.","closed","type: bug,","bgK","2019-05-27T13:24:49Z","2019-06-03T20:36:59Z"
"","23015","Expose StompSubProtocolHandler and StompBrokerRelayMessageHandler metrics","In #22807, the metrics for `StompSubProtocolWebSocketHandler` were made accessible so their can be sent to metrics aggregation systems.  It would be nice if the metrics for `StompSubProtocolHandler` and `StompBrokerRelayMessageHandler` were made accessible as well following the same reasoning.","closed","type: enhancement,","bgK","2019-05-22T08:36:01Z","2019-05-23T22:33:40Z"
"","23228","RestTemplate method patchForObject should also support Void response types","In #13216 (see commit c472a163f114ba946974980be299deb0a7cb7f34), `exchange()` was adjusted so that it could handle `Void` response types.  I am currently using this for testing as my patch endpoint returns a 204.   I was trying to implement the same using the `patchForObject()` method but ran into a type issue:  ```java ResponseEntity responseEntity = this.testRestTemplate.exchange(testUri + ENDPOINT_USER, HttpMethod.PATCH, new HttpEntity<>(userUpdate), Void.class);  ResponseEntity responseEntity2 = this.testRestTemplate.patchForObject(testUri + ENDPOINT_USER, new HttpEntity<>(userUpdate), Void.class); ```    I face incompatible types with the second example.","closed","type: enhancement,","xXInfamousWolf","2019-07-03T01:24:10Z","2019-07-03T08:12:49Z"
"","23416","Fix grammar in integration.adoc","Improve description for better","closed","status: declined,","KangZhiDong","2019-08-04T14:37:24Z","2019-08-09T11:16:29Z"
"","23407","Fix grammar in integration.adoc","Improve description for better","closed","","KangZhiDong","2019-08-02T17:04:27Z","2022-02-18T19:07:08Z"
"","23401","Fix grammar in package-info.java","Improve description for better","closed","type: documentation,","KangZhiDong","2019-08-02T02:30:47Z","2019-08-02T11:40:43Z"
"","23255","convertList method added","Implementation for #23254  A simple method for converting lists in an iterative way. Considered to get converter outside of the loop but getConverter method uses a cache mechanism and fetches from a HashMap this means. it's already O(1).","closed","in: core,","firatkucuk","2019-07-09T09:12:29Z","2021-11-16T13:26:38Z"
"","22927","Getters for LocalSessionFactoryBeans","Implement public getter methods for LocalSessionFactoryBean  Motivation: we have extended LSFB in order to perform additional actions to compute the `annotatedClasses`. In general, it would be advisable that a class extending the LSFB can read the properties other than setting them.  For example, if you want to _add_ an annotated class using your own logic, you can invoke both `getAnnotatedClasses`, edit the array, and then `setAnnotatedClasses` with the new array.  In this scenario, it could also have been possible to add a `protected addAnnotatedClasses` or `protected addXXX` method","closed","status: declined,","djechelon","2019-05-08T16:42:34Z","2021-12-10T22:18:40Z"
"","23097","WebFlux retryBackoff() not works with exchange()","If you use retrieve() method all works fine:  ```java       boolean send(String event) {            Response response = webClient.post()                   .body(fromObject(event))                   .retrieve()                   .bodyToMono(Response.class)                   .retryBackoff(numRetries, firstBackoff, maxBackoff, jitterFactor)                   .doOnError(t -> log.error(""Some problems with request"", t))                   .onErrorReturn(ERROR)                   .block();            if (response != null && response.error) {               log.error(""Can't send event to OpenBroker"");               return false;           }            return true;     }      public static class Response {         private final boolean error;     } ```  for test you can use OkHttp MockWebServer (setup numRetries = 2 before): ```java     void test() {         MockWebServer  server = new MockWebServer();         server.start(InetAddress.getByName(""localhost"", ""8888"");          MockResponse response = new MockResponse();         response.setResponseCode(HttpStatus.INTERNAL_SERVER_ERROR.value());          server.enqueue(response);         server.enqueue(response);         server.enqueue(response);         assertFalse(send(""test""));     } ``` In logs you can see that webClient send 3 request and next thrown IllegalStateException: ```java jun. 07, 2019 4:38:38 PM okhttp3.mockwebserver.MockWebServer$4 processOneRequest INFO: MockWebServer[8888] received request: POST / HTTP/1.1 and responded: HTTP/1.1 500 Server Error 16:38:38.949 DEBUG [reactor-http-nio-4] o.s.w.r.f.c.ExchangeFunctions [LogFormatUtils.java:91] [1dbeedff] Response 500 INTERNAL_SERVER_ERROR 16:38:39.023 DEBUG [parallel-2] o.s.w.r.f.c.ExchangeFunctions [LogFormatUtils.java:91] [1dbeedff] HTTP POST http://localhost:8888 jun. 07, 2019 4:38:39 PM okhttp3.mockwebserver.MockWebServer$4 processOneRequest INFO: MockWebServer[8888] received request: POST / HTTP/1.1 and responded: HTTP/1.1 500 Server Error 16:38:39.028 DEBUG [reactor-http-nio-4] o.s.w.r.f.c.ExchangeFunctions [LogFormatUtils.java:91] [1dbeedff] Response 500 INTERNAL_SERVER_ERROR 16:38:39.079 DEBUG [parallel-4] o.s.w.r.f.c.ExchangeFunctions [LogFormatUtils.java:91] [1dbeedff] HTTP POST http://localhost:8888 jun. 07, 2019 4:38:39 PM okhttp3.mockwebserver.MockWebServer$4 processOneRequest INFO: MockWebServer[8888] received request: POST / HTTP/1.1 and responded: HTTP/1.1 500 Server Error 16:38:39.138 DEBUG [reactor-http-nio-4] o.s.w.r.f.c.ExchangeFunctions [LogFormatUtils.java:91] [1dbeedff] Response 500 INTERNAL_SERVER_ERROR 16:38:39.140 DEBUG [reactor-http-nio-4] o.s.w.r.f.c.ExchangeFunctions [ExchangeFunctions.java:105] [1dbeedff] Cancel signal (to close connection) 16:38:39.143 ERROR [reactor-http-nio-4] i.k.c.s.o.OpenBrokerNoClient [OpenBrokerNoClient.java:304] Some problems with request to Open broker java.lang.IllegalStateException: Retries exhausted: 2/2 	at reactor.core.publisher.FluxRetryWhen.lambda$null$0(FluxRetryWhen.java:260) 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:350) 	at reactor.core.publisher.FluxIndex$IndexSubscriber.onNext(FluxIndex.java:95) 	at reactor.core.publisher.DirectProcessor$DirectInner.onNext(DirectProcessor.java:333) 	at reactor.core.publisher.DirectProcessor.onNext(DirectProcessor.java:142) 	at reactor.core.publisher.SerializedSubscriber.onNext(SerializedSubscriber.java:89) 	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:160) 	<...> 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at java.base/java.lang.Thread.run(Thread.java:834) Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$InternalServerError: 500 Internal Server Error 	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:196) 	at org.springframework.web.reactive.function.client.DefaultWebClient$DefaultResponseSpec.lambda$createResponseException$13(DefaultWebClient.java:495) 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:100) 	... 45 common frames omitted 16:38:39.143 ERROR [main] i.k.c.s.o.OpenBrokerNoClient [OpenBrokerNoClient.java:310] Can't send event to OpenBroker jun. 07, 2019 4:38:39 PM okhttp3.mockwebserver.MockWebServer$3 acceptConnections ```  If you try use exchange() method with retryBackoff() you will see that send only 1 request: ```java       boolean send(String event) {            Response response = webClient.post()                   .body(fromObject(event))                   .exchange()                   .flatMap(clientResponse -> clientResponse.bodyToMono(Response.class))                   .retryBackoff(numRetries, firstBackoff, maxBackoff, jitterFactor)                   .doOnError(t -> log.error(""Some problems with request"", t))                   .onErrorReturn(ERROR)                   .block();            if (response != null && response.error) {               log.error(""Can't send event to OpenBroker"");               return false;           }            return true;     }      public static class Response {         private final boolean error;     } ```  Run same test and you will see in logs: ```java jun. 07, 2019 4:51:57 PM okhttp3.mockwebserver.MockWebServer$4 processOneRequest INFO: MockWebServer[8888] received request: POST / HTTP/1.1 and responded: HTTP/1.1 500 Server Error 16:51:57.132 DEBUG [reactor-http-nio-4] o.s.w.r.f.c.ExchangeFunctions [LogFormatUtils.java:91] [7c4ca87c] Response 500 INTERNAL_SERVER_ERROR jun. 07, 2019 4:51:57 PM okhttp3.mockwebserver.MockWebServer$3 acceptConnections INFO: MockWebServer[8888] done accepting connections: Interrupted function call: accept failed 16:51:57.151 DEBUG [main] o.s.t.c.s.AbstractDirtiesContextTestExecutionListener [AbstractDirtiesContextTestExecutionListener.java:107] After test method: context [DefaultTestContext@6581dc0a testClass = Test, testInstance = Test@34b27915, testMethod = test@Test, testException = org.opentest4j.AssertionFailedError: expected:  but was: , mergedContextConfiguration = [MergedContextConfiguration@39de3d36 testClass = Test, locations = '{}', classes = '', contextInitializerClasses = '[class org.springframework.boot.test.context.ConfigFileApplicationContextInitializer]', activeProfiles = '{test}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@1583741e, org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@1efe439d, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@12d2ce03, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null].  org.opentest4j.AssertionFailedError: expected:  but was:  ``` No retries in this case.  Is this bug or I doing something wrong?","open","in: web,","altro3","2019-06-07T10:00:17Z","2021-11-08T11:17:39Z"
"","23632","Spring ""SchedulerFactoryBean"" overrides the Quartz ""jobstore"" properties values","If you are using Spring's SchedulerFactoryBean, it overrides the configured value from the properties file. So if you tried to use JobStoreTx it is always overridden by the LocalDataSourceJobStore from spring  Code snippet below shows the part from the SchedulerFactoryBean. I have overcome it by using a customizer.   ```CollectionUtils.mergePropertiesIntoMap(this.quartzProperties, mergedProps); 		if (this.dataSource != null) { 			mergedProps.setProperty(StdSchedulerFactory.PROP_JOB_STORE_CLASS, LocalDataSourceJobStore.class.getName()); 		} ``` What if I wan to extend the existing LocalDataSourceJobStore?","closed","status: superseded,","ms3eed","2019-09-12T16:26:55Z","2021-10-19T12:43:22Z"
"","23257","Log at WARN level in case of contradicting PersistenceUnitManager setup","If users configure a `LocalContainerEntityManagerFactoryBean` and accidentally set both a persistence unit name *and* packages to scan, the latter are ignored but the message pointing to the invalidity of this setup is only logged at debug level. The observable misbehavior is that apparently the entity scanning silently does not work.  Here's an [example StackOverflow question](https://stackoverflow.com/questions/26583015/no-managedtype-was-found-for-the-key-class).","closed","type: enhancement,","odrotbohm","2019-07-09T10:40:06Z","2019-07-09T15:26:36Z"
"","23175","Error signal not propagated if writeFunction in ChannelSendOperator fails immediately","If the writeFunction in `ChannelSendOperator` fails immediately inside the call to `apply`, the error signal should be propagated to the write completion Subscriber. Not doing so means the error is lost and the write appears to never complete.  This is unlikely to occur in WebFlux unless one of the `Supplier` based commit action fails, but is more likely to happen in RSocket processing where the write function invokes a return value handler (and is how it was uncovered).","closed","type: enhancement,","rstoyanchev","2019-06-21T11:58:37Z","2019-06-21T13:17:59Z"
"","22819","Reading consecutive HTTPS responses with empty bodies hangs","If I submit two HTTPS requests using WebClient (using reactor-netty), and the second response has an empty body (content-length: 0), then the client hangs and does not emit a response. When I do the same over HTTP, it works.  So, this appears isolated to HTTPS.  | module | version | |----|----| | spring-webflux | 5.1.6.RELEASE | | reactor-core | 3.2.8.RELEASE| | reactor-netty | 0.8.6.RELEASE| | netty |4.1.34.Final |  I initially discovered this when running against a real server that returned an empty protobuf payload.  I have a created a unit test ([project attached](https://github.com/spring-projects/spring-framework/files/3096139/webclient_empty_body.zip)) that executes requests against an okhttp3 MockWebServer to demonstrate the issue. The unit test has two methods that each execute two requests against the mock server, with the only difference being HTTP vs HTTPS. * The HTTP test passes. * The HTTPS test fails with a timeout exception waiting on the second response.   Here is what I have noticed in trace logs.  For the second HTTP request (which succeeds):  ``` 2019-04-18 13:41:20,635 INFO  [main]: REQUEST #2 2019-04-18 13:41:20,635 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] onStateChange(POST{uri=/, connection=PooledConnection{channel=[id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670]}}, [disconnecting]) 2019-04-18 13:41:20,635 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] Releasing channel 2019-04-18 13:41:20,635 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] Channel cleaned, now 0 active connections and 1 inactive connections 2019-04-18 13:41:20,635 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] READ COMPLETE 2019-04-18 13:41:20,636 TRACE [main]: [47c64cfe] HTTP POST http://127.0.0.1:60670/, headers={} 2019-04-18 13:41:20,637 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] Channel acquired, now 1 active connections and 0 inactive connections 2019-04-18 13:41:20,637 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] Handler is being applied: {uri=http://127.0.0.1:60670/, method=POST} 2019-04-18 13:41:20,638 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] WRITE: 154B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 50 4f 53 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d |POST / HTTP/1.1.| |00000010| 0a 75 73 65 72 2d 61 67 65 6e 74 3a 20 52 65 61 |.user-agent: Rea| |00000020| 63 74 6f 72 4e 65 74 74 79 2f 30 2e 38 2e 36 2e |ctorNetty/0.8.6.| |00000030| 52 45 4c 45 41 53 45 0d 0a 68 6f 73 74 3a 20 31 |RELEASE..host: 1| |00000040| 32 37 2e 30 2e 30 2e 31 3a 36 30 36 37 30 0d 0a |27.0.0.1:60670..| |00000050| 61 63 63 65 70 74 3a 20 2a 2f 2a 0d 0a 43 6f 6e |accept: */*..Con| |00000060| 74 65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f |tent-Type: text/| |00000070| 70 6c 61 69 6e 3b 63 68 61 72 73 65 74 3d 55 54 |plain;charset=UT| |00000080| 46 2d 38 0d 0a 63 6f 6e 74 65 6e 74 2d 6c 65 6e |F-8..content-len| |00000090| 67 74 68 3a 20 30 0d 0a 0d 0a                   |gth: 0....      | +--------+-------------------------------------------------+----------------+ 2019-04-18 13:41:20,638 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] FLUSH 2019-04-18 13:41:20,639 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] WRITE: 0B 2019-04-18 13:41:20,639 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] FLUSH 2019-04-18 13:41:20,639 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] onStateChange(POST{uri=/, connection=PooledConnection{channel=[id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670]}}, [request_sent]) 2019-04-18 13:41:20,640 INFO  [MockWebServer /127.0.0.1:60671]: MockWebServer[60670] received request: POST / HTTP/1.1 and responded: HTTP/1.1 200 OK 2019-04-18 13:41:20,640 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] READ: 38B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP/1.1 200 OK.| |00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:| |00000020| 20 30 0d 0a 0d 0a                               | 0....          | +--------+-------------------------------------------------+----------------+ 2019-04-18 13:41:20,640 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] Received response (auto-read:false) : [Content-Length=0] 2019-04-18 13:41:20,641 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] onStateChange(POST{uri=/, connection=PooledConnection{channel=[id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670]}}, [response_received]) 2019-04-18 13:41:20,641 TRACE [reactor-http-nio-9]: [47c64cfe] Response 200 OK, headers={masked} 2019-04-18 13:41:20,641 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] Received last HTTP packet  ```  For the second HTTPS request (which hangs):  ``` 2019-04-18 13:41:15,588 INFO  [main]: REQUEST #2 2019-04-18 13:41:15,588 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] Channel cleaned, now 0 active connections and 1 inactive connections 2019-04-18 13:41:15,588 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] READ COMPLETE 2019-04-18 13:41:15,589 TRACE [main]: [3e134896] HTTP POST https://127.0.0.1:60640/, headers={} 2019-04-18 13:41:15,591 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] Channel acquired, now 1 active connections and 0 inactive connections 2019-04-18 13:41:15,591 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] Handler is being applied: {uri=https://127.0.0.1:60640/, method=POST} 2019-04-18 13:41:15,592 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] WRITE: 154B          +-------------------------------------------------+          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f | +--------+-------------------------------------------------+----------------+ |00000000| 50 4f 53 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d |POST / HTTP/1.1.| |00000010| 0a 75 73 65 72 2d 61 67 65 6e 74 3a 20 52 65 61 |.user-agent: Rea| |00000020| 63 74 6f 72 4e 65 74 74 79 2f 30 2e 38 2e 36 2e |ctorNetty/0.8.6.| |00000030| 52 45 4c 45 41 53 45 0d 0a 68 6f 73 74 3a 20 31 |RELEASE..host: 1| |00000040| 32 37 2e 30 2e 30 2e 31 3a 36 30 36 34 30 0d 0a |27.0.0.1:60640..| |00000050| 61 63 63 65 70 74 3a 20 2a 2f 2a 0d 0a 43 6f 6e |accept: */*..Con| |00000060| 74 65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f |tent-Type: text/| |00000070| 70 6c 61 69 6e 3b 63 68 61 72 73 65 74 3d 55 54 |plain;charset=UT| |00000080| 46 2d 38 0d 0a 63 6f 6e 74 65 6e 74 2d 6c 65 6e |F-8..content-len| |00000090| 67 74 68 3a 20 30 0d 0a 0d 0a                   |gth: 0....      | +--------+-------------------------------------------------+----------------+ 2019-04-18 13:41:15,593 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] FLUSH 2019-04-18 13:41:15,593 DEBUG [reactor-http-nio-4]: [id: 0x518b335c, L:/127.0.0.1:60666 - R:/127.0.0.1:60640] WRITE: 0B 2019-04-18 13:41:15,594 INFO  [MockWebServer /127.0.0.1:60666]: MockWebServer[60640] received request: POST / HTTP/1.1 and responded: HTTP/1.1 200 OK <<< HANG >>> ```  At the point of hanging, it seems the second HTTPS request does _not_ log the following (which is seen in HTTP), indicating that maybe it thinks the request has not been fully sent yet, and therefore does not start waiting on the response...  ``` 2019-04-18 13:41:20,639 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] FLUSH 2019-04-18 13:41:20,639 DEBUG [reactor-http-nio-9]: [id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670] onStateChange(POST{uri=/, connection=PooledConnection{channel=[id: 0xa50ef88e, L:/127.0.0.1:60671 - R:/127.0.0.1:60670]}}, [request_sent]) ```  I'm not sure if this is a reactor-netty issue, or a WebClient issue.  I'll start here, but I'll be happy to file an issue on reactor-netty if needed.","closed","for: external-project,","philsttr","2019-04-18T20:54:39Z","2019-04-19T08:22:45Z"
"","23381","destroy-method not called on improperly wired prototype","If a prototype bean is not properly wired, spring will still create it on demand (without erroring, even at TRACE level) but will not call the destroy-method if one is specified.  I've verified this on spring version 4.3.22.RELEASE and 5.1.6.RELEASE (using both CommonsPoolTargetSource and CommonsPool2TargetSource) on several 1.8 JDKs.  Consider the following class:      public class Thing {       public Thing() {         System.out.println(""A thing was created"");       }       public void close() {         System.out.println(""A thing was destroyed"");       }     }  And the following xml configuration:  	 		 		 		 		 	 	 	  While the application runs, we can see Things properly being created and destroyed over and over in the console, as we would expect:      A thing was created     A thing was destroyed     A thing was created     A thing was destroyed      Now lets change bean thing to have an invalid definition:  	              	  Spring still manages to successfully create the bean thing.  However, the destroy-method is no longer called; Things are constantly created, but never cleaned up.  Additionally, no warnings or errors are logged from spring - even at TRACE level.  I would expect either the destroy-method to still be called, or some sort of warning/error from spring.","open","in: core,","jayeeebee","2019-07-29T14:27:47Z","2021-11-11T10:12:40Z"
"","23421","ConstraintViolationException returned as HttpMediaTypeNotAcceptableException","If a client sends a request with `accept` header not matching the endpoints `produces` `MediaType`: should the webservice respond with 406 not acceptable (eg when ConstraintValidationExceptions occur)?  - this is the current implementation. In cause you would want to stick to it, the issue can be closed directly.  If not - my suggestion: wouldn't it be better if spring would expose the real underlying error eg as message body, while still preserving the 406?  Example to reproduce: If my endpoint does not produce json or xml, but any other media type like `text/plain`, or `text/event-stream`, then request validations are return as `HttpMediaTypeNotAcceptableException`.  Which is wrong, they should at least return the real error somehow.  Example:  ``` @RestController @Validated public class TestServlet { 	@GetMapping(value = ""/test"", produces = MediaType.APPLICATION_JSON_VALUE) 	public void test(@RequestParam @Valid @NotBlank String name) {  	}  	@GetMapping(value = ""/test2"", produces = MediaType.TEXT_PLAIN_VALUE) 	public void test2(@RequestParam @Valid @NotBlank String name) {  	} } ```  If the first method is called: `localhost:8080/test?name=` with `Accept:application/json`:  Then the correct error response is shown: ``` {     ""timestamp"": ""2019-08-06T12:07:12.186+0000"",     ""status"": 500,     ""error"": ""Internal Server Error"",     ""message"": ""test.name: must not be blank"",     ""path"": ""/test"" } ```  But for the 2nd method, the real validation error is hidden behind a `406 Not Acceptable`: `localhost:8080/test2?name=` with `Accept:text/plain`. Returns `406` status code with empty message body.  I *assume* this is because spring tries to return the validation error as another media type that is not `text/plain`, and then fails.  I think even if the client requests an `accept` http header explicit, errors should still be getting exposed somehow!  Error in logs: ``` 2019-08-06 14:08:31.414 ERROR 3933 --- [nio-8080-exec-8] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is javax.validation.ConstraintViolationException: test.name: must not be blank with root cause  javax.validation.ConstraintViolationException: test.name: must not be blank 	at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:116) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at de.test.PersonServlet$$EnhancerBySpringCGLIB$$c3619ed5.test() ~[classes/:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:853) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1587) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.21.jar:9.0.21] 	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]  2019-08-06 14:08:31.417  WARN 3933 --- [nio-8080-exec-8] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation] ```  `spring-boot-2.1.6` with `spring-webmvc-5.1.8`.","closed","for: external-project,","membersound","2019-08-06T12:19:29Z","2020-01-03T15:18:22Z"
"","23319","Errors.NativeIoException from WebClient on WebFlux server does not set the response status","If `Errors.NativeIoException` is raised from controller while handling service logic it is not properly handled by Spring Framework / WebFlux.  I'm observing the issue in one of my services that runs on Linux, it uses `WebClient` to access another web-service and, if idled for a while in connection pool, it generates `Errors.NativeIoException` with error code indication ""Connection reset by peer"" (I have mentioned it here: https://github.com/reactor/reactor-netty/issues/641#issuecomment-512865171).  Disregarding the fact that this connection is not taken out from the pool automatically the behavior of the Spring WebFlux is odd: the service returns **HTTP 200 with empty content**, where as I have expected at least HTTP 500.  It can be easy reproduced by raising this Exception manually using latest versions of Spring-Boot, Netty and Java. Spring-Boot version (maven): ```xml  	org.springframework.boot 	spring-boot-starter-parent 	2.1.6.RELEASE 	   	 		org.springframework.boot 		spring-boot-starter-webflux 	 	... ```  Linux version (in Docker): ``` root@59a09bf2408a:/demo# uname -a Linux 59a09bf2408a 4.9.125-linuxkit #1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 GNU/Linux ```  Java version: ``` root@59a09bf2408a:/demo# mvn -version Apache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-04T19:00:29Z) Maven home: /usr/share/maven Java version: 11.0.4, vendor: Oracle Corporation, runtime: /usr/local/openjdk-11 Default locale: en, platform encoding: UTF-8 OS name: ""linux"", version: ""4.9.125-linuxkit"", arch: ""amd64"", family: ""unix"" ```  Example of controller to cause the issue: ```java @RestController @EnableWebFlux public class DemoController { 	@GetMapping(""/objects/{id}"") 	public Mono getObjects(final @PathVariable String id) { 		switch (id) { 			case ""1"": 				return Mono.error(new IOException(""Failed to read object: "" + id)); 			case ""2"": 				// -104 Connection reset by peer 				return Mono.error(new Errors.NativeIoException(""Failed to read object: "" + id, -104)); 			default: 				DemoObject data = new DemoObject(); 				data.id = id; 				return Mono.just(data); 		} 	}  	public static final class DemoObject { 		public String id; 	} } ```  `-104` is a [Connection reset by peer](https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/errno.h#L87) code on Linux generated in my service by underlying communication to the external service using `WebClient`  Standard `IOException` are handled as expected: ``` $ curl -v http://localhost:8080/objects/1 *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /objects/1 HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < Content-Type: application/json;charset=UTF-8 < Content-Length: 129 < * Connection #0 to host localhost left intact {""timestamp"":1563573616713,""path"":""/objects/1"",""status"":500,""error"":""Internal Server Error"",""message"":""Failed to read object: 1""} ```  But the `Errors.NativeIoException` have weird handling: ``` ~ $ curl -v http://localhost:8080/objects/2 *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /objects/2 HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-length: 0 < * Connection #0 to host localhost left intact ```  I believe `Errors.NativeIoException` is misinterpret by Netty as an error of incoming HTTP connection and not the underlying business / service logic. But should not this be a part of WebFlux to take care of any Exception that is raised from inside controllers and deliver them as HTTP 500 to outside clients?  Workaround: at the moment I am using `Mono.onErrorMap` to map any `Errors.NativeIoException` into `ResponseStatusException` before it leaves the controller to avoid **HTTP 200** response in case of internal issues. But this feels very wrong to me.  I'll be happy about any guidance and/or explanation about current behavior of WebFlux. Thank you!","closed","type: enhancement,","darklynx","2019-07-19T22:18:37Z","2019-09-24T12:40:18Z"
"","23045","Weird behaviour when calling `ApplicationContext.getBean()` with a null class reference","I've run into wierd behaviour when calling `ApplicationContext::getBean` for nullable class: ```java @SpringBootApplication public class DemoApplication {      public static void main(String[] args) {         ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args);          Class o = null;         Object bean = context.getBean(o);//todo should be NPE     } } ``` Execution of this method throws exception with list of all beans in the context ```stacktrace Exception in thread ""main"" org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'java.lang.Object' available: more than one 'primary' bean found among candidates: [org.springframework.context.annotation.internalConfigurationAnnotationProcessor, org.springframework.context.annotation.internalAutowiredAnnotationProcessor, org.springframework.context.annotation.internalCommonAnnotationProcessor, org.springframework.context.event.internalEventListenerProcessor, org.springframework.context.event.internalEventListenerFactory, demoApplication, org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory, org.springframework.boot.autoconfigure.AutoConfigurationPackages, org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration, org.springframework.boot.autoconfigure.condition.BeanTypeRegistry, propertySourcesPlaceholderConfigurer, org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration$TomcatWebSocketConfiguration, websocketServletWebServerCustomizer, org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration, org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration$EmbeddedTomcat, tomcatServletWebServerFactory, org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration, servletWebServerFactoryCustomizer, tomcatServletWebServerFactoryCustomizer, server-org.springframework.boot.autoconfigure.web.ServerProperties, org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor, org.springframework.boot.context.properties.ConfigurationBeanFactoryMetadata, webServerFactoryCustomizerBeanPostProcessor, errorPageRegistrarBeanPostProcessor, org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletConfiguration, dispatcherServlet, spring.http-org.springframework.boot.autoconfigure.http.HttpProperties, spring.mvc-org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties, org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration, dispatcherServletRegistration, org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration, org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration, taskExecutorBuilder, applicationTaskExecutor, spring.task.execution-org.springframework.boot.autoconfigure.task.TaskExecutionProperties, org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration, defaultValidator, methodValidationPostProcessor, org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration, error, beanNameViewResolver, org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration$DefaultErrorViewResolverConfiguration, conventionErrorViewResolver, org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration, errorAttributes, basicErrorController, errorPageCustomizer, preserveErrorControllerTargetClassPostProcessor, spring.resources-org.springframework.boot.autoconfigure.web.ResourceProperties, org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter$FaviconConfiguration, faviconHandlerMapping, faviconRequestHandler, org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration, requestMappingHandlerAdapter, requestMappingHandlerMapping, mvcConversionService, mvcValidator, mvcContentNegotiationManager, mvcPathMatcher, mvcUrlPathHelper, viewControllerHandlerMapping, beanNameHandlerMapping, resourceHandlerMapping, mvcResourceUrlProvider, defaultServletHandlerMapping, mvcUriComponentsContributor, httpRequestHandlerAdapter, simpleControllerHandlerAdapter, handlerExceptionResolver, mvcViewResolver, mvcHandlerMappingIntrospector, org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter, defaultViewResolver, viewResolver, welcomePageHandlerMapping, requestContextFilter, org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration, hiddenHttpMethodFilter, formContentFilter, org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration, mbeanExporter, objectNamingStrategy, mbeanServer, org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration, springApplicationAdminRegistrar, org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration, org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration, standardJacksonObjectMapperBuilderCustomizer, spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties, org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration, jacksonObjectMapperBuilder, org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$ParameterNamesModuleConfiguration, parameterNamesModule, org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration, jacksonObjectMapper, org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration, jsonComponentModule, org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration$StringHttpMessageConverterConfiguration, stringHttpMessageConverter, org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration$MappingJackson2HttpMessageConverterConfiguration, mappingJackson2HttpMessageConverter, org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration, org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration, messageConverters, org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration$LoggingCodecConfiguration, loggingCodecCustomizer, org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration$JacksonCodecConfiguration, jacksonCodecCustomizer, org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration, org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration, spring.info-org.springframework.boot.autoconfigure.info.ProjectInfoProperties, org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration, taskSchedulerBuilder, spring.task.scheduling-org.springframework.boot.autoconfigure.task.TaskSchedulingProperties, org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration, restTemplateBuilder, org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration$TomcatWebServerFactoryCustomizerConfiguration, tomcatWebServerFactoryCustomizer, org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration, org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration, characterEncodingFilter, localeCharsetMappingsCustomizer, org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration, multipartConfigElement, multipartResolver, spring.servlet.multipart-org.springframework.boot.autoconfigure.web.servlet.MultipartProperties, autoConfigurationReport, org.springframework.boot.context.ContextIdApplicationContextInitializer$ContextId, springApplicationArguments, springBootBanner, springBootLoggingSystem, environment, systemProperties, systemEnvironment, org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry, messageSource, applicationEventMulticaster, servletContext, contextParameters, contextAttributes, lifecycleProcessor] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.determinePrimaryCandidate(DefaultListableBeanFactory.java:1529) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1128) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:407) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:341) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:335) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1123) 	at com.example.demo.DemoApplication.main(DemoApplication.java:14) ```  Shouldn't we throw NPE immediately when one instantiates `ResolvableType` with nullable field `type` instead of checking all beans in the context?","closed","in: core,","stsypanov","2019-05-28T09:44:28Z","2019-06-04T13:31:19Z"
"","23672","@Scheduled method is started without transaction, if bean has circular dependency","I've found an interesting bug, that if the bean has reference to itself and some method marked with `@Scheduled` annotation, then this method is executed without any aspects, including `@Transactional`. Like in this case: ``` @Service public class ServiceWithIssue {      @Autowired     private ServiceWithIssue serviceWithIssue;      @Transactional     @Scheduled(initialDelay = 10, fixedDelay = 100000)     public void runTask() {         if (!TransactionSynchronizationManager.isActualTransactionActive()) {             throw new RuntimeException(""ServiceWithIssue not in transaction!"");         }          System.out.println(""ServiceWithIssue is in transaction!"");     } } ``` In the above example exception will be thrown.  As a workaround to fix this, we can add `@Lazy` annotation to our circular dependency.  After a brief debug I think the problem is somewhere in class `AbstractAutoProxyCreator`, but can't guarantee this.  Reproduced in _org.springframework.boot:spring-boot-starter-parent:2.1.8.RELEASE_  A test project to quickly reproduce the problem: [test-project.zip](https://github.com/spring-projects/spring-boot/files/3635447/test-project.zip)","open","in: core,","brunneng","2019-09-20T10:22:50Z","2021-11-10T11:58:03Z"
"","23251","Add unit tests for PropertyAccessorUtils","I've analysed your codebase and noticed that `org.springframework.beans.PropertyAccessorUtils` is not fully tested. I've written some tests for the methods in this class with the help of [Diffblue Cover](https://www.diffblue.com/opensource).  Hopefully, these tests will help you detect any regressions caused by future code changes. If you would find it useful to have additional tests written for this repository, I would be more than happy to look at other classes that you consider important in a subsequent PR.  ""obvious fix""","closed","in: core,","EricHetti","2019-07-08T16:58:02Z","2019-07-10T13:54:14Z"
"","23816","Websocket race condition between processing of CONNECT frame and creation SessionConnectedEvent","I'm working on an application using spring boot `2.1.6` that uses STOMP over websocket with simple broker enabled and security configured. This is working well most of the cases except sometimes the client fails to receive any messages. Looking into this it seems that in the rare cases when things are not working the `SessionConnectedEvent` is created before the `CONNECT` frame is processed enough and manages to add the user in `stompAuthentications` map (`StompSubProtocolHandler::handleMessageFromClient()`). This results in a `SessionConnectedEvent` being created without the user set (`StompSubProtocolHandler::handleMessageToClient()`) and in turn has a side effect in `DefaultSimpUserRegistry` ending up with the session not being registered and thus message destination is not resolved when sending messages to user queues `messagingTemplate.convertAndSendToUser()`.  My assumption was that if the `CONNECT` frame has a valid authentication token the `SessionConnectedEvent` should always have the user set and the users session should be registered in `DefaultSimpUserRegistry`. Is this correct or am I missing something?","closed","status: duplicate,","lucian-moldovan","2019-10-16T06:47:26Z","2019-10-16T11:11:28Z"
"","22999","feature request: JMS interceptors","I'm working on a Spring Boot app which communicates with other apps, or with itself, using JMS. In addition to the functional message payload being exchanged, some contextual information is added to the messages, as properties. For example: the identity of the user (or process) who triggered the sending of the message.  Instead of having to add this contextual information each time I send a message, and to extract this contextual information each time I receive one, I would like to do that once, in a single place (it's then stored it in a thread-local variable, and/or stored in the slf4J MDC).  The way I currently do it is by overriding methods of JmsTemplate and of DefaultMessageListenerContainer. This, however is not as elegant as I would like it: I need to provide my own configuration to provide a custom JmsTemplate, and a custom DefaultMessageListenerContainerFactory, which itself creates a custom DefaultMessageListenerContainer, instead of simply using the ones auto-configured by Spring Boot, leading to code that is more verbose than necessary, and which duplicates what Spring Boot does already (properties-based customization, etc.)  I also thought about using AOP to intercept the calls to the JmsListener-annotated methods. But then that prevents me from simply using the type of the payload for the method argument: every method must take a `Message` as argument, just to allow extracting the message properties inside the aspect.  Unless there is already a better way to achieve what I want, I would find it nice if I could simply add interceptors to the JmsTemplate and to the DefaultMessageListenerContainerFactory.   - the JmsTemplate interceptors would allow to preprocess the message before sending it  - the DefaultMessageListenerContainerFactory interceptors would be set on each of the created DefaultMessageListenerContainers (as the other properties are), and would allow preprocessing a message before invoking the listener, and postprocessing it after the listener is invoked, in a way similar to an MVC interceptor.","open","in: messaging,","jnizet","2019-05-20T16:21:30Z","2021-11-10T11:41:08Z"
"","22814","Illegal reflective access operation on Java 11 for lazy-init beans registered with MBeanServer","I'm using spring-boot 2.2.0.M2 with Java 11 and i am getting this warning:  ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (file:/home/porfirio/.m2/repository/org/springframework/spring-core/5.2.0.M1/spring-core-5.2.0.M1.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release ``` I don't know if it is a know bug with spring-boot+java11 or an issue on my end ```xml                       org.springframework.boot             spring-boot-starter-actuator                               org.springframework.boot             spring-boot-starter-data-jpa                               org.springframework.boot             spring-boot-starter-security                               org.springframework.boot             spring-boot-starter-web                               org.springframework.boot             spring-boot-devtools             runtime                               org.postgresql             postgresql             runtime                               org.projectlombok             lombok             true                               org.springframework.boot             spring-boot-starter-test             test                               org.springframework.security             spring-security-test             test               ```","closed","status: feedback-provided,","porfirioribeiro","2019-04-17T14:55:28Z","2021-03-04T07:15:26Z"
"","23343","Running jar-file from bootJar behaves differently than bootRun in certain scenarios of dependency injection","I'm using Spring Boot 2.1.5.RELEASE, which i recently upgraded two, and the corresponding versions of Spring Security, Spring JPA and Hibernate. One of the main reasons was the option to use `@Autowired` to inject code into a JPA Attribute Converter.  Doing so resulted in a strange behaviour when running my application. All works perfectly fine (at least it seems so) in tests and when running the application via `bootRun`. But if I run the same application using the jar-file I get from `bootJar` I will get the following exception:      org.springframework.security.oauth2.provider.endpoint.TokenEndpoint.handleException:169 Handling error: IllegalStateException, This object has not been built     java.lang.IllegalStateException: This object has not been built         at org.springframework.security.config.annotation.AbstractSecurityBuilder.getObject(AbstractSecurityBuilder.java:55) ~[spring-security-config-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:508) ~[spring-security-config-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.security.oauth2.provider.password.ResourceOwnerPasswordTokenGranter.getOAuth2Authentication(ResourceOwnerPasswordTokenGranter.java:71) ~[spring-security-oauth2-2.3.6.RELEASE.jar!/:?]         ...  I opened a [stackoverflow ](https://stackoverflow.com/questions/57004314/how-to-solve-illegalstateexception-this-object-has-not-been-built-when-using)question for this, but with my own investigation going on, I think the issue is better suited to be filed here. I may be wrong though.  I also created a stripped down sample project and publish it in [Github](https://github.com/szauner/investigate-springsec-jar-only-problem). The readme-file includes instructions on how to reproduce the problem and how to identify possible causes.  Please let me know, if I should provide more information.","open","in: core,","szauner","2019-07-23T08:17:44Z","2021-11-10T12:00:12Z"
"","23258","Add a ScriptEngine factory to ScriptTemplateConfigurer","I'm using a the Graal.js engine with ScriptTemplateConfigurer with setSharedEngine(false) to enable thread safety.  Graal.js needs to be configured in order to enable Java interop, for example like this:  ```java ScriptEngine engine = new ScriptEngineManager().getEngineByName(""graal.js""); Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE); bindings.put(""polyglot.js.allowHostAccess"", true); bindings.put(""polyglot.js.allowHostClassLookup"", true); ```  The problem is that it's not possible to create an engine instance, configure it and assign it to the ScriptTemplateConfigurer if setSharedEngine is false. In that case you can only set the engine name.  Would it be possible to add a ScriptEngine factory method to ScriptTemplateConfigurer so that it's possible to configure the thread local engine instances?","closed","type: enhancement,","kl","2019-07-09T10:43:16Z","2019-07-11T15:24:35Z"
"","23351","org.apache.tomcat.util.net.NioEndpoint : Failed to register socket with selector from poller","I'm using `WebClient` to make requests to a downstream service. With Webflux running it on tomcat.  ```java   @Bean   public WebClient webClient(       @Value(""${http.client.connection-timeout-millis}"") final int connectionTimeoutMillis,       @Value(""${http.client.socket-timeout-millis}"") final int socketTimeoutMillis,       @Value(""${http.client.wire-tap-enabled}"") final boolean wireTapEnabled,       final ObjectMapper objectMapper) {      Consumer doOnConnectedConsumer = connection ->         connection             .addHandler(new ReadTimeoutHandler(socketTimeoutMillis, MILLISECONDS))             .addHandler(new WriteTimeoutHandler(connectionTimeoutMillis, MILLISECONDS));      TcpClient tcpClient = TcpClient.newConnection()         .wiretap(wireTapEnabled)         .option(CONNECT_TIMEOUT_MILLIS, connectionTimeoutMillis)         .doOnConnected(doOnConnectedConsumer);      return WebClient.builder()         .clientConnector(new ReactorClientHttpConnector(HttpClient.from(tcpClient).compress(true)))         .exchangeStrategies(customExchangeStrategies(objectMapper))         .build();   }   // ..........      MultiValueMap params = getParams(t1, t2);      return webClient.get()         .uri(HttpUtils.buildUrl(serviceUrl, params, name))         .exchange()         .flatMap(this::handleClientResponse)         .onErrorMap(Exception.class, ex -> handleUnexpectedEx(ex, name, params));   } ``` Everything works fine, but im running gatling performance tests, and sending multiple requests to my service, that is sending requests to my downstream services.  when i run the performance tests, most of the requests return with 200 and success. but most of times one of the requests throw the log entry:  ``` 2019-07-24 17:35:23.230 ERROR [-,,,] 28076 --- [25-ClientPoller] org.apache.tomcat.util.net.NioEndpoint   : Failed to register socket with selector from poller java.nio.channels.ClosedChannelException: null 	at java.base/java.nio.channels.spi.AbstractSelectableChannel.register(AbstractSelectableChannel.java:206) 	at org.apache.tomcat.util.net.NioEndpoint$PollerEvent.run(NioEndpoint.java:506) 	at org.apache.tomcat.util.net.NioEndpoint$Poller.events(NioEndpoint.java:631) 	at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:729) 	at java.base/java.lang.Thread.run(Thread.java:834) ```  and it basically close the connection with the gatling client without return any response, no errors, nothing. it just close the connection between client and server.  i'm trying to get the logs with wiretap enable, but its kinda tricky to reproduce this error, because sometimes happen, sometimes don't  any clue what can be causing this problem? i think it might be related with the way Tomcat handles the pooled connections. but again i have no clue.","closed","for: external-project,","xDouglasx","2019-07-24T17:23:52Z","2021-01-08T16:56:13Z"
"","23249","PrematureCloseException: Connection prematurely closed","I'm using `WebClient` to make requests to a downstream service.  ```java   @Bean   public WebClient webClient(       @Value(""${http.client.connection-timeout-millis}"") final int connectionTimeoutMillis,       @Value(""${http.client.socket-timeout-millis}"") final int socketTimeoutMillis,       @Value(""${http.client.wire-tap-enabled}"") final boolean wireTapEnabled,       final ObjectMapper objectMapper) {      Consumer doOnConnectedConsumer = connection ->         connection             .addHandler(new ReadTimeoutHandler(socketTimeoutMillis, MILLISECONDS))             .addHandler(new WriteTimeoutHandler(connectionTimeoutMillis, MILLISECONDS));      TcpClient tcpClient = TcpClient.newConnection()         .wiretap(wireTapEnabled)         .option(CONNECT_TIMEOUT_MILLIS, connectionTimeoutMillis)         .doOnConnected(doOnConnectedConsumer);      return WebClient.builder()         .clientConnector(new ReactorClientHttpConnector(HttpClient.from(tcpClient).compress(true)))         .exchangeStrategies(customExchangeStrategies(objectMapper))         .build();   }   // ..........      MultiValueMap params = getParams(t1, t2);      return webClient.get()         .uri(HttpUtils.buildUrl(serviceUrl, params, name))         .exchange()         .flatMap(this::handleClientResponse)         .onErrorMap(Exception.class, ex -> handleUnexpectedEx(ex, name, params));   } ```  So basically in this case I need the `clientResponse`, because 404 is not an error, so we just return a empty mono, we do all the logic on the `handleCLientResponse` to throw exceptions and etc.  everything works fine, but when we have 404's its keep logging this:  ``` 2019-07-08 11:56:51.972  WARN [-,,,] 1504 --- [ctor-http-nio-3] reactor.netty.channel.FluxReceive        : [id: 0x66c8568c, L:/127.0.0.1:62319 ! R:localhost/127.0.0.1:8990] An exception has been observed post termination  reactor.netty.http.client.PrematureCloseException: Connection prematurely closed DURING response  2019-07-08 11:56:52.013 DEBUG [-,,,] 1504 --- [ctor-http-nio-2] reactor.netty.ReactorNetty               : [id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990] Non Removed handler: ReadTimeoutHandler, context: ChannelHandlerContext(ReadTimeoutHandler, [id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990]), pipeline: DefaultChannelPipeline{(reactor.left.httpCodec = io.netty.handler.codec.http.HttpClientCodec), (reactor.left.decompressor = io.netty.handler.codec.http.HttpContentDecompressor), (WriteTimeoutHandler = io.netty.handler.timeout.WriteTimeoutHandler), (ReadTimeoutHandler = io.netty.handler.timeout.ReadTimeoutHandler), (reactor.right.reactiveBridge = reactor.netty.channel.ChannelOperationsHandler)} 2019-07-08 11:56:52.014 DEBUG [-,,,] 1504 --- [ctor-http-nio-2] reactor.netty.ReactorNetty               : [id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990] Non Removed handler: WriteTimeoutHandler, context: ChannelHandlerContext(WriteTimeoutHandler, [id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990]), pipeline: DefaultChannelPipeline{(reactor.left.httpCodec = io.netty.handler.codec.http.HttpClientCodec), (reactor.left.decompressor = io.netty.handler.codec.http.HttpContentDecompressor), (WriteTimeoutHandler = io.netty.handler.timeout.WriteTimeoutHandler), (ReadTimeoutHandler = io.netty.handler.timeout.ReadTimeoutHandler), (reactor.right.reactiveBridge = reactor.netty.channel.ChannelOperationsHandler)} 2019-07-08 11:56:52.014 DEBUG [-,,,] 1504 --- [ctor-http-nio-2] r.netty.resources.NewConnectionProvider  : [id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990] onStateChange([response_incomplete], GET{uri=/service/TWFDHF?T1=1.0.0&T2=1, connection=SimpleConnection{channel=[id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990]}}) 2019-07-08 11:56:52.014  WARN [-,,,] 1504 --- [ctor-http-nio-2] reactor.netty.channel.FluxReceive        : [id: 0xf50bdf8d, L:/127.0.0.1:62324 ! R:localhost/127.0.0.1:8990] An exception has been observed post termination ```  I already tried everything, the only thing that make it remove is if i use `.clientConnector(new ReactorClientHttpConnector(HttpClient.newConnection().compress(true)))`.  But it bring me others problems with timeout of requests and endless reset looping on my unit tests when using fault and connection_reset_by_peer.  i have no clue how to fix this...","closed","for: stackoverflow,","xDouglasx","2019-07-08T10:46:36Z","2019-07-10T15:46:24Z"
"","23561","FactoryBean registered with explicit target type cannot be autowired by type","I'm trying upgrade spring from 5.1.4.RELEASE to 5.2.0.RC1, some tests with `@Autowired` fails caused by `NoSuchBeanDefinitionException`, I found there is a regression of  `BeanFactory::getBean(Class requiredType)`. and use   ```java 		@Bean 		public MyServiceFactoryBean MyService() { 			return new MyServiceFactoryBean(); 		} ```  instead of   ```java 		@Bean 		public BeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor() { 			return new MyBeanDefinitionRegistryPostProcessor(); 		} ```  will success.  here is the full test case  ```java import static org.hamcrest.CoreMatchers.is; import static org.hamcrest.CoreMatchers.notNullValue; import static org.hamcrest.MatcherAssert.assertThat;  import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.BeansException; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor; import org.springframework.beans.factory.support.DefaultListableBeanFactory; import org.springframework.beans.factory.support.RootBeanDefinition; import org.springframework.context.annotation.Bean; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringRunner;  @RunWith(SpringRunner.class) @ContextConfiguration(classes = MyTest.MyConfiguration.class) public class MyTest {  	@Autowired 	DefaultListableBeanFactory beanFactory;  	@Autowired 	MyService myService;  	// @Autowired 	// autowire will fail 	MyServiceFactoryBean MyFactoryBean;  	@Test 	public void testGetBean() throws Exception { 		String beanName = MyService.class.getSimpleName(); 		assertThat(beanFactory.getBean(beanName), is(myService)); 		assertThat(beanFactory.getBean(""&"" + beanName), notNullValue()); 		assertThat(beanFactory.getBeansOfType(FactoryBean.class).size(), is(1)); // is(0) 		assertThat(beanFactory.getBeansOfType(MyServiceFactoryBean.class).size(), is(1)); // is(0) 		assertThat(beanFactory.getBean(MyServiceFactoryBean.class), notNullValue()); // NoSuchBeanDefinitionException 	}  	static class MyConfiguration {  		@Bean 		public BeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor() { 			return new MyBeanDefinitionRegistryPostProcessor(); 		} 	}  	public interface MyService {  	}  	public static class MyServiceFactoryBean implements FactoryBean {  		@Override 		public MyService getObject() throws Exception { 			return new MyService() { 			}; 		}  		@Override 		public Class getObjectType() { 			return MyService.class; 		}  	}  	public static class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {  		@Override 		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { 			RootBeanDefinition beanDefinition = new RootBeanDefinition(MyServiceFactoryBean.class.getCanonicalName()); 			beanDefinition.setPrimary(true); 			beanDefinition.setTargetType(MyService.class); 			beanDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_NO); 			beanDefinition.setAttribute(getClass().getName(), true); 			registry.registerBeanDefinition(MyService.class.getSimpleName(), beanDefinition); 		}  		@Override 		public void postProcessBeanFactory(ConfigurableListableBeanFactory bf) throws BeansException {  		}  	} }  ```","closed","in: core,","quaff","2019-09-02T07:43:54Z","2019-09-20T19:56:34Z"
"","22996","Hazelcast requestMappingHandlerAdapter run error","I'm trying to use hazelcast with webflux. I checked the spring docs, hazelcast docs, and some online articles. They all write basically the same, i tried everything that was there, but i can't run the applicaton. I'm using:  -  spring-boot-starter-webflux -  hazelcast, hazelcast-spring - spring-boot-starter-web - spring-boot-starter-security   When i try to run the application i get the following error:   `""The bean 'requestMappingHandlerAdapter', defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class], could not be registered. A bean with that name has already been defined in org.springframework.web.reactive.config.DelegatingWebFluxConfiguration and overriding is disabled.""`  I'm assuming even if i override it somehow, then the webflux handler wouldn't work.","closed","","iron2414","2019-05-20T08:58:45Z","2019-06-03T12:48:36Z"
"","23058","DefaultMessageListenerContainer fails to reconnect to ActiveMQ broker","I'm trying to simulate a reconnect with this scenario:  1. Client 1 connects to ActiveMQ 2. Client 2 connects to ActiveMQ with failover/reconnection with same clientId as client 1 - expected to throw already connected error 3. Kill client 1 (doesn't call close or properly clean up the connection) 4. Expect that client 2 reconnects after awhile  Client 2 somehow cannot reconnect and leaves a dead connection to the broker. Rerunning client 1 or 2 after the scenario throws already connected error too.  Client 1 test case: ``` ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory( ""guest"", ""guest"",                 ""tcp://localhost:61616"" );         connectionFactory.setClientID( ""guest"" );         Connection connection = connectionFactory.createConnection();         connection.start();         Thread.sleep( Long.MAX_VALUE ); ```  Client 2 test case: ```         String clientId = ""guest"";         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory( ""guest"", ""guest"",                 ""failover:(tcp://localhost:61616)"" );         connectionFactory.setClientID( clientId );         SingleConnectionFactory singleConnectionFactory = new SingleConnectionFactory( connectionFactory );         singleConnectionFactory.setClientId( clientId );         DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();         container.setConnectionFactory( singleConnectionFactory );         container.setDestinationName( ""topic://test"" );         container.afterPropertiesSet();         container.start();         Thread.sleep( Long.MAX_VALUE ); ```  Both clients connect to the same broker and has a `maxInactivityDuration` set to `10000`. I expect ActiveMQ to clean up client 1 after 10s with this parameter set but doesn't work too.  Exception thrown by client 2: ```  30/05/19 10:23:11.735 INFO  [DefaultMessageListenerContainer] JMS message listener invoker needs to establish shared Connection 30/05/19 10:23:11.746 ERROR [DefaultMessageListenerContainer] Could not refresh JMS Connection for destination 'topic://test' - retrying using FixedBackOff{interval=5000, currentAttempts=0, maxAttempts=unlimited}. Cause: Broker: localhost - Client: guest already connected from tcp://127.0.0.1:64437 30/05/19 10:23:16.753 ERROR [DefaultMessageListenerContainer] Could not refresh JMS Connection for destination 'topic://test' - retrying using FixedBackOff{interval=5000, currentAttempts=1, maxAttempts=unlimited}. Cause: Broker: localhost - Client: guest already connected from tcp://127.0.0.1:64455 30/05/19 10:23:21.761 ERROR [DefaultMessageListenerContainer] Could not refresh JMS Connection for destination 'topic://test' - retrying using FixedBackOff{interval=5000, currentAttempts=2, maxAttempts=unlimited}. Cause: Broker: localhost - Client: guest already connected from tcp://127.0.0.1:64455 ... (and so on) ```  Observations:  - If client 2 uses a `SingleConnectionFactory/CachingConnectionFactory`, it cannot reconnect. - If client 2 uses `ActiveMQConnectionFactory` on its container, it's able to reconnect. (showed `Successfully refreshed JMS Connection`) - Based on the exception log, it first says that client 1 is connected - port:64437, after stopping client 1, it says that there is another client connected - port:64455  Spring version: 4.3.24.RELEASE ActiveMQ JMS client library version: 5.15.9 ActiveMQ broker version: 5.15.9","open","in: messaging,","danieljohngomez","2019-05-30T02:31:00Z","2021-11-10T11:41:08Z"
"","23594","WebClient does not clean up underlying resources","I'm trying spring 5.2.0.RC1 and reactor-3.2.11 and reactor-netty-0.8.10, failed to clean up resources. ``` 	@Bean 	public ReactorResourceFactory resourceFactory() { 		ReactorResourceFactory factory = new ReactorResourceFactory(); 		factory.setUseGlobalResources(false); 		return factory; 	}  	@Bean 	public WebClient webClient() { 		ClientHttpConnector connector = new ReactorClientHttpConnector(resourceFactory(), client -> client); 		return WebClient.builder().clientConnector(connector).build(); 	}  ``` threads `webflux-http-kqueue-n` and `elastic-evictor-1` and `elastic-2` are not destroyed. ``` org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [webflux-http-kqueue-1] but has failed to stop it. This is very likely to create a memory leak.  org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [webflux-http-kqueue-2] but has failed to stop it. This is very likely to create a memory leak. org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [elastic-evictor-1] but has failed to stop it. This is very likely to create a memory leak. org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [elastic-2] but has failed to stop it. This is very likely to create a memory leak.  ```  Please run tests in attachment [WebClientTest.zip](https://github.com/spring-projects/spring-framework/files/3581955/WebClientTest.zip).","closed","for: external-project,","quaff","2019-09-06T02:27:04Z","2019-09-20T12:09:10Z"
"","23668","SseEmitter onError method does not get called on Payara 5","I'm trying below code on Spring MVC (5.1.8 version of dependencies) deployed on Payara 5 (Glassfish) :  ```java @GetMapping(""/listen-sse"") public SseEmitter sseEmitter() {         SseEmitter emitter = new SseEmitter(0L);         emitter.onError(e -> System.out.println(""OnError""));          ExecutorService service = Executors.newCachedThreadPool();         service.execute(() -> {             while (true) {                 try {                     Thread.sleep(2000);                     emitter.send(""Hello"");                 } catch (IOException | InterruptedException e) {                     System.out.println(""Exception"");                     break;                 }             }         });          service.shutdown();         return emitter; } ``` When the client disconnects I can only see ""Exception"" on console but not ""OnError"". I've tried the same code with Spring boot (same dependency versions) and embed tomcat everything works as expected.","closed","for: external-project,","hsynff","2019-09-19T06:13:31Z","2020-01-03T10:08:16Z"
"","23680","parameterized tests based on spring profiles","I'm testing various FHIR endpoint functionality, these tests are functionally identical except an `@ActiveProfiles` I'd like to apply. Here's what I imagine writing, basically all tests in the test would be run for each parameterized profile, e.g. foo and bar, regular active profiles e.g. baz, would still be always applied.  ``` @ParameterizedTestActiveProfiles(""foo"", ""bar"") @ActiveProfiles(""baz"") ```","closed","status: duplicate,","xenoterracide","2019-09-23T17:49:46Z","2019-09-24T10:56:48Z"
"","23410","TransactionAwareDataSourceProxy causing connection leaks","I'm testing a app which consist of hibernate and legacy jdbc is used together. I have a some spring testng test cases where i have TransactionAwareDataSourceProxy for managing transactions for legacy jdbc code under spring transactions which also update hibernate entities.  In my jdbc code i have special code segment which tried to unwrap the connection to get hold of the underlying connection to keep a mapping between some other information. This unwrapping behavior is implemented by calling the org.springframework.jdbc.datasource.ConnectionProxy.getTargetConnection method.  No my problem is when my code is inside a transaction and tries to call this unwrapping method that cause the TransactionAwareDataSourceProxy's invocation handler to get hold of the connection from the DataSourceUtils. This will increase the reference count at  org.springframework.transaction.support.ResourceHolderSupport class. Since my unwrapping call doesn't close the connection after this getTargetConnection method call, my code ended up not decreasign the reference count at ResourceHolderSupport. At the end of the transaction when the connection is going to release through org.springframework.jdbc.datasource.ConnectionHolder#released. The holder will be still open since the reference count which was increased for unwrap operation was not decreased, this cause the actual connection to be kept open.  My datasource defintion looks as follows ``` 	 		 			 				 				 				 				 				 			 		 		 	  ``` The getTargetConnection will return the underlying connection which will not be aware of the transaction aware proxy. So incrementing the resource holder in such case will not receive a matching release since the returned connection might be closed by the consumer outside the transaction awareness.  In my app i only use the underlying connection to read catelog information which isn't causing any state change on the database side.","open","in: data,","gayanper","2019-08-03T02:52:48Z","2021-11-10T11:28:35Z"
"","23064","MappingMediaTypeFileExtensionResolver ConcurrentModificationException","I'm seeing this issue running Spring 5.0.9 but the code involved doesn't look notably different in the master branch.  The MappingMediaTypeFileExtensionResolver can throw a ConcurrentModificationException when encountering a new media type. Here is the series of events in an example I'm seeing:  1. A request comes into the server at a URL like /something.tar.gz 2. The .gz suffix isn't initially mapped to any media type, but AbstractMappingContentNegotiationStrategy's handleNoMatch method is able to figure out that application/x-gzip is a reasonable content type for the ""gz"" suffix. 3. MappingMediaTypeFileExtensionResolver.addMapping is called to permanently add the mapping between application/x-gzip and the ""gz"" content type. This method is vulnerable to a ConcurrentModificationException because the fileExtensions map it's trying to update is not thread-safe.  Example stack:  ``` Exception caught during HTTP request. Returning status 500 java.util.ConcurrentModificationException: null 	at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134) ~[na:na] 	at org.springframework.util.LinkedMultiValueMap.add(LinkedMultiValueMap.java:87) ~[spring-core-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.accept.MappingMediaTypeFileExtensionResolver.addMapping(MappingMediaTypeFileExtensionResolver.java:80) ~[spring-web-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.accept.AbstractMappingContentNegotiationStrategy.resolveMediaTypeKey(AbstractMappingContentNegotiationStrategy.java:121) ~[spring-web-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.accept.AbstractMappingContentNegotiationStrategy.resolveMediaTypes(AbstractMappingContentNegotiationStrategy.java:102) ~[spring-web-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.accept.ContentNegotiationManager.resolveMediaTypes(ContentNegotiationManager.java:124) ~[spring-web-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.condition.ProducesRequestCondition.getAcceptedMediaTypes(ProducesRequestCondition.java:262) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.condition.ProducesRequestCondition.getMatchingCondition(ProducesRequestCondition.java:199) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.RequestMappingInfo.getMatchingCondition(RequestMappingInfo.java:222) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:93) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:57) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.addMatchingMappings(AbstractHandlerMethodMapping.java:384) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:352) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:318) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:62) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:350) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1188) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] ```","closed","type: bug,","ZikFat","2019-05-30T20:27:20Z","2019-06-11T22:41:42Z"
"","23278","Expose mime types in Jaxb2Decoder","I'm receiving xml data from a webserver. Problem: they are returned as `Content-Type=text/html` even though it is xml.  Developers are face webservers they don't have control of. Like in my case, so I cannot change the way the webserver responds.  As I'm working with `WebClient` reactive stream, I'm using `Jaxb2XmlDecoder` of course to decode xml to dto.  Only way is to tell the `Jaxb2XmlDecoder` that is should support more `MimeTypes`. It could be as easy as `new Jaxb2XmlDecoder(MimeTypeUtils.TEXT_HTML)`, **but** as the constructor is protected, that's not possible.  ``` public class Jaxb2XmlDecoder extends AbstractDecoder { 	public Jaxb2XmlDecoder() { 		super(MimeTypeUtils.APPLICATION_XML, MimeTypeUtils.TEXT_XML); 	} } ```  If you'd make the constructor public, those problems could be solved.  Current workaround could be as follows, but I don't know if there are performance drawbacks by creating an extra `ClientRequest`?  ``` private ExchangeFilterFunction contentTypeInterceptor() {     return ExchangeFilterFunction.ofRequestProcessor(clientRequest ->          Mono.just(ClientRequest.from(clientRequest)             .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_XML_VALUE)             .build())); } ```","closed","type: task,","membersound","2019-07-11T14:49:30Z","2019-07-13T10:02:28Z"
"","22821","LinkedCaseInsensitiveMap does not track removals via keySet, entrySet, or values","I'm learning spring boot (using Spring-boot 2.1.3) while playing with REST API calls i found something interesting with `HttpHeaders` object  Suppose if i have an HttpHeaders object with some values  ```java       HttpHeaders headers = new HttpHeaders();       headers.add(""Connection"", ""keep-alive""); ```  But now if i try to delete and add them again it throws `NullPointerException`  ```java       headers.entrySet().removeIf(entry -> entry.getKey().equals(""Connection""));       headers.add(""Connection"", ""keep-alive""); ```  Error:  ```        Caused by: java.lang.NullPointerException: null 	at org.springframework.util.CollectionUtils$MultiValueMapAdapter.add(CollectionUtils.java:460) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] 	at org.springframework.http.HttpHeaders.add(HttpHeaders.java:1559) ~[spring-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] 	at com.demo.DemoMain.run(DemoMain.java:27) ~[main/:na] 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:813) ~[spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE] 	... 5 common frames omitted ```","closed","in: core,","codeexistent","2019-04-19T20:09:08Z","2019-09-16T09:59:42Z"
"","23765","ClassUtils.isAssignable() returns false for the ""same"" types loaded from different ClassLoaders","I'm having a strange issue while using Spring Boot Auto Configuration and `@Autowired` is not working. Through debugging process I found this:  ![批注 2019-10-07 164404](https://user-images.githubusercontent.com/900606/66297495-5a9e6280-e922-11e9-829e-efb84a39ddaa.png)  The 2 arguments of method `isAssignable()` refers to the same class, but not the same Class instance because `lhsType` is loaded by `RestartClassLoader` and `rhsType` is loaded by `Launcher$AppClassLoader`.   As a result, `lhsType.isAssignableFrom(rhsType)` returns `false`, which makes Spring unable to locate the factory method to create this bean:  ``` 2019-10-07 17:05:30.598 DEBUG 944 --- [  restartedMain] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception  org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.hyd.dao.DataSources' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1662) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1221) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1175) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:595) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:376) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1411) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:592) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] ```  I have no idea why the 2 arguments are from different class loaders, and I don't know how to solve this problem.  ---  Affects: 5.1.10-RELEASE","open","in: core,","yiding-he","2019-10-07T09:08:43Z","2022-06-09T12:43:23Z"
"","23221","Extend caching for collections","I'd like to use the Spring Caching abstraction in a way that I can also ask for a bunch of items via a list of provided IDs, and then put the result into the cache, as if I had asked for each item one by one.   As an example, consider the following snippet: ```java     @Cacheable(""myCache"")     public String findById(String id) {         // ... access DB backend and return item     }      @CollectionCacheable(""myCache"") // let's suppose this exists and does the magic :D     public Map findByIds(Collection ids) {         // ... access DB backend, return map of id to item     } ``` Then usage would be: ```java // suppose the following call has happened before the examples below findById(""key1"")  // example1: uses ""key1"" from cache, never calls findByIds findByIds(Arrays.asList(""key1""))   // example2: calls findByIds([""key2""]) and uses value for ""key1"" from cache, //           puts value for ""key2"" into cache findByIds(Arrays.asList(""key1"", ""key2""))  // example3: calls findByIds([""key3"", ""key4""]) as there's nothing in the cache //           puts value for ""key3"" and for ""key4"" separately into cache findByIds(Arrays.asList(""key3"", ""key4""))  ```  I've implemented this functionality in a proof-of-concept Spring Boot application here: https://github.com/neiser/spring-collection-cacheable The main implementation can be found in `CollectionCacheInterceptor#handleCollectionCacheable`  The PoC lacks the following: 1. Modifying the `BeanFactoryCacheOperationSourceAdvisor` to account for my extra `CollectionCacheableCacheAnnotationParser` and `CollectionCacheInterceptor` only worked via a `BeanFactoryPostProcessor` 1. No consisderation of `sync` (might be possible, but is harder to implement) 1. The `CacheAspectSupport` (which I extended in `CollectionCacheInterceptor`) has only some methods protected, which required me to copy some of the code from `CacheAspectSupport` in `CollectionCacheInterceptor`  Still, the tests in `MyRepositoryIntTest` show that the PoC works 👍   My questions to you folks are: 1. Do you have a better idea how to ""modify"" the `BeanFactoryCacheOperationSourceAdvisor` in order to support my custom `@CollectionCacheable`? 1. Do you think the annotation `@CollectionCacheable` could be officially integrated in Spring's caching layer (of course with some more polishing)? I've seen some discussions on Stackoverflow and in particular in #19777 but they lack the ""partial"" invocation feature as in example 2 above (they proposes to use the Cache/CacheManager interfaces to achieve the desired functionality). 1. If you don't want to integrate something like `@CollectionCacheable`: The `CacheAspectSupport` class is hard to extend for my PoC. The same holds for `CollectionCacheableCacheAnnotationParser`, which is extending `SpringCacheAnnotationParser`. Would you mind to make this easier for my use case?   I'm happy to contribute a PR once I know what your opinion on this feature is. I can also polish the PoC further following your recommendations. I appreciate any feedback!","closed","in: core,","neiser","2019-07-01T11:29:16Z","2021-01-02T22:05:47Z"
"","23219","MockMvc no longer handles UTF-8 characters","I wrote simple controller:  ```java @RestController public class TestController {      @GetMapping(""/api"")     public Map simpleTest() {         // here is the text with special characters, all in UTF-8         return Collections.singletonMap(""test"", ""Příliš žluťoučký kůň úpěl ďábelské ódy"");     } } ```  Also very simple tutorial-like test:  ```java     @Before     public void setup() {         this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();     }      @Test     public void test() throws Exception {         this.mockMvc.perform(get(""/api""))                 .andDo(print())                 .andExpect(jsonPath(""$.test"").value(""Příliš žluťoučký kůň úpěl ďábelské ódy""));     } ```  The test fails in version 5.2.0.M3 now. Test passes in the previous milestone version 5.2.0.M2 and earlier versions.  The issue is somehow related to deprecation of `org.springframework.http.MediaType#APPLICATION_JSON_UTF8_VALUE`.  Of course it is possible to fix the test by adding _accept_ but I rather do not do that, because `APPLICATION_JSON_UTF8_VALUE` is deprecated now.  ```java .accept(MediaType.APPLICATION_JSON_UTF8_VALUE) ```  I have also prepared simple maven project to simulate the problem. [springutf8.zip](https://github.com/spring-projects/spring-framework/files/3345177/springutf8.zip)  It seems to me, that `MockMvc` client does not handle UTF-8 characters well, like other modern browsers.","closed","type: regression,","momega","2019-07-01T10:46:37Z","2019-10-09T08:19:19Z"
"","23770","Consider adding ""ObjectProvider#getIfNotUnique"" and its variants","I write a library on spring-boot and it is used by multiple apps. Since it is a library, I do not know what beans are defined up front; thus I use `ObjectProvider`  often.  Currently, to check whether the beans are not unique(with semantics of `@Primary` is the unique), we need to use List or iterate and check the size.  To streamline the API, it is nice to have `getIfNotUnique` and its variant methods available in `ObjectProvider`.  Something like: - `List getIfNotUnique()` - `List getIfNotUnique(Supplier> defaultSupplier)` - `void ifNotUnique(Consumer> consumer)`  If ordering is the matter, may need to separate APIs for ordered and not ordered.","open","status: feedback-provided,","ttddyy","2019-10-09T02:33:41Z","2021-11-11T09:05:40Z"
"","23017","Support separate annotation introspectors in Jackson2ObjectMapperBuilder","I would like to be able to reuse the existing `Jackson2ObjectMapperBuilder` to set an `AnnotationIntrospector` for serialization only.  This is currently not possible since the `Jackson2ObjectMapperBuilder` only supports a single `AnnotationIntrospector` which will be used for both serialization and deserialization.","closed","type: enhancement,","otheriault","2019-05-22T19:45:02Z","2020-05-13T11:31:44Z"
"","23342","Improve WebClient.Builder::filter documentation","I would assume the following adds the filter **after** any existing filters into the chain: ``` @Service public class YourService {      //builder is injected      public YourService (WebClient.Builder builder) {          builder.filter(ExchangeFilterFunction.ofResponseProcessor(...)))...build();      } }  ```  But in fact this adds the filter on top, so that this filter is processed **first**, instead of **last** as I would expect.  This is a problem when having a default `WebClient` that has already a common logging-filter (eg defined through your own company-wide framework), and now you want to add any other filter, eg an statuscode-filter:  ``` private static ExchangeFilterFunction statuscodeFilter() { 	return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> { 		HttpHeaders headers = clientResponse.headers().asHttpHeaders(); 		if (headers.getFirst(""customStatus"").equals(""400"")) { 			return Mono.error(new CustomWebError()); 		} 			 		return Mono.just(clientResponse); 	}); } ```  Of course, even in case of exceptions, you still want the logger to be executed **before** the statuscode filter. As otherwise you'd lose the logging functionality.  But the only way to achieve this is:  ``` .filters(filters -> filters.add(filters.size()-1, statuscodeFilter())) ```  So could this be optimized? Is it worth adding a `.filterFirst()` or `filterLast()` function to directly set the new filter into a specific order? Or if you stick with the solution adding the filter within `.filters(idx, filter)`, then maybe the docs could be more clear on this?","closed","in: web,","membersound","2019-07-23T12:09:37Z","2019-11-20T10:58:37Z"
"","22978","Enhancement - MockHttpServletRequestBuilder - Add ability to manually set queryString","I will go ahead and admit that this use case is probably unconventional, but such is life when maintaining/upgrading legacy systems.  Essentially, I need to stream a report file to the browser and I have to do it via a GET request.  Since GET requests don't support a Request Body, and my UI can apply filters to the report, I need to send the filters as an encoded query string...I'll pause for a second so you can process.  This was something I found that was mildly annoying and would have made writing my test a bit easier:  ``` this.mockMvc.perform(     get(""/api/reports/download"")     .session(mockHttpSession)     .queryString(encodedQueryString)) //this is the part I want added     .andExpect(status().isOk()); ``` Let me know if anyone else out there thinks this would be a nice thing to have.  I'm essentially thinking that .queryString() and .param() would be mutually exclusive.  This Builder is for testing, so it would be nice to just have the flexibility.","closed","status: declined,","mjohns39","2019-05-15T15:33:41Z","2019-05-17T14:28:57Z"
"","23629","Add SVG mapping to mime.types file for JavaMail support","I was trying to change my picture to SVG in a generated email. Now I understand why it was not working properly.","closed","type: enhancement,","douddle","2019-09-12T13:30:39Z","2019-09-12T14:53:16Z"
"","23617","Spring not injecting the configured conversionService into the DataBinder.","I was trying to add some converters to be used while binding a form. Spring version : 4.3.17 when adding some converters to conversionService, we add a bean with the custom converters i, the xml file, then we add the following tag  and our configured bean will be injected, but if we have another config xml file, having the following tag , spring will inject the default conversionService, the one without our custom converters.","closed","status: invalid,","mboufous","2019-09-11T08:28:13Z","2019-09-11T11:17:00Z"
"","23389","Invalid using @EnableCaching(mode = AdviceMode.ASPECTJ)","i want use `@EnableCaching(mode = AdviceMode.ASPECTJ)` but it not work?","open","in: core,","brucelwl","2019-07-28T10:43:17Z","2021-11-10T09:51:26Z"
"","23433","spring test package","i want to learn spring from sources these days, could you give me your test packages for me to start with?  just those test cases for  each function points.","closed","status: declined,","gravin","2019-08-08T09:04:57Z","2019-08-09T12:10:56Z"
"","23625","BeanCopier not support setter with 'return this'","I want to copy bean using BeanCopier ,my target bean has setter with 'return this', then it do not work. but if i modify the setter with no return,it works. can you support the setter (with return this)? ![V91817_I7{MDIFQ}7ML0CBF](https://user-images.githubusercontent.com/10300594/64752203-40ef4280-d551-11e9-8c86-261460186b8a.png)","closed","status: declined,","wxq1990","2019-09-12T03:34:21Z","2019-09-12T11:03:22Z"
"","23687","Spring Cache:How to set prefixKeysWith in RedisCacheConfiguration","I want to change prefixKey in RedisCacheConfiguration with below code: `@Component public class RedisCacheConfigurationBeanPostProcessor implements BeanPostProcessor {     @Override     public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {         if (bean instanceof org.springframework.data.redis.cache.RedisCacheConfiguration) {             ((RedisCacheConfiguration) bean).prefixKeysWith(""#"");         }         return bean;     } }` **but this not work!**","closed","for: stackoverflow,","jianguo8661","2019-09-24T07:36:34Z","2019-09-24T07:37:52Z"
"","23610","When I use Swagger, I use the SpringVersion.getVersion() method to return null.","I user Swagger in Spring Cloud but it prompts me to return Null when using SpringVersion to get the Spring version number. I'm using Spring-core is 5.1.6.REALESE. thank you!","closed","","ywbjja","2019-09-09T06:00:49Z","2019-10-08T10:44:35Z"
"","23362","Introduce SimpleUrlHandlerMapping constructor that accepts an order and a Map","I use `SimpleUrlHandlerMapping` for reactive websockets and I either end up instantiating the bean and then calling `.setUrlMap(...)` and `setOrder(...);` Or I create an anonymous subclass and call those setters in that. Either way, tedious. Please add a constructor so it can be a one-liner :-)","closed","type: enhancement,","joshlong","2019-07-26T02:33:49Z","2019-07-28T16:03:28Z"
"","23727","Remove TODO in AnnotationUtils","I think we should remove [this TODO](https://github.com/spring-projects/spring-framework/blob/b24ac741063ed04233df32f6e3a5e57dd1755b6f/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java#L173) before we go GA since we're not planning to address this in the current release.","closed","in: core,","philwebb","2019-09-29T18:02:46Z","2019-09-30T05:57:25Z"
"","23300","Use StringJoiner where possible to simplify String joining","I think this is the last change of this kind in Spring's code base","closed","status: feedback-provided,","stsypanov","2019-07-16T17:47:08Z","2019-07-24T08:28:33Z"
"","23224","Change @TestConstructor.autowire attribute into an enum","I think it's possible that we might want to support different autowire modes with `@TestConstructor` in the future. Specifically, I think it would be nice if we could mix autowire with other extension mechanisms and have autowiring apply only when no other `ParameterResolvers` match.  I wonder if we should change `autowire` from a `boolean` to an `enum` so we can add more options in the future.  e.g.:  ```java @TestConstructor(autowire=Autowire.ANNOTATED) @TestConstructor(autowire=Autowire.ALL) @TestConstructor(autowire=Autowire.REMAINING) ```","closed","type: enhancement,","philwebb","2019-07-01T17:17:20Z","2019-07-11T17:07:02Z"
"","23569","Fix DefaultListableBeanFactory#copyConfigurationFrom","I think it should use **otherListableFactory** to copy configuration","closed","in: core,","GungnirLaevatain","2019-09-03T07:44:13Z","2019-09-25T19:08:17Z"
"","22849","Why dont' you use BufferedOutputStream?","I noticed that in `MultipartFile.transferTo()` methods, and probably also in other point of the code, you don't use `BufferedOutputStream`. Why?","closed","","Marco-Sulla","2019-04-28T07:20:42Z","2019-04-29T06:33:52Z"
"","22949","Add HttpHeaders.getOrEmpty(…) to avoid clients having to default to an empy list","I know that the semantics of the existing `get(…)` method align with what `Map` defines. However as headers are always multi-value and the method returns a list, it would be useful to have an additional method that simply defaults to an empty list instead of `null` as it's good practice for methods that return lists.","closed","type: enhancement,","odrotbohm","2019-05-13T08:11:10Z","2019-05-22T13:28:03Z"
"","23488","Empty Part variables when sending Multipart request with 5.2.0.M2","I just switched to the spring-boot-webflux version 2.2.0.M3 due to the new r2dbc-M8 release and experiencing some issues with the multipart variable resolving in the spring webflux 5.2.0.M2 module. **I am not able to receive a simple String which was posted in the Body of my webclient.** I can't figure out why this behavior changed from webflux 2.1.9.RELEASE to 5.2.0.M2. Also I don't see any significant information about this issue in the migration guide (https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x). So every attempt to receive a String just failed and I got an empty String. But I would at least expect an Exception because the Parameter obviously can't be fetched (would be null?).  I've added a test-Project to clarify my expectations in a simple unit test. My basic setup to validate the behavior is as follows:  TestController: ```kotlin @RestController class TestController {     @PostMapping(consumes = [MULTIPART_FORM_DATA_VALUE], produces = [APPLICATION_STREAM_JSON_VALUE])     fun uploadStuff(             @RequestPart(""title"") title1: String,             @RequestPart(""title"") title2: Part,             @RequestPart(""title"") title3: Mono,             @RequestPart(""title"") title4: Mono,             @RequestPart data: Mono): Mono> { [...] } ``` ControllerResponse: ```kotlin data class TestResult(         val titleAsDefaultString: String,         val titleAsPart: String,         val titleAsMonoString: String,         val titleAsMonoPart: String,         val data: ByteArray ) ``` Test method: ```kotlin @Test fun `submit multipart data to Controller`() {     val body = MultipartBodyBuilder()             .apply { part(""title"", ""someTitle"") }             .apply { part(""data"", FileSystemResource(testData)) }             .build()      val bodyReceived = testClient             .post()             .contentType(MULTIPART_FORM_DATA)             .syncBody(body)             .exchange()             .expectStatus().isOk             .expectBody()      logger.debug(""Received Body: ${String(bodyReceived.returnResult().responseBody)}"")      bodyReceived             .jsonPath(""$.titleAsDefaultString"").isEqualTo(""someTitle"")             .jsonPath(""$.titleAsPart"").isEqualTo(""someTitle"")             .jsonPath(""$.titleAsMonoString"").isEqualTo(""someTitle"")             .jsonPath(""$.titleAsMonoPart"").isEqualTo(""someTitle"")             .jsonPath(""$.data"").isNotEmpty } ```  [reactiveweb.zip](https://github.com/spring-projects/spring-framework/files/3519911/reactiveweb.zip)","closed","","Numbernick","2019-08-20T10:13:26Z","2019-09-25T13:42:22Z"
"","23194","Spring 5 Webclient doest not throw ReadTimeout Exception in the interdependent calls","I have two interdependent webclient calls to different api's , when the first webclient call's response is delayed then readtimeout exception is coming . but whenever the first call is success and the second call's response is delayed then it is waiting for the response indefinitely.  i tried creating two seperate instances of webclient for each call . still issue persists.","closed","for: stackoverflow,","madhukundala","2019-06-25T09:16:38Z","2019-06-25T09:28:01Z"
"","23472","spring-data-jpa: Uninitialized HIbernateProxy cannot be deleted by repository","I have such base entity class with **private** version property: ```java public abstract class AbstractEntity { ... 	@Version         @Column(nullable = false) 	private Long getVersion() { 		return version; 	}  	@SuppressWarnings(""unused"") 	private void setVersion(Long version) { 		this.version = version; 	} } ``` When I try to delete entity (which is actually **uninitialized** hibernate proxy) by entity repository, the deletion does not occur. ```java Document document = documentLine.getDocument(); 		 Assert.assertFalse(""Document must not be initialized."", Hibernate.isInitialized(document)); 		 Assert.assertThat(document, IsInstanceOf.instanceOf(HibernateProxy.class)); 		 documentRepository.delete(document); ``` Method ```java org.springframework.data.jpa.repository.support.SimpleJpaRepository.delete(T entity)``` detects that entity is **new** entity.  But if I try to delete implementation of proxy then the deletion occurs as expected.  In attached project you could find two test cases to reproduce issue.   In the first test case, an attempt is made to delete a proxy. (fail) In the second test case, an attempt is made to delete a unproxy entity. (success)  Issue reproduces in versions of spring.data.releasetrain.version **Lovelace-SR10** and **Lovelace-SR9**.  Before version **Lovelace-SR9** both test cases complete successfully.  Libraries versions: ```    1.3.176   4.12   5.4.4.Final   5.1.9.RELEASE   2.1.6.RELEASE   Lovelace-SR10   1.3   2.0.1.Final   6.0.17.Final  ``` [spring-data-issues.zip](https://github.com/spring-projects/spring-framework/files/3509992/spring-data-issues.zip)","closed","for: external-project,","toughpheeckouse","2019-08-16T14:53:07Z","2019-08-17T12:31:11Z"
"","23496","Feature request: provide support for JSR 310 types in CronTrigger","I have noticed that `CronTrigger `still uses `java.util.Date` to compute the next execution time.  That component should be considered outdated in favour of the JSR-310 types, in particular with the current implementation of `CronTrigger`s it should be possible to generate no more than a LocalDateTime, since 1) CronTriggers do not carry timezone information and 2) normally time triggers are used to schedule actions on a local node.  Of course, the developer can always convert a Date to a LocalDateTime, but it would be nice if Spring provided native support for JSR-310 types natively and a fallback java.util.Date implementation that basically converts the computed LocalDateTime into Date.  I _think_ that the implementation of a cron sequence generator using JSR 310 is simpler, especially because the current one uses Calendar.","closed","type: enhancement,","djechelon","2019-08-21T10:02:47Z","2020-08-03T14:45:13Z"
"","23525","Getting 500 instead of 406 when upgraded to Spring 5.0.7","I have my controller configured with this and both have differrent implementations as 1 returns json and other returns zip ```java @RequestMapping(value = ""/get/{id}"", method = RequestMethod.GET, headers = ""Accept=application/json"", produces = ""application/json"") ``` ```java @RequestMapping(value = ""/get/{id}"", method = RequestMethod.GET, headers = ""Accept=application/zip"", produces = ""application/zip"") ``` When i make a request with header `Accept = 'application/xml'` (or any thing other than application/json and application/zip') It used to give 406 StatusCode in Spring 4.1.5 but when i have updated Spring Version to 5.0.7 and Spring boot to 2.0.5 it is returning 500 StatusCode   Can I know why the behavior is changed and what is the solution as i need 406.?","closed","status: feedback-reminder,","akheel96","2019-08-27T09:30:25Z","2021-01-08T13:09:12Z"
"","22833","Add Embedded MySQL","I have been using [Embedded MySQL](https://github.com/wix/wix-embedded-mysql) for testing, this PR makes it available via Spring APIs for the same purpose.","closed","status: declined,","juliano","2019-04-24T12:43:29Z","2021-12-10T22:21:37Z"
"","23787","When using Jackson2ObjectMapperBuilderCustomizer with DefaultTypeResolver, Flux doesn't serialize correctly","I have a Springboot REST server  in which I overrode the default Jackson ObjectMapper Settings by the following: ``` @Configuration public class ServerConfiguration {    @Bean   Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {     TypeResolverBuilder typeResolver =         new ObjectMapper.DefaultTypeResolverBuilder(DefaultTyping.NON_FINAL).init(Id.CLASS, null)             .inclusion(As.PROPERTY);     return jacksonObjectMapperBuilder -> jacksonObjectMapperBuilder         .defaultTyping(typeResolver);        }  } ```  Then, In a controller I set up a flux endpoint: ``` @RestController public class Controller {   @GetMapping(value = ""/test"")   public Flux getFlux() {     return Flux.just(true);   } } ```  When I test the endpoint with a browser (http://localhost:8080/test), I get: - **[""org.springframework.web.servlet.mvc.method.annotation.ReactiveTypeHandler$CollectedValuesList"",[true]]** - But the expected output is: **true**  -- - Spring boot version: 2.1.2.RELEASE - Java version: JDK 8","closed","status: invalid,","zeralight","2019-10-12T10:45:18Z","2019-10-15T18:51:40Z"
"","23717","MockServletContext should treat InvalidPathException like an IOException","I have a simple `ConfigurationProperties` class that binds a String property to a `Path` object:  ```java @Component @ConfigurationProperties(""app"") @Getter @Setter public class AppConfigurationProperties { 	 	private Path somePath; } ```  Then I define `app.somePath=C:\\temp` within _application.properties_. This works when running the application, but a simple Test that loads the context throws:  ``` com.example.demo.DemoApplicationTests > contextLoads() FAILED     java.lang.IllegalStateException         Caused by: org.springframework.boot.context.properties.ConfigurationPropertiesBindException             Caused by: org.springframework.boot.context.properties.bind.BindException                 Caused by: org.springframework.core.convert.ConverterNotFoundException ```  The test class is most simple:  ```java @SpringBootTest public class DemoApplicationTests {  	@Test 	public void contextLoads() { 	} } ```  I created a project with the most recent Spring-Boot version (2.1.8.RELEASE) with Initializr (Gradle build with Spring Web as only dependency) to replicate the problem in isolation. It can be found [here](https://github.com/Spunc/demo). I run the project on Windows 10.  I found out that the test passes, if there are no backslashes in the property value. Furthermore, it passes if I don't use `org.springframework.boot:spring-boot-starter-web` but `org.springframework.boot:spring-boot-starter` as dependency. (The test project does not require web, but the actual project does.)","closed","type: bug,","Spunc","2019-09-25T09:41:16Z","2019-11-15T13:12:07Z"
"","22811","HttpClientErrorException getResponseBodyAsString() returning byte string","I have a problem getting the response body from an 403 http code response from third party server. Before april 5 2019 I was able to get the response body from third party correctly but for now I'm retrieving a byte string from getResponseBodyAsString. Is this an issue from package org.springframework.web.client? ``` try{     //Request via restTemplate..     } catch (HttpClientErrorException | HttpServerErrorException ex) {                 loggingService.writeLogs(""Error From Third Party Request, Message: "" + ex.getMessage() + ""| Response Body: "" + ex.getResponseBodyAsString(), this.getClass(), LoggingEnum.ERROR, BatchConstants.moduleId); ```  Here is sample value I get when debugging the code:  ![stackover1](https://user-images.githubusercontent.com/26607878/56283159-7e3ada00-6143-11e9-93ba-5dc6a030e336.PNG)  Response on hitting third party api directly ![stack2](https://user-images.githubusercontent.com/26607878/56283267-cc4fdd80-6143-11e9-9eb7-1c7894dc3c5c.PNG)        ...","closed","for: stackoverflow,","gerwin123","2019-04-17T11:05:54Z","2019-04-17T11:39:51Z"
"","23402","Explicit attribute overrides configured via @AliasFor not supported for components picked up via component scanning","I have a longer set of annotation attributes, so I use `@AliasFor` to set up a short annotation. If the new annotation is set on the boot class, the value of the annotation attributes can be obtained, but the value of the annotation attributes can not be obtained on the non-boot class Maybe if you look at my demo, you can get a clearer understanding of what I mean. https://github.com/brucelwl/demo","closed","status: feedback-provided,","brucelwl","2019-08-01T15:57:02Z","2019-08-09T12:29:31Z"
"","22857","Generic class and @JsonUnwrapped causes failure to deserialize JSON in some cases","I have a generic class which wraps another generic class which itself wraps a couple of other classes. I want the JSON from all these to be ""flattened"", so I use the `@JsonUnwrapped` annotation. I can then GET and POST the flattened JSON and it all works fine. But if I then introduce some abstract (generic) REST controller, so that the method which receives the POSTed data is in a generic class, Spring fails to deserialize the JSON correctly.  For clarity, here's some code that explains the situation...  First, I have some DTOs representing information about a user:  ``` public class UserBasicInfo {     private String name;      // ... getters and setters }  public class UserExtendedInfo {     private String roleName;      // ... getters and setters } ```  I then have a generic class that I use to combine this ""basic"" and ""extended"" information:  ``` public class ItemInfo {     @JsonUnwrapped     private Basic basicInfo;      @JsonUnwrapped     private Extended extendedInfo;      // ... getters and setters } ```  I then have a generic class which wraps the generic class above and adds more information to it (e.g an ID):  ``` public class SavedItem {     private Id id;      @JsonUnwrapped     private Info info;      // ... getters and setters } ```  In the end, what I work with is an object of this type: `SavedItem>`  If I then have a controller which receives an item of that type, as shown below, it all works OK:  ``` @RestController public class UserRestController {     @PostMapping     public void handle(@RequestBody SavedItem> item) {     } } ```  However, if I declare that method instead in an abstract generic base class, as shown below, it doesn't quite work:  ``` public abstract class AbstractRestController {     public void handle(SavedItem> item) {         // Here, item.getInfo().getBasicInfo() returns null, as does getExtendedInfo()     } }  @RestController public class UserRestController extends AbstractRestController { } ```  What happens is that the `basicInfo` and `extendedInfo` items are left null as the JSON fails to be deserialized correctly.  The issue does not occur if: * The concrete class, `UserRestController`, explicitly implements the method(even if it just overrides it and then calls the super class's implementation),  Or * There is only one generic class rather than two, e.g. if the method receives `ItemInfo` instead of `SavedItem>`  Or * I don't use `@JsonUnwrapped` (meaning the JSON has a couple of extra levels of nesting within it).  The reason I think this might be an issue with Spring rather than Jackson is because if I put a breakpoint in `AbstractJackson2HttpMessageConverter.readJavaType()` ([line 239](https://github.com/spring-projects/spring-framework/blob/842e7e5ef71e30e9ff3a37af11b68b626e7fb350/spring-web/src/main/java/org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter.java#L239)) I can see that when the Jackson object mapper is called, the `javaType` argument which is passed to it doesn't have any of the generic information in the `ItemInfo` class.  Whereas when that same line of code is hit when the REST controller method is implemented in the concrete class, then the full generic type information is correctly passed into Jackson.  However that's just a guess, so if you think this is actually a Jackson issue let me know and I'll log an issue with them.  A git repo where the issue can be replicated is available [here](https://github.com/yonigibbs/spring-jackson-unwrapped). Details of how to replicate it are provided in the readme in that repo.  The version information is: * Spring Boot 2.1.4.RELEASE * Spring Framework 5.1.6.RELEASE * Jackson 2.9.8","open","in: web,","yonigibbs","2019-04-30T08:05:10Z","2021-11-12T13:49:43Z"
"","23115","Feature: Supplier for default header in WebClient","I have a function that I need to call to insert a token into all my requests, so I cannot use the `org.springframework.web.reactive.function.client.WebClient.Builder#defaultHeader` for that. But would be nice if that method also accepted a `java.util.function.Supplier` of `String`.","closed","","Sam-Kruglov","2019-06-12T10:22:54Z","2019-06-19T09:08:53Z"
"","23601","@ConfigurationProperties in plain spring","I have a feature request. In spring boot we have `@ConfigurationProperties` to read the properties directly into bean, but there is nothing equivalent on the plain Spring side.  In our organization, we have a light framework shim over Spring . And due to legacy reasons we have two flavors of framework - First, expose controller as Jersey with Spring DI and deployed as WAR (legacy) - Second, deploy as SpringBoot App with Jersey Controller.  Now, this all work but reading properties like SpringBoot becomes challenge in plain Spring. Is it possible or do you have any workaround to import  `@ConfigurationProperties` in plain Spring. Any support will be highly appreciated!","closed","status: declined,","pulkitmehra","2019-09-06T19:07:59Z","2019-09-08T06:55:15Z"
"","23008","Async request timeout for returned Mono","I have a controller method returning Mono with a timeout operator. However default 30s timeout in Tomcat is applied, I can configure it globally, but in this case it should be per-request.  My current workaround is executing the following code before returning the value.  ```java WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(servletRequest); asyncManager.registerDeferredResultInterceptor(""SET_TIMEOUT"", new DeferredResultProcessingInterceptor() {   @Override   public  void preProcess(NativeWebRequest request, DeferredResult deferredResult) {     final HttpServletRequest servletRequest = (HttpServletRequest) request.getNativeRequest();     servletRequest.getAsyncContext().setTimeout(timeout);   } }); ```","closed","in: web,","panchenko","2019-05-21T08:12:14Z","2021-01-08T13:25:42Z"
"","23028","I want to improve jdbcTemplate","I had used mongoTemplate and was fascinated,So i starting an project which is a orm framwork, It  likes a combination of jpa and mongoTemplate usage and based on jdbcTemplate.I prefer contributing it to spring-jdbc,but i have no idea to do, here is my project url [https://github.com/SpringStudent/GyJdbc](url) Looking forward to your reply.","closed","","SpringStudent","2019-05-24T10:09:22Z","2022-02-18T19:10:12Z"
"","22971","Add an option to not include Charset in the final http request ContentType Header","I had the following problem when using `RestTemplate`. The `FormHttpMessageConverter` always adds the charset like this `application/x-www-form-urlencoded; charset=UTF-8`. But, the service I was consuming was malfunctioning if I give the charset like this. It was working with just `application/x-www-form-urlencoded` without the charset parameter. This is an external service, so I do not have control over it.   ## How I solved it I subclassed `MediaType`, `HttpHeaders` and `HttpEntity`, so that the `getMediaType` method in `FormHttpMessageConverter` do not try to create a new `MediaType` with parameters.   ## What I am proposing  I think there should be a property in the `FormHttpMessageConverter` `includeCharset`. We do the charset validation as usual, but before writing the `ContentType`, we check the flag to exclude the parameter.  I am happy to give a PR if this sounds okay.","closed","type: enhancement,","tamimcsedu19","2019-05-14T03:48:07Z","2019-11-26T10:04:06Z"
"","23481","Use Collections.addAll() where feasible","I found that some code can be replaced with a lambda expression when using IDEA for inspect the code.so submit a PR here.","closed","type: task,","ysc972","2019-08-18T11:40:50Z","2019-12-13T15:22:56Z"
"","23327","Allow to create a MergedAnnotations instance composed of multiple MergedAnnotations instance","I find myself having to lookup annotations from an ordered set of different locations and use the information from the first location a particular annotation is present. The particular use case is to find some object mapping annotations on some property accessor methods first but falling back to the field backing a property.  I currently keep [a `List` with the accessor method derived instances first, the one created from the field last](https://github.com/spring-projects/spring-hateoas/blob/a71aeeb4d12650ee82302b01cde54b891a44ef6b/src/main/java/org/springframework/hateoas/mediatype/PropertyUtils.java#L301-L304) and stream over them, check for whether the annotation is present, if so use that and continue looking for it otherwise (see [this](https://github.com/spring-projects/spring-hateoas/blob/a71aeeb4d12650ee82302b01cde54b891a44ef6b/src/main/java/org/springframework/hateoas/mediatype/PropertyUtils.java#L371-L378)). It would be cool if that external iteration could be hidden behind a `MergedAnnotations` instance in the first place.  /cc @philwebb","closed","status: superseded,","odrotbohm","2019-07-21T16:01:41Z","2019-07-23T13:05:07Z"
"","23634","Make org.springframework.web.multipart.MultipartFileResource Public","I don't see anypoint in makeing this class org.springframework.web.multipart.MultipartFileResource Package scoped. This class can be used by any Spring Developer to convert MultipartFile to Spring Abstration of Resource and hence must be public.","closed","status: waiting-for-feedback,","ankurpathak","2019-09-13T02:20:20Z","2021-01-08T13:09:13Z"
"","22822","StompBrokerRelay doesn't send heartbeats to broker when @MessageMapping handles received messages","I discovered that `StompBrokerRelayMessageHandler` just forwards all messages from webscoket connection. This includes heartbeats from STOMP (over webscoket) clients (including `WebSocketStompClient`).  This works fine. But there is one caveat here. Not all STOMP messages from webscoket are handled by `StompBrokerRelayMessageHandler`. Some of them handled by `SimpAnnotationMethodMessageHandler` because their destination has prefix equal to prefix, that is set in `MessageBrokerRegistry.setApplicationDestinationPrefixes`.  For example:  ```     @Override     public void configureMessageBroker(MessageBrokerRegistry registry) {         registry.setApplicationDestinationPrefixes(""/app"");         registry.enableStompBrokerRelay(""/topic"", ""/queue"");     } ```  If `WebSocketStompClient` just sends a message every 1 second to `/app/greeting` destination, then this message is handled by controller `@MessageMapping(""/greeting"")` and if that controler doesn't forward it to `/topic/greeting` in the same tcp-session (with RabbitMQ broker) (i.e. returning a value from controller's method), then **RabbitMQ never receives that message**.  It is common situation, I think. Not all application controllers should send something into broker. Especially **into the same tcp connection** that associated with websocket, from which message received. For example, I want to send message from my controller, but I want to send it through `_system_` connection (not through connection, associated with webscoket, from which the message come) to the broker using `SimpMessagingTemplate`.  And the problem here is that `WebSocketStompClient` thinks it sends some bytes (it actually does), so it's `org.springframework.messaging.simp.stomp.DefaultStompSession.WriteInactivityTask` is never called.  But at the same time these bytes are never delivered to RabbitMQ broker, because they are handled by `@MessageMapping` controller. So the **RabbitMQ doesn't receive any bytes in the heartbeat interval and closes the connection**.  ```  [warning] <0.20898.54> STOMP detected missed client heartbeat(s) on connection 192.168.250.203:41574 -> 172.17.0.2:61613, closing it ```  I think there are two solutions here:  1. Just always send heartbeats from `WebSocketStompClient` on specified interval, without relying on whether some bytes were send recently or not.     As I see, [stompjs](https://github.com/stomp-js/stompjs) does [exactly that](https://github.com/stomp-js/stompjs/blob/f11ad889211b9a8bd5c90d7309a23b832e1b60af/src/stomp-handler.ts#L237-L242). It is not exactly how heartbeats should work in STOMP protocol as described [here](https://stomp.github.io/stomp-specification-1.2.html#Heart-beating), but it is more defensive (and produces more traffic of course).  2. Do not forward heartbeats from `WebSocketStompClient` (and any other connected websocket STOMP client), but do heartbeating with broker internally instead, like it does for `_system_` connection. At the same time, do not forward heartbeats from broker to the webscoket, and instead do heartbeating with websocket internally. So, there will be two independent sets of heartbeat senders/chekers: one to broker side, and one to websocket side. So, even if the client will send only application messages (and will not send heartbeats because of that), the broker will still receive heartbeats from internal scheduler and will not close the connection.     This soulution is more server resource intensive I think. The relay will have to do some scheduling instead of just relaying heartbeats back and forward, but it looks like a more ""right"" solution, that doesn't violate STOMP protocol (in the sense of not sending heartbeats to the broker in specified interval because of `@MessageMapping`).     While I think this solution is more ""right"", I'm worried about performance here. For example, to service 10k webscoket connections, it should be 10k `onWriteInactivity` and 10k `onReadInactivity` checks on both sides , total 40k.","closed","type: enhancement,","xak2000","2019-04-20T16:08:20Z","2020-11-25T12:10:25Z"
"","23706","Update documentation for importing projects into Eclipse","I did follow the steps mentioned in https://github.com/spring-projects/spring-framework/wiki/Build-from-Source, but still getting errors in the project .Do we need to install kotlin support plugin for eclipse ? Also the version against which the version of STS is given doesnt seem to be available now ?  Kindly update the steps","closed","type: documentation,","rakotkar","2019-09-25T17:46:07Z","2019-09-30T16:23:14Z"
"","23197","why can't a bean being autowired","I declare this class:  ```java @SpringBootApplication public class ProgrammingTrading {     @Bean     public Logger logInit() {         return LoggerFactory.getLogger(Logger.class);     } } ```  and want to use like this:  ```java @Service public class MarketDataRobot extends Thread {     @Autowired     private Logger logger; } ```  but always got null pointer exception, I just don't get it ...  thank you very much.","closed","for: stackoverflow,","omobh","2019-06-26T09:22:35Z","2019-06-26T10:15:19Z"
"","22944","WebMvcConfigurationSupport's BIG BUG","i configured default-property-inclusion: NON_NULL in my application.yml，it is work very well.BUT,when i create an @Configuration java class，it crashed. my json encodes null field in my json. ``` @Configuration public class MyConfiguration extends WebMvcConfigurationSupport{ 	 	/** 	 * 可以注册一些拦截器 	 */ /*	@Override 	public void addInterceptors(InterceptorRegistry registry) { 		//registry.addInterceptor(new CrossOriginInterceptor()); 	}*/  	/** 	 * 解决跨域问题 	 *  	 * 外围网关已经对跨域问题进行了统一处理，微服务内部可以不再关注跨域。 	 * 如果想直接将微服务对外提供跨域服务，跨域将注释放开。（如开发调试等特殊需求） 	 */ /*	@Override 	public void addCorsMappings(CorsRegistry registry) { 		//registry.addMapping(""/**"").allowedOrigins(""*"").allowedMethods(""*"").maxAge(24*60*60); 	}*/ ```","closed","","xiongchun","2019-05-11T16:42:23Z","2021-01-08T13:09:07Z"
"","23183","I'm sorry I didn't describe my problem clearly。when i get the source code from github,and build from the command line,then import into my IDEA.the problem is that i create a spring demo module and when i build it,the error was occured: Error:(19, 28) Kotlin: Unresolved reference: core. (my kotlin version is 1.3, and java version is jdk1.8.0_161, gradle version: 5.4.1)","I can't do much which no more detail provided. Please provide a repro project and check your configuration against the one generated from https://start.spring.io/?language=kotlin.  _Originally posted by @sdeleuze in https://github.com/spring-projects/spring-framework/issues/23161#issuecomment-503887201_","closed","for: stackoverflow,","bai597030001","2019-06-24T02:05:11Z","2019-06-24T12:10:29Z"
"","23086","Rename TransactionSynchronizationManager#currentTransaction to something more meaningful","I am working currently on implementing reactive Transactions with our new Neo4j reactive driver and need to access the reactive transaction synchronisation manager through  ``` ...reactive.TransactionSynchronizationManager#currentTransaction ```  The JavaDoc says ""…Return the TransactionSynchronizationManager of the current transaction…""  I understand that `TransactionSynchronizationManager` is merely a wrapper around the `TransactionContext`.  Neither the manager nor the context are the transaction itself and therefor I think that the `currentTransaction()` would benefit from another name, like `current TransactionSynchronizationManager()` or `currentTransactionContext()`; it's intentions would be clearer.  cc @mp911de","closed","status: feedback-provided,","michael-simons","2019-06-05T08:42:23Z","2019-08-31T10:15:11Z"
"","23511","logging.level.org.springframework.web=DEBUG fetches lazy-loaded entity fields","I am using Spring Boot together with JPA. When `logging.level.org.springframework.web=DEBUG` is set, fetching an entity via JPQL fetches lazy-loaded fields via SQL, even if they are annotated with `@JsonIgnore`.  Example:  ```java @Entity public class Author {     @Id     private UUID id;      @JsonIgnore     @OneToMany(cascade = CascadeType.ALL, mappedBy = ""author"", fetch = FetchType.LAZY)     private List books;      @Column     private UUID groupId; }  @Entity public class Book {     @ManyToOne     private Author author; }  public interface AuthorRepository extends JpaRepository {     @Query(""SELECT a FROM Author a WHERE a.groupId IN :groupIds"")     Page findByGroupIds(@Param(""groupIds"") Set groupIds, Pageable pageable); } ```  `AuthorRepository.findByGroupIds` will generate a query to fetch all the authors in the specified groupId set. If `logging.level.org.springframework.web=DEBUG` is set, it will also generate a query to fetch the books of each author, even though it is lazy and annotated with `@JsonIgnore`.  If this is expected behaviour, I think these side-effects should at least be documented.","open","in: web,","lpfeup","2019-08-23T13:12:38Z","2021-11-10T12:22:33Z"
"","23044","org.springframework.aop.framework.DefaultAopProxyFactory Serializable without Serialization UID","I am using SkyWalking javaagent to enhance DefaultAopProxyFactory which changes the class structures.  Since DefaultAopProxyFactory  has no static serialization uid specified, the change of class structure changes the calculated Serialization UID.  When serialize/deserialize the enhanced DefaultAopProxyFactory instance, because of the Serialization UID inconsistence, java.io.InvalidClassException happens.  I believe that DefaultAopProxyFactory  with static serialization UID could avoid similar problems.  FYI  https://github.com/apache/skywalking/issues/2768  https://github.com/spring-projects/spring-security-oauth/issues/1684","open","in: core,","mattwmj","2019-05-28T06:57:02Z","2021-11-10T10:02:59Z"
"","23474","WebClient's Uri Builder is not encoding ""+"" in query parameter.","I am using below code snippet to re-produce this issue.  ```java final MultiValueMap queryParams = new LinkedMultiValueMap<>(); String value= ""2+3 4""; String key = ""val""; queryParams.add(key, value); ResponseSpec response = agent.get(headers->{}, queryParams, ""/data/read""); String responseBody = respnose.bodyToMono(String.class).block();  ```  The service call to producer application is happening successfully but it returns 404-Not Found since the query parameter is not encoded completely.  Encoded final url: `/data/read?val=2+3%204`  Expected encoded URL: `/data/read?val=2%2B3%204`  Here `""+""` is not encoded. Appreciate any suggestion here.  Thanks, Vikram.N","closed","status: feedback-reminder,","VikramAdh","2019-08-16T19:23:18Z","2021-09-30T20:55:02Z"
"","23512","No way to replace Set-Cookie header via MockHttpServletResponse","I am trying to test a servlet filter passing it an instance of `MockHttpServletResponse`.   The filter attempts to overwrite existing `Set-Cookie` headers with a new `Set-Cookie` header calling the `response.setHeader` method. This works on Jetty and Tomcat, however it does not work on the `MockHttpServletResponse` - leading my tests to fail.  The `MockHttpServletResponse` actually **adds** a new `Set-Cookie` header when using the `setHeader` method - possibly in contradiction to the `HttpServletResponse` interface contract.   From inspection, it appears the `setSpecialHeader` method contains a treatment of `Set-Cookie` which other container implementations do not have. In other containers e.g. Jetty or Tomcat, the set of special headers is limited to `Content-Type` or `Content-Length`. In the `MockHttpServletResponse`, the set of special headers also contains `Language` and `Set-Cookie` (see line 589) - which then leads to the `Set-Cookie` header to be added, rather than replaced.   This difference means I can not test the behavior of my filter in a way consistent with how it will be deployed.","closed","status: feedback-provided,","philsmart","2019-08-23T15:23:45Z","2019-08-28T11:26:33Z"
"","23689","@Transactional does not work in spring-boot running Tomcat, with AspectJ load-time weaving (LTW)","I am having a hard time configuring transactional support in spring-boot 2.0.3 with AspectJ LTW (load-time weaving). My spring-boot is running embedded Tomcat servlet container. In my persistence layer, I am not using JPA, but Spring JDBC Template instead.  I opted for AspectJ mode for transaction management because we are leveraging a rather big project with nested transactions and sometimes it is hard to keep track of all the applications of @Transactional annotation. So that when this annotation is being used I want to have a predictable result - atomic DB operation. I do not want to think about whether we have a self-invocation or method that is marked to be transactional is public.  I have read a bunch of documentation regarding transaction support in spring and how to configure LTW AspectJ weaving. Unfortunately, I cannot make it work. I have created a test (spring-boot test class) that is meant to mimic different failures in a code that should be transactional (see it below). Also, I cannot see the weaving actually happening. I am clearly missing something, cannot figure out what.  My test class: ``` @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestConfig.class) @ActiveProfiles(""TEST"") public class TransactionalIT {      @SpyBean     private JdbcTemplate jdbcTemplate;      // we need this guy in order to perform a cleanup in static @AfterClass method     private static JdbcTemplate jdbcTemplateInStaticContext;      @Autowired     private PlatformTransactionManager txManager;      @Spy     private NestedTransactionsJdbcDao dao;      @Before     public void setUp() {         if (jdbcTemplateInStaticContext == null) {             // Making sure we're working with the proper tx manager             assertThat(txManager).isNotNull();             assertThat(txManager.getClass()).isEqualTo(DataSourceTransactionManager.class);              jdbcTemplateInStaticContext = jdbcTemplate;              jdbcTemplateInStaticContext.execute(""CREATE TABLE entity_a (id varchar(12) PRIMARY KEY, name varchar(24), description varchar(255));"");             jdbcTemplateInStaticContext.execute(""CREATE TABLE entity_b (id varchar(12) PRIMARY KEY, name varchar(24), description varchar(255));"");             jdbcTemplateInStaticContext.execute(""CREATE TABLE entity_a_to_b_assn (entity_a_id varchar(12) NOT NULL, entity_b_id varchar(12) NOT NULL, "" +                     ""CONSTRAINT fk_entity_a FOREIGN KEY (entity_a_id) REFERENCES entity_a(id), "" +                     ""CONSTRAINT fk_entity_b FOREIGN KEY (entity_b_id) REFERENCES entity_b(id), "" +                     ""UNIQUE (entity_a_id, entity_b_id));"");         }     }      @AfterClass     public static void cleanup() {         if (jdbcTemplateInStaticContext != null) {             jdbcTemplateInStaticContext.execute(""DROP TABLE entity_a_to_b_assn;"");             jdbcTemplateInStaticContext.execute(""DROP TABLE entity_a;"");             jdbcTemplateInStaticContext.execute(""DROP TABLE entity_b;"");         }     }      @Test     public void createObjectGraph_FailsDuring_AnAttemptToCreate3rdEntityA() {         doThrow(new RuntimeException(""blah!"")).when(jdbcTemplate).update(eq(""INSERT INTO entity_a (id, name, description) VALUES(?, ?, ?);""),                 eq(""a3""), eq(""entity a3""), eq(""descr_a_3""));         try {             dao.createObjectGraph(getObjectGraph());             fail(""Should never reach this point"");         } catch (RuntimeException e) {             assertThat(e.getMessage()).isEqualTo(""blah!"");             assertDbCounts(0L, 0L, 0L);         }     }      private void assertDbCounts(long expectedACount, long expectedBCount, long expectedAToBCount) {         Long actualACount = jdbcTemplate.queryForObject(""SELECT count(*) count_a FROM entity_a"", new LongRowMapper());         assertThat(actualACount).isEqualTo(expectedACount);         Long actualBCount = jdbcTemplate.queryForObject(""SELECT count(*) count_b FROM entity_b"", new LongRowMapper());         assertThat(actualBCount).isEqualTo(expectedBCount);         Long actualAToBCount = jdbcTemplate.queryForObject(""SELECT count(*) count_a_to_b FROM entity_b"", new LongRowMapper());         assertThat(actualAToBCount).isEqualTo(expectedAToBCount);     }      private final class LongRowMapper implements RowMapper {         @Override         public Long mapRow(ResultSet resultSet, int i) throws SQLException {             return resultSet.getLong(1);         }     }      private ObjectGraph getObjectGraph() {         EntityA a1 = new EntityA(""a1"", ""entity a1"", ""descr_a_1"");         EntityA a2 = new EntityA(""a2"", ""entity a2"", ""descr_a_2"");         EntityA a3 = new EntityA(""a3"", ""entity a3"", ""descr_a_3"");         EntityB b1 = new EntityB(""b1"", ""entity b1"", ""descr_b_1"");         EntityB b2 = new EntityB(""b2"", ""entity b2"", ""descr_b_2"");         EntityB b3 = new EntityB(""b3"", ""entity b3"", ""descr_b_3"");          AtoBAssn a1b1 = new AtoBAssn(""a1"", ""b1"");         AtoBAssn a1b3 = new AtoBAssn(""a1"", ""b3"");         AtoBAssn a2b2 = new AtoBAssn(""a2"", ""b2"");         AtoBAssn a2b3 = new AtoBAssn(""a2"", ""b3"");         AtoBAssn a3b1 = new AtoBAssn(""a3"", ""b1"");          return new ObjectGraph(                 Lists.newArrayList(a1, a2, a3),                 Lists.newArrayList(b1, b2, b3),                 Lists.newArrayList(a1b1, a1b3, a2b2, a2b3, a3b1));     }      @Data     @AllArgsConstructor     private class EntityA {         private String id;         private String name;         private String description;     }      @Data     @AllArgsConstructor     private class EntityB {         private String id;         private String name;         private String description;     }      @Data     @AllArgsConstructor     private class AtoBAssn {         private String idA;         private String idB;     }      @Data     @AllArgsConstructor     private class ObjectGraph {         private List aList;         private List bList;         List aToBAssnList;     }      @Repository     public class NestedTransactionsJdbcDao {          @Transactional         public void createObjectGraph(ObjectGraph og) {             createEntitiesA(og.getAList());             createEntitiesB(og.getBList());             createAtoBAssn(og.getAToBAssnList());             doSomethingElse();         }          @Transactional         public void createEntitiesA(List aList) {             aList.forEach(a ->                     jdbcTemplate.update(""INSERT INTO entity_a (id, name, description) VALUES(?, ?, ?);"",                             a.getId(), a.getName(), a.getDescription()));         }          @Transactional         public void createEntitiesB(List bList) {             bList.forEach(b ->                     jdbcTemplate.update(""INSERT INTO entity_b (id, name, description) VALUES(?, ?, ?);"",                             b.getId(), b.getName(), b.getDescription()));         }          @Transactional         /**          * Intentionally access is set to package-private          */         void createAtoBAssn(List aToBAssnList) {             aToBAssnList.forEach(aToB ->                     jdbcTemplate.update(""INSERT INTO entity_a_to_b_assn (entity_a_id, entity_b_id) VALUES(?, ?);"",                             aToB.getIdA(), aToB.getIdB()));         }          void doSomethingElse() {             // Intentionally left blank         }     } } ```  Here is my configuration class:  ``` import org.apache.catalina.loader.WebappClassLoader; import org.springframework.context.annotation.AdviceMode; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableLoadTimeWeaving; import org.springframework.context.annotation.Primary; import org.springframework.instrument.classloading.LoadTimeWeaver; import org.springframework.instrument.classloading.tomcat.TomcatLoadTimeWeaver; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.annotation.EnableTransactionManagement; import org.springframework.transaction.aspectj.AnnotationTransactionAspect;      @Configuration     @EnableTransactionManagement(mode = AdviceMode.ASPECTJ)     @EnableLoadTimeWeaving(aspectjWeaving = EnableLoadTimeWeaving.AspectJWeaving.ENABLED)     public class EventCoreConfig {          @Bean         public LoadTimeWeaver loadTimeWeaver() {             return new TomcatLoadTimeWeaver(new WebappClassLoader());         }          @Bean         @Primary         public PlatformTransactionManager txManager(DataSource dataSource) {             DataSourceTransactionManager txManager = new DataSourceTransactionManager(dataSource);             AnnotationTransactionAspect aspect = new AnnotationTransactionAspect();             aspect.setTransactionManager(txManager);             return txManager;         }     } ```  Here is the portion of my pom.xml that is adding dependencies of interest:  ```      org.springframework.boot     spring-boot-starter-jdbc       org.springframework.data     spring-data-commons       org.springframework     spring-aspects       org.springframework     spring-aop           org.springframework     spring-instrument-tomcat     4.3.25.RELEASE           mysql     mysql-connector-java     runtime       ch.vorburger.mariaDB4j     mariaDB4j     2.4.0     test       org.mariadb.jdbc     mariadb-java-client     2.4.0     test  ``` Any help will be greatly appreciated. I know this is a little advanced topic, but I do not think it should be that complicated. I think Spring's documentation lacks examples of how to properly perform this kind of configuration. Also, I haven't found any success stories over there with a similar setup.","closed","for: stackoverflow,","imochurad","2019-09-24T15:26:51Z","2019-09-25T10:20:33Z"
"","23213","RestTemplate is returning LinkedHashMap when working with Eureka","I am building two microservices which are supposed to talk to each other. I am using Eureka as service registry.  **Microservice 1** -  *Microservice1.java* ```java     @SpringBootApplication     public class Microservice1Application {         public static void main(String[] args) {             SpringApplication.run(Microservice1Application.class, args);         }     } ```  *Microservice1Controller.java*  ```java     @RestController     @RequestMapping(""/getdata"")     public class Microservice1Controller {	     	@GetMapping(value = ""/"")      public ResponseEntity>> getAll() {     		List list = //get data from repository     		     		return new ResponseEntity>>(new Microservice1ResponseWrapper>(Microservice1ResponseStatus.SUCCESS,list);     	}     } ```  *Microservice1ResponseWrapper.java* - this is generic wrapper  ```java     public class Microservice1ResponseWrapper {     private Microservice1ResponseStatus status;     private T data;     //constructor, getter and setters     } ```  *applicationProperties.yaml*      spring:       application:         name: microservice1                  server:       port: 8073   ```java     public class Customer1 implements Serializable {              	private static final long serialVersionUID = 1L;              private Long custId;     	     	private String custName;     	     	private String firstName;          	private String lastName;         	         private Long age;          	public Customer1() {     	}         //getter, setter and toString     }  ```   **Microservice2** Microservice2 that will get data from Microservice1  ```java     @SpringBootApplication     public class Microservice2Application {         public static void main(String[] args) {             SpringApplication.run(Microservice2Application.class, args);         }     }          @Configuration     class Config {     	     	@LoadBalanced     	@Bean     	public RestTemplate restTemplate() {     		return new RestTemplate();     	}     } ```  *Microservice2Controller.java*   ```java     @RestController     @RequestMapping(""/fetchdata"")     public class Microservice2Controller {	     @Autowired     	private RestTemplate restTemplate;  	     	@GetMapping(value = ""/"")     public ResponseEntity>> getAll() {		     			String getAllUrl = ""http://microservice1/getdata/"";     			ParameterizedTypeReference>>  parameterizedTypeReference =      				    new ParameterizedTypeReference>>(){};     				         			ResponseEntity>> listData =     					restTemplate.exchange(getAllUrl, HttpMethod.GET, null,parameterizedTypeReference);			     			return listData;     	}	     } ```  *Microservice2ResponseWrapper.java* - this is generic wrapper  ```java     public class Microservice2ResponseWrapper {     private Microservice2ResponseStatus status;     private T data;     //constructor, getter and setters     } ```  *applicationProperties.yaml*      spring:       application:         name: microservice2                  server:       port: 8074  Customer1(in Microservice1) and Customer2(Microservice2) are almost identical objects.  Customer2.java in Microservice2   ```java     public class Customer2 implements Serializable {              	private static final long serialVersionUID = 1L;              private Long custId;     	     	private String custName;     	     	private String firstName;          	private String lastName;         	         private Long age;          	public Customer2() {     	}          //getter, setter and toString     } ```  When I  run Microservice1 : http://localhost:8073/getdata it gets data from database and works fine. Here is the response I see on screen:  ```xml          SUCCESS          1     string1     string1     string1     30           ```  When I  run Microservice2 : http://localhost:8074/fetchdata it should go to Microservice 1 and get data.  However, I am getting error like:      org.springframework.web.client.RestClientException: Error while extracting response for type     at org.springframework.web.client.HttpMessageConverterExtractor.extractData(HttpMessageConverterExtractor.java:117)     	at org.springframework.web.client.RestTemplate$ResponseEntityResponseExtractor.extractData(RestTemplate.java:994)     	at org.springframework.web.client.RestTemplate$ResponseEntityResponseExtractor.extractData(RestTemplate.java:977)      Caused by: org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot construct instance of `com.rest.Customer2` (although at least one Creator exists): no String-argument constructor/factory method to deserialize from String value ('1'); nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `com.rest.Customer2` (although at least one Creator exists): no String-argument constructor/factory method to deserialize from String value ('1')      at [Source: (PushbackInputStream); line: 1, column: 61] (through reference chain: com.rest.wrapper.Microservice2ResponseWrapper[""data""]->java.util.ArrayList[0])     	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:245)     	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.read(AbstractJackson2HttpMessageConverter.java:227)     	at org.springframework.web.client.HttpMessageConverterExtractor.extractData(HttpMessageConverterExtractor.java:102)     	... 77 more          Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `com.rest.Customer2` (although at least one Creator exists): no String-argument constructor/factory method to deserialize from String value ('1')      at [Source: (PushbackInputStream); line: 1, column: 61] (through reference chain: com.rest.wrapper.Microservice2ResponseWrapper[""data""]->java.util.ArrayList[0])     	at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)     	at com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1343)     	at com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1032)     	at com.fasterxml.jackson.databind.deser.ValueInstantiator._createFromStringFallbacks(ValueInstantiator.java:371)     	at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromString(StdValueInstantiator.java:323)     	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromString(BeanDeserializerBase.java:1373)     	at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:171)     	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:161)     	at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:286)     	at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)     	at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)     	at com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:127)     	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:369)     	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:159)     	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)     	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3084)     	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:239)         If I make following change in Microservice2 Controller then I see 2 issues: 1) start getting LinkedHashMap error. java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to java.util.List  2) It doesn't pull all records, it just pulls last element from List. e.g. There are 2 users, then it just shows last one user and not all.  ``` ParameterizedTypeReference  parameterizedTypeReference =      				    new ParameterizedTypeReference(){};  ResponseEntity listData =     					restTemplate.exchange(getAllUrl, HttpMethod.GET, null,parameterizedTypeReference); List ls = (List) listData.getBody().getData();  //if I print listData.getBody().getData() then it just shows only one record of users. ```  ***Am I making any mistake in ParameterizedTypeReference or resttemplate exchange call?***  NOTE: If I run these two microservices without Eureka registry, they work absolutely fine. But the moment I introduce Eureka and register these two services with Eureka, I get issue as stated above. For this I just made the change to Miroservice2 controller: String getAllUrl = ""http://localhost:8073/getdata/"";","closed","for: external-project,","shivrajjadhav733","2019-06-29T02:10:07Z","2020-01-02T15:29:56Z"
"","23606","spring-web: DefaultWebSessionManager cancels subscription to Mono from underlying ReactiveSessionRepository#findById","I am building a `ReactiveSessionRepository` and was surprised that after adding metrics I saw a lot of `cancellation` signals on `findById` which I did not expect.  The cause for this how `DefaultWebSessionManager#retrieveSession` deals with multiple `sessionIds` as it uses a [`MonoNext`](https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/MonoNext.java#L75) which causes a cancel `onNext`.  This feels a bit unexpected and I'm not really sure if this was an intended behaviour, anyway I created a PR to explain the issue including a fix.","closed","status: superseded,","AndreasKl","2019-09-07T20:50:20Z","2019-09-10T15:36:39Z"
"","23037","Testing or running Spring boot app with ContextRefreshedEvent[EventListener] event with transactional support using App Context[Spring Boot]","https://stackoverflow.com/questions/56222420/testing-contextrefreshedeventeventlistener-event-with-transactional-support-us","closed","for: stackoverflow,","nalin-sharma-freshworks","2019-05-27T11:28:24Z","2019-05-27T11:50:19Z"
"","22972","Oracle LOB segments holding TEMP space after executing SP using SimpleJdbcCall with SqlParameterSource","https://github.com/spring-projects/spring-framework/blob/e0654a5b3dcf55a7840cd29d25c55854a071202c/spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java#L460  When using SimpleJdbcCall with MapSqlParameterSource but without initial parameters declaration - all parameters became as SqlParameterValue.  But cleanup method doesn't expect such type of parameters and therefore is not executing freetemporary for LOBs.","closed","type: bug,","sean-che","2019-05-14T04:12:27Z","2020-07-19T18:02:32Z"
"","22940","Why is query sign '=' encoded ? Is it in accordance with rfc3986 ?","https://github.com/spring-projects/spring-framework/blob/de69871354d4d264e28b3e7f5b2eab4a69b7ae73/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java#L642","closed","status: declined,","antonysychov","2019-05-10T07:29:10Z","2019-05-15T22:15:52Z"
"","23010","Soft reference-based cache causes confusing exception message from AnnotationTypeMapping resolveAliasTarget","https://github.com/spring-projects/spring-framework/blob/9b3c92e8d2a9a284ec031687fdb6aad5c2407f67/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java#L184-L190  I have a situation where `mirror` and `attribute` are different instances of the `name` attribute on `@Bean`. The use of `!=` then results in the following exception:  ``` Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'value' in annotation [org.springframework.context.annotation.Bean] must be declared as an @AliasFor 'name', not 'name'. 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:186) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:130) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:122) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:99) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:107) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:68) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:61) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:215) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_181] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:211) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:179) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.process(TypeMappedAnnotations.java:417) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:400) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:366) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.processMethodAnnotations(AnnotationsScanner.java:382) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.processMethodInheritedAnnotations(AnnotationsScanner.java:248) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.processMethod(AnnotationsScanner.java:231) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.process(AnnotationsScanner.java:109) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:96) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:77) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations.scan(TypeMappedAnnotations.java:244) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations.get(TypeMappedAnnotations.java:151) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations.get(TypeMappedAnnotations.java:133) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AutowiredAnnotationBeanPostProcessor.java:508) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.lambda$buildAutowiringMetadata$2(AutowiredAnnotationBeanPostProcessor.java:476) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.util.ReflectionUtils.doWithLocalMethods(ReflectionUtils.java:320) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(AutowiredAnnotationBeanPostProcessor.java:471) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata(AutowiredAnnotationBeanPostProcessor.java:438) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(AutowiredAnnotationBeanPostProcessor.java:233) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors(AbstractAutowireCapableBeanFactory.java:1081) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:567) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2] 	... 15 common frames omitted ```  The problem occurs when running a Spring Boot application with a very tightly constrained max heap. I suspect it's due to eviction from the soft reference cache used by `AnnotationTypeMappings`. It's not limited to `@Bean` as I have also seen it with `@RequestMapping`:  ``` Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'value' in annotation [org.springframework.web.bind.annotation.RequestMapping] must be declared as an @AliasFor 'path', not 'path'. 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:186) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:130) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:122) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:99) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:107) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:68) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:61) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:215) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_181] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:211) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:179) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.process(TypeMappedAnnotations.java:417) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:400) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:366) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.processMethodAnnotations(AnnotationsScanner.java:382) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.processMethodHierarchy(AnnotationsScanner.java:266) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.processMethod(AnnotationsScanner.java:236) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.process(AnnotationsScanner.java:109) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:96) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:77) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations.scan(TypeMappedAnnotations.java:244) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.TypeMappedAnnotations.get(TypeMappedAnnotations.java:151) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation(AnnotatedElementUtils.java:633) ~[spring-core-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.createRequestMappingInfo(RequestMappingHandlerMapping.java:262) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getMappingForMethod(RequestMappingHandlerMapping.java:225) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getMappingForMethod(RequestMappingHandlerMapping.java:65) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lambda$detectHandlerMethods$0(AbstractHandlerMethodMapping.java:271) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2] 	... 26 common frames omitted ```","closed","in: core,","wilkinsona","2019-05-21T11:18:03Z","2019-05-29T07:58:44Z"
"","23186","bridgeMethod null check missing","https://github.com/spring-projects/spring-framework/blob/9239ab1891385a389a1dea68e703b153eb5d9a66/spring-core/src/main/java/org/springframework/core/BridgeMethodResolver.java#L69  in spring 4.x there is the bridgeMethod null check.  https://github.com/spring-projects/spring-framework/blob/92abe2927ed8d272ba7fea0c76c7cd7016e44c9e/spring-core/src/main/java/org/springframework/core/BridgeMethodResolver.java#L59  Why this check is deleted in spring 5.x？  Thanks for any information.","closed","status: declined,","amozz","2019-06-24T09:35:11Z","2019-06-24T09:40:41Z"
"","23233","ExceptionHandlerExceptionResolver warns when re-throwing the exception cause","https://github.com/spring-projects/spring-framework/blob/3d913b813412c38e1a235b23e1e61adf39711175/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ExceptionHandlerExceptionResolver.java#L412  If an `@ExceptionHandler` method matches and rethrows a cause of the root exception, it will always log this warning. Instead, the warning should only be logged if the exception differs from the one bound to the ExceptionHandler method's parameter.  Instead, this code should do something like this: ```java         Throwable evaluatedException = null;         try {             if (logger.isTraceEnabled()) {                 logger.trace(""Invoking @ExceptionHandler method: "" + exceptionHandlerMethod);             }             Throwable cause = exception.getCause();             if (cause != null) {                 // Expose cause as provided argument as well                 evaluatedException = cause;                 exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);             }             else {                 // Otherwise, just the given exception as-is                 evaluatedException = exception;                 exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);             }         }         catch (Throwable invocationEx) {             // Any other than the original exception is unintended here,             // probably an accident (e.g. failed assertion or the like).             if (invocationEx != evaluatedException && logger.isWarnEnabled()) {                 logger.warn(""Failed to invoke @ExceptionHandler method: "" + exceptionHandlerMethod, invocationEx);             }             // Continue with default processing of the original exception...             return null;         } ```  I'm testing on Spring 4.3.24, but the code appears to be the same.","closed","type: enhancement,","arlowhite","2019-07-03T23:10:26Z","2019-07-05T10:03:35Z"
"","23449","Only one connection receive subscriber allowed On custom HandlerMethodArgumentResolver","https://github.com/spring-projects/spring-framework/blob/28c5d7b586bac659bac2558264a928e1f5dd6b2c/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L200 When you read the body of request in the `resolveArgument` method of `HandlerMethodArgumentResolver`, an error ""`Only one connection receive subscriber allowed.`"" occurs. look at this:  https://stackoverflow.com/questions/57427549/only-one-connection-receive-subscriber-allowed-on-custom-handlermethodargumentre  Do I think it is necessary to wrap a copy of `exchange` here in` line 200`? Each time the `resolveArgument` method is a separate copy, can you solve this problem?","closed","for: stackoverflow,","kerwin612","2019-08-12T01:34:20Z","2019-08-22T09:40:37Z"
"","23201","Is the `volatile` valid ?","https://github.com/spring-projects/spring-framework/blob/0b6239cecce110f5c660428f982758f57fd45f75/spring-core/src/main/java/org/springframework/core/io/FileUrlResource.java#L49","closed","for: stackoverflow,","Runrioter","2019-06-27T03:16:39Z","2019-07-03T15:08:04Z"
"","23624","How can i upgrade my spring boot 2.1.8 based project to spring framework  5.2.0 RC2","How can i upgrade my spring boot 2.1.8 based project to spring framework  5.2.0 RC2? I WANT TO UPGRADE MY PROJECT FOR STARTED USING R2DBC TRANSACTION MANAGEMENT IN MY PROJECT. HOW CAN I DO THAT WITHOUT STARTING MY PROJECT FROM SCRATCH?","closed","for: stackoverflow,","nikkisingh111333","2019-09-11T18:45:29Z","2019-09-11T19:19:37Z"
"","23684","Allow dynamic ttl in @Cacheable","Hitting this issue with Spring All versions:  Currently, `@Cacheable` only permmited cacheConfig TTL. I have a requirement to set TTL dynamically using the `@Cacheable` annotation. Of course, it can be handled with a custom `RedisCacheWriter` or`CacheResolver`, but I think it can be useful to many users if a method such as `String dynamicTtl()` is supported for `@Cacheable`.","closed","status: declined,","young891221","2019-09-24T01:39:06Z","2019-09-24T10:25:42Z"
"","23641","Backport PR #22485 (Exclude jdk package in ShadowingClassLoader) to 5.1 branch","Hitting this issue with Spring `5.1.9.RELEASE`:             Caused by: java.lang.IllegalAccessError: class jdk.internal.reflect.ConstructorAccessorImpl loaded by      org.springframework.instrument.classloading.ShadowingClassLoader@7c3ca3f0      cannot access jdk/internal/reflect superclass jdk.internal.reflect.MagicAccessorImpl   Given Spring 5.1 officially supports JDK11, any reasons this [PR-22485](https://github.com/spring-projects/spring-framework/pull/22485) that was merged into master branch should not be backported to `5.1` branch? @jhoeller","closed","type: enhancement,","rahulsh1","2019-09-15T00:49:40Z","2019-09-25T11:10:29Z"
"","22869","Support final classes annotated with @Configuration(proxyBeanMethods = false)","Historically Kotlin classes annotated with `@Configuration` had to have `open` modifier at class level and each method level in order to support CGLIB proxies. Since `@Configuration(proxyBeanMethods = false)` now allows proxy-less processing of these classes, related checks in `org.springframework.context.annotation.ConfigurationClass` should be relaxed accordingly.","closed","in: core,","sdeleuze","2019-05-02T07:43:18Z","2019-05-03T12:19:44Z"
"","23552","Non-argument constructor is still needed for @Configuration class","Hi, the @Configuration API does not mention that it needs a non-argument constructor as a constraint in Spring 5 documentation. I know this was a limitation in Spring 4. I am sure it is still true for Spring 5. Please verify this.  This is my proof: [code] @Configuration public class ApplicationConfiguration{    public ApplicationConfiguration(int test){ }    //no other constructor is defined.  .....   } [/code] [code]  public class MyApp{    public static void main(String... args){     AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfiguration.class);   ....   } } [/code] Output: [quote]  Error creating bean with name 'applicationConfiguration': Unsatisfied dependency expressed through constructor parameter 0; [/quote]  @Configuration Spring 5 API Reference: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html   **Affects:** \  ---","closed","status: invalid,","aCodeRancher","2019-08-31T01:31:00Z","2019-08-31T06:23:17Z"
"","22858","Forward duplicates parameter values (jetty)","Hi, Spring engineers!  I faced a problem that the async forwarding in spring mvc (`5.1.6.RELEASE`) results in duplicating query parameters. This can be better illustrated by the following example. Consider the [following controller](https://github.com/SerCeMan/jettyredirect/blob/7b3c9b7105637cb038bba1dc4e890c2c6eeeb002/src/main/kotlin/main.kt#L10-L18): ```kotlin @Controller(""/"") open class Page {     @GetMapping(""/page1"")     open fun page1(str: String) = CompletableFuture.completedFuture(""forward:/page2"")      @GetMapping(""/page2"")     @ResponseBody     open fun page2(str: String) = ""params: $str"" } ```  Requesting `/page1?str=test` results in duplicating the parameters: ```bash $ curl http://localhost:8070/page1?str=test params: test,test ```  Returning forward synchronously fixes the issue, but there are certain use cases where forwarding can be returned only after an asynchronous call finishes.  The project reproducer: https://github.com/SerCeMan/jettyredirect  As far as I can tell, the problem only occurs when spring is configured on top of jetty, and it's likely to be related to this issue: https://github.com/eclipse/jetty.project/issues/2074. However, I can't tell if this is due to spring behaviour or jetty behaviour. As far as I understood from the comments on the issue, the servlet spec is ambiguous.   Please let me know if I can do anything to move this issue forward.   Thanks :)","closed","for: external-project,","SerCeMan","2019-04-30T08:54:49Z","2019-05-01T19:24:14Z"
"","23593","Bean definition override leads to NPE due to inconsistent equality check","Hi, I've recently tried to switch to spring 5.1.9. And my old code (based on spring 4.3.4) stopped working because of NPE during context refresh. I've created a minimal reproducible example https://gist.github.com/andrey-vasilyev/ad42b33c13ce850bfd7065ef35f95017  The issues (difference in behaviour) seems to be in `AbstractBeanDefinition.equals` method. Could you please take a look?","closed","in: core,","andrey-vasilyev","2019-09-05T17:02:02Z","2019-09-25T19:08:38Z"
"","23150","Document how to specify Jackson JSON view serialization hints","Hi,   I have the problem to hide some fields according specific security role, one way to do it is using **JsonView** like this [sample](https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring#with-spring-boot) or even better this one [Filtering Jackson with security](https://www.baeldung.com/spring-security-role-filter-json), however, there no way to do it with **RouterFunctions**, there some post open in [stackoverflow](https://stackoverflow.com/questions/51972715/spring-webflux-functional-endpoints-jsonview-how).  Thanks.","closed","in: web,","nekperu15739","2019-06-18T11:47:58Z","2019-06-18T14:55:25Z"
"","23559","Mono returned by ServerRequest.bodyToMono() method not extracting the body if I return ServerResponse immediately","Hi, I am using spring dependency ```xml      org.springframework.boot     spring-boot-starter-parent     2.1.7.RELEASE    ```  I am using web reactive in spring web flux. I have implemented a Handler function for POST request. I want the server to return immediately. So, I have implemeted the handler as below -:  ```java public Mono handle(ServerRequest request) {     Mono bodyMono = request.bodyToMono(String.class);      bodyMono.map(str -> {       System.out.println(""body got is "" + str);       return str;     }).subscribe();      return ServerResponse.status(HttpStatus.CREATED).build();   } ```  But the print statement inside the map function is not getting called. It means the body is not getting extracted.  If I do not return the response immediately and use  `return bodyMono.then(ServerResponse.status(HttpStatus.CREATED).build())`, then the map function is getting called.   So, how can I do processing on my request body in the background? Please help.","closed","","arunim29","2019-09-01T12:01:29Z","2021-01-08T13:09:12Z"
"","23716","Tomcat 8.0.33 crashing with Spring security","Hi, I am having issues with tomcat crash every time when load occurs on JVM, I am getting below error logs initially it is working fine. When some users are increased to access the server then server crashing every time. My java version is 8.0_222 please help me to get out of this issue  I am using spring 4.0.0 version    ``` # A fatal error has been detected by the Java Runtime Environment: # #  SIGSEGV (0xb) at pc=0x00007f5e79885cb8, pid=3364, tid=0x00007f5df6fef700 # # JRE version: OpenJDK Runtime Environment (8.0_222-b10) (build 1.8.0_222-b10) # Java VM: OpenJDK 64-Bit Server VM (25.222-b10 mixed mode linux-amd64 compressed oops) # Problematic frame: # C  [core.so+0x7cb8]  socket_send+0x98 # # Failed to write core dump. Core dumps have been disabled. To enable core dumping, try ""ulimit -c unlimited"" before starting Java again # # An error report file with more information is saved as: # /opt/apache-tomcat-8.0.33/bin/hs_err_pid3364.log # # If you would like to submit a bug report, please visit: #   http://bugreport.java.com/bugreport/crash.jsp # The crash happened outside the Java Virtual Machine in native code. # See problematic frame for where to report the bug. # Sep 23, 2019 11:55:39 -0700 [5979 1] com.newrelic INFO: New Relic Agent: Loading configuration file ""/opt/apache-tomcat-8.0.33/newrelic/./newrelic.yml"" Sep 23, 2019 11:55:40 -0700 [5979 1] com.newrelic INFO: New Relic Agent: Writing to log file: /opt/apache-tomcat-8.0.33/newrelic/logs/newrelic_agent.log [GC (Allocation Failure) [ParNew: 545344K->35317K(613440K), 0.0337966 secs] 545344K->35317K(5174784K), 0.0338674 secs] [Times: user=0.12 sys=0.01, real=0.04 secs]  [GC (CMS Initial Mark) [1 CMS-initial-mark: 0K(4561344K)] 35327K(5174784K), 0.0046687 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]  [CMS-concurrent-mark-start] [CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]  [CMS-concurrent-preclean-start] [CMS-concurrent-preclean: 0.005/0.005 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]  [CMS-concurrent-abortable-preclean-start] 23-Sep-2019 11:55:44.925 WARNING [main] org.apache.catalina.startup.SetAllPropertiesRule.begin [SetAllPropertiesRule]{Server/Service/Connector} Setting property 'keepAlivetimeout' to '60000' did not find a matching property. 23-Sep-2019 11:55:44.940 WARNING [main] org.apache.catalina.startup.SetAllPropertiesRule.begin [SetAllPropertiesRule]{Server/Service/Connector} Setting property 'keepAlivetimeout' to '60000' did not find a matching property. 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version:        Apache Tomcat/8.0.33 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Mar 18 2016 20:31:49 UTC 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server number:         8.0.33.0 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            3.10.0-957.27.2.el7.x86_64 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64 23-Sep-2019 11:55:45.033 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64/jre 23-Sep-2019 11:55:45.034 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           1.8.0_222-b10 23-Sep-2019 11:55:45.034 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation 23-Sep-2019 11:55:45.034 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /opt/apache-tomcat-8.0.33 23-Sep-2019 11:55:45.034 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /opt/apache-tomcat-8.0.33 ```","closed","status: invalid,","venkateshyella","2019-09-26T08:04:51Z","2019-09-26T10:37:12Z"
"","22876","Support Publisher in MultipartBodyBuilder#asyncPart","Hi,  While trying a similar solution like in issue #21142  ```java @PostMapping(path = ""/upload/identifiers"") public Mono saveWithIdentifier(@RequestPart(""file"") Mono file) {      MultipartBodyBuilder bodyBuilder = new MultipartBodyBuilder();     bodyBuilder.asyncPart(""file"", file, FilePart.class);      return WebClient.create(SOME_URL).put()             .uri(FILE_UPLOAD_URI)             .syncBody(bodyBuilder.build())             .retrieve()             .bodyToMono(FileRef.class); ```  throws an exception:   ``` org.springframework.core.codec.CodecException: No suitable writer found for part: file ``` Is this an issue, incomplete documentation or am I just not using it right?  Regards, Alex","closed","type: enhancement,","p3ndu","2019-05-03T08:45:27Z","2019-05-08T15:01:31Z"
"","22935","Fix trivial errors in `integration.adoc`","Hi,  this PR fixes some trivial errors in `integration.adoc`","closed","in: core,","cac03","2019-05-09T11:48:10Z","2019-05-09T11:50:27Z"
"","23494","Fix groupId for spring-framework-bom","Hi,  the recent changes to the Gradle builds seem to have caused the BOM to be published with a wrong groupId. E.g. it is `spring` now while it was (and probably should be) `org.springframework`  This PR is an attempt to fix this by applying the group as in [build.gradle#L53](https://github.com/spring-projects/spring-framework/blob/master/build.gradle#L53).  Cheers, Christoph","closed","status: declined,","dreis2211","2019-08-20T19:19:55Z","2019-08-22T08:12:37Z"
"","23040","Avoid unnecessary call to get message type","Hi,  just noticed this unnecessary call to `SimpMessageHeaderAccessor.getMessageType(headers);` in cases where `SimpleBrokerMessageHandler.checkDestinationPrefix()` causes an early return.  Cheers, Christoph","closed","type: enhancement,","dreis2211","2019-05-27T16:16:24Z","2019-05-28T17:49:17Z"
"","22829","Avoid possible memory leak in ResolvableType","Hi,  in recent profiling sessions of Spring-Boot apps, I noticed that instances of ResolvableType are retained by their `DefaultVariableResolver`: ![grafik](https://user-images.githubusercontent.com/6304496/56597829-91daba80-65f3-11e9-9f63-694f520ae553.png) Until now I've not seen any critical leaks but I thought better be safe than sorry.  Let me know what you think. Cheers, Christoph","closed","","dreis2211","2019-04-23T16:17:18Z","2022-02-18T19:10:08Z"
"","22870","Abort early in PropertyPlaceholderHelper if no placeholder exists","Hi,  I am currently working on https://github.com/spring-projects/spring-boot/issues/16401 and investigate performance issues in the binding context. I noticed a small optimization opportunity in PropertyPlaceholderHelper if no placeholders exist. We can early out in those cases and thus save the allocations coming from the StringBuilder (and the HashSet). To be fair: this is not a major performance bottleneck at all (there are ~5000 StringBuilder/HashSet allocations that we could save), but every little helps and who knows what other people might be doing with that class.  Cheers, Christoph","closed","type: enhancement,","dreis2211","2019-05-02T12:17:23Z","2019-05-13T15:00:17Z"
"","22817","spring-jms  DefaultMessageListenerContainer when using retries cause comes as null in Dead Letter Queue using ActiveMQ","Hi Spring community,   I'm implementing retries with a DLQ in spring, I'm using the DefaultMessageListenerContainer but not the SimpleMessageListenerContainer, when the retries exceed the message in the DLQ looks like the following:  > java.lang.Throwable: Delivery[2] exceeds redelivery policy imit:RedeliveryPolicy    {destination = queue://*,     collisionAvoidanceFactor = 0.15,     maximumRedeliveries = 1,     maximumRedeliveryDelay = -1,     initialRedeliveryDelay = 10000,     useCollisionAvoidance = false,     useExponentialBackOff = true,     backOffMultiplier = 5.0,     redeliveryDelay = 10000,     preDispatchCheck = true},     cause:null  the cause:null should be coming back with the exception that happened in the consumer but it doesn't, apparently in spring we are swallowing the exception (in the DefaultMessageListenerContainer) and ActiveMQ cannot remember the cause as per: http://activemq.2283324.n4.nabble.com/ActiveMQ-5-5-Not-able-to-get-the-DLQ-DELIVERY-FAILURE-CAUSE-PROPERTY-value-td3492931.html.","open","in: messaging,","lfernandez93","2019-04-18T14:24:53Z","2021-11-10T11:41:07Z"
"","22824","Cannot parse byte array to string on HttpClientErrorException getResponseBodyAsString when http code of client server is 403 (Forbidden) and on a kubernetes environment","Hi please see screenshot below , this is on debugging mode (org.springframework.web.client  class HttpClientErrorException)  This is when client api server returning 403 http  code with a body (see ex.getResponseBodyAsString on debugging console) ![stackover1](https://user-images.githubusercontent.com/26607878/56485013-df2c2e80-6504-11e9-8ab5-9d05817077ab.PNG)  Expected result should get  even 403 response code( tried directly hitting api on postman) ![stack2](https://user-images.githubusercontent.com/26607878/56485059-261a2400-6505-11e9-8ae4-643705cb55f5.PNG)   While i requested client server to adjust their http code to 400 , this is what happens  (see ex.getResponseBodyAsString on debugging console), works normally upon changing http code ![stack4](https://user-images.githubusercontent.com/26607878/56485185-9e80e500-6505-11e9-97a1-d92e20a02deb.PNG)","closed","status: invalid,","gerwin123","2019-04-22T05:50:52Z","2019-05-13T13:00:27Z"
"","23400","Properly encoded + (plus sign encoded with %2B) still replaced with blank space in @RequestParam","Hi all,  there are many issues here raised regarding the handling of ""+"" signs in URLs. Nevertheless, I understood that if they are properly encoded (replaced by %2B) they should be decoded again as a ""+"" and not as blank space. However, that is not the case (with Spring 5.1.8) Maybe I am still getting something wrong here but from my understanding this is not as it's supposed to be.  I have trouble using an ISO timestamp as a request parameter although I encoded the + sign with %2B.  Any help and explanations are very welcome!  Regards, Lars","closed","status: invalid,","larsduelfer","2019-08-01T19:32:09Z","2019-08-05T06:10:28Z"
"","23510","java.lang.UnsupportedOperationException SuppressedExceptions: Collections$UnmodifiableRandomAccessList","Hi All,  I have an issue with webflux - java.lang.UnsupportedOperationException is thrown inside the framework.  I debugged into this [piece of code](https://github.com/spring-projects/spring-framework/blob/50decc43cea4cfbcb92afabd8fa892308a4a389d/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java#L155)  and found that  `HttpHeaders responseHeaders = exchange.getResponse().getHeaders(); ` returns an object of ReadOnlyHttpHeaders (headers: NettyHeadersAdapter) So the next [piece of code](https://github.com/spring-projects/spring-framework/blob/50decc43cea4cfbcb92afabd8fa892308a4a389d/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.java#L158) ``` 			if (!entityHeaders.isEmpty()) { 				entityHeaders.entrySet().stream() 						.forEach(entry -> responseHeaders.put(entry.getKey(), entry.getValue())); 			}  ``` throws this kind of exception.  Could you please provide a workaround or a fix?  Thank you, Dmitri","closed","status: invalid,","dmitrius","2019-08-23T13:19:03Z","2019-11-20T11:52:28Z"
"","23347","interaction between @primary and registerBeanDefinition","hi  the @Primary javadoc specifies that primary beans should be prioritized over non primary beans if both qualify for autowiring. yet DefaultListableBeanFactory.registerBeanDefinition gladly replaces a primary bean with a non primary one. is this behavior a bug or am i missing something ?  spring version : 5.0.4.RELEASE","closed","for: stackoverflow,","okadhem","2019-07-24T09:14:55Z","2019-07-24T09:19:17Z"
"","23790","[question] for beans components #getPropertyHoldingValue","Hey, recently I tried to debug the source code of beans components. branch：   **remotes/origin/5.1.x** file: https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java line: 391 accessor.setAutoGrowNestedPaths(true);  When I execute here, my keys are non-null, but the getPropertyValue method sets DefaultValue when keys are non-null, so getPropertyValue should return to a non-null collection.  ```java private Object getPropertyHoldingValue(PropertyTokenHolder tokens) { 		// Apply indexes and map keys: fetch value for all keys but the last one. 		Assert.state(tokens.keys != null, ""No token keys""); 		PropertyTokenHolder getterTokens = new PropertyTokenHolder(tokens.actualName); 		getterTokens.canonicalName = tokens.canonicalName; 		getterTokens.keys = new String[tokens.keys.length - 1]; 		System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1); 		Object propValue; 		try { 			// call getPropertyValue , keys must be not null 			propValue = getPropertyValue(getterTokens); 		} 		catch (NotReadablePropertyException ex) { 			throw new NotWritablePropertyException(getRootClass(), this.nestedPath + tokens.canonicalName, 					""Cannot access indexed value in property referenced "" + 					""in indexed property path '"" + tokens.canonicalName + ""'"", ex); 		}  		// why check that propValue is null after calling getPropertyValue？ 		if (propValue == null) { 			// null map value case 			if (isAutoGrowNestedPaths()) { 				int lastKeyIndex = tokens.canonicalName.lastIndexOf('['); 				getterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex); 				propValue = setDefaultValue(getterTokens); 			} 			else { 				throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + tokens.canonicalName, 						""Cannot access indexed value in property referenced "" + 						""in indexed property path '"" + tokens.canonicalName + ""': returned null""); 			} 		} 		return propValue; 	} ```  ```java protected Object getPropertyValue(PropertyTokenHolder tokens) throws BeansException { 		String propertyName = tokens.canonicalName; 		String actualName = tokens.actualName; 		PropertyHandler ph = getLocalPropertyHandler(actualName); 		if (ph == null || !ph.isReadable()) { 			throw new NotReadablePropertyException(getRootClass(), this.nestedPath + propertyName); 		} 		try { 			Object value = ph.getValue();  			// key are not-null 			if (tokens.keys != null) { 				if (value == null) { 					// the AutoGrowNestedPaths enabled 					if (isAutoGrowNestedPaths()) { 						// this value not null 						value = setDefaultValue(new PropertyTokenHolder(tokens.actualName)); 					} 					else { 						throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, 								""Cannot access indexed value of property referenced in indexed "" + 										""property path '"" + propertyName + ""': returned null""); 					} 				} ```  The question is why you check that propValue is null after calling getPropertyValue. Isn't this done in getPropertyValue?","closed","","lyqingye","2019-10-14T09:48:25Z","2022-02-18T19:07:13Z"
"","22844","Does Spring-Ldap support integration to Oracle Unified Directory OUD","Hello, We would like to develop a java solution using Spring-Ldap to perform CRUD operation on Oracle Unified Directory (OUD) directory server in our enterprise. Would like to know if Spring-Ldap has been used to address this sort of problem prior. If so, could you please direct us to a support forum that resembles this kind of a solution. If not, would Spring forum address any issues the application run into after implementation. Could you also please confirm if spring-ldap can be used for any directory server interactions. Thank you, Vijay","closed","for: stackoverflow,","vsham5766","2019-04-26T13:44:47Z","2019-04-26T13:49:03Z"
"","24360","Cache level when using spring.artemis.pool.enabled with spring-boot-starter-artemis","Hello,  When I'm using spring-boot-starter-artemis with org.messaginghub pooled-jms, if I'm stopping the application (or sometimes during the execution) I get:  ``` javax.jms.IllegalStateException: Session is closed 	at org.apache.activemq.artemis.jms.client.ActiveMQSession.checkClosed(ActiveMQSession.java:1165) ~[artemis-jms-client-2.6.4.jar:2.6.4] 	at org.apache.activemq.artemis.jms.client.ActiveMQSession.setMessageListener(ActiveMQSession.java:315) ~[artemis-jms-client-2.6.4.jar:2.6.4] 	at org.messaginghub.pooled.jms.JmsPoolSession.close(JmsPoolSession.java:91) ~[pooled-jms-1.0.6.jar:na] 	at org.springframework.jms.support.JmsUtils.closeSession(JmsUtils.java:109) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.clearResources(DefaultMessageListenerContainer.java:1242) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.access$100(DefaultMessageListenerContainer.java:1048) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.jms.listener.DefaultMessageListenerContainer.doShutdown(DefaultMessageListenerContainer.java:594) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.jms.listener.AbstractJmsListeningContainer.shutdown(AbstractJmsListeningContainer.java:244) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.jms.listener.AbstractJmsListeningContainer.destroy(AbstractJmsListeningContainer.java:184) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.jms.config.JmsListenerEndpointRegistry.destroy(JmsListenerEndpointRegistry.java:251) ~[spring-jms-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:258) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1040) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1033) ~[spring-beans-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945) ~[spring-context-5.1.10.RELEASE.jar:5.1.10.RELEASE] ```  If the cache is set to `CACHE_CONNECTION` or `CACHE_NONE`, I don't get this exception.  Conceptually shouldn't the cache be disable (automatically) when the pool is used?","open","status: feedback-provided,","bigon","2019-10-16T13:43:46Z","2021-11-24T10:13:07Z"
"","23284","ConcurrentReferenceHashMap default DEFAULT_REFERENCE_TYPE","Hello,  We are currently facing an issue when successive redeployments happen. We get an  java.lang.OutOfMemoryError: Metaspace. On redeployment, new classloaders are created but there are soft references which are kept in ConcurrentReferenceHashMap across spring core. What we see as a general behavior is that softkeys are only freed on garbage collection if a certain memory threshold is reached in the **heap memory**. But there are cases where the keys retain classloaders which were dereferenced elsewhere on undeployment and in that case, if what is stressed is the metaspace we arrive to an OOM Metaspace because the softkeys are not freed in the heap memory.  We are currently considering to change the DEFAULT_REFERENCE_TYPE to WEAK through reflection, but taken into account the following comment:  https://github.com/spring-projects/spring-framework/issues/16021#issuecomment-453409588  Shouldn't spring provide a way to change the default reference type which is now private?  Thanks in advance","open","in: core,","fsgonz","2019-07-12T18:00:32Z","2021-11-11T10:12:40Z"
"","23240","FlashMapManager throws StringIndexOutOfBoundsException for empty target URL path","Hello,  My project is currently using Spring MVC version 5.0.8.  Incidentally, I found a technical error relating to the library.  It is about the method `decodeAndNormalizePath` of the `AbstractFlashMapManager` class. If you look at the implementation, you can easily see that it is wrong. An empty path will pass the `null` check but fail to get the first character.  ```java private String decodeAndNormalizePath(@Nullable String path, HttpServletRequest request) { /* 231 */       if(path != null) { /* 232 */          path = this.getUrlPathHelper().decodeRequestString(request, path); /* 233 */          if(path.charAt(0) != 47) { /* 234 */             String requestUri = this.getUrlPathHelper().getRequestUri(request); /* 235 */             path = requestUri.substring(0, requestUri.lastIndexOf(47) + 1) + path; /* 236 */             path = StringUtils.cleanPath(path); /*     */          }      } /*     */  /* 239 */       return path; /*     */    } ```  ``` org.apache.catalina.core.ApplicationDispatcher.invoke Servlet.service() for servlet [tnjs-servlet] threw exception  java.lang.StringIndexOutOfBoundsException: String index out of range: 0 	at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:44) 	at java.base/java.lang.String.charAt(String.java:704) 	at org.springframework.web.servlet.support.AbstractFlashMapManager.decodeAndNormalizePath(AbstractFlashMapManager.java:233) 	at org.springframework.web.servlet.support.AbstractFlashMapManager.saveOutputFlashMap(AbstractFlashMapManager.java:204) 	at org.springframework.web.servlet.support.RequestContextUtils.saveOutputFlashMap(RequestContextUtils.java:281) 	at org.springframework.web.servlet.view.RedirectView.renderMergedOutputModel(RedirectView.java:311) 	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:314) 	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1325) 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1069) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1008) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:866) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ```","closed","type: bug,","pbluong","2019-07-05T04:05:05Z","2019-08-26T02:43:03Z"
"","23417","Preserve the originalMessage when creating an ErrorMessage in MessageBuilder","Hello,  I was creating a small POC using spring integration and for some cases I noticed that Gateways that use messagingTemplate underneath do not preserve the original message when sending a related ErrorMessage to the error channel.  I didn't find any better place to address that.   In my opinion original message worth preserving in any case. However there is another possibility to pass the MessageBuilder.originalMessage link without unwrapping it","closed","type: enhancement,","L00kian","2019-08-05T10:46:35Z","2019-11-08T15:06:54Z"
"","22910","Spring JMS Template Sync Receive on Non-Durable Subscriber Message Loss","Hello,  I call JMSTemplate.receive() in a loop on Non-Durable Subscriber, if I send many messages to the topic, some messages will be lost on receiver. The messages lost occurs after return of JMSTemplate.receive(), but before next call on JMSTemplate.receive().  Is it expected behaviour? or something is wrong with me?","closed","for: stackoverflow,","zhvfeng","2019-05-07T06:07:05Z","2019-05-07T06:17:37Z"
"","23462","JPA Repository method (findByUsername) ignores case.","Hello,  As I understood this [documentation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods), this method: ` User findByUsernameAndPassword(String username, String password);` should perform like: `where x.lastname = ?1 and x.firstname = ?2` but it's performing actually like: `where UPPER(x.firstame) = UPPER(?1)`","closed","","Retewe","2019-08-14T18:16:05Z","2021-01-08T13:09:11Z"
"","23822","Please add support for beannamegenerator in ConfigurationClassBeanDefinitionReader","Hello!  I've got a huge project with history, that I am migrating step by step.  Now I'm switching from annotation-based-component-scan to @Configuration-Classes. For  the generation of beannames of scanned beandefinitions I use a custom beannamegenerator (as the project is really huge).  Unfortunatly this is not possible for Beans defined in @Configuration-Klasses. The generated (default)-beanname is always the simple methodname. This is a fixed bean-name-generation defined in Method ""loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod).  Please add the possibility to use a beanname-generator here. Thank you very much!  Best regards Hans","open","in: core,","hosea","2019-10-16T15:12:34Z","2021-11-11T10:12:42Z"
"","23643","Delete obsolete comment in RowMapperTests","Hello Spring Team🙌  When I read `RowMapperTests`, found it that unnecessary verify code. so just removed it.","closed","type: task,","NESOY","2019-09-16T09:47:33Z","2019-09-16T12:11:04Z"
"","22980","Why is the SPEL ReflectionHelper class not named ReflectionUtils?","Hello Spring Team  I would create this question to SO, but because it is an opinionated situation I am creating this post here.  I have read this post:  * [What are the differences between Helper and Utility classes?](https://stackoverflow.com/questions/12192050/what-are-the-differences-between-helper-and-utility-classes)  I understand the answer.  Now if we see the [ReflectionHelper](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/expression/spel/support/ReflectionHelper.html) class (located in the `org.springframework.expression.spel.support` package), it has only `static` methods, so why is not named `ReflectionUtils` instead?  I have seen many other classes through the APIs/javadoc in SF, SB, SI, SS projects, and practically the answer available in SO is accomplished or applied through these projects, but this `ReflectionHelper` class is the exception  It would be confuse for possible contributors  Consider please this issue how trivial.  Thanks  **Observation**: exists the [ReflectionUtils](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/ReflectionUtils.html) class located in the `org.springframework.util` package. Where it has all the methods declared how `static`","closed","for: stackoverflow,","manueljordan","2019-05-15T23:23:50Z","2019-05-21T18:33:55Z"
"","22970","How to connect authenticated service into admin server?","Hello developers! I have several numbers of services in eureka. I want to monitor these services. So I decided to use Spring boot admin.    I added that codes to my application yaml file. > eureka:     instance:         metadata-map:             user.name: eureka             user.password: password  So, I can't solve that problem! How to solve ???","closed","for: stackoverflow,","Nyamkhuub","2019-05-14T03:33:46Z","2019-05-14T07:55:25Z"
"","22919","WebClient.block throws java.lang.IllegalStateException: block()/blockFirst()/blockLast() are blocking, which is not supported in thread","Hello I try to use WebClient (netty) in synchronous style:  ``` return internalWebClient                 .post()                 .uri(composeUri(ACCOUNTS_LIST_URL))                 .syncBody(userCodes)                 .retrieve()                 .bodyToFlux(UserResponse.class)                 .collectList()                 .block(); ```  Documentation - https://github.com/spring-projects/spring-framework/blob/master/src/docs/asciidoc/web/webflux-webclient.adoc - says that it's ok but I got `IllegalStateException`  ``` java.lang.IllegalStateException: block()/blockFirst()/blockLast() are blocking, which is not supported in thread reactor-http-nio-4 	at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:77) 	at reactor.core.publisher.Mono.block(Mono.java:1494) ```  Can you explain how to use WebClient in synchronous style / what's wrong / is documentation correct?","closed","status: invalid,","fedotxxl","2019-05-07T14:31:35Z","2022-04-20T17:46:08Z"
"","22850","build from source failed in commandline","Greetings,   **Expected Behavior** Can build from source succesfully after pulling lastest version <5.1.x>  **Current Behavior** Javadoc generation fails when provide `gradlew build` as admin mode in win command line   **Error Details** >  Task :api FAILED >  > FAILURE: Build failed with an exception. >  > * What went wrong: > Execution failed for task ':api'. >  Javadoc generation failed. Generated Javadoc options file (useful for troubleshooting): 'D:\SpringFrameworkSource\spring-framework\build\tmp\api\javadoc.options' >  > * Try: > Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights. >  > * Get more help at https://help.gradle.org >  > BUILD FAILED in 19m 45s > 192 actionable tasks: 34 executed, 158 up-to-date  **Environment** *Gradle 5.4* Build time:   2019-04-16 02:44:16 UTC Revision:     a4f3f91a30d4e36d82cc7592c4a0726df52aba0d  Kotlin:       1.3.21 Groovy:       2.5.4 Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018 JVM:          12 (Oracle Corporation 12+33) OS:           Windows 10 10.0 amd64  *Java* java version ""12"" 2019-03-19 Java(TM) SE Runtime Environment (build 12+33) Java HotSpot(TM) 64-Bit Server VM (build 12+33, mixed mode, sharing)","closed","status: invalid,","HungVo31","2019-04-28T14:57:01Z","2019-04-30T15:12:37Z"
"","23585","Detect unsupported suspending handler methods in Spring MVC","Given the reports I already had from people trying to use suspending functions with Spring MVC, better to provide an explicit check for that. Only WebFlux support suspending functions for now.","closed","type: task,","sdeleuze","2019-09-04T15:53:05Z","2020-04-05T17:43:42Z"
"","23756","Introduce sessionAttributeDoesNotExist in RequestResultMatchers","Given the matcher `attributeDoesNotExist` of `ModelResultMatchers`, it makes sense for a session attribute `ResultMatcher` equivalent – `sessionAttributeDoesNotExist` which asserts that the given session attributes are `null` in the `HttpSession`.","closed","type: enhancement,","drumonii","2019-10-04T01:02:29Z","2019-10-23T10:35:39Z"
"","23089","Dependencies using Kotlin functions with Kotlin collections fail to autowire","Given the following component with an autowired Kotlin function: ``` @Component class Test @Autowired constructor(val dependency: (String) -> (List)) {   fun hello() {     TODO()   } } ```  And the component that should be autowired: ``` @Component class Dependency : (String) -> List {   override fun invoke(p1: String): List {     TODO()   } } ```  The following error occurs on startup: ``` ApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'test' defined in file [/com/example/demo/Test.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'kotlin.jvm.functions.Function1>' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} ```  Based on the error, it appears to be looking for a `java.util.List`, rather than a `kotlin.List`. This also occurs when using a Kotlin `Set`, or `Map`, but not when using sub-types like `MutableList`.  A sample project has been attached, which is based on the vanilla SpringBoot Initializr.  [Demo Application](https://github.com/spring-projects/spring-boot/files/3257151/demo.zip)  **SpringBoot Version:** 2.1.5.RELEASE","closed","status: duplicate,","jacksonjesse","2019-06-05T12:25:20Z","2019-06-06T11:57:05Z"
"","23277","Document behaviour of @Transactional in reactive environments with non-reactive signatures","Given a scenario with a `ReactiveTransactionManager` in the context, I expected methods annotated with `@Transactional` handled by this transaction manager.  However, only methods exposing some sort of reactive API (`Flux`, `Mono` and related) are handled via `TransactionAspectSupport`.  So given a component like  ```java static class Foobar {  	@Transactional 	public void boom() {  	}  	@Transactional 	public Mono imFine() { 		return Mono.empty(); 	} } ```  would effectively need two transaction managers, or at one of the methods will fail. With only a reactive transaction manager, `boom` fails:  ``` java.lang.IllegalStateException: Specified transaction manager is not a PlatformTransactionManager: ```  While `boom` is probably not a method that can be used in a sensible way in a reactive context, it's something that's gonna happen eventually and should be at least documented.  As I don't have a good idea, what else to use to decide about which transaction manager to use, I try not to suggest making it work in another way, but just be very clear in the docs about what to expect.","open","type: documentation,","michael-simons","2019-07-11T14:43:04Z","2021-11-10T09:27:05Z"
"","23180","Fix typo in CONTRIBUTING.md","Found a type in CONTRIBUTING.md","closed","type: documentation,","gaurav9822","2019-06-22T11:55:33Z","2019-06-22T19:34:28Z"
"","23283","Move Jackson2Json{De,En}coder to spring-core","For the RSocket support in `spring-messaging` it would be quite handy to use the Jackson2JsonEncoder and Jackson2JsonDecoder without adding `spring-web` to the dependencies.","closed","status: declined,","joshiste","2019-07-12T14:46:54Z","2019-07-15T12:56:27Z"
"","23423","Support JSON Patch for nested collections","For spring-boot 2.2.0.M4 (spring-data version 3.2.0.RC1), JsonPatch add operation is not properly working with a nested list  Exemple:  ```java @Entity @Table(name = ""entities"") public class entity {   UUID id;   Foo foo; }  public class Foo {   List nestedList; } ```  The following PATCH request on entity/{entityId} ```json [ 	{ 		""op"": ""add"", 		""path"": ""foo/nestedList/-"", 		""value"": ""bar"" 	} ] ``` throws ""No property - found for type String! Traversed path: entity.foo.bar.""   In file org.springframework.data.rest.webmvc.json.patch.SpelPath, the following line seems to lead to this error :   `return typeInformation.isCollectionLike() ? this.skipWith(""-"".equals(segment) ? ""$[true]"" : String.format(""[%s]"", segment)) : this.nested(segment);`  Indeed, typeInformation should be related to the parent list but is set with the the type of object Foo, as a result, 'this.nested(segment)' is called instead of returning '$[true]'   error in logs:  ``` Caused by: org.springframework.data.mapping.PropertyReferenceException: No property - found for type String! Traversed path: Entity.foo.bar. 	at org.springframework.data.mapping.PropertyPath.(PropertyPath.java:94) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:382) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:358) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:342) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at org.springframework.data.mapping.PropertyPath.lambda$from$0(PropertyPath.java:314) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_192] 	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:293) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at org.springframework.data.mapping.PropertyPath.nested(PropertyPath.java:214) ~[spring-data-commons-2.2.0.RC1.jar:2.2.0.RC1] 	at org.springframework.data.rest.webmvc.json.patch.SpelPath$TypedSpelPath$SpelExpressionBuilder.nested(SpelPath.java:529) ~[spring-data-rest-webmvc-3.2.0.RC1.jar:3.2.0.RC1] 	... 138 common frames omitted  ```","closed","for: external-project,","leruitga-ss","2019-08-06T15:09:37Z","2019-10-03T12:01:17Z"
"","23468","Provide Dispatcher using RequestMatchers for MockWebServer okhttp","For integration testing  `WebClient`, it is advised to use okhttp `MockWebServer` (see for example #19852). Which is great in general, but it lacks an important ability that `MockRestServiceServer` offered: writing conditions for the responses to return:  ``` mockServer.expect(ExpectedCount.once(), requestTo(path))                 .andExpect(method(HttpMethod.POST))                 .andExpect(jsonPath(""$"", hasSize(1)))                 .andExpect(jsonPath(""$[0].someField"").value(""some value"")); ```  In `MockWebServer` that's simply not possible. Your only chance is to `mockWebServer.enqueue()`, and if you have a service that sends multiple webservice requests, there is no chance to match responses to explicit requests.  okhttp offers a ""solution"" by using a custom `Dispatcher` with custom logic: https://github.com/square/okhttp/tree/master/mockwebserver  Idea: it would be great if spring could offer a `Dispatcher` that can take `RequestMatcher` like above. Something like: ``` dispatcher.addExpected(new MockResponse().body(body), method(HttpMethod.POST), requestTo(path), jsonPath(""$[0].someField"").value(""some value"")); ```  The Dispatcher should then only return the mocked response if all the `RequestMatcher` have been true.","closed","status: declined,","membersound","2019-08-16T06:40:51Z","2019-11-15T17:29:20Z"
"","23526","Add `add`, `filter`, `before`, `after`, `onError` to Kotlin router DSL","For feature parity between Java and Kotlin.","closed","type: enhancement,","sdeleuze","2019-08-27T09:48:45Z","2019-09-17T10:03:26Z"
"","23172","Document that Ordered is not supported for @ControllerAdvice beans","For details, see gh-23163.","closed","in: web,","sbrannen","2019-06-21T09:37:59Z","2019-06-21T09:44:03Z"
"","23587","Rename fromObject to fromValue in BodyInserters","For consistency with `bodyValue`. `BodyInserters#fromObject` will be deprecated.","closed","type: task,","sdeleuze","2019-09-05T12:25:59Z","2019-09-08T22:14:13Z"
"","22868","Consider making @Value consistent for resource arrays and collections","For `Resource` arrays, the `ResourceArrayPropertyEditor` will convert the location pattern to an array of resources. However, if `@Value` is present on a `Collection`, you get a `Resource` that you then probably have to call `getPath()` on and use a `ResourcePatternResolver` to resolve that. It seems like it would be useful to make `@Value` consistent for resource collections and arrays.   This was originally raised in [Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/15835)  for `@ConfigurationProperties`. We'd like to be consistent with what Framework does for `@Value`.","open","type: enhancement,","mbhave","2019-05-01T16:44:13Z","2019-07-29T17:47:26Z"
"","23250","Introduce TransactionOperations.execute(Runnable) convenience method","Following up on #23198, `TransactionOperations` and `TransactionTemplate` would benefit from a dedicated `void execute(Runnable)` method which is conveniently usable with lambda expressions, not enforcing a potentially unused `TransactionStatus` and not having to return a `null` dummy.","closed","type: enhancement,","jhoeller","2019-07-08T13:33:15Z","2019-07-17T20:40:14Z"
"","22889","Consistent naming of WebFlux HandlerMethodArgumentResolver implementations","Following up on #22888, there are also a few WebFlux `HandlerMethodArgumentResolver` implementations with a shortened `ArgumentResolver` name which should really be named `MethodArgumentResolver` for consistency next to all other resolver implementation classes in their package.","closed","type: task,","jhoeller","2019-05-04T16:12:04Z","2019-05-04T16:40:49Z"
"","23156","Upgrade to ASM 7.2","Following up on #22503, since early JDK 14 support has arrived in ASM master already, let's track those commits for Spring Framework 5.2. We expect that they'll be released as ASM 7.2 eventually.","closed","type: dependency-upgrade,","jhoeller","2019-06-19T15:16:41Z","2019-07-05T14:28:21Z"
"","22912","Consistent handling of empty List entries in LinkedMultiValueMap","Following up on #22421, not only `getFirst` may run into an `IndexOutOfBoundsException` but also `toSingleValueMap`. Let's fix this consistently and also backport it.","closed","in: core,","jhoeller","2019-05-07T10:58:52Z","2019-05-07T11:14:21Z"
"","23611","Support suspending handler methods in Spring MVC","Following Coroutines support introduced in Spring WebFlux and since Spring MVC supports `Mono` via the `ReactiveAdapterRegistry`, it would probably makes sense to support Coroutines (suspending handler methods) in Spring MVC.  It will require similar handling than in WebFlux side + disabling the check introduced via #23585.  Good candidate for Spring Framework 5.3.","closed","type: enhancement,","sdeleuze","2019-09-09T08:17:03Z","2020-10-09T10:32:47Z"
"","23287","AbstractMessageConverterMethodProcessor results in 406 with ""Accept: */*"" when @RequestMapping produces condition determined the content type","Following #23205 I found a similar issue.  If you declare a controller like this:  ```java @GetMapping(path = ""/xml"", produces = ""application/xml"") public Map producesContentTypeThatIsNotSupportedByAnyConverter() { 	return ImmutableMap.of(""foo"", ""bar""); } ```  And make a request like this (httpie):  ``` http -v :9080/xml ```  Then the result will be:  ``` GET /xml HTTP/1.1 Accept: */* ...    HTTP/1.1 406 ... ```  `AbstractMessageConverterMethodProcessor#writeWithMessageConverters` method will throw `org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation`.  This is very similar case to a case with `ResponseEntity` - the server is responsible for selecting content-type `application/xml` (if it is acceptable by a client, and in this case - it is) and no converters found that can write the result using this content-type.  The `Accept` header was taken into account but it was `Accept: */*` so it is obviously not ""Could not find acceptable representation"" case, but more like a ""Cound not find http message converter for totally acceptable representation"" (`application/xml` is acceptable for a client, that requsted it with `Accept: */*`).  So it is strange to receive a 406 result for a request with `Accept: */*` header. The real problem in this case is a server misconfiguration: the server declares that it produces `application/xml`, but at the same time it didn't register any `HttpMessageConverter` that can return this content type. How can this be a 4xx then?","closed","type: enhancement,","xak2000","2019-07-13T17:11:38Z","2020-01-09T11:11:33Z"
"","23379","Introduce Converter.andThen(...)","Fixes: gh-22381","closed","type: enhancement,","jzheaux","2019-07-29T13:16:51Z","2020-09-29T13:29:13Z"
"","23070","Fixes issue with optional @RequestPart Mono argument being resolved to null instead of Mono.empty","Fixes #23060","closed","type: bug,","L00kian","2019-05-31T14:05:55Z","2019-07-02T08:54:34Z"
"","23074","Fix MockHttpServletRequest.setCookies to produce single Cookie header","Fixes #23029","closed","type: bug,","L00kian","2019-06-03T12:10:26Z","2019-07-02T08:55:49Z"
"","23320","Support @TestPropertySource as a repeatable annotation","Fixed #21986 and https://jira.spring.io/browse/SPR-17454?redirect=false  I often make composite meta-annotations in my libraries and sometimes I need to define some properties in tests by the using of meta-annotation, it's difficult without the full support of inheritance and repeatable of the TestPropertySource annotation.  I tried to implement it in this PR, hope this is the right way. If not, please suggest me how to make it better.","closed","status: feedback-provided,","antkorwin","2019-07-20T07:18:52Z","2019-07-29T21:04:34Z"
"","23603","Fix typo","fix typo(an sql)","closed","type: documentation,","KangZhiDong","2019-09-07T06:05:25Z","2019-09-07T14:07:58Z"
"","23726","Fix typo in DispatcherServlet Javadoc","fix typo","closed","type: documentation,","KangZhiDong","2019-09-29T12:28:19Z","2019-09-29T14:22:57Z"
"","23814","AbstractRequestLoggingFilter.isIncludeHeaders() declared as protected","Fix SPR-16881 in 4.3.x. (It was supposed to be backported in 4.3.18, but it was not actually fixed.)","closed","type: bug,","endtak","2019-10-16T01:58:54Z","2019-11-13T16:48:27Z"
"","22941","Fix typo in package-info.java","fix SImple -> Simple","closed","type: documentation,","chenqimiao","2019-05-10T08:06:01Z","2019-05-10T08:51:38Z"
"","23046","Fix typo","fix provices -> provides","closed","type: documentation,","shadowzey","2019-05-28T10:55:42Z","2019-05-28T14:00:45Z"
"","23797","Add setPrimary method","fix https://github.com/spring-projects/spring-framework/issues/23794","closed","status: duplicate,","wycm","2019-10-15T14:16:01Z","2022-02-18T19:07:14Z"
"","23414","Add queryParam method to MockHttpServletRequestBuilder","fix #23296  add query params to query string in builder method in MockHttpServletRequestBuilder  add tests","closed","status: superseded,","jo2","2019-08-03T20:51:42Z","2019-11-12T16:39:15Z"
"","23148","Spring Web ignores '+' character while encoding with HierarchicalUriComponents","First of all, thank you very much for maintaining this great project! But let me go straight to the issue.  Here is a unit test to demonstrate the problem: ```java @Test public void encode_withUrlInQueryParams() throws UnsupportedEncodingException {     String base = ""https://www.base.com"";     String first = ""https://www.first.com?time_stamp=2019-06-17+03%3A48%3A56&address=25+Downing+Street"";     String second = ""https://www.second.com?address=25%20Downing%20Street"";     String encoded = UriComponentsBuilder.fromHttpUrl(base)             .queryParam(""first"", first)             .queryParam(""second"", second)             .build().toUriString();     Map values = UriComponentsBuilder.fromUriString(encoded).build().getQueryParams().toSingleValueMap();     assertThat(URLDecoder.decode(values.get(""second""), ""UTF-8"")).isEqualTo(second);     assertThat(URLDecoder.decode(values.get(""first""), ""UTF-8"")).isEqualTo(first); } ```  This test works on `4.3.21.RELEASE`, but fails on `5.1.7.RELEASE` version: ```java Expected :""https://www.first.com?time_stamp=2019-06-17+03%3A48%3A56&address=25+Downing+Street"" Actual   :""https://www.first.com?time_stamp=2019-06-17 03%3A48%3A56&address=25 Downing Street"" ```  In short: as Spring ignores `+` character while encoding, further decoding ""breaks"" parameter.","closed","status: invalid,","stepio","2019-06-17T17:12:56Z","2019-06-24T12:54:14Z"
"","23189","RSocketRequester.ResponseSpec Kotlin extensions issue","Extension functions need to use reified types to create  ParameterizedTypeReference  Closes gh-23185","closed","","slawluc","2019-06-24T17:44:31Z","2022-02-18T19:07:08Z"
"","23598","ClassCastException when use ServerHttpResponseDecorator to modify response of websocket","Execuse me, I really need your help!  I submit an issue in spring-cloud-gateway project, but their member let me reach out to you.  In gateway, I want to modify response and return some customized message to client  when websocket connect success. Then I add a filter and copy codes from ModifyResponseBodyGatewayFilterFactory.   My spring cloud version is Greenwich.SR2. But finally I got a ClassCastException.  Is there any way to solve this exception?  Here is the exception : ``` 2019-09-06 10:14:49.199 ERROR 17200 --- [ctor-http-nio-8] a.w.r.e.AbstractErrorWebExceptionHandler : [551d2e4c] 500 Server Error for HTTP GET ""/websocket""  java.lang.ClassCastException: com.test.demo.gateway.filters.ModifyResponseFilter$1 cannot be cast to org.springframework.http.server.reactive.AbstractServerHttpResponse 	at org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy.upgrade(ReactorNettyRequestUpgradeStrategy.java:75) ~[spring-webflux-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService.lambda$handleRequest$1(HandshakeWebSocketService.java:235) ~[spring-webflux-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:141) [reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:53) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeek.subscribe(MonoPeek.java:71) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3852) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDoFinally.subscribe(MonoDoFinally.java:47) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3852) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:144) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1515) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFilterWhen$MonoFilterWhenMain.onNext(MonoFilterWhen.java:140) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2071) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFilterWhen$MonoFilterWhenMain.onSubscribe(MonoFilterWhen.java:103) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFilterWhen.subscribe(MonoFilterWhen.java:56) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeek.subscribe(MonoPeek.java:71) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3852) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onNext(FluxConcatMap.java:244) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxDematerialize$DematerializeSubscriber.onNext(FluxDematerialize.java:114) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxDematerialize$DematerializeSubscriber.onNext(FluxDematerialize.java:42) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drainAsync(FluxFlattenIterable.java:395) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drain(FluxFlattenIterable.java:638) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.onNext(FluxFlattenIterable.java:242) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:179) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1498) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onComplete(MonoCollectList.java:121) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.DrainUtils.postCompleteDrain(DrainUtils.java:131) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.DrainUtils.postComplete(DrainUtils.java:186) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxMaterialize$MaterializeSubscriber.onComplete(FluxMaterialize.java:134) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drainAsync(FluxFlattenIterable.java:325) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drain(FluxFlattenIterable.java:638) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.onComplete(FluxFlattenIterable.java:259) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:144) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1499) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onComplete(MonoCollectList.java:121) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:540) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:426) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:265) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:201) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:335) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97) [reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoCollectList.subscribe(MonoCollectList.java:40) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlattenIterable.subscribe(MonoFlattenIterable.java:101) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxMaterialize.subscribe(FluxMaterialize.java:40) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoCollectList.subscribe(MonoCollectList.java:40) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlattenIterable.subscribe(MonoFlattenIterable.java:101) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxDematerialize.subscribe(FluxDematerialize.java:39) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:54) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3852) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.Mono.subscribe(Mono.java:3852) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:172) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:70) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.core.publisher.MonoPeekTerminal.subscribe(MonoPeekTerminal.java:61) ~[reactor-core-3.2.11.RELEASE.jar:3.2.11.RELEASE] 	at reactor.netty.http.server.HttpServerHandle.onStateChange(HttpServerHandle.java:64) ~[reactor-netty-0.8.10.RELEASE.jar:0.8.10.RELEASE] 	at reactor.netty.tcp.TcpServerBind$ChildObserver.onStateChange(TcpServerBind.java:226) ~[reactor-netty-0.8.10.RELEASE.jar:0.8.10.RELEASE] 	at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:442) ~[reactor-netty-0.8.10.RELEASE.jar:0.8.10.RELEASE] 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:91) ~[reactor-netty-0.8.10.RELEASE.jar:0.8.10.RELEASE] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:161) ~[reactor-netty-0.8.10.RELEASE.jar:0.8.10.RELEASE] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328) ~[netty-codec-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302) ~[netty-codec-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) ~[netty-common-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.38.Final.jar:4.1.38.Final] 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.38.Final.jar:4.1.38.Final] 	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_144] ```  Here is my filter : ``` public class ModifyResponseFilter implements GatewayFilter, Ordered {     @Override     public Mono filter(ServerWebExchange exchange, GatewayFilterChain chain) {          System.out.println(""pass ModifyResponseFilter..."");         return chain.filter(exchange.mutate().response(decorate(exchange)).build());     }      @Override     public int getOrder() {         return NettyWriteResponseFilter.WRITE_RESPONSE_FILTER_ORDER - 1;     }      ServerHttpResponse decorate(ServerWebExchange exchange) {         return new ServerHttpResponseDecorator(exchange.getResponse()) {              @Override             public Mono writeWith(Publisher body) {                  Class inClass = String.class;                 Class outClass = String.class;                  String originalResponseContentType = exchange                         .getAttribute(ORIGINAL_RESPONSE_CONTENT_TYPE_ATTR);                 HttpHeaders httpHeaders = new HttpHeaders();                 // explicitly add it in this way instead of                 // 'httpHeaders.setContentType(originalResponseContentType)'                 // this will prevent exception in case of using non-standard media                 // types like ""Content-Type: image""                 httpHeaders.add(HttpHeaders.CONTENT_TYPE,                         originalResponseContentType);                  ClientResponse clientResponse = ClientResponse                         .create(exchange.getResponse().getStatusCode())                         .headers(headers -> headers.putAll(httpHeaders))                         .body(Flux.from(body)).build();                  // TODO: flux or mono                 Mono modifiedBody = clientResponse.bodyToMono(inClass)                         .flatMap(originalBody -> {                             String newResult =  ""modify response : "" + originalBody;                             return Mono.just(newResult);                         });                  BodyInserter bodyInserter = BodyInserters.fromPublisher(modifiedBody, outClass);                 CachedBodyOutputMessage outputMessage = new CachedBodyOutputMessage(                         exchange, exchange.getResponse().getHeaders());                 return bodyInserter.insert(outputMessage, new BodyInserterContext())                         .then(Mono.defer(() -> {                             Flux messageBody = outputMessage.getBody();                             HttpHeaders headers = getDelegate().getHeaders();                             if (!headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {                                 messageBody = messageBody.doOnNext(data -> headers                                         .setContentLength(data.readableByteCount()));                             }                             // TODO: fail if isStreamingMediaType?                             return getDelegate().writeWith(messageBody);                         }));             }              @Override             public Mono writeAndFlushWith(                     Publisher> body) {                 return writeWith(Flux.from(body).flatMapSequential(p -> p));             }         };     } } ```   In ReactorNettyRequestUpgradeStrategy, I found a force cast from exchange.getResponse() to AbstractServerHttpResponse, so the ServerHttpResponseDecorator is failed. ``` public class ReactorNettyRequestUpgradeStrategy implements RequestUpgradeStrategy {     private int maxFramePayloadLength = 65536;      public ReactorNettyRequestUpgradeStrategy() {     }      public void setMaxFramePayloadLength(Integer maxFramePayloadLength) {         this.maxFramePayloadLength = maxFramePayloadLength;     }      public int getMaxFramePayloadLength() {         return this.maxFramePayloadLength;     }      public Mono upgrade(ServerWebExchange exchange, WebSocketHandler handler, @Nullable String subProtocol, Supplier handshakeInfoFactory) {         ServerHttpResponse response = exchange.getResponse();         HttpServerResponse reactorResponse = (HttpServerResponse)((AbstractServerHttpResponse)response).getNativeResponse();         HandshakeInfo handshakeInfo = (HandshakeInfo)handshakeInfoFactory.get();         NettyDataBufferFactory bufferFactory = (NettyDataBufferFactory)response.bufferFactory();         return reactorResponse.sendWebsocket(subProtocol, this.maxFramePayloadLength, (in, out) -> {             ReactorNettyWebSocketSession session = new ReactorNettyWebSocketSession(in, out, handshakeInfo, bufferFactory, this.maxFramePayloadLength);             return handler.handle(session);         });     } } ```   [spring-cloud-gateway-websocket-demo.zip](https://github.com/spring-cloud/spring-cloud-gateway/files/3582005/spring-cloud-gateway-websocket-demo.zip)  You can reproduce the exception with this demo. 1. start EurekaApplication 2. start GatewayApplication 3. start WebSocketServerApplication 4. run com.test.demo.websocketserver.WebSocketClient.java in websocket-server project","closed","type: bug,","SaigonoHanabi","2019-09-06T11:15:28Z","2019-09-12T20:29:11Z"
"","22901","Exception message should be null checked before accessing it in InvocableHandlerMethod#logArgumentErrorIfNecessary","Exception message should be null checked before accessing it in [InvocableHandlerMethod#logArgumentErrorIfNecessary](https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219).  If message is null, NPE will be thrown and webflux responds 500(INTERNAL SERVER ERROR).  In [corresponding function in webmvc](https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219), exception message is checked before accessing its method.","closed","status: superseded,","sakuna63","2019-05-06T10:03:50Z","2019-05-06T10:07:06Z"
"","23354","use idea compile spring5 source code occur error and i haven pull the lastest kotlin","Error:Kotlin: [Internal Error] java.lang.LinkageError: loader constraint violation: loader (instance of org/jetbrains/kotlin/cli/jvm/plugins/PluginURLClassLoader$SelfThenParentURLClassLoader) previously initiated loading for a different type with name ""kotlin/sequences/Sequence"" 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:760) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) 	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) 	at org.jetbrains.kotlin.cli.jvm.plugins.PluginURLClassLoader$SelfThenParentURLClassLoader.findClass(PluginURLClassLoader.kt:47) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 	at java.lang.ClassLoader.defineClass1(Native Method) 	at java.lang.ClassLoader.defineClass(ClassLoader.java:760) 	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) 	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) 	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) 	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) 	at java.security.AccessController.doPrivileged(Native Method) 	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) 	at org.jetbrains.kotlin.cli.jvm.plugins.PluginURLClassLoader$SelfThenParentURLClassLoader.findClass(PluginURLClassLoader.kt:47) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) 	at kotlin.coroutines.experimental.SequenceBuilderKt__SequenceBuilderKt.buildSequence(SequenceBuilder.kt:24) 	at org.jetbrains.kotlin.scripting.compiler.plugin.ScriptiDefinitionsFromClasspathDiscoverySourceKt.discoverScriptTemplatesInClasspath(ScriptiDefinitionsFromClasspathDiscoverySource.kt:53) 	at org.jetbrains.kotlin.scripting.compiler.plugin.ScriptDefinitionsFromClasspathDiscoverySource.(ScriptiDefinitionsFromClasspathDiscoverySource.kt:37) 	at org.jetbrains.kotlin.scripting.compiler.plugin.ScriptingCompilerConfigurationExtension.updateConfiguration(ScriptingCompilerConfigurationExtension.kt:56) 	at org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment.(KotlinCoreEnvironment.kt:201) 	at org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment.(KotlinCoreEnvironment.kt:120) 	at org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment$Companion.createForProduction(KotlinCoreEnvironment.kt:433) 	at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.createCoreEnvironment(K2JVMCompiler.kt:295) 	at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.kt:147) 	at org.jetbrains.kotlin.cli.jvm.K2JVMCompiler.doExecute(K2JVMCompiler.kt:51) 	at org.jetbrains.kotlin.cli.common.CLICompiler.execImpl(CLICompiler.java:95) 	at org.jetbrains.kotlin.cli.common.CLICompiler.execImpl(CLICompiler.java:50) 	at org.jetbrains.kotlin.cli.common.CLITool.exec(CLITool.kt:88) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl$compile$$inlined$ifAlive$lambda$1.invoke(CompileServiceImpl.kt:399) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl$compile$$inlined$ifAlive$lambda$1.invoke(CompileServiceImpl.kt:98) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl$doCompile$$inlined$ifAlive$lambda$2.invoke(CompileServiceImpl.kt:927) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl$doCompile$$inlined$ifAlive$lambda$2.invoke(CompileServiceImpl.kt:98) 	at org.jetbrains.kotlin.daemon.common.DummyProfiler.withMeasure(PerfUtils.kt:137) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl.checkedCompile(CompileServiceImpl.kt:957) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl.doCompile(CompileServiceImpl.kt:926) 	at org.jetbrains.kotlin.daemon.CompileServiceImpl.compile(CompileServiceImpl.kt:397) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ![image](https://user-images.githubusercontent.com/48974977/61844511-45449b00-aed2-11e9-93ed-2ca6f9f4734a.png)","closed","","ppamos","2019-07-25T04:25:00Z","2020-05-03T15:09:59Z"
"","23095","javax.servlet.error.status_code return null when get through WebRequest.getAttribute(String name, int scope)","Environment: Centos 7.6 / Oracle JDK 1.8 / Spring Framework 4.3.18 **Affects:** \<4.3.18>  --- **Issue:** status_code return null when get through WebRequest.getAttribute(String name, int scope) as in the following code snippet:  ` @Controller public class ErrorController {      @GetMapping(""/error"")     protected ModelAndView errorHandler(WebRequest request){         ModelAndView model = new ModelAndView(""error/err"");         Map map = new HashMap();        try {             map.put(""forward_context_path"", (String)request.getAttribute(""javax.servlet.forward.context_path"", RequestAttributes.SCOPE_REQUEST));             map.put(""forward_servlet_path"", (String)request.getAttribute(""javax.servlet.forward.servlet_path"", RequestAttributes.SCOPE_REQUEST));             map.put(""bestMatchingPattern"", (String)request.getAttribute(""org.springframework.web.servlet.HandlerMapping.bestMatchingPattern"", RequestAttributes.SCOPE_REQUEST));              map.put(""error_servlet_name"", (String)request.getAttribute(""javax.servlet.error.servlet_name"", RequestAttributes.SCOPE_REQUEST));             map.put(""error_request_uri"", (String)request.getAttribute(""javax.servlet.error.request_uri"", RequestAttributes.SCOPE_REQUEST));             map.put(""status_code"", request.getAttribute(""javax.servlet.error.status_code"", RequestAttributes.SCOPE_REQUEST).toString());             map.put(""message"", (String)request.getAttribute(""javax.servlet.error.message"", RequestAttributes.SCOPE_REQUEST));         } catch (Exception e) {             e.printStackTrace();         }          model.addAllObjects(map);          return model;     } } `  The above code will result in just like the output below: java.lang.NullPointerException 	at localsite.ErrorController.errorHandler(ErrorController.java:31) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) 	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:678) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:836) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1839) 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.lang.Thread.run(Thread.java:748)   The above java.lang.NullPointerException caused by:             map.put(""status_code"", request.getAttribute(""javax.servlet.error.status_code"", RequestAttributes.SCOPE_REQUEST).toString());  BUT the status_code SHOULD NOT to be null.  Thx for your attention.","closed","","rosschn","2019-06-07T00:38:10Z","2022-02-18T19:10:14Z"
"","22830","Add a way to combine more than one AnnotationIntrospector in Jackson2ObjectMapperBuilder instead of overriding it","Enhancement  Today there is an option to provide custom `annotationIntrospector` to the `Jackson2ObjectMapperBuilder` via `Jackson2ObjectMapperBuilderCustomizer`: ```java     @Bean     public Jackson2ObjectMapperBuilderCustomizer myCustomizer() {         return jacksonObjectMapperBuilder -> jacksonObjectMapperBuilder.annotationIntrospector(new MyIntrospector());     } ``` However, in that way I'm replacing existing `introspector`. So if some other introspectors were added by some libs - they will be just lost and today there seems to be no option to extend existing ones instead.  Would be good to adjust `org.springframework.http.converter.json.Jackson2ObjectMapperBuilder` to either provide some way to get currently configured `annotationIntrospector` (so that I can use something like `AnnotationIntrospector.pair` to combine it with mine) or to have some other way to add new introspector to current one instead of replacing it.","closed","type: enhancement,","anatoliy-balakirev","2019-04-24T08:20:40Z","2020-02-05T20:50:35Z"
"","25430","Bean overriding for 'taskExecutor' alias is not detected","Earlier I was using 2.0.9.RELEASE, i have simply upgraded to 2.1.7.RELEASE. One of the bean couldn't be found or scanned by ComponentScan.   ``` *************************** APPLICATION FAILED TO START *************************** Description: Field taskExecutor in com.helper.Helper required a bean of type 'com.task.TaskExecutor' that could not be found. The injection point has the following annotations: 	- @org.springframework.beans.factory.annotation.Autowired(required=true) Action: Consider defining a bean of type 'com.task.TaskExecutor' in your configuration. ```  In main class `@ComponentScan` is present and TaskExecutor is annotated with `@Component`.  I have tried moving up the main class, but didn't help still.","closed","in: core,","rgampa","2019-08-09T23:45:20Z","2020-07-22T16:45:19Z"
"","22895","Reference to response payload is kept in each thread","Each thread of the application keeps reference to response payload. This reference is getting cleaned/reused when thread gets used again.  This behavior is abnormal, because keeping reference to payload causes OoM when number of threads is high and payloads are big. It is not question of sizing of jvm as permanent heap requirements are n*m where n is the max size of the pool and m is the biggest size of response of the application.  How to reproduce:  Consider a method that returns `StreamSource`.  ```java @PayloadRoot(namespace = PULLACK_NAMESPACE_URI, localPart = ""PullRequest"") @ResponsePayload public StreamSource requestDataGetEvents(@RequestPayload XMLStreamReader reader) throws DurableStorageException{…… ```  and ensure that reply is big enough, then memory footprint would look similar to: ![image](https://user-images.githubusercontent.com/50314851/57211152-88802380-6fdf-11e9-87d3-32419659a846.png)  The reference to memory is kept and thread goes back to pool after processing the reply to the client. This reference is replaced by new reference once thread gets reused.  Ideas about resolution: either output stream is not closed, either reference to payload is not cleaned correctly.  Workaround: manipulate streams directly in the application which is not the objective here.","closed","for: external-project,","smaxi","2019-05-06T07:26:33Z","2019-05-07T12:32:02Z"
"","23777","Fix typos in websocket.adoc","During the read of WebSocket docs I came across some minor but quality affecting mistakes in the documentation which I've decided to fix.","closed","type: task,","CaptainAye","2019-10-10T21:29:16Z","2019-10-23T16:33:57Z"
"","23602","WebClient read timeout after being idle for several minutes","duplicate from #22142， due to that issue has been closed. @bclozel @violetagg  i found this issue may relates to the **Reactor Connection Pool**, i reproduced this problem in my dev envrionment,I did 4 requests at ```2019-09-06 00:10:14.739```(t1)、```2019-09-06 00:19:51.274```(t2)、```2019-09-06 00:30:37.992```(t3)、```2019-09-06 00:33:13.314```(t4)， the request1(at t1), request2(at t2)  webclient didn't idle too long time, the requests were processed fine, but request3(at t3), webclient was idle 10minutes, webclient got **Read Timeout**, then i did request4 , it was processed fine as well. and i noticed that request1、request2、request3，they used same local port: 59838 but request4 used local port:60928  so i guess that: the connection(or channel in netty) will be cached in the connection pool, reactor netty will manage and reuse it, but when the connection idle too long, the connection may be closed or cut down by remote side(F5 loadbalance or Nginx?) or some other reason, it became disconnected on the link layer, but the connection pool did not realize what happened actually, the connection pool still thinks this connection is connected and provide it to webclient, and boom: read time out. ```java         HttpClient httpClient = HttpClient.create()                 .tcpConfiguration(tcpClient -> {                     tcpClient = tcpClient.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);                     tcpClient = tcpClient.doOnConnected(conn -> conn                             .addHandlerLast(new ReadTimeoutHandler(15000, TimeUnit.MILLISECONDS)));                     return tcpClient;                 }); ``` request1: ``` 2019-09-06 00:10:14.768 [reactor-http-kqueue-5] DEBUG reactor.netty.http.client.HttpClientOperations - [id: 0x0759376f, L:/10.49.3.9:59838 - R:****.com/****:****] Received response (auto-read:false) : [Server=nginx, Date=Thu, 05 Sep 2019 16:10:15 GMT, Content-Type=application/json, Content-Length=64, Connection=keep-alive, Access-Control-Allow-Headers=Accept, Accept-Encoding, Authorization, Content-Type, Origin, Access-Control-Allow-Methods=GET, OPTIONS, Access-Control-Expose-Headers=Date, Vary=Accept-Encoding, Access-Control-Allow-Credentials=true] 2019-09-06 00:10:14.768 [reactor-http-kqueue-5] DEBUG reactor.netty.resources.PooledConnectionProvider - [id: 0x0759376f, L:/10.49.3.9:59838 - R:****.com/****:****] onStateChange(GET{uri=/api/v1/query?time=1567439463&query****), connection=PooledConnection{channel=[id: 0x0759376f, L:/10.49.3.9:59838 - R:****/****:****]}}, [response_received]) 2019-09-06 00:10:14.768 [reactor-http-kqueue-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1807c047] Response 200 OK ``` request2: ``` 2019-09-06 00:19:51.272 [reactor-http-kqueue-5] DEBUG reactor.netty.http.client.HttpClientOperations - [id: 0x0759376f, L:/10.49.3.9:59838 - R:****.com/****:****] Received response (auto-read:false) : [Server=nginx, Date=Thu, 05 Sep 2019 16:19:51 GMT, Content-Type=application/json, Content-Length=64, Connection=keep-alive, Access-Control-Allow-Headers=Accept, Accept-Encoding, Authorization, Content-Type, Origin, Access-Control-Allow-Methods=GET, OPTIONS, Access-Control-Expose-Headers=Date, Vary=Accept-Encoding, Access-Control-Allow-Credentials=true] 2019-09-06 00:19:51.272 [reactor-http-kqueue-5] DEBUG reactor.netty.resources.PooledConnectionProvider - [id: 0x0759376f, L:/10.49.3.9:59838 - R:****.com/****:****] onStateChange(GET{uri=/api/v1/query?time=1567439463&query=****), connection=PooledConnection{channel=[id: 0x0759376f, L:/10.49.3.9:59838 - R:****.com/***:***]}}, [response_received]) 2019-09-06 00:19:51.272 [reactor-http-kqueue-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1a576a1] Response 200 OK ``` request3: ``` 2019-09-06 00:30:52.998 [reactor-http-kqueue-5] WARN  reactor.netty.http.client.HttpClientConnect - [id: 0x0759376f, L:/10.49.3.9:59838 - R:njyh.data.promes.cloudytrace.com/10.104.232.131:9801] The connection observed an error io.netty.handler.timeout.ReadTimeoutException: null 	Suppressed: java.lang.Exception: #block terminated with an error ``` request4: ``` 2019-09-06 00:33:13.338 [reactor-http-kqueue-3] DEBUG reactor.netty.http.client.HttpClientOperations - [id: 0x47c1f6c3, L:/10.49.3.9:60928 - R:****.com/****:****] Received response (auto-read:false) : [Server=nginx, Date=Thu, 05 Sep 2019 16:33:13 GMT, Content-Type=application/json, Content-Length=64, Connection=keep-alive, Access-Control-Allow-Headers=Accept, Accept-Encoding, Authorization, Content-Type, Origin, Access-Control-Allow-Methods=GET, OPTIONS, Access-Control-Expose-Headers=Date, Vary=Accept-Encoding, Access-Control-Allow-Credentials=true] 2019-09-06 00:33:13.338 [reactor-http-kqueue-3] DEBUG reactor.netty.resources.PooledConnectionProvider - [id: 0x47c1f6c3, L:/10.49.3.9:60928 - R:****.com/****:***] onStateChange(GET{uri=/api/v1/query?time=1567439463&query=****), connection=PooledConnection{channel=[id: 0x47c1f6c3, L:/10.49.3.9:60928 - R:****.com/***:****]}}, [response_received]) 2019-09-06 00:33:13.338 [reactor-http-kqueue-3] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [11c0862d] Response 200 OK ```  sorry for my poor english  _Originally posted by @phantomedc in https://github.com/spring-projects/spring-framework/issues/22142#issuecomment-528492715_","closed","for: external-project,","phantomedc","2019-09-07T02:27:28Z","2019-09-10T08:01:37Z"
"","23573","BeanUtils.isSimpleValueType() should not consider void or Void as a simple value type","Due to work performed in conjunction with #23572, it has come to our attention that `isSimpleProperty()` and `isSimpleValueType()` in `BeanUtils` consider `void` and `Void` as ""simple value types""; however, in this context it does not make sense to consider `void` and `Void` as a primitive and wrapper, respectively.  We should therefore add explicit exclusions for `void` and `Void` in `BeanUtils.isSimpleValueType()` and revise the final `return` statement in `org.springframework.web.reactive.result.view.ViewResolutionResultHandler.supports(HandlerResult)` accordingly.","closed","type: enhancement,","sbrannen","2019-09-03T12:05:39Z","2019-09-04T14:36:00Z"
"","22928","Document gh-22286 in the Reference Manual","Document gh-22286 in the Reference Manual.","closed","type: documentation,","sbrannen","2019-05-08T20:03:15Z","2019-05-09T14:20:43Z"
"","23784","ApplicationListenerMethodAdapter: gracefully handle beans which are actually NullBean","Currently, if you have an optional event listener (via a @Bean method returning `null`) this causes the event multicaster to explode violently.  Now, we just safely skip it.","closed","type: enhancement,","stevenschlansker","2019-10-11T21:04:55Z","2019-11-11T17:21:00Z"
"","22872","Make it easier to deal with a ServerResponse with a non-standard status code","Currently, if a `ServerResponse` has been built with a status code that is not part of the `HttpStatus` enum, there's no way to get the response's status. The existing `statusCode` method will throw an undocumented `IllegalArgumentException`. It would be useful to have a safe way to get the raw status code or, failing that, to document that an `IllegalArgumentException` may be thrown if the status is not known to `HttpStatus`. Another option would be to return `null` if the `int` can't be mapped to an `HttpStatus` but that would require the method to be `@Nullable` which would be a breaking change.","closed","type: enhancement,","wilkinsona","2019-05-02T14:14:03Z","2019-09-05T08:41:06Z"
"","23747","Optimize Connection.setReadOnly(false) in DataSourceUtils.resetConnectionAfterTransaction(…)","Currently, `DataSourceUtils.resetConnectionAfterTransaction(…)` queries the `isReadOnly()` state from the given JDBC `Connection` to disable read-only mode if `isReadOnly()` returns `true`. Ideally, the read-only state should be reset only if transaction attributes indicated to enable read-only mode (similar to isolation level and auto-commit).  Some JDBC drivers (e.g. H2) reach out to the database to query the state and we could skip this interaction.","closed","type: enhancement,","mp911de","2019-10-02T10:18:05Z","2019-10-29T23:28:28Z"
"","23572","ClassUtils.isPrimitiveOrWrapper(…) and friends should consider Void.class a primitive wrapper for void.class","Currently, `ClassUtils.isPrimitiveOrWrapper(…)` and `isPrimitiveWrapper(…)` do not consider `Void.class` a wrapper for `void`. Other primitives are covered, so it would make sense to consider `Void.class` a wrapper for `void.class`.  Here's a test case to reproduce the issue:  ```java @Test public void isPrimitiveOrWrapperShouldConsiderVoid() {  	assertThat(ClassUtils.isPrimitiveOrWrapper(void.class)).isTrue(); 	assertThat(ClassUtils.isPrimitiveOrWrapper(Void.class)).isTrue(); 	assertThat(ClassUtils.isPrimitiveWrapper(Void.class)).isTrue(); } ```","closed","type: enhancement,","mp911de","2019-09-03T10:33:29Z","2019-09-03T12:32:49Z"
"","23484","Respect already set `content-length` header for HEAD request.","Currently when making a downstream request from Spring Cloud Gateway, the `content-length` HTTP header is being overwritten by `org.springframework.http.server.reactive.HttpHeadResponseDecorator`. Ideally this decorator should not kick in when the header was already set manually, or otherwise. Also see https://github.com/spring-cloud/spring-cloud-gateway/issues/1210.","closed","type: enhancement,","TYsewyn","2019-08-19T08:23:01Z","2019-08-21T07:26:04Z"
"","23442","rootObject parameter should be nullable in SpEL Expression","Currently we have something like (including variants):  ```java public interface Expression {      @Nullable     Object getValue(Object rootObject) throws EvaluationException;      @Nullable      T getValue(@Nullable Class desiredResultType) throws EvaluationException; } ```  This cause some type inference issue with Kotlin where calling `val value = expression.getValue(String::class.java)` uses the first variant, not the second one. Also in implementation `rootObject` is nullable.  As a consequence, `Object rootObject` parameters should be changed to `@Nullable Object rootObject`. It is more correct semantically and avoid the ""issue"" in Kotlin.","closed","in: core,","sdeleuze","2019-08-09T15:28:01Z","2019-08-29T09:06:00Z"
"","23513","Add method to apply Consumer in RSocketRequester","Currently to include a credential within `RSocketRequester` a user needs to pass in a value and MediaType. If there are multiple values, the user has double the work to do. If there is a rich type being provided, the `RSocketStrategies` likely needs to be customized as well. For example, providing a username/password might look something like this:  ```java this.requester.route(""secure.retrieve-mono"") 		.metadata(credentials.getUsername(), USERNAME) 		.metadata(credentials.getPassword(), PASSWORD) 		... ```  It would be nice if a user could just do something like:  ```java this.requester.route(""secure.retrieve-mono"")         // apply(Consumer) 		.apply(credentials(credentials)) 		... ```  Another point is that it appears that RSocket APIs typically integrate using a Flyweight pattern such that encoding has access to lower level APIs (i.e. `ByteBuf metadata`). However, `RSocketRequester` does not provide access to these APIs. This means that direct support for `RSocket` cannot be leveraged with `RSocketRequester`. It would be nice if this could be reused somehow.","closed","in: messaging,","rwinch","2019-08-23T16:27:38Z","2019-09-02T12:42:07Z"
"","23271","Support application/json;charset=UTF-8 for ProtobufHttpMessageConverter","Currently the other mappers and converters default to UTF-8, but the protobuf to JSON HTTP utils don't.  For some context on the other tools see [here](https://github.com/spring-projects/spring-framework/issues/22100)","closed","status: declined,","CluEleSsUK","2019-07-10T13:51:08Z","2019-07-11T10:35:29Z"
"","23083","Support filename input in MultipartBodyBuilder","Currently the only way to submit a file part is to provide a `Resource` with a filename, which is problematic if in the input is a `Publisher` as in #22616.","closed","type: enhancement,","rstoyanchev","2019-06-04T18:46:01Z","2019-06-04T21:23:18Z"
"","22906","Deprecate StandardMetadata constructors","Currently the `StandardMetadata` class has public constructors that are making it hard to evolve. Specifically we'd like to remove the `nestedAnnotationsAsMap` parameter, and make the default effectively `nestedAnnotationsAsMap=true`.  It's doubtful that anyone is using this class directly, but to be safe we could deprecate the constructors and use a factory method instead.","closed","in: core,","philwebb","2019-05-06T20:25:58Z","2019-05-07T21:13:48Z"
"","23336","Retain merged bean definition caches during post processing","Currently the `RootBeanDefinition` used to represent merged bean definitions includes quite a few package private caches. These are currently dropped whenever after bean post processors have run in case post processing causes the bean type to change. In modern Spring applications this is very unlikely to happen and we could benefit my trying to retain cached items if they're still relevant.","closed","type: enhancement,","philwebb","2019-07-23T09:47:53Z","2019-07-31T10:23:28Z"
"","23637","Allow @Import and @ComponentScan classes to use constructor injection","Currently the `ImportBeanDefinitionRegistrar`, `ImportSelector`, `DeferredImportSelector.Group` and `TypeFilter` interfaces allow the following callbacks to be used:  * `EnvironmentAware` * `BeanFactoryAware` * `BeanClassLoaderAware` * `ResourceLoaderAware`  It would be very nice if constructor arguments could be used as an alternative to these. This would allow implementation to use `final` fields.","closed","type: enhancement,","philwebb","2019-09-13T17:04:30Z","2019-09-13T23:18:20Z"
"","22915","Add support for Coroutines transactions","Currently spring transactions bind to ThreadLocal. Are there any plans to support binding to Kotlin coroutines?  For example @Transactional over a suspend function maybe should  bind to the coroutine context regardless of the executing thread.","closed","type: enhancement,","gkdevone","2019-05-07T11:14:13Z","2021-11-16T15:39:03Z"
"","23539","Add blank line between java and javax imports","Currently it's impossible to configure Eclipse to organize imports in a way that makes checkstyle happy. There's no way to not add the gap between `java` and `javax`.  Rather than fighting the IDE, we could consider changing the import rules.","closed","type: task,","philwebb","2019-08-28T15:54:53Z","2019-09-05T09:47:50Z"
"","22959","AntPathMatcher#isPattern ignores template variables","Currently it checks the presence of `""*""` and `""?""` only.","closed","type: enhancement,","rstoyanchev","2019-05-13T14:48:41Z","2019-05-23T13:58:39Z"
"","22845","CrudRepository add support for Optional","Currently I use CrudRepository this way ```java @Repository public interface StuffRepository extends CrudRepository {      public Stuff findStuffByOtherId(String otherId); } ``` would be great if this were possible ```java @Repository public interface StuffRepository extends CrudRepository {      public Optional findStuffByOtherId(String otherId); } ```  This would enable more compact code like this ```java @Autowired StuffRepository stuffRepository;  public Stuff getOrCreateStuff(String otherId) {   return stuffRepository.findByOtherId(otherId)       .orElse(stuffRepository.save(new Stuff(otherId))); } ```","closed","for: external-project,","amalic","2019-04-27T13:28:33Z","2019-04-27T13:36:18Z"
"","23170","Support for registering handlers in RSocketRequester.Builder","Currently client-side handling involves registering an acceptor, for example [like so](https://github.com/spring-projects/spring-framework/blob/cc05608ae9a1a33da2158612ed633067a1e3cbf6/spring-messaging/src/test/java/org/springframework/messaging/rsocket/RSocketServerToClientIntegrationTests.java#L113), which is likely an [RSocketMessageHandler bean](https://github.com/spring-projects/spring-framework/blob/cc05608ae9a1a33da2158612ed633067a1e3cbf6/spring-messaging/src/test/java/org/springframework/messaging/rsocket/RSocketServerToClientIntegrationTests.java#L262-L268) with manually registered handlers.   Arguably in this case there isn't much reason for applications to be aware of the `RSocketMessageHandler` nor to have it as a bean, so we should offer an option to register such client-side handlers directly with `RSocketRequester.Builder`, which would internally create the `RSocketMessageHandler` and configure it as an acceptor in the `RSocketFactory`.  In the Javadoc we should make it clear that registering handlers is a shortcut for creating an `RSocketMessageHandler` and configuring it as an acceptor. That latter still remains an option for more advanced cases and that should be made clear.","closed","type: enhancement,","rstoyanchev","2019-06-21T05:12:52Z","2019-07-17T10:24:45Z"
"","23469","Use enum instance instead of instantiating AutowiredArgumentMarker","Currently AutowiredArgumentMarker is instantiated for each autowired argument in ConstructorResolver. This can be avoided with use of `enum`.","closed","type: task,","stsypanov","2019-08-16T10:18:55Z","2019-08-27T08:01:26Z"
"","22818","Add getRoot() to MergedAnnotation","Currently `MergedAnnotation` has a `getParent()` method but I think it would also be useful to add a `getRoot()` method as well. Using the API, I've quite often wanted to show details of the actual user annotation and not the meta-annotation.","closed","type: enhancement,","philwebb","2019-04-18T17:46:07Z","2019-05-12T14:38:44Z"
"","22885","Eliminate java.lang annotations from `AnnotatedTypeMetadata`","Currently `AnnotatedTypeMetadata` has some fairly inconsistent rules around `java.lang` annotations.   With `StandardAnnotationMetadata` for example `hasAnnotation` will support `java.lang` annotations, where as `isAnnotated` delegates `AnnotatedElementUtils` which will filter them.  The ASM `AnnotationMetadataReadingVisitor` class provides parity by using `AnnotationUtils.isInJavaLangAnnotationPackage(annotationName)` for `isAnnotated`.  Some work on removing the overhead of `java.lang` processing was implemented in #17580 but I think we can go further and simply always filter java.lang annotations. Doing this will also help simplify the implementation for #22884","closed","in: core,","philwebb","2019-05-04T01:15:29Z","2019-05-07T21:13:47Z"
"","22908","Add MergedAnnotation.getTypeHierarchy method","Currently `AnnotatedElementUtils` has a private `parentAndType` method that we use in `getAllAnnotationAttributes`. We're going to need a similar method for #22884 so it makes sense to make this a first class citizen of `MergedAnnotation`. We can probably also then cache the result in the `AnnotationTypeMapping` class.","closed","type: enhancement,","philwebb","2019-05-06T20:37:31Z","2019-05-07T21:13:47Z"
"","22960","AbstractBeanDefinition.getBeanClass() javadoc misleads about returning null","Current javadoc says:  ```java /**      * Return the class of the wrapped bean, if already resolved.      * @return the bean class, or {@code null} if none defined      * @throws IllegalStateException if the bean definition does not define a bean class,      * or a specified bean class name has not been resolved into an actual Class      */ ```  The `@return`  and `@throws` are contradictory as this method can not return null due to   ```java if (beanClassObject == null) { 			throw new IllegalStateException(""No bean class specified on bean definition""); } ```","closed","in: core,","olegz","2019-05-13T14:52:47Z","2019-05-13T16:18:11Z"
"","23649","Fix RSocketRequester API for requests without payload","Current `RSocketRequester` makes it mandatory to use `RequestSpec#data` methods in order to reach `ResponseSpec` methods that allow to perform the exchange. This `RequestSpec` / `ResponseSpec` split seems unnecessary since  all `ResponseSpec` methods can be invoked directly for request without payload, which seems to be a perfectly valid use case.  This leads to code like `req.route(""find.radar.{iata}"", iata).data(Mono.empty()).retrieveMono(AirportLocation.class))`, and the issue is even more impacting in Coroutines world since `data()` does not accept `null`.  After discussion with @bclozel, our proposal is to merge `RequestSpec` and `ResponseSpec` in order to avoid this issue. Another hint that they should probably be merged is that `ResponseSpec` methods have side effects on the request itself.  About the name, maybe we could just use `RequestSpec`,  move `ResponseSpec` methods in it and remove `ResponseSpec`.","closed","type: enhancement,","sdeleuze","2019-09-17T15:50:36Z","2019-09-18T14:03:29Z"
"","22848","Could not refresh JMS Connection for destination","Could not refresh JMS Connection for destination 'queue://Consumer.tag.VirtualTopic.order.pay' - retrying using FixedBackOff{interval=5000, currentAttempts=0, maxAttempts=unlimited}. Cause: Error while attempting to add new Connection to the pool","open","status: feedback-provided,","xiangyang-gao","2019-04-28T07:18:09Z","2021-11-10T11:41:08Z"
"","22993","Update webflux.adoc","Correction of example with `@RequestBody` and `BindingResult` which dosn't work. Added Example with WebExchangeBindException.class Exception Handler.","closed","status: superseded,","flezsoftware","2019-05-19T00:41:14Z","2019-05-22T12:54:35Z"
"","23087","Refine Coroutines adapter registration activation","Coroutines adapter should be registered only when Reactor is available, otherwise it can trigger error when using Spring MVC with Coroutines in the classpath. This issue is a refinement of #19975.","closed","type: enhancement,","sdeleuze","2019-06-05T09:35:41Z","2019-06-05T10:00:59Z"
"","22813","Ensure flush after StreamingResponseBody","Consider this simple controller:  ```java @RestController @RequestMapping(""/api"") public class DemoController {     @GetMapping(""/demo"")     public StreamingResponseBody demo(@RequestParam(required = false) Boolean flush) {         String str = ""This is the response"";          return os -> {             IOUtils.copy(new ByteArrayInputStream(str.getBytes()), os);             if (flush)                 os.flush();         };     } } ```  When called with the `flush=true` argument we get the expected response: ```sh $ curl  -vv http://localhost:8080/api/demo?flush=true ``` ``` *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /api/demo?flush=true HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.63.0 > Accept: */* > < HTTP/1.1 200 < Transfer-Encoding: chunked < Date: Wed, 17 Apr 2019 13:18:26 GMT < This is the response* Connection #0 to host localhost left intact ```  However, when called without, we get a 500: ```sh $ curl  -vv http://localhost:8080/api/demo ``` ``` *   Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /api/demo HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.63.0 > Accept: */* > < HTTP/1.1 500 < Content-Type: application/json;charset=UTF-8 < Transfer-Encoding: chunked < Date: Wed, 17 Apr 2019 13:20:07 GMT < Connection: close < {""timestamp"":1555507207121,""status"":500,""error"":""Internal Server Error"",""message"":""No message available"",""path"":""/api/demo""}* Closing connection 0 ```  **Affected version:** Spring Boot 2.2.0.M2","closed","type: enhancement,","jru","2019-04-17T13:28:05Z","2020-06-17T20:50:37Z"
"","22946","Consider renaming MergedAnnotation.getParent()","Consider renaming `MergedAnnotation.getParent()` in order to avoid confusion regarding the top-down hierarchical nature of annotation declarations and reversed parent/child relationships.   See discussions in  #22818.","closed","in: core,","sbrannen","2019-05-12T14:38:05Z","2019-05-27T09:07:45Z"
"","23137","Correct encoding and decoding of ""message/x.rsocket.routing.v0""","Composite metadata is now supported as of M3 (see #22798) with the String route added as a `""message/x.rsocket.routing.v0""` entry in the composite metadata, plus the option to add more metadata entries. The route is still encoded as a simple String. That needs to be changed when rsocket-core provides an API for that.","closed","type: enhancement,","rstoyanchev","2019-06-13T21:23:54Z","2019-09-03T01:35:15Z"
"","23022","Migrate tests to AssertJ","Commits d7320de871dba75e0bbc4f5307d37005c3198379 and 02850f357f29f3dabe64750a3ab9405a94501b3a for #22894 have already started the process of migrating exception checking tests to AssertJ but there's a lot of benefit in migrating all remaining assertions as well. Tests will be easier to read if they all use the same assertion style, and a wholesale migration to JUnit 5 will be much easier.","closed","type: task,","philwebb","2019-05-23T22:46:43Z","2019-05-26T16:36:15Z"
"","23776","ResponseCookie should ignore leading dot in domain","Commit 17c423f added RFC6265 validation when building a new ResponseCookie, but the validation seems too ""strict"" for the domain attribute-value.  The RFC says : (https://tools.ietf.org/html/rfc6265#section-5.2.3):   > > 5.2.3.  The Domain Attribute > [...] > If the first character of the attribute-value string is %x2E ("".""): >  >       Let cookie-domain be the attribute-value without the leading %x2E >       (""."") character. >  >    Otherwise: >  >       Let cookie-domain be the entire attribute-value. >   And  > 4.1.2.3.  The Domain Attribute > >   The Domain attribute specifies those hosts to which the cookie will >   be sent.  For example, if the value of the Domain attribute is >   ""example.com"", the user agent will include the cookie in the Cookie >   header when making HTTP requests to example.com, www.example.com, and >   www.corp.example.com.  (**Note that a leading %x2E ("".""), if present, >   is ignored even though that character is not permitted**, but a >   trailing %x2E ("".""), if present, will cause the user agent to ignore >   the attribute.)  If the server omits the Domain attribute, the user  >  agent will return the cookie only to the origin server.  The current implementation of the `Rfc6265Utils validateDomain` method throws an IllegalArgumentException if the domain attribute-value starts with a . (dot)     If I understand well, the expected behavior should ignore/remove the leading dot instead of throwing an exception. Am I right ?","closed","in: web,","fredhdroz","2019-10-10T17:17:09Z","2019-11-14T13:27:00Z"
"","23731","how to getbean in a static method","code：  ```java @Component public final class SpringUtils implements ApplicationContextAware {      @Getter     private static ApplicationContext applicationContext;      @Override     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {         if (SpringUtils.applicationContext == null) {             SpringUtils.applicationContext = applicationContext;         }     }      public static  T getBean(Class clazz) {         return SpringUtils.applicationContext.getBean(clazz);     }      public static Object getBean(String className) {         return SpringUtils.applicationContext.getBean(className);     } } ```  how can i avoid updating a static field from a non-static method？","closed","for: stackoverflow,","fizzxue","2019-09-30T16:13:09Z","2019-10-01T09:42:41Z"
"","23737","Code improvement in `for` statement to use lambda expression","Code improvement in `for` statement to use lambda expression.","closed","status: declined,","ze12augusto","2019-10-01T11:11:28Z","2019-10-01T12:49:07Z"
"","23136","org.springframework.http.HttpStatus 5.1.x does not support Cloudflare responses.","Cloudflare servers use extended HTTP response codes. See [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) and scroll down for Cloudflare codes.  On receiving 520, `HttpStatus.valueOf(HttpStatus.java:527)` returns `IllegalArgumentException: No matching constant for [520]`  I am using version 5.1.5, but I also see the codes missing on 5.1.7's [API](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html)","closed","type: enhancement,","lafual","2019-06-13T16:54:46Z","2019-06-14T10:32:13Z"
"","23764","Switch default to UTF-8 in RestClientResponseException","closes https://github.com/spring-projects/spring-framework/issues/23738","closed","type: task,","ask4gilles","2019-10-07T06:47:33Z","2019-10-23T16:33:56Z"
"","23195","Handle absolute path on Windows in PathEditor","Closes https://github.com/spring-projects/spring-framework/issues/22511","open","in: core,","Antoniossss","2019-06-25T16:02:21Z","2021-04-27T05:06:10Z"
"","23676","Reinitialize SQLErrorCodeSQLExceptionTranslator when initial JDBC connection retrieval failed","closes gh-23675","open","type: enhancement,","samratdhillon","2019-09-23T02:03:54Z","2021-12-21T08:10:37Z"
"","23408","Add a warning to AnnotationReadingVisitorUtils","Closes gh-23406","closed","status: superseded,","mwiacek","2019-08-02T17:46:48Z","2019-08-06T16:02:01Z"
"","23052","Document @Value support in the reference manual","Closes gh-12255","closed","in: core,","slem1","2019-05-29T08:19:19Z","2019-06-12T07:31:43Z"
"","23582","Add support for X-Forwarded-For and Forwarded for","Closes #23260","closed","type: enhancement,","molassar","2019-09-04T08:43:29Z","2020-11-12T15:19:19Z"
"","23715","Add custom TriggerContext to ReschedulingRunnable","Changes based on:  Allow ReschedulingRunnable to receive a TriggerContext on creation #19475  I needed a way to resume work after a downtime - lets say I need to do daily reports based on what happened during that day. It doesn't matter if the report is delayed as long as it will be there when the system goes back online. With changes, you can easily handle this situation by finding last report date and creating triggerContext based on that time AND passing CronTrigger with argument fixedRate set to true.  It takes away burden of having to manually sync up on startup with custom logic (apart from finding last date), it prevents cases where you have rows with date 10.05, 11.05 and then 14.05, because new Cron fired task for day 14.05 but your catchup logic didn't finish yet the days between 11.05 and 14.05 (unless you write logic to handle ""holes"" between dates).  Example:  ``` final String cron = ""0/10 * * ? * *""; final CronTrigger cronTrigger = new CronTrigger(cron, true);  // quickly revert time by 1 minute for demonstration purposes Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.MINUTE, calendar.get(Calendar.MINUTE) - 1); SimpleTriggerContext simpleTriggerContext = new SimpleTriggerContext(calendar.getTime(), calendar.getTime(), calendar.getTime());  // quickly prepare task for demonstration purposes Thread task = new Thread(() -> {     logger.debug(""executed scheduled for {} with scheduled time {}"", cron, cronTrigger.nextExecutionTime(simpleTriggerContext)); }); taskScheduler.schedule(task, cronTrigger, simpleTriggerContext)); ```  The output for printing execution times will be:  ``` 2019-09-25 14:06:52.903 DEBUG 15336 --- [           main] project.scheduler.SchedulerService         : Scheduling test cron 0/10 * * ? * * 2019-09-25 14:06:52.905 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:06:00 UTC 2019 2019-09-25 14:06:52.906 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:06:10 UTC 2019 2019-09-25 14:06:52.906 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:06:20 UTC 2019 2019-09-25 14:06:52.906 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:06:30 UTC 2019 2019-09-25 14:06:52.906 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:06:40 UTC 2019 2019-09-25 14:06:52.906 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:06:50 UTC 2019 2019-09-25 14:07:00.001 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:07:00 UTC 2019 2019-09-25 14:07:10.002 DEBUG 15336 --- [taskScheduler-1] project.scheduler.SchedulerService         : executed scheduled for 0/10 * * ? * * with scheduled time Wed Sep 25 12:07:10 UTC 2019 ```  Our cron fired 6 times on startup - TriggerContext set to 60 seconds before ""now"" and CronTrigger set to fire every 10 seconds. After ""catching up"" scheduler will work and do it's job like a normal scheduled would do, apart from taking scheduled time when calculating next execution time instead of completion time, which is especially important in cases where you hit huge load and can't keep up with generating lets say these reports but once the load goes down, the reports will be processed and generated.  ### As for code:  I didn't write any tests. I'm not sure if changes didn't break some tests due to small edits in one or two interfaces (I tried to find all usages but I could miss some). I couldn't properly build project from source without excluding some tasks (-x test -x javadoc -x asciidoctor -x docsZip -x schemaZip -x distZip -x publishMavenJavaPublicationToMavenLocal). I tried to match the original code and style as closely as possible, I also provided some basic documentation for new things based on similar parts in classes. I needed this functionality and thought that making changes directly in Spring was the best way instead of writing custom logic, when most of it is already a part of framework. Adjust the code and add tests based on your preferences or needs.","open","in: core,","MaciejGorczyca","2019-09-26T06:02:41Z","2021-11-10T12:03:12Z"
"","23066","Allow alternative JdbcOperations implementations","Change various JDBC abstraction classes to allow them to work with JdbcOperations instead of JdbcTemplate. This allows the usage of custom JdbcOperations that for example perform additional logging.  The following classes have been updated  - AbstractJdbcCall - SimpleJdbcCall - AbstractJdbcInsert - SimpleJdbcInsert - JdbcBeanDefinitionReader - RdbmsOperation - StoredProcedure  This is a backwards compatible change. All existing JdbcTemplate methods are kept.  Closes gh-23065","open","type: enhancement,","marschall","2019-05-30T20:38:32Z","2021-04-27T05:06:10Z"
"","22891","Polish CONTRIBUTING.md","Change ""72 lines for the description"" to "" 72-character lines for the description"" Fixes #22890","closed","type: documentation,","rewolf","2019-05-05T02:56:09Z","2019-05-05T07:40:10Z"
"","23453","Upgrade to CGLIB 3.3","CGLIB 3.3 emits Java 1.8+ bytecode so that it can call static interface methods from a fastclass.","closed","type: dependency-upgrade,","jhoeller","2019-08-12T16:38:30Z","2019-08-12T17:37:20Z"
"","22992","Cannot enhance @Configuration bean definition","Cannot enhance @Configuration bean definition if its singleton instance has been created too early. Add the corresponding testcase. Fix #22990.","open","in: core,","lgxbslgx","2019-05-18T14:58:54Z","2021-04-27T05:06:10Z"
"","23304","No means to synchronize when cancelling a TransactionalOperator Subscription (Publisher)","Canceling a `Subscription` (in reactive transactions) leads to a state where transaction cleanup happens asynchronously and detached from completion signals. Consider the following code:  ```java TransactionalOperator transactionalOperator = …; DatabaseClient databaseClient = …; JdbcTemplate jdbcTemplate = …;  Flux integerFlux = transactionalOperator.execute(status -> { 	return databaseClient 		.execute(""INSERT INTO legoset (idl) VALUES(42055)"").fetch().rowsUpdated(); });  Mono next = integerFlux.next();  next.as(StepVerifier::create).expectNext(1).verifyComplete();  assertThat(jdbcTemplate.queryForMap(""SELECT id, name, manual FROM legoset"")).hasEntrySatisfying(""id"",42055); ```  Initially, the table is empty and both, `DatabaseClient` and `JdbcTemplate` are configured to point to the same database.  The assertion with `queryForMap` typically fails with `EmptyResultDataAccessException`. This is, because calling `integerFlux.next()` cancels the upstream subscription while emitting completion as soon as an element was emitted.   `TransactionalOperator` and its backing `ReactiveTransactionManager` implementations issue a commit to clean up the transaction that happens asynchronously, without an ability to await commit completion.  Not sure whether we can fix the problem at all or whether we can mitigate it. One approach could be with `TransactionalOperator.transactional(Mono)` to cancel the innermost `Publisher` and hand out a `Mono`. This change would return a properly bounded `Mono` and cancellation would happen on the innermost `Publisher` and preventing cancellation of the `Publisher` that is returned from `TransactionalOperator`.  This ticket is an opportunity to discuss that effect and its potential impact on cancellation of `Publishers` which are enhanced for transactions.  /cc @smaldini @simonbasle","closed","in: data,","mp911de","2019-07-17T10:16:01Z","2021-01-08T13:09:09Z"
"","22838","Public key or cert from Client auth","Can I get the client's cert or the client's public key from HttpSecurity? I use custom cert and I need the public key for authentication and not the subject principal. If it not possible, how can I implement custom function to get security information from http header for rest security. Does exist any tutorial/doc?","closed","for: stackoverflow,","readonlynetwork","2019-04-25T11:50:46Z","2019-04-29T05:30:02Z"
"","23620","Enable parallel builds by default","Building in parallel is now recommended by the Gradle team so this pull request enables it by default. On my MacBook Pro it reduces build time by roughly 50%. Machines with greater or fewer cores may see a greater or lesser reduction in build time. There may also be improvements that can be made to the build to improve its parallelisation. We can hopefully identify these in the future once we've got a number of parallel builds to examine.","closed","type: task,","wilkinsona","2019-09-11T09:25:13Z","2019-09-12T14:07:45Z"
"","23734","bug  WebClient Header cannot upadte in org.springframework.http.codec.HttpMessageWriter","bug  WebClient Header cannot upadte in org.springframework.http.codec.HttpMessageWriter. org.springframework.web.reactive.function.client.DefaultClientRequestBuilder.BodyInserterRequest 's HttpHeaders cannot readOnly, developer need add HttpHeader in org.springframework.http.codec.HttpMessageWriter,eg: add a HttpHeader xxx-bodyOfSignature","closed","status: superseded,","qinarmy-zoro","2019-09-30T19:13:55Z","2019-10-01T10:13:37Z"
"","23529","Add support for transaction by method + lambda","Besides `@Transactional` annotation, add support for transaction by method + lambda.   ```java connection.transaction(lambda) ```  or in Kotlin  ```kotlin connection.transaction { } ```  Examples - https://www.jooq.org/doc/3.11/manual/sql-execution/transaction-management/ - https://www.playframework.com/documentation/2.5.x/JavaJPA#Running-transactions-decoupled-from-requests - https://github.com/JetBrains/Exposed/wiki/Transactions - Another example is `use` extension method from Kotlin: https://github.com/Kotlin/kotlinx.support/blob/master/kotlinx-support-jdk7/src/main/kotlin/AutoCloseable.kt#L13  In this case we can write 2 separate transaction in one method, and no need to make 2 separate methods just for adding `@Transactional`. Also no need for annotation processing.","closed","in: core,","raderio","2019-08-27T18:01:52Z","2019-08-28T12:04:55Z"
"","22936","Fix EncoderHttpMessageWriter.isStreamingMediaType()","Before [this commit](https://github.com/spring-projects/spring-framework/commit/59fdce111675ba22960333ac33e9eff372956807) the behavior of `EncoderHttpMessageWriter.isStreamingMediaType()` was incorrect due to a bogus parameter comparison (entry compared with key). Additional refinements are also needed to validate the parameter values.","closed","type: bug,","sdeleuze","2019-05-09T12:53:33Z","2019-05-09T13:05:32Z"
"","23753","Simplify some code","because of the default method of java8, it doesn't seem to be necessary.","closed","","liaozan","2019-10-02T19:39:31Z","2022-02-18T19:07:12Z"
"","23509","NullPointerException when customize RequestMappingHandlerMapping and enable Aspectj","Because of some reason, I need create `RequestMappingHandlerMapping` (using anonymous inner class instead here, need override some method(s)) myself, and need using AspectJ, when my defined `RequestMappingHandlerMapping` intercepted by AOP, my defined `RequestMappingHandlerMapping` will throw `NullPointerException` when `getHandler` called, you can re-create this issue using below code (create any RESTful Controller for testing) I checked, it because logger is null, but it works fine if I remove Aspect code.  ```  line 416:	if (logger.isTraceEnabled()) { 			logger.trace(""Mapped to "" + handler); 		} ```  **error details:** > Caused by: java.lang.NullPointerException: null > 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:416) ~[spring-webmvc-5.1.7.RELEASE.jar:5.1.7.RELEASE] > 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1232) ~[spring-webmvc-5.1.7.RELEASE.jar:5.1.7.RELEASE] > 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1015) ~[spring-webmvc-5.1.7.RELEASE.jar:5.1.7.RELEASE] > 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.7.RELEASE.jar:5.1.7.RELEASE] > 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.7.RELEASE.jar:5.1.7.RELEASE] > 	... 26 common frames omitted >  >   depends and codes below: ``` Spring boot version and dependencies: springBootVersion = '2.1.5.RELEASE' dependencies {      compile 'org.springframework.boot:spring-boot-starter-web'     compile 'org.springframework.boot:spring-boot-starter-aop'     compile 'org.apache.tomcat.embed:tomcat-embed-jasper'     compile 'javax.servlet:jstl'     compile 'com.google.guava:guava:23.0'          testCompile 'org.springframework.boot:spring-boot-starter-test'  } ``` **java codes:** ```java package com.mdx.myboot.web.config; @Configuration public class MyWebMVCConfiguration extends WebMvcConfigurationSupport {       @Override     protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {         return new RequestMappingHandlerMapping() {             @Override             public void afterPropertiesSet() {                 super.afterPropertiesSet();             }         };     } }  ``` ```java package com.mdx.myboot.config;  @Component @Aspect public class MyAspect {       @Pointcut(""execution(* com.mdx..*.*(..))"")     public void loggingPointCut() {     }      @Around(""loggingPointCut()"")     public Object logging(ProceedingJoinPoint joinPoint) throws Throwable {         System.err.println(""executing "" + joinPoint.getSignature());         return joinPoint.proceed();     } }  ```","closed","status: invalid,","mdxShrimp","2019-08-23T11:24:38Z","2020-01-07T10:40:36Z"
"","23754","Ensure pre-flight request does not return error code 401","Based on issue: https://github.com/spring-projects/spring-framework/issues/23752  Provides a test, which shows exactly in what conditions does the issue arises and provides a fix to that issue.","closed","status: invalid,","rolaca11","2019-10-02T20:21:48Z","2019-11-11T10:35:43Z"
"","23460","ConcurrentModificationException in MockHttpServletResponse","Based on https://github.com/spring-projects/spring-security/issues/7224#issuecomment-520936156  by @rwinch:  > There appears to be an issue with MockMvc not allowing multiple Threads to operate on the headers at the same time. It happens in Spring Security because the `HeaderWriterFilter` will attempt to write the headers [when it completes](https://github.com/spring-projects/spring-security/blob/5.1.6.RELEASE/web/src/main/java/org/springframework/security/web/header/HeaderWriterFilter.java#L77) and just before the [response is committed](https://github.com/spring-projects/spring-security/blob/5.1.6.RELEASE/web/src/main/java/org/springframework/security/web/header/HeaderWriterFilter.java#L100). > > I [pushed a branch named nosecurity](https://github.com/rwinch/SPSS-7224/tree/nosecurity) that reproduces the issue without Spring Security being used to demonstrate the issue is in MockMvc rather than Spring Security.","closed","type: bug,","mmyersDE","2019-08-14T07:47:16Z","2019-09-02T11:51:04Z"
"","23804","Use getAvailableExtensionNames from JettyWebServerFactory","Backport of gh-23799","closed","status: duplicate,","spring-projects-issues","2019-10-15T14:51:33Z","2019-11-07T10:09:10Z"
"","23808","Allow setting primary flag on BeanDefinitionBuilder","Backport of gh-23794","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:38Z","2019-10-30T10:20:24Z"
"","23806","Apply debug logging for WebSocket lifecycle in WebSocketStompClient","Backport of gh-23793","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:34Z","2019-10-30T12:35:15Z"
"","23805","Improve response message on DecodingException","Backport of gh-23781","closed","for: external-project,","spring-projects-issues","2019-10-15T14:51:33Z","2019-10-30T12:01:02Z"
"","23809","Polish HttpWebHandlerAdapter.handleUnresolvedError()","Backport of gh-23780","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:38Z","2019-10-30T09:55:57Z"
"","23802","fix mistakes in websocket.adoc","Backport of gh-23777","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:33Z","2019-10-30T09:56:58Z"
"","23807","ResponseCookie should ignore leading dot in domain","Backport of gh-23776","closed","status: declined,","spring-projects-issues","2019-10-15T14:51:38Z","2019-10-17T11:03:40Z"
"","23801","Optimize Connection.setReadOnly(false) in DataSourceUtils.resetConnectionAfterTransaction(…)","Backport of gh-23747","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:32Z","2019-10-29T17:13:15Z"
"","23800","Handling of ResponseStatusException to also include setting of response headers","Backport of gh-23741","closed","type: backport,","spring-projects-issues","2019-10-15T14:51:32Z","2019-10-30T12:35:14Z"
"","23711","Bean definition override leads to NPE due to inconsistent equality check","Backport of gh-23593","closed","type: backport,","spring-projects-issues","2019-09-25T19:08:38Z","2019-10-30T10:09:58Z"
"","23709","Bean definition override leads to NPE due to inconsistent equality check","Backport of gh-23593","closed","type: backport,","spring-projects-issues","2019-09-25T18:40:24Z","2019-10-30T10:09:24Z"
"","23710","Fix DefaultListableBeanFactory#copyConfigurationFrom","Backport of gh-23569","closed","type: backport,","spring-projects-issues","2019-09-25T19:08:18Z","2019-10-30T10:10:03Z"
"","23708","Fix DefaultListableBeanFactory#copyConfigurationFrom","Backport of gh-23569","closed","type: backport,","spring-projects-issues","2019-09-25T18:40:02Z","2019-10-30T10:09:30Z"
"","23799","Use getAvailableExtensionNames from JettyWebServerFactory","Backport of gh-23565","closed","type: backport,","spring-projects-issues","2019-10-15T14:45:47Z","2019-11-07T10:13:06Z"
"","23707","Synchronized blocks in MethodOverrides are hurting concurrency","Backport of gh-23448","closed","type: backport,","spring-projects-issues","2019-09-25T18:38:59Z","2019-10-30T10:09:36Z"
"","23387","MethodParameter.equals is too coarse-grained for its use in HandlerMethodArgumentResolverComposite","Backport of gh-23352","closed","type: backport,","spring-projects-issues","2019-07-30T15:41:15Z","2019-08-01T12:44:16Z"
"","23386","MethodParameter.equals is too coarse-grained for its use in HandlerMethodArgumentResolverComposite","Backport of gh-23352","closed","type: backport,","spring-projects-issues","2019-07-30T15:41:04Z","2019-08-01T12:39:14Z"
"","23399","Javadoc missing on some public BeanDefinitionParserDelegate methods","Backport of gh-23349","closed","type: backport,","spring-projects-issues","2019-08-01T13:33:16Z","2019-08-01T19:33:39Z"
"","23398","Javadoc missing on some public BeanDefinitionParserDelegate methods","Backport of gh-23349","closed","type: backport,","spring-projects-issues","2019-08-01T13:33:09Z","2019-08-01T19:33:23Z"
"","23397","Session.close() accidentally triggers creation of TransactionAwareDataSourceProxy Connection","Backport of gh-23346","closed","type: backport,","spring-projects-issues","2019-08-01T13:32:33Z","2019-08-01T19:33:34Z"
"","23396","Session.close() accidentally triggers creation of TransactionAwareDataSourceProxy Connection","Backport of gh-23346","closed","type: backport,","spring-projects-issues","2019-08-01T13:32:25Z","2019-08-01T19:33:17Z"
"","23334","Inconsistent javadoc: implementation of ServerHttpRequest.Builder (implementation is DefaultServerHttpRequestBuilder) does not override headers","Backport of gh-23333","closed","type: backport,","spring-projects-issues","2019-07-23T09:28:25Z","2019-07-23T11:43:21Z"
"","23322","ResolvableType.forRawClass fails isAssignable against TypeVariable","Backport of gh-23321","closed","type: backport,","spring-projects-issues","2019-07-20T07:50:03Z","2019-07-20T15:35:32Z"
"","23309","Improve documentation for @Autowired constructors","Backport of gh-23263","closed","type: backport,","spring-projects-issues","2019-07-17T16:53:03Z","2019-07-18T09:57:15Z"
"","23308","Improve documentation for @Autowired constructors","Backport of gh-23263","closed","type: backport,","spring-projects-issues","2019-07-17T16:52:51Z","2019-07-18T09:57:11Z"
"","23246","FlashMapManager throws StringIndexOutOfBoundsException for empty target URL path","Backport of gh-23240","closed","type: backport,","spring-projects-issues","2019-07-07T14:46:32Z","2019-07-07T17:03:23Z"
"","23245","FlashMapManager throws StringIndexOutOfBoundsException for empty target URL path","Backport of gh-23240","closed","type: backport,","spring-projects-issues","2019-07-07T14:46:21Z","2019-07-07T16:52:38Z"
"","23174","Document that Ordered is not supported for @ControllerAdvice beans","Backport of gh-23172","closed","type: backport,","spring-projects-issues","2019-06-21T09:38:30Z","2019-06-21T09:53:38Z"
"","23173","Document that Ordered is not supported for @ControllerAdvice beans","Backport of gh-23172","closed","type: backport,","spring-projects-issues","2019-06-21T09:38:18Z","2019-06-21T09:53:41Z"
"","23118","Thread-safe removal of destruction callbacks in web scopes","Backport of gh-23117","closed","type: backport,","spring-projects-issues","2019-06-12T12:20:41Z","2019-07-16T08:05:43Z"
"","23085","Fix MockHttpServletRequest.setCookies to produce single Cookie header","Backport of gh-23074","closed","type: backport,","spring-projects-issues","2019-06-05T08:02:44Z","2019-06-06T14:30:51Z"
"","23080","Reintroduce author list and copyright notice","Backport of gh-23049","closed","type: backport,","spring-projects-issues","2019-06-04T08:56:40Z","2019-06-04T09:07:19Z"
"","23027","Fix ScriptUtils for MS Windows line ending","Backport of gh-23019","closed","type: backport,","spring-projects-issues","2019-05-24T09:39:21Z","2019-05-24T09:45:42Z"
"","23026","Fix ScriptUtils for MS Windows line ending","Backport of gh-23019","closed","type: backport,","spring-projects-issues","2019-05-24T09:38:56Z","2019-05-24T09:47:23Z"
"","23001","spring-mvc.xsd stale-if-error attribute documentation incorrect","Backport of gh-22983","closed","type: backport,","spring-projects-issues","2019-05-20T16:31:21Z","2019-05-20T22:06:58Z"
"","23000","spring-mvc.xsd stale-if-error attribute documentation incorrect","Backport of gh-22983","closed","type: backport,","spring-projects-issues","2019-05-20T16:31:10Z","2019-05-20T21:50:14Z"
"","22967","AbstractBeanDefinition.getBeanClass() javadoc misleads about returning null","Backport of gh-22960","closed","type: backport,","spring-projects-issues","2019-05-13T16:18:11Z","2019-05-20T22:18:15Z"
"","22966","AbstractBeanDefinition.getBeanClass() javadoc misleads about returning null","Backport of gh-22960","closed","type: backport,","spring-projects-issues","2019-05-13T16:17:57Z","2019-05-20T22:17:57Z"
"","22965","Avoid expensive assertions in web resource resolution","Backport of gh-22955","closed","type: backport,","spring-projects-issues","2019-05-13T16:14:35Z","2019-05-20T22:18:21Z"
"","22964","Avoid expensive assertions in web resource resolution","Backport of gh-22955","closed","type: backport,","spring-projects-issues","2019-05-13T16:14:15Z","2019-05-20T22:18:02Z"
"","22914","Consistent handling of empty List entries in LinkedMultiValueMap","Backport of gh-22912","closed","type: backport,","spring-projects-issues","2019-05-07T11:02:41Z","2019-05-07T12:02:52Z"
"","22913","Consistent handling of empty List entries in LinkedMultiValueMap","Backport of gh-22912","closed","type: backport,","spring-projects-issues","2019-05-07T11:02:33Z","2019-05-07T11:51:29Z"
"","22905","Introduce HTTPS mappings in spring.schemas files","Backport of gh-22903  ## Overview  Since some tools (e.g., older versions of STS, MyEclipse installations, etc.) physically read the contents of `spring.schemas` files to load XML schemas from the local classpath (instead of downloading them over the Internet), we should introduce HTTPS entries for all existing HTTP entries in all `/META-INF/spring.schemas` files.  ## Deliverables  Add HTTPS mappings to the `spring.schemas` files in the following artifacts.  - [x] spring-aop - [x] spring-beans - [x] spring-context - [x] spring-jdbc - [x] spring-jms - [x] spring-oxm - [x] spring-tx - [x] spring-webmvc - [x] spring-websocket","closed","type: backport,","spring-projects-issues","2019-05-06T15:41:08Z","2019-05-07T11:20:51Z"
"","22904","Introduce HTTPS mappings in spring.schemas files","Backport of gh-22903  ## Overview  Since some tools (e.g., older versions of STS, MyEclipse installations, etc.) physically read the contents of `spring.schemas` files to load XML schemas from the local classpath (instead of downloading them over the Internet), we should introduce HTTPS entries for all existing HTTP entries in all `/META-INF/spring.schemas` files.  ## Deliverables  Add HTTPS mappings to the `spring.schemas` files in the following artifacts.  - [x] spring-aop - [x] spring-beans - [x] spring-context - [x] spring-jdbc - [x] spring-jms - [x] spring-oxm - [x] spring-tx - [x] spring-webmvc - [x] spring-websocket","closed","type: backport,","spring-projects-issues","2019-05-06T15:40:53Z","2019-05-07T11:43:42Z"
"","22864","ResourceUrlEncodingFilter throws StringIndexOutOfBoundsException when %ED%B6 is in the URL path","Backport of gh-22851","closed","type: backport,","spring-projects-issues","2019-04-30T15:13:51Z","2019-05-02T15:49:49Z"
"","22863","ResourceUrlEncodingFilter throws StringIndexOutOfBoundsException when %ED%B6 is in the URL path","Backport of gh-22851","closed","type: backport,","spring-projects-issues","2019-04-30T15:13:49Z","2019-05-02T15:49:28Z"
"","22880","EL1072E when evaluating compiled comparison expression","Backport of gh-22358","closed","type: backport,","spring-projects-issues","2019-05-03T12:37:02Z","2019-05-03T14:12:40Z"
"","22879","EL1072E when evaluating compiled comparison expression","Backport of gh-22358","closed","type: backport,","spring-projects-issues","2019-05-03T12:36:54Z","2019-05-03T13:33:52Z"
"","23656","Defer creating LogAccessor","Avoid early log initialization, fix for https://github.com/spring-projects/spring-framework/issues/23655","closed","","quaff","2019-09-18T09:54:18Z","2022-02-18T19:07:12Z"
"","23359","Upgrade to RSocket 1.0.0-RC2","At the moment the upgrade is causing consistent JVM crashes in RSocket integration tests even though hardly anything has changed in this version since `0.12.2-RC4`. After playing around, upgrading `rsocket-core` to Reactor Dysprosium and using that instead, seems to make a difference. I've requested https://github.com/rsocket/rsocket-java/issues/670.","closed","type: dependency-upgrade,","rstoyanchev","2019-07-25T11:26:03Z","2019-08-01T19:17:03Z"
"","23789","Rollback transactions in case if Exception was thrown","At the moment a transaction is rollback only if it was thrown a `RuntimeException`.  In Kotlin there is no checked exceptions, so compiler to do not force to check when is was thrown an `Exception`. When some library from Java throw an `Exception`, in Kotlin methods with `@Transactional` annotation do not rollback.","closed","status: duplicate,","raderio","2019-10-13T10:06:42Z","2019-10-13T11:27:34Z"
"","23769","Preserve expires attribute in MockCookie","At present, `MockCookie` doesn't preserve expires attribute. This has a consequence that cookie value set using `MockHttpServletResponse#addHeader` containing expires attribute will not match the cookie value obtained from `MockHttpServletResponse#getHeader` since the expires will get calculated based on current time.  This is very simple to demonstrate using a test that's added to `MockHttpServletResponseTests` as a part of this PR:  ```java @Test void addCookieHeaderWithExpires() {     String cookieValue = ""SESSION=123; Path=/; Max-Age=100; Expires=Tue, 8 Oct 2019 19:50:00 GMT; Secure; "" +             ""HttpOnly; SameSite=Lax"";     response.addHeader(HttpHeaders.SET_COOKIE, cookieValue);     assertThat(response.getHeader(HttpHeaders.SET_COOKIE)).isEqualTo(cookieValue); } ```  This PR enhances `MockCookie` to preserve expires attribute.","closed","type: bug,","vpavic","2019-10-08T22:10:37Z","2019-10-29T13:44:20Z"
"","23124","Stop using `libs-*` repo in favour of consistent use of Maven Central","As we want to make sure we build and release against public artifacts available on Maven Central, let's stop using the `libs-*` repositories on repo.spring.io that are controlled by us and could potentially contain extra artifacts.","closed","type: task,","snicoll","2019-06-13T07:36:46Z","2019-09-19T11:28:49Z"
"","23294","Asynchronous initialization of Spring beans","As the most people's problems, we have come to the same confusion. Our project has about 1,000 beans, but the startup time has been close to 10 minutes. Every time we fix a bug and do an integrated deployment, it takes a long time to wait.  There are two Suggestions could be taken  into consideration.  1. On the basis of existing source code, the initialization of beans with `init method` or `afterPropetiesSet`  left to the thread pool, but the dependency safety must be ensured, such as `A->B`, but B is not initialized. We can give each Bean  a proxy, ensure `B` initialized  at first through the way of  intercepting the proxy's methods.  2. Static analysis of dependencies between beans  generates multiple graphs.  - Calculate Strongly Connected Component(SCC) of each Directed acyclic graph (DAG)  reference the Tarjan algorithm -  Each SCC subgraph as a specific node - Generate a parallel  execution schedule based on topological sort.  Issue Links: https://github.com/spring-projects/spring-framework/issues/13410 Parallel bean initialization during startup [SPR-8767] https://github.com/spring-projects/spring-framework/issues/19487 Asynchronous initialization of beans during startup [SPR-14920]","open","type: enhancement,","thorgits","2019-07-16T07:30:10Z","2020-08-24T16:57:27Z"
"","23295","Clarify use of MultipartBodyBuilder with RestTemplate","As seen in spring-projects/spring-boot#12579 and [as shown in the reference documentation](https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/spring-framework-reference/integration.html#rest-template-multipart), developers are using `MultipartBodyBuilder` with `RestTemplate` in a pure Spring MVC application. In that context, the reactive-streams dependency bringing `Publisher` is not on classpath by default.  It seems that the `MultipartBodyBuilder` implementation requires that class to be on classpath.  We should make that dependency optional or avoid documenting this option with `RestTemplate`.","closed","in: web,","bclozel","2019-07-16T07:36:41Z","2019-07-19T09:54:31Z"
"","23522","Remove explicit disabling of buffer recycling in non-blocking Jackson parsing","As pointed out in [this comment](https://github.com/FasterXML/jackson-core/issues/479#issuecomment-525143217), Jackson 2.10 will support buffer recycling for non-blocking parsing. Since it is disabled since Jackson 2.9.7, the purpose of this issue is to remove `JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING` explicit disabling and raise the minimum requirement to Jackson 2.9.7 for Spring Framework 5.2.","closed","type: task,","sdeleuze","2019-08-27T08:08:13Z","2019-08-28T16:49:29Z"
"","23465","Replacing netty-all with specific dependencies","As per @bclozel 's comment on the below:  > Spring Framework is sometimes depending on ""-all.jar"" variants for historical reasons, and doing so in an application or library is not advised. Arguably we should not do that in our build and this is something we should fix. But in the meantime this is incorrect/misleading information we're publishing  https://github.com/spring-projects/spring-framework/issues/23234#issuecomment-521153626  spring-framework/spring-web/src contains references to following netty packages covered by the artifacts:  - artifact netty-buffer   - io.netty.buffer - artifact netty-transport   - io.netty.channel   - io.netty.bootstrap   - io.netty.channel.nio - artifact netty-handler   - io.netty.handler.ssl   - io.netty.handler.ssl.util   - io.netty.handler.timeout - artifact netty-codec-http   - io.netty.handler.codec.http","closed","type: task,","suztomo","2019-08-15T15:27:36Z","2019-11-08T13:08:47Z"
"","23490","Remove statusCode state from ContentCachingResponseWrapper","As part of one of our services we have a `HandlerInterceptor` which has some logic dependant on the status code of the response. As such we've been using a [ContentCachingResponseWrapper](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/util/ContentCachingResponseWrapper.java) in order to gain access to the body of the response object dependant on if the response object's `status` is equal to certain values.  When our `ControllerAdvice` catches an exception the `status` of the resultant response is set, and the response is then intercepted by our `HandlerInterceptor` implementation.  Inside the `HandlerInterceptor` we wrap the response object with `ContentCachingResponseWrapper`, and at this point the `status` and `statusCode` do not match. I believe this is because the ctor for `ContollerAdvice` ultimately does not set `statusCode`, but defaults to `HttpServletResponse.SC_OK` instead, where I believe it should default to the status of the response being passed in.  Is there a reason why `statusCode` is separate to `status`? Or would it make sense moving forwards to use `setStatus` and `getStatus` and have `getStatusCode` just forward to `getStatus` to preserve backwards compatibility?","closed","type: enhancement,","lpickford-yozu","2019-08-20T14:07:11Z","2019-08-21T10:42:00Z"
"","23693","SameSite cookie attribute missing when using WebFlux","As of Spring Framework 5.1 the ""What’s New” wiki documentation states the following for Spring WebFlux (https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x#spring-webflux-1):  ""Session cookies now have SameSite=Lax to protect against CSRF attacks”  In practice this is not true when using any of the framework supplied HttpHandler adapters and no SameSite attribute is added to session cookies. This is dangerous as a user may read this note and assume that the SameSite attribute will be set to a value that will prevent CSRF on all modern browsers (https://caniuse.com/#feat=same-site-cookie-attribute) when using Spring WebFlux >= 5.1.  You can verify that the SameSite attribute is not being added to session cookies on WebFlux by default by creating a new Spring Boot WebFlux project on the Spring Initializr, creating a controller that sets an attribute on the session, and then making a HTTP request to this controller method and inspecting the returned session cookie.  The issue seems to be that internally the framework uses a [ResponseCookie](https://github.com/spring-projects/spring-framework/blob/098ac0bbb88cd178e85b7dc31642bed091560316/spring-web/src/main/java/org/springframework/http/ResponseCookie.java) that does set the SameSite attribute to “Lax"" by default. However, all of the ServerHttpResponse adapters for the various servers do not copy the SameSite attribute into the resulting cookie when calling their applyCookies() method:  ReactorServerHttpResponse - https://github.com/spring-projects/spring-framework/blob/27aaad5a892f6bec71316d2fec0871eb5c2b8435/spring-web/src/main/java/org/springframework/http/server/reactive/ReactorServerHttpResponse.java#L93-L111  UndertowServerHttpResponse  - https://github.com/spring-projects/spring-framework/blob/27aaad5a892f6bec71316d2fec0871eb5c2b8435/spring-web/src/main/java/org/springframework/http/server/reactive/UndertowServerHttpResponse.java#L103-L121  ServletServerHttpResponse - https://github.com/spring-projects/spring-framework/blob/7194261961cc190838a3a421e0a1d81837bf0253/spring-web/src/main/java/org/springframework/http/server/reactive/ServletServerHttpResponse.java#L144-L162  This may be somewhat problematic to fix using the existing logic that delegates to the server Cookie implementation as only Undertow currently has a method to set the SameSite attribute.  Also related to this issue is that in the near future Chrome will default cookies that do not have a SameSite attribute to “Lax” (https://www.chromestatus.com/feature/5088147346030592) which may break some applications if they have no ability to change the value of the SameSite attribute.","closed","type: bug,","essh","2019-09-24T21:20:19Z","2019-10-18T10:17:57Z"
"","23661","Use Reactor's new Schedulers.boundedElastic()","As of reactor/reactor-core#1804, Reactor core will provide a new Scheduler implementation, `Schedulers.boundedElastic()`.  This implementation, unlike `elastic` does not create an unbounded number of threads; it creates a bounded number of workers and will queue tasks if there are no worker available. This implementation is a direct replacement for the elastic one, as it limits the amount of resources.  Spring Framework is currently using alternate `Schedulers` in several places:  * a `Schedulers.elastic()` in `StandardWebSocketClient`, because the connection phase is blocking. We should improve there and use `boundedElastic()` instead. While this might not provide big runtime improvements, it's compatible with the existing choice and it should be beneficial to use this scheduler since it should be used  in most places * the `ReactorNettyTcpClient` is using a specific parallel scheduler; this use case seems valid and we should not change this","closed","type: enhancement,","bclozel","2019-09-18T14:03:27Z","2019-09-18T19:40:28Z"
"","23207","Defensively register ReactiveReturnValueHandler for messaging methods","As of our support for reactive return types from messaging handler methods in #21175, we register a `ReactiveReturnValueHandler` which has a reference to the `ReactiveAdapterRegistry` type, which in turn refers to `ReactiveAdapter` which has a hard reference to `org.reactivestreams.Publisher`. In order to avoid class resolution failures in certain JVM scenarios (in particular in debug mode), we should defensively register the `ReactiveReturnValueHandler` only when the Reactive Streams API is present on the classpath.","closed","type: bug,","jhoeller","2019-06-28T12:38:35Z","2019-07-05T16:23:48Z"
"","23503","Publish Gradle metadata","As of its 5.3 version, Gradle is able to [generate and consume Gradle-specific build metadata](https://blog.gradle.org/gradle-metadata-1.0). It's an opt-in feature for now, but it will be enabled by default with Gradle 6.0.  Should we produce and publish this metadata for our 5.2.0 release?  Here is the `module.json` file published for `spring-webflux`:  ```json {   ""formatVersion"": ""1.0"",   ""component"": {     ""group"": ""org.springframework"",     ""module"": ""spring-webflux"",     ""version"": ""5.2.0.BUILD-SNAPSHOT"",     ""attributes"": {       ""org.gradle.status"": ""integration""     }   },   ""createdBy"": {     ""gradle"": {       ""version"": ""5.6"",       ""buildId"": ""tnw2jjpho5a5jfyvqcxsiinl3u""     }   },   ""variants"": [     {       ""name"": ""apiElements"",       ""attributes"": {         ""org.gradle.category"": ""library"",         ""org.gradle.dependency.bundling"": ""external"",         ""org.gradle.jvm.version"": 8,         ""org.gradle.libraryelements"": ""jar"",         ""org.gradle.usage"": ""java-api"",         ""org.jetbrains.kotlin.localToProject"": ""public"",         ""org.jetbrains.kotlin.platform.type"": ""jvm""       },       ""dependencies"": [         {           ""group"": ""org.springframework"",           ""module"": ""spring-beans"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-core"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-web"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""io.projectreactor"",           ""module"": ""reactor-core"",           ""version"": {             ""requires"": ""3.3.0.M3""           }         }       ],       ""files"": [         {           ""name"": ""spring-webflux-5.2.0.BUILD-SNAPSHOT.jar"",           ""url"": ""spring-webflux-5.2.0.BUILD-SNAPSHOT.jar"",           ""size"": 812464,           ""sha1"": ""2ba63ce11e96bccd35154fdc683101bd3414bc56"",           ""md5"": ""7ed44177912810577066d4e262f8273d""         }       ]     },     {       ""name"": ""runtimeElements"",       ""attributes"": {         ""org.gradle.category"": ""library"",         ""org.gradle.dependency.bundling"": ""external"",         ""org.gradle.jvm.version"": 8,         ""org.gradle.libraryelements"": ""jar"",         ""org.gradle.usage"": ""java-runtime"",         ""org.jetbrains.kotlin.localToProject"": ""public"",         ""org.jetbrains.kotlin.platform.type"": ""jvm""       },       ""dependencies"": [         {           ""group"": ""org.springframework"",           ""module"": ""spring-beans"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-core"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-web"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""io.projectreactor"",           ""module"": ""reactor-core"",           ""version"": {             ""requires"": ""3.3.0.M3""           }         }       ],       ""files"": [         {           ""name"": ""spring-webflux-5.2.0.BUILD-SNAPSHOT.jar"",           ""url"": ""spring-webflux-5.2.0.BUILD-SNAPSHOT.jar"",           ""size"": 812464,           ""sha1"": ""2ba63ce11e96bccd35154fdc683101bd3414bc56"",           ""md5"": ""7ed44177912810577066d4e262f8273d""         }       ]     }   ] } ```  Here is the `module.json` file for our Java Platform (also exported as a Maven BOM): ```json {   ""formatVersion"": ""1.0"",   ""component"": {     ""group"": ""org.springframework"",     ""module"": ""spring-framework-bom"",     ""version"": ""5.2.0.BUILD-SNAPSHOT"",     ""attributes"": {       ""org.gradle.status"": ""integration""     }   },   ""createdBy"": {     ""gradle"": {       ""version"": ""5.6"",       ""buildId"": ""536e76sdo5cndbduo2qqzgbcja""     }   },   ""variants"": [     {       ""name"": ""apiElements"",       ""attributes"": {         ""org.gradle.category"": ""platform"",         ""org.gradle.usage"": ""java-api""       },       ""dependencyConstraints"": [         {           ""group"": ""org.springframework"",           ""module"": ""spring-aop"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-aspects"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-beans"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-context"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-context-indexer"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-context-support"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-core"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-expression"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-instrument"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-jcl"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-jdbc"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-jms"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-messaging"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-orm"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-oxm"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-test"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-tx"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-web"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-webflux"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-webmvc"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-websocket"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         }       ]     },     {       ""name"": ""runtimeElements"",       ""attributes"": {         ""org.gradle.category"": ""platform"",         ""org.gradle.usage"": ""java-runtime""       },       ""dependencyConstraints"": [         {           ""group"": ""org.springframework"",           ""module"": ""spring-aop"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-aspects"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-beans"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-context"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-context-indexer"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-context-support"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-core"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-expression"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-instrument"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-jcl"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-jdbc"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-jms"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-messaging"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-orm"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-oxm"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-test"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-tx"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-web"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-webflux"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-webmvc"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         },         {           ""group"": ""org.springframework"",           ""module"": ""spring-websocket"",           ""version"": {             ""requires"": ""5.2.0.BUILD-SNAPSHOT""           }         }       ]     }   ] } ```  Note that all the generated POMs are slightly changed with the following:  ```xml                    4.0.0   org.springframework   spring-framework-bom ```","closed","type: task,","bclozel","2019-08-22T16:58:42Z","2020-04-29T10:03:43Z"
"","22866","Support quality values for MVC `@RequestHeader`","As of 5.1.6, the `RequestHeaderMethodArgumentResolver` helpfully supports multi-valued headers including appropriate type conversion into a collection container. However, quality values are not supported and result in a `MethodArgumentTypeMismatchException` at request time. I request the ability to parse quality values for `@RequestHeader`.  Specifically, the use case that I am trying to support is rendering document templates on demand. Various templates may be available in various translations, and it is preferable to fall back to rendering, e.g., `en_US` instead of `es_MX` rather than fail entirely. However, the default locale resolution happens at the container level and presents a single preferred locale to the controller instead of a sequence of optional locales.  When not using quality values, this header is mapped into the controller as expected:  ``` Accept-Language: es_MX,en_US ```  Adding `;q=0.8`, however, results in an exception.   I understand that a change of this sort might collide with other uses of `@RequestHeader`, and propose that an annotation element such as `boolean useQualityValues default false` might make sense. When active, the handler should order multiple values according to weight.","closed","status: declined,","chrylis","2019-05-01T07:26:40Z","2019-05-17T19:01:30Z"
"","23038","WebFlux AbstractView does not allow null model values anymore","As of 172afb510a7e8e0daca10753fe965b0dfb53f6f7, the `AbstractView` implementation switched from a `LinkedHashMap` to a `ConcurrentHashMap` for storing model attributes. The latter does not allow `null` values and will throw a `NullPointerException` if the provided model has a `null` value associated with any key.  This is currently breaking the Spring Boot build as we're adding null values to the model in the error handling support.  Should we try and relax that requirement or just enforce it by filtering null values before copying them in the `attributes` map?","closed","type: bug,","bclozel","2019-05-27T11:46:38Z","2019-06-07T20:27:11Z"
"","23165","Leverage new Kotlin script templating support","As of 1.3.40, Kotlin now provides a kotlin-scripting-jsr223-embeddable dependency which:  - Fixes classloading related issues  - Provides out of the box JSR 223 support  - Is compatible with Spring Boot Fat Jar mechanism  Spring Framework tests and documentation should be updated accordingly.","closed","type: enhancement,","sdeleuze","2019-06-20T08:14:57Z","2019-06-20T08:29:41Z"
"","23168","PathPattern::extractPathWithinPattern does not use custom separator","As of #23092, PathPatternParser allows custom separators - but the `extractPathWithinPattern` implementation, when extracting the path within the pattern of a matched route (see `PathPattern::extractPathWithinPattern`), does not take into account the configured separator and only uses the default, `/`.","closed","type: bug,","bclozel","2019-06-20T17:21:21Z","2019-06-20T18:41:27Z"
"","23167","PathPatternRouteMatcher should parse routes with custom separator","As of #23092, `PathPatternParser` allows custom separators. `PathPatternRouteMatcher` accepts a `PathPatternParser` instance but does not use the configured separator when parsing routes from incoming requests.  This means that currently a Spring RSocket application configured with a `.` separator for pattern matching does not match correctly, since incoming routes are parsed with the `/` separator (which is the default).","closed","type: bug,","bclozel","2019-06-20T16:30:19Z","2019-06-20T18:41:27Z"
"","22937","CronTrigger support for overlapping executions","As mentioned in [SPR-10556](https://github.com/spring-projects/spring-framework/issues/15186), overlapping executions won't occur.  But in my project, I have a scheduled task which has to run every hour (with cron expression **0 20 * * * ?**) .In most case, it took 20 to 30 minutes. But sometimes, it took 2 to 3 hours due to force majeure. Though there is a way to solve it by submitting the task to a separate thread pool,  it would be better if spring-context support overlapping executions.  For now, I solve it by the following codes:  1. BaseOnLSETCronTrigger.java which copy from **org.springframework.scheduling.support.CronTrigger** but changed in ```java 	/** 	 * Determine the next execution time according to the given trigger context. 	 * Next execution times are calculated based on the 	 * {@linkplain TriggerContext#lastScheduledExecutionTime completion time} of the 	 * previous execution; therefore, overlapping executions will occur on purpose. 	 */ 	@Override 	public Date nextExecutionTime(TriggerContext triggerContext) { 		Date date = triggerContext.lastScheduledExecutionTime(); 		if (date == null) { 			date = new Date(); 		} 		return this.sequenceGenerator.next(date); 	} ```  2. ReschedulingImmediatelyRunnable.java copy from **org.springframework.scheduling.concurrent.ReschedulingRunnable** and changed in ```java         /** 	 * we firstly call schedule() and then call super.run() to keep 	 * tasks which take lots of time from delaying the schedule 	 */ 	@Override 	public void run() { 		Date actualExecutionTime = new Date();  		this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, null);  		if (!obtainCurrentFuture().isCancelled()) { 			schedule();//schedule first 		}  		super.run();//then run 		Date completionTime = new Date(); 		synchronized (this.triggerContextMonitor) { 			Assert.state(this.scheduledExecutionTime != null, ""No scheduled execution""); 			this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, completionTime);  		} 	} ```  3. To apply ReschedulingImmediatelyRunnable.java to spring-context, I copy ReshdeulingImmediatelyTaskScheduler.java from **org.springframework.scheduling.concurrent.ConcurrentTaskScheduler** and changed in ```java 	@Override 	@Nullable 	public ScheduledFuture schedule(Runnable task, Trigger trigger) { 		try { 			ErrorHandler errorHandler = 					(this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true)); 			return new ReschedulingImmediatelyRunnable(task, trigger, this.scheduledExecutor, errorHandler).schedule(); 		} catch (RejectedExecutionException ex) { 			throw new TaskRejectedException(""Executor ["" + this.scheduledExecutor + ""] did not accept task: "" + task, ex); 		} 	} ```  4. And finally ```java @EnableScheduling @Configuration public class ScheduleConfig implements SchedulingConfigurer {  	private static final Logger log = LoggerFactory.getLogger(ScheduleConfig.class);  	@Autowired 	private Scheduler scheduler;  	@Override 	public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {  		taskRegistrar.setScheduler(new ReshdeulingImmediatelyTaskScheduler(taskExecutor()));  		/** 		 * this task would took much time than expected, and it has to run every hour 		 */ 		taskRegistrar.addTriggerTask(() -> 				scheduler.syncPlayStatistics() 		, new BaseOnLSETCronTrigger(""0 20 * * * ? "")); 	} 	 	@Bean(destroyMethod = ""shutdown"") 	public ScheduledExecutorService taskExecutor() { 		ScheduledThreadPoolExecutor executorService = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4); 		log.info(""executorService:{}"", executorService); 		return executorService; 	} } ```","open","in: core,","dydeve","2019-05-09T18:32:41Z","2021-11-10T12:00:11Z"
"","22929","ServletContext atomic register of bean","As far as I can see the registering beans to `javax.servlet.ServletContext` is not atomic. Destruction callback registration has some thread-safe issues as it using not thread safe collection.","closed","type: enhancement,","lmagyar89","2019-05-08T21:33:47Z","2019-06-12T10:56:49Z"
"","23712","StackOverflow exception if Filter is registered for all DispatcherTypes","As discussed in the spring-boot gitter channel I have a spring-boot web application that uses JSPs, and has this bean defined: ```  @Bean(name = { ""defaultRequestContextFilterRegistration"", ""requestContextFilterRegistration"" })     public FilterRegistrationBean requestContextFilterRegistration(RequestContextFilter requestContextFilter) {         FilterRegistrationBean bean = new FilterRegistrationBean<>(requestContextFilter);         bean.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));         bean.setOrder(SessionRepositoryFilter.DEFAULT_ORDER + 1);         return bean;     } ```  now whenever there's an exception on the server side, the execution flow goes through the ErrorController and then a stack-overflow is produced: ``` Caused by: java.lang.StackOverflowError: null     at java.base/java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:936) ~[na:na]     at org.apache.catalina.connector.Request.getAttribute(Request.java:869) ~[tomcat-embed-core-9.0.24.jar:9.0.24]     at org.apache.catalina.connector.RequestFacade.getAttribute(RequestFacade.java:282) ~[tomcat-embed-core-9.0.24.jar:9.0.24]     at org.apache.catalina.core.ApplicationHttpRequest.getAttribute(ApplicationHttpRequest.java:245) ~[tomcat-embed-core-9.0.24.jar:9.0.24]     at org.apache.catalina.core.ApplicationHttpRequest.getAttribute(ApplicationHttpRequest.java:245) ~[tomcat-embed-core-9.0.24.jar:9.0.24]     at org.springframework.web.context.request.async.WebAsyncUtils.getAsyncManager(WebAsyncUtils.java:48) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.isAsyncDispatch(OncePerRequestFilter.java:147) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.skipDispatch(OncePerRequestFilter.java:128) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:99) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilterNestedErrorDispatch(OncePerRequestFilter.java:250) ~[spring-web-5.1.9.RELEASE.jar:5.1.9.RELEASE]     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.9.RELEASE.ja ``` works fine with Spring-boot 2.0.6 (5.1.8.RELEASE), fails with 2.0.7+ ( 5.1.9.RELEASE)  I found out that it is caused by this line:  ``` bean.setDispatcherTypes(EnumSet.allOf(DispatcherType.class)); ``` `RequestContextFilter` now overrides this method: ```     @Override     protected boolean shouldNotFilterErrorDispatch() {         return false;     } ``` and if mapped to `DispatcherType.ERROR` causes it to loop over-and-over again in the `OncePerRequestFilter`.  I have a demo-project generated from start.spring.io if you are interested","closed","status: duplicate,","ptahchiev","2019-09-25T20:06:16Z","2019-09-26T05:44:50Z"
"","23424","AnnotationAttributes#assertNotException should check for instance of Throwable","As discussed in https://github.com/spring-projects/spring-framework/pull/23408#issuecomment-518728668, `AnnotationAttributes#assertNotException(String, Object)` should actually check `if (attributeValue instanceof Throwable)` instead of `if (attributeValue instanceof Exception)`.","closed","in: core,","sbrannen","2019-08-06T15:52:58Z","2019-08-06T16:20:50Z"
"","23650","Fix transaction aspect's incorrect state after creating new context","As aspects are singletons, `transactionManagerCache` and `transactionManager` in `TransactionAspectSupport` are persistent. It's ok if context is not changing, but if new contexts gets created (in tests, for example), new transaction manager should be used.   I faced it using Spring Data with repository's `@Transactional` set to `MANDATORY`: 1. Service's `Transactional` method is called 2. Transaction is created in aspect 3. Transaction manager is put to cache 4. Transaction is used in `TransactionInterceptor` of SpringData repository 5. New context got created for another test 6. Service's `Transactional` method is called 7. Transaction is created in old transaction manager, that is cached inside aspect 8. `TransactionInterceptor` in SpringData repository fails to find transaction, because it uses different (new) transaction manager  I fixed it with clearing cache every time aspect's bean is created (and also remove a null check for `txManager parameter`, because if it's null, it should clear `txManager field` and also setter's parameter marked `Nullable`) and created tests for that.  I also had to change gradle settings for integration tests, because they were not processed by aspectj AND that fixed one strange test where aspects were not found in classpath.  To demonstrate the issue, I also created [this repository](https://github.com/SammyVimes/SpringDataAspectjFail), where the test which is run second always fails.","open","status: pending-design-work,","SammyVimes","2019-09-17T20:38:20Z","2021-04-27T05:06:11Z"
"","23660","BOM has explicit `compile` scope for each dependency","As a result, `spring-test` is put on the `compile` scope in any application that uses the BOM (and includes `spring-test` transitively).  See https://repo.spring.io/snapshot/org/springframework/spring-framework-bom/5.2.0.BUILD-SNAPSHOT/spring-framework-bom-5.2.0.BUILD-20190918.123055-142.pom","closed","type: regression,","snicoll","2019-09-18T12:48:30Z","2019-09-18T13:38:01Z"
"","22874","Avoid unguarded String concatenation for debug/trace logging","As a leftover from #21485, there is an issue in `CachingResourceTransformer` where it performs unguarded String concatenation for a trace log attempt. Along with an `isTraceEnabled()` guard at that position, several `isDebugEnabled()` checks are missing in less hotspot places as well.","closed","type: bug,","jhoeller","2019-05-02T22:09:46Z","2019-05-02T22:25:26Z"
"","23476","Introduce @EnabledForTestGroups in Spring's test suite","As a followup to gh-23451, we can improve the user experience and runtime behavior for our test group support by introducing an `@EnabledForTestGroups` backed by a JUnit Jupiter `ExecutionCondition`.","closed","type: task,","sbrannen","2019-08-17T12:21:07Z","2019-08-17T12:57:12Z"
"","23575","Support suspending functions annotated with @Transactional","As a follow-up of #22915, this issue is about supporting suspending functions annotated with `@Transactional`. It seems not straightforward to call `CoroutinesUtils.invokeHandlerMethod(method: Method, bean: Any, vararg args: Any?): Any?` from `TransactionAspectSupport.ReactiveTransactionSupport#invokeWithinTransaction` where we deal with a parameter-less `InvocationCallback`.","closed","type: enhancement,","sdeleuze","2019-09-03T20:53:49Z","2020-10-25T17:36:55Z"
"","23627","Improve Coroutines transaction API","As a follow-up of #22915, the purpose of this issue is to improve Coroutines programmatic transaction API to make it more consistent with the Java one.  For suspending functions, we currently have `TransactionalOperator.transactional` extension with a suspending lambda parameter which is conceptually closer to `TransactionalOperator.execute` Java API, so it would probably make sense to rename it `TransactionalOperator.executeAndAwait` and add a `ReactiveTransaction` parameter to the lambda.   For `Flow` the `TransactionalOperator.transactional` is correct but would be more idiomatic as a `Flow` extension.","closed","type: task,","sdeleuze","2019-09-12T12:30:22Z","2019-09-12T12:49:00Z"
"","23081","Support consistent ordering of string adapting properties","As a follow up to gh-23018, we should support consistent ordering of properties for the `Properties` object created by `CollectionFactory.createStringAdaptingProperties()`.","closed","type: enhancement,","sbrannen","2019-06-04T11:08:51Z","2019-06-04T11:57:08Z"
"","22924","Add @SpringTest annotation to bootstrap integration with the type's lifecycle and features similar to standard Spring components","As a follow up of #22286, this ticket is supposed to discuss the idea of a canonical annotation to be used with test classes that constitute Spring integration tests and configure JUnit to treat the class like a Spring component as much as possible. In detail, this includes:  - The instances of the test class are singletons by default - Dependency injection (esp. constructor injection) works just as for Spring components  This could effectively look something like this (name TBD):  ```java @SpringJUnitConfig // Bootstrap Spring container @AutowireTestConstructor // Enable constructor injection @TestInstance(Lifecycle.PER_CLASS) // Singleton, i.e. one instance for all test method invocations // other annotations needed @interface SpringTest { // SpringTest as that's in line with @SpringBootTest   // add aliases for attributes of above annotations } ```  The goal is to minimalize the conceptual differences between a Spring component in production code and a integration test class.","closed","type: enhancement,","odrotbohm","2019-05-08T11:04:54Z","2019-07-23T07:05:57Z"
"","23204","BasicAuthenticationInterceptor should cache the encoded credentials","As `BasicAuthenticationInterceptor` is just an `Interceptor` that recreates the encoded `Basic Authentication` header for *each* request, I think the encoded credentials should be cached and reused.  Maybe `org.springframework.http.HttpHeaders` could offer a `static encodeBasicAuth(String username, String password, @Nullable Charset charset)` that does the same as `setBasicAuth()`, but instead of setting the header directly, it just returns the `Basic ` string.  Suggested class therefore would change to:  ```java public class BasicAuthenticationInterceptor implements ClientHttpRequestInterceptor {         private final String basicAuth;  	public BasicAuthenticationInterceptor(String username, String password) { 		this(username, password, null); 	}  	public BasicAuthenticationInterceptor(String username, String password, @Nullable Charset charset) { 		Assert.doesNotContain(username, "":"", ""Username must not contain a colon""); 		this.basicAuth = HttpHeaders.encodeBasicAuth(username, password, charset); 	}   	@Override 	public ClientHttpResponse intercept( 			HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {  		HttpHeaders headers = request.getHeaders(); 		if (!headers.containsKey(HttpHeaders.AUTHORIZATION)) { 			headers.set(HttpHeaders.AUTHORIZATION, basicAuth); 		} 		return execution.execute(request, body); 	}  } ```  Pro: neither username nor pass has to be kept as cleartext.","closed","type: enhancement,","membersound","2019-06-27T13:05:18Z","2019-06-28T16:03:21Z"
"","22887","Move package messaging.handler.annotation.support.reactive to messaging.handler.annotation.reactive","Among the new reactive packages introduced in #21987, the `org.springframework.messaging.handler.annotation.support.reactive` package is arguably too deep. Let's move it to `org.springframework.messaging.handler.annotation.reactive`, at the same level as the `support` subpackage, aligned with `org.springframework.messaging.handler.invocation.reactive` and in particular the recent `org.springframework.transaction.reactive` package (#22646) which lives at the same level as `org.springframework.transaction.support` as well.","closed","type: task,","jhoeller","2019-05-04T15:20:17Z","2019-05-04T15:36:42Z"
"","23815","Changed the default character encoding to UTF-8 in both the exceptions","Also added an overload method for clients to get the response body in a different character encoding. Closes [Issue 23803](https://github.com/spring-projects/spring-framework/issues/23803)","closed","status: duplicate,","Sauhardstark","2019-10-16T06:23:07Z","2019-10-16T09:43:13Z"
"","22955","Avoid expensive assertions in web resource resolution","Along the lines of #22742, our resource resolution logic in `ResourceUrlEncodingFilter` and `EncodedResourceResolver` contains expensive assertions that should get replaced with direct `IllegalStateException` throwing.","closed","type: enhancement,","jhoeller","2019-05-13T10:22:13Z","2019-05-13T16:14:35Z"
"","23011","Consistently support CompletionStage/CompletableFuture in ReactiveAdapterRegistry","Along the lines of #19823 in the 4.3.x line, we should revise `ReactiveAdapterRegistry` towards `CompletionStage` support, considering all implementations of that interface as adaptable (instead of just `CompletableFuture`). This makes reactive return types for WebFlux consistent with MVC/messaging handler methods, most importantly allowing return type declarations to use the `CompletionStage` interface even if they effectively return `CompletableFuture` instances at runtime.","closed","type: enhancement,","jhoeller","2019-05-21T15:54:46Z","2019-05-21T17:28:25Z"
"","23242","Why Spring does not use placeholders to output logs？","All places are using string concat to output logs, instead of using placeholders. I'm confused about it.","closed","status: invalid,","chenqimiao","2019-07-05T06:06:41Z","2019-07-07T11:02:16Z"
"","23567","Log HTTP method in logging filters and revise log message format","Ahoy,  I was surprised to neither find the http method in the log messages of the `AbstractRequestLoggingFilter` nor the option to turn them on.  This looks like a fairly uncontroversial, fully optional and backwards compatible change to me so I did not open an issue up front. I'm happy to open one if more discussion is required.  ### Two things to note for the reviewer: ~~- [ ] I copy-pasted the method javadocs, and I'm not 100% sure if anything else needs to be done to get~~ ``` 	 * Should be configured using an {@code } for parameter name 	 * ""includeHttpMethod"" in the filter definition in {@code web.xml}. ``` ~~to work. I did some CTRL-Fing for the other values and nothing interesting came up.~~   ~~- [ ] I did not add a `@since 5.2` annotation as I'm not sure which version this will hit. Just amend it in :)~~    Cheers, Napster  Btw, setting up the local build and running tests was a breeze, great docs!","closed","status: feedback-provided,","napstr","2019-09-02T17:42:45Z","2019-09-16T15:01:00Z"
"","23313","Reactive JettyRequestUpgradeStrategy returns 'No WebSocketServerFactory available' on startup with simultaneous handshakes","After the server application has started the initial burst of WebSocket handshake requests some will fail with a 500 with the error 'No WebSocketServerFactory available', afterwards it's fine.   The problem is caused by the following code in class `org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy` in the `startLazily` method.   ```java if (this.servletContext != null) { 	return; }  synchronized (this.lifecycleMonitor) { 	if (this.servletContext == null) { 		this.servletContext = request.getServletContext(); 		start(); 	} } ```  If the above code is executed concurrently the code will early out when the servlet context is no longer null. But the `start()` method has not been (entirely) invoked causing exceptions for the requests already being executed untill the `start()` method has also been completed.","closed","type: bug,","MatthijsEM","2019-07-18T09:52:58Z","2019-09-24T12:40:18Z"
"","23196","New OncePerRequestFilter behavior breaks RequestContextFilter on Jetty after sendError","After the change to `OncePerRequestFilter` in #22989, when using a `RequestContextFilter`, the request context will no longer be available after `sendError(...)` completes in Jetty. This means that the usage of any `@Scope(""request"")` beans in places like the *afterCompletion* in interceptors or on the return path of filters will not work, nor will more general usage of `RequestContextHolder.getRequestAttributes()` work.  The problem is that the change in `OncePerRequestFilter` causes the filter to be processed *again*, even though it is a *Once*PerRequestFilter. And the `RequestContextFilter` is not designed to be nested. The `finally` block clears all request attributes, even when attributes were set before the filter started.  I'm not really sure what the best solution would be. Maybe introduce a `OncePerRequestFilter.shouldNotFilterOnNestedErrorDispatch()` or something. Or maybe make `RequestContextFilter` restore the previous request context, instead of clearing everything (it seems like `FrameworkServlet` does this too)? Or both.  **Affected version**: 5.1.8","closed","type: regression,","svschouw-bb","2019-06-26T08:40:24Z","2019-07-15T13:48:42Z"
"","23032","Support for fine-grained by-type references in the bean definition model","After reviewing the core _Spring Framework_ `BeanReference` implementations, I got to thinking if there was a `RuntimeBeanTypeReference` like implementation, or something similar?    I am aware of the [RuntimeBeanReference](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/RuntimeBeanReference.html) and [RuntimeBeanNameReference](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/RuntimeBeanNameReference.html) implementations, however, both of these only refer to a “single” bean in the _Spring_ context.  This is useful in situations like the following.  Given:  ``` class A {     B b;     // getters/setters omitted }  class B {      ...  } ```  Then in a framework (e.g. _Spring Data_ or _Spring Session_, etc) provided `ImportBeanDefinitionRegistrar` implementation, I can:   class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {  ```     public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {          BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(A.class);          builder.addPropertyReference(""b"",  ""nameOfSingleBeanB"");          // Or alternatively...         builder.addPropertyValue(""b"", new RuntimeBeanReference(""nameOfSingleBeanB""));          registry.registerBeanDefinition.register(""nameForBeanA"", builder.build());     } } ```  However, what if I want to register a `BeanDefinition` who’s class type has a property that requests all beans of a particular type declared and registered in the _Spring_ container?  Reimagining our class definitions from above:  ``` class A {     B[] b     // getters/setters omitted }  class B {     ... } ````  Then, with a `RuntimeBeanTypeReference`, I could:  ``` class CustomImportBeanDefinitionRegistrar implement ImportBeanDefinitionRegistrar {      public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {          BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(A.class);          builder.addPropertyReference(""b"",  new RuntimeBeanTypeReference(B.class));          registry.registerBeanDefinition(""nameForBeanA"", builder.build());     } } ```  I know we also have things like `Managed[List|Map|Set]` which can take 1 or more `BeanReference` objects, but again, I am constrained by having to know all the bean names possibly registered in the container upfront.  Of course, I could iterate the `BeanFactory`, `beanDefinitionNames` and inspect each `BeanDefinition` to determine if the class of the bean definition matches my desired type (e.g. `B`).    But, this does not work so well with `@Configuration` classes as it turns out.  It seems that when looking at the `beanDefinitionMap` the `@Configuration` classes have not be resolved with any `@Bean` definitions they contain, particularly when inspecting the `BeanFactory` (e.g. `getBeansOfType(..)`) inside a `ImportBeanDefinitionRegistrar`.  Therefore, by iterating (prematurely), I would not know if those `@Configuration` classes (or really, any `@Component` class), which is allowed to contain other `@Bean` definitions, would potentially match beans of my desired type (i.e. `B`).  Hence the thinking behind a `RuntimeBeanTypeReference` implementation.  I suppose `class A` could be defined as:  ``` class A {     @Autowired     B[] b; } ```  But, if annotation config (autowiring) were not enabled (which even though maybe uncommon), would not work.  Hence my thinking behind a `RuntimeBeanTypeReference` implementation.  Thoughts?","closed","type: enhancement,","jxblum","2019-05-25T02:57:46Z","2019-06-11T16:31:14Z"
"","23607","DefaultWebSessionManager should not cancel the subscription to WebSessionStore when there is no need to.","After receiving the first signal from `WebSessionStore#retrieveSession` the subscription on the `Mono` is cancelled which could confuse `WebSessionStore` implementations.  The flow currently is: request -> onNext -> cancel -> onComplete After the change the flow is: request -> onNext -> onComplete  Fixes gh-23606.  Author: Andreas Kluth","closed","","AndreasKl","2019-09-07T21:03:31Z","2022-02-18T19:07:11Z"
"","23523","Remove bodyWithType extension from WebFlux","After https://github.com/spring-projects/spring-framework/commit/008687d5aef120205ad218a27c2d8f2fa65122f3, `bodyWithType` extensions (introduced during Spring Framework 5.2 development) should be removed and the `body` reified one should be not deprecated anymore.","closed","type: task,","sdeleuze","2019-08-27T08:41:54Z","2019-08-28T11:48:18Z"
"","23376","Introduce gitattributes file","Affects: This repository's master branch.  There is currently no .gitattributes file, which means line ending settings are left up to each developer. This can cause issues when Windows devs check in code, as they may not have set `core.autocrlf` to true, and may be committing files with CRLF. It can also cause issues on checkout, as checking out the directory with `autocrlf` set to true will convert all files to CRLF, which breaks e.g. the `gradlew` script.  Using a .gitattributes means we can check in EOL settings alongside the code. A decent approach would probably be to start with `* text=auto` in the .gitattributes, and then add exceptions as necessary.  Reference https://git-scm.com/docs/gitattributes","closed","type: task,","srdo","2019-07-27T12:54:57Z","2019-10-02T13:47:27Z"
"","23179","WebSocketHttpRequestHandler not writing headers after interceptor returns false","Affects: spring-websocket 5.1.x and below  ## Setup Basic spring websocket server with one HandshakeInterceptor that limits the amount of connections. If the limit is reached, the interceptor sets http status 503, the retry-after header and returns false.  ## Expected Behavior The websocket server responds with http code 503 and the retry-after header.  ## Current Behavior The websocket server responds with http code 503, but **not** the retry-after header.  ## Cause As you can see in the [WebSocketHttpRequestHandler.java](https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-websocket/src/main/java/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.java#L150) the handleRequest() Method exits if a Inteceptor returns false.   Due to this, response.close() does not get called and headers are not written to the response. See [ServletServerHttpResponse.java](https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-web/src/main/java/org/springframework/http/server/ServletServerHttpResponse.java#L99), only close(), flush() and getBody() write headers.  We worked around this by calling response.close() in our Interceptor, but shouldn't this stuff be handled by ... the handler?","closed","type: bug,","niemannd","2019-06-22T06:12:20Z","2019-07-03T16:28:14Z"
"","23741","Handling of ResponseStatusException to also include setting of response headers","Affects: 5.1.10 Spring RestController offers a nice function, one could filter requests by methods. E.g.: ```java @RequestMapping(value = ""/some-pattern"", method = {RequestMethod.GET, RequestMethod.HEAD}) public Mono handler(...) ``` If a request matches the path pattern but does not match the method pattern spring-web automatically generates a response `405 Method Not Allowed` which is perfectly fine.  But RFC 7231 Explicitly requires servers to include the Allow header (https://tools.ietf.org/html/rfc7231#page-59): `The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.`  It request method filters must automatically insert an Allow header with a list of allowed methods into a response.","closed","type: enhancement,","Zabelinski-Andrey","2019-10-01T16:13:22Z","2019-10-30T12:11:31Z"
"","23743","Actuator WebEndpoint on Webflux with responses over 8192 bytes sometimes fail","Affects versions: `Spring Boot 2.1.8`, `Spring Boot 2.2.0M6` O/S: Mac 10.12, Also manifests in docker container on various platforms.  **Description**  Specifically for Spring Webflux, when the response for an actuator endpoint has a length over 8192, the responses sometimes fail. When the failure occurs, it appears that rather than sending the complete response, the first 8192 bytes are sent, and the connection is subsequently terminated. The failure does not occur on every request, but with significant frequency.  This problem was first observed when using Prometheus metrics registry and Spring Actuator in conjunction. Using the default metrics set, querying of the scrape endpoint will eventually result in an error. Using a JMeter client, the response is: ``` Thread Name: promtest-ThreadStarter 1-9 Sample Start: 2019-10-01 12:00:13 PDT Load time: 6 Connect Time: 1 Latency: 5 Size in bytes: 1315 Sent bytes:0 Headers size in bytes: 0 Body size in bytes: 1315 Sample Count: 1 Error Count: 1 Data type (""text""|""bin""|""""): text Response code: Non HTTP response code: org.apache.http.ConnectionClosedException Response message: Non HTTP response message: Premature end of Content-Length delimited message body (expected: 9,000; received: 8,042)  HTTPSampleResult fields: ContentType: application/vnd.spring-boot.actuator.v2+json;charset=UTF-8 DataEncoding: UTF-8 ```  In the logs, the following can be observed: ``` 2019-10-01 12:00:13.587 ERROR 98826 --- [nio-8080-exec-2] o.a.coyote.http11.Http11NioProtocol      : Error reading request, ignored  java.lang.IllegalStateException: Calling [asyncOperation()] is not valid for a request with Async state [COMPLETING] 	at org.apache.coyote.AsyncStateMachine.asyncOperation(AsyncStateMachine.java:269) ~[tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:203) ~[tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:53) ~[tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) ~[tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_181] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_181] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]  2019-10-01 12:00:13.587  INFO 98826 --- [nio-8080-exec-2] o.a.catalina.connector.CoyoteAdapter     : Encountered a non-recycled request and recycled it forcedly.  org.apache.catalina.connector.CoyoteAdapter$RecycleRequiredException: null 	at org.apache.catalina.connector.CoyoteAdapter.checkRecycled(CoyoteAdapter.java:525) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.coyote.http11.Http11Processor.recycle(Http11Processor.java:1322) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.release(AbstractProtocol.java:1016) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:984) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_181] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_181] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.16.jar:9.0.16] 	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]  ```  **Steps to reproduce**  1. Using Spring initializer, generate a project with the following parameters:       - Gradle project, Kotlin, Spring boot 2.1.8, Add ""Spring Reactive Web"" and ""Spring Boot Actuator"".  2.  Add the following dependencies to `build.gradle.kts`:       - `implementation(""org.springframework.boot:spring-boot-starter-tomcat"")` 3. Add the following endpoint in `DemoApplication.kt`:  ``` @WebEndpoint(id = ""test"") @Component class PrometheusScrapeEndpoint { 	@ReadOperation 	fun test(): String { 		return ""a"".repeat(8193) 	} } ``` 4. Expose the created endpoint using the following configuration:       - `management.endpoints.web.exposure.include=test` 5. Run the app, verify tomcat is being used. 6. Make requests to the `/actuator/test` endpoint. For this, I used JMeter @ 10rps and hit the above error repeatedly within a few seconds.  For your convenience, I've attached a demo app that manifest this issue.  **Notes** - This issue seems specific to Tomcat -- I see no problems when using Netty. - The latest non-manifesting Spring Boot version is `2.1.4`. - I can reproduce this on `2.2.0-M6`,  but not, for example, on `2.2.0-M1` - Pinning the Tomcat version to, say, `9.0.16` (Spring Boot `2.1.4` version) does not appear to help - I explored changing various configuration settings for Tomcat, to no avail.    **Sample app with issue** [demo.zip](https://github.com/spring-projects/spring-framework/files/3678162/demo.3.zip)  Let me know if there's any additional information / help required to debug this issue. Thanks for your attention.","closed","for: external-project,","erikbeerepoot","2019-10-01T19:27:31Z","2020-03-13T18:26:58Z"
"","23262","Obsolete documentation of  ""autowire"" property for @Bean","Affected version : **since 5.1**   Affected section : **_Spring core_ : 1.4.5. Autowiring Collaborators**  Documentation  always mentions the old obsolete description **vs**  the fact that the property is deprecated due to the @bean factory/@Autowired  resolution processing that supersede name/type-based bean property injection.","closed","status: invalid,","medzan","2019-07-09T15:59:34Z","2020-02-23T16:02:52Z"
"","23545","Adding Kotlin code examples to Testing documentation.","Adding Kotlin code examples to Testing documentation. See - gh-21778","closed","type: documentation,","kohlmu-pivotal","2019-08-30T00:38:02Z","2019-08-31T09:45:05Z"
"","22974","service blocks when content-length in request set too large","Adding a custom content-length header in request send to spring webflux service deliberately setting its value too high causes service to hang while connection is kept alive.  I need to validate/limit the request payload size in the spring service and this works fine as long as the content length header in the request complies with the actual size of the request body in octets OR is set too low. But whenever I test with a value in content-length where the value is higher than the actual size of the request body the spring webflux services seem to hang!?   kind regards,","closed","in: web,","maxvandewiel","2019-05-12T03:42:36Z","2019-12-10T15:29:23Z"
"","23671","Enhanced form data request support in MockRestServiceServer","Added FormDataRequestMatchers to be able to verify expected form parameters when using `MockRestServiceServer`  E.g.   ```java MockRestServiceServer mockServiceServer = MockRestServiceServer.createServer(restTemplate);  mockServiceServer.expect(ExpectedCount.once(), requestTo(""/foobar""))                 .andExpect(method(POST))                 .andExpect(formData().value(""foo"", ""bar""))                 .andExpect(formData().value(""baz"", Matchers.containsInAnyOrder(""fizz"", ""buzz"")))                 .andRespond(withSuccess().location(URI.create(""/foobar/123""))); ```","closed","type: enhancement,","spac-valentin","2019-09-19T18:19:16Z","2020-06-18T07:15:07Z"
"","23524","Improve parity between Java and Kotlin router DSL","Add variants with pattern, predicate and handlerFunction to Kotlin router DSLs. Equivalent of `Builder GET(String pattern, RequestPredicate predicate, HandlerFunction handlerFunction);` in Java.","closed","type: enhancement,","sdeleuze","2019-08-27T09:19:50Z","2019-09-17T10:44:02Z"
"","22900","Check if null before accessing exception message in webflux InvocableHandlerMethod#logArgumentErrorIfNecessary","Add null check before call `message.contains`.  Exception message should be null checked before accessing it in [InvocableHandlerMethod#logArgumentErrorIfNecessary](https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219).  If message is null, NPE will be thrown and webflux responds 500(INTERNAL SERVER ERROR).  In [corresponding function in webmvc](https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219), exception message is checked before accessing its method. I think webflux should do in the same manner.  Refs. - https://github.com/spring-projects/spring-framework/blob/e16a134/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java#L172 - https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219","closed","type: bug,","sakuna63","2019-05-06T09:58:44Z","2019-09-23T03:39:55Z"
"","23612","Support Optional argument in @MessageMapping","Add method argument resolver to Optional  @MessageMapping can use Optional as a  method argument, which allows to work with or without authentication and to avoid error message org.springframework.messaging.simp.annotation.support.MissingSessionUserException: No ""user"" header in message","closed","type: task,","KateVasovski","2019-09-09T13:30:15Z","2019-10-23T16:37:34Z"
"","23714","Add ability for StopWatch to aggregate results","Add configuration option for the StopWatch to aggregate results of timers with the same name, as opposed to replacing them. To preserve existing behaviour, this functionality is disabled (set to false) by default.  Changed the internals of the taskList to use a LinkedHashMap instead of a LinkedList so as to enable fast lookups of previous timers whilst also preserving the previous behaviour of ordering the list by insertion order.  Closes gh-6655","open","in: core,","Catchwa","2019-09-26T00:09:10Z","2021-11-11T09:52:32Z"
"","23119","Add queryParams and replaceQueryParams with Collection to UriBuilder","Add `UriBuilder.queryParams(name, Collection values)` and `UriBuilder.replaceQueryParams(name, Collection values)` methods to provide multiValued query parameters.  gh-23114","closed","type: enhancement,","nosan","2019-06-12T13:25:09Z","2019-07-05T10:06:25Z"
"","23692","Add CompositeTaskDecorator","Add `CompositeTaskDecorator` class.  For #23686","open","in: core,","ttddyy","2019-09-24T17:46:02Z","2021-11-11T09:52:31Z"
"","22997","WebFlux documentation states incorrectly that BindingResult is supported after @RequestBody","According to Webflux documentation: https://github.com/spring-projects/spring-framework/blob/master/src/docs/asciidoc/web/webflux.adoc  > You can use `@RequestBody` in combination with `javax.validation.Valid` or Spring’s `@Validated` annotation, which causes Standard Bean Validation to be applied. By default, validation errors cause a `WebExchangeBindException`, which is turned into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally within the controller through an Errors or a `BindingResult` argument.   The following example uses a `BindingResult` argument:  ```java @PostMapping(""/accounts"") public void handle(@Valid @RequestBody Account account, BindingResult result) { 	// ... } ```  This part throws an following exception :  > java.lang.IllegalStateException: An Errors/BindingResult argument is expected immediately after the `@ModelAttribute` argument to which it applies. For `@RequestBody` and `@RequestPart` arguments, please declare them with a reactive type wrapper and use its onError operators to handle WebExchangeBindException  Sample code : https://github.com/flezsoftware/requestbody-bindingresult  Suggested changes to documentation : https://github.com/spring-projects/spring-framework/pull/22993/files  and comment by @rstoyanchev https://github.com/spring-projects/spring-framework/pull/22993#issuecomment-493975726","closed","type: documentation,","flezsoftware","2019-05-20T13:34:17Z","2019-12-10T16:55:38Z"
"","22923","Fix JDK 9+ generics compilation problem in TransactionAspectSupport","According to https://build.spring.io/browse/SPR-JDK11-JOB1-151/log, the JDK 9+ compiler has a problem inferring some specific generics in TransactionAspectSupport's new reactive code path.","closed","in: core,","jhoeller","2019-05-08T10:59:22Z","2019-05-08T12:02:39Z"
"","23394","Polish getTypeForFactoryBean comment","AbstractAutowireCapableBeanFactory#getTypeForFactoryBean","closed","type: task,","ijliym","2019-08-01T07:44:42Z","2019-08-01T08:20:05Z"
"","23409","Improve Javadoc of ContentNegotiationManagerFactoryBean","About the javadoc for the [ContentNegotiationManagerFactoryBean](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.htm) class, appears in the top the following:  ``` Property Setter                 | Underlying Strategy          | Default Setting setFavorPathExtension(boolean)  | Path Extension strategy      | On favorParameter                  | Parameter strategy           | Off ignoreAcceptHeader              | Header strategy              | On defaultContentType              | Fixed content strategy       | Not set defaultContentTypeStrategy      | ContentNegotiationStrategy   | Not set  ```  Where again through the javadoc I can confirm the following:   * The [setFavorPathExtension](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.html#setFavorPathExtension-boolean-) method indicates that by default it is is set to **true**, same information as the table shown above, in this case **On**. * The [favorParameter](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.html#setFavorParameter-boolean-) method indicates that by default it is is set to **false**, same information as the table shown above, in this case **Off**.   The situation is with the `ignoreAcceptHeader` method  * The [ignoreAcceptHeader](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.html#setIgnoreAcceptHeader-boolean-) method indicates that by default it is is set to **false**, but this information is **not** the same information as the table shown above, in this case **On**.  It is confuse, I am assuming that should be `Off` instead of `On`","closed","type: task,","manueljordan","2019-08-02T21:42:21Z","2019-11-29T18:05:24Z"
"","23580","Optimize PostProcessorRegistrationDelegate to improve performance","A performance-related optimization recommendation in `PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors`  See #23578.","closed","in: core,","lgxbslgx","2019-09-04T08:06:42Z","2020-12-30T14:52:49Z"
"","23198","Add no-op TransactionOperations implementation","A no-op implementation can be useful for:  - having `TransactionOperations` consuming code switch to non-transactional behavior by injecting `NoOpTransactionOperations` instead of `TransactionTemplate` - testing purposes  For first point we have a use case in Spring Session's `JdbcOperationsSessionRepository`. I've used similar approach in a number of other projects so having Framework provide it OOTB would be nice. Also note that `TransactionOperations` isn't parameterized, but `TransactionOperations#execute` is which makes it impossible to have no-op implementation as lambda expression.","closed","type: enhancement,","vpavic","2019-06-26T21:48:00Z","2019-07-05T14:30:55Z"
"","23415","A dead loop found in SerializableTypeWrapper.java","a dead loop found","closed","in: core,","enkao","2019-08-04T05:27:53Z","2019-08-07T10:26:16Z"
"","23321","ResolvableType.forRawClass fails isAssignable against TypeVariable","A `ResolvableType` created using `forRawClass` incorrectly returns `false` when `isAssignable` is called against a type backed by a `TypeVariable`.  E.g.: Given the following type:  ```java public static class ExtendedList extends List { } ```  This code will result in `false` when it should be `true`:  ```java ResolvableType.forRawClass(CharSequence.class).isAssignableFrom(ResolvableType.forClass(ExtendsList.class).as(List.class).getGeneric()); ```","closed","in: core,","philwebb","2019-07-20T07:41:13Z","2019-07-20T12:43:24Z"
"","23562","Omit cancellation of transactional Monos in TransactionOperator","`TransactionOperator.as(Mono)` now no longer short-cuts via a `Flux.next()` but provides an implementation via `Mono.usingWhen(…)`. The short-cut previously issued a cancellation signal to the transactional `Mono` causing the transaction cleanup to happen without a handle for synchronization.  Using `Mono.usingWhen(…)` initiates transaction cleanup when the `Mono` completes eliminating the need for cancellation of the transactional `Publisher`.  This change does not fully fix #23304 but it softens its impact because `TransactionalOperator.transactional(Mono)` avoids cancellation.  /cc @michael-simons @simonbasle @smaldini   ---  - [x] We should get feedback from Michael or someone from the reactor team prior to merging this PR.","closed","type: enhancement,","mp911de","2019-09-02T10:01:43Z","2019-09-21T17:21:37Z"
"","23299","Support @TestPropertySource as a repeated annotation","`TestPropertySource` is inherited in case of class hierarchy however it is not inherited in meta-annotation hierarchy. The lack of this is made clear by @sbrannen in his answer: https://stackoverflow.com/a/26183692 He says: > The algorithm that the Spring Framework uses when searching for an annotation stops once it has found the first occurrence of the sought annotation.   ## Expected behaviour The settings from the `@CustomTest` and `MyTest` should merged as it is merged in case of class inheritance.  ```java @TestPropertySource(properties = { ""property-a=value-a"", ""property-b=value-b"" }) public @interface CustomTest { } ```  ```java @CustomTest @TestPropertySource(properties = { ""property-a=value-x"", ""property-c=value-c"" }) public class MyTest {   @Value(""${property-a}"")   private String propertyA;   @Value(""${property-b}"")   private String propertyB;   @Value(""${property-c}"")   private String propertyC;    @Test   public void test() {     assertEquals(""value-x"", propertyA);     assertEquals(""value-b"", propertyB);     assertEquals(""value-c"", propertyC);   } } ```  ## Rationale It could give much more flexibility in tests.","closed","type: enhancement,","gebezs","2019-07-16T16:31:33Z","2019-08-04T23:15:14Z"
"","23686","Support multiple TaskDecorators in TaskExecutionAutoConfiguration","`TaskExecutionAutoConfiguration` currently only take single `TaskDecorator` bean. This is because there is no implementation that represents multiple `TaskDeorator`s. (e.g.:  `CompositeTaskDecorator`).  I handle this by creating `CompositeTaskDecorator`:  ```java public class CompositeTaskDecorator implements TaskDecorator {     private List taskDecorators = new ArrayList<>();      public CompositeTaskDecorator(Collection taskDecorators) {         this.taskDecorators.addAll(taskDecorators);     }      public CompositeTaskDecorator(TaskDecorator... taskDecorators) {         this.taskDecorators.addAll(Arrays.asList(taskDecorators));     }      public boolean add(TaskDecorator taskDecorator) {         return this.taskDecorators.add(taskDecorator);     }      @Override     public Runnable decorate(Runnable runnable) {         for (TaskDecorator taskDecorator : this.taskDecorators) {             runnable = taskDecorator.decorate(runnable);         }         return runnable;     } } ```  I believe it is pretty common to have usecases to apply multiple TaskDecorators; so, it is nice if `CompositeTaskDecorator` is available in either spring or spring-boot.  Then, if such class is available, `TaskExecutionAutoConfiguration`(`TaskExecutorBuilder`) can detect  multiple task decorators.  ```java TaskDecorator taskDecorator(ObjectProvider taskDeorators) {   return new CompositeTaskDecorator(taskDeorators.orderedStream().collect(Collectors.toList())); } ```","open","type: enhancement,","ttddyy","2019-09-24T05:54:22Z","2022-06-17T15:49:07Z"
"","23755","TaskScheduler does not work with TaskDecorator","`TaskDecorator` doesn't directly work with task scheduler implementations - `ThreadPoolTaskScheduler`/`ConcurrentTaskScheduler`.  Related: https://github.com/spring-projects/spring-framework/issues/18502  I think the underlying reason is there is no easy way of applying `TaskDecorator` to `ScheduledExecutorService`.  Currently, I workaround by wrapping `ScheduledExecutorService` with a proxy that performs task decoration.  Proxy Handler: ```java public class TaskDecoratingScheduledExecutorServiceInterceptor implements MethodInterceptor {      private final TaskDecorator taskDecorator;      public TaskDecoratingScheduledExecutorServiceInterceptor(TaskDecorator taskDecorator) {         this.taskDecorator = taskDecorator;     }      @Override     public Object invoke(MethodInvocation invocation) throws Throwable {         Object[] args = invocation.getArguments();         if (args.length == 0) {             return invocation.proceed();  // no decoration, simply proceed         }          Object swapped;         if (args[0] instanceof Runnable) {             swapped = replaceRunnable(method, (Runnable) args[0]);         } else if (args[0] instanceof Callable) {             swapped = replaceCallable(method, (Callable) args[0]);         } else if (args[0] instanceof Collection) { // see the ExecutorService API             swapped = ((Collection>) args[0]).stream()                     .map(callable -> replaceCallable(method, callable))                     .collect(toList());         } else {             return invocation.proceed(); // bail out, no replace needed         }         args[0] = swapped;  // swap          return invocation.proceed();     }      .... } ```  Wrap created `ScheduledThreadPoolExecutor` in `ThreadPoolTaskScheduler`:  ```java ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler() {      private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;      @Override     protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {                  // keep it for ""getScheduledThreadPoolExecutor()""         this.scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) super.createExecutor(poolSize, threadFactory, rejectedExecutionHandler);          ScheduledExecutorService executorService = this.scheduledThreadPoolExecutor;          // apply task decorator via proxy         ProxyFactory proxyFactory = new ProxyFactory(executorService);         proxyFactory.addAdvice(new TaskDecoratingScheduledExecutorServiceInterceptor(taskDecorator));          return (ScheduledExecutorService) proxyFactory.getProxy();     }      @Override     public ScheduledThreadPoolExecutor getScheduledThreadPoolExecutor() throws IllegalStateException {         return this.scheduledThreadPoolExecutor;     } } ```  I think it would be nice that `ThreadPoolTaskScheduler`/`ConcurrentTaskScheduler` to have some API to work with `TaskDecorator` OR a way to easily customize underlying `ScheduledExecutorService` to apply decorators.   For example, a delegate class that takes `TaskDecorator`:  ```java public class TaskDecoratingScheduledExecutorServiceDelegate implement ScheduledExecutorService {   private final ScheduledExecutorService delegate;   private final TaskDecorator taskDecorator;      ... }  ```","open","in: core,","ttddyy","2019-10-04T00:54:55Z","2021-11-10T12:03:13Z"
"","22907","StandardAnnotationMetadata does not use declared methods cache","`StandardAnnotationMetadata` currently directly calls `getDeclaredMethods`. It could use the `ReflectionUtils` method instead to take advantage of the cache.","closed","type: enhancement,","philwebb","2019-05-06T20:29:08Z","2019-05-07T21:13:48Z"
"","22934","SimpleJdbcInsert.executeAndReturnKey() does not support LocalDateTime type","`SimpleJdbcInsert.executeAndReturnKey()` does not support LocalDateTime type. Corresponding to Mysql8.0.15 `datetime` type.  **Current solution** `java.util.Date`  **Expected support type** `java.time.LocalDateTime`","open","in: data,","yl-yue","2019-05-09T10:43:30Z","2021-11-12T12:12:41Z"
"","23794","Allow setting primary flag on BeanDefinitionBuilder","`setPrimary(…)` is absent from `BeanDefinitionBuilder` and currently can only be set on `BeanDefinition` directly.","closed","type: enhancement,","odrotbohm","2019-10-15T09:52:01Z","2019-10-30T00:05:42Z"
"","23296","Add queryParam method to MockHttpServletRequestBuilder","`ServletUriComponentsBuilder` uses `HttpServletRequest#getQueryString` to build on the current request. However, in a GET or HEAD request, `MockHttpServletRequestBuilder#param` only adds to the combined parameter map and not the query string, causing it to fail.  The workaround is to provide the parameters directly in the URI string, but this is inferior to the fluent API. The different behaviour is probably surprising to many users.  See also https://github.com/spring-projects/spring-restdocs/issues/26","closed","status: superseded,","OrangeDog","2019-07-16T12:13:43Z","2019-11-12T16:41:50Z"
"","23459","Allow use of DataBufferUtils from ServerHttpResponseDecorator#writeWith","`ServerHttpResponseDecorator` accepts `Publisher` while `DataBufferUtils` expects `Publisher`.","closed","in: core,","ilgrosso","2019-08-14T06:52:09Z","2019-09-04T11:15:01Z"
"","23368","RSocketRequester.Builder support for ConnectionSetupPayload","`RSocketRequester` supports Objects for metadata and data in requests, but for the initial `SETUP` frame, you're left to prepare and set `ConnectionSetupPayload` on the `RSocketFactory`.","closed","type: enhancement,","rstoyanchev","2019-07-26T11:01:53Z","2019-07-29T21:28:08Z"
"","23093","Annotate Object#equals parameter with @Nullable","`Object#equals` parameter should be annotated with `@Nullable` when overridden. Notice that Kotlin 1.3.30+ now checks that more strictly than previous versions.","closed","type: enhancement,","sdeleuze","2019-06-06T12:17:43Z","2019-06-06T12:43:30Z"
"","23360","Pre-allocate NoTransactionException in TransactionContextManager","`NoTransactionException` should be pre-allocated in `org.springframework.transaction.reactive.TransactionContextManager` to prevent expensive exception creation when calling `TransactionContextManager.currentContext()`. Ideally, this exception captures no stack trace, that is irrelevant in the context of reactive flows.  /cc @simonbasle @bsideup","closed","type: enhancement,","mp911de","2019-07-25T13:46:43Z","2019-09-03T22:07:11Z"
"","22968","Improve GraalVM native support","`native-image` is the command that compiles an application (in our case a Spring application) into a native executable. Configuration of the command can be done via command line options (passed directly or via static side files) or by building a `Feature`. In some cases command line options is fine but a `Feature` gives maximum flexibility as it is code that participates in the `native-image` execution process and can make dynamic decisions based on the proposed content of the executable.  There is a prototype of Spring Boot Feature in this project: https://github.com/spring-projects-experimental/spring-graalvm-native - the feature is here:  https://github.com/spring-projects-experimental/spring-graalvm-native/blob/master/spring-graalvm-native-feature/src/main/java/org/springframework/graalvm/support/SpringFeature.java - there is a https://github.com/spring-projects-experimental/spring-graalvm-native/tree/master/spring-graalvm-native-samples folder  The prototype is crude and currently uses a lot of fixed information which needs computing but the project proves that once that information is collected (and if we workaround that remaining Graal issue), `native-image` is happy to build Spring projects.  There are four kinds of data that are passed by the `Feature` as the `native-image` command executes: - reflection. We need to determine which types are going to be reflected on as the application runs, and if we tell the compiler it will generate metadata such that reflection will succeed at runtime. - resources. We need to determine which resources are going to be accessed as the application runs. If we tell the compiler about them they will be added to the executable image and available at runtime. This includes obvious files like `spring.factories` `spring.components` but also if the system is going to load the bytecode to run asm over it to find something, those class files also need to be available as resources. - proxies. We need to determine what proxies will be generated as the system runs. By telling the compiler about them it will generate them at image build time and they will be available at runtime when requested. - delayed initialization. The compiler will try to do as much initialization up front for faster execution later. This means executing class initializers as the image is built. This works great if building a data table for later lookup, but it does not work in all cases. For example if the code was creating a `DirectByteBuffer`. We need to compute any types that need to be delayed for runtime initialization and tell the compiler about them.  Some of this data can be computed easily - some types are already annotated (or meta-annotated) with something that indicates we'll need to add them to the reflection/resource lists. (`@Configuration`). The current prototype Feature doesn't do much computation (yet) but you can see the kind of data it is passing (and so needs computing) for all these four kinds of data here: https://github.com/aclement/spring-boot-graal-feature/tree/master/src/main/resources (That is not the minimal set of data, it is just a set that works!)  JDK Proxy usage is allowed in applications being compiled but not dynamic class definition via CGLIB. To avoid the need to do that you can use the new `proxyBeanMethods=false` option. You can see  `@SpringBootApplication(proxyBeanMethods = false)` in the sample demo app mentioned above. There are other ways we can handle this (annotation processor that generates the proxy at build time).  The sample project above is using the `spring-content-indexer` maven plugin to create a `spring.components` file for some processing. Not entirely clear this is necessary yet.  There is a challenge in drawing the line between framework and boot.  A basic version of a feature for framework might scan for `spring.factories` and simply add any listed classes to the reflect/resource lists. The problem is whether that goes far enough to make something work. For example if `spring.factories` is being used to specify boots `EnableAutoConfiguration` then just adding the referred auto-configuration classes isn't enough. If those configuration classes use a `ConditionalOnClass` check, the types referred to in those conditions also need adding in order for the configuration to behave and framework has no knowledge of that need (only boot does). Going further, and that is what the sample feature above does (as an experiment and to keep the size of the manually maintained json files): What if the `ConditionalOnClass` check was going to fail because at image build time we know the classpath and it isn't there? There is no need to add the auto configuration to the system because it will fail immediately.  You can tweak resource files as the image is built (remove unnecessary entries in spring.factories for example). This would reduce image size and make the compiled result even faster.  (As an example, boot 2.2 lists ~120 autoconfigurations in spring.factories, 100 of them are immediately going to fail ConditionalOnClass checks).  Can both boot and framework have a feature? Sure, but how would you handle this case above when there are two? Maybe keep it dumb initially and measure the impact (framework feature simply adds types referred to in `spring.factories` where the boot feature takes another pass and adds the deeper set of types, no smart exclusion).  Dependencies are likely to add their own features over time. For example the sample project above includes its own configuration for `netty` but `netty` now ships their own that we should simply rely on.  Also need to decide how to recommend users run `native-image`. It can be run as part of a maven build but you probably want it attached to a separate target because it takes a while (you probably wouldn't want to run it all the time).  The sample project above unpacks the boot far jar before running it, that may not be necessary with a more sophisticated feature.  Having said all the above... taking a step back there is an alternative to a feature if we wish to go down the compiler plugin route. Annotation processors can produce the more static kind of data (the `json` flat files) that native-image can then pickup. Possibly slightly more advanced than your standard annotation processor as may need to dig deeply through some types to track down some things that need to be included in those files. In this situation we'd build spring itself with these processors and include the `json` files in each built artifact. The files would look a bit like those I linked above but be split up by jar that introduces those entries. The users application would also need to be built with the processor to produce the side files. What all this wouldn't allow is the more dynamic behaviour (excluding certain things as the image is built because you know the complete classpath for the system that is going to run).","closed","type: enhancement,","aclement","2019-05-13T18:01:41Z","2020-07-27T10:27:13Z"
"","22881","Fix doCleanupAfterCompletion invocation and replace signal materialization","`doCleanupAfterCompletion` gets now subscribed to when processing cleanup after a new transaction.  We now use `Flux.usingWhen()` instead materialize/dematerialize operators to reuse Reactor's resource closure.  Until usingWhen() accepts a BiFunction to consume error signals, we need to map error signals outside of `usingWhen` which requires re-wrapping of the `ReactiveTransaction` object.  See also reactor/reactor-core#1687","closed","type: task,","mp911de","2019-05-03T12:58:43Z","2019-05-03T14:37:52Z"
"","23024","DelegatingWebFluxConfiguration could be marked as proxyTargetBean=false","`DelegatingWebFluxConfiguration` still doesn't have the `proxyTargetBean=false` flag, and I can't see any internal method calls to `@Bean` methods.","closed","status: duplicate,","dsyer","2019-05-24T07:18:54Z","2019-05-24T13:49:24Z"
"","23184","DefaultMultipartMessageReader should not buffer","`DefaultMultipartMessageReader` should not use `bufferUntil` as that stores all parts in memory.  See https://github.com/spring-projects/spring-framework/issues/21659#issuecomment-504660093 and https://github.com/spring-projects/spring-framework/issues/21659#issuecomment-504663344 by @thekalinga.","closed","status: superseded,","poutsma","2019-06-24T08:01:33Z","2019-07-29T14:11:04Z"
"","23615","Add checksum-dependency-plugin for verification of plugin/dependency checksums","`checksum-dependency-plugin` is a superset of `gradle-witness`, and it enables to increase the level of security.  See https://github.com/vlsi/vlsi-release-plugins#checksum-dependency-plugin See https://medium.com/@vladimirsitniko/dependency-verification-checksum-vs-pgp-582e76207019?sk=7485298b76eaf9f935b899b002f4c3b5  See https://github.com/spring-projects/spring-framework/issues/23434","open","status: waiting-for-triage,","vlsi","2019-09-10T08:46:57Z","2021-04-27T05:06:11Z"
"","23006","Upgrade to asciidoctorj-pdf version 1.5.0-alpha.17","`asciidoctor-pdf` finally upgraded after nearly two years.","closed","status: declined,","diguage","2019-05-21T02:19:45Z","2019-05-31T07:58:26Z"
"","22847","PathPattern with double-star(**) not works as expected","```java public class SpringPathPatternTest {      @Test     public void testDoubleStar() {         PathPattern pathPattern = new PathPatternParser().parse(""/first/**/last"");         PathContainer path = PathContainer.parsePath(""/first/a/b/c/last"");          assertTrue(pathPattern.matches(path)); // FAILED !!!     } } ```  tested on spring-web 5.1.5.RELEASE","closed","status: invalid,","ronnin","2019-04-28T05:03:15Z","2019-04-29T08:31:50Z"
"","23578","Optimize PostProcessorRegistrationDelegate to improve performance","```java List currentRegistryProcessors = new ArrayList();  			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. 			String[] postProcessorNames = 					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 			for (String ppName : postProcessorNames) { 				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { 					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); 					processedBeans.add(ppName); 				} 			} 			sortPostProcessors(currentRegistryProcessors, beanFactory); 			registryProcessors.addAll(currentRegistryProcessors); 			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 			currentRegistryProcessors.clear();  			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. 			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 			for (String ppName : postProcessorNames) { 				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) { 					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); 					processedBeans.add(ppName); 				} 			} 			sortPostProcessors(currentRegistryProcessors, beanFactory); 			registryProcessors.addAll(currentRegistryProcessors); 			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 			currentRegistryProcessors.clear();  			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. ```","closed","status: superseded,","SuiSuiNian19","2019-09-04T03:14:29Z","2020-12-30T14:56:10Z"
"","23425","ResolvableType.forClass(converterClass).as(genericIfc) could not get lamda type info","```java @Configuration public class LocalDateConverterConfig {      @Bean     public Converter localDateConverter() {         return source -> LocalDate.parse(source, DateTimeFormatter.ofPattern(""yyyy-MM-dd""));     }      @Bean     public Converter localDateTimeConverter() {         return source -> LocalDateTime.parse(source, DateTimeFormatter.ofPattern(""yyyy-MM-dd HH:mm:ss""));     }  } ``` when i start the application, i got an exception: ```java Caused by: java.lang.IllegalArgumentException: Unable to determine source type  and target type  for your Converter [com.maxiao.config.LocalDateConverterConfig$$Lambda$595/1561854103]; does the class parameterize those types? ``` It seems like that it does not support lamda expressions. any one help?  here is the stack trace ```java Caused by: java.lang.IllegalArgumentException: Unable to determine source type  and target type  for your Converter [com.maxiao.config.LocalDateConverterConfig$$Lambda$595/1561854103]; does the class parameterize those types? 	at org.springframework.core.convert.support.GenericConversionService.addConverter(GenericConversionService.java:92) ~[spring-core-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.addFormatters(WebMvcAutoConfiguration.java:302) ~[spring-boot-autoconfigure-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.web.servlet.config.annotation.WebMvcConfigurerComposite.addFormatters(WebMvcConfigurerComposite.java:81) ~[spring-webmvc-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration.addFormatters(DelegatingWebMvcConfiguration.java:78) ~[spring-webmvc-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration.mvcConversionService(WebMvcAutoConfiguration.java:479) ~[spring-boot-autoconfigure-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration$$EnhancerBySpringCGLIB$$b85a4d01.CGLIB$mvcConversionService$0() ~[spring-boot-autoconfigure-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration$$EnhancerBySpringCGLIB$$b85a4d01$$FastClassBySpringCGLIB$$c93fbff1.invoke() ~[spring-boot-autoconfigure-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration$$EnhancerBySpringCGLIB$$b85a4d01.mvcConversionService() ~[spring-boot-autoconfigure-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_212] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_212] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_212] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_212] 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	... 52 common frames omitted ```","closed","","liaozan","2019-08-06T18:00:23Z","2021-01-08T13:09:10Z"
"","23725","Prototype does not return new instance if ScopedProxyMode.TARGET_CLASS","```java @Component @Scope(value = BeanDefinition.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS) public class ShouldBePrototype {  } ```  Class above is not prototype.  I wrote test to prove that   ```java @RunWith(SpringRunner.class) @SpringBootApplication public class NotPrototypeApplicationTests {     @Autowired     ObjectFactory  shouldBePrototypeFactory;      @Test     public void notOk() {         assert (shouldBePrototypeFactory.getObject() != shouldBePrototypeFactory.getObject());     }  } ```  Test is fail.   Full project to reproduce https://github.com/MEJIOMAH17/funnyPrototype","open","status: feedback-provided,","MEJIOMAH17","2019-09-28T15:43:24Z","2021-11-10T11:58:03Z"
"","23352","MethodParameter.equals is too coarse-grained for its use in HandlerMethodArgumentResolverComposite","```java 	@Override 	public int hashCode() { 		return (getExecutable().hashCode() * 31 + this.parameterIndex); 	} ```  `HandlerMethodArgumentResolverComposite` uses `MethodParameter` as a cache key for `HandlerMethodArgumentResolver`.  Consider:  ```java @FunctionalInterface public interface GenericHandler {  	Object handle(P payload, MessageHeaders headers);  } ```  ```java 		public static class MapHandler implements GenericHandler> {  			@Override 			public String handle(Map mapPayload, MessageHeaders messageHeaders) { 				return ""Hello "" + mapPayload.get(""key""); 			}  		}  		public static class StringHandler implements GenericHandler {  			@Override 			public String handle(String stringPayload, MessageHeaders messageHeaders) { 				return stringPayload + "" World!""; 			}  		} ```  `MethodParameter.executable` in both cases is the interface `Method`:  >`public abstract java.lang.Object org.springframework.integration.handler.GenericHandler.handle(java.lang.Object,org.springframework.messaging.MessageHeaders)`  When invoking the second method, we get a cache hit and fail with a class cast exception because the wrong argument resolver is returned.  Spring Integration recently changed to use a shared `DefaultMessageHandlerMethodFactory` `@Bean`, and hence a shared  `HandlerMethodArgumentResolverComposite`.  We can work around this by changing the bean scope to prototype, but I think the `hashCode()` and `equals()` should include at least the `containingClass` and/or `parameterType` field.  See https://github.com/spring-projects/spring-integration/issues/3004","closed","in: core,","garyrussell","2019-07-24T17:40:14Z","2019-08-01T13:31:39Z"
"","23190","Outdated Spring project versioning page","[This document](https://github.com/spring-projects/spring-build-gradle/wiki/Spring-project-versioning) that specifies the versioning used in the spring projects seems to be deprecated.  Could please update it or confirm whether you still use the same semantics for versioning or not?  Because I am updating some minor and micro versions of a couple of our projects but I need to confirm the backward-compatibility of these newer versions.","closed","","kareemadel","2019-06-24T19:41:34Z","2019-06-26T20:08:10Z"
"","23548","Can't remove header using HttpServletResponse","[Please check out my reproduction of the issue here.](https://bitbucket.org/szabkel/emptyfileonexceptionrepro/src/master/src/main/java/com/emptyfileproblem/repro/TestResponseChange.java)  I ran into this problem, while I wanted to make an endpoint, which allows the users to download a File (browser pops up a File Save As window), but if there is an error during the preparing process, it should display an error message (default spring whitelabel error page would be fine). You can read more [here](https://stackoverflow.com/questions/57689005/spring-boot-exception-during-download-results-in-empty-file).  If I once set the header `Content-Disposition`, I can't remove it using the `HttpServletResponse`.  Example:  ```java @RestController @RequestMapping(""api"") public class TestResponseChange {     @Autowired     ResourceLoader resourceLoader;      @GetMapping(""/download-change"")     public void download(HttpServletResponse response) throws SomeException {          try (OutputStream out = response.getOutputStream()) {             response.setContentType(""application/x-download"");             response.setHeader(""Content-Disposition"", ""attachment; filename=\""SomeFile.txt\"""");              if (1 == 1 / 1) {                 throw new Exception(""Test"");             }              var resource = resourceLoader.getResource(""classpath:TestFileToRead.txt"");             try (var inputStream = new FileInputStream(resource.getFile())) {                 StreamUtils.copy(inputStream, out);             }         } catch (Exception e) {             response.setContentType(""text/plain"");             response.setHeader(""Content-Disposition"", null);             throw new SomeException(e);         }     }      @ExceptionHandler(SomeException.class)     public ResponseEntity handleException(SomeException ex) {         System.out.println(""Failed. "" + ex.getMessage());         return new ResponseEntity<>(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);     } } ```  If I navigate my browser to the `api/download-change` url, the result will be an empty file download and a ""logged"" error.","closed","status: invalid,","SzabKel","2019-08-30T09:11:05Z","2019-08-30T11:47:39Z"
"","23090","GenericConverter methods are contradictory and risk ClassCastException","[GenericConverter.getConvertibleTypes](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/GenericConverter.html#getConvertibleTypes--) returns a pair of `Class`, while [GenericConverter. convert](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/GenericConverter.html#convert-java.lang.Object-org.springframework.core.convert.TypeDescriptor-org.springframework.core.convert.TypeDescriptor-) accepts a pair of `TypeDescriptor`. This is inconsistent because the `getConvertibleTypes` has no way to specify generic type information that's available in the `TypeDescriptor`. If I wrote a converter to convert comma-separated string to a list of integers, and another to convert comma-separated string to a list of floats, the `getConvertibleTypes` wouldn't be able to differentiate between them.  It makes a lot of sense to return a pair of `TypeDescriptor` from getConvertibleTypes, so that it's consistent with the `convert` method.","open","in: core,","asarkar","2019-06-05T18:15:17Z","2021-11-11T10:12:39Z"
"","23688","RedeliveryDelay not working in ActiveMQ listeners when transactionManager is present","[demoJms.zip](https://github.com/spring-projects/spring-framework/files/3646869/demoJms.zip)  Hi,  I've created a demo with a spring boot application that has defined a listener to activemq broker, I can detect that the redeliveryDelay is not working when the transactionManager is available in the DefaultJmsListenerContainerFactory. I can reproduce it with atomikos and bitronix.  I've attached the project, so you can reproduce the problem.  Thxs.","open","in: messaging,","ceremo","2019-09-24T11:29:13Z","2021-11-12T13:42:09Z"
"","23361","WebClient blocks on JDK 8","[BlockHound](https://github.com/reactor/BlockHound) detects a blocking I/O on JDK 8 in this simple test using `WebClient`. It's related to how the JDK initializes the `java.lang.Package.getSystemPackage()`. This error occurs in JDK 8, however, is not an issue with JDK 10.  I'm wondering if there is a fix that can be applied within WebFlux to resolve this error under JDK 8?  There has been earlier discussions with @rstoyanchev and @rwinch around this issue.  Here is a link to the [reproducer](https://github.com/jgrandja/oauth2-client-nonblock/blob/master/ui-app/src/test/java/sample/SimpleTests.java#L43).","closed","status: invalid,","jgrandja","2019-07-25T14:13:18Z","2019-11-20T12:56:20Z"
"","23549","@Transactional  cause synchronized invalid","@Transactional  cause synchronized invalid   springboot version 2.1.7.release My code is  `public interface GoodsMapper {     @Update("" update goods set stock = stock-1 where id= #{id}    "")    int reduceStock(@Param(""id"")  Integer id);     @Select("" select  *  from goods   where id= #{id}  "")    Goods getGoodsById(@Param(""id"")  Integer id); }   public interface OrderMapper {     @Options(useGeneratedKeys = true,keyProperty = ""id"",keyColumn = ""id"")    @Insert("" insert into `order`(user_id)  values(#{userId})    "")    int addOrder(Order order);   }  @Component public class GoodsService {     @Autowired     GoodsMapper goodsMapper;      @Autowired     OrderMapper orderMapper;       @Transactional      public void  reductStock(Integer id) throws Exception {           synchronized (this){               Goods goods = goodsMapper.getGoodsById(id);               if (goods.getStock()>0){                   goodsMapper.reduceStock(id);                   Order order = new Order();                   order.setUserId(UUID.randomUUID().toString());                   orderMapper.addOrder(order);               }else{                   throw new RuntimeException("" 库存不足"");               }           }      } }  Controller   --------------------------     @GetMapping(""/stock/reduce"")     public Object reduceStock(Integer id) throws Exception {             goodsService.reductStock(id);       return ""ok"";    }  `  ![image](https://user-images.githubusercontent.com/13187186/64015523-4adb7380-cb57-11e9-94a1-9fc8385b86bc.png)","open","in: data,","jimforcode","2019-08-30T10:53:24Z","2021-11-10T09:27:05Z"
"","23793","Debug logging for WebSocket lifecycle in WebSocketStompClient","@pivotal-issuemaster This is an Obvious Fix","closed","type: task,","alexandrumm","2019-10-14T19:48:19Z","2019-10-30T12:11:31Z"
"","23220","@jbp19866 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=23217)!","@jbp19866 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=23217)!  [Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=23217) to manually synchronize the status of this Pull Request.  See the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.  _Originally posted by @pivotal-issuemaster in https://github.com/spring-projects/spring-framework/pull/23217#issuecomment-507209656_","closed","status: invalid,","jbp198669","2019-07-01T11:00:09Z","2019-07-09T11:46:41Z"
"","23785","How to override the SameSite attribute of JSESSIONID cookie","@BoomManPro You should be able to [add a cookie initializer](https://github.com/vpavic/spring-framework/blob/8d3162352211c7edf05518c03236dae64223388e/spring-web/src/main/java/org/springframework/web/server/session/CookieWebSessionIdResolver.java#L91) which can override the default value. If you have additional questions problems, you might want to create a ticket in JIRA https://jira.spring.io/browse/SPR  _Originally posted by @rwinch in https://github.com/spring-projects/spring-framework/pull/1889#issuecomment-442980715_","closed","","AaronZhengkk","2019-10-12T03:53:43Z","2019-12-12T16:18:52Z"
"","23461","Consider addressing alerts reported by lgtm.com","I learned about a static analysis website called [lgtm.com](https://lgtm.com) some time ago, and I noticed that the Spring Framework has an entry on the website where currently [115 alerts](https://lgtm.com/projects/g/spring-projects/spring-framework/alerts) are reported against it, a few of which seem to be security-related.  I personally think these alerts should be looked into and ideally fixed. What's the Spring team's thoughts on this? :thinking:","closed","status: declined,","jbduncan","2019-08-14T17:52:15Z","2019-08-15T04:57:16Z"
"","23527","EnableCaching and EnableTransactionManagement with unexpected order","I use EnableTransactionManagement and EnableCaching at the same time. I find them in the same aspect order.   You may see  > Advice ordering > What happens when multiple pieces of advice all want to run at the same join point? Spring AOP follows the same precedence rules as AspectJ to determine the order of advice execution. The highest precedence advice runs first ""on the way in"" (so given two pieces of before advice, the one with highest precedence runs first). ""On the way out"" from a join point, the highest precedence advice runs last (so given two pieces of after advice, the one with the highest precedence will run second). >  > When two pieces of advice defined in different aspects both need to run at the same join point, unless you specify otherwise the order of execution is undefined. You can control the order of execution by specifying precedence. This is done in the normal Spring way by either implementing the org.springframework.core.Ordered interface in the aspect class or annotating it with the Order annotation. Given two aspects, the aspect returning the lower value from Ordered.getValue() (or the annotation value) has the higher precedence. >  > When two pieces of advice defined in the same aspect both need to run at the same join point, the ordering is undefined (since there is no way to retrieve the declaration order via reflection for javac-compiled classes). Consider collapsing such advice methods into one advice method per join point in each aspect class, or refactor the pieces of advice into separate aspect classes - which can be ordered at the aspect level.  the same order is Ordered.LOWEST_PRECEDENCE I think the cacheAspect may have a higher order than transactionAspect because we need not to make a request to database if the data is cached. In my project, I can see lot of  ```sql select @@session.tx_read_only ``` even the data is cached.  I will modify the EnableCaching with the order Ordered.LOWEST_PRECEDENCE-1","open","in: core,","qixiaobo","2019-08-24T06:38:23Z","2021-11-10T09:51:26Z"
"","23206","@ComponentScan is activated unexpectedly.","### spring boot version `2.1.5.RELEASE` ### TestConfig.java ```java package org.xyattic.boot.calkin.demo.oauth2.server.config;  import org.springframework.boot.autoconfigure.condition.ConditionalOnBean; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; import org.springframework.core.io.Resource;  /**  * @author wangxing  * @create 2019/6/28  */ @Configuration @Import(TestConfig.Test.class) @ConditionalOnBean(Resource.class) public class TestConfig {      @ConditionalOnClass(Resource.class)     @ComponentScan(""org.xyattic.boot.calkin.demo.oauth2.test"")     class Test {      }  } ``` The package `org.xyattic.boot.calkin.demo.oauth2.test` by default is not scanned. When I activated it under certain conditions, I found that `@ComponentScan` was also activated when the condition was not met. ```java TestConfig:       Did not match:          - @ConditionalOnBean (types: org.springframework.core.io.Resource; SearchStrategy: all) did not find any beans of type org.springframework.core.io.Resource (OnBeanCondition)     TestConfig.Test:       Did not match:          - Ancestor org.xyattic.boot.calkin.demo.oauth2.server.config.TestConfig did not match (ConditionEvaluationReport.AncestorsMatchedCondition)       Matched:          - @ConditionalOnClass found required class 'org.springframework.core.io.Resource' (OnClassCondition) ``` The log shows as not matching. And the following will not accidentally activate. ```java @Configuration @Import(TestConfig.Test.class) //@ConditionalOnBean(Resource.class) @ConditionalOnProperty(""test.enabled"") public class TestConfig {      @ConditionalOnClass(Resource.class)     @ComponentScan(""org.xyattic.boot.calkin.demo.oauth2.test"")     class Test {      }  } ```","open","in: core,","wangxing-git","2019-06-28T08:05:50Z","2019-12-05T09:31:43Z"
"","23007","How to configure spring-context.xml for @ContextConfiguration to compile into Test.jar and command line can executes","import org.testng.annotations.Test; @ContextConfiguration(locations = {""classpath:spring-context.xml""}) public class Test extends AbstractTestNGSpringContextTests{        @Test 	public void Test(){ 		System.out.println(""1111111111111""); 	} } The project is compiled into Test.jar, spring-context.xml in the top-level directory of Test.jar, and the **command line executes** :java-jar Test.jar-testclass com. *.Test，The error is as follows：“Failed to load ApplicationContext” ， loading spring-context.xml‘s context path .How to configure spring-context.xml for @ContextConfiguration to compile into Test.jar  INFO: TEST [Command line test] SKIPPED at [09:12:20 2019-05-21] - Failed to load ApplicationContext org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:94) org.springframework.test.context.DefaultTestContext.getApplicationContext(DefaultTestContext.java:72) org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:117) org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:212) org.springframework.test.context.testng.AbstractTestNGSpringContextTests.springTestContextPrepareTestInstance(AbstractTestNGSpringContextTests.java:145) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) java.lang.reflect.Method.invoke(Unknown Source) org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:84) org.testng.internal.Invoker.invokeConfigurationMethod(Invoker.java:564) org.testng.internal.Invoker.invokeConfigurations(Invoker.java:213) org.testng.internal.Invoker.invokeConfigurations(Invoker.java:138) org.testng.internal.TestMethodWorker.invokeBeforeClassMethods(TestMethodWorker.java:175) org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:107) org.testng.TestRunner.privateRun(TestRunner.java:767) org.testng.TestRunner.run(TestRunner.java:617) org.testng.SuiteRunner.runTest(SuiteRunner.java:348) org.testng.SuiteRunner.runSequentially(SuiteRunner.java:343) org.testng.SuiteRunner.privateRun(SuiteRunner.java:305) org.testng.SuiteRunner.run(SuiteRunner.java:254) org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52) org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86) org.testng.TestNG.runSuitesSequentially(TestNG.java:1224) org.testng.TestNG.runSuitesLocally(TestNG.java:1149) org.testng.TestNG.run(TestNG.java:1057) org.testng.TestNG.privateMain(TestNG.java:1364) org.testng.TestNG.main(TestNG.java:1333)","closed","for: stackoverflow,","fengwenni","2019-05-21T02:32:05Z","2019-05-21T06:18:04Z"
"","23426","ConcurrentModificationException during setHeader for MockHTTPServletResponse during setRedirection","[TestSpringProject.zip](https://github.com/spring-projects/spring-framework/files/3475181/TestSpringProject.zip)  **Affects:** 5.1.7.RELEASE  ---   Hi  We are getting a concurrent modification exception sometimes when our tests run in Jenkins. I have attached a test project to reproduce the issue. I could see there are changes in master for HeaderValueHolder class but do we have any plan for backporting those changes?  To run the attached project just run TestControllerTest test. It might take a minute or two to get the exception.  Caused by: java.util.ConcurrentModificationException 	at java.util.LinkedHashMap$LinkedHashIterator.nextNode(LinkedHashMap.java:719) 	at java.util.LinkedHashMap$LinkedKeyIterator.next(LinkedHashMap.java:742) 	at org.springframework.mock.web.HeaderValueHolder.getByName(HeaderValueHolder.java:98) 	at org.springframework.mock.web.MockHttpServletResponse.containsHeader(MockHttpServletResponse.java:383) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) 	... 32 more  Thanks","closed","status: duplicate,","Hello629","2019-08-07T04:32:10Z","2019-08-21T10:45:40Z"
"","23152","Bean validation doesn't work with Kotlin coroutine controller","**Affects:Spring 5.2.0.M2**   ---   Same issue as mentioned [here](https://github.com/konrad-kaminski/spring-kotlin-coroutine/issues/38)  Adding a `@Validated` annotation  to a coroutine `@RestController` throws an `ArrayIndexOutOfBoundsException`  Using Spring Boot 2.2.0.M3 and Coroutines 1.3.0-M1  ```java java.lang.ArrayIndexOutOfBoundsException: 2 	at java.util.Arrays$ArrayList.get(Arrays.java:3841) ~[na:1.8.0_181] 	at org.hibernate.validator.internal.metadata.aggregated.ParameterMetaData$Builder.build(ParameterMetaData.java:169) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.findParameterMetaData(ExecutableMetaData.java:435) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:388) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:192) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.lambda$getBeanMetaData$0(BeanMetaDataManager.java:160) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_181] 	at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:159) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.engine.ValidationContext$ValidationContextBuilder.forValidateParameters(ValidationContext.java:619) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:254) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:224) ~[hibernate-validator-6.0.12.Final.jar:6.0.12.Final] 	at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:97) ~[spring-context-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) ~[spring-aop-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.kotlin.experimental.coroutine.web.CoroutineController$$EnhancerBySpringCGLIB$$220f8cfd.delayedMultiply() ~[classes/:na] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_181] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_181] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_181] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_181] 	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) ~[spring-web-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) ~[spring-web-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:891) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:866) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) ~[tomcat-embed-core-8.5.34.jar:8.5.34] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) ~[spring-webmvc-5.0.9.RELEASE.jar:5.0.9.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) ~[tomcat-embed-core-8.5.34.jar:8.5.34] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-8.5.34.jar:8.5.34]` ```","closed","status: duplicate,","FearlessHyena","2019-06-19T08:37:52Z","2021-04-07T07:50:22Z"
"","23154","FilePart transferTo fails with java.nio.file.NoSuchFileException","**Affects:** Spring boot 2.2.0.M3 --- Hello, I just trying the sample [here](https://github.com/sdeleuze/webflux-multipart) and found the same bug referenced in this closed issue #21089 My code can be found in this commit https://github.com/TheGhostShell/Lily/commit/e4fbd8319d0ad2a9787783443cc9a6bf0c345439 I don't know if I missing something or doing wrong. Thanks","closed","status: duplicate,","John-Dormevil","2019-06-19T12:41:50Z","2019-06-24T11:45:31Z"
"","23517","Wiki build instructions for local Maven repo are outdated","**Affects:** project wiki / 5.2.0.BUILD-SNAPSHOT  ---  Commit 7ce1f5e652fee3f0e21925ac12f0882d733badb3 (related to #23282) changes gradle task used for pushing artifacts to local maven repository, making instructions on project wiki obsolete:  https://github.com/spring-projects/spring-framework/wiki/Build-from-Source  `./gradlew install -x javadoc`  results in `Task 'install' not found in root project 'spring'.` error. Correct comand is:  `./gradlew publishToMavenLocal -x javadoc`  This change is not compatible with branches 5.1.x and earlier, so perhaps wiki article should be expanded to reflect that or install task should be restored to preserve old behavior.","closed","type: documentation,","jlawrynowicz","2019-08-25T22:33:52Z","2019-08-27T09:47:11Z"
"","23648","Webflux: java.lang.IllegalStateException: java.lang.IllegalStateException: Socket couldn't be stopped within 3000ms","**Affects:** \Spring-WebFlux 5.1.9:RELEASE  Hello, I catch this error often on Debian 9 and very rarely on Windows 10 (OpenJDK 12.0.2+10).  I do this:  1. Create very long `WebClient` responses chain; 2. Subscribe to the `Publisher` and set the `Disposable` to a member value of `Configuration` class; 3. In `onComplete` i can publish a special async (For ex: `SpecEvent`) event to `Configuration`; 4. (AsyncEventListener) In `SpecEventHandler` i invoke `dispose()`, sleep one second and close current `ApplicationContext`; 5. And I get such error:  ``` [17:56:07][Step 1/1] java.lang.IllegalStateException: java.lang.IllegalStateException: Socket couldn't be stopped within 3000ms [17:56:07][Step 1/1] 	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext$ServerManager.stop(ReactiveWebServerApplicationContext.java:233) [17:56:07][Step 1/1] 	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.stopAndReleaseReactiveWebServer(ReactiveWebServerApplicationContext.java:157) [17:56:07][Step 1/1] 	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.onClose(ReactiveWebServerApplicationContext.java:151) [17:56:07][Step 1/1] 	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1032) [17:56:07][Step 1/1] 	at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:975) [17:56:07][Step 1/1] 	at com.myexample.external.pendingResolver.PendingResolver.handleStopEvent(PendingResolver.java:112) // My async handler [17:56:07][Step 1/1] 	at com.myexample.external.pendingResolver.PendingResolver$$FastClassBySpringCGLIB$$2fb70d9d.invoke() [17:56:07][Step 1/1] 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) [17:56:07][Step 1/1] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) [17:56:07][Step 1/1] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [17:56:07][Step 1/1] 	at org.springframework.aop.interceptor.AsyncExecutionInterceptor.lambda$invoke$0(AsyncExecutionInterceptor.java:115) [17:56:07][Step 1/1] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) [17:56:07][Step 1/1] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [17:56:07][Step 1/1] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [17:56:07][Step 1/1] 	at java.base/java.lang.Thread.run(Thread.java:835) [17:56:07][Step 1/1] Caused by: java.lang.IllegalStateException: Socket couldn't be stopped within 3000ms [17:56:07][Step 1/1] 	at reactor.netty.DisposableChannel.disposeNow(DisposableChannel.java:98) [17:56:07][Step 1/1] 	at reactor.netty.DisposableChannel.disposeNow(DisposableChannel.java:82) [17:56:07][Step 1/1] 	at org.springframework.boot.web.embedded.netty.NettyWebServer.stop(NettyWebServer.java:120) [17:56:07][Step 1/1] 	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext$ServerManager.stop(ReactiveWebServerApplicationContext.java:230) [17:56:07][Step 1/1] 	... 14 common frames omitted [17:56:07][Step 1/1] Process exited with code 0 ```  I can increase my sleep time, and the error will appear less.  Also i found the similar [issue](https://github.com/apache/dubbo/issues/4727).","closed","","Bittuw","2019-09-17T15:30:29Z","2021-01-08T13:09:13Z"
"","23079","I think that 0(zero) is appropriate as ControllerAdvice's order default.","**Affects:** \Spring framework 5.1.6.RELEASE  ---  I think that 0(zero) is appropriate as ControllerAdvice's order default better than current default value Ordered.LOWEST_PRECEDENCE. I used `@Order(Ordered.LOWEST_PRECEDENCE)` and expected that is lower priority than `@Order` unannotated. However, `@Order(Ordered.LOWEST_PRECEDENCE)` ControllerAdviser and `@Order` unannotated ControllerAdviser are in contention. So, A Exception handled sometimes `@Order(Ordered.LOWEST_PRECEDENCE)` ControllerAdviser, sometimes `@Order` unannotated ControllerAdviser. Of course, This priority not changed after running Spring application, But changed after packaging for build situations. The method `initOrderFromBeanType` in `org.springframework.web.method.ControllerAdviceBean` is return default Ordered.LOWEST_PRECENDENCE if order is null. I think spring users want to divide into low priority groups, high priority groups and general groups. For now, If I want to assign Ordered.LOWEST_PRECEDENCE to a ControllerAdviser's order, I should annotated something like `@Order(0)` for all even uninteresting ControllerAdviser. But, If ControllerAdviser's default priority is 0(zero), spring users use `@Order(Ordered.LOWEST_PRECEDENCE)` to assign lowest priority than other ControllerAdviser components.  how do you think of this suggestion?","closed","status: declined,","jaoromi","2019-06-04T05:54:01Z","2019-06-19T11:25:18Z"
"","23078","Mongo transactions Manager bean presence alters behaviour of save() for JPA repositories","**Affects:** \Spring framework 5.1, Spring boot - 2.1.1.RELEASE  ---   I have a use case to use Mongo transactions. For enabling transactions i followed the mongo transaction document In my application I have MySql DB connections as well.  Upon creating the mongo transaction bean, the JPA repositories save() method is not persisting data.  The JPA repositories save method works well, if I comment out MongoTransactionManager bean: ``` public class MongoTransactionConfiguration  extends AbstractMongoConfiguration {      @Autowired     private MongoProperties props;  /*    @Bean     MongoTransactionManager transactionManager(MongoDbFactory dbFactory) {         return new MongoTransactionManager(dbFactory);     }*/      @Override     public MongoClient mongoClient() {         return new MongoClient(new MongoClientURI(props.getUri()));     }      @Override     protected String getDatabaseName() {         return props.getDatabase();     } } ``` The sample code is available in github In this example I'm connecting to local host mysql, and as part of @PostConstruct of Application class, will try to populate a table.  The table gets populated when mongo transaction bean does not exists. But when the MongoTransactionBean exists nothing gets populated.  I expect to have MongoTransactions enabled and proper functioning of mysql save(). Could someone help me figure out how to overcome this issue?  Stackoverflow : https://stackoverflow.com/questions/56424920/mongo-transactions-manager-bean-presence-alters-behaviour-of-save-for-jpa-repo","open","in: core,","KencyK","2019-06-04T04:48:00Z","2021-11-10T12:00:12Z"
"","23332","@MatrixVariable auto convert to Pojo","**Affects:** \5.1.8 Feature request: I would like to be able to use MatrixVariable to directly create a Pojo ex: ``` @GetMapping(""/employee-skills/{id}"") public ResponseEntity getEmployeeSkill(@MatrixVariable(pathVar = ""id"") EmployeeSkillId employeeSkillId) { ``` instead of  ``` @GetMapping(""/employee-skills/{id}"") public ResponseEntity getEmployeeSkill(@MatrixVariable(pathVar = ""id"") Map id) {     final ObjectMapper mapper = new ObjectMapper(); // jackson's objectmapper     final EmployeeSkillId employeeSkillId = mapper.convertValue(id, EmployeeSkillId.class); ``` ---","open","in: web,","yelhouti","2019-07-23T03:23:32Z","2021-11-10T12:16:38Z"
"","23096","WebFlux with Tomcat, intermittent timeout when creating response","**Affects:** \5.1.7.RELEASE  ---  I am running a spring-boot application which is using WebFlux with Tomcat as the underlying http server. In my real application with fairly high request rate, I noticed in metrics what appeared to be a slow leak in tomcat connections. I have since added a WebFilter to implement a response timeout, and this confirmed that a low volume of responses were never being completed. With the WebFilter in place, the observed connection leak is fixed - but I would like to resolve the response timeouts.  I have created a relatively simple isolated demo project which reproduces the issue here: https://github.com/danielra/webflux_response_timeout_repro  The project can be built via `./gradlew clean build` and then run via `java -jar ./build/libs/demo-0.0.1-SNAPSHOT.jar`. To reproduce the issue with the demo project I have then been using `wrk` ( https://github.com/wg/wrk ) to throw load against the running application.  For example: ``` $ ./wrk -c 20 -t 16 -d 300 http://localhost:8080/get --latency Running 5m test @ http://localhost:8080/get   16 threads and 20 connections   Thread Stats   Avg      Stdev     Max   +/- Stdev     Latency     1.04ms    5.38ms 335.15ms   98.55%     Req/Sec     1.62k   280.92     4.75k    79.07%   Latency Distribution      50%  508.00us      75%  762.00us      90%    2.00ms      99%    7.48ms   7719452 requests in 5.00m, 28.98GB read   Socket errors: connect 0, read 7, write 0, timeout 1 Requests/sec:  25723.26 Transfer/sec:     98.89MB ``` Note that for this 5 minutes of load, 1 timeout was observed. The corresponding application console output was as follows: ``` $ java -jar ./build/libs/demo-0.0.1-SNAPSHOT.jar    .   ____          _            __ _ _  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.1.5.RELEASE)  2019-06-06 16:41:14.795  INFO 18437 --- [           main] com.example.demo.DemoApplication         : Starting DemoApplication on machine1 with PID 18437 (/home/daniela/webflux_response_timeout_repro/demo/build/libs/demo-0.0.1-SNAPSHOT.jar started by daniela in /home/daniela/webflux_response_timeout_repro/demo) 2019-06-06 16:41:14.798  INFO 18437 --- [           main] com.example.demo.DemoApplication         : No active profile set, falling back to default profiles: default 2019-06-06 16:41:15.642  INFO 18437 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http) 2019-06-06 16:41:15.676  INFO 18437 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat] 2019-06-06 16:41:15.676  INFO 18437 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.19] 2019-06-06 16:41:16.229  INFO 18437 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path '' 2019-06-06 16:41:16.231  INFO 18437 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 1.772 seconds (JVM running for 2.188) Response timeout after 10001 milliseconds for GET request with uri 'http://localhost:8080/get'. Response status code was already committed: '200 OK'. 2019-06-06 16:46:09.230 ERROR 18437 --- [io-8080-exec-12] o.s.w.s.adapter.HttpWebHandlerAdapter    : [67fec09] Error [java.lang.IllegalStateException: Async operation timeout.] for HTTP GET ""/get"", but ServerHttpResponse already committed (200 OK) 2019-06-06 16:46:09.238 ERROR 18437 --- [io-8080-exec-12] o.a.c.c.C.[.[.[/].[httpHandlerServlet]   : Servlet.service() for servlet [httpHandlerServlet] threw exception  java.lang.IllegalStateException: Async operation timeout.         at org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseAsyncListener.onTimeout(ServletServerHttpResponse.java:208) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE]         at org.apache.catalina.core.AsyncListenerWrapper.fireOnTimeout(AsyncListenerWrapper.java:44) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.catalina.core.AsyncContextImpl.timeout(AsyncContextImpl.java:133) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:153) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:241) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:53) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:836) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1747) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_181]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_181]         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]  2019-06-06 16:46:09.239 ERROR 18437 --- [io-8080-exec-12] o.a.c.c.C.[.[.[/].[httpHandlerServlet]   : Servlet.service() for servlet [httpHandlerServlet] in context with path [] threw exception [Failed to create response content] with root cause  java.lang.IllegalStateException: Async operation timeout.         at org.springframework.http.server.reactive.ServletServerHttpResponse$ResponseAsyncListener.onTimeout(ServletServerHttpResponse.java:208) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE]         at org.apache.catalina.core.AsyncListenerWrapper.fireOnTimeout(AsyncListenerWrapper.java:44) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.catalina.core.AsyncContextImpl.timeout(AsyncContextImpl.java:133) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.catalina.connector.CoyoteAdapter.asyncDispatch(CoyoteAdapter.java:153) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.coyote.AbstractProcessor.dispatch(AbstractProcessor.java:241) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:53) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:836) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1747) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_181]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_181]         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.19.jar!/:9.0.19]         at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181] ```  The line `Response timeout after 10001 milliseconds for GET request with uri 'http://localhost:8080/get'. Response status code was already committed: '200 OK'.` is from the WebFilter included in the demo project. In this case there was also an apparently corresponding IllegalStateException logged, though in other runs I don't always see this sort of exception logged when the WebFilter's log line appears.  For quick reference, the Controller method which handles the relevant requests in the demo project can be seen here: https://github.com/danielra/webflux_response_timeout_repro/blob/master/src/main/java/com/example/demo/controller/DemoController.java#L30 And the WebFilter that implements the response timeout can be seen here: https://github.com/danielra/webflux_response_timeout_repro/blob/master/src/main/java/com/example/demo/filter/DemoWebFilter.java#L25  Note that while the timeout is set to 10 seconds in this example, the responses seem to never be completed regardless of how long is waited. Apparently leaked tomcat connections could be observed building up for more than a week in my real application's metrics.  Please let me know if there is anything additional from my end that would be helpful in understanding and resolving this issue. Thank you for your time!","closed","type: bug,","danielra","2019-06-07T00:44:28Z","2019-09-09T17:15:05Z"
"","23388","Webclient getCookies() returns only one cookie when there is duplicate cookie in header","**Affects:** \5.1.4.RELEASE  ---   Spring-boot : 2.1.2.RELEASE Spring-webflux : 5.1.4.RELEASE reactor-netty : 0.8.4.RELEASE  When response header have many Set-Cookie header with same key like as shown below webclient clientResponse.cookies() return only the first cookie    ``` Set-Cookie : CookieKey=firstCookieValue expires=Tue, 30-Jul-2019 11:17:56 GMT; path=/; HttpOnly Set-Cookie : CookieKey=SecondCookieValue; path=/ ```","closed","status: invalid,","Odysseymoon","2019-07-31T00:58:18Z","2019-07-31T09:37:43Z"
"","22945","Minor documentation issue for Validators","**Affects:** \5.0.0.M1  Hi, in the code snippet for the [`CustomerValidator`](https://docs.spring.io/spring-framework/docs/5.0.0.M1/spring-framework-reference/html/validation.html#validator) a quote went missing  Actual: ```java //...     public CustomerValidator(Validator addressValidator) {         // ...         if (!addressValidator.supports(Address.class)) {             throw new IllegalArgumentException(""The supplied [Validator] must "" +                 support the validation of [Address] instances."");         }         // ...     } //... ```  Expected: ```java //...     public CustomerValidator(Validator addressValidator) {         // ...         if (!addressValidator.supports(Address.class)) {             throw new IllegalArgumentException(""The supplied [Validator] must "" +                 ""support the validation of [Address] instances."");         }         // ...     } //... ```  Hope this is the right issue tracker to submit it to. If there's a repo for the documentation, please let me know and I can attach a PR to the issue next time :smile:   ---","closed","status: duplicate,","Anticom","2019-05-11T17:34:09Z","2019-05-12T07:36:33Z"
"","23264","FlowExecutionImpl does not have the serialVersionUID defined","**Affects:** \2.3.4.RELEASE  --- I'm running into an issue that's awfully similar to SPR-4826.  My issue is upgrading from spring-webflow 2.0.9.RELEASE to 2.3.4.RELEASE -- my previously existing snapshots can no longer be loaded/deserialized/unmarshalled:  `java.io.InvalidClassException: org.springframework.webflow.engine.impl.FlowExecutionImpl; local class incompatible: stream classdesc serialVersionUID = 507164007291131518, local class serialVersionUID = -4659689664429207075`  So I tried to approach it by hardcoding `private static final long serialVersionUID = -4659689664429207075L;` just like the fix for SPR-4826, but it's still throwing the same error, so maybe I missed a class/step?  What's my best option to approach this?","closed","for: external-project,","nmargono","2019-07-09T20:33:30Z","2019-07-10T15:51:57Z"
"","23123","method postForObject in RestTemplate causes NPE","**Affects:** \<4.3.13-RELEASE> --- Hi,    When I was using postForObject method of RestTemplate, it may occur NPE. after debuggging, I found the exception was caused by 772 line in org.springframework.web.client.RestTemplate.java ```java public void doWithRequest(ClientHttpRequest request) throws IOException {     if (this.responseType != null) {         Class responseClass = null;         if (this.responseType instanceof Class) {             responseClass = (Class) this.responseType;         }         List allSupportedMediaTypes = new ArrayList();         for (HttpMessageConverter converter : getMessageConverters()) {             if (responseClass != null) {                 if (converter.canRead(responseClass, null)) {        //converter may be null, so NPE may occur. and I don't know why it may be null, and why not do something to prevent this exception occuring                     allSupportedMediaTypes.addAll(getSupportedMediaTypes(converter));                 }             }             else if (converter instanceof GenericHttpMessageConverter) {                 GenericHttpMessageConverter genericConverter = (GenericHttpMessageConverter) converter;                 if (genericConverter.canRead(this.responseType, null, null)) {                     allSupportedMediaTypes.addAll(getSupportedMediaTypes(converter));                 }             }         }         if (!allSupportedMediaTypes.isEmpty()) {             MediaType.sortBySpecificity(allSupportedMediaTypes);             if (logger.isDebugEnabled()) {                 logger.debug(""Setting request Accept header to "" + allSupportedMediaTypes);             }             request.getHeaders().setAccept(allSupportedMediaTypes);         }     } } ``` I don't know whether the exception occers because I used such expression such as  ```java restTemplate.getMessageConverters().add(0,new StringHttpMessageConverter(Charset.forName(""UTF-8""))); ``` or ```java rest = new RestTemplate(); rest.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); ``` After the exception occured, I need restart my project, however, it may occur again after sometimes. I do hope someone can give me some hints, thanks!","closed","status: superseded,","TRockis","2019-06-13T01:31:23Z","2019-06-18T11:53:53Z"
"","23820","Why escaped comma is the delimiter for `@RequestParam List`?","**Affects:** \< Spring Boot 2.1.2.RELEASE>  ---  I have a simple rest controller with the method the get requests mapped on: ```java @GetMapping(""/cis_list"") public Map cisList(@RequestParam(value = ""cis"") List cis) {         log.debug(""#cisList: started with cisIds = {}"", cis);         return cisService.findByIds(cis);     } ```  I try to pass string **hello, world!** as a single element of _List cis_ parameter: >curl -X GET ""http://127.0.0.1:8095/api/v3/facade/cis/cis_list?cis=hello%2C%20world!"" -H ""accept: */*""   I have expected the list contains only one string but аs it turned the list contains two elements although the comma has been escaped in source request.  ![image](https://user-images.githubusercontent.com/23580186/66923800-27e71f00-f032-11e9-8539-e7642f9527df.png)  In this way there's not a difference between requests: >curl -X GET ""http://127.0.0.1:8095/api/v3/facade/cis/cis_list?cis=hello%2C%20world!"" -H ""accept: */*""   and  >curl -X GET ""http://127.0.0.1:8095/api/v3/facade/cis/cis_list?cis=hello,%20world!"" -H ""accept: */*""   So, I'm not able to map parameters of HTTP GET requests to Java List if they contain escaped commas.","closed","status: declined,","akrikheli","2019-10-16T13:41:37Z","2022-03-05T14:44:52Z"
"","23466","import spring source code fail. I'm going crazy","**Affects:** \  I reference import-into-idea.md ，but it is fail. It took me a lot of time！  > environment：  - idea201902 - gradle 4.8 | gradle 5.6 - jdk 1.8 - aspects 1.9  > Various problems  ` Error:(26, 34) java: 程序包org.apache.commons.logging不存在  Error:(350, 51) java: 找不到符号   符号:   变量 CoroutinesUtils   位置: 类 org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar  Error:(26, 38) java: 找不到符号   符号:   类 InstrumentationSavingAgent   位置: 程序包 org.springframework.instrument `  > My steps  1. down spring-framework branch of master 2. gradlew.bat :spring-oxm:compileTestJava 3. Import into IntelliJ (File -> New -> Project from Existing Sources -> Navigate to directory -> Select build.gradle) 4. gradle spring-core:compileTestJava 5. gradle spring-beans:compileTestJava 6. gradle spring-context:compileTestJava 7. Configuring the aspects compiler for spring-aop 8. gradle spring-aspects :compileTestJava 9. new mytest Module ``` dependencies {     compile(project("":spring-context""))     compile(project("":spring-beans""))     compile(project("":spring-core"")) } ``` 10. my test code , ``` public static void main(String[] args) { 		BeanFactory xmlBf = new XmlBeanFactory(new ClassPathResource(""beanFactoryTest.xml"")); 		MyTestBean myTestBean = (MyTestBean) xmlBf.getBean(""myTestBean""); 		System.out.println(""myTestBean.Name = "" + myTestBean.getName()); 	}  ``` ---","closed","","youngfuture","2019-08-16T04:24:01Z","2022-07-14T08:00:14Z"
"","23722","Endpoints at Reactive routes require a prefix ""/"" but @RequestMapping and others works even without it.","**Affects:** \  --- If we have use `@GetMapping (""hello"")` or `@GetMapping(""/hello"")` both works seamlessly .Example: -  ```java @GetMapping(""user/{userId}"") public Optional getUser(@PathVariable(""userId"") Long id) { 	logger.info("" User id {}"", id); 	return userRepository.findById(id); } ```  With Reactive Routes it is not same, it accepts only with prefix ""/"" which is counter intuitive. Example  : -    ```java @Bean     public RouterFunction userRoutes() {         return RouterFunctions.route(                 RequestPredicates.GET(""/users""), userHandler::getAll)                 .andRoute(RequestPredicates.POST(""/user""), userHandler::add)                 .andRoute(RequestPredicates.PUT(""/user""), userHandler::update)                 .andRoute(RequestPredicates.GET(""/user/{id}""), userHandler::get)                 .andRoute(RequestPredicates.DELETE(""/user/{id}""), userHandler::delete);     } ```  It might not be a bug but certainly can be an enhancement.","closed","status: duplicate,","CODINGSAINT","2019-09-27T16:53:33Z","2019-10-15T10:42:13Z"
"","23520","build source code failed","**Affects:** \  ---  when i build source code ,the gradle plugin build error there is no class named **org/gradle/api/plugins/internal/JvmPluginsHelper** my gradle version is 5.5.1","closed","","thyu-xiaoya","2019-08-26T16:40:34Z","2019-09-09T17:25:20Z"
"","23652","Cannot build with javadoc errors for class ConcurrentReferenceHashMap","**Affects:** \  ---  Trying to run `./gradlew build` with spring-framework-5.1.x project. Got javadoc error:  com.sun.tools.javac.code.ClassFinder$BadClassFile: Erroed class file: E:\Programming\LearningResource\spring-framework-5.1.x\spring-core\build\libs\spring-core-5.1.10.BUILD-SNAPSHOT.jar(/org/springframework/util/ConcurrentReferenceHashMap$1.class)  ConcurrentReferenceHashMap$1(org.springframework.util.ConcurrentReferenceHashMap,org.springframework.util.ConcurrentReferenceHashMap.TaskOption[],boolean,java.lang.Object)","closed","","xiaoyiMia","2019-09-18T02:17:31Z","2019-09-24T13:05:59Z"
"","23696","spring cache's `sync` option behavior","**Affects:** \  ---   Hello.  When I give `sync` option to spring cacheable method, `put` method of spring `Cache` instance would not be called.   ### Cacheable Method ```     @Cacheable(value = CacheName.KEY_VISUALIZE_MAP, keyGenerator = ""jsonCacheKeyGenerator"", sync=true)     public ABC get(Object param) {     } ```  when I set sync=true   ### Cache Manager ``` @Component public class MyCacheManager extends AbstractCacheManager {      @Override     protected Collection loadCaches() {         String name = ""MY_CACHE"";         CaffeineCache caffeineCache = new CaffeineCache(name, Caffeine.newBuilder().expireAfterWrite(12, TimeUnit.HOURS).maximumSize(10000).build());         Cache springWrapper = new Cache() {             @Override             public String getName() {                 return name;             }              @Override             public Object getNativeCache() {                 return caffeineCache;             }              @Override             public ValueWrapper get(Object key) {                 return caffeineCache.get(key);             }              @Override             public  T get(Object key, Class type) {                 return caffeineCache.get(key, type);             }              @Override             // fine called when sync enabled             public  T get(Object key, Callable valueLoader) {                 return caffeineCache.get(key, valueLoader);             }              @Override            //  never called when sync enabled             public void put(Object key, Object value) {                  caffeineCache.put(key, value);              }              @Override            // never called when sync enabled             public ValueWrapper putIfAbsent(Object key, Object value) {                  return caffeineCache.putIfAbsent(key, value);              }              @Override             public void evict(Object key) {                 caffeineCache.evict(key);             }              @Override             public void clear() {                 caffeineCache.clear();             }         };         return Collections.singletonList(springWrapper);     } } ```  ### Without sync, get and put called well. ```     @Cacheable(value = ""MY_CACHE"", keyGenerator = ""jsonCacheKeyGenerator"")     public ABC get(Object param) {     } ```  Where should I check out for this?","closed","for: stackoverflow,","jeesim2","2019-09-25T07:24:09Z","2019-09-25T07:44:10Z"
"","23581","is this the problem of jdk version，I use jdk8，latest source code","**Affects:** \  ---   Error:(138, 37) java: 不兼容的类型: org.springframework.beans.support.PropertyComparator无法转换为java.util.Comparator  public static void sort(List source, SortDefinition sortDefinition) throws BeansException { 		if (StringUtils.hasText(sortDefinition.getProperty())) { 			source.sort(new PropertyComparator<>(sortDefinition)); 		} 	}","closed","status: invalid,","13567436138","2019-09-04T08:27:38Z","2020-03-30T10:20:04Z"
"","23411","test issue for spring security conflict with spring data","**Affects:** \  ---    test issue for spring security conflict with spring data","closed","status: invalid,","hamid3764","2019-08-03T08:02:00Z","2019-08-03T08:52:31Z"
"","23750","Match route paths ignoring case sensitivity when using yml configuration files","**Affects:** \  ---","closed","for: external-project,","xBentu","2019-10-02T16:52:07Z","2019-10-02T20:52:00Z"
"","23492","Git API returns empty license type for this repository - Add mandatory license file","**Affects:** \  ---","closed","type: task,","amaendeepm","2019-08-20T15:27:26Z","2019-08-20T20:01:53Z"
"","23222","Good","**Affects:** \  ---","closed","status: invalid,","Khonak","2019-07-01T11:31:22Z","2019-07-01T11:44:44Z"
"","23218","gfgsdsgsdgsgs","**Affects:** \  ---","closed","status: invalid,","jbp198669","2019-07-01T10:31:55Z","2019-07-01T21:16:59Z"
"","23161","when i new a project with spring-framework 5.1.x, and run it,Error:(19, 28) Kotlin: Unresolved reference: core was occured","**Affects:** \  ---","closed","status: invalid,","bai597030001","2019-06-20T02:51:22Z","2019-06-20T05:59:20Z"
"","23021","SpringMVC 5.1.7 application/json not support？","**Affects:** \  ---","closed","status: invalid,","GreatPencil","2019-05-23T18:58:57Z","2019-05-24T13:56:52Z"
"","22958","eifjccgievuriinbjjechfurrivvnivkhilgduvdvblc","**Affects:** \  ---","closed","","asdhanapal","2019-05-13T13:28:22Z","2021-01-08T13:09:08Z"
"","22841","就没看到中文评？","**Affects:** \  ---","closed","","AconHu","2019-04-26T06:46:18Z","2019-04-27T07:29:03Z"
"","23571","Memory leak when using @Async after upgrading from 5.1 to 5.2","**Affects:** 5.2.0.RC1  ---  In our application I upgraded from spring-framework 5.1.9 to 5.2.0.RC1 and our tests started leaking memory.  Previously it looked like this in VisualVM:  ![image](https://user-images.githubusercontent.com/109243/64158877-8d43cf80-ce39-11e9-8582-85357e439198.png)  And now it looks like this:  ![image](https://user-images.githubusercontent.com/109243/64158907-9b91eb80-ce39-11e9-963a-e2c08716f55a.png)  I've made a heapdump to see where the memory is going:  ![image](https://user-images.githubusercontent.com/109243/64163425-8325cf00-ce41-11e9-922d-886c6feac4e4.png)  I've seen something similar in our application previously, but that was solved by using `@MockBean` instead of a lot of `@ContextConfiguration` with `@Configuration` classes inside our test classes to override beans with mocked objects :thinking:...","closed","status: feedback-provided,","arian","2019-09-03T09:58:39Z","2019-09-18T12:30:57Z"
"","23226","MockMvc: Async result for handler [org.springframework.web.servlet.function.RouterFunctionDslKt$sam$org_springframework_web_servlet_function_HandlerFunction$0@6d4a65c6] was not set during the specified timeToWait=10000","**Affects:** 5.2.0.M3  Async tests are failed when I try to test mvc router function: `java.lang.IllegalStateException: Async result for handler [org.springframework.web.servlet.function.RouterFunctionDslKt$sam$org_springframework_web_servlet_function_HandlerFunction$0] was not set during the specified timeToWait=10000`  Spring Boot Version: 2.2.0.M4 Example:  https://github.com/FVershinin/utf8-request/blob/master/src/test/kotlin/com/example/utf8request/ApplicationTests.kt https://github.com/FVershinin/utf8-request/blob/master/src/main/kotlin/com/example/utf8request/Application.kt","open","in: test,","FVershinin","2019-07-02T04:29:38Z","2021-11-10T11:50:23Z"
"","23311","Add RSocket Interceptors","**Affects:** 5.2.0.BUILD-SNAPSHOT ---   The `WebClient` supports an `ExchangeFilterFunction` that allows intercepting the request/response. `WebClient` also allows providing attributes that can be used by `ExchangeFilterFunction` for processing. In combination this allows a user to provide an OAuth token via the attributes and have an `ExchangeFilterFunction` add the token to the request. The `ExchangeFilterFunction` can also refresh the token (a blocking operation) if the token is expired before sending the original request.  It would be nice to have the ability to have similar features with the RSocket support.","open","in: messaging,","rwinch","2019-07-17T17:12:54Z","2019-09-13T10:44:55Z"
"","23310","Support for template routes with encoded separator in RSocketRequester","**Affects:** 5.2.0.BUILD-SNAPSHOT ---   `RSocketRequester` allows a route to be provided. It would be nice if there were a simple way to perform encoding of the route. For example, if a route were `foo.{id}` and `id` contains a `.` then it would not work. It would be nice if there were a simple mechanism to encode the route.","closed","type: enhancement,","rwinch","2019-07-17T17:02:10Z","2019-07-22T13:08:05Z"
"","23448","Synchronized blocks in MethodOverrides are hurting concurrency","**Affects:** 5.1.x, 4.3.x  --- The fix for issue #18905 introduced `synchronized` blocks into the `MethodOverrides` class to fix a race condition. While this fixed the original bug, the introduction of the `synchronized` blocks is really hurting the concurrency of our application. We make use of method injection in a hot spot in our application, which has very high request concurrency. All of those requests go through `MethodOverrides`, and through these `synchronized` blocks. While the individual operations are fairly quick, it's still significant enough to cause serious concurrency degradation.  Can this class be reworked to avoid synchronized blocks?","closed","in: core,","kennymacleod","2019-08-11T23:41:12Z","2020-08-06T14:09:59Z"
"","23122","HtmlUtils Javadoc refers to deprecated Apache Commons Lang","**Affects:** 5.1.x  --- The javadoc for [HtmlUtils](https://github.com/spring-projects/spring-framework/blob/5.1.x/spring-web/src/main/java/org/springframework/web/util/HtmlUtils.java) refers users to the Apache Commons Lang [StringEscapeUtils ](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringEscapeUtils.html) class        * For a comprehensive set of String escaping utilities,      * consider Apache Commons Lang and its StringEscapeUtils class.  But that is now deprecated and moved to commons-text as of 3.6. If this advice still applies, please update the javadoc to refer to the new location for the class.   Alternatively, since commons lang is no longer required, consider using commons-text in Spring rather than maintaining separate string processing methods.","closed","in: web,","pthorson","2019-06-12T21:21:21Z","2019-06-14T11:52:44Z"
"","22957","AnnotatedElementUtils.findMergedAnnotation not working for javax annotations (e.g. NotNull)","**Affects:** 5.1.x  ---   Meta-annotations not being scanned for any package that begins with the ""java"" string, which includes the javax package.  The utility the method `AnnotationUtils.hasPlainJavaAnnotationsOnly` is checking if the class name starts with ""java"" instead of ""java.""  Previously using `AnnotatedElementUtils.findMergedAnnotation` we could have an element annotated with `javax.validation.constraints.NotNull` search for the meta-annotation `javax.validation.Constraint` However, this stopped working with 5.1.x because it relies on the utility method.  Excluding all packages which begin with the string ""java"" and not targeting known and specific packages is a big assumption.","closed","in: core,","bakslashr","2019-05-13T12:59:57Z","2019-06-11T21:25:58Z"
"","23508","Raise 400 instead of 500 on failure to find  index of lookupPath within requestUri in ResourceUrlEncodingFilter","**Affects:** 5.1.9  ``` java.lang.IllegalStateException: Failed to find lookupPath '/d/mixcloud/logo.png' within requestUri '/d/mixcloud/superbmixes/../logo.png'. Does the path have invalid encoded characters for characterEncoding 'UTF-8'? 	at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter$ResourceUrlEncodingRequestWrapper.initLookupPath(ResourceUrlEncodingFilter.java:102) 	at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter$ResourceUrlEncodingRequestWrapper.setAttribute(ResourceUrlEncodingFilter.java:86) 	at org.springframework.web.servlet.resource.ResourceUrlProviderExposingInterceptor.preHandle(ResourceUrlProviderExposingInterceptor.java:51) 	at org.springframework.web.servlet.HandlerExecutionChain.applyPreHandle(HandlerExecutionChain.java:136) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1034) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) 	at javax.servlet.http.HttpServlet.doHead(HttpServlet.java:245) ```  If that URI is unexpected, I think that request should result in a 400 rather than the 500 from the IllegalStateException.","closed","type: enhancement,","mixcloud-downloader","2019-08-23T09:35:49Z","2019-08-29T12:14:23Z"
"","23134","LocalSessionFactoryBean not correctly exposing EntityManagerFactory","**Affects:** 5.1.7.RELEASE --- Objective:  Expose Spring beans to hibernate for CDI support under AttributeConverters using spring version `5.1.7.RELEASE` and hibernate version `5.3.7.Final`.  Attempt: Tried to create a LocalSessionFactoryBean under my spring configuration class using the following code: ```java @Bean public LocalSessionFactoryBean entityManagerFactory() throws IOException {  	final LocalSessionFactoryBean bean = new LocalSessionFactoryBean();  	bean.setDataSource(dataSource()); 	bean.setPackagesToScan(new String[] { ""com.example.test"" });  	final Properties props = new Properties(); 	props.setProperty(""hibernate.dialect"", ""org.hibernate.dialect.Oracle10gDialect""); 	//props.setProperty(""hibernate.show_sql"", ""true""); 	props.setProperty(""hibernate.format_sql"", ""true""); 	props.setProperty(""hibernate.transaction.coordinator_class"", ""jta""); 	props.setProperty(""hibernate.transaction.jta.platform"", 	""org.hibernate.service.jta.platform.internal.JBossAppServerJtaPlatform"");  	bean.setHibernateProperties(props);  	bean.afterPropertiesSet(); 	return bean; } ``` I expect `LocalSessionFactoryBean` to built and expose the `EntityMangerFactory` which means I should be able to inject the `@PersitanceContext` under spring managed components. However the following stacktrace is thrown:  ``` Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'errorServiceImpl': Injection of persistence dependencies failed; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'javax.persistence.EntityManagerFactory' available 	at org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor.postProcessProperties(PersistenceAnnotationBeanPostProcessor.java:359) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1378) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:273) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1237) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1164) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:593) 	... 36 more Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'javax.persistence.EntityManagerFactory' available 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1087) 	at org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor.findDefaultEntityManagerFactory(PersistenceAnnotationBeanPostProcessor.java:580) 	at org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor.findEntityManagerFactory(PersistenceAnnotationBeanPostProcessor.java:543) 	at org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor$PersistenceElement.resolveEntityManager(PersistenceAnnotationBeanPostProcessor.java:711) 	at org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor$PersistenceElement.getResourceToInject(PersistenceAnnotationBeanPostProcessor.java:684) 	at org.springframework.beans.factory.annotation.InjectionMetadata$InjectedElement.inject(InjectionMetadata.java:180) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) 	at org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor.postProcessProperties(PersistenceAnnotationBeanPostProcessor.java:356) ```  Upon frustration, I tried this method to expose spring beans to hibernate: ```java @Bean() public LocalContainerEntityManagerFactoryBean entityManagerFactory(ConfigurableListableBeanFactory beanFactory) {  	final LocalContainerEntityManagerFactoryBean bean = new LocalContainerEntityManagerFactoryBean();  	bean.getJpaPropertyMap().put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(beanFactory));  	bean.setJpaVendorAdapter(new HibernateJpaVendorAdapter()); 	bean.setJtaDataSource(dataSource()); 	bean.setLoadTimeWeaver(new InstrumentationLoadTimeWeaver()); 	bean.setPackagesToScan(new String[] { ""com.example.test"" });  	final Properties props = new Properties(); 	props.setProperty(""hibernate.dialect"", ""org.hibernate.dialect.Oracle10gDialect""); 	//props.setProperty(""hibernate.show_sql"", ""true""); 	props.setProperty(""hibernate.format_sql"", ""true""); 	props.setProperty(""hibernate.transaction.coordinator_class"", ""jta""); 	props.setProperty(""hibernate.transaction.jta.platform"", 	""org.hibernate.service.jta.platform.internal.JBossAppServerJtaPlatform"");  	bean.setJpaProperties(props); 	return bean; } ``` And this now throws this new error: ``` Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean]: Factory method 'entityManagerFactory threw exception; nested exception is java.lang.NoClassDefFoundError: Failed to link org/springframework/orm/hibernate5/SpringBeanContainer (Module ""deployment.example.war:main"" from Service Module Loader): org/hibernate/resource/beans/container/spi/BeanContainer 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) 	... 36 more ```","closed","status: feedback-provided,","rooshan1234","2019-06-13T16:09:07Z","2019-06-15T13:06:05Z"
"","22991","MethodNotAllowedException cannot be handled by @ExceptionHandler on webflux","**Affects:** 5.1.7.RELEASE  ---  When I tried to handle the http `405` error with `@ExceptionHandler` I found that I couldn't catch the `MethodNotAllowedException` exception in `webflux`, which can be done in the `web mvc` by catching the `HttpRequestMethodNotSupportedException` exception. Is this a bug or is it not supported or is there another way to do it?","closed","status: invalid,","wangxing-git","2019-05-18T10:41:58Z","2019-05-20T13:06:56Z"
"","23009","Improve FreeMarker Unit Tests in spring-webflux","**Affects:** 5.1.7  --- While working on #22950 I noticed that Unit Tests `FreeMarkerConfigurerTests` and `FreeMarkerMacroTests` (like those in spring-webmvc) are missing.  Is it a deliberate choice or should we add them?","closed","status: superseded,","ielatif","2019-05-21T10:19:32Z","2019-05-26T12:47:23Z"
"","22952","WebFlux: Mono does not invoke onComplete(), but instead cancel()","**Affects:** 5.1.6.RELEASE --- Hello,  **How to reproduce**:  When I have a simple `@RestController`:  ``` @GetMapping(""monoSuccess"") public Mono monoSuccess(){     return Mono.just(""test"").log(); } ```  I can see in the Reactor logs the following:  ``` [ctor-http-nio-3] reactor.Mono.Just.1 : | onSubscribe([Synchronous Fuseable] Operators.ScalarSubscription) [ctor-http-nio-3] reactor.Mono.Just.1 : | request(unbounded) [ctor-http-nio-3] reactor.Mono.Just.1 : | onNext(test) [ctor-http-nio-3] reactor.Mono.Just.1 : | cancel() ```  This behavior does not match the bahavior of Flux.  ``` @GetMapping(""fluxSuccess"") public Flux fluxSuccess(){         return Flux.just(""test"") .log(); } ```  ``` reactor.Flux.Just.1 : | onSubscribe([Fuseable] FluxJust.WeakScalarSubscription) reactor.Flux.Just.1 : | request(1) reactor.Flux.Just.1 : | onNext(test) reactor.Flux.Just.1 : | request(32) reactor.Flux.Just.1 : | onComplete() ```  **My expectation**:  - I would expect that Mono and Flux behavior similar. - I would expect that `onComplete()` is invoked instead of `ScalarSubscription.cancel()` after `onNext`.   **My problem** : When I do a simple test with my Resilience4j CircuitBreaker operator I can see the expected behavior of Reactor.  ```   StepVerifier.create(     Mono.just(""Event"")       .log()       .transform(CircuitBreakerOperator.of(circuitBreaker))       .log())     .expectNext(""Event"")     .verifyComplete(); ```  ``` reactor.Mono.Just.1 - | onSubscribe([Synchronous Fuseable] Operators.ScalarSubscription) reactor.Mono.CircuitBreaker.2 - onSubscribe(CircuitBreakerSubscriber) reactor.Mono.CircuitBreaker.2 - request(unbounded) reactor.Mono.Just.1 - | request(unbounded) reactor.Mono.Just.1 - | onNext(Event) reactor.Mono.CircuitBreaker.2 - onNext(Event) reactor.Mono.Just.1 - | onComplete() reactor.Mono.CircuitBreaker.2 - onComplete() ```  My custom CircuitBreaker operator handles `onComplete` as a successful call and `onError` as a failed call. But `onEvent` is just forwarded to the downstream subscriber. With the current unexpected behavior I have to handle `onEvent` specially when a `Mono` is decorated.  Kind regards,  Robert","closed","type: enhancement,","RobWin","2019-05-13T09:49:28Z","2019-05-15T21:34:17Z"
"","22902","Wrong autowiring by type into collection-typed bean with multiple bounds generics","**Affects:** 5.1.6 , and I believe any previous  Autowired list of beans with multiple bounds generics may result in `ClassCastException` in the runtime due to `org.springframework.core.ResolvableType::resolveBounds` taking only the first  (`return bounds[0]`) bound into the account.  Here is the minimal reproducible example: https://github.com/d-roenko/multiple-bounds-generics/blob/03a9aad3040d69c3073510664dfb6a9bdc007cdb/src/main/java/com/example/demo/DemoApplication.java  ---","open","in: core,","d-roenko","2019-05-06T14:57:11Z","2021-11-10T12:00:11Z"
"","22853","[Regression] 404 without ACCEPT request header results in a 406 in Spring Framework 5.1.6","**Affects:** 5.1.6  Since the Upgrade from Spring-Boot-2.1.3.RELEASE to Spring-Boot-2.1.4.RELEASE, ~~any error (e.g. a 404 or an 500)~~ an expected 404 without an ACCEPT request header result in a 406 response and this message in the logs: > DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation]  This regression happens only when setting the default content type to TEXT_HTML:  ``` @Configuration class DefaultContentTypeConfiguration implements WebMvcConfigurer {  	@Override 	public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { 		configurer.defaultContentType(TEXT_HTML); 	} } ```  See https://github.com/spring-projects/spring-framework-issues/pull/191 for an example.  On a site note: This is the second bug in a very short time (the other was https://github.com/spring-projects/spring-framework/issues/22851) which goes unnoticed with Spring's classic `MockMVC` testing approach. It makes me thing that using `MockMVC` is not a too good idea any more.","closed","type: regression,","mixcloud-downloader","2019-04-29T19:35:04Z","2019-05-08T14:10:34Z"
"","22851","ResourceUrlEncodingFilter throws StringIndexOutOfBoundsException when %ED%B6 is in the URL path","**Affects:** 5.1.6  A request with %ED%B6 in the path (e.g. http://example.org/%ED%B6) will fail with a 500 http response code and this exception:          java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 2 	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:3319) ~[na:na] 	at java.base/java.lang.String.substring(String.java:1874) ~[na:na] 	at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter$ResourceUrlEncodingRequestWrapper.initLookupPath(ResourceUrlEncodingFilter.java:99) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter$ResourceUrlEncodingRequestWrapper.setAttribute(ResourceUrlEncodingFilter.java:86) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.servlet.resource.ResourceUrlProviderExposingInterceptor.preHandle(ResourceUrlProviderExposingInterceptor.java:51) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	at org.springframework.web.servlet.HandlerExecutionChain.applyPreHandle(HandlerExecutionChain.java:136) ~[spring-webmvc-5.1.6.RELEASE.jar:5.1.6.RELEASE] 	…  This only happens when having these two dependencies (managed versions by spring-boot-2.1.4.RELEASE) in the pom: - spring-boot-starter-thymeleaf - webjars-locator-core  See https://github.com/spring-projects/spring-framework-issues/pull/190 for an example.  Also for context, the complete path was %CE%D2%BA%C3%CF%EB%C4%E3%C8%C3%C8%AB%CA%C0%BD%E7%D6%AA%B5%C0%CE%D2%B0%AE%C4%E3%D0%ED%B6%E0%C4%EA%D2%D4%BA%F3%C0%CB%D7%D3%BB%D8%CD%B7%C5%AE%C8%CB%B5%C4%D1%A1%D4%F1, but it appears that only having %ED%B6 is enough for that bug.","closed","type: bug,","mixcloud-downloader","2019-04-28T22:19:02Z","2019-05-07T09:42:39Z"
"","23664","WebMVC: Non-intuitive annotation names","**Affects:** 5.1.2.RELEASE  ---  I'm coming from a project that uses JAX-RS and is currently in the process of migrating to Spring WebMVC. One of the things that struck me as odd are the names of the annotations that can be used to extract things from requests. Namely, those are `@PathVariable`, `@MatrixVariable`, `@RequestParam`, `@RequestHeader`, `@CookieValue`, and `@RequestBody`. In JAX-RS there are annotations that serve the same purpose, but their names are a bit more consistent and therefore easier to remember (at least to me):  | Spring WebMVC  | JAX-RS | | --- | --- | | `@PathVariable` | `@PathParam` | | `@MatrixVariable`  | `@MatrixParam`  | | `@RequestParam` | `@QueryParam` | | `@RequestHeader` | `@HeaderParam` | | `@CookieValue` | `@CookieParam` | | `@RequestBody` | `@BeanParam` ? |  Would it not be a good idea to get rid of the different suffixes/prefixes like variable/request/value and choose a more consistent naming?","closed","status: declined,","nictas","2019-09-18T14:50:03Z","2019-09-19T12:11:29Z"
"","23683","@Cachable serializes Map as Map","**Affects:** 5.0.9.RELEASE --- When using @Cachable on a method that returns a Map, the map is serialised as a JSON object where all fields are Strings. As a consequence, when deserialised, the Map will effectively be a Map and any subsequent get from it will likely fail (Integers never being equal to their String representation)  e.g. (code has been simplified and anonymised to adhere to company policies) ``` @Override @Cacheable(cacheNames = ""clientMap"") public Map getMap() {     Object data = apiClient.getData();     if (data == null) {         return Collections.emptyMap();     }     return data; } ``` the above code would produce a json serialisation like this: ```json {   ""1"": {""value"": ""value""}   ""2"": {""value"": ""value""}   ""3"": {""value"": ""value""} } ``` while the expected serialisation is : ```json {   1: {""value"": ""value""}   2: {""value"": ""value""}   3: {""value"": ""value""} } ``` As the first serialization causes the map to be deserialised in a Map leaving the programmer totally unaware since generics are only available at compile time.  This only seem to happen with maps. Collections are serialized just fine so I'm wandering if this has anything to do with json property names? But apparently you can change the ObjectMapper and force it to treat any map as a Map so it does seem to be a missing feature.  BTW using a custom Object mapper would apply to any map in the codebase and hence it's not a feasible solutions when you have Maps of different types that you want to serialise and cache.","closed","status: invalid,","acaligiuri","2019-09-23T20:42:39Z","2019-09-24T06:25:51Z"
"","23231","Fine-grained control on bean-overriding restriction rules in DefaultListableBeanFactory","**Affects:** 4.x, 5.0, 5.1, 5.2  ---   It's possible to allow more fine-grained control on bean-overriding restriction rules in DefaultListableBeanFactory?  In Spring 5.2 and 4.x, DefaultListableBeanFactory has only one property `allowBeanDefinitionOverriding`. But what to do If  user want to allow only some overriding like replacing of bean with `step` scoped bean, where `step` is scope coming from Spring Batch.  [The example with Spring Batch+Spring Boot+Using `step` scope](https://github.com/qwazer/spring-batch-step-scope-bean-overriding) show that in some cases fine-grained control can be useful.  Related SO questions: https://stackoverflow.com/questions/55737684/jobscope-and-overriding-beans https://stackoverflow.com/questions/35498037/spring-batch-with-scoped-beans-and-allowbeandefinitionoverriding-false","open","in: core,","qwazer","2019-07-03T15:04:14Z","2021-11-11T10:12:39Z"
"","22843","There may be unexpected result in ClassUtils#resolvePrimitiveClassName(String name)","**Affects:** 4.x and 5.x ---  I'm not sure whether there is a bug or not.  [ClassUtils#resolvePrimitiveClassName(String name)](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ClassUtils.java) ```java public static Class resolvePrimitiveClassName(@Nullable String name) { 	Class result = null; 	// Most class names will be quite long, considering that they 	// SHOULD sit in a package, so a length check is worthwhile. 	if (name != null && name.length() <= 8) { 			// Could be a primitive - likely. 		result = primitiveTypeNameMap.get(name); 	} 	return result; } ``` The length of ""boolean[]"" is 9. How to resolve the primitive class like boolean[].class?","closed","","Costriod","2019-04-26T11:19:47Z","2022-02-18T19:10:08Z"
"","23301","Problem with DeferredResult and Hibernate","**Affects:**  Tested with 4.2.4/4.2.9/4.3.6  I'm using spring DeferredResult on a http request. The controller receives some info, make a query or two and then return the DeferredResult.  ```java final RandomObj randomObj = someDAO.getSomething(someParameters);  final CustomResponse response = new CustomResponse(); response.setError(""need_password""); return new DeferredResult(10L, response); ```  But for some reason Hibernate Session is not being closed after the return of after the timeout expires.  In c3p0 there is the option to kill long unreturned connections and debug the problem, and with the DeferredResult scenario I always get this after a while:  ``` jul 16, 2019 10:42:26 AM com.mchange.v2.resourcepool.BasicResourcePool removeResource INFO: A checked-out resource is overdue, and will be destroyed: com.mchange.v2.c3p0.impl.NewPooledConnection@13b130de jul 16, 2019 10:42:26 AM com.mchange.v2.resourcepool.BasicResourcePool removeResource INFO: Logging the stack trace by which the overdue resource was checked-out. java.lang.Exception: DEBUG STACK TRACE: Overdue resource check-out stack trace. ``` I confirmed that the session is not closed by putting some breakpoints on the Session.close() method.  I think my problem is the following: [Here](https://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-web/src/main/java/org/springframework/web/context/request/async/WebAsyncManager.java#L376) 3 interceptors are registered, the AsyncRequestInterceptor is the second one. When the timeout trigger,[this](https://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-web/src/main/java/org/springframework/web/context/request/async/DeferredResultInterceptorChain.java#L71) code is executed, it first trigger [this](https://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-web/src/main/java/org/springframework/web/context/request/async/DeferredResult.java#L218) interceptor, after that, since there is a timeout result, it is [assigned](https://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-web/src/main/java/org/springframework/web/context/request/async/DeferredResult.java#L226) as the result. When the iteration is over and the second interceptor (AsyncRequestInterceptor) would be run, the result of setOrExpired (because the timeout result) is true, and it break the execution of the interceptor loop. Because of that the AsyncRequestInterceptor don't get flagged [here](https://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-orm/src/main/java/org/springframework/orm/jpa/support/AsyncRequestInterceptor.java#L111), and it does not close the hibernate session   If I don't put a timeout result object it works as expected, closing the session.   That is the expected behavior??","open","status: feedback-provided,","brunomanzo","2019-07-16T19:33:18Z","2021-11-12T12:13:53Z"
"","23778","[spring-web] Invalid encoded sequence ""%;"": url path is decoded incorrectly","**Affects:**  Spring Boot 2.1.2.RELEASE  I have a simple rest controller with the method the get requests mapped on.  ```java @RestController @RequestMapping(""/"") public class SimpleController {    @GetMapping(""/{cis}"")    public String foo(@PathVariable String cis) {            log.debug(""#foo: started with params: cis={}"", cis);            return ""OK"";    } } ```  When I try to do request to this endpoint passing **%;** (_pct-encoded_) as cis path variable I get the exception:  > curl -X GET ""http://localhost/%25%3B"" -H ""accept: */*""  ```java java.lang.IllegalArgumentException: Invalid encoded sequence ""%;"" 	at org.springframework.util.StringUtils.uriDecode(StringUtils.java:748) ~[spring-core-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.util.UriUtils.decode(UriUtils.java:342) ~[spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.util.UrlPathHelper.decodeInternal(UrlPathHelper.java:464) ~[spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.util.UrlPathHelper.lambda$decodePathVariables$0(UrlPathHelper.java:543) ~[spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at java.util.LinkedHashMap.forEach(LinkedHashMap.java:684) ~[?:?] 	at org.springframework.web.util.UrlPathHelper.decodePathVariables(UrlPathHelper.java:543) ~[spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.handleMatch(RequestMappingInfoHandlerMapping.java:134) ~[spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.handleMatch(RequestMappingInfoHandlerMapping.java:57) ~[spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:418) ~[spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:368) ~[spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:65) ~[spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:401) ~[spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1231) [spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1014) [spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) [spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) [spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) [spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) [spring-webmvc-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:90) [spring-boot-actuator-2.1.2.RELEASE.jar:2.1.2.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:176) [spring-security-oauth2-2.3.4.RELEASE.jar:?] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) [spring-security-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.security.oauth2.client.filter.OAuth2ClientContextFilter.doFilter(OAuth2ClientContextFilter.java:60) [spring-security-oauth2-2.3.4.RELEASE.jar:?] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:117) [spring-boot-actuator-2.1.2.RELEASE.jar:2.1.2.RELEASE] 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:106) [spring-boot-actuator-2.1.2.RELEASE.jar:2.1.2.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-5.1.4.RELEASE.jar:5.1.4.RELEASE] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1417) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.14.jar:9.0.14] 	at java.lang.Thread.run(Thread.java:834) [?:?] ``` I have done some researches and have discovered that the possible reason is full matching of servlet path and decoded request uri when the uri contains **;** _semicolon_ (see UrlPathHelper#getRemainingPath). Due to double decoding, this exception is occurred.  It seems like a little bug. Maybe you know some workarounds to the fast solution?  Thanks.","closed","","akrikheli","2019-10-10T22:34:06Z","2019-11-15T12:25:31Z"
"","22983","spring-mvc.xsd stale-if-error attribute documentation incorrect","**Affects:**  5.2.0.M2, 5.1.x, 4.3.x, etc --- The documentation for the `stale-if-error` attribute in [spring-mvc.xsd](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/config/spring-mvc.xsd) appears to have been copied from the `s-maxage` attribute:","closed","in: web,","pthorson","2019-05-16T16:51:38Z","2019-05-20T16:31:20Z"
"","22975","Documentation: MVC Static Resource config XML example issue","**Affects:**  5.2.0.M2  **Actual:** In the [MVC Static Resource Config documentation](https://docs.spring.io/spring/docs/5.2.0.M2/spring-framework-reference/web.html#mvc-config-static-resources), an example given has the incorrect syntax for `resource-cache`:                                                                                                                             **Expected**                                                                                                                 See also https://stackoverflow.com/questions/38087131/resource-versioning-with-configuration-xml-based-spring   ---","closed","type: task,","pthorson","2019-05-14T19:12:03Z","2019-05-15T21:34:18Z"
"","23055","FreeMarkerConfigurerTests in spring-webmvc is testing against FreeMarkerConfigurationFactoryBean but not FreeMarkerConfigurer","**Affects:**  5.1.7  ---  `FreeMarkerConfigurerTests` in `spring-webmvc` is testing against `FreeMarkerConfigurationFactoryBean` but not `FreeMarkerConfigurer`   https://github.com/spring-projects/spring-framework/blob/82d0e49de96b085e8d1d2e4b9ded8e6d82cd535a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerConfigurerTests.java#L57-L64  The test above will succeed when running against `FreeMarkerConfigurationFactoryBean` but fail against `FreeMarkerConfigurer` because in this case `TemplateLoader` for `FreeMarkerConfigurer` is a `MultiTemplateLoader` that contains `SpringTemplateLoader` and `ClassTemplateLoader`  Proposal :  - Test against `FreeMarkerConfigurer` to have good coverage  - Move `FreeMarkerConfigurationFactoryBean` tests to `org.springframework.ui.freemarker.FreeMarkerConfigurationFactoryBeanTests`","closed","status: superseded,","ielatif","2019-05-29T15:11:58Z","2019-06-06T15:01:36Z"
"","23749","some methods can be added in StringUtils","---  To make string to uppercase and lowercase.","closed","status: declined,","rsbeoriginal","2019-10-02T12:42:20Z","2019-10-02T13:44:48Z"
"","23771","How to extend distributed lock in CacheAspectSupport Class","---  spring cache  is very usefull and convenient. for example, It's easy to use @Cacheable, @CacheEvict,@CachePut . but it has concurrency issues.  if  in CacheAspectSupport  class, method `private Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) ` , using lock can resove it, but now can not extend lock in CacheAspectSupport  class.  can i extend lock in CacheAspectSupport  class source ? and push it?","closed","","yuanchangjin","2019-10-09T03:04:46Z","2020-08-07T08:51:23Z"
"","23674","Upgrade ""Spring Framework Versions"" page to mention JDK 13 support","5.2 supports JDK 13 but that's not reported [on the wiki page](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions) yet.","closed","type: documentation,","snicoll","2019-09-22T15:52:58Z","2019-09-23T12:16:24Z"
"","23430","Merge pull request #1 from spring-projects/5.0.x","5.0.x","closed","status: invalid,","zhangjinhang00","2019-08-07T17:08:45Z","2019-08-08T06:45:39Z"
"","23516","Merge pull request #1 from spring-projects/master","20190825","closed","","biggerwang","2019-08-25T04:48:27Z","2019-08-25T04:48:34Z"
"","23515","Merge pull request #1 from spring-projects/master","20190825","closed","","biggerwang","2019-08-25T04:43:12Z","2019-08-25T04:45:36Z"
"","23357","Application run failed,but process is not exited.mongo,rabbitmq,tomcat were all closed,but kafka is alive.I have met two times,I have no idea,I need some help.","2019-07-23 20:25:35 [org.springframework.context.support.AbstractApplicationContext:554] WARN  org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: **Failed to start bean 'org.springframework.kafka.config.internalKafkaListenerEndpointRegistry'; nested exception is org.apache.kafka.common.errors.TimeoutException: Timeout expired while fetching topic metadata 2019-07-23 20:25:35** [org.springframework.scheduling.concurrent.ExecutorConfigurationSupport:208] INFO  org.springframework.scheduling.concurrent.**ThreadPoolTaskExecutor - Shutting down ExecutorService 'applicationTaskExecutor'** 2019-07-23 20:25:35 [org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer:1190] INFO  org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer - **Shutdown ignored - container is not active already** 2019-07-23 20:25:35 [com.mongodb.diagnostics.logging.SLF4JLogger:71] INFO  org.mongodb.driver.connection - Closed connection [connectionId{localValue:4}] to **mongos-svc:27017 because the pool has been closed.** 2019-07-23 20:25:35 [com.mongodb.diagnostics.logging.SLF4JLogger:71] INFO  org.mongodb.driver.connection - Closed connection [connectionId{localValue:2}] to **mongos-svc:27017 because the pool has been closed.** 2019-07-23 20:25:35 [org.apache.juli.logging.DirectJDKLog:173] INFO  org.apache.catalina.core.StandardService - **Stopping service [Tomcat]** 2019-07-23 20:25:35 [org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener:142] INFO  org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener -   Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2019-07-23 20:25:35 [org.springframework.boot.SpringApplication:858] ERROR org.springframework.boot.SpringApplication - **Application run failed** org.springframework.context.ApplicationContextException: Failed to start bean 'org.springframework.kafka.config.internalKafkaListenerEndpointRegistry'; nested exception is org.apache.kafka.common.errors.TimeoutException: Timeout expired while fetching topic metadata 	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:185) 	at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:53) 	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:360) 	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:158) 	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:122) 	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:879) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:163) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) 	at com.h3c.iot.IotsdkservermgrApplication.main(IotsdkservermgrApplication.java:27) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48) 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:50) 	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:51) Caused by: org.apache.kafka.common.errors.TimeoutException: Timeout expired while fetching topic metadata 2019-07-23 21:04:04 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-6, groupId=iotsdkservermgr] Node 0 was unable to process the fetch request with (sessionId=2075377223, epoch=4257): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 21:07:41 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-2, groupId=iotsdkservermgr] Node 0 was unable to process the fetch request with (sessionId=609016071, epoch=4700): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 21:20:34 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-8, groupId=iotsdkservermgr] Node 1 was unable to process the fetch request with (sessionId=1414506249, epoch=6592): INVALID_FETCH_SESSION_EPOCH. 019-07-23 21:57:35 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-2, groupId=iotsdkservermgr] Node 2 was unable to process the fetch request with (sessionId=1581749342, epoch=11037): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 22:21:44 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-8, groupId=iotsdkservermgr] Node 1 was unable to process the fetch request with (sessionId=864693921, epoch=7289): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 22:34:19 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-6, groupId=iotsdkservermgr] Node 1 was unable to process the fetch request with (sessionId=1494210423, epoch=15377): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 22:54:11 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-6, groupId=iotsdkservermgr] Node 1 was unable to process the fetch request with (sessionId=1564129696, epoch=2367): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 23:03:10 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-4, groupId=iotsdkservermgr] Node 0 was unable to process the fetch request with (sessionId=1117881135, epoch=18080): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 23:07:27 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-2, groupId=iotsdkservermgr] Node 2 was unable to process the fetch request with (sessionId=31438056, epoch=8327): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 23:07:27 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-2, groupId=iotsdkservermgr] Node 1 was unable to process the fetch request with (sessionId=663747677, epoch=19353): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 23:12:13 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-2, groupId=iotsdkservermgr] Node 1 was unable to process the fetch request with (sessionId=866581978, epoch=567): INVALID_FETCH_SESSION_EPOCH. 2019-07-23 23:37:08 [org.apache.kafka.clients.FetchSessionHandler:383] INFO  org.apache.kafka.clients.FetchSessionHandler - [Consumer clientId=consumer-6, groupId=iotsdkservermgr] Node 0 was unable to process the fetch request with (sessionId=1424368118, epoch=17737): INVALID_FETCH_SESSION_EPOCH.","closed","for: stackoverflow,","strugglekian","2019-07-25T09:27:03Z","2019-07-25T09:50:09Z"
"","23583","use lambda & code simplify","1.use lambda. 2.In my opinion , orderedPostProcessorNames and nonOrderedPostProcessorNames are unnecessary,beanPostProcessors can be added directly to the list insted of two additional cycles.","closed","status: declined,","fakefrog","2019-09-04T10:55:00Z","2019-09-06T16:46:54Z"
"","23445","Simplify the if statements and replace 'try finally' with 'try' with resources","1.Simplify the if statements, making it easier to read. 2.Replace 'try finally' with 'try' with resources in DataSourceTransactionManager","closed","type: task,","zhuzhuman978","2019-08-09T21:43:13Z","2019-08-10T12:03:29Z"
"","23729","Ensure spring-core jar task is UP-TO-DATE","- Use the [shadow plugin](https://github.com/johnrengelman/shadow) for repackaging.   - Using this plugin allows to get rid of Ant JarJar task   - ~Using `preserveFileTimestamps = false` and `reproducibleFileOrder = true` on all jars ensure consistent checksums whenever the jar are rebuilt.~ - Use a more dogmatic approach to embed the `kotlin-coroutines` classes into `spring-core` jar.   - Instead of using a `zipTree` of the project default configuration, let the `kotlin-coroutines` project export an artifact containing the output of the kotlin compilation task.  ~See [this Gradle Enterprise task inputs comparison](https://ge.spring.io/c/e6m3krl5jfwjk/viakdt3a6d5eu/task-inputs) between the same project checkout, in two different directories. The `spring-core:jar` is not present anymore, because its inputs were the same in both builds.~  ~Regarding the new generated `spring-core.jar`. I checked using `pkgdiff` that its content is byte-to-byte identical to the former one. The MD5 is different though, as the timestamps are not changed anymore when rebuilt (and that's the reason why I changed to the Shadow plugin)~  EDIT: After discussion with @lptr, we agreed that using `preserveFileTimestamps = false` and `reproducibleFileOrder = true` just to get the non-cacheable `:spring-core:jar` task up-to-date is not worth it. A filter on the task input comparison to focus on _cacheable_ task will probably be added, as a way to filter out the noise produced by non-cacheable tasks","closed","type: task,","facewindu","2019-09-30T12:20:34Z","2019-11-04T09:45:22Z"
"","23563","Document minimum JDK 8 update version","- surefire: 2.20.1 - jdk: 1.8.0_45 - Spring: 5.0.15.RELEASE - mvn: 3.6.1  When I run `mvn test` with the `maven-surefire-plugin`, this happens:  ``` [2019-09-02T09:28:48.807Z] java.lang.IllegalStateException: Failed to load ApplicationContext  [2019-09-02T09:28:48.807Z] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'requestMappingHandlerAdapter' defined in class path resource [org/springframework/web/servlet/config/annotation/DelegatingWebMvcConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter]: Factory method 'requestMappingHandlerAdapter' threw exception; nested exception is java.lang.BootstrapMethodError: call site initialization exception  [2019-09-02T09:28:48.807Z] Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter]: Factory method 'requestMappingHandlerAdapter' threw exception; nested exception is java.lang.BootstrapMethodError: call site initialization exception  [2019-09-02T09:28:48.807Z] Caused by: java.lang.BootstrapMethodError: call site initialization exception  [2019-09-02T09:28:48.807Z] Caused by: java.lang.ClassCastException: Cannot cast org.springframework.http.converter.xml.SourceHttpMessageConverter$$Lambda$81/217380081 to org.xml.sax.EntityResolver ```  ```mvn clean test -U -X -T 4```  the error code slice:  ```java public class SourceHttpMessageConverter extends AbstractHttpMessageConverter {  	private static final EntityResolver NO_OP_ENTITY_RESOLVER = 			(publicId, systemId) -> new InputSource(new StringReader("""")); ```  However, when I used the jdk of version jdk1.8.0_211, it didn't happen any more. It probably could be caused by jdk type inference mechanism(which may be fixed in later version) under the surefire class loader.  Just report the issue, btw are there some documents related to it?","closed","type: documentation,","crosslover","2019-09-02T12:21:45Z","2019-09-05T12:18:32Z"
"","23443","Support for OpenJDK's project Loom (Fibers, Continuations)","*This issue is just a placeholder for future considerations regarding this topic.*  [Project Loom](https://openjdk.java.net/projects/loom/) is an OpenJDK project that aims to provide support for [Continuations ](https://en.wikipedia.org/wiki/Continuation) and Fibers in the JVM natively. [Here is a good article](https://developers.redhat.com/blog/2019/06/19/project-loom-lightweight-java-threads/) that explains the concepts and a couple of YouTube videos on this topic are available as well. There is also a [public prototype available](http://mail.openjdk.java.net/pipermail/loom-dev/2018-July/000061.html) as well as at least one comprehensive [git project example collection](https://github.com/forax/loom-fiber) that implements a couple of different things (actors, TCP Proxy server, etc).  I wonder how some of the Spring projects could benefit in the end or if a new one could emerge. The first thing that comes to my mind it spring-web*. WebMvc is a rock solid and easy web implementation whereas WebFlux is a scalable reactive implementation. The latter comes with drawbacks in code complexity, readability and debuggability. Loom actually promises to allow scalability by spawning millions of Fibers and at the same time keeping the code readable by maintaining its sequential order.  I assume, some of the web server implementations like [netty ](https://netty.io/) will eventually make use of Fibers, but does it make sense to apply the concepts to some Spring projects as well or will there be a clear boundary?   Have there been any considerations or ideas on how to leverage the power of Fibers and Continuations in the Spring eco-system?","open","in: core,","jwedel","2019-08-09T20:09:48Z","2022-06-07T13:39:58Z"
"","23285","Cannot apply AspectJ AOP advice by selecting annotation","**Version::5.1.7.RELEASE.**  when I use AOP like this: `@Around(""@annotation(PulsarListener)"")`, I cannot find  `PulsarListener` like this:    ```java PulsarListener annotation = AnnotationUtils.getAnnotation(method, PulsarListener.class);  ```  I 'm not sure it's a bug or I use wrong, so I also ask on [stackoverflow](https://stackoverflow.com/questions/57000814/annotationutils-getannotationmethod-pulsarlistener-class-cannnot-work).  **Code:**  ```java @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface PulsarListener {     String[] topics() default {}; }  @Aspect @Slf4j @Component @Order(0) public class MDCAspect {     @Around(""@annotation(PulsarListener)"")     public Object around(ProceedingJoinPoint joinPoint) throws Throwable {     ...     } }  @Slf4j @Component public class PulsarPostProcessor implements BeanPostProcessor {      @Value(""${pulsar.service.url}"")     private String pulsar_service_url;     @Override     public Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException {          Method[] methods = bean.getClass().getDeclaredMethods();          for (Method method : methods) {             //here  annotation is null;             PulsarListener annotation = AnnotationUtils.getAnnotation(method, PulsarListener.class);           ... ```","closed","for: stackoverflow,","AcrazyDog","2019-07-13T00:16:50Z","2019-07-13T16:40:11Z"
"","23713","Extra empty line a[""\n""] messages from ActiveMQ STOMP broker","**version:**: ``` spring-boot-starter-parent - version: 2.1.8.RELEASE spring-boot-starter-websocket - as above ```  **issue:** `Client receives extra/un-necessary message(a[""\n""] or empty line) for each message sent  from external broker via brokerrelay `","closed","type: enhancement,","seenimurugan","2019-09-25T21:29:18Z","2020-01-16T16:04:07Z"
"","23372","WebClient unable to send files using InputStreamResource from 2.1.5.RELEASE","**Use case is:**  send files via Streaming using _InputStream_, since _spring webclient_ is not working with _InputStreamResource_, made some modifications created _MultiPartInputStreamFileResource_ (code pasted below) Using _ByteArrayInputStreamResource_ is not an option for us, it will load everything into memory (causing memory issues) instead of streaming. Works till 2.1.4.RELEASE of spring-boot-starter-parent using (_MultiPartInputStreamFileResource_ ),  1) 2.1.5.RELEASE of spring-boot-starter-parent  -> throws unsupported operation exception  2) 2.1.6.RELEASE of spring-boot-starter-parent  -> unsupported operation exception is resolved, but  Getting ""Unexpected end of multipart data"" from server, while sending files.    ```       org.springframework.boot     spring-boot-starter-parent     2.1.4.RELEASE          ``` ```java public class MultipartInputStreamFileResource extends InputStreamResource {    private final String filename;    public MultipartInputStreamFileResource(InputStream inputStream, String filename) {     super(inputStream);     this.filename = filename;   }    @Override   public String getFilename() {     return this.filename;   }    @Override   public long contentLength() {     return -1; // we do not want to generally read the whole stream into memory ...   }    @Override   public boolean equals(Object o) {     if (this == o) {       return true;     }     if (o == null || getClass() != o.getClass()) {       return false;     }     if (!super.equals(o)) {       return false;     }     MultipartInputStreamFileResource that = (MultipartInputStreamFileResource) o;     return Objects.equals(filename, that.filename);   }    @Override   public int hashCode() {     return Objects.hash(super.hashCode(), filename);   } }  public class ResourceHttpMessageConverterHandlingInputStreams extends ResourceHttpMessageConverter {    @Override   protected Long getContentLength(Resource resource, MediaType contentType) throws IOException {     Long contentLength = super.getContentLength(resource, contentType);      return contentLength == null || contentLength < 0 ? null : contentLength;   } }    private BodyInserter getMultipartBodyInserter(       InputStream inputStream, String fileName, String version, String messageDigest) {     MultipartInputStreamFileResource multipartInputStreamFileResource =         new MultipartInputStreamFileResource(inputStream, fileName);     MultiValueMap multiValueMap = new LinkedMultiValueMap<>();     addHashToMap(multiValueMap, messageDigest);     multiValueMap.put(""version"", Arrays.asList(version));     multiValueMap.put(""file"", Arrays.asList(multipartInputStreamFileResource));      return BodyInserters.fromMultipartData(multiValueMap);   }  ``` and use the body inserter in webclient as below,  ```java  WebClient webClient = webClientBuilder.baseUrl(url).defaultUriVariables(uriVariables)         .build();     WebClient.RequestBodySpec requestBodySpec = webClient.method(httpMethod);     Mono responseEntityMono = requestBodySpec.body(bodyInserter).exchange()         .flatMap(clientResponse -> clientResponse.toEntity(responseClassType)); ```","closed","status: duplicate,","gurudatta11","2019-07-26T22:39:47Z","2021-07-06T13:27:38Z"
"","23312","SpEL wrongly handles doubles in list of integers.","**Steps to reproduce issue:**  Given the following piece code:   ```java ExpressionParser parser = new SpelExpressionParser(); List numbers = (List) parser.parseExpression(""{1.1,2,3}"").getValue(); System.out.println(numbers.get(0)); System.out.println(numbers.get(0).getClass()); ```  **Now:**  The code compiles successfully. 1.1 is printed Exception is thrown class java.lang.Double cannot be cast to class java.lang.Integer  (on line 4).  **Expected:**  The code compiles successfully. Exception is thrown class java.lang.Double cannot be cast to class java.lang.Integer (on line 3).  I find rather misleading the fact that one can operate with the element of type Double as part of the list of Integers.","closed","in: core,","Kriska","2019-07-18T06:21:08Z","2019-07-18T13:43:39Z"
"","22831","Spring Web Services Reference Documentation have invalid maven command example.","**Spring Web Services Reference Documentation** contains insignificant error under the paragraph [3.5 Creating the project](https://docs.spring.io/spring-ws/docs/3.0.7.RELEASE/reference/#tutorial-creating-project).   Instead of  `mvn archetype:create ...` it should be `mvn archetype:generate...` due to the support of the ""create"" goal have been removed, ref. JIRA: [ARCHETYPE-437](https://issues.apache.org/jira/browse/ARCHETYPE-437) [](url)  **Affects:** \<3.0.7.RELEASE>  ---","closed","for: external-project,","Funnjy","2019-04-24T08:34:17Z","2019-04-29T05:47:13Z"
"","23192","@CacheEvict beforeInvocation with transaction does not work","**Spring Version: 5.1.7.RELEASE** ---  When Spring transactions are enabled, the `Cache` operation is proxied by `TransactionAwareCacheDecorator`. Only the `get()` operation is invoked directly. The `put()`, `evict()`, and `clear()` operations will be delayed until after the transaction has been committed (via a custom `TransactionSynchronizationAdapter.afterCommit()` callback).  When `username='zhangsan'` is cached, the `updateAndRefresh()` method will return the old cached value because `userRepository.getByUsername()` is executed before the transaction is committed.   Even if `beforeInvocation=true`, `CacheAspectSupport.processCacheEvicts()` also only sets cache operation to `ThreadLocal`.  Is there is a bug for `@CacheEvict(beforeInvocation = true, ...)` when executing within a transaction?  ```java class UserRepository { 	@Cacheable(value = ""userCache"", key = ""#username"") 	User getByUsername( String username );  	@CacheEvict(value = “userCache”, key = ""#user.username"", beforeInvocation = true) 	void save( User user ); }  class UserService { 	@Transactional 	User updateAndRefresh( User user ) { 		userRepository.save(user); 		return userRepository.getByUsername( user.getUsername() ); 	} } ```  CacheAspectSupport.java ```java private void performCacheEvict( 			CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result) {  		Object key = null; 		for (Cache cache : context.getCaches()) { 			if (operation.isCacheWide()) { 				logInvalidating(context, operation, null); 				doClear(cache); 			} 			else { 				if (key == null) { 					key = generateKey(context, result); 				} 				logInvalidating(context, operation, key); 				doEvict(cache, key); 			} 		} 	} ```  TransactionAwareCacheDecorator.java ```java @Override 	public void evict(final Object key) { 		if (TransactionSynchronizationManager.isSynchronizationActive()) { 			TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() { 				@Override 				public void afterCommit() { 					TransactionAwareCacheDecorator.this.targetCache.evict(key); 				} 			}); 		} 		else { 			this.targetCache.evict(key); 		} 	} ```","closed","type: enhancement,","wusthuke","2019-06-25T08:24:10Z","2020-06-12T09:13:59Z"
"","23243","Webflux http.server.requests 200 Metrics not Recorded","**Affects:** webflux 2.1.5.RELEASE & 2.1.6.RELEASE --- The default metrics for rest controllers (http.server.requests) is not reporting 200 responses however it does record if an error is thrown. The error looks to have been introduced in 2.1.4.RELEASE.  See https://github.com/HarryEMartland/webflux-metrics-issue for an example application  |Spring Boot Version | Server  | Controller Response | Metrics Reported | |--------------------|---------|---------------------|------------------| |2.1.6.RELEASE       | webflux | Mono                | no               |  |2.1.6.RELEASE       | webflux | String              | no               |  |2.1.6.RELEASE       | webflux | Exception           | yes              |  |2.1.6.RELEASE       | web     | String              | yes              |  |2.1.5.RELEASE       | webflux | String              | no               |  |2.1.5.RELEASE       | webflux | Mono                | no               |  |2.1.5.RELEASE       | webflux | Exception           | yes              |  |2.1.5.RELEASE       | web     | String              | yes              |  |2.1.4.RELEASE       | webflux | String              | yes              |  |2.1.4.RELEASE       | webflux | Mono                | yes              |  |2.1.4.RELEASE       | webflux | Exception           | yes              |  |2.1.4.RELEASE       | web     | String              | yes              |","closed","in: web,","HarryEMartland","2019-07-05T15:39:31Z","2019-08-17T09:46:40Z"
"","23375","Multipart timeouts when send via WebClient after setting R/W timeouts via doOnConnected/HttpClient/ReactorClientHttpConnector","**Affects:** SpringBoot 2.1.6.RELEASE  --- **Usecase** Want to proxy a Multipart content in reactive manner from server to another server (eg. curl/postman call -> serverApp1 -> serverApp2).  **Problem** The the whole chain hangs and timeouts when reaching server2. All Reactive Filters on the way on both servers are called properly, proper endpoint on server2 is determined, but the actual controller method of server2 never gets called. After the set timeout, the connection is cancelled.  **Suspected cause** Setting the timeouts on the WebClient (see commented section of code below).  **Notes** * The the example of broken code is below, to fix it, comment out the 'doOnConnected' section -> the whole flow finishes successfully * The problem seems to be related only when multipart content is involved, 'basic' JSON-API calls seem to work fine * The approach how to configure is similar as recommened in #390  Code (prototype of the error extracted from the actual app, stripped of filters, security, etc): ``` @RestController class Multipart {      @PostMapping(""/multipartA"")     fun endpointA(             @RequestPart(""file"") file: FilePart     ): Mono = client.post()             .uri(""localhost:8080/multipartB"")             .syncBody(                     MultipartBodyBuilder().also { builder ->                         builder.asyncPart(""file"", file.content(), DataBuffer::class.java).headers {                             it.addAll(file.headers())                         }                         builder.asyncPart(""some"", SomJsonDTO(""xx"").toMono(), SomJsonDTO::class.java)                     }.build()             ).exchange()             .map {                 if (!it.statusCode().is2xxSuccessful)                     throw IllegalStateException(""Invalid response: ${it.statusCode()}"")             }      @PostMapping(""/multipartB"")     fun endpointB(             @RequestPart(""file"") file: FilePart,             @RequestPart(""some"") some: SomJsonDTO,             serverWebExchange: ServerWebExchange     ): Mono {         println(""Received the request: $some"")         return file.transferTo(File(""/home/some-user/stuff/result.png"")).map {             Unit         }     }       companion object {         val client = HttpClient.create().tcpConfiguration { client ->             with(client) {                 option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300000)                 // *** commenting out the 'doOnConnected' fixes the issue ***                 doOnConnected { conn ->                     conn.addHandlerLast(ReadTimeoutHandler(30))                     conn.addHandlerLast(WriteTimeoutHandler(30))                 }                 // ***             }         }.compress(true).let {             WebClient.builder()                     .clientConnector(ReactorClientHttpConnector(it))                     .build()         }     }  }  data class SomJsonDTO(val x: String) `","open","in: web,","zacharo","2019-07-27T12:42:45Z","2021-11-08T11:17:40Z"
"","23537","Not able to use @EnableAspectJAutoProxy(proxyTargetClass = true)","**Affects:** Spring-webmvc 5.1.8.RELEASE  **Description:** The latest changes in the AbstractHandlerMapping and DispatcherServlet in the commit 28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5 bring to null pointer exception if  RequestMappingHandlerMapping is a proxy created by CGLIB because the logger field is null for proxy object: ![Screen Shot 2019-08-27 at 4 58 02 PM](https://user-images.githubusercontent.com/17482133/63777507-e36dbb80-c8eb-11e9-845a-c686bb68b1e6.png)  To reproduce that behavior I created code snippet: https://github.com/smoomrik/code-snippets/tree/master/proxy-target-class-logger-nullpointer  it contains 3 tags: - 5.0.7_wide_scope: Spring version is 5.0.7.Release. The aspect has a wide scope that force to replace RequestMappingHandlerMapping with proxy created by CGLIB. It works (not fine but it doesn't break anything) - 5.1.8_wide_scope: Spring version is 5.1.8.Release. The aspect has a wide scope that force to replace RequestMappingHandlerMapping with proxy created by CGLIB. It doesn't work (null pointer exception because the logger field is null) - 5.1.8_small_scope: Spring version is 5.1.8.Release. The aspect has a limited to package scope that removes needs for proxying RequestMappingHandlerMapping. It works fine.  I know the usage of so wide scope for aspects is wrong, but the question is: - Is it expected that Spring allows proxying RequestMappingHandlerMapping in the version 5.0.7 without any problems and allow but bring to the unusable state in the version 5.1.8?  I supposed there is some kind of protection logic to avoid proxying of Spring internals. Isn't it?  @rstoyanchev could you please take a look.","open","in: core,","smoomrik","2019-08-28T11:53:32Z","2021-11-11T10:12:40Z"
"","23270","Calling uri of the form /-system is causing an exception in jvm-11","**Affects:** spring-test 5.1.5.RELEASE  Calling in the test uri of the form /-system is causing an exception in jvm-11 Example: `        MvcResult mvcResult = mvc.perform(get(""/-system/check"")                 .accept(MediaType.TEXT_PLAIN_VALUE))                 .andExpect(status().isOk())                 .andReturn(); `  Stacktrace: `org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: sun/misc/SharedSecrets         at cs.SystemCheckIT.shouldGetSystemCheck(SystemCheckIT.java:37) Caused by: java.lang.NoClassDefFoundError: sun/misc/SharedSecrets         at cs.SystemCheckIT.shouldGetSystemCheck(SystemCheckIT.java:37) Caused by: java.lang.ClassNotFoundException: sun.misc.SharedSecrets         at cs.SystemCheckIT.shouldGetSystemCheck(SystemCheckIT.java:37) `","closed","","GrigoreStancul","2019-07-10T11:18:04Z","2021-01-08T13:09:09Z"
"","23358","The StompSession.send() ignore ByteArrayMessageConverter and don't set correct content type.","**Affects:** spring-messaging:5.1.8.REALEASE --- **Setup:** ```java WebSocketStompClient client = new WebSocketStompClient(new JettyWebSocketClient(webSockClient)); client.setMessageConverter(new ByteArrayMessageConverter()); StompSession ses = client.connect(cfg.serverUri() + AGENTS_PATH, new AfterConnectedSessionHandler()); ses.send(""/app/some/destination"", new byte[]{-37,75,0,0,1,0,24}); ``` **Result after message receive without correct content-type header** ```java @MessageMapping(""/app/some/destination"") public void data(byte[] data) {}  After receive message, data is equals: new byte[]{-17, -65, -67, 75, 0, 0, 1} ```  **Result after message receive with correct content-type header** ```java StompHeaders headers = new StompHeaders(); headers.setContentType(MimeTypeUtils.APPLICATION_OCTET_STREAM); headers.setDestination(""/app/some/destination"");  ses.send(headers, new byte[]{-37,75,0,0,1,0,24});  After send message with content-type we receive correct byte array on server side. ```   The root cause here: ```java private Message createMessage(StompHeaderAccessor accessor, Object payload) { 	accessor.updateSimpMessageHeadersFromStompHeaders(); 	Message message; 	if (payload == null) { 		message = MessageBuilder.createMessage(EMPTY_PAYLOAD, accessor.getMessageHeaders()); 	}         // WE DON'T CALL ByteArrayMessageConverter :( 	else if (payload instanceof byte[]) { 		message = MessageBuilder.createMessage((byte[]) payload, accessor.getMessageHeaders()); 	} 	else { 		message = (Message) getMessageConverter().toMessage(payload, accessor.getMessageHeaders()); 		accessor.updateStompHeadersFromSimpMessageHeaders(); 		if (message == null) { 			throw new MessageConversionException(""Unable to convert payload with type='"" + 					payload.getClass().getName() + ""', contentType='"" + accessor.getContentType() + 					""', converter=["" + getMessageConverter() + ""]""); 		} 	} 	return message; } ```","closed","in: messaging,","somjik-api","2019-07-25T10:25:29Z","2019-07-30T10:04:14Z"
"","22939","Illegal reflective access on shutdown of ExecutorService","**Affects:** spring-core-5.1.6.RELEASE  I'm migrating an application to Open JDK **11.0.2**, and updated its **Spring Boot** from v1.5 to **v2.1.4**, that in turn updates **SpringFramework** to **v5.1.6**.  My application runs several threads, and I implemented an EventListener for the situation when an administrator shuts down the application and the Context is stopped or closed the application tries to gracefully shutdown the child threads managed by an ExecutorService.   ```java @Component public class AppController {    @Autowired   private ExecutorService runner1;    public void run(ApplicationArguments theArgs) throws Exception {      Runnable myRunnable = new Consumer();      runner1.execute(myRunnable);      //Do Business Logic, until Thread Interrupted      runner1.shutdown();     if (!runner1.awaitTermination(5, TimeUnit.SECONDS)) {       runner1.shutdownNow();     }     System.exit(2);   } } ``` Good news is that everything shuts down.  But I do get the following warning with JDK 11:   ``` Illegal reflective access by org.springframework.util.ReflectionUtils (file:spring-core-5.1.6.RELEASE.jar)  to method java.util.concurrent.Executors$DelegatedExecutorService.shutdown() ``` My problem appears similar to Issues #22791 and #22242.  I've attached a sample project to recreate the error when you use JDK 11, just run the included JUnit class and use the VM arg `--illegal-access=debug` to see the stacktrace. ``` WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:spring-core-5.1.6.RELEASE.jar) to method java.util.concurrent.Executors$DelegatedExecutorService.shutdown()         at org.springframework.util.ReflectionUtils.makeAccessible(ReflectionUtils.java:602)         at org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:336)         at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:271)         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)         at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)         at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)         at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)         at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)         at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945) ``` [reflective-access-threads.zip](https://github.com/spring-projects/spring-framework/files/3164238/reflective-access-threads.zip)","closed","type: enhancement,","Clank84","2019-05-09T22:40:05Z","2019-06-11T21:25:57Z"
"","23464","SimpleKeyGenerator does not handle Collections the same way it handles Arrays","**Affects:** spring-context 5.1.6.RELEASE  ---  Issue:  Using the `@Cacheable` annotation on a method with a single argument that is a `Collection` or `Map` while using a `RedisCache` often fails to serialize the argument as the cache key when no keyGenerator is specified (defaults to `SimpleKeyGenerator`).  Example:  Using a `RedisCache` with configuration defaults except for using JSON serialization for values: `RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.json()));`  ```java @Cacheable public ResultObject findSomething(final List somethings) {     // do the expensive operation with the somethings list to return a ResultObject     return doExpensiveOperation(somethings); } ```  This results in a serialization error generating a cache key because there is no conversion service to convert `List` to `String`.  The reason `List` is being used to convert to `String` is because `SimpleKeyGenerator` has a condition when the params array is length 1. If the single param in the array (in our example, the `List`) is not null and is not an array, then `SimpleKeyGenerator` returns that single param to use as the key. If there is more than 1 item in the params array, then a `SimpleKey` is returned to use as the key.  If `SimpleKeyGenerator` were changed to handle `Collection` and `Map` as well as array in the case where the params array is length 1, then the example method would work fine since the key would be a `SimpleKey` instead of the actual `List`.  I propose changing the `SimpleKeyGenerator.generateKey(Object... params)` method to this: ```java 	public static Object generateKey(Object... params) {             if (params.length == 0) {                 return SimpleKey.EMPTY;             }             if (params.length == 1) {                 final Object param = params[0];                 if (param != null && !param.getClass().isArray()                         // this is the part that differs from SimpleKeyGenerator                         && !Collection.class.isAssignableFrom(param.getClass())                         && !Map.class.isAssignableFrom(param.getClass())) {                     return param;                 }             }             return new SimpleKey(params);         } ```","closed","status: invalid,","rlubbat","2019-08-14T21:52:11Z","2019-09-03T06:53:20Z"
"","23532","PathMatchingResourcePatternResolver cannot load resources with a '#' in their file name within JARs","**Affects:** spring version 5.1.5  ### Description  Given file `/validation/api#test.json` within `a.jar` which is in the classpath...  a project dependent a.jar, in project code   ```java ResourcePatternResolver resourceLoader = new PathMatchingResourcePatternResolver(); Resource[] resources22 = resourceLoader.getResources(""classpath*:/validation/**/api#test.json""); InputStream inputStream = resources[0].getInputStream(); ```  error:  ``` Exception in thread ""main"" java.io.FileNotFoundException: JAR entry validation/api not found in a.jar 	at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:142) 	at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:150) 	at java.net.URL.openStream(URL.java:1038) ```  ### Analysis  The `URL` created in `org.springframework.core.io.UrlResource.createRelative(String)` treats everything after `#` as the URL _fragment_, causing the file path to be incorrect when the file is last read.  URL object: - file: `a.jar!/validation/api` - path: `a.jar!/validation/api` - ref: `test.json`  ### Solutions  #### Solution 1  ```java extends PathMatchingResourcePatternResolver  @Override protected Set doFindPathMatchingJarResources() {   ....            result.add(rootDirResource.createRelative(ParseUtil.encodePath(relativePath)))   ... } ```  #### Solution 2  ```java  URL url = resources[0].getURL();             if (ResourceUtils.isJarURL(url) || ResourceUtils.isJarFileURL(url)) {                 String parent = url.toExternalForm().substring(0, url.toExternalForm().indexOf(""!/validation/"") + 13);                 String encodeFileName = url.toExternalForm().substring(url.toExternalForm().indexOf(""!/validation/"") + 13);                 String encodeFile = ParseUtil.encodePath(encodeFileName);                 URL url21 = new URL(parent + encodeFile);                 inputStream = url21.openStream();             } else {                 inputStream = resources[0].getInputStream();             } ```  ### Question  Is there any other better solution, or is there a problem with my use?","closed","type: enhancement,","tofdragon","2019-08-28T03:32:59Z","2019-09-20T19:56:35Z"
"","23538","Clarify documentation for @Transactional on interfaces","**Affects:** Spring framework version 5 ---  The [Spring Reference Manual](https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-annotations) states the following.  > The Spring team recommends that you annotate only concrete classes (and methods of concrete classes) with the `@Transactional` annotation, as opposed to annotating interfaces. You certainly can place the `@Transactional` annotation on an interface (or an interface method), but this works only as you would expect it to if you use interface-based proxies. The fact that Java annotations are not inherited from interfaces means that, if you use class-based proxies (proxy-target-class=""true"") or the weaving-based aspect (mode=""aspectj""), the transaction settings are not recognized by the proxying and weaving infrastructure, and the object is not wrapped in a transactional proxy, which would be decidedly bad.  But I tried an example using CGLIB proxy, and annotate `@Transactional` on an interface. I expect an error. But it does not throw any error, to my surprise. I guess Spring documentation needs to be updated, maybe?  We posted our code example here in coderanch.com/forum and one staff recommends me to ask Spring community. The detail code example and discussion is here. Please take a look: https://coderanch.com/t/714204/frameworks/Spring-Transactional-inheritance  Thanks.","open","in: data,","aCodeRancher","2019-08-28T15:34:35Z","2021-11-10T09:52:24Z"
"","23230","Exception while WebClient onStatus handler is applied leads to ByteBuf leak","**Affects:** Spring Framework 5.2.0.M3  **Description:** Throwing exception in `onStatus` handler causes ByteBuf leak.  Sample snippet with ByteBuf leak: ```kotlin     fun createComplaint(dto: Complaint) =         client             .post()             .uri(COMPLAINT)             .body(BodyInserters.fromObject(dto))             .retrieve()             .onStatus({ s -> s == HttpStatus.BAD_GATEWAY }, { resp -> throw BusinessException(SystemError.COMPLAINT_COULD_NOT_BE_CREATED) })             .bodyToMono(object : ParameterizedTypeReference>() {}) ```  No leak: ```kotlin     fun createComplaint(dto: Complaint) =         client             .post()             .uri(COMPLAINT)             .body(BodyInserters.fromObject(dto))             .retrieve()             .onStatus({ s -> s == HttpStatus.BAD_GATEWAY }, { resp -> Mono.error(BusinessException(SystemError.COMPLAINT_COULD_NOT_BE_CREATED)) })             .bodyToMono(object : ParameterizedTypeReference>() {}) ```  Error:      Log  ``` LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information. Recent access records:  #1: 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:286) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1478) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) #2: 	io.netty.buffer.AdvancedLeakAwareByteBuf.forEachByte(AdvancedLeakAwareByteBuf.java:670) 	io.netty.handler.codec.http.HttpObjectDecoder$HeaderParser.parse(HttpObjectDecoder.java:793) 	io.netty.handler.codec.http.HttpObjectDecoder.readHeaders(HttpObjectDecoder.java:592) 	io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:218) 	io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1478) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) #3: 	io.netty.buffer.AdvancedLeakAwareByteBuf.forEachByte(AdvancedLeakAwareByteBuf.java:670) 	io.netty.handler.codec.http.HttpObjectDecoder$HeaderParser.parse(HttpObjectDecoder.java:793) 	io.netty.handler.codec.http.HttpObjectDecoder.readHeaders(HttpObjectDecoder.java:572) 	io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:218) 	io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1478) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) #4: 	io.netty.buffer.AdvancedLeakAwareByteBuf.getUnsignedByte(AdvancedLeakAwareByteBuf.java:160) 	io.netty.handler.codec.http.HttpObjectDecoder.skipControlCharacters(HttpObjectDecoder.java:557) 	io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:193) 	io.netty.handler.codec.http.HttpClientCodec$Decoder.decode(HttpClientCodec.java:202) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1478) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) #5: 	Hint: 'reactor.left.httpCodec' will handle the message from this point. 	io.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:357) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1478) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) #6: 	io.netty.buffer.AdvancedLeakAwareByteBuf.internalNioBuffer(AdvancedLeakAwareByteBuf.java:736) 	io.netty.handler.ssl.SslHandler.toByteBuffer(SslHandler.java:1488) 	io.netty.handler.ssl.SslHandler.access$300(SslHandler.java:166) 	io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:296) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1332) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) #7: 	io.netty.buffer.AdvancedLeakAwareByteBuf.nioBufferCount(AdvancedLeakAwareByteBuf.java:706) 	io.netty.handler.ssl.SslHandler.toByteBuffer(SslHandler.java:1488) 	io.netty.handler.ssl.SslHandler.access$300(SslHandler.java:166) 	io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:296) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1332) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) Created at: 	io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:349) 	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187) 	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:178) 	io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115) 	io.netty.handler.ssl.SslHandler.allocate(SslHandler.java:2125) 	io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1327) 	io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1227) 	io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1274) 	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:796) 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:432) 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:333) 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) 	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	java.base/java.lang.Thread.run(Thread.java:834) : 6 leak records were discarded because the leak record count is targeted to 4. Use system property io.netty.leakDetection.targetRecords to increase the limit. ```","closed","type: enhancement,","indiv1d","2019-07-03T13:19:06Z","2019-07-05T09:58:29Z"
"","23164","Improve RSocketRequester.ResponseSpec Kotlin extensions","**Affects:** Spring Framework 5.2.0-M3  It would be nice to have _Kotlin extension functions_ for `RSocketRequester.ResponseSpec` so that one could write in Kotlin style, e.g.:  ``` requester.route(""find-by-id"")     .data(CustomerIdRequest(id))     .retrieveMono() ```  instead of  ``` requester.route(""find-by-id"")     .data(CustomerIdRequest(id))     .retrieveMono(Customer::class.java) ```  In the same way it would be nice to have `.retrieveFlux()`","closed","type: enhancement,","juergenzimmermann","2019-06-20T06:29:41Z","2019-06-21T13:27:17Z"
"","22861","Don't throw an exception in CookieLocaleResolver, fallback to default locale instead","**Affects:** Spring Framework 5.1.2  In the `CookieLocaleResolver`, would it be possible to ignore the parsing error altogether instead of throwing an `IllegalStateException`? Basically, I would want the `CookieLocaleResolver` to return the locale from the cookie, if valid, or the default locale otherwise - never throwing an exception.   It's easy enough to write a custom `CookieLocaleResolver`, but this seems like a bug to me. When a user has an invalid locale cookie it should not break anything, just fallback to the default locale.  This is similar to https://github.com/spring-projects/spring-framework/issues/19748 where the exception was swallowed for when it's an error dispatch.","closed","type: enhancement,","darioseidl","2019-04-30T11:44:38Z","2019-04-30T21:48:00Z"
"","23544","Cannot use relative path following placeholder in @TestPropertySource locations","**Affects:** Spring Boot version: 2.1.1.RELEASE with Spring-test version: 5.1.3.RELEASE  I'm trying to add custom path to `application.properties` file for one of my class test with use of `@TestPropertySource` like this:  ```java @RunWith(SpringRunner.class) @SpringBootTest @TestPropertySource(locations = ""file:${user.dir}/../config/application.properties"") public class AuthControllerITest {     //some code } ```  And I have an error caused by `FileNotFoundException` which says that it can not find this path: `config/application.properties`. When I remove this "".."" characters (so i've got `file:${user.dir}/config/application.properties`), then it gives me this path:  `/home/pawel/projekty/simulatorserver/server/config/application.properties`, but I want to get to this path: `/home/pawel/projekty/simulatorserver/config/application.properties` (without server directory).  I did some investigation and I found out that [org.springframework.util.StringUtils#cleanPath(String path)](https://github.com/spring-projects/spring-framework/blob/8d86a861a1eff13dd1abe14829e4213200509300/spring-core/src/main/java/org/springframework/util/StringUtils.java#L648) removes ${user.dir} from path.   I guess it should first resolve ${user.dir} to path, and then remove one directory from it.  For now I'm satisfied with this solution:  ```java @RunWith(SpringRunner.class) @SpringBootTest @TestPropertySource(locations = ""file:../config/application.properties"") public class AuthControllerITest {     //some code } ```  which gives me proper output: `/home/pawel/projekty/simulatorserver/config/application.properties`.  Stacktrace: ``` java.lang.IllegalStateException: Failed to load ApplicationContext  	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:125) 	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:108) 	at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) 	at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:246) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:227) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:289) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:291) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:246) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) 	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) 	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) 	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) 	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.IllegalStateException: Failed to add PropertySource to Environment 	at org.springframework.test.context.support.TestPropertySourceUtils.addPropertiesFilesToEnvironment(TestPropertySourceUtils.java:201) 	at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:104) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:117) 	... 24 more Caused by: java.io.FileNotFoundException: config/application.properties (No such file or directory) 	at java.base/java.io.FileInputStream.open0(Native Method) 	at java.base/java.io.FileInputStream.open(FileInputStream.java:219) 	at java.base/java.io.FileInputStream.(FileInputStream.java:157) 	at java.base/java.io.FileInputStream.(FileInputStream.java:112) 	at java.base/sun.net.www.protocol.file.FileURLConnection.connect(FileURLConnection.java:86) 	at java.base/sun.net.www.protocol.file.FileURLConnection.getInputStream(FileURLConnection.java:184) 	at org.springframework.core.io.UrlResource.getInputStream(UrlResource.java:173) 	at org.springframework.core.io.support.EncodedResource.getInputStream(EncodedResource.java:159) 	at org.springframework.core.io.support.PropertiesLoaderUtils.fillProperties(PropertiesLoaderUtils.java:99) 	at org.springframework.core.io.support.PropertiesLoaderUtils.fillProperties(PropertiesLoaderUtils.java:73) 	at org.springframework.core.io.support.PropertiesLoaderUtils.loadProperties(PropertiesLoaderUtils.java:59) 	at org.springframework.core.io.support.ResourcePropertySource.(ResourcePropertySource.java:86) 	at org.springframework.test.context.support.TestPropertySourceUtils.addPropertiesFilesToEnvironment(TestPropertySourceUtils.java:197) 	... 27 more ```","closed","type: bug,","Pancor","2019-08-29T13:31:25Z","2019-08-31T17:08:14Z"
"","23193","AbstractCacheManager.getCache() breaks contract of CacheManager.getCache()","**Affects:** Spring Boot version 2.1.3  --- **Problem:** According to the documentation, `CacheManager.getCache(String)` must return > the associated cache, or null if none found  However, `AbstractCacheManager` doesn't implement this contract. Instead, it always returns a not-null value disregards to what was requested. In fact, it creates a new cache every time an unknown cache is requested.  It is misleading and error-prone. I relied on this functionality in my code and ended up with broken business logic.  **More details.**  Here is the documentation of `CacheManager.getCache(String)`:  > Return the cache associated with the given name. >Params: name – the cache identifier (must not be null) >Returns: the associated cache, or null if none found  And here is the implementation of `AbstractCacheManager.getCache(String)`:  ```java @Override @Nullable public Cache getCache(String name) {     Cache cache = this.cacheMap.get(name);     if (cache != null) {         return cache;     }     else {         // Fully synchronize now for missing cache creation...         synchronized (this.cacheMap) {             cache = this.cacheMap.get(name);             if (cache == null) {                 cache = getMissingCache(name);                 if (cache != null) {                     cache = decorateCache(cache);                     this.cacheMap.put(name, cache);                     updateCacheNames(name);                 }             }             return cache;         }     } } ```  **Potential solutions:** Please either update the documentation and make sure it is mentioned that the method could also create a cache or update the implementation, or, if I am missing something, make the documentation transparent.","closed","in: core,","Shpota","2019-06-25T08:55:25Z","2019-06-25T12:02:48Z"
"","23127","Document that @TransactionalEventListener is not supported with ReactiveTransactionManager","**Affects:** Spring Boot 2.2.0.M3  ---  If we publish the events within the transactional reactive methods, for example:  ```java @Transactional public Mono create(Model model, ModelEvent.Type type) {     return repo.save(model)             .doOnSuccess(m -> publisher.publishEvent(new ModelEvent(m, type))); } ``` then the 'event listener' method with `@TransactionalEventListener` is not invoked (regardless of whether the `@Async` annotation is used or not):  ```java // @Async @TransactionalEventListener(condition = ""#event.inTransactionEventListener()"") public void handleEventInTransactionEventListener(ModelEvent event) {     log.info(""[i] Handled event: {}, in transactional event listener"", event.getModel()); } ```  Related demo is [here](https://github.com/Cepr0/sb-reactive-transaction-publishing-event-issue).","open","type: documentation,","Cepr0","2019-06-13T09:04:09Z","2022-06-15T13:40:43Z"
"","23126","IllegalStateException while publishing events within a transactional reactive method if 'event listener' method has @Transactional annotation","**Affects:** Spring Boot 2.2.0.M3  ---  If we publish the events within the transactional reactive methods, for example:  ```java @Transactional public Mono create(Model model, ModelEvent.Type type) {     return repo.save(model)             .doOnSuccess(m -> publisher.publishEvent(new ModelEvent(m, type))); } ``` then `IllegalStateException` is raised with a message:   `Specified transaction manager is not a PlatformTransactionManager: org.springframework.data.mongodb.ReactiveMongoTransactionManager`   if the 'event listener' method has `@Transactional` annotation (with MANDATORY parameter, for example, to check if we are really in the existent transaction):  ```java @Transactional(propagation = Propagation.MANDATORY) @EventListener(condition = ""#event.withTransactional()"") public void handleEventWithTransactional(ModelEvent event) {     log.info(""[i] Handled event: {}, with transactional"", event.getModel()); } ```  Detailed demo is [here](https://github.com/Cepr0/sb-reactive-transaction-publishing-event-issue).","open","in: data,","Cepr0","2019-06-13T08:59:41Z","2021-11-10T09:27:04Z"
"","23647","oauth2 with ForwardedHeaderFilter bean does not respect Forwarded, nor X-Forwarded-Prefix headers","**Affects:** Spring Boot 2.1.8.RELEASE (Spring Framework 5.1.9) --- I am using spring-security-oauth2-client for ""log in"" using github. My application is being deployed behind reverse proxy (nginx). Generated logi npage from oauth artefact does not have correct links (if I have more than one provider, login page lists them all and given links have missing prefix from http header X-Forwarded-Prefix).  Another problem is that redirect sent to github authorization url is wrong and it does not respect Forwarded header.  See also my similar report for simple login for spring-security here: https://github.com/spring-projects/spring-security/issues/7081  My codebase now contains just https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2login sample project ""converted"" to maven, with added single bean ForwardedHeaderFilter.  More info for second described problem: My nginx is sending proxied requests like this one: ``` 2019-09-17 13:30:28.962 DEBUG 1 --- [nio-8080-exec-2] o.a.coyote.http11.Http11InputBuffer      : Received [GET / HTTP/1.0 Forwarded: for=81.92.1.1;host=qpp.qpp.sk:443;proto=https X-Forwarded-Prefix: /oauth2login-test Host: internal.qpp.sk:18080 Connection: close user-agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:69.0) Gecko/20100101 Firefox/69.0 accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 accept-language: en-US,en;q=0.5 accept-encoding: gzip, deflate, br dnt: 1 upgrade-insecure-requests: 1 cookie: JSESSIONID=BFA1XAFB12D5842E470208C980AC8E  ] ```  Redirect url is than generated (copied log message here): ``` 2019-09-17 13:30:29.090 DEBUG 1 --- [nio-8080-exec-3] o.s.s.web.DefaultRedirectStrategy        : Redirecting to 'https://github.com/login/oauth/authorize?response_type=code&client_id=8d9244444444444&scope=read:user&state=ebCgdemkfeWEFDWw43m-vSQhRREDb_1ee44rRorRkRNjs%3D&redirect_uri=http://internal.qpp.sk:18080/login/oauth2/code/github' ```  As you see redirect_uri parameter is set to internal address, where my spring application actually runs, instead of nginx proxy, which is available from Internet (qpp.qpp.sk).","closed","status: invalid,","luvarqpp","2019-09-17T13:37:26Z","2019-09-26T10:13:17Z"
"","23497","OutOfMemoryError on TomcatEmbeddedContext when trying to precompile JSP files","**Affects:** Spring Boot 2.1.0 --- We are precompiling our JSP files on application startup and we are getting an OutOfMemoryError when migrating our application from Spring Boot 2.0.4 to 2.1.0. ``` java.lang.OutOfMemoryError: Requested array size exceeds VM limit 	at java.util.ArrayList.(ArrayList.java:153) ~[na:1.8.0_202] 	at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext$$Lambda$349/790229674.apply(Unknown Source) ~[na:na] 	at java.util.Map.computeIfAbsent(Map.java:957) ~[na:1.8.0_202] 	at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.getLoadOnStartupWrappers(TomcatEmbeddedContext.java:75) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.lambda$deferredLoadOnStartup$0(TomcatEmbeddedContext.java:65) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext$$Lambda$348/215632153.run(Unknown Source) ~[na:na] 	at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.doWithThreadContextClassLoader(TomcatEmbeddedContext.java:109) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedContext.deferredLoadOnStartup(TomcatEmbeddedContext.java:64) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.performDeferredLoadOnStartup(TomcatWebServer.java:282) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.start(TomcatWebServer.java:200) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.startWebServer(ServletWebServerApplicationContext.java:300) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:162) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.2.RELEASE.jar:5.1.2.RELEASE] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.0.RELEASE.jar:2.1.0.RELEASE] 	at com.example.demo.DemoApplication.main(DemoApplication.java:19) [classes/:na] ```  We do the precompilation by creating a servlet for each of our JSP files like this: ```java @Bean public ServletContextInitializer preCompileJspsAtStartup() {     return servletContext -> {         foreachJSP(jspPath -> {             ServletRegistration.Dynamic reg = servletContext.addServlet(jspPath, Constants.JSP_SERVLET_CLASS);             reg.addMapping(jspPath);         });     }; } ``` Here `servletContext.addServlet` creates a new StandardWrapper for each of the files. This Wrapper sets the loadOnStartup value to `-1` by default but returns `Integer.MAX_VALUE` for JSP servlets. ```java @Override public int getLoadOnStartup() {     if (isJspServlet && loadOnStartup < 0) {         /*          * JspServlet must always be preloaded, because its instance is          * used during registerJMX (when registering the JSP          * monitoring mbean)          */          return Integer.MAX_VALUE;     } else {         return this.loadOnStartup;     } } ```  The error is happening on TomcatEmbeddedContext because it is trying to create an ArrayList with the size of `order` (which in case of a JSP is `Integer.MAX_VALUE`). ```java 73: int order = wrapper.getLoadOnStartup(); 74: if (order >= 0) {         // next line is calling new ArrayList<>(order) instead of new ArrayList<>() 75:     grouped.computeIfAbsent(order, ArrayList::new); 76:     grouped.get(order).add(wrapper); 77: } ```  You can avoid the error by simple explicitly setting the `loadOnStartup` value to a positive integer. ```java @Bean public ServletContextInitializer preCompileJspsAtStartup() {     return servletContext -> {         foreachJSP(jspPath -> {             ServletRegistration.Dynamic reg = servletContext.addServlet(jspPath, Constants.JSP_SERVLET_CLASS);             reg.addMapping(jspPath);             reg.setLoadOnStartup(99); // manually set to avoid problems         });     }; } ```  You can replicate the error by running this simple application: https://github.com/jagobagascon/Spring-Boot-OutOfMemoryError-Bug","closed","","jagobagascon","2019-08-21T13:01:34Z","2019-08-21T13:04:46Z"
"","22979","Java 11 ""No visible constructors in class"" CGLib wrongly used? Works in Java 8","**Affects:** Spring 5.1.7.RELEASE Java version affected: 11 ---  I have a class that implements an interface, I have an aspect that targets a method implemented by my class with an `Around` advice (targeting an annotation with my pointcut expression). The constructor is private on my service class, its coming from a library out of my control. Even though my service class implements an interface, for some reason CGLib continues to be used for proxying instead of a JDK proxy. When using Java 8, the code works perfectly fine, however when switched to Java 11 the exception is thrown:  ``` java.lang.IllegalStateException: Failed to load ApplicationContext Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'springAopIssueApplication': Unsatisfied dependency expressed through method 'setMyService' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'myService' defined in test.springaopissue.SpringAopIssueApplication$MyConfig: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class test.springaopissue.SpringAopIssueApplication$MyServiceImpl: Common causes of this problem include using a final class or a non-visible class; nested exception is java.lang.IllegalArgumentException: No visible constructors in class test.springaopissue.SpringAopIssueApplication$MyServiceImpl Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'myService' defined in test.springaopissue.SpringAopIssueApplication$MyConfig: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class test.springaopissue.SpringAopIssueApplication$MyServiceImpl: Common causes of this problem include using a final class or a non-visible class; nested exception is java.lang.IllegalArgumentException: No visible constructors in class test.springaopissue.SpringAopIssueApplication$MyServiceImpl Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class test.springaopissue.SpringAopIssueApplication$MyServiceImpl: Common causes of this problem include using a final class or a non-visible class; nested exception is java.lang.IllegalArgumentException: No visible constructors in class test.springaopissue.SpringAopIssueApplication$MyServiceImpl Caused by: java.lang.IllegalArgumentException: No visible constructors in class test.springaopissue.SpringAopIssueApplication$MyServiceImpl ```  The following code reproduces the issue:  ```java package test.springaopissue;  import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; import org.springframework.stereotype.Component;  @SpringBootApplication @EnableAspectJAutoProxy public class SpringAopIssueApplication implements ApplicationRunner {     private MyService myService;      public static void main(final String[] args) {         SpringApplication.run(SpringAopIssueApplication.class, args);     }      @Override     public void run(final ApplicationArguments args) throws Exception {         myService.myMethod();     }      @Autowired     public void setMyService(final MyService myService) {         this.myService = myService;     }      @Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE, ElementType.METHOD })     @Retention(RetentionPolicy.RUNTIME)     @Inherited     public @interface MyAnnotation {     }      @Configuration     public class MyConfig {          @Bean         MyService myService() {             return MyServiceImpl.newBuilder()                     .build();         }     }      @Aspect     @Component     public static class MyAspect {         private static final Logger LOGGER = LoggerFactory.getLogger(MyAspect.class);          @Around(""execution (@test.springaopissue.SpringAopIssueApplication.MyAnnotation * *.*(..))"")         public Object surround(final ProceedingJoinPoint pjp) throws Throwable {             try {                 LOGGER.info(""Starting execution..."");                 return pjp.proceed();             } finally {                 LOGGER.info(""... done executing"");             }         }     }      public interface MyService {         void myMethod();     }      public static class MyServiceImpl implements MyService {         private static final Logger LOGGER = LoggerFactory.getLogger(MyServiceImpl.class);          private MyServiceImpl() {         }          @MyAnnotation         @Override         public void myMethod() {             LOGGER.info(""executing myMethod"");         }          public static Builder newBuilder() {             return new Builder();         }          public static class Builder {             private Builder() {             }              public MyService build() {                 return new MyServiceImpl();             }         }     } } ```  To reproduce use 	  ```xml    11  ```  If you switch to java 8 the issue goes away:  ```xml    1.8  ```","open","in: core,","csueiras","2019-05-15T19:16:24Z","2022-04-20T14:49:52Z"
"","23273","Proposal for IN operator in SpEL","**Affects:** current/all  --- Currently SpEL does not have an `IN` operator. If you want to test whether a value is contained in a collection, you can do things like:  ```java thingies.contains(""foo"") // or, for literals {""foo"", ""bar"", ""baz""}.contains(""foo"") ```  ## Use case  A tool with a target audience of non-technical users who nonetheless are familiar with SQL and similar query syntax.  ## Proposal  ```java ""foo"" IN thingies // or, for literals ""foo"" IN {""foo"", ""bar"", ""baz""} ```  This would add support for an `IN` operator that (roughly) would resolve to `true` if the right-hand operand is an `Iterable` and has an element that passes `equals` with the left-hand operand.  Notice I'm not proposing to change how list literals are done or anything; the intention is this would not be a breaking change.  ## Prior art  SpEL already has a few things like this that provide a more relatable syntax instead of Java methods and operators, e.g:  ```java foo AND bar // effectively same as foo && bar  foo == bar // effectively same as foo.equals(bar) ```  There was an issue #12500 that was closed due to years of inactivity. At this point I'd be pleased to just do the pull request but want to first gauge whether it would be desirable from the project's point of view.","open","in: core,","davidjgoss","2019-07-10T22:37:56Z","2019-07-23T08:00:23Z"
"","23238","@RequestBody when contentType=""application/x-www-form-urlencoded"" does not re-encode `*`","**Affects:** at least >= 5.0.4  --- Hi,  When I try to inject request body to a controller when content type is application/x-www-form-urlencoded and contains some encoded characters the result differs from the original body sent to the application.  I reproduced the bug with this case project https://github.com/szatkus/spring-bug (there is a test case, but the behaviour is the same both with MockMvc and real runtime)  I figured this is what happens: 1. A request is sent with body `fff=aaa%2Abbb`. 2. The body is converted to a parameters list (`fff = ""aaa*bbb""`) because of `application/x-www-form-urlencoded` and POST method. 3. For injecting the request body, Spring reconstructs it from the parameters list (`ServletServerHttpRequest.getBodyFromServletRequestParameters`), but information about encoding is lost (so injected body is `fff=aaa*bbb`).  In case you'd be curious about my use case, [I need to verify Slack signature and I need full, unchanged body for that](https://api.slack.com/docs/verifying-requests-from-slack#how_to_make_a_request_signature_in_4_easy_steps__an_overview).","closed","status: declined,","szatkus","2019-07-04T19:35:28Z","2019-12-09T10:09:06Z"
"","22950","spring.ftl is missing in spring-webflux","**Affects:** `spring-webflux` 5.1.6  In `org.springframework.web.reactive.result.view.freemarker.FreeMarkerConfigurer` the `spring.ftl` is mentioned, but actually does not exist.  I tried to use the one shipped with `spring-webmc`, but that led to further problems.  Please provide a webflux ready version of the ftl.   Thank you!","closed","status: superseded,","DerThanne","2019-05-13T08:52:24Z","2019-05-28T16:01:54Z"
"","23730","Spring data bug throwing java.lang.LinkageError exceptions","**Affects:** \spring-data-mongodb:2.1.10.RELEASE  After many inserts into MongoDB (using MongoTemplate.doInsertBatch) we get java.lang.LinkageError exceptions (see below). We think the bug is in the ClassGeneratingPropertyAccessorFactory because no exceptions are thrown if you would use the BeanWrapperPropertyAccessorFactory instead.  This can be reproduced with the following code (takes about 100K iterations).  `import java.util.stream.IntStream;  import org.springframework.data.mapping.IdentifierAccessor; import org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory; import org.springframework.data.mapping.model.Property; import org.springframework.data.mapping.model.SimpleTypeHolder; import org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntity; import org.springframework.data.mongodb.core.mapping.CachingMongoPersistentProperty; import org.springframework.data.util.ClassTypeInformation; import org.springframework.data.util.TypeInformation;  public class SpringDataBug {      public static void main(String[] args) {         IntStream.range(0, 1_000_000).forEach(i -> {             MyBean bean = new MyBean(i);             TypeInformation typeInformation = ClassTypeInformation.from(MyBean.class);             BasicMongoPersistentEntity persistentEntity = new BasicMongoPersistentEntity<>(typeInformation);             try {                 Property idProperty = Property.of(ClassTypeInformation.from(MyBean.class), MyBean.class.getDeclaredField(""id""));                 persistentEntity.addPersistentProperty(new CachingMongoPersistentProperty(idProperty, persistentEntity, SimpleTypeHolder.DEFAULT, null));             } catch (NoSuchFieldException e) {                 e.printStackTrace();             }             persistentEntity.setPersistentPropertyAccessorFactory(new ClassGeneratingPropertyAccessorFactory());             IdentifierAccessor identifierAccessor = persistentEntity.getIdentifierAccessor(bean);             System.out.println(identifierAccessor.getIdentifier());         });     }      private static class MyBean {          int id;          public MyBean(int id) {             this.id = id;         }          public int getId() {             return id;         }      }  }`  It throws the following exception:  ``` Exception in thread ""main"" java.lang.RuntimeException: java.lang.IllegalStateException: org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app') 	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory.createAccessorClass(ClassGeneratingPropertyAccessorFactory.java:200) 	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory.potentiallyCreateAndRegisterPersistentPropertyAccessorClass(ClassGeneratingPropertyAccessorFactory.java:184) 	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory.getPropertyAccessor(ClassGeneratingPropertyAccessorFactory.java:92) 	at org.springframework.data.mapping.model.BasicPersistentEntity.getPropertyAccessor(BasicPersistentEntity.java:455) 	at org.springframework.data.mapping.model.IdPropertyIdentifierAccessor.(IdPropertyIdentifierAccessor.java:54) 	at org.springframework.data.mapping.model.BasicPersistentEntity.getIdentifierAccessor(BasicPersistentEntity.java:471) 	at SpringDataBug.lambda$main$0(SpringDataBug.java:26) 	at java.base/java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Streams.java:104) 	at java.base/java.util.stream.IntPipeline$Head.forEach(IntPipeline.java:593) 	at SpringDataBug.main(SpringDataBug.java:15) Caused by: java.lang.IllegalStateException: org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app') 	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory$PropertyAccessorClassGenerator.generateCustomAccessorClass(ClassGeneratingPropertyAccessorFactory.java:326) Caused by: java.lang.IllegalStateException: org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app')  	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory.createAccessorClass(ClassGeneratingPropertyAccessorFactory.java:198) 	... 9 more Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app') 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:530) Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app')  	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory$PropertyAccessorClassGenerator.generateCustomAccessorClass(ClassGeneratingPropertyAccessorFactory.java:324) 	... 10 more Caused by: java.lang.LinkageError: loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app') 	at java.base/java.lang.ClassLoader.defineClass1(Native Method) 	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016) Caused by: java.lang.LinkageError: loader 'app' attempted duplicate class definition for SpringDataBug$MyBean_Accessor_4j0ajz. (SpringDataBug$MyBean_Accessor_4j0ajz is in unnamed module of loader 'app')  	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:527) 	... 11 more   ```","closed","for: external-project,","LukMorbeeClarivate","2019-09-30T13:59:02Z","2019-10-04T07:02:09Z"
"","22875","Improve Kotlin integration testing documentation","**Affects:** \5.2.0.M1  --- I just read the [kotlin documentation for spring testing framework](https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#testing)  In my opinion is the unit test documentation is mature. On the other hand, I would like to see a more detailed documentation related to integration testing. Specially, how I can mock _transitive dependencies_ with _mockk_ in the component testing environment.  Example: I test _SampleController_ which depends on _SampleService_. In an `@WebMvcTest(SampleController::class)`-Test, how can I inject a mock of the SampleService into the SampleController, which is under integration test?  Context: The bean _SampleService_ Bean is not loaded in the test application-context with the `@WebMvcTest`-Annotation. Therefore, instead of dependency injection, I would like to do mock injection. Preferably with [mockk](mockk.io) mocks. I chose mockk to be in line with unit test mocking framework under kotlin.","closed","type: documentation,","mattbaumann","2019-05-02T22:52:38Z","2019-07-17T14:46:53Z"
"","23349","Javadoc missing on some public BeanDefinitionParserDelegate methods","**Affects:** \2.5.1 (also master) --- I have inherited some code and was doing some maintenance inside.  This code called `BeanDefinitionParserDelegate#parseCustomElement(Element)` and now also calls `BeanDefinitionParserDelegate#parseCustomElement(Element, BeanDefinition)`.  I noted that these methods have no javadoc and this engendered a question ""How mainstream is this/are we doing the right thing"".  Having eyeballed the (Spring) code I'm reasonably sure that this the right thing and whilst I'd imagine that custom parsers are not mainstream I'm comfortable with the code.  But can we add some javadoc?  I'll try and pull together a PR if it would help. but I note that there are other methods in this class which are missing javadoc and I'd not be comfortable adding it to them.  Thanks  /Rod","closed","type: enhancement,","rodwiddowson","2019-07-24T13:50:01Z","2019-08-01T13:33:16Z"
"","23577","UriComponentBuilder does not support opaque URI scheme","**Affects:** \<5.1.3>  ---  Please see my stack overflow post. In this post, you can see that UriComponentBuilder fails to work given an opaque URL, when it should be according to the RFC standard. Please see the answer of the asked question  https://stackoverflow.com/questions/46833320/are-query-parameters-allowed-in-opaque-uris/50263219#50263219","closed","","michaelmaitland","2019-09-04T03:03:30Z","2019-09-18T20:10:50Z"
"","23554","Application can't be closed gracefully with cron task registered","**Affects:** \<4.3.25.RELEASE>  --- Hello  I found a strange Spring behavior. If we implement `SchedulingConfigurer` interface like this:   ```java @EnableScheduling @Configuration public class CoreConfiguration implements SchedulingConfigurer {    @Bean   public TaskScheduler taskScheduler() {     ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();     scheduler.setWaitForTasksToCompleteOnShutdown(true);      return scheduler;   }    @Override   public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {     taskRegistrar.setTaskScheduler(taskScheduler());   } } ```   register a cron task and call `context.close()` then java application will  wait until next cron task planned time. (Java main thread will wait for worker thread).  It is strange because if we don't manually set `TaskScheduler` on `ScheduledTaskRegistrar` context will close fine.  To make it clear I created a repo with demonstration https://github.com/akvone/Spring-cron-bug.","open","in: core,","akvone","2019-08-31T19:13:23Z","2021-11-10T11:58:02Z"
"","23159","Support multipart/related and multipart/mixed MediaTypes in RestTemplate","**Affects:** \  At the moment, the `RestTemplate` posts multipart with `Content-Type: multipart/form-data`.   We have a requirement to post multipart data with a `Content-Type` of `multipart/mixed` or `multipart/related`.  C# provides flexibility for this with a `MultipartContent` with a subtype parameter.    https://docs.microsoft.com/en-us/dotnet/api/system.net.http.multipartcontent.-ctor?view=netframework-4.8#System_Net_Http_MultipartContent__ctor_System_String_  Any recommendations?","closed","type: enhancement,","sethcleveland","2019-06-19T23:38:04Z","2020-02-28T17:19:11Z"
"","23436","Reference documentation for ContextClosedEvent is misleading","**Affects:** \  ---  The Spring Framework [reference documentation](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-ctx-events-tbl) for `ContextClosedEvent` states the following:  > Published **when the ApplicationContext is closed** by using the close() method on the ConfigurableApplicationContext interface. **Here, “closed” means that all singleton beans are destroyed.** ...  It seems that such a definition may be misleading as soon as it sounds like event is triggered **after** beans destruction.  Actually `AbstractApplicationContext#doClose` defines the real execution order.","closed","type: documentation,","akvone","2019-08-08T16:21:28Z","2019-08-09T21:31:52Z"
"","23211","MimeTypeUtils.parseMimeType returns null MIME type in case of high concurrency","**Affects:** 5.5.0.M2 + (Problem observed in 5.5.0.M2, probably in any release after 2/5/2019) --- I am getting an NPE on line MediaType.java:550 of spring-web-5.2.0.M2.jar (currently line 563 in master) because the cache is apparently returning a null type from MimeTypeUtils.parseMimeType(). ``` 	public static MimeType parseMimeType(String mimeType) { 		return cachedMimeTypes.get(mimeType); 	} ``` and the method below doesn't account for a null return from the LRU cache ```cachedMimeTypes``` ``` 	public static MediaType parseMediaType(String mediaType) { 		MimeType type; 		try { 			type = MimeTypeUtils.parseMimeType(mediaType); 		} 		catch (InvalidMimeTypeException ex) { 			throw new InvalidMediaTypeException(ex); 		} 		try { 			return new MediaType(type.getType(), type.getSubtype(), type.getParameters()); //NPE 		} 		catch (IllegalArgumentException ex) { 			throw new InvalidMediaTypeException(mediaType, ex.getMessage()); 		} 	} ``` The ConcurrentLruCache in MimeTypeUtils must have a bug b/c that is the only way null type could be getting returned. The ConcurrentLruCache.get(key) method does returns in two places and one of them is returning a null. The return in the write lock block looks safe but the return in the read lock block could return null if the internal queue has the same key in it twice at which point the internal cache map wouldn't have the value anymore and then a null could be returned. ``` 		public V get(K key) { 			this.lock.readLock().lock(); 			try { 				if (this.queue.remove(key)) { 					this.queue.add(key); 					return this.cache.get(key); 				} 			} 			finally { 				this.lock.readLock().unlock(); 			} 			this.lock.writeLock().lock(); 			try { 				if (this.queue.size() == this.maxSize) { 					K leastUsed = this.queue.poll(); 					if (leastUsed != null) { 						this.cache.remove(leastUsed); 					} 				} 				V value = this.generator.apply(key); 				this.queue.add(key); 				this.cache.put(key, value); 				return value; 			} 			finally { 				this.lock.writeLock().unlock(); 			} 		} ``` Assume two threads go through read lock block at same time, one of them will remove the key and add it back to front of queue, the other thread will fall through and wait for the write lock. Once the thread gets the write lock it will also add the key to the queue and now the key will be in the queue twice. Eventually the duplicate key might work its way to least used and get removed from the cache. At that point, all subsequent requests for that key will return null because the queue still has the key but the hash map doesn't have the value.   This is pretty serious b/c once it starts happening for a particular mime type, I think the application needs to be restarted.","closed","type: enhancement,","hdeadman","2019-06-28T17:29:11Z","2019-06-28T22:21:02Z"
"","23768","Corrupted multipart + correct content-length lead to Flux hanging","**Affects:** 5.2.0.RELEASE and earlier  --- TLDR  Issue is related to interrogation with `org.synchronoss.cloud.nio.multipart.NioMultipartParser` In particular to code around line [SynchronossPartHttpMessageReader.java#L173](https://github.com/spring-projects/spring-framework/blob/v5.2.0.RELEASE/spring-web/src/main/java/org/springframework/http/codec/multipart/SynchronossPartHttpMessageReader.java#L173)  **Suggested fix could be** Replace ```Java 	try { 		parser.close(); 	} ``` With something like ```Java 	try { 		parser.close(); 		// ensure that parts-sink will be notified about data-stream completion 		listener.onAllPartsFinished(); 	} ``` Attached tests code (maven projects)  * [reactor-multipart-issue-brief.zip](https://github.com/spring-projects/spring-framework/files/3704076/reactor-multipart-issue-brief.zip)  * [reactor-multipart-issue-full.zip](https://github.com/spring-projects/spring-framework/files/3704080/reactor-multipart-issue-full.zip)   Steps to reproduce - description  * Prepare valid multipart payload,  * Then truncate few bytes of that payload and post this truncated version (with matching to truncation) content-length to some multipart-accepting controller  **Expected behavior** some exception raised/emitted (reporting about corrupted payload) **Actual behavior** `Flux` passed to controller ""never completes"" (hanged forever). For some combinations of artifacts it is properly canceled when connection reset (termination) occurs, but for code snippet (attached) below - it looks like it doesn't (more likely this flux just ""leaks"" - on-finally does not executed on it)  Steps to reproduce - code (test case)  Simple single-file example could look like one below (it is also available in attached files) Run with maven ``` mvn clean test ``` File **[reactor-multipart-issue-brief.zip](https://github.com/spring-projects/spring-framework/files/3704076/reactor-multipart-issue-brief.zip)/reactor-multipart-issue-brief/src/test/kotlin/issue/multipart/WebFluxMultipartTest.kt** ```Kotlin package issue.multipart  //import org.junit.jupiter.api.Timeout import com.fasterxml.jackson.databind.ObjectMapper import io.netty.buffer.ByteBufAllocator import io.netty.channel.ChannelOption import issue.multipart.MainConfig.Companion.SERVER_PORT import org.junit.jupiter.api.Test import org.slf4j.LoggerFactory import org.springframework.context.ApplicationContext import org.springframework.context.annotation.Bean import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration import org.springframework.core.io.buffer.DataBuffer import org.springframework.core.io.buffer.DataBufferFactory import org.springframework.core.io.buffer.NettyDataBufferFactory import org.springframework.http.HttpStatus import org.springframework.http.ResponseEntity import org.springframework.http.codec.multipart.Part import org.springframework.http.server.reactive.HttpHandler import org.springframework.http.server.reactive.ReactorHttpHandlerAdapter import org.springframework.test.context.junit.jupiter.SpringJUnitConfig import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestBody import org.springframework.web.bind.annotation.RequestMapping import org.springframework.web.bind.annotation.RestController import org.springframework.web.reactive.config.EnableWebFlux import org.springframework.web.server.ServerWebExchange import org.springframework.web.server.adapter.WebHttpHandlerBuilder import reactor.core.publisher.Flux import reactor.core.publisher.Mono import reactor.core.publisher.toMono import reactor.netty.DisposableServer import reactor.netty.http.server.HttpServer import reactor.netty.resources.LoopResources import reactor.netty.tcp.TcpServer import java.net.InetSocketAddress import java.net.URL import java.nio.file.Files import java.nio.file.Paths import java.time.Duration import kotlin.test.assertNotNull  @SpringJUnitConfig(MainConfig::class) class WebFluxMultipartTest {     val rootUrl = ""http://localhost:$SERVER_PORT""      val logger = LoggerFactory.getLogger(javaClass)      // this will use original (NOT-patched) version of `org.springframework.http.codec.multipart.SynchronossPartHttpMessageReader`     @Test     //@Timeout(15)     fun testFailNotPatchedPostFormDataWithJdkClient() {         val res = runCatching { testPostFormDataWithJdkClient(corruptMultipartData = true) }         logger.info(res.toString(), res.exceptionOrNull())         assertNotNull(res.exceptionOrNull())     }      fun testPostFormDataWithJdkClient(corruptMultipartData: Boolean) {         val url = URL(""$rootUrl/io-target/post-form-data"")         val con = url.openConnection()         con.doOutput = true         con.addRequestProperty(""Content-Type"", ""multipart/form-data;boundary=NbjrKgjbsaMLdnMxMfDpD6myWomYc0qNX0w;charset=UTF-8"")         val body = Files.readAllBytes(Paths.get(javaClass.getResource(""post-form-data-valid"").toURI()))          con.getOutputStream().use { out ->             if (corruptMultipartData) {                 out.write(body, 0, body.size - 8)             } else {                 out.write(body)             }         }         logger.info(""bytes[0..4]:"" + con.getInputStream().readNBytes(4)!!.run { ""${contentToString()}:${String(this)}"" })         logger.info(""bytes[4...]:"" + String(con.getInputStream().readAllBytes()))     }  }  @RestController @RequestMapping(""/io-target"") class IoTargetController {      val logger = LoggerFactory.getLogger(javaClass)      @PostMapping(""/post-form-data"")     fun postFormData(         @RequestBody parts: Flux,         serverExchange: ServerWebExchange     ): Mono>> = run {         logger.info(""postFormData: request.headers.content-length: ${serverExchange.request.headers[""content-length""]}"")         ResponseEntity.status(HttpStatus.OK).body(             Mono.defer {                 ""raw:data:1234567"".toDataBuffer().toMono().delayElement(Duration.ofSeconds(1)).log(""respond-0"")             }.concatWith(                 ""r01:data:1234567"".toDataBuffer().toMono().delayElement(Duration.ofSeconds(1)).log(""respond-1"")             ).concatWith(                 parts.log(""parts"").flatMap {                     it.content().log(""part-content"").then().thenReturn(""ok"")                 }.then(                     ""r02:data:1234567"".toDataBuffer().toMono().delayElement(Duration.ofSeconds(1)).log(""respond-2"")                 )             ).concatWith(                 ""r03:data:1234567"".toDataBuffer().toMono().delayElement(Duration.ofSeconds(1)).log(""respond-3"")             ).log(""response-body"")         )             .toMono().delayElement(Duration.ofSeconds(1)).doFinally { signal ->                 logger.info(""${::postFormData.name}: doFinally: $signal"")             }     }  }  @Configuration @EnableWebFlux @Import(IoTargetController::class) open class MainConfig {      companion object {         const val SERVER_PORT = 9011     }      @Bean     open fun objectMapper(): ObjectMapper = ObjectMapper()      @Bean     open fun httpHandler(applicationContext: ApplicationContext): HttpHandler =         WebHttpHandlerBuilder.applicationContext(applicationContext).build()      @Bean     open fun loopResources(): LoopResources =         LoopResources.create(""issue.multipart-LoopResources"", 16, false)      @Bean(destroyMethod = ""dispose"")     open fun httpServer(         loopResources: LoopResources,         httpHandler: HttpHandler     ): DisposableServer = run {         val tcpServer = TcpServer.create()             //.wiretap(true)             .option(ChannelOption.ALLOCATOR, ByteBufAllocator.DEFAULT)             .runOn(loopResources)             .addressSupplier { InetSocketAddress(SERVER_PORT) }         HttpServer.from(tcpServer)             .handle(ReactorHttpHandlerAdapter(httpHandler))             .bindNow()     }  }  val byteBufAllocator: ByteBufAllocator = ByteBufAllocator.DEFAULT val bufferFactory: DataBufferFactory = NettyDataBufferFactory(byteBufAllocator)  fun String.toDataBuffer(): DataBuffer = this.toByteArray().let { bytes ->     bufferFactory.allocateBuffer(bytes.size).apply { write(bytes) } } ```  Results of this test execution are following: ``` 2019-10-08 21:35:12.505 INFO org.springframework.test.context.support.DefaultTestContextBootstrapper Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener, org.springframework.test.context.event.EventPublishingTestExecutionListener] 2019-10-08 21:35:12.515 INFO org.springframework.test.context.support.DefaultTestContextBootstrapper Using TestExecutionListeners: [org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@5db4c359, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@209775a9, org.springframework.test.context.support.DirtiesContextTestExecutionListener@18e7143f, org.springframework.test.context.event.EventPublishingTestExecutionListener@f9b7332]  2019-10-08 21:35:14.083 INFO issue.multipart.IoTargetController postFormData: request.headers.content-length: [257] 2019-10-08 21:35:15.118 INFO response-body onSubscribe(FluxConcatArray.ConcatArraySubscriber) 2019-10-08 21:35:15.119 INFO response-body request(1) 2019-10-08 21:35:15.126 INFO respond-0 onSubscribe([Fuseable] MonoDelayElement.DelayElementSubscriber) 2019-10-08 21:35:15.126 INFO respond-0 request(1) 2019-10-08 21:35:15.127 INFO issue.multipart.IoTargetController postFormData: doFinally: onComplete 2019-10-08 21:35:16.128 INFO respond-0 onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:35:16.128 INFO response-body onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:35:16.134 INFO respond-0 onComplete() 2019-10-08 21:35:16.134 INFO respond-1 onSubscribe([Fuseable] MonoDelayElement.DelayElementSubscriber) 2019-10-08 21:35:16.142 INFO response-body request(127) 2019-10-08 21:35:16.142 INFO respond-1 request(127) 2019-10-08 21:35:16.144 INFO issue.multipart.WebFluxMultipartTest bytes[0..4]:[114, 97, 119, 58]:raw: 2019-10-08 21:35:18.014 INFO respond-1 onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:35:18.015 INFO response-body onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:35:18.018 INFO respond-1 onComplete() 2019-10-08 21:35:18.023 INFO parts onSubscribe(FluxSwitchIfEmpty.SwitchIfEmptySubscriber) 2019-10-08 21:35:18.023 INFO parts request(256)  ... here it hangs ""forever"" ... ``` In case when not-corrupted multipart payload is used, execution become valid, and looks like ``` 2019-10-08 21:44:54.316 INFO org.springframework.test.context.support.DefaultTestContextBootstrapper Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener, org.springframework.test.context.event.EventPublishingTestExecutionListener] 2019-10-08 21:44:54.327 INFO org.springframework.test.context.support.DefaultTestContextBootstrapper Using TestExecutionListeners: [org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@3d08f3f5, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@119f1f2a, org.springframework.test.context.support.DirtiesContextTestExecutionListener@1a1da881, org.springframework.test.context.event.EventPublishingTestExecutionListener@5b970f7]  2019-10-08 21:44:55.978 INFO issue.multipart.IoTargetController postFormData: request.headers.content-length: [265] 2019-10-08 21:44:57.021 INFO response-body onSubscribe(FluxConcatArray.ConcatArraySubscriber) 2019-10-08 21:44:57.022 INFO response-body request(1) 2019-10-08 21:44:57.029 INFO respond-0 onSubscribe([Fuseable] MonoDelayElement.DelayElementSubscriber) 2019-10-08 21:44:57.029 INFO respond-0 request(1) 2019-10-08 21:44:57.030 INFO issue.multipart.IoTargetController postFormData: doFinally: onComplete 2019-10-08 21:44:58.031 INFO respond-0 onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:44:58.031 INFO response-body onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:44:58.037 INFO respond-0 onComplete() 2019-10-08 21:44:58.038 INFO respond-1 onSubscribe([Fuseable] MonoDelayElement.DelayElementSubscriber) 2019-10-08 21:44:58.044 INFO response-body request(127) 2019-10-08 21:44:58.045 INFO respond-1 request(127) 2019-10-08 21:44:58.047 INFO issue.multipart.WebFluxMultipartTest bytes[0..4]:[114, 97, 119, 58]:raw: 2019-10-08 21:45:22.997 INFO respond-1 onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:45:22.998 INFO response-body onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:45:22.998 INFO respond-1 onComplete() 2019-10-08 21:45:23.003 INFO parts onSubscribe(FluxSwitchIfEmpty.SwitchIfEmptySubscriber) 2019-10-08 21:45:23.003 INFO parts request(256) 2019-10-08 21:45:23.029 INFO parts onNext(Part 'part-00-name=post-payload-text-23456789ABCDEF:post-payload-0001-3456789ABCDEF:post-payload-0002-3456789ABCDEF:post-payload-0003-3456789ABCDEF') 2019-10-08 21:45:23.033 INFO part-content | onSubscribe([Fuseable] FluxJust.WeakScalarSubscription) 2019-10-08 21:45:23.033 INFO part-content | request(unbounded) 2019-10-08 21:45:23.033 INFO part-content | onNext(DefaultDataBuffer (r: 0, w: 128, c: 128)) 2019-10-08 21:45:23.033 INFO part-content | onComplete() 2019-10-08 21:45:23.034 INFO parts request(1) 2019-10-08 21:45:23.034 INFO parts onComplete() 2019-10-08 21:45:23.034 INFO respond-2 onSubscribe([Fuseable] MonoDelayElement.DelayElementSubscriber) 2019-10-08 21:45:23.034 INFO respond-2 request(unbounded) 2019-10-08 21:45:24.034 INFO respond-2 onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:45:24.034 INFO response-body onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:45:24.034 INFO respond-3 onSubscribe([Fuseable] MonoDelayElement.DelayElementSubscriber) 2019-10-08 21:45:24.034 INFO respond-3 request(125) 2019-10-08 21:45:24.035 INFO respond-2 onComplete() 2019-10-08 21:45:25.036 INFO respond-3 onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:45:25.036 INFO response-body onNext(PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 16)) 2019-10-08 21:45:25.036 INFO respond-3 onComplete() 2019-10-08 21:45:25.036 INFO response-body onComplete() 2019-10-08 21:45:25.039 INFO issue.multipart.WebFluxMultipartTest bytes[4...]:data:1234567r01:data:1234567r02:data:1234567r03:data:1234567 2019-10-08 21:45:25.040 INFO issue.multipart.WebFluxMultipartTest Success(kotlin.Unit)  ... here it completes normally ... ```","closed","type: bug,","ibaklan","2019-10-08T19:04:38Z","2019-12-03T11:20:53Z"
"","23758","MockMvc Kotlin DSL should support async dispatch","**Affects:** 5.2.0.RELEASE  Spring MVC now supports returning a Mono from REST controller handler methods. And this, in my experience, becomes more and more common because the reactive WebClient tends to be used instead of RestTemplate in MVC applications.  Testing those handler methods with MockMvc requires doing an async dispatch, as documented [here](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.html#asyncDispatch-org.springframework.test.web.servlet.MvcResult-).  This is not easy to find out with the MockMvc Java DSL. But when using MockMvc Kotlin DSL, it's even less intuitive. Here's the required code (AFAIK):  ```         val mvcResult =             mockMvc.get(url).andExpect {                 request { asyncStarted() }             }.andReturn()          ResultActionsDsl(mockMvc.perform(MockMvcRequestBuilders.asyncDispatch(mvcResult))).andExpect {             status { isOk }         } ```  As you can see, it requires:  - using the static method `MockMvcRequestBuilders.asyncDispatch()`, whereas the Kotlin DSL is designed to avoid having to use static methods, which are hard to find  - making two subsequent calls to mockMvc, which is unintuitive  - calling `mockMvc.perform()`, although the Kotlin DSL usually avoids it thanks to its extension methods (get(), post(), etc.)  - creating a new instance of the `ResultActionsDsl` class explicitly, which is also unintuitive.  I can hide this complexity into an extension function, but I think this function shouldn't be required, and should be part of the DSL itself:  ``` fun ResultActionsDsl.asyncDispatch(mockMvc: MockMvc): ResultActionsDsl {     return this.andExpect {         request { asyncStarted() }     }.andReturn().let {         ResultActionsDsl(mockMvc.perform(MockMvcRequestBuilders.asyncDispatch(it)))     } } ```  This allows using the following code to write the same test as above: ```         mockMvc.get(url).asyncDispatch(mockMvc).andExpect {             status { isOk }         } ```","closed","type: enhancement,","jnizet","2019-10-04T07:32:10Z","2019-11-22T15:27:57Z"
"","23775","ShallowETagHeaderFilter overwrites ETag","**Affects:** 5.2.0.RELEASE  Inside a `@Controller` I set the **ETag** and **Cache-control** header: ```java String etag = ... if (webRequest.checkNotModified( etag ))     return null; response.setHeader( HttpHeaders.CACHE_CONTROL, CacheControl.maxAge( 30, TimeUnit.DAYS ).cachePublic().getHeaderValue() ); ``` **ShallowETagHeaderFilter** overwrites ETag because **isEligibleForEtag** method returns **true**: ```java String cacheControl = response.getHeader(HttpHeaders.CACHE_CONTROL); return (cacheControl == null || !cacheControl.contains(DIRECTIVE_NO_STORE)); ``` **ShallowEtagHeaderFilter** should first check if an ETag is already set and skip it.","closed","type: bug,","cdalexndr","2019-10-09T21:04:13Z","2020-02-29T12:48:49Z"
"","23757","MockMvcResultHandlersDsl.handle() should take a function as argument","**Affects:** 5.2.0.RELEASE  `MockMvcResultHandlersDsl` has a `handle(resultHandler: ResultHandler)` method. This method is useful, for example when the controller returns a StreamingResponseBody as the body value, in order to be able to call `getAsyncResult()`. ResultHandler is a functional interface. But since it's being used as the argument of a Kotlin method here, using it requires using the following code:  ```     andDo {         handle(ResultHandler { it.asyncResult })     } ```  Instead of the more idiomatic  ```     andDo {         handle { it.asyncResult }     } ```  This can of course be fixed by introducing my own extension function on `MockMvcResultHandlersDsl`:  ``` fun MockMvcResultHandlersDsl.handle(handler: (result: MvcResult) -> Unit) = handle(ResultHandler { handler(it) }) ```  But I think I shouldn't have to do that, and `handle()` should have taken a function as argument instead of a `ResultHandler` in the first place.  It would be nice if a `handle(handler: (result: MvcResult) -> Unit)` overloading method was added to `MockMvcResultHandlersDsl`. And maybe the other one should be deprecated, too.","closed","type: enhancement,","jnizet","2019-10-04T06:27:53Z","2020-10-26T08:59:38Z"
"","23760","Add exchangeAsync to WebTestClient API","**Affects:** 5.2.0.RELEASE  ---  The motivation for this enhancement is that `WebTestClient` API is mostly blocking (with the exception of `.returnResult(Class).getResponseBody()` which exits the chained API), and when it's used with Spring WebFlux it might be very common to get an exception because `reactor-tcp-nio-x` is a non-blocking thread.  The main idea is to have another exchange method that is wrapped around a Mono publisher. This way the exchange can be executed within the reactive stream and the assertion API used in the `assertNext(..)` method of the `StepVerifier`.  This might also indirectly solve issues #21781 and especially #23390 since allowing the API to exchange within the stream will also allow the exchange to be in the same transaction. For example:  ```java @Test  public void account_test() {   accountRepo.save( // Create and store an account using spring-data-r2dbc and r2dbc-postgresql     Account.builder()       .username(""mock"")       .password(""1234"")       .build()   )   .publishOn(Schedulers.elastic()) // need to publish on an elastic thread or the blocking exchange will throw an exception   .as(TestHelpers::withRollback) // a transaction wrapper using TransactionalOperator and configured as rollback only   .as(StepVerifier::create)   .assertNext(saved -> {     assertThat(saved.getId()).isGreaterThan(0); // just to verify the account was persited on db      WebTestClient.bindToApplicationContext(appContext)       .build()       .get()       .uri(""/account/"" + saved.getUsername()) // a simple WebFlux end-point that finds the account by username and returns it in the response body       .exchange()       .expectStatus()       .isOk();   })   .verifyComplete(); } ```  This test will always fail because is running within a transaction. As the `exchange()` method is blocking, it will be executed in another thread outside the transaction, so the saved account will never be found. To run the end-point test within the transaction we need a non-blocking exchange method. In addition, it'll also remove the need to publish on a blockable thread.  Thanks in advance for taking the time to review this PR 🙂   cc. @sbrannen @jhoeller @mp911de","closed","status: declined,","JoseLion","2019-10-04T22:31:04Z","2021-09-18T05:17:45Z"
"","23752","Pre-flight requests return with error code: 401","**Affects:** 5.2.0.RC2  --- When sending a POST request to the autoconfigured `/oauth/token` endpoint, most browsers send a preflight request to determine if the actual request has any chance of succeeding.  I have configured an application with [spring-secutiry-oauth2-autoconfigure](https://github.com/spring-projects/spring-security-oauth2-boot), [spring-security-oauth](https://github.com/spring-projects/spring-security-oauth) and the brand new [spring-security](https://github.com/spring-projects/spring-security).  I tried implementing the new implementation of OAuth2 authentication with JWTs, but that doesn't support an authorization server, which I need.  This works fine from _Postman_, if I send a POST request to the right endpoint, I get an access token. However, things get wrong, when I try the same from a browser, because of the above mentioned pre-flight request.  When the browser sends this request, the `/oauth/token` endpoint realises that there are no authentication data sent alongside the request, so it throws an error, Through some error handling path, the request gets to the cors processor, which realises that the original request was in fact a pre-flight one and sets the headers of the response accordingly, except for the status code, which remains 401. The browser, seeing the status code aborts the request with a `Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:8080/oauth/token. (Reason: CORS preflight channel did not succeed).` message.  I tried, from the debugger, set the status code to 200 manually and in this case, the browser sees it as a green light, to send the actual request, which in turn gives the access token in question.  I'm planning on creating a solution for this problem myself, since it's an easy one. This is the first problem that I'm trying to help solve for the spring framework and I'm really excited to start contributing.  Curious, if I'm getting something wrong. The problem originally occured with the latest stable release of spring boot, the _2.1.7.RELEASE_ version, that's why I'm trying out the milestone version.","closed","status: superseded,","rolaca11","2019-10-02T19:33:07Z","2019-10-03T11:57:31Z"
"","23724","Newly added TransactionOperations.execute(Runnable) breaks existing Kotlin code","**Affects:** 5.2.0.RC1+  ---  https://github.com/spring-projects/spring-framework/commit/2c33c11d4c5833ff662b49ae520b7ad101ddd023 / #23250 added the new `TransactionOperations.execute(Runnable)` method for Java lambda usage without return value.  However it breaks existing Kotlin code using TransactionTemplate with return values:  ```kotlin val result = transactionTemplate.execute {   ...   1 } // result becomes Unit type, which used to be Int? type ```  This happens because Kotlin allows omitting single parameter (the implicit `it` parameter). Kotlin compiler cannot distinguish no-arg `Runnable` with unary `TransactionCallback`.  In order to disambiguate, a parameter or the callback interface should be explicitly stated:  ```kotlin val result = transactionTemplate.execute { _ ->   ...   1 } // or val result = transactionTemplate.execute(TransactionCallback {   ...   1 }) ```  I'm not sure how to fix it. Maybe let it break for bigger convenience in Java?","closed","type: regression,","dittos","2019-09-28T13:54:07Z","2019-09-29T17:40:34Z"
"","23463","Static resource support does not handle requests for a file with % character in its name","**Affects:** 5.2.0.RC1 (earlier versions may also be affected)  When a request is made for a static resource with a `%` in its file name, `PathResourceResolver` attempts to decode the path to check for the presence of encoded `../` or `..\`. This fails when the path is, for example, `test%file.txt` from a GET request for `/test%25file.txt`. The failure is the following:  ``` Caused by: java.lang.IllegalArgumentException: URLDecoder: Illegal hex characters in escape (%) pattern - For input string: ""fi"" 	at java.net.URLDecoder.decode(URLDecoder.java:194) ~[na:1.8.0_181] 	at org.springframework.web.servlet.resource.PathResourceResolver.isInvalidEncodedPath(PathResourceResolver.java:285) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.PathResourceResolver.isResourceUnderLocation(PathResourceResolver.java:254) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.PathResourceResolver.checkResource(PathResourceResolver.java:211) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.PathResourceResolver.getResource(PathResourceResolver.java:186) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.PathResourceResolver.getResource(PathResourceResolver.java:154) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.PathResourceResolver.resolveResourceInternal(PathResourceResolver.java:136) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.AbstractResourceResolver.resolveResource(AbstractResourceResolver.java:45) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.DefaultResourceResolverChain.resolveResource(DefaultResourceResolverChain.java:74) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.ResourceHttpRequestHandler.getResource(ResourceHttpRequestHandler.java:526) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.resource.ResourceHttpRequestHandler.handleRequest(ResourceHttpRequestHandler.java:451) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter.handle(HttpRequestHandlerAdapter.java:53) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.2.0.RC1.jar:5.2.0.RC1] 	... 47 common frames omitted ```","closed","type: enhancement,","wilkinsona","2019-08-14T20:16:14Z","2019-08-21T07:26:04Z"
"","23234","spring-core-5.2.0.M3.pom missing netty dependencies","**Affects:** 5.2.0.M3  Would you declare dependencies in pom.xml when installing spring artifacts to a repository?  ---  - [Spring-core 5.2.0.M3's pom.xml](https://repo.spring.io/libs-milestone-local/org/springframework/spring-core/5.2.0.M3/spring-core-5.2.0.M3.pom) in Spring milestone repository does not have Netty dependency.   ```               org.springframework       spring-jcl       5.2.0.M3       compile           ``` - [Spring-core 5.1.8-RELEASE's pom.xml](https://repo1.maven.org/maven2/org/springframework/spring-core/5.1.8.RELEASE/spring-core-5.1.8.RELEASE.pom) published in Maven Central has netty dependency with optional: true.   ```   ...        io.netty     netty-buffer     4.1.36.Final     compile     true      ...   ```  # Context  Although these optional dependencies of a transitive dependency are only used in compilation time of spring-core and not automatically retrieved by users' build tools, declaring optional dependencies in pom.xml is helpful for the following reasons:  ## For static analysis tools  I develop [a tool](https://github.com/GoogleCloudPlatform/cloud-opensource-java/tree/master/enforcer-rules) to check missing dependency. The tool reads pom.xml of Maven artifacts. The tool detected spring-core 5.2.0.M3 does not have proper dependencies declared in pom.xml.  ## For human  Declaring these dependencies serves as human-readable documentation. For example some of the classes in spring-core use `io.netty.buffer.ByteBufAllocator`. Declaring optional dependency in spring-core's pom.xml helps its users to pick up correct Maven artifact to make the classes work.   -------  With the reasons above, would you declare dependencies in pom.xml when installing to a repository?  Note that spring-core and Netty are just one example pair of this issue. There are [many other dependencies](https://github.com/spring-projects/spring-framework/blob/95a9d46/spring-core/spring-core.gradle#L67) that are not shown in [spring-core 5.2.0.M3's pom.xml](https://repo.spring.io/libs-milestone-local/org/springframework/spring-core/5.2.0.M3/spring-core-5.2.0.M3.pom), and probably other artifacts like spring-context.","closed","status: declined,","suztomo","2019-07-04T03:06:46Z","2019-08-20T07:52:38Z"
"","23395","Functional Bean Definition DSL for noarg functions","**Affects:** 5.2.0.M3  When using the Kotlin-based _Functional Bean Definition DSL_ I'm having a definition like this one:  ``` val beans = beans {     bean()     bean()      // 3 args resp. 1 arg     bean(::router)         bean(::securityWebFilterChain)      // userDetailsService has no args     // bean(::userDetailsService) DOESN'T COMPILE     bean { userDetailsService() } } ```  For readability reasons it would be nice to also use a function reference when the bean function has no arguments.","closed","in: core,","juergenzimmermann","2019-08-01T09:05:44Z","2020-01-13T09:55:09Z"
"","23155","onStatus throws away default status handler","**Affects:** 5.2.0.M3  **Description** Using webflux `WebClient` i want to override behavior if service returns 404 http code. Documentation says to use `onStatus` but there is no warning that it will throw away the default handler and i will lose default behavior on 5xx/4xx statuses.  Is it supposed to be like that? If i override one status i must provide handler for other error statuses?  ```java @Override public ResponseSpec onStatus(Predicate statusPredicate,         Function> exceptionFunction) {      if (this.statusHandlers.size() == 1 && this.statusHandlers.get(0) == DEFAULT_STATUS_HANDLER) {         this.statusHandlers.clear();     }     this.statusHandlers.add(new StatusHandler(statusPredicate,             (clientResponse, request) -> exceptionFunction.apply(clientResponse)));      return this; } ```","closed","type: enhancement,","indiv1d","2019-06-19T15:06:01Z","2019-07-16T14:25:36Z"
"","23229","Allow users to use existing PlatformTransactionManager with webflux","**Affects:** 5.2.0.M2  I'm using the milestone version of `spring-tx` thru autoconfiguration. When I try to use `@Transactional` with jdbc apis within webflux, I get the following exception  `org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.springframework.transaction.ReactiveTransactionManager' available`  `TransactionAspectSupport#invokeWithinTransaction` is internally forcing users to use `ReactiveTransactionManager` just based on the fact that `org.reactivestreams.Publisher` is present in the classpath  This means, all users who have databases that dont have reactive drivers are forced to implement this interface. Users should be allowed to use blocking JDBC thru `PlatformTransactionManager` aswell as not every data store currently/will support reactive drivers","closed","status: invalid,","thekalinga","2019-07-03T04:36:59Z","2019-07-09T10:19:34Z"
"","23215","NullPointerException when FormContentFilter handles a request with no content type","**Affects:** 5.2.0 snapshots  A test [is failing](https://ci.spring.io/teams/spring-boot/pipelines/spring-boot/jobs/build/builds/2942) in Boot's build. I believe it is failing because `FormContentFilter` is filtering a request with no content type. In deciding if it should parse the request, it calls `MediaType.parseMediaType(null)` (`null` is the request's content type) which ultimately results in a `NullPointerException`:  ``` 22:14:41 java.lang.NullPointerException 22:14:41	java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:936) 22:14:41	org.springframework.util.MimeTypeUtils$ConcurrentLruCache.get(MimeTypeUtils.java:437) 22:14:41	org.springframework.util.MimeTypeUtils.parseMimeType(MimeTypeUtils.java:192) 22:14:41	org.springframework.http.MediaType.parseMediaType(MediaType.java:571) 22:14:41	org.springframework.web.filter.FormContentFilter.shouldParse(FormContentFilter.java:116) 22:14:41	org.springframework.web.filter.FormContentFilter.parseIfNecessary(FormContentFilter.java:98) 22:14:41	org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:87) 22:14:41	org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) 22:14:41	org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) 22:14:41	org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ```  I suspect that https://github.com/spring-projects/spring-framework/commit/5a308ad5bd57203b610b14637b0fdde16f82bfa3 is the cause.","closed","type: bug,","wilkinsona","2019-06-29T21:35:10Z","2019-06-30T05:48:01Z"
"","23795","Availability of a bean definition's resolved factory method depends upon a side-effect of getBeanNamesForType which is lost when metadata caching is disabled","**Affects:** 5.1.x and 5.2.x  This is a follow-on from https://github.com/spring-projects/spring-boot/issues/18440. The difference in Framework's behaviour with and without bean metadata caching is illustrated by the following tests:  ```java package example;  import static org.assertj.core.api.Assertions.assertThat;  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  import org.junit.jupiter.api.Test; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.support.RootBeanDefinition; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; import org.springframework.context.annotation.ImportSelector; import org.springframework.core.type.AnnotationMetadata;  class FactoryMethodResolutionTests { 	 	@Test 	void factoryMethodCanBeResolvedWithBeanMetadataCachingEnabled() { 		assertThatFactoryMethodCanBeResolved(true); 	} 	 	@Test 	void factoryMethodCanBeResolvedWithBeanMetadataCachingDisabled() { 		assertThatFactoryMethodCanBeResolved(false);		 	} 	 	private void assertThatFactoryMethodCanBeResolved(boolean cache) { 		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) { 			context.getBeanFactory().setCacheBeanMetadata(cache); 			context.register(ImportSelectorConfiguration.class); 			context.refresh(); 			BeanDefinition definition = context.getBeanFactory().getMergedBeanDefinition(""exampleBean""); 			assertThat(((RootBeanDefinition)definition).getResolvedFactoryMethod()).isNotNull(); 		} 	} 	 	@Configuration 	@Import(ExampleImportSelector.class) 	static class ImportSelectorConfiguration { 		 	} 	 	static class ExampleImportSelector implements ImportSelector {  		@Override 		public String[] selectImports(AnnotationMetadata importingClassMetadata) { 			return new String[] { TestConfiguration.class.getName() }; 		} 		 	} 		 	@Configuration 	static class TestConfiguration { 		 		@Bean 		@ExampleAnnotation 		public ExampleBean exampleBean() { 			return new ExampleBean(); 		} 		 	} 	 	static class ExampleBean { 		 	} 	 	@Target(ElementType.METHOD) 	@Retention(RetentionPolicy.RUNTIME) 	@interface ExampleAnnotation { 		 	}  } ```  This has only become a problem in Boot 2.2 as we're now leaning more heavily upon the resolved factory method for performance reasons.  My analysis in the Boot issue that led to me opening this issue was the following:  > `factoryMethodToIntrospect` is set on the `ConfigurationClassBeanDefinition` due to a call that's made to `beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)` when invoking bean factory post-processors. With caching enabled, this merged bean definition is held in the bean factory's `mergedBeanDefinitions` map. It's then available when making a subsequent call to `getResolvedFactoryMethod()`. When caching is disabled, the merged bean definition on which `factoryMethodToIntrospect` is set is not held in the `mergedBeanDefinitions` map so the information is lost. When a new merged bean definition is subsequently retrieved via a call to `getMergedBeanDefinition`, there's no logic to set `factoryMethodToIntrospect` so it's `null`. > > Having investigated further and written up the above, I'm now of the opinion that this is a bug in Framework. `getResolvedFactoryMethod()` only works reliably due to a side-effect of `getBeanNamesForType()`. When caching is disabled, that side-effect is too short-lived to be useful. We could work around this in Boot by falling back to the old logic when `getResolvedFactoryMethod()` is `null`, but that would be a point-solution to what feels like a general problem.  I have added a workaround in Boot to avoid shipping a regression in 2.2, but I'd like to be able to revert that workaround in favour of a more general solution in Framework.","open","type: enhancement,","wilkinsona","2019-10-15T10:33:35Z","2019-11-12T14:59:16Z"
"","23560","Webclient partial JSON deserialization","**Affects:** 5.1.9.RELEASE --- For a specific call on the Spotify API with WebClient, the response is partially deserialize. That does not occur on other calls, even if the type is similar. This seem to be quite tricky, so I'm ready to give access to the full project, or demonstrate it during an Hangout call.  ```java     public Mono> getUserAlbums(SpotifyAccessToken accessToken, int page) {         ParameterizedTypeReference> type = new ParameterizedTypeReference<>() {         };          return spotifyWebClient.get()             .uri(uriBuilder -> uriBuilder                 .path(""/v1/me/albums"")                 .queryParam(""offset"", page * DEFAULT_OFFSET)                 .queryParam(""limit"", DEFAULT_OFFSET)                 .build())             .header(""Authorization"", accessToken.getHeader())             .retrieve()             .bodyToMono(type)             .log();     } ```  The final object value after every single call. The correct number of items are processed, but all objects in the `items` list have null or default value.  ```text result = {SpotifyWrapper@11478}   items = {ArrayList@11480}  size = 1   0 = {SpotifyAlbum@11483}     images = {ArrayList@11484}  size = 0    copyrights = {ArrayList@11485}  size = 0    releaseDatePrecision = null    label = null    type = null    externalIds = null    uri = null    tracks = null    artists = {ArrayList@11486}  size = 0    releaseDate = null    genres = {ArrayList@11487}  size = 0    popularity = 0    name = null    albumType = null    href = null    id = null    externalUrls = null  href = ""https://api.spotify.com/v1/me/albums?offset=0&limit=25""  limit = 25  offset = 0  prevLink = null  nextLink = null  total = 1 ```  Model classes used :   `SpotifyWrapper` ```java public class SpotifyWrapper {     @JsonProperty(""items"")     private List items = new ArrayList<>();      @JsonProperty(""href"")     private String href;      @JsonProperty(""limit"")     private int limit;      @JsonProperty(""offset"")     private int offset;      @JsonProperty(""previous"")     private String prevLink;      @JsonProperty(""next"")     private String nextLink;      @JsonProperty(""total"")     private int total;      public List getItems() {         return items;     }      public void setItems(List items) {         this.items = items;     }  // ... All every getters and setters ```  `SpotifyAlbum` ```java @JsonInclude(JsonInclude.Include.NON_NULL) public class SpotifyAlbum {      @JsonProperty(""images"")     private List images = new ArrayList<>();      @JsonProperty(""copyrights"")     private List copyrights= new ArrayList<>();      @JsonProperty(""release_date_precision"")     private String releaseDatePrecision;      @JsonProperty(""label"")     private String label;      @JsonProperty(""type"")     private String type;      @JsonProperty(""external_ids"")     private Map externalIds;      @JsonProperty(""uri"")     private String uri;      @JsonProperty(""tracks"")     private Tracks tracks;      @JsonProperty(""artists"")     private List artists = new ArrayList<>();      @JsonProperty(""release_date"")     private String releaseDate;      @JsonProperty(""genres"")     private List genres = new ArrayList<>();      @JsonProperty(""popularity"")     private int popularity;      @JsonProperty(""name"")     private String name;      @JsonProperty(""album_type"")     private String albumType;      @JsonProperty(""href"")     private String href;      @JsonProperty(""id"")     private String id;      @JsonProperty(""external_urls"")     private ExternalUrls externalUrls;      public void setImages(List images) {         this.images = images;     }      public List getImages() {         return images;     }   //...Every getters and setters .... } ```","closed","","jlefebure","2019-09-01T14:10:30Z","2021-01-08T13:09:13Z"
"","23551","Entry set of read-only HttpHeaders loses original headers' ordering","**Affects:** 5.1.9.RELEASE  The entry set returned from the result of calling `HttpHeaders.readOnlyHttpHeaders(HttpHeaders)` does not maintain the original headers' ordering. This is a regression from 5.1.0 that I think was introduced in 5.1.1 in https://github.com/spring-projects/spring-framework/commit/ce7278aaf4f20348862267c2081c20dc5bd77128. I believe the set is unordered due to the use of `Collectors.toSet()` which creats an unordered `Set`:  https://github.com/spring-projects/spring-framework/blob/1ea6ce72bb3b1139abc370f6dc32c51fc27ae90b/spring-web/src/main/java/org/springframework/http/ReadOnlyHttpHeaders.java#L146","closed","type: regression,","wilkinsona","2019-08-30T14:07:48Z","2019-08-31T11:25:01Z"
"","23501","Synchronization during singleton creation may result in deadlock","**Affects:** 5.1.9.RELEASE  During singleton creation, `DefaultSingletonBeanRegistry` synchronises on `this.singletonObjects`:  https://github.com/spring-projects/spring-framework/blob/b1171d82967cfd374f0b08f9580fe662fa1a98e8/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L204  While synchronized, it then uses the `singletonFactory` to create the singleton:  https://github.com/spring-projects/spring-framework/blob/b1171d82967cfd374f0b08f9580fe662fa1a98e8/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L222  This call into user code while holding a lock can result in deadlock. We've seen one example reported in [this Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/17765) where Micrometer is also involved. I've also reproduced a very similar problem without Micrometer and with no synchronization in user code:  ```java package example;  import javax.annotation.PostConstruct; import javax.validation.Validator; import javax.validation.constraints.Max;  import org.junit.jupiter.api.Test; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Lazy; import org.springframework.validation.annotation.Validated; import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean; import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;  public class SingletonCreationDeadlockTests { 	 	@Test 	public void create() { 		new AnnotationConfigApplicationContext(Config.class).close();; 	} 	 	private static final class Registry { 		 		private final ConfigProperties properties; 		 		Registry(ConfigProperties properties) { 			this.properties = properties; 		} 		 		void register() { 			this.properties.getSetting(); 		} 		 	} 	 	@Validated 	static class ConfigProperties {  		@Max(10) 		private int setting = 5;  		public int getSetting() { 			return this.setting; 		}  		public void setSetting(int setting) { 			this.setting = setting; 		} 		 	} 	 	@Configuration 	static class Config { 		 		@Bean 		public Registry registry(ConfigProperties properties) { 			return new Registry(properties); 		} 		 		@Bean 		public ConfigProperties properties() { 			return new ConfigProperties(); 		} 		 		@Bean 		public LocalValidatorFactoryBean localValidatorFactoryBean() { 			return new LocalValidatorFactoryBean(); 		} 		 		@Bean 		public static MethodValidationPostProcessor methodValidationPostProcessor(@Lazy Validator validator) { 			MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor(); 			postProcessor.setValidator(validator); 			return postProcessor; 		} 		 		@Bean 		public Registrar registrar(Registry registry) { 			return new Registrar(registry); 		} 		 	} 	 	static class Registrar { 		 		private final Registry registry; 		 		Registrar(Registry registry) { 			this.registry = registry; 		} 		 		@PostConstruct 		void register() { 			Thread thread = new Thread(() -> { 				registry.register(); 			}); 			thread.start(); 			try { 				thread.join(); 			} catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 		} 		 	}  } ```  Here's a zip of a complete project containing the above test: [singleton-creation-deadlock.zip](https://github.com/spring-projects/spring-framework/files/3529528/singleton-creation-deadlock.zip)  The deadlock occurs because the main thread has locked `singletonObjects` and then waits for the thread created by `Registrar` to complete. The thread created by `Registrar` ends up waiting to lock `singletonObjects` due to `ConfigProperties` being `@Validated` and the resolution of the `@Lazy` `Validator` requiring a call to `DefaultListableBeanFactory.doResolveDependency` which results in a call to `DefaultSingletonBeanRegistry.getSingleton` where the attempt to lock `singletonObjects` is made.","open","in: core,","wilkinsona","2019-08-22T10:04:11Z","2021-11-11T09:26:55Z"
"","23404","Add a new RequestEntity$HeadersBuilder#headers(HttpHeaders) method","**Affects:** 5.1.9 and previous versions (spring-web)  ---  `RequestEntity` builders are very handy, however adding multiple headers can currently only be done like this:  ```java         return RequestEntity.get(url)             .header(""first"", ""value"")             .header(""second"", ""other value"")             .build(); ```  This is cumbersome when a common set of headers needs to be added to various requests.  Adding a `B headers(HttpHeaders headers)` method to `RequestEntity$HeadersBuilder` would solve it by making this possible:  ```java         return RequestEntity.get(url)             .headers(new CommonHttpHeaders())        // implements HttpHeaders             .build(); ```  The same method was added to `ResponseEntity$HeadersBuilder` with #16929, so this would also improve consistency between request and response builders.","closed","in: web,","grimsa","2019-08-02T12:36:13Z","2019-08-23T09:34:13Z"
"","23675","Incorrect exception type throw by spring jdbc","**Affects:** 5.1.9 and previous versions  `spring-jdbc` uses `SQLErrorCodeSQLExceptionTranslator` with mapping file `/spring-jdbc/src/main/resources/org/springframework/jdbc/support/sql-error-codes.xml` to map between vendor error codes and relevant Exceptions.  For example, if underlying database is mysql then vendor error code 1062 gets mapped to `DuplicateKeyException`.  However to be able to identify the vendor itself `spring-jdbc` invokes `JdbcUtils#extractDatabaseMetaData(dataSource, ""getDatabaseProductName"")` which then calls `JdbcUtils.extractDatabaseMetaData(DataSource, DatabaseMetaDataCallback)`. The call to `JdbcUtils#extractDatabaseMetaData` creates a connection using the `datasource` and then retrieves the database vendor (although vendor name could be available from the driver itself and creating connection may not be necessary). If however creating the connection fails for whatever reason, then `SQLErrorCodesFactory` will never try to re-initialize `SQLErrorCodes` and then for the entire life cycle of the application Spring will fall back to the `SQLExceptionSubclassTranslator`.  This causes Spring to throw inconsistent exceptions. For example, if mysql throws 1062 and `SQLErrorCodeSQLExceptionTranslator` is not properly initialized due to connection issue, then `SQLExceptionSubclassTranslator` will throw `DataIntegrityViolationException` instead of `DuplicateKeyException`, and this will continue until the application is restarted.  Ideally Spring should keep on retrying to discover vendor name if `JdbcUtils#extractDatabaseMetaData` fails. This can be very annoying in a cluster where one node with properly initialized `SQLErrorCodes` will throw a different exception from a node which is falling back to `SQLExceptionSubclassTranslator`.","closed","status: superseded,","samratdhillon","2019-09-23T01:38:54Z","2019-09-23T10:27:07Z"
"","23553","Response with an invalid content type hangs when using WebFlux with Jetty","**Affects:** 5.1.9  I discovered this while adding a test for https://github.com/spring-projects/spring-boot/issues/18027 that covered all of Boot's reactive web servers. I've tried to reproduce it in a small standalone example but didn't manage to do so. Sorry. It can be reproduced by moving [this test](https://github.com/spring-projects/spring-boot/blob/3d23277b8f764f05bc16877736299212fddcedd0/spring-boot-project/spring-boot/src/test/java/org/springframework/boot/web/embedded/netty/NettyReactiveWebServerFactoryTests.java#L90-L98) to the superclass and then running [JettyReactiveWebServerFactoryTests](https://github.com/spring-projects/spring-boot/blob/2.1.x/spring-boot-project/spring-boot/src/test/java/org/springframework/boot/web/embedded/jetty/JettyReactiveWebServerFactoryTests.java). You should see the block time out after 30 seconds.","closed","type: bug,","wilkinsona","2019-08-31T07:35:44Z","2019-09-12T20:36:44Z"
"","23531","Spring cache multiple level cache support","**Affects:** 5.1.9  Does spring cache support multiple level cache?  I want a L1 cache like caffeine and a L2 cache like redis.  There is a `CompositeCacheManager`, but it seems not for this case.","closed","for: stackoverflow,","abccbaandy","2019-08-28T02:49:03Z","2019-08-28T08:24:16Z"
"","23471","Provide a way to register multiple beans at once using java configuration","**Affects:** 5.1.9  ---  At the moment it is possible to register beans using `@Bean` annotation. As far I know each bean registered in such way need its own method so it is impossible to register variable number of beans based on configuration or other dynamic mechanism.  Once there is a need for dynamic bean registration one have to abandon java configuration in favor of `BeanFactoryPostProcessor` or `BeanDefinitionRegistryPostProcessor`.   It would be great to be able to register variable number of beans at once using java configuration. Sample solution could be to have `@Beans` annotation that decorates methods returning arrays, collections or maps and instead of registering the whole container as a bean it registers each item separately.  The names of the beans could be auto-generated (like `#`) or somehow provided by the programmer (map keys, SpEL expression to evaluate against bean).","closed","status: invalid,","AGrzes","2019-08-16T11:48:30Z","2019-08-17T08:34:32Z"
"","23589","BindingResult from RedirectAttributes flashAttribute ignored if redirect target uses @ModelAttribute","**Affects:** 5.1.9  **Also affects:** 1.5.21   Using an annotated controller and using RedirectAttributes to send BindingResult via flash attributes to allow errors to be displayed at the redirect target.  This works perfectly if the target of the redirect uses Model to locate the bean associated to the BindingResult i.e. the bean and associated BindingResult are transferred intact.  If the target of the redirect uses @ModelAttribute to retrieve the targeted bean as part of the method signature, then the BindingResult is reset and the error information lost.  Per my investigation, the issue seems to be introduced in the `org.springframework.web.method.annotation.ModelAttributeMethodProcessor`.  If the targeted bean is located within the ModelAndViewContainer, the BindingResult seems to be ignored and a new one created.   For clarity, the following signature will always result in an empty/reset BindingResult on redirect with flash attributes: ``` @GetMapping(""/test1"") public void showTest1(@ModelAttribute TestCommand testCommand, BindingResult bindingResult, HttpServletRequest request, HttpServletResponse response) {   ... } ```  ...and the following will result in the BindingResult being transferred through the redirect intact: ``` @GetMapping(""/test2"") public void showTest2(Model model, HttpServletRequest request, HttpServletResponse response)  {      ... } ``` Self-contained controller included in attachment here: [TestController.zip](https://github.com/spring-projects/spring-framework/files/3579482/TestController.zip).  The use of HTML and responseBody.getWriter() was used to provide a completely functional test scenario.  The same behaviour was observed initially using Thymeleaf templates.  In both POST methods, the same flash attributes are added but only /test2 shows that the error existed after the redirect.","closed","status: invalid,","marcthornton","2019-09-05T13:32:28Z","2020-10-08T22:02:06Z"
"","23252","Template URI Variables with newline %0A or %0D are not matched","**Affects:** 5.1.8.RELEASE  The `AntPathMatcher` does not match strings containing newlines `\n` or `\r` when encoded as `%0A` or `%0D` for template URI variables. This is due to AntPathMatcher using defaulting matching regex of `(.*)`, which matches all characters except newline characters.  For instance the controller (using spring boot):  ```java @RestController public class Controller {      @RequestMapping(""/foo/x\ny"")     public String fooNewline() {         return ""From fooNewline()"";     }      @RequestMapping(""/foo/x\ry"")     public String fooCarriageReturn() {         return ""From fooCarriageReturn()"";     }      @RequestMapping(""/bar/{param1}"")     public String bar(@PathVariable(""param1"") String param1) {         return ""From bar(). Passed in "" + param1;     }  } ```  Would match   ``` GET /foo/x%0Ay GET /foo/x%0Dy ```  but  ``` GET /bar/x%0Ay GET /bar/x%0Dy ```  would return HTTP 404 Not Found with no context on the error with no opportunity to give a more helpful error message. Specifically from the default `ErrorController`:  ``` {   ""timestamp"": ""2019-07-09T03:05:04.285+0000"",   ""status"": 404,   ""error"": ""Not Found"",   ""message"": ""No message available"",   ""path"": ""/bar/x%0Ay"" } ```  This can be worked around by manually specify a DOTALL modifier flag in every path param.   E.g.  ```java @RequestMapping(""/bar/{param1:(?s:.*)}"") ```  But I think it would make sense if the `AntPathMatcher` did this by default, and I consider it a bug as normal path matching behavior, outside of template variables, would happily match newline or carriage returns.","closed","type: enhancement,","tmoschou","2019-07-09T03:23:09Z","2020-11-12T22:01:51Z"
"","23518","WebFlux WebClient loading entire file into direct buffer memory during multipart upload","**Affects:** 5.1.8-RELEASE  We have an endpoint that we can upload files using multipart and are using WebClient for our uploads.  Our upload client code looks like this  ```kotlin @Component class UploadClient(     private val client: WebClient, ) {     suspend fun upload(filePath: String) =         client.post()               .uri(""/upload"")               .contentType(MULTIPART_FORM_DATA)                  .body(BodyInserters.fromMultipartData(generateMultipartBody(filePath)))               .retrieve()               .bodyToMono(UploadResult::class.java)               .awaitFirst()      private fun generateMultipartBody(filePath: String): MultiValueMap> {         val builder = MultipartBodyBuilder()         builder.part(""file"", FileSystemResource(filePath))         return builder.build()     } } ```  However when we upload a large file, (1.6gb) we are seeing that this entire file is loaded into direct memory:  ![](https://i.stack.imgur.com/wVj7C.png)  As the file is uploaded, the memory is released, then when the next file is uploaded you can see the spike in memory again.  For contrast I tried replacing WebClient with https://github.com/AsyncHttpClient/async-http-client and the memory usage is much lower, ~60mb per upload","closed","","matthewwilson","2019-08-26T12:07:07Z","2021-01-08T13:09:12Z"
"","23406","AnnotationReadingVisitorUtils does not log a warning when it encounters an exception","**Affects:** 5.1.8  The following section causes the problem: ` catch (Throwable ex) { 				// Class not found - can't resolve class reference in annotation attribute. 				result.put(entry.getKey(), ex); 			} ` Catching any Throwable seems to be excessive.","closed","status: superseded,","mwiacek","2019-08-02T15:45:35Z","2019-08-06T15:40:25Z"
"","23635","SimpleCacheManager should not synchronize on AbstractCacheManager#cacheMap","**Affects:** 5.1.8  By inheriting `AbstractCacheManager#getCache`, `SimpleCacheManager` synchronizes on `cacheMap`, when the requested `Cache` is not available.  Since `SimpleCacheManager` uses predefined caches, this creates superfluous synchronizations.  The same is actually true for `RedisCacheManager`, when inflight `Cache` allocation is disabled.  This hits us on every request, since we are using `CompositeCacheManager`, which first checks our `SimpleCacheManager` holding only select caches and only afterwards to the manager holding the actual cache for certain requests.","closed","type: enhancement,","mpretzer","2019-09-13T11:54:23Z","2019-10-01T20:30:39Z"
"","23272","MockHttpServletResponse not set when using Spring Web, MockMvc and reactive return type","**Affects:** 5.1.8  --- Spring MVC supports controllers return reactive type:  **Application code**  ``` @RestController public class DemoController { 	@GetMapping 	public Mono> get() { 		return Mono.just(new ResponseEntity<>(new Foobar().setFoo(""A"").setBar(""1""), HttpStatus.ACCEPTED)); 	} } ```  However, testing this type of application with `MockMvc` doesn't work.  **Test code**  ``` @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class DemoApplicationTests { 	 	@Autowired 	private MockMvc client;  	@Test 	public void getRoot() throws Exception { 		client.perform(get(""/"")) 		      .andExpect(status().isAccepted()) 		      .andExpect(jsonPath(""foo"").value(""A"")) 		      .andExpect(jsonPath(""bar"").value(""1"")) 		;		  	} } ```  **Test output**  ``` MockHttpServletResponse:            Status = 200     Error message = null           Headers = []      Content type = null              Body =      Forwarded URL = null    Redirected URL = null           Cookies = [] ```  When debugging test:  * Controller is successfully called * Reactive stack and result is properly retrieved * ResponseEntity is never processed * `MockHttpServletResponse` fields are never set  When debugging application:  * It seems request and response are processed by Coyote processor * At some future time, DispatcherServlet is called again and a `HandlerMethodReturnValueHandler` process `ResponseEntity`","closed","","loganmzz","2019-07-10T16:06:14Z","2020-05-08T03:59:20Z"
"","23163","Support Ordered interface for @ControllerAdvice beans","**Affects:** 5.1.8  ---  The [ControllerAdvice](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html) doc states that:  > All such beans are sorted via AnnotationAwareOrderComparator, i.e. based on `@Order` and `Ordered`, and applied in that order at runtime.  But when I try to order using the `Ordered` interface, it is not working, although the `@Order` annotation is working.  Example below: ```kotlin @ControllerAdvice //@Order(1) class TestAdviceFirst : Ordered {     override fun getOrder(): Int {         return 1     }     @ExceptionHandler     @ResponseBody     fun handleException(e: Exception): String {         return ""Handling exception in TestAdviceFirst""     } }  @ControllerAdvice //@Order(2) class TestAdvice : Ordered {     override fun getOrder(): Int {         return 2     }     @ExceptionHandler     @ResponseBody     fun handleException(e: Exception): String {         return ""Handling exception in TestAdvice""     } }  @RestController class TestController {     @GetMapping(""/exception"")     fun exception(e: Exception) {         throw Exception()     } } ```  When `@Order` is commented out, I get the response ""Handling exception in TestAdvice"". However when I uncomment `@Order`, then I get the correct order response: ""Handling exception in TestAdviceFirst""  There is also a StackOverflow question but it is unanswered: https://stackoverflow.com/questions/51896436/ordered-interface-is-not-taken-into-account-for-controlleradvice-components","closed","type: enhancement,","dicksonleong","2019-06-20T06:03:46Z","2019-06-23T16:33:24Z"
"","23060","Optional @RequestPart Mono argument resolves to null","**Affects:** 5.1.7  --- In this call ```java   @PostMapping(value = ""/{callId}"", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)   public Mono store(       @PathVariable final String callId,       @RequestPart(value = ""fieldOne"", required = false) final Mono fieldOne)  ```  If `fieldOne` is not provided then it should be empty Mono instead of null.","closed","status: superseded,","lazystone","2019-05-30T13:05:14Z","2019-07-02T08:45:44Z"
"","23268","Unnecessarily alarming stack trace logged during scheduler resolution","**Affects:** 5.1.6.RELEASE  When booting server with TRACE logging enabled Spring prints an alarming-looking stack trace if there are multiple bean candidates of the same type. As I understand it then proceeds to resolve them by name and, in this case, succeeds. Therefore, everything works as expected but the error looks unnecessarily alarming and may trigger automated error reporting as it is an exception. Surely an exception should be raised / printed if bean resolution fails.  I suggest to log the message without the exception. Ideally explaining what is being done, for example:   No qualifying bean of type 'org.springframework.scheduling.TaskScheduler' available: expected single matching bean but found 2: taskScheduler,configWatchTaskScheduler. **Will attempt to resolve by name.**   Example: ``` 2019-07-09 15:48:03.504 o.s.b.f.s.DefaultListableBeanFactory          254 T :: Returning cached instance of singleton bean 'taskScheduler' 2019-07-09 15:48:03.505 o.s.b.f.s.DefaultListableBeanFactory          254 T :: Returning cached instance of singleton bean 'configWatchTaskScheduler' org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'org.springframework.scheduling.TaskScheduler' available: expected single matching bean but found 2: taskScheduler,configWatchTaskScheduler         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1140)         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1082)         at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.resolveSchedulerBean(ScheduledAnnotationBeanPostProcessor.java:313)         at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.finishRegistration(ScheduledAnnotationBeanPostProcessor.java:254)         at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:231)         at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:103)         at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)         at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)         at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:402)         at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:359)         at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:896)         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:163)         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:552)         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142)         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775)         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)         at org.springframework.boot.SpringApplication.run(SpringApplication.java:316)         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260)         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248)         at com.mjog.common.spring.base.MJogSpringApplication.run(MJogSpringApplication.java:37)         at com.mjog.post.MJogPostApplication.main(MJogPostApplication.java:21)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)         at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)         at org.springframework.boot.loader.Launcher.launch(Launcher.java:50)         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:51) ```","closed","type: enhancement,","MJ-Max","2019-07-10T08:49:59Z","2020-07-19T18:02:31Z"
"","22877","MockHttpServletRequest raises IndexOutOfBoundsException when Accept-Language is not set","**Affects:** 5.1.6.RELEASE  MockHttpServletRequest causes the exeption in  `	public Locale getLocale() { 		return this.locales.get(0); 	}`  as soon as the request das not have an Accept-Language header set.  When I set an empty Accept-Language header for my tests   `mockMvc.perform(get(""/some/request"") 				.header(ACCEPT_LANGUAGE, """") 				.andExpect(status().isBadRequest());`  method adddHeader does :  `HttpHeaders headers = new HttpHeaders(); headers.add(HttpHeaders.ACCEPT_LANGUAGE, value.toString()); List locales = headers.getAcceptLanguageAsLocales(); this.locales.clear(); this.locales.addAll(locales);`  _locales_ receives an empty List. So instead of checking for Bad Request I get the OutOfBound exception from _getLocale()_.   Not sure what the better solution is:   - returning Locale.ROOT from `getLocale` in case of an empty list - rejecting an empty value in `addHeader` with an exception - translating an empty value in `addHeader` into Locale.ROOT   Best regards    Mathias","closed","type: bug,","matze1610","2019-05-03T09:16:53Z","2019-05-03T12:35:51Z"
"","23225","Order of methods shouldn't matter in Data Binding","**Affects:** 5.1.6.RELEASE  ---  My Spring Controller method, which handles a post request, will throw the following exception when doing the data binding:  > NullValueInNestedPathException: Invalid property 'parent' of bean class [AreaImpl]: Could not instantiate property type [Area] to auto-grow nested property path; nested exception is java.lang.NoSuchMethodException: Area.()  The reason seems to be that the data container object has an interface as an attribute. In the below instance (and for simplicity) it is a recursively nesting attribute, but I don't think that is the problem. Since you can't have constructors for interfaces, the reflection code fails and says it can't instantiate it. I understand that it's impossible to guess at implementations, so that is not the issue here.  I read that I can disable `autoGrowNestedPaths`, but that leads to a host of other problems with null objects everywhere, so that's not a solution either for me. However, I've found a workaround ! If my Entity class has two setters for the interface attribute, then the code will work without a hitch, but only if they are defined in the data container object *in a specific order*.  ```java     interface Area {         Area getParent();         void setParent(Area parent);     } ```  The following implementation will throw the above exception, whether or not `setParent(AreaImpl1)` exists:  ```java     class AreaImpl1 implements Area {         Area parent;          @Override         public Area getParent() {             return parent;         }          @Override         public void setParent(Area parent) {             this.parent = parent;         }          public void setParent(AreaImpl1 parent) {             this.parent = parent;         }     } ```  The following implementation will give valid data binding!  ```java     class AreaImpl2 implements Area {         Area parent;          @Override         public Area getParent() {             return parent;         }          public void setParent(AreaImpl2 parent) {             this.parent = parent;         }          @Override         public void setParent(Area parent) {             this.parent = parent;         }     } ```  I've traced the issue into `AbstractNestablePropertyAccessor.getPropertyTypeDescriptor`, but I don't know if the resulting behavior is expected or buggy. If it is expected behavior, then I haven't found any documentation describing it, so this may be a documentation bug as well.  I don't mind adding the extra method to my entire domain layer (though it is a weird thing to have to do, and there may be some problems when there are actually multiple classes that can implement the interface), but I do mind that the order is important: it can make any refactoring, automated or otherwise, very brittle, and the resulting exceptions are not at all relatable to the root cause of the issue.","open","in: core,","blagae","2019-07-01T21:05:26Z","2019-07-03T14:45:08Z"
"","23495","prototype FactoryBean instantiated during singleton-creation","**Affects:** 5.1.6 up to 5.2.0.RC1 (worked in 5.1.5)  ---  If I define a prototype-scoped bean of type FactoryBean there is an attempt made to  instantiate it during singleton-creating. If that bean needs a parameter that is not present in the context (as it will be provided at creating-time), in earlier versions this failed silently, now it throws. Seems to be the result of #22409.  Version 5.1.5 and prio log this Exception: ``` [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Bean creation exception on non-singleton FactoryBean type check: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'prototypeBean' defined in eu.pinske.spring.prototype.App: Unsatisfied dependency expressed through method 'prototypeBean' parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.String' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} ```  Version 5.1.6 and later throw this Exception: ``` [main] WARN org.springframework.context.annotation.AnnotationConfigApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'prototypeBean' defined in eu.pinske.spring.prototype.App: Unsatisfied dependency expressed through method 'prototypeBean' parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.String' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} Exception in thread ""main"" org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'prototypeBean' defined in eu.pinske.spring.prototype.App: Unsatisfied dependency expressed through method 'prototypeBean' parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.String' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:509) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getNonSingletonFactoryBeanForTypeCheck(AbstractAutowireCapableBeanFactory.java:1041) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBean(AbstractAutowireCapableBeanFactory.java:866) 	at org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch(AbstractBeanFactory.java:574) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:518) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:489) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:475) 	at org.springframework.context.event.EventListenerMethodProcessor.afterSingletonsInstantiated(EventListenerMethodProcessor.java:103) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:862) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) 	at org.springframework.context.annotation.AnnotationConfigApplicationContext.(AnnotationConfigApplicationContext.java:88) 	at eu.pinske.spring.prototype.App.main(App.java:41) Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'java.lang.String' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1658) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1217) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1171) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) 	... 15 more ```  See the attached test case [spring-prototype.zip](https://github.com/spring-projects/spring-framework/files/3524052/spring-prototype.zip). Run with `mvn test`. Vary versions in `pom.xml`.","open","in: core,","apinske","2019-08-21T07:24:54Z","2021-11-10T12:00:12Z"
"","22973","Align @RequestPart support in WebFlux with Spring MVC","**Affects:** 5.1.6  --- After upgrading Spring Boot from 2.0.2 to 2.1.4 we started to see an issue with multipart form data uploading: ```java @PostMapping(value = ""/{id}"", consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public Mono store(@PathVariable final String id,         @RequestPart(""metadata"") final Map metadata,         @RequestPart(""fieldOne"") final List fieldOne,         @RequestPart(""fieldTwo"") final List fieldTwo) ```  That worked on spring boot 2.0.2, but on 2.1.4 it fails with decoding exception: ``` Cannot deserialize instance of `java.lang.Double` out of START_ARRAY token ``` So it actually tries to deserialize list of doubles as just a Double.  As a workaround we've changed method signature to use Double[] instead of List. After that it works as expected.","closed","type: bug,","lazystone","2019-05-14T12:36:42Z","2020-06-22T06:02:26Z"
"","22852","Pass URI Template to RestTemplate Interceptors","**Affects:** 5.1.6  ---  This is an enhancement request, to change `RestTemplate` so that it passes the original URI template to its interceptors when processing a HTTP request.  The reason for this change is to enable the implementation of feature https://github.com/spring-cloud/spring-cloud-sleuth/issues/1331 in the Spring Cloud Sleuth project.","closed","status: declined,","msmsimondean","2019-04-29T08:50:50Z","2019-05-01T13:38:33Z"
"","22943","messageBrokerTaskScheduler incorrect type","**Affects:** 5.1.5 --- If you use `@EnableWebSocketMessageBroker` and `@EnableScheduling` in the same application,  `AbstractMessageBrokerConfiguration` creates a `ThreadPoolTaskScheduler` [here](https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/simp/config/AbstractMessageBrokerConfiguration.java#L363). This `TaskScheduler` gets used by the scheduling framework because it simply scans for an available `TaskScheduler`. This is itself weird, since scheduled tasks are executed under threads with `MessageBroker- ` thread name.  The real trouble begins, if you use [Shedlock](https://github.com/lukas-krecan/ShedLock) which tries to wrap scheduling task executor in a proxy. It then fails with   ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'stompWebSocketHandlerMapping' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.HandlerMapping]: Factory method 'stompWebSocketHandlerMapping' threw exception; nested exception is java.lang.IllegalStateException: @Bean method AbstractMessageBrokerConfiguration.messageBrokerTaskScheduler called as bean reference for type [org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler] but overridden by non-compatible bean instance of type [com.sun.proxy.$Proxy71]. Overriding bean of same name declared in: class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class] 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:456) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1305) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1144) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:849) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:785) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:407) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1278) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1266) 	at net.javacrumbs.shedlock.test.boot.Application.main(Application.java:36) Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.web.servlet.HandlerMapping]: Factory method 'stompWebSocketHandlerMapping' threw exception; nested exception is java.lang.IllegalStateException: @Bean method AbstractMessageBrokerConfiguration.messageBrokerTaskScheduler called as bean reference for type [org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler] but overridden by non-compatible bean instance of type [com.sun.proxy.$Proxy71]. Overriding bean of same name declared in: class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class] 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) 	... 19 common frames omitted Caused by: java.lang.IllegalStateException: @Bean method AbstractMessageBrokerConfiguration.messageBrokerTaskScheduler called as bean reference for type [org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler] but overridden by non-compatible bean instance of type [com.sun.proxy.$Proxy71]. Overriding bean of same name declared in: class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class] 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.resolveBeanReference(ConfigurationClassEnhancer.java:418) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:366) 	at org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration$$EnhancerBySpringCGLIB$$fca45b4f.messageBrokerTaskScheduler() 	at org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport.stompWebSocketHandlerMapping(WebSocketMessageBrokerConfigurationSupport.java:76) 	at org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration$$EnhancerBySpringCGLIB$$fca45b4f.CGLIB$stompWebSocketHandlerMapping$11() 	at org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration$$EnhancerBySpringCGLIB$$fca45b4f$$FastClassBySpringCGLIB$$25647ffa.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) 	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) 	at org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration$$EnhancerBySpringCGLIB$$fca45b4f.stompWebSocketHandlerMapping() 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:564) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ```  The reason is that messageBrokerTaskScheduler returns `ThreadPoolTaskScheduler` instead of `TaskScheduler`.   I understand that changing the return type to `TaskScheduler` may break applications that are  expecting  `ThreadPoolTaskScheduler` in the application context but 5.2.x may be a good opportunity to fix this.  Example project https://github.com/lukas-krecan/ShedLock/tree/failure/spring/shedlock-springboot22-test  StackOverflow question: https://stackoverflow.com/questions/56017382/how-to-fix-websockets-and-shedlock-compatibility-in-spring-boot-application","closed","type: enhancement,","lukas-krecan","2019-05-10T12:31:17Z","2019-09-17T06:32:08Z"
"","23818","Allow processing of binary content via input streams with Websocket","**Affects:** 5.1.2.RELEASE  ---   Hi,  I want to use web sockets for upload of large files. The files need to be stored in a database for later processing. The problem I have is that `spring-websocket`'s `BinaryWebSocketHandler`s allow me to only process binary content as a byte array:  - If I keep the partial messages support disabled, this would mean that the entire file would be stored in-memory, which I want to avoid.  - If I enable the partial messages support, this means that I would have to collect the parts into a temporary file before persisting it in the database. I don't want this either.  It would be ideal if I could get access to the underlying `InputStream` and just forward that to my database driver, so it can stream the file's content directly to the database. This seems like it would be do-able, since as far as I saw, you use Java's WebSocket API under the hood and it provides https://docs.oracle.com/javaee/7/api/javax/websocket/MessageHandler.Whole.html. According to the documentation one of the supported types is `InputStream`.  Do you think it would be a good idea to allow us to have handlers for such `InputStream`s or would that be a bad idea somehow?  PS: Maybe it's somehow already possible to do this, but I couldn't find a way. I also asked a question in StackOverflow, but I didn't get an answer besides the partial messages feature: https://stackoverflow.com/questions/58395489/how-to-process-binary-messages-as-input-streams/58395721 I was also pointed to this question: https://stackoverflow.com/questions/37896551/spring-stomp-over-websocket-stream-large-files Where some people also wanted to use `InputStream`s instead of byte arrays.","closed","status: invalid,","nictas","2019-10-16T12:00:08Z","2019-10-17T08:53:45Z"
"","23633","Removing a key from HttpHeaders' key set leaves it in an inconsistent state","**Affects:** 5.1.10 snapshots  The problem is illustrated by the following test:  ```java package example;  import java.util.Arrays;  import org.junit.Test;  import org.springframework.http.HttpHeaders;  import static org.assertj.core.api.Assertions.assertThat; import static org.assertj.core.api.Assertions.entry;  public class HttpHeadersTests {  	@Test 	public void removeFromKeySet() { 		HttpHeaders httpHeaders = new HttpHeaders(); 		httpHeaders.set(""Alpha"", ""apple""); 		httpHeaders.set(""Bravo"", ""banana""); 		httpHeaders.keySet().remove(""Alpha""); 		assertThat(httpHeaders).containsOnly(entry(""Bravo"", Arrays.asList(""banana""))); 		assertThat(httpHeaders).doesNotContainKey(""Alpha""); 	}  } ```  The first assertion passes but the second fails:  ``` java.lang.AssertionError:  Expecting:   <{""Bravo""=[""banana""]}> not to contain key:   <""Alpha""> 	at example.HttpHeadersTests.removeFromKeySet(HttpHeadersTests.java:21) ```","closed","in: core,","wilkinsona","2019-09-12T16:29:51Z","2019-09-16T10:01:09Z"
"","23740","Avoid default Accept header from HttpUrlConnection in RestTemplate with put and delete","**Affects:** 5.1.10  It seems that the RestTemplate does not handle exceptions thrown by DELETE the same way as it does for GET and POST. `HttpStatusCodeException.getResponseBodyAsString()` returns whitelabel error page as HTML instead of the expected JSON.  **Example from exceptional DELETE:** `Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Tue Oct 01 15:38:04 CEST 2019There was an unexpected error (type=Internal Server Error, status=500).I am delete error`  **Example from exceptional GET:** `{""timestamp"":""2019-10-01T13:38:04.682+0000"",""status"":500,""error"":""Internal Server Error"",""message"":""I am get error"",""path"":""/test""}`  Reproduced in [this simple Spring Boot project](https://github.com/nytro77/resttemplate-delete-errorhandling)","closed","status: superseded,","nytro77","2019-10-01T13:29:57Z","2019-11-07T16:55:32Z"
"","22825","Expose default error handling from RequestHeadersSpec::retrieve for use with RequestHeadersSpec::exchange","**Affects:** 5.1  ---  This is an enhancement request around the `RequestHeadersSpec::exchange` and `RequestHeadersSpec::retrieve` methods.  Per the documentation for `retrieve`:  > This method is a shortcut to using `exchange()` and decoding the response body through `ClientResponse`.  The decoding mentioned here also includes some default error handling that converts 4XX and 5XX status responses to `WebClientResponseException`s as follows:  ```java private static Mono createResponseException( 		ClientResponse response, HttpRequest request) {  	return DataBufferUtils.join(response.body(BodyExtractors.toDataBuffers())) 			.map(dataBuffer -> { 				byte[] bytes = new byte[dataBuffer.readableByteCount()]; 				dataBuffer.read(bytes); 				DataBufferUtils.release(dataBuffer); 				return bytes; 			}) 			.defaultIfEmpty(new byte[0]) 			.map(bodyBytes -> { 				Charset charset = response.headers().contentType() 						.map(MimeType::getCharset) 						.orElse(StandardCharsets.ISO_8859_1); 				if (HttpStatus.resolve(response.rawStatusCode()) != null) { 					return WebClientResponseException.create( 							response.statusCode().value(), 							response.statusCode().getReasonPhrase(), 							response.headers().asHttpHeaders(), 							bodyBytes, 							charset, 							request); 				} 				else { 					return new UnknownHttpStatusCodeException( 							response.rawStatusCode(), 							response.headers().asHttpHeaders(), 							bodyBytes, 							charset, 							request); 				} 			}); } ```  I would like to be able to apply this same error-handling to results of `exchange` before performing my own processing, so that error handling is unified across all requests (regardless of whether they are implemented using `exchange` + additional processing, or `retrieve`).  Would it be possible to expose this error-handling functionality publicly so that it can be composited with other response processing? I'm not sure what the appropriate mechanism would be if so, but it looks like some related discussion occurred in #22368.  If not, would the recommendation be to always prefer `exchange` over `retrieve` and to reimplement the logic above in a shared `ExchangeFilterFunction`?","closed","type: enhancement,","stkent","2019-04-22T19:51:08Z","2019-07-29T13:09:06Z"
"","23325","Cannot call entityManager.flush() when use @Async","**Affects:** 5.0.7.RELEASE**  I have a question about why `entityManager.flush()` raises an exception when `@Async` is used.  This question is raised in [Stack Overflow](https://stackoverflow.com/questions/57129912/when-i-add-async-entitymanager-flush-will-raise-an-exception).","open","status: feedback-provided,","huashui","2019-07-21T06:58:59Z","2021-11-10T12:13:42Z"
"","23121","Target type in jsonPath method of MockMvcResultMatchers","**Affects:** 5.0.5  ---  **This in an enhancement**  In #21129 `MockMvcResultMatchers` adds the possibility to set the `targetType` when using `jsonPath`, but this can only be achieved as in the following code:  ```java jsonPath(""$.id"").value(is(entity.getId()), Long.class) // getId returns a Long ```  It would be great to have the following method in the `MockMvcResultMatchers` class:  ```java  jsonPath(String, Matcher, Class) // here you can set the target type in the same method. ```  See https://github.com/spring-projects/spring-framework/blob/0a77477d325db2e5b0c83601d3c0bc336f7b506c/spring-test/src/main/java/org/springframework/test/web/servlet/result/MockMvcResultMatchers.java#L203  The new method can be something like this:  ```java public static  ResultMatcher jsonPath(String expression, Matcher matcher, Class targetType) {     return new JsonPathResultMatchers(expression).value(matcher, targetType); } ```","closed","status: superseded,","juanmbellini","2019-06-12T17:22:19Z","2019-06-18T15:13:39Z"
"","23202","SPEL: ""index"" not usable in collection selection/projection?","**Affects:** 5.0.4  When iterating on a collection, both [Selection](https://github.com/spring-projects/spring-framework/blob/master/spring-expression/src/main/java/org/springframework/expression/spel/ast/Selection.java#L146) and [Projection](https://github.com/spring-projects/spring-framework/blob/master/spring-expression/src/main/java/org/springframework/expression/spel/ast/Projection.java#L99) set a variable called `index` that contains the index of the current element. I would expect this variable to be usable in SPEL, e.g. for filtering one list based on elements on another list (or any other criterion that takes the index into account).  However, there doesn't seem to be any way to reference it. The only code that makes use of `VariableScope` is never called.  Am I missing something or is this feature not really complete?","open","in: core,","peterschubert","2019-06-27T12:09:41Z","2021-11-10T10:53:12Z"
"","23438","Deadlock in AbstractApplicationContext at JVM shutdown (SIGTERM)","**Affects:** 5.0.12 (sure) and probably 5.1.9 since we tried to upgrade and this is the same code.  --- There is a deadlock at JVM shutdown if a thread tries to close the spring context at the same time.  The issue is a lock in `AbstractApplicationContext`  ```java 	@Override 	public void registerShutdownHook() { 		if (this.shutdownHook == null) { 			// No shutdown hook registered yet. 			this.shutdownHook = new Thread() { 				@Override 				public void run() { 					synchronized (startupShutdownMonitor) { 						doClose(); 					} 				} 			}; 			Runtime.getRuntime().addShutdownHook(this.shutdownHook); 		} 	} ```  ```java 	@Override 	public void close() { 		synchronized (this.startupShutdownMonitor) { 			doClose(); 			// If we registered a JVM shutdown hook, we don't need it anymore now: 			// We've already explicitly closed the context. 			if (this.shutdownHook != null) { 				try { 					Runtime.getRuntime().removeShutdownHook(this.shutdownHook); 				} 				catch (IllegalStateException ex) { 					// ignore - VM is already shutting down 				} 			} 		} 	} ```  Here is an extract of the thread dump:  ``` ""SIGTERM handler"" #354 daemon prio=9 os_prio=0 tid=0x00007f5d38004800 nid=0x2bb4c waiting for monitor entry [0x00007f5ae66e5000]    java.lang.Thread.State: BLOCKED (on object monitor)     at java.lang.Shutdown.exit(Shutdown.java:212)     - waiting to lock <0x00000005cc3bde18> (a java.lang.Class for java.lang.Shutdown)     at java.lang.Terminator$1.handle(Terminator.java:52)     at sun.misc.Signal$1.run(Signal.java:212)     at java.lang.Thread.run(Thread.java:748)  ""Thread-33"" #215 prio=5 os_prio=0 tid=0x00007f5a20002800 nid=0x2bb20 in Object.wait() [0x00007f5ccbbf9000]    java.lang.Thread.State: WAITING (on object monitor)     at java.lang.Object.wait(Native Method)     at java.lang.Object.wait(Object.java:460)     at com.tc.object.InFlightMessage.timedWait(InFlightMessage.java:294)     - locked <0x00000007534e0638> (a com.tc.object.InFlightMessage)     at com.tc.object.InFlightMessage.waitForAcks(InFlightMessage.java:239)     at com.tc.object.InFlightMessage.waitForAcks(InFlightMessage.java:222)     at com.tc.object.ClientEntityManagerImpl.queueInFlightMessage(ClientEntityManagerImpl.java:566)     at com.tc.object.ClientEntityManagerImpl.sendMessageWhileBusy(ClientEntityManagerImpl.java:525)     at com.tc.object.ClientEntityManagerImpl.internalRelease(ClientEntityManagerImpl.java:505)     at com.tc.object.ClientEntityManagerImpl.access$600(ClientEntityManagerImpl.java:82)     at com.tc.object.ClientEntityManagerImpl$1.run(ClientEntityManagerImpl.java:467)     at com.tc.object.EntityClientEndpointImpl.close(EntityClientEndpointImpl.java:296)     at org.terracotta.voltron.proxy.client.VoltronProxyInvocationHandler.invoke(VoltronProxyInvocationHandler.java:124)     at com.sun.proxy.$Proxy128.close(Unknown Source)     at org.terracotta.management.entity.nms.client.DefaultNmsService.close(DefaultNmsService.java:112)     at com.terracottatech.management.voltron.AggregateNmsService.lambda$close$0(AggregateNmsService.java:126)     at com.terracottatech.management.voltron.AggregateNmsService$$Lambda$1269/551340504.accept(Unknown Source)     at java.util.concurrent.ConcurrentHashMap$KeySetView.forEach(ConcurrentHashMap.java:4649)     at com.terracottatech.management.voltron.AggregateNmsService.close(AggregateNmsService.java:123)     at com.terracottatech.management.voltron.VoltronTmsConnection.doClose(VoltronTmsConnection.java:181)     at com.terracottatech.management.cluster.api.AbstractTmsConnection.close(AbstractTmsConnection.java:88)     at com.terracottatech.management.cluster.api.AbstractTmsConnectionFactoryService.close(AbstractTmsConnectionFactoryService.java:42)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:498)     at org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:337)     at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:271)     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)     at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:954)     at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)     at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:961)     at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1039)     at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1015)     at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:935)     - locked <0x00000005cc513e08> (a java.lang.Object)  ""SIGTERM handler"" #350 daemon prio=9 os_prio=0 tid=0x00007f5d38001000 nid=0x2bb08 in Object.wait() [0x00007f5ccbdfc000]    java.lang.Thread.State: WAITING (on object monitor)     at java.lang.Object.wait(Native Method)     - waiting on <0x00000005cd116528> (a org.springframework.context.support.AbstractApplicationContext$1)     at java.lang.Thread.join(Thread.java:1252)     - locked <0x00000005cd116528> (a org.springframework.context.support.AbstractApplicationContext$1)     at java.lang.Thread.join(Thread.java:1326)     at java.lang.ApplicationShutdownHooks.runHooks(ApplicationShutdownHooks.java:107)     at java.lang.ApplicationShutdownHooks$1.run(ApplicationShutdownHooks.java:46)     at java.lang.Shutdown.runHooks(Shutdown.java:123)     at java.lang.Shutdown.sequence(Shutdown.java:167)     at java.lang.Shutdown.exit(Shutdown.java:212)     - locked <0x00000005cc3bde18> (a java.lang.Class for java.lang.Shutdown)     at java.lang.Terminator$1.handle(Terminator.java:52)     at sun.misc.Signal$1.run(Signal.java:212)     at java.lang.Thread.run(Thread.java:748) ```","closed","in: core,","mathieucarbou","2019-08-08T21:24:16Z","2019-09-02T11:52:50Z"
"","22854","JSR305 @CheckForNull should be equivalent to Spring @Nullable for indicating optional autowired injections","**Affects:** 5.0.10  ---  ## Summary  The JSR305 `@CheckForNull` annotation should be treated equivalently to the Spring `@org.springframework.lang.Nullable` annotation.  It is supposed to have the same semantic meaning: users of a variable should be checked for nullness before it is used, because it is intended to sometimes have a null value; and null is a valid and expected value for clients of the code to pass.  ## Details  The specific instance of this encountered was using constructor injection.  A ""Nullable""-like annotation can be applied to constructor parameter to tell Spring that the parameter is optional (if it can't be injected, then null is passed for it, instead of failing).  While adding the `@javax.annotation.Nullable` from [Findbugs JSR305 v3.0.1](https://mvnrepository.com/artifact/com.google.code.findbugs/jsr305/3.0.1) does work to indicate optional parameters to Spring, the `@javax.annotation.CheckForNull` does not work.  Now the naming of JSR305 `@Nullable` and `@CheckForNull` is very confusing, so take care.  `@CheckForNull` is actually the most correct annotation in this case, due to how JSR305 defines `@CheckForNull` (stronger) and `@Nullable` (weaker).  Quick reference:  ""The annotated element could be null under some circumstances. [...] This annotation is useful mostly for overriding a Nonnull annotation. [...] Use CheckForNull to indicate that the element value should always be checked for a null value."" [JSR305 Nullable.java](https://github.com/amaembo/jsr-305/blob/master/ri/src/main/java/javax/annotation/Nullable.java)  ""The annotated element might be null, and uses of the element should check for null."" [JSR305 CheckForNull.java](https://github.com/amaembo/jsr-305/blob/master/ri/src/main/java/javax/annotation/CheckForNull.java)  # Minimal Complete Verifiable Example  See https://github.com/cdbennett/spring-checkfornull-test for a complete example illustrating the problem.","open","in: core,","cdbennett","2019-04-29T22:36:17Z","2021-11-10T12:00:10Z"
"","23307","@ConditionalOn behaves unintuitively for @Bean methods with same name (depends on method declaration order)","**Affects:** 4.3.x - 5.1.x  Probably affects older versions as well.  ---  When `@ConditionalOn..` annotations are used on `@Bean` methods with the same name  within one configuration class, the outcome depends on the declaration order of the methods.  Consider the simple example, in which application startup fails, because the bean name 'conditionalBean' becomes blacklisted on the upper definition, thus the second one is ignored.  ```java     @SpringBootApplication     @Configuration     public class DemoApplication {  	public static void main(String[] args) { 		SpringApplication.run(DemoApplication.class, args); 	}  	@Bean 	@ConditionalOnExpression(""false"") 	public ConditionalBean conditionalBean(ApplicationContext ctx) { 		return new ConditionalBean(); 	}  	@Bean 	public ConditionalBean conditionalBean() { 		return new ConditionalBean(); 	}  	@Bean 	public SomeOtherBean someOtherBean(ConditionalBean conditionalBean) { 		return new SomeOtherBean(); 	}  	public class ConditionalBean {} 	public class SomeOtherBean {}      } ```  In this example the application starts up properly:  ```java 	@Bean 	public ConditionalBean conditionalBean() { 		return new ConditionalBean(); 	}  	@Bean 	@ConditionalOnExpression(""false"") 	public ConditionalBean conditionalBean(ApplicationContext ctx) { 		return new ConditionalBean(); 	} ```  The reason for this behavior lies in  `ConfigurationClassBeanDefinitionReader::loadBeanDefinitionsForBeanMethod`, where the method name is internally stored as skipped:   ```java     // Do we need to mark the bean as skipped by its condition? 	if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) { 		configClass.skippedBeanMethods.add(methodName); 		return; 	} 	if (configClass.skippedBeanMethods.contains(methodName)) { 		return; 	} ```  A sample project to reproduce this error can be found here: https://github.com/tobisinghania/spring-conditionaOn-order","open","in: core,","tobisinghania","2019-07-17T14:44:08Z","2021-04-19T10:28:57Z"
"","22981","NamedParameterJdbcTemplate: treat Iterable parameters like Collections","**Affects:** 4.3.18  --- When specifying named parameters and using a `NamedParameterJdbcTemplate`, if you want to replace an ""IN"" clause argument with a series of values you must supply a `Collection`. Example:  ```java     Map params = new HashMap<>();     params.put(""ages"", Arrays.asList(""30"", ""31"");         template.queryForList(""SELECT name FROM Person WHERE age IN (:ages)"", params, String.class); ```  This will translate to: `SELECT name FROM Person WHERE age IN (?, ?)` with those ""?"" replaced with 30 and 31 respectively.  If, however, you specify `ages` param as an array, or as some other kind of `Iterable`, this does not work: the parameter is translated into a single String SQL param value using the array or `Iterable` `toString()` output.  IMHO this is not intuitive, especially if you're using an array (an array of enum values, for instance). It took me quite a lot today to discover why a query was not producing the expected results.","closed","type: enhancement,","mauromol","2019-05-16T10:51:27Z","2019-06-12T14:28:52Z"
"","23564","Custom DefaultResourceLoader subclass should be able to consume context-provided ProtocolResolvers","**Affects:** 4.3+  `ConfigurableApplicationContext` has a `addProtocolResolver` method that can be used to register additional `ProtocolResolver` implementations. As far as I can see, this is the recommended approach that is followed by a number of implementations out there (example in [Spring Cloud AWS](https://github.com/spring-cloud/spring-cloud-aws/blob/f436ecab53dbdbd549e2e73298975a8c34b15931/spring-cloud-aws-context/src/main/java/org/springframework/cloud/aws/context/support/io/SimpleStorageProtocolResolverConfigurer.java#L55)).  When setting a custom `ResourceLoader` on the context, one could get the already registered  `ProtocolResolver` instances (via `getProtocolResolvers`) if they want to reuse them but there is no way to be notified that additional instances have been configured. Unfortunately, the vast majority of the current implementations will register their protocol resolver later.  A concrete example is Spring Boot Devtools that has to set a custom `ResourceLoader` but should be improved to honour `ProtocolResolver` as well, see https://github.com/spring-projects/spring-boot/issues/9331  One way to workaround this problem is to get the registered list every time a resource has to be resolved. If you just want the default behaviour it's not super obvious to do that. I have some prototype in https://github.com/snicoll/spring-boot/commit/1ceba096825869707f3c048d15c7068e3ef0e4a7, wondering if we could improve the code by a change in framework.","closed","type: enhancement,","snicoll","2019-09-02T13:53:09Z","2019-09-25T11:23:12Z"
"","23084","Introduce support to return operands and operator of a SpEL expression","**Affects:** 4.3  Introduce support to return operands and operator of a SpEL expression.  For example SpEL provides a function to retrieve a value:  ```java // Addition int two = parser.parseExpression(""1 + 1"").getValue(Integer.class); ```  But there is no effective way to fetch the operators and operands like:  ```java Object [] operands = parser.parseExpression(""1 + 1"").getOperands(); ```","open","status: feedback-provided,","007aniketkumar","2019-06-05T02:44:03Z","2019-07-04T12:24:49Z"
"","23346","Session.close() accidentally triggers creation of TransactionAwareDataSourceProxy Connection","**Affects:** 3.1.4.RELEASE Using hibernate: 3.6.10.Final  --- I'm facing an issue caused by opening connections with database on session.close call. For some reason, hibernate throws an exception when is opening a connection with database, then he starts to rollback the transaction. From now on, a proxy connection exists in session (`TransactionAwareInvocationHandler`), but real connection with database does not exists.  After that, _spring-orm_ call `SessionFactoryUtils.closeSession`, and this goes to close connection, but real connection failed to be created  Hibernate `ConnectionManager`, before close the connection call `JDBCExceptionReporter.logAndClearWarnings( connection );` (connection parameter is proxy `TransactionAwareInvocationHandler` connection without real connection because creation failed)  Then `TransactionAwareInvocationHandler` create a new connection with database because `getWarnings` and `clearWarnings` are not mapped methods in invoke This connection is closed right after creation, but when I am inside a transaction, this connection resource is binded to thread and never unbinded. Because _spring-tx_ is alredy in a rollback block.  I think a connection should not be opened when some of those two methods `getWarnings` and `clearWarnings` are called and real connection does not exists.  https://github.com/zgsolucoes/spring-framework/commit/35c0b084906e6d122b13980df12383958a935213","closed","type: bug,","jpozorio","2019-07-23T19:53:28Z","2019-08-01T13:32:33Z"
"","23429","Unable to resolve taglib schema through https for spring-webmvc","**Affects:**  spring-webmvc 5.0.13 and above  I'm upgrading spring-webmvc from 4.3.16 to 5.1.17 and getting this error at runtime ```bash 06-Aug-2019 15:08:11.901 INFO [localhost-startStop-1] com.sun.xml.ws.transport.http.servlet.WSServletDelegate. WSSERVLET14: JAX-WS servlet initializing 06-Aug-2019 15:08:12.706 WARNING [localhost-startStop-1] org.apache.tomcat.util.digester.Digester.warning Parse Warning Error at line 5 column 17: schema_reference.4: Failed to read schema document 'https://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd', because 1) could not find the document; 2) the document could not be read; 3) the root element of the document is not . org.xml.sax.SAXParseException; systemId: jar:file:/usr/mware/tcServerAppDetails/ROL/webapps/rolol/WEB-INF/lib/spring-webmvc-5.1.7.RELEASE.jar!/META-INF/spring.tld; lineNumber: 5; columnNumber: 17; schema_reference.4:  Failed to read schema document 'https://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd', because 1) could not find the document; 2) the document could not be read; 3) the root element of the document is not . at  com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203) at  com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.warning(ErrorHandlerWrapper.java:99) at  com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:392) at  com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:327) at  com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:284) at  com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.findSchemaGrammar(XMLSchemaValidator.java:2451) at  com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.handleStartElement(XMLSchemaValidator.java:1768) at  com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:741) at ``` which was caused by this change in `WEB-INF/spring.tld` and `WEB-INF/spring-form.tld` from ```xml  ``` to (basically a change of schema location from http protocol to https protocol) ```xml  ``` although the xsd file is available and accessible over the network, it didn't work for us because  our application stays within an intranet and not having access to external network. Also it seems that there isn't any schema mapping for taglib with https that's why only https did not work for our application. Do you have any advice on this? If there's any fix that need to be made, I would be happy to contribute","closed","status: invalid,","stanleynguyen","2019-08-07T15:07:51Z","2020-08-11T10:24:10Z"
"","23392","NullPointerException in JpaMetamodel with Hibernate dynamic-component","**Affects:**  spring-data Ingalls-SR22  ---  With Hibernate 5.3.10, I am using an .hbm.xml mapping which contains : ` ` see https://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html_single/#components-dynamic for more info or https://github.com/hibernate/hibernate-orm/blob/164178330a92ce1b064b44306c5d9408e86cefdf/hibernate-core/src/test/java/org/hibernate/test/legacy/Glarch.hbm.xml#L27 for an example  I tried to create the jpa repositories with  `` and got :  > 2019-07-31 16:09:15,317 ERROR [o.s.w.c.ContextLoader] localhost-startStop-1 Context initialization failed > org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jpaMappingContext': Invocation of init method failed; nested exception is java.lang.NullPointerException > 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1630) > 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553) > 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481) > 	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) > 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) > 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308) > 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) > 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:737) > 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867) > 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542) > 	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:443) > 	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:325) > 	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107) > 	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4743) > 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5207) > 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) > 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1419) > 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1409) > 	at java.util.concurrent.FutureTask.run(FutureTask.java:266) > 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) > 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) > 	at java.lang.Thread.run(Thread.java:748) > Caused by: java.lang.NullPointerException: null > 	at org.springframework.data.mapping.model.AbstractPersistentProperty.getActualType(AbstractPersistentProperty.java:318) > 	at org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.getActualType(JpaPersistentPropertyImpl.java:152) > 	at org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.isEntity(JpaPersistentPropertyImpl.java:201) > 	at org.springframework.data.mapping.model.AbstractPersistentProperty.getPersistentEntityType(AbstractPersistentProperty.java:130) > 	at org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.getPersistentEntityType(JpaPersistentPropertyImpl.java:161) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:525) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:483) > 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:693) > 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:347) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:526) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:483) > 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:693) > 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:347) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:526) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:483) > 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:693) > 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:347) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:526) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:483) > 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:693) > 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:347) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:526) > 	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:483) > 	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:693) > 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:347) > 	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:299) > 	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:429) > 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:73) > 	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:26) > 	at org.springframework.beans.factory.config.AbstractFactoryBean.afterPropertiesSet(AbstractFactoryBean.java:135) > 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1688) > 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1626) > 	... 21 common frames omitted  And this exception occurs while trying to analyse the dynamic-component properties.","open","in: data,","xpoinsard","2019-07-31T15:13:59Z","2021-11-10T11:28:35Z"
"","23783","Image serialization to JSON recurses infinitely","**Affects:**  Spring Boot (v2.1.6.RELEASE)  I made a tiny test case: https://github.com/boiert/imgbug/ I'm JSONifying an Image object, but the Serializer gets stuck in infinite recursion on the image dimensions? I'm unsure where to report this, so I chose here..","closed","status: invalid,","ghost","2019-10-11T20:12:31Z","2019-10-14T11:57:29Z"
"","22862","Consider adding is*Enabled() methods to LogAccessor","**Affects:**  5.2.x  Please consider adding `is*Enabled()` methods to `LogAccessor`.  I can see 2 use cases...  - a superclass with a protected final `LogAccessor` with many subclasses - it would make the transition easier because we wouldn't have to transition every subclass at the same time. - logging non-final (or effectively final) variables from the `Supplier` lambda - right now, we have to create a dummy final variable before logging; with these methods, we could continue to use the existing ""if enabled"" style for these cases.","closed","type: enhancement,","garyrussell","2019-04-30T15:10:57Z","2019-05-02T09:59:02Z"
"","23499","Bean validation doesn't work with Kotlin coroutines controller","**Affects:**  5.2.0.RC1  when using Kotlin suspend function and Validated annotation, like this.      package example          import org.springframework.http.HttpStatus     import org.springframework.http.ResponseEntity     import org.springframework.validation.annotation.Validated     import org.springframework.web.bind.annotation.RequestMapping     import org.springframework.web.bind.annotation.RestController      @Validated     @RestController     class Foo {         @RequestMapping(""/foo"")         suspend fun foo() = ResponseEntity(""foo"", HttpStatus.OK)     }  occured exception.      java.lang.ArrayIndexOutOfBoundsException: 0             at java.util.Arrays$ArrayList.get(Arrays.java:3841) ~[na:1.8.0_102]             Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:     Error has been observed at the following site(s):             |_ checkpoint ⇢ Handler example.Foo#foo(Continuation) [DispatcherHandler]             |_ checkpoint ⇢ org.springframework.security.web.server.authorization.AuthorizationWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.authorization.ExceptionTranslationWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.authentication.logout.LogoutWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.savedrequest.ServerRequestCacheWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.context.SecurityContextServerWebExchangeWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.context.ReactorContextWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.header.HttpHeaderWriterWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.config.web.server.ServerHttpSecurity$ServerWebExchangeReactorContextWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.security.web.server.WebFilterChainProxy [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.cloud.sleuth.instrument.web.TraceWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain]             |_ checkpoint ⇢ HTTP GET ""/foo"" [ExceptionHandlingWebHandler]     Stack trace:                     at java.util.Arrays$ArrayList.get(Arrays.java:3841) ~[na:1.8.0_102]                     at org.hibernate.validator.internal.metadata.aggregated.ParameterMetaData$Builder.build(ParameterMetaData.java:169) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibern ate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.findParameterMetaData(ExecutableMetaData.java:435) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:388) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:204) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:166) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:265) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:233) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]                     at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:104) ~[spring-context-5.2.0.RC1.jar:5.2.0.RC1]                     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.0.RC1.jar:5.2.0.RC1]                     at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.2.0.RC1.jar:5.2.0.RC1]     ...","open","in: kotlin,","yuki-teraoka","2019-08-22T05:09:27Z","2022-03-14T22:41:08Z"
"","23456","Kotlin examples in Spring Core docs should use extension functions with reified types","**Affects:**  5.2.0-SNAPSHOT  In https://github.com/spring-projects/spring-framework/tree/master/src/docs/asciidoc/core line 374 is: ``` val service = context.getBean(""petStore"", PetStoreService::class.java) ```  ""Kotlin style"" would be: ``` val service = context.getBean(""petStore"") ```","closed","in: core,","juergenzimmermann","2019-08-13T05:31:07Z","2019-08-13T07:45:14Z"
"","23370","io.netty.handler.codec.DecoderException: javax.net.ssl.SSLException: Received fatal alert: handshake_failure","**Affects:**  5.1.4  **Error**: io.netty.handler.codec.DecoderException: javax.net.ssl.SSLException: Received fatal alert: handshake_failure  **How to reproduce**: Attempt to call a HTTPS endpoint using the Spring Webflux WebClient.  Everything works perfectly when I use RestTemplate.  I tried two different configurations:  **Option 1**:  ```java         WebClient webClient = WebClient.builder().build();          return new MyApi(settings, webClient); ```  **Option 2**:  ```java         SslProvider sslProvider = SslProvider.builder()                 .sslContext(SslContextBuilder.forClient())                 .defaultConfiguration(SslProvider.DefaultConfigurationType.NONE)                 .build();          TcpClient tcpClient = TcpClient.create().secure(sslProvider);         HttpClient httpClient = HttpClient.from(tcpClient);         ClientHttpConnector httpConnector = new ReactorClientHttpConnector(httpClient);          WebClient webClient = WebClient.builder().clientConnector(httpConnector).build();          return new MyAPI(settings, webClient); ```  There is nothing specifically special about the HTTPS endpoint that I want to call.","closed","","drieselliott","2019-07-26T13:05:36Z","2020-05-04T12:07:37Z"
"","23062","Generic bean resolution doesn't work for nested generics","**Affects:**  4.3.x  Consider the following class heirarchy (assume constructors with @Inject for final fields): ```java @Component class DataStore {     private final CachingService cachingService; }  @Component class PersonCachingService implements CachingService { ... }  @Component class VehicleCachingService implements CachingService { ... }  @Component class PeopleApp {    private final DataStore dataStore; } ``` **Expected Behavior:** Resolving the `DataStore` dependency for `PeopleApp` should succeed as there is only 1 matching candidate bean (`personCachingService`) that matches the right bounds for the type parameter of `DataStore` required by `PeopleApp`  **Actual Behavior:** Bean resolution fails with the following exception: `org.springframework.beans.factory.NoUniqueBeanDefinitionException:  No qualifying bean of type 'com.amazon.cpcatropsplanner.CachingService' available:  expected single matching bean but found 2: personCachingService,vehicleCachingService `","open","in: core,","Avinm","2019-05-30T13:37:49Z","2021-10-29T08:09:57Z"
"","23288","Illegal reflective access warning for CGLIB proxy on JDK 11","**Affects:**  2.1.6.RELEASE  Hey guys,  I'm using **JDK 11.0.2** and **Spring Boot 2.1.6.RELEASE**. Right after the upgrade to **2.1.6.RELEASE**, I started getting the following warning:  ``` WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils (file:/.../org/springframework/spring-core/5.1.8.RELEASE/spring-core-5.1.8.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:525) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.reflect.FastClass$Generator.create(FastClass.java:65) 	at org.springframework.cglib.proxy.MethodProxy.helper(MethodProxy.java:135) 	at org.springframework.cglib.proxy.MethodProxy.init(MethodProxy.java:76) 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:216) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:684) 	at platterz.accounting.services.LedgerServiceImp$$EnhancerBySpringCGLIB$$dfc059db.toString() 	at platterz.treat.jobs.RuleCreditingJob.execute(RuleCreditingJob.kt:31) 	at org.quartz.core.JobRunShell.run(JobRunShell.java:202) 	at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) ```  Is it planned on being fixed anytime soon? Is there a workaround? Do you guys need additional logs?  Thanks, Moshe!","closed","status: superseded,","bmoshe","2019-07-14T06:36:45Z","2021-01-23T12:10:50Z"
"","23185","RSocketRequester.ResponseSpec Kotlin extensions issue","**Affects: Spring Framework 5.2.0-M3**  Really glad you're integrating Kotlin, Coroutines and RSocket into the messaging module @sdeleuze   I think inline reified generics are needed on these new methods.  - data - retrieveFlow - retrieveFlux - retrieveAndAwait - retrieveMono  `    requester.route(""myRoute"").data(""123"").retrieveFlow() ` gives me the following error  ` Caused by: java.lang.IllegalArgumentException: No decoder for ? at o.s.m.r.RSocketStrategies.decoder(RSocketStrategies.java:85) at o.s.m.r.DefaultRSocketRequester$DefaultResponseSpec.retrieveFlux(DefaultRSocketRequester.java:366)  at o.s.m.r.DefaultRSocketRequester$DefaultResponseSpec.retrieveFlux(DefaultRSocketRequester.java:339)	 ` I have a patch to fix the code and test in [gist](https://gist.github.com/slawluc/11673dc423b4a938d232b497106694cd#file-fix-patch). I can submit as a pull request shortly","closed","type: bug,","slawluc","2019-06-24T08:33:15Z","2019-07-08T10:12:10Z"
"","23369","SpEL could not call methods of Object on a Proxy-Object","**Affects: Spring Framework 5.0/5.1**  --- I found the problem, that I couldn't call methods of Object in the SpEL, when the target-object is a Proxy. In my case it was the toString()-method. I build a test, which shows the behavior and my workaround: [SpelProxyText.zip](https://github.com/spring-projects/spring-framework/files/3435517/SpelProxyText.zip)","closed","status: superseded,","MrCoffee77","2019-07-26T11:26:23Z","2021-12-10T23:09:07Z"
"","22963","Duplicate @PropertySource declaration is not processed","**Affects: `spring-core` 5.1.7**   `@PropertySource` appears to be read only once even if specified multiple times (probably for performance reasons ?). This leads to some strange behavior.  Consider this code :   ```java @PropertySource(""classpath:dev2.properties"") @PropertySource(""classpath:dev.properties"") @Configuration public class MyProperties {  } ```  Here `dev.properties` wins and overrides `dev2.properties`. As expected.    But this code :   ```java @PropertySource(""classpath:dev.properties"") @PropertySource(""classpath:dev2.properties"") @PropertySource(""classpath:dev.properties"") @Configuration public class MyProperties {  } ```  `dev2.properties` overrides `dev.properties`. Which is kind of unexpected. That's because the second `dev.properties` is ignored because it has already been read.    I would expect the other way around, that the last specified `@PropertySource` always ""wins"".","closed","status: feedback-provided,","olevitt","2019-05-13T16:08:08Z","2019-05-14T10:12:56Z"
"","22985","DispatcherServlet reads request body while log request information","**Affects** 5.1  --- `DispatcherServlet.logRequest` method reads input stream with request body while executing `request.getParameterMap()`. As soon as the input stream is read for the first time, it’s marked as consumed and cannot be read again. So any MVC controller will not be able to read request body after the logging.  An exception appears in the log:  ``` [org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public void com.haulmont.bpm.web.controller.ModelController.updateModel(java.lang.String,org.springframework.util.MultiValueMap,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) throws java.io.IOException] ``` Sample:  Spring application with Spring MVC. Controller that handles request body: ``` @Controller(""ModelController"") @RequestMapping(""/modeler/model"") public class ModelController {  @RequestMapping(value = ""/{actModelId}"", method = RequestMethod.PUT)     public void updateModel(@PathVariable String actModelId,                             @RequestBody MultiValueMap values,                             HttpServletRequest request,                             HttpServletResponse response) throws IOException {} } ```  This works fine on Spring 4.3.18.","closed","status: invalid,","andreysubbotin","2019-05-17T06:06:00Z","2019-09-26T05:38:57Z"
"","23275","Add constants for X-Forwarded-* headers in HttpHeaders","**Affects** current/all  **Proposal** There is a need of constants for X-Forwarded-* Headers in [HttpHeaders](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/HttpHeaders.java). Below headers are good candidates: 1. X-Forwarded-Host 2. X-Forwarded-Port 3. X-Forwarded-Proto 4. X-Forwarded-Prefix 5. X-Forwarded-Ssl  **Some references of their usages:** - [IETF - RFC7239 Forwarded HTTP Extension](https://tools.ietf.org/html/rfc7239#section-5.2) - https://github.com/spring-projects/spring-framework/issues/20169 - [ServletUriComponentsBuilder.java](https://github.com/spring-projects/spring-framework/blob/9f4d4d18297581ad770a6281097f733c4f6342d3/spring-webmvc/src/main/java/org/springframework/web/servlet/support/ServletUriComponentsBuilder.java) - [ForwardedHeaderFilter.java](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java)  **Earlier related discussions** - Proposal to map standard Http Headers in Guava - [HTTP Inbound Gateway headers not mapping Content-Disposition](https://jira.spring.io/browse/INT-3488) - [Guava has these headers meanwhile](https://github.com/google/guava/issues/2430)","closed","","amjedonline","2019-07-11T09:37:48Z","2019-07-25T13:28:31Z"
"","23291","After pulling, the new module reports an error, CoroutinesRegistrar gives an error","* Environmental configuration   * `idea 2018`   * `jdk1.8_131`   * `gradle-4.9`  * error message  ``` Error:(347, 51) java: 找不到符号 符号: 变量 CoroutinesUtils 位置: 类 org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar ```  * Workaround, add dependencies in the custom `module`  ```groovy compile project("":spring-instrument"") compile project("":spring-core-coroutines"") // or use compile files(""../spring-instrument/build/libs/spring-instrument-5.2.0.BUILD-SNAPSHOT.jar"") compile files(""../spring-core-coroutines/build/libs/spring-core-coroutines-5.2.0.BUILD-SNAPSHOT.jar"") ```  ### configuration  * Master configuration class  ```java package com.jonny.config;  import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration;  /**  * @Author Lee  * @Description  * @Date 2019年07月14日 20:56  */ @Configuration @ComponentScan(""com.jonny"") public class App {  } ```  * serviceimpl  ```java package com.jonny.service;  import org.springframework.stereotype.Service;  /**  * @Author Lee  * @Description  * @Date 2019年07月14日 20:57  */ @Service public class UserServiceImpl {  	public UserServiceImpl() { 		System.out.println(""init...""); 	} } ```  * test class  ```java import com.jonny.config.App; import org.springframework.context.annotation.AnnotationConfigApplicationContext;  /**  * @Author Lee  * @Description  * @Date 2019年07月14日 20:53  */ public class Test { 	public static void main(String[] args) { 		AnnotationConfigApplicationContext ioc = new AnnotationConfigApplicationContext(App.class); 		System.out.println(ioc); 	} } ```  * Console output  ```bash init... org.springframework.context.annotation.AnnotationConfigApplicationContext@c038203, started on Sun Jul 14 22:06:17 CST 2019 ```  *  [Reference address](https://github.com/spring-projects/spring-framework/issues/22859)","closed","","Jonny023","2019-07-14T14:26:36Z","2019-07-28T15:03:29Z"
"","23227","Log the bean exception trace as a multi line log","(As requested, moved from the issue at Spring Boot: https://github.com/spring-projects/spring-boot/issues/17343 At the moment, when there is an issue during bean creation (exceptions that something is missing or that there are circular dependencies, etc.), the EXCEPTION_MSG contains the trace through all the beans that were involved in the error.   The problem is that this trace is displayed on a single line. Considering that this trace can go through multiple beans (the current one I am trying to fix goes 8 levels deep) this line can get thousands of characters long.   It would be nice if the bean exception trace would be displayed on multiple lines, for readability and to prevent the need of horizontal scrolling, like:  ``` yyyy-mm-dd hh:ii:ss,fff - ERROR: MESSAGE=[Application run failed] TID=[main] CLASS=[org.springframework.boot.SpringApplication] EXCEPTION=[org.springframework.beans.factory.UnsatisfiedDependencyException] EXCEPTION_MSG=[ 		Error creating bean with name 'someBean':  			Unsatisfied dependency expressed through field 'someOtherBean';  	nested exception is org.springframework.beans.factory.BeanCreationException:  		Error creating bean with name 'someOtherBean' defined in class path resource [path/to/ResourceAutoConfiguration.class]:  			Bean instantiation via factory method failed;  	nested exception is org.springframework.beans.BeanInstantiationException:  		Failed to instantiate [path.to.resource.SomeOtherBean]:  			Circular reference involving containing bean 'someBean' - consider declaring the factory method as static for independence from its containing instance.  			Factory method 'someOtherBean' threw exception;  	nested exception is org.springframework.beans.factory.BeanCreationException:  		Error creating bean with name 'aThirdBean':  			Requested bean is currently in creation: Is there an unresolvable circular reference? ] ROOT_CAUSE=[org.springframework.beans.factory.BeanCurrentlyInCreationException] ROOT_CAUSE_MSG=[Error creating bean with name 'aThirdBean': Requested bean is currently in creation: Is there an unresolvable circular reference?] STACKTRACE=[org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) ``` In stead of: ``` yyyy-mm-dd hh:ii:ss,fff - ERROR: MESSAGE=[Application run failed] TID=[main] CLASS=[org.springframework.boot.SpringApplication] EXCEPTION=[org.springframework.beans.factory.UnsatisfiedDependencyException] EXCEPTION_MSG=[Error creating bean with name 'someBean': Unsatisfied dependency expressed through field 'someOtherBean'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'someOtherBean' defined in class path resource [path/to/ResourceAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [path.to.resource.SomeOtherBean]: Circular reference involving containing bean 'someBean' - consider declaring the factory method as static for independence from its containing instance. Factory method 'someOtherBean' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'aThirdBean': Requested bean is currently in creation: Is there an unresolvable circular reference?] ROOT_CAUSE=[org.springframework.beans.factory.BeanCurrentlyInCreationException] ROOT_CAUSE_MSG=[Error creating bean with name 'aThirdBean': Requested bean is currently in creation: Is there an unresolvable circular reference?] STACKTRACE=[org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) ```","open","type: enhancement,","CC007","2019-07-02T14:24:14Z","2019-07-03T08:08:44Z"
"","23439","Fix */* in Javadoc","> {@code} >  >     {@code text } >  > Equivalent to {@literal text }. >  > Displays text in code font without interpreting the text as HTML markup or nested Javadoc tags.  https://docs.oracle.com/en/java/javase/12/docs/specs/doc-comment-spec.html  This is why `{@code */*}` isn't rendered as */* as expected.  @pivotal-issuemaster This is an Obvious Fix.","closed","type: documentation,","GreenRecycleBin","2019-08-09T06:03:10Z","2019-08-10T09:27:19Z"
"","23269","Create migration guide from RestTemplate to WebClient","> The RestTemplate will be deprecated in a future version and will not have major new features added going forward.  https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html  Could you add a detailed migration guide on how to refactor existing `RestTemplate` (which typically is for sync blocking requests) into `WebClient` requests (also sync and blocking)?  Because the usual case for WebClient is probably for async requests, but chances are high that if someone refactors to `WebClient` he want's to stick to his synchronous patterns.  Wouldn't this be a good idea to grab spring users by their hands just now, if it's planned to deprecate `RestTemplate` in future anyhow?","open","in: web,","membersound","2019-07-10T10:46:50Z","2022-04-20T10:15:14Z"
"","23266","Please use AssertJ assertions. [expectedExceptionAnnotation]","> Task :spring-test:checkstyleTest FAILED  >[ant:checkstyle] [ERROR] C:\Users\liao_\Documents\spring-source-code\spring-framework\spring-test\src\test\java\org\springframework\test\context\testng\transaction\programmatic\ProgrammaticTxMgmtTestNGTests.java:102: Please use AssertJ assertions. [expectedExceptionAnnotation] [ant:checkstyle] [ERROR] C:\Users\liao_\Documents\spring-source-code\spring-framework\spring-test\src\test\java\org\springframework\test\context\testng\transaction\programmatic\ProgrammaticTxMgmtTestNGTests.java:108: Please use AssertJ assertions. [expectedExceptionAnnotation] [ant:checkstyle] [ERROR] C:\Users\liao_\Documents\spring-source-code\spring-framework\spring-test\src\test\java\org\springframework\test\context\testng\transaction\programmatic\ProgrammaticTxMgmtTestNGTests.java:114: Please use AssertJ assertions. [expectedExceptionAnnotation] [ant:checkstyle] [ERROR] C:\Users\liao_\Documents\spring-source-code\spring-framework\spring-test\src\test\java\org\springframework\test\context\testng\transaction\programmatic\ProgrammaticTxMgmtTestNGTests.java:120: Please use AssertJ assertions. [expectedExceptionAnnotation] [ant:checkstyle] [ERROR] C:\Users\liao_\Documents\spring-source-code\spring-framework\spring-test\src\test\java\org\springframework\test\context\testng\transaction\programmatic\ProgrammaticTxMgmtTestNGTests.java:126: Please use AssertJ assertions. [expectedExceptionAnnotation] [ant:checkstyle] [ERROR] C:\Users\liao_\Documents\spring-source-code\spring-framework\spring-test\src\test\java\org\springframework\test\context\testng\transaction\programmatic\ProgrammaticTxMgmtTestNGTests.java:131: Please use AssertJ assertions. [expectedExceptionAnnotation]  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-test:checkstyleTest'. > Checkstyle rule violations were found. See the report at: file:///C:/Users/liao_/Documents/spring-source-code/spring-framework/spring-test/build/reports/checkstyle/test.html   Checkstyle files with violations: 1   Checkstyle violations by severity: [error:6]","closed","status: invalid,","lightning-L","2019-07-10T06:27:16Z","2019-07-10T14:29:55Z"
"","23253","Javadoc generation fails due to improper encoding","> Task :api C:\Users\Documents\spring-source-code\spring-framework\spring-web\src\main\java\org\springframework\http\codec\multipart\DefaultMultipartMessageReader.java:255: error: unmappable character for encoding GBK 				builder.append(""鈵?""); 				                 ^ C:\Users\Documents\spring-source-code\spring-framework\spring-web\src\main\java\org\springframework\http\codec\multipart\DefaultMultipartMessageReader.java:258: error: unmappable character for encoding GBK 				builder.append(""鈵?""); 				                 ^ 2 errors  > Task :api FAILED  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':api'. > Javadoc generation failed. Generated Javadoc options file (useful for troubleshooting): 'C:\Users\liao_\Documents\spring-source-code\spring-framework\build\tmp\api\javadoc.options'","closed","type: task,","lightning-L","2019-07-09T07:15:07Z","2019-07-10T03:18:51Z"
"","22890","CONTRIBUTING.md missing word in commit message formatting description","> Format commit messages using 55 characters for the subject line, 72 lines for the description, followed by the issue fixed, e.g. Fixes #22276.  ""72 lines"" should read 72-character lines to explain that lines in the description should not exceed 72 characters in width.","closed","status: superseded,","rewolf","2019-05-05T02:53:21Z","2019-05-05T07:03:54Z"
"","23653","Enhancement - Bean name duplication","#enhancement  A case:  ``` @Bean public SomeOne aBean() {      return new SomeOne(); }  @Bean public AnotherOne aBean() {      return new AnotherOne(); } ```  In this case, I'll get `NoSuchBeanDefinitionException` on autowiring AnotherOne  It is confusing because of the root of exception in bean names duplication on anotherOne overrides previous bean definition  I think It will be convenient to get a specific exception or warning. If there is already some mechanism please let me know and I'll request close the issue  Of course, it is about naming, and it should not be named as in the example above. But my point in case of carelessness and framework feedback","open","in: core,","artemptushkin","2019-09-18T08:19:42Z","2021-11-10T11:58:02Z"
"","22931","Support any HttpEntity implementing ResolvableTypeProvider","#22876 which introduces a dependency from the `http.client` package to `http.codec.multipart` revealed a specific dependency back from `http.codec.multipart` to `http.client`, causing a cycle: `MultipartHttpMessageWriter` checks for `MultipartBodyBuilder.PublisherEntity` when it really only needs a `ResolvableType` associated with a given `HttpEntity`. For less tight coupling, `PublisherEntity` could simply implement the `ResolvableTypeProvider` interface, and `MultipartHttpMessageWriter` could simply check whether a given `HttpEntity` implements that interface, avoiding a hard reference back to `MultipartBodyBuilder`.","closed","type: enhancement,","jhoeller","2019-05-09T00:02:36Z","2019-05-09T00:27:57Z"
"","23608","Unable to register MBean - Invalid character `:' in value","##### Issue originally posted https://github.com/spring-projects/spring-integration/issues/3051  Hi all. I have similar(I think) issues to [spring-cloud-stream/#1497](https://github.com/spring-cloud/spring-cloud-stream/issues/1497) when I try run application to listening mqtt broker. Simple project with that issue and workaround: https://github.com/Stiuil06/demo-mqtt-listener Im trying to run this code: https://docs.spring.io/spring-integration/docs/5.2.0.BUILD-SNAPSHOT/reference/html/mqtt.html#configuring-with-the-java-dsl **Configuring with the Java DSL**  for **Configuring with Java Configuration** everything works.  My stacktrace ``` org.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean [mqttInbound.mqtt:inbound-channel-adapter#0] with key 'mqttInbound.mqtt:inbound-channel-adapter#0'; nested exception is javax.management.MalformedObjectNameException: Invalid character `:' in value 	at org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:625) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.jmx.export.MBeanExporter.lambda$registerBeans$2(MBeanExporter.java:551) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at java.base/java.util.HashMap.forEach(HashMap.java:1333) ~[na:na] 	at org.springframework.jmx.export.MBeanExporter.registerBeans(MBeanExporter.java:551) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.jmx.export.MBeanExporter.afterSingletonsInstantiated(MBeanExporter.java:434) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:862) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:743) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:390) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1214) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1203) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at com.firstnamelastname.grl.MiddlewareApplication.main(MiddlewareApplication.java:10) ~[classes/:na] Caused by: javax.management.MalformedObjectNameException: Invalid character `:' in value 	at java.management/javax.management.ObjectName.parseValue(ObjectName.java:978) ~[na:na] 	at java.management/javax.management.ObjectName.checkValue(ObjectName.java:1010) ~[na:na] 	at java.management/javax.management.ObjectName.construct(ObjectName.java:729) ~[na:na] 	at java.management/javax.management.ObjectName.(ObjectName.java:1450) ~[na:na] 	at java.management/javax.management.ObjectName.getInstance(ObjectName.java:1356) ~[na:na] 	at org.springframework.jmx.support.ObjectNameManager.getInstance(ObjectNameManager.java:99) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.jmx.export.naming.MetadataNamingStrategy.getObjectName(MetadataNamingStrategy.java:135) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.boot.autoconfigure.jmx.ParentAwareNamingStrategy.getObjectName(ParentAwareNamingStrategy.java:59) ~[spring-boot-autoconfigure-2.1.7.RELEASE.jar:2.1.7.RELEASE] 	at org.springframework.jmx.export.MBeanExporter.getObjectName(MBeanExporter.java:755) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.jmx.export.MBeanExporter.registerBeanInstance(MBeanExporter.java:654) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	at org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:615) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE] 	... 13 common frames omitted ```  My code ```@Configuration public class MeasurementListener {      @Bean     public IntegrationFlow mqttInbound() {         return IntegrationFlows.from(                 new MqttPahoMessageDrivenChannelAdapter(""tcp://localhost:1883"", ""/measurement/+/+""))                 .handle(m -> System.out.println(m.getPayload()))                 .get();     }  } ```  My main pom ```      4.0.0      com.firstnamelastname     grl     0.0.1-SNAPSHOT     green-real-time     Green Real Time      pom              grl-core         grl-firmware-simulator         grl-middleware                   org.springframework.boot         spring-boot-starter-parent         2.1.7.RELEASE                               UTF-8         UTF-8         12         ${java.version}         ${java.version}                                 org.springframework.boot             spring-boot-starter                               org.springframework.boot             spring-boot-starter-test             test                                                           org.springframework.boot                 spring-boot-maven-plugin                                           org.apache.maven.plugins                 maven-release-plugin                                      install                     true                                               ``` pom for this module ```      4.0.0               com.firstnamelastname         grl         0.0.1-SNAPSHOT           grl-middleware     0.0.1-SNAPSHOT     green-real-time-middleware     Green Real Time - Middleware               true                                 com.firstnamelastname             grl-core             0.0.1-SNAPSHOT             compile                               org.springframework.boot             spring-boot-starter-data-cassandra-reactive                               org.springframework.integration             spring-integration-mqtt             5.1.7.RELEASE                                                           org.springframework.boot                 spring-boot-maven-plugin                              ```","open","in: core,","Stiuil06","2019-09-08T15:07:58Z","2021-11-11T10:12:41Z"
"","23605","Spring fails to determine that XML is DTD-based if DTD declaration is followed by a comment","### Version Tested on spring **5.1.9.RELEASE**.  ### Repro 1. First create a simple  configuration file: `spring-config.xml` (note that there is a comment at the end of the DOCTYPE line)  ```xml       ```  2. Load this configuration file `ApplicationContext context = new ClassPathXmlApplicationContext(""spring-config.xml"");`  3. An exception has occurred  ``` Exception in thread ""main"" org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 5 in XML document from class path resource [spring-config.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 5; columnNumber: 8; cvc-elt.1.a: 找不到元素 'beans' 的声明。 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:404) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257) 	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128) 	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94) 	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:133) 	at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:636) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:521) 	at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:144) 	at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:85) 	at com.kang.Test.main(Test.java:8) Caused by: org.xml.sax.SAXParseException; lineNumber: 5; columnNumber: 8; cvc-elt.1.a: 找不到元素 'beans' 的声明。 	at java.xml/com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:204) 	at java.xml/com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.error(ErrorHandlerWrapper.java:135) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:395) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:326) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:283) 	at java.xml/com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.handleStartElement(XMLSchemaValidator.java:2131) 	at java.xml/com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:828) 	at java.xml/com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.startElement(XMLDTDValidator.java:746) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:374) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl$NSContentDriver.scanRootElementHook(XMLNSDocumentScannerImpl.java:613) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:3058) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(XMLDocumentScannerImpl.java:820) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:601) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:112) 	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:531) 	at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:887) 	at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:823) 	at java.xml/com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141) 	at java.xml/com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:243) 	at java.xml/com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:339) 	at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:77) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadDocument(XmlBeanDefinitionReader.java:434) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:392) 	... 14 more ```  4. If you remove the comment at the last position in the DOCTYPE line, then everything works fine...  ### Analysis  The cause of the exception is to incorrectly parse the validation mode of the XML document.   The code that causes the bug is in the **consumeCommentTokens(String)** method of the `org.springframework.util.xml.XmlValidationModeDetector`.  This method not only consumes the comment itself, but also consumes the content **before** the comment.  Suppose a line in the xml file has the following code: `aaabbb` After this content is processed by this method, only the ""bbb"" string will be returned.  In other words, the effective information ""aaa"" is lost.   This is why the xml validation type cannot be parsed correctly after adding a comment after the DOCTYPE line.","closed","in: core,","kangjianwei","2019-09-07T16:54:01Z","2019-09-09T14:43:12Z"
"","23502","WebClient's ClientRequest.Builder#cookies and ClientRequest.Builder#cookie give different results","### Summary  `ClientRequest.Builder#cookies(Consumer> cookiesConsumer)` gives different results than `ClientRequest.Builder#cookie(String name, String... values)`  ### Actual Behavior  **Code:**  `builder.cookies( cookies -> cookies.set(  ""XSRF-TOKEN"", ""7ed2ea19-7442-413a-ab5d-4be9c2f4a3ed"" ) )` or `builder.cookies( cookies -> cookies.add(  ""XSRF-TOKEN"", ""7ed2ea19-7442-413a-ab5d-4be9c2f4a3ed"" ) )`  **What is sent**  `Set-Cookie: XSRF-TOKEN=7ed2ea19-7442-413a-ab5d-4be9c2f4a3ed; Path=/; Secure`   **Code:**  `builder.cookie( ""XSRF-TOKEN"", ""7ed2ea19-7442-413a-ab5d-4be9c2f4a3ed"" ) `  **What is sent**  `Set-Cookie: XSRF-TOKEN=7ed2ea19-7442-413a-ab5d-4be9c2f4a3ed`  ### Expected Behavior  Both methods create the same cookie or documentation indicates the difference.  ### Version  spring-webflux - 5.1.8.RELEASE  ### Sample  Discovered it when I was working on CsrfClientExchangeFilterFunction which can be found here: https://stackoverflow.com/a/57611121/2004186","closed","in: web,","skrzyneckik","2019-08-22T14:19:26Z","2019-09-06T12:55:21Z"
"","23666","Field level permissions based on data classification","### Is your feature request related to a problem? Please describe. I would like to classify entity properties according to a specific perspective and the manage access to them via permissions based on these classifications.  EG. I would like to add a GDPR perspective classification (PII or non-PII). Then I would like to specify to certain users, roles or permissions if they are allowed to see PII and/or non-PII data. Another classification is confidentiality (public data, internal data, condifential and or strictly confidential)   ### Describe the solution you'd like It would be great to have an annotation such as @classify that works in a similar was as @authorize.   ### Additional context In my opinion, there are 3 levels of security being action (crud-operation), object level and field-property level. This last one is still missing. Views are an option, but it isn't fundamentalky about security, views are about representing behaviour and how you expose data. Not about if you are allowed to expose data.   Looking forward on feedback about this!","closed","for: external-project,","Tankske","2019-09-18T21:50:40Z","2019-09-19T10:58:57Z"
"","23365","WebClient subscribing twice","### Expected behavior Only hit `reactor.netty.channel.FluxReceive#startReceiver` once  ### Actual behavior Hits twice, where second time throws silently the `""Only one connection receive subscriber allowed.""`  In production, sometimes this exception is reported from `reactor.core.publisher.Operators : Operator called default onErrorDropped ...`. Locally I could only see this exception at the point of throwing inside `FluxReceive#startReceiver` with a debugger. Later in `reactor.core.publisher.MonoFlatMap.FlatMapMain#onError` it was `done = false`, so the exception was never shown anywhere.  ### Steps to reproduce My calling code is the following: ```java webClient.get()       .uri(""myUri"")       .retrieve()       .onStatus(HttpStatus::isError, response ->                           response.bodyToMono(ErrorResponse.class)                                   .log(""response.bodyToMono"")                                   .flatMap(error -> Mono.error(                                           new MyException(                                                   MyErrorType.ofCode(error.getCode()).orElse(null),                                                   error.getDescription()                                           )                                   ))         )       .bodyToMono(MyDto.class) ```  the logs: ``` client.bodyToMono                        : | onSubscribe([Fuseable] MonoFlatMap.FlatMapMain) client.bodyToMono                        : | request(unbounded) response.bodyToMono                      : | onSubscribe([Fuseable] MonoSingle.SingleSubscriber) response.bodyToMono                      : | request(unbounded) response.bodyToMono                      : | onNext(ErrorResponse(code=500, description=message)) response.bodyToMono                      : | cancel() client.bodyToMono                        : | onError(com.bla.MyException: message) client.bodyToMono                        :  the exception stacktrace ```  ### Reactor Core version `org.springframework:spring-webflux:5.1.6.RELEASE` ### JVM version (e.g. `java -version`) `openjdk version ""11.0.1"" 2018-10-16`   ========   The workaround for me is using an ExchangeFilterFunction https://stackoverflow.com/a/48984852/6166627 instead of `onStatus`. With this approach, I only hit the start receiver once with a debugger. Hopefully, it's gonna fix itself.   Anyway, this ERROR log seems to not affect anything actually, the code still throws MyException  --- originally posted in reactor but it's off-topic there https://github.com/reactor/reactor-core/issues/1747 Similar: #22096 #22284","closed","status: invalid,","Sam-Kruglov","2019-07-26T07:23:07Z","2022-06-10T15:03:56Z"
"","23138","Support rollbackFor attribute of @Transactional in the TestContext framework","### Description  Transactional test methods wouldn't rollback for exception，when annotated by `@Commit` or `@Rollback(false)`.    For example, the following `roleService.saveOrUpdate(sysRole)` would commit.   ```java @RunWith(SpringRunner.class) @SpringBootTest @Transactional(rollbackFor = Exception.class) @Commit public class UserServiceTest {     @Autowired     private RoleService roleService;     @Test     public void testRollBack() {         SysRole sysRole = new SysRole(""General"");         roleService.saveOrUpdate(sysRole);         throw new RuntimeException(""ALWAYS_THROW"");     } } ```  This would cause partial DML operation commit.  ### Suggestion  The following code snippet force commit or rollback according to `flaggedForRollback`  ```java // class org.springframework.test.context.transaction.TransactionContext#endTransaction if (this.flaggedForRollback) {     this.transactionManager.rollback(this.transactionStatus); } else {     this.transactionManager.commit(this.transactionStatus); }  ``` **I would like to make some changes, determine if there is a matching exception in the testContext.**","closed","status: feedback-provided,","yanjuning","2019-06-14T06:29:24Z","2019-06-19T12:02:17Z"
"","23533","Make @Scheduled's fixedDelay work with methods returning Mono","### Context Consider this method ```java @Scheduled(fixedDelay = 1000) void job() {     // some syncronous work } ``` The `job()` method can be counted upon to never be called until the previous run of `job()` is finished.  Now consider this method ```java @Scheduled(fixedDelay = 1000) void job() {     someAsyncMethodReturningAMono()        .subscribe() } ``` Here, `job()` would be called 1000ms after the previous run of `job()` returns, _not_ when the the `Mono` returned by `someAsyncMethodReturningAMono()` would terminate. If the asynchronous work takes just over a bit longer than 1000ms, it may run at the same time as previous runs. This can be mitigated by using the `.block()` statement to subscribe to `someAsyncMethodReturningAMono()`, effectively making `job()` syncronous again, but it would be better to have a non-blocking answer to this.  ### Proposal To let `@Scheduled`'s `fixedDelay` property, when the annotated method returns a `Mono` or a `Flux`, start the delay count from the moment the returned `Mono` or `Flux` terminates instead of when the method returns the `Mono`, so that one can write this: ```java @Scheduled(fixedDelay = 1000) Mono job() {     return someAsyncMethodReturningAMono(); } ``` This code would resonate with WebFlux users nicely.","open","type: enhancement,","DavidDuwaer","2019-08-28T07:37:15Z","2021-11-01T14:39:22Z"
"","23504","Support invoking static methods with ReflectionTestUtils.invokeMethod()","### Background  Spring Test's [ReflectionTestUtils](https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html) includes methods for setting/getting fields, like so (bolded text is from me):   - `getField(Class targetClass, String name)`     - Get the value of the **static field** with the given name from the provided `targetClass`.  - `getField(Object targetObject, Class targetClass, String name)`     - Get the value of the **field** with the given name from the provided `targetObject`/`targetClass`.  - `getField(Object targetObject, String name)`     - Get the value of the **field** with the given name from the provided `targetObject`.  Note that `getField()` works for both static fields and regular fields (support for static fields was added in v4.2.0.RC1 with [this commit](https://github.com/spring-projects/spring-framework/commit/063ef240c185fe6ba2ed39ef2fc6767c7a8dd900), associated with #11458).  ### Problem  In contrast, there is only one version of `invokeMethod()`, and it only works on an instantiated `Object`.   - `invokeMethod(Object target, String name, Object... args)`    - Invoke the **method** with the given name on the supplied target object with the supplied arguments.  There are no other versions of `invokeMethod()` that work for static methods.   ### Feature Request  To make the class more consistent with `getField()` and `setField()`, I would like to request a new version of `invokeMethod()` that works on static methods:   - `invokeMethod(Class targetClass, String name, Object... args)`    - Invoke the **static method** with the given name on the provided `targetClass` with the supplied arguments.  If it makes sense, we should also add:   - `invokeMethod(Object targetObject, Class targetClass, String name, Object... args)`    - Invoke the **method** with the given name on the provided `targetObject`/`targetClass` with the supplied arguments.","closed","type: enhancement,","Thunderforge","2019-08-22T20:23:03Z","2019-08-23T14:29:01Z"
"","23029","MockHttpServletRequest setCookies should join cookies to single Cookie header","## Version  spring-test-5.1.6.RELEASE  ## Overview  `setCookies` on a `MockHttpServletRequest` sets multiple ""Cookie"" Headers. It should concatenate the cookie name/value pairs into a single ""Cookie"" header string joined with delimiter `""; ""`.  `MockHttpServletRequest` `setCookies` javadoc has little detail on what behavior a user should expect.  If the behavior deviates from [rfc6265](https://tools.ietf.org/html/rfc6265#section-4.2.1) syntax by design then could the documentation be amended to reflect that?  ### Test case exposing defect  ```java     @Test     public void cookiesRegressionIssue() {         // potentially regression of https://github.com/spring-projects/spring-framework/issues/19790 ?         // ** arrange         MockHttpServletRequest request = new MockHttpServletRequest();         Cookie cookie1 = new Cookie(""foo"", ""bar"");         Cookie cookie2 = new Cookie(""baz"", ""qux"");          // ** act         // Javadoc gives no detail:         // https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/mock/web/MockHttpServletRequest.html#setCookies-javax.servlet.http.Cookie...-         request.setCookies(cookie1, cookie2);          // ** assert         Cookie[] cookies = request.getCookies();         assertAll(""Cookies>Headers conversion should work"",                 () -> assertThat(cookies.length, is(2)),                 () -> assertThat(cookies[0].getName(), is(""foo"")),                 () -> assertThat(cookies[0].getValue(), is(""bar"")),                 () -> assertThat(cookies[1].getName(), is(""baz"")),                 () -> assertThat(cookies[1].getValue(), is(""qux"")),                 () -> assertThat(request.getHeader(""Cookie""), is(""foo=bar; baz=qux"")),                  () -> assertThat(Collections.list(request.getHeaders(""Cookie"")), hasSize(1))         );     } ```","closed","status: feedback-provided,","chas678","2019-05-24T11:09:29Z","2019-06-05T08:02:13Z"
"","23187","PriorityOrdered Javadoc is misleading","## Status Quo  The first paragraph in the Javadoc for `PriorityOrdered` currently states the following.  > Extension of the `Ordered` interface, expressing a priority ordering: order values expressed by `PriorityOrdered` objects always apply before same order values expressed by plain `Ordered` objects.  That clearly means that a `PriorityOrdered` object has a higher priority when compared to an `Ordered` object with the same order value.  When reading that documentation, I also assume that a `PriorityOrdered` object **does not** have a higher priority when compared to an `Ordered` object that has a lower order value (i.e., higher priority numerically speaking).  In other words, based on the aforementioned Javadoc I expect `PriorityOrdered` to only have an overriding effect if the two compared objects have the same order value.  However, the current implementation of `OrderComparator#compare(Object, Object)` ignores the actual order value if one (and only one) of the two objects implements `PriorityOrdered`.  ## Analysis  The current behavior of `OrderComparator#compare(Object, Object)` is in line with the original intention of `PriorityOrdered` semantics. Thus, the Javadoc needs to be improved to avoid any confusion.  ## Related Issues  - #23079  - #23163  ## Deliverables  - [x] Update the class-level Javadoc for `PriorityOrdered` to clarify the supported semantics.","closed","in: core,","sbrannen","2019-06-24T11:07:49Z","2019-06-25T08:43:17Z"
"","23188","Presort beans in ControllerAdviceBean.findAnnotatedBeans()","## Status Quo  The `findAnnotatedBeans(ApplicationContext)` static utility method in `ControllerAdviceBean` currently does not sort the list it returns. However, every use case within the Spring Framework currently sorts the returned list immediately -- for example, in `ControllerMethodResolver.initControllerAdviceCaches(ApplicationContext)` (WebFlux), `ExceptionHandlerExceptionResolver.initExceptionHandlerAdviceCache()` (Web MVC), etc.  Since every known use case needs the beans sorted, we should just sort them upfront.  In addition, the current clients of this utility method sort the beans using `AnnotationAwareOrderComparator` which adds unnecessary overhead since a `ControllerAdviceBean` is never annotated with `@Order` or `@Priority`: `@Order` or `@Priority` are already honored internally in `ControllerAdviceBean#getOrder()`. We should therefore only sort `ControllerAdviceBean` instances using `OrderComparator`.  ## Deliverables  - [x] Sort `ControllerAdviceBean` instances using `OrderComparator` directly within `ControllerAdviceBean.findAnnotatedBeans()`.","closed","type: enhancement,","sbrannen","2019-06-24T11:42:52Z","2019-06-24T13:44:09Z"
"","23203","Introduce addSupportedMediaTypes() in FormHttpMessageConverter","## Status Quo  Although it is currently possible to add a custom supported `MediaType` to `FormHttpMessageConverter`, it is a bit cumbersome since the `List` returned by `getSupportedMediaTypes()` is immutable, which leads to code similar to the following.  ```java FormHttpMessageConverter converter = // ... List supportedMediaTypes = new ArrayList<>(converter.getSupportedMediaTypes()); supportedMediaTypes.add(new MediaType(""text"", ""custom-type"")); converter.setSupportedMediaTypes(supportedMediaTypes); ```  ## Proposal  It would be great if adding a custom media type was as simple as the following, where `addSupportedMediaTypes()` accepts a var-args list.  ```java FormHttpMessageConverter converter = // ... converter.addSupportedMediaTypes(new MediaType(""text"", ""custom-type"")); ```  ## Related Issues  - gh-23159  ## Deliverables  - [x] Introduce `addSupportedMediaTypes(MediaType...)` in `FormHttpMessageConverter`.","closed","type: enhancement,","sbrannen","2019-06-27T12:56:40Z","2019-06-27T14:17:34Z"
"","22962","Introduce Checkstyle rules to prevent improper use of JUnit APIs in production code","## Overview   This issue is a follow up to #22932.  The challenge is to define Checkstyle rules that prevent the use of types such as `org.junit.Assert` and `org.junit.Assume` in `src/main/java` while simultaneously allowing their use in `src/test/java`.  In addition, the rules cannot be too restrictive since `spring-test` actually depends on various JUnit APIs.  If we implement such rules, the implementation may require the introduction of a special `checkstyle.xml` file that is only applied to `src/main`. Furthermore, we likely should only apply these special rules to `spring-test`.  In addition, we may want to ensure that we do not accidentally use improper APIs from JUnit Jupiter and TestNG -- for example, their assertion libraries -- in `src/main` for `spring-test`.  ## Deliverables  Introduce Checkstyle rules to prevent improper use of testing/assertion APIs (except where needed in `spring-test`).  - [x] JUnit 3: `junit.framework.*` (`src/main` and `src/test`) - [x] JUnit 4: `org.junit.*` (`src/main` and `src/test`) - [x] JUnit Jupiter:`org.junit.jupiter.api.Assertions` and `org.junit.jupiter.api.Assumptions` (`src/main` and `src/test`) - [x] TestNG: `org.testng.*` (`src/main` and `src/test`) - [x] Hamcrest: `org.hamcrest.*` (`src/main` and `src/test`)","closed","type: task,","sbrannen","2019-05-13T15:43:37Z","2019-09-12T09:37:18Z"
"","23659","Ensure ClassFilter and MethodMatcher implementations are cacheable","## Overview  While resolving the regression raised in #23571, it came to our attention that not all of our `ClassFilter` and `MethodMatcher` implementations are properly cacheable with CGLIB generated proxies due to missing (or improper) `equals()` and `hashCode()` implementations.  Although such deficiencies may not manifest themselves as bugs in Core Spring's default arrangements, these might cause issues in custom arrangements in user applications.  ## Already Implemented  - `AnnotationClassFilter` - `AspectJExpressionPointcut` - `DefaultIntroductionAdvisor` and `LockMixinAdvisor` - `DeclareParentsAdvisor` - lambda expression in constructor: unnecessary - `TrueClassFilter`: unnecessary due to _Singleton_ pattern - `TrueMethodMatcher`: unnecessary due to _Singleton_ pattern - `AbstractRegexpMethodPointcut` and `JdkRegexpMethodPointcut` - `CacheOperationSourcePointcut` - `JCacheOperationSourcePointcut` - `PerTargetInstantiationModelPointcut`: unnecessary - `TransactionAttributeSourcePointcut`  ## Deliverables  Ensure that `ClassFilter` and `MethodMatcher` implementations properly implement `equals()`, `hashCode()`, and `toString()`.  ### Potential Bugs  - [x] `RootClassFilter`: `equals()`, `hashCode()`, and `toString()` - [x] `TypePatternClassFilter`: `equals()`, `hashCode()`, and `toString()` - [x] `AnnotationMethodMatcher`: `equals()` does not include the `checkInherited` flag  ### Improvements  - [x] `ControlFlowPointcut`: `toString()` - [x] `UnionClassFilter`: `toString()` - [x] `IntersectionClassFilter`: `toString()` - [x] `IntersectionMethodMatcher` and `IntersectionIntroductionAwareMethodMatcher`: `toString()` - [x] `UnionMethodMatcher` and `UnionIntroductionAwareMethodMatcher`: `toString()` - [x] `AdviceExcludingMethodMatcher`: `toString()` - [x] `SetterPointcut` and `GetterPointcut`: `toString()` - [x] `NameMatchMethodPointcut`: `toString()` - [x] `ClassFilterAwareUnionMethodMatcher` and `ClassFilterAwareUnionIntroductionAwareMethodMatcher`: `toString()`","closed","in: core,","sbrannen","2019-09-18T12:42:32Z","2019-09-19T14:23:10Z"
"","23550","Replace TestSourcesPlugin with Gradle test fixture support","## Overview  We should consider replacing our custom [`TestSourcesPlugin`](https://github.com/spring-projects/spring-framework/blob/master/buildSrc/src/main/java/org/springframework/build/testsources/TestSourcesPlugin.java) with Gradle's official support for [Test Fixtures](https://docs.gradle.org/current/userguide/java_testing.html#sec:java_test_fixtures).  ## Rationale  - Currently all test code is visible in all other (downstream) projects, and that makes it too easy to introduce unnecessary coupling.   - For example, this made it more difficult to migrate to JUnit Jupiter. - Having test fixture code in a dedicated source folder makes it readily apparent that the code is reused across the test suite. - It will be much cleaner if projects explicitly declare that they rely on specific test fixtures of upstream projects.  ## Related Issues  - #23282","closed","type: task,","sbrannen","2019-08-30T12:28:17Z","2020-01-02T19:58:58Z"
"","23149","Document supported @Transactional attributes in the TestContext framework","## Overview  The Spring TestContext framework has traditionally not supported attributes in `@Transactional` for test-managed transactions. Exceptions to the rule include support for a `PlatformTransactionManager` _qualifier_ and the `NOT_SUPPORTED` _propagation_ behavior.  Although it is possible to declare other `@Transactional` attributes for test-managed transactions, these are silently ignored, which can lead to potential confusion.  ## Related Issues  - gh-23138  ## Deliverables  - [x] Document supported `@Transactional` attributes in the TestContext framework.","closed","type: documentation,","sbrannen","2019-06-18T09:32:35Z","2019-06-18T11:36:29Z"
"","23378","Search for annotations on enclosing classes with MergedAnnotations API","## Overview  The `MergedAnnotations` API currently supports four search strategies via the `SearchStrategy` enum; however, none of those support searches on enclosing classes.  In a typical Spring application, it is not necessary to search for an annotation on an enclosing class; however, in order to provide first-class support for Spring configuration in `@Nested` test class hierarchies in JUnit Jupiter, we need a mechanism for searching on enclosing classes as well (see gh-19930). There may be other use cases as well.  ## Proposal  Introduce a new `SearchStrategy` for the `MergedAnnotations` API that supports searching for annotations on ""enclosing classes"". This would likely be in addition to the semantics currently associated with the `EXHAUSTIVE` enum.  In one way, this would be `EXHAUSTIVE`++, but I don't know that we want to change the current semantics of `EXHAUSTIVE`. So, perhaps something like `EXHAUSTIVE_PLUS_ENCLOSING_CLASSES` would be more suitable.  Providing such support in `MergedAnnotations` could alleviate some of the challenges of providing custom workarounds as can be seen in the [current work for gh-19930](https://github.com/spring-projects/spring-framework/compare/issues/gh-19930).","closed","type: enhancement,","sbrannen","2019-07-28T12:35:31Z","2019-07-31T20:16:34Z"
"","22903","Introduce HTTPS mappings in spring.schemas files","## Overview  Since some tools (e.g., older versions of STS, MyEclipse installations, etc.) physically read the contents of `spring.schemas` files to load XML schemas from the local classpath (instead of downloading them over the Internet), we should introduce HTTPS entries for all existing HTTP entries in all `/META-INF/spring.schemas` files.  ## Deliverables  Add HTTPS mappings to the `spring.schemas` files in the following artifacts.  - [x] spring-aop - [x] spring-beans - [x] spring-context - [x] spring-jdbc - [x] spring-jms - [x] spring-oxm - [x] spring-tx - [x] spring-webmvc - [x] spring-websocket","closed","type: task,","sbrannen","2019-05-06T15:40:11Z","2019-05-07T11:05:40Z"
"","23076","Upgrade to JUnit Jupiter 5.5","## Overview  Since JUnit Jupiter 5.5 RC1 has already been [released](https://github.com/junit-team/junit5/milestone/37), we should plan to upgrade to 5.5 GA once it's released, in time for Spring Framework 5.2.  ## Deliverables  - [x] Upgrade to JUnit Jupiter 5.5 as soon as it is [released](https://github.com/junit-team/junit5/milestone/40). - [x] Upgrade to JUnit Jupiter 5.5 RC1 in the interim. - [x] Upgrade to JUnit Jupiter 5.5 RC2 in the interim. - [x] Test JUnit Jupiter 5.5 `@Timeout` support with Spring's test-managed transactions.","closed","type: dependency-upgrade,","sbrannen","2019-06-03T13:11:45Z","2019-06-30T21:04:55Z"
"","23699","Refactor MBeanServer tests to use custom service URL port","## Overview  Several tests in our test suite that interact with an `MBeanServer` fail sporadically due to a `BindException`, indicating that multiple tests are attempting to create an `MBeanServer` on the same local port simultaneously. See [SPR-PUBM-113](https://build.spring.io/browse/SPR-PUBM-113) for an example.  Specifically, most of our JMX tests use the default service URL `service:jmx:jmxmp://localhost:9875`.  Commit b9013ada9ffcd400165c7701da46ba550c9660a0 helps to mitigate build failures for such conflicts, but that is effectively only a ""band aid"" solution that doesn't actually address the underlying problem.  ## Proposal  We should refactor such tests to use `SocketUtils` to find an available port, compose a custom JMX service URL using that port, and start an `MBeanServer` for the particular test using that port.","closed","type: task,","sbrannen","2019-09-25T10:51:03Z","2019-10-31T13:35:19Z"
"","23604","Upgrade to JUnit 5.5.2","## Overview  Once JUnit Jupiter 5.5.2 has already been [released](https://github.com/junit-team/junit5/milestone/43), we should upgrade and undo the workaround introduced in 3c4cd99237b89c5f3c448bcf4911914d7303440c.  ## Deliverables  - [x] Upgrade to JUnit Jupiter 5.5.2 - [x] Undo workaround in `build.gradle`","closed","type: dependency-upgrade,","sbrannen","2019-09-07T16:39:15Z","2021-02-04T20:36:45Z"
"","22894","Upgrade to JUnit 4.13","## Overview  JUnit 4.13 will be released soon. We should therefore verify that the Spring Framework build and especially the `spring-test` module work properly with JUnit 4.13 before it goes GA and then upgrade to 4.13 once it is officially released.  ## Deliverables  - [x] Upgrade to JUnit 4.13 as soon as it is [released](https://github.com/junit-team/junit4/issues/1496). - [x] Upgrade to JUnit 4.13-beta-3 in the interim.","closed","type: dependency-upgrade,","sbrannen","2019-05-05T12:59:19Z","2020-04-28T10:13:42Z"
"","23588","Update IntelliJ IDEA codestyle regarding static imports","## Overview  It appears (based solely on visual inspection of the configuration file) that our [codestyle.xml](https://github.com/spring-projects/spring-framework/blob/master/src/idea/spring-framework.xml) should be upgraded with regard to static imports.  Specifically, it appears that the configuration puts static imports first instead of last as documented [here](https://github.com/spring-projects/spring-framework/wiki/Code-Style#import-statements).  ## Deliverables  - [x] Confirm that the current configuration puts static imports first. - [x] If it does, modify it so that static imports come last.","closed","type: task,","sbrannen","2019-09-05T12:27:44Z","2019-09-05T12:56:50Z"
"","23479","Upgrade to Gradle 5.6.x","## Overview  Gradle 5.6 has been released: https://docs.gradle.org/5.6/release-notes.html  Let's upgrade the Spring Framework build to Gradle 5.6.x during Spring Framework 5.2 development.  ## Related Issues  - gh-23214","closed","type: task,","sbrannen","2019-08-17T16:28:40Z","2019-08-17T17:24:12Z"
"","23214","Upgrade to Gradle 5.5.x","## Overview  Gradle 5.5 has been released: https://docs.gradle.org/5.5/release-notes.html  Let's upgrade the Spring Framework build to Gradle 5.5.x during Spring Framework 5.2 development.  ## Related Issues  - gh-22805","closed","type: task,","sbrannen","2019-06-29T07:47:11Z","2019-07-11T12:09:40Z"
"","23209","Add explicit support for multipart/mixed in FormHttpMessageConverter","## Overview  gh-23159 added support for `multipart/*` media types in `FormHttpMessageConverter`, but users must still manually register `multipart/mixed` as a supported media type in order to POST multipart data with that content type.  For example, something similar to the following code is required to get it work.  ```java MediaType multipartMixed = new MediaType(""multipart"", ""mixed"");  restTemplate.getMessageConverters().stream()     .filter(FormHttpMessageConverter.class::isInstance)     .map(FormHttpMessageConverter.class::cast)     .findFirst()     .orElseThrow(() ->         new IllegalStateException(""Failed to find FormHttpMessageConverter""))     .addSupportedMediaTypes(multipartMixed);  MultiValueMap parts = new LinkedMultiValueMap<>(); parts.add(""field 1"", ""value 1""); parts.add(""file"", new ClassPathResource(""myFile.jpg""));  HttpHeaders requestHeaders = new HttpHeaders(); requestHeaders.setContentType(multipartMixed); HttpEntity> requestEntity =     new HttpEntity<>(parts, requestHeaders);  restTemplate.postForLocation(""example.com/myFileUpload"", requestEntity); ```  Since `multipart/mixed` is rather common in REST scenarios, it would be nice if users could forgo the steps required to manually register it as a supported media type.  ## Deliverables  - [x] Introduce a `multipart/mixed` constant in `MediaType`. - [x] Add explicit support for `multipart/mixed` in `FormHttpMessageConverter`.","closed","type: enhancement,","sbrannen","2019-06-28T15:59:40Z","2019-06-29T08:47:37Z"
"","23286","Execute test suite in Gradle using JUnit Platform","## Overview  At some point in the future, we may choose to migrate some or all existing JUnit 4 based tests to JUnit Jupiter (a.k.a., JUnit 5). At that point we will be required to execute the test suite in Gradle via `useJUnitPlatform()` in the `test` task; however, making that change now has some benefits.  For example, ignored tests within ignored test classes will be properly reported in the test results on the CI server.  Within `spring-test` we already execute JUnit Jupiter tests via `useJUnitPlatform()`; however, we can simplify the configuration for `spring-test.gradle` by running JUnit 4 tests and JUnit Jupiter tests together in the standard Gradle `test` task.  ## Deliverables  - [x] Execute JUnit 4 and JUnit Jupiter tests together in `spring-test`. - [x] Execute all JUnit based tests in the test suite via the JUnit Platform in the Gradle build.","closed","type: task,","sbrannen","2019-07-13T16:20:53Z","2019-07-13T17:20:03Z"
"","23330","Introduce generic assertion hooks in MockMvc","## Overview  As discussed in https://github.com/spring-projects/spring-framework/issues/21178#issuecomment-512774918, it would be possible to provide generic hooks in `MockMvc` APIs that allow one to use any assertion library of choice. Such generic hooks could even be used for purposes other than performing assertions.  Due to the usefulness of such general purpose hooks, we should consider introducing them in various `MockMvc` APIs even if we do not provide specific support for a fluent assertion API such as AssertJ (see gh-21178).  The introduction of such hooks would also align with similar support provided in `WebTestClient` -- for example, `WebTestClient.BodySpec.value(Consumer)`.  ## Deliverables  _TBD_","open","type: enhancement,","sbrannen","2019-07-22T16:09:30Z","2019-09-03T17:09:39Z"
"","23331","Add multi-prefix comment support for @SqlConfig","## Overview  As a follow up to gh-23289, we should also support multiple single-line comment prefixes in `@SqlConfig` for the `@Sql` support in `spring-test` in order to stay true to the Javadoc for `@Sql`.  > The configuration options provided by this annotation and `@SqlConfig` are equivalent to those supported by `ScriptUtils` and `ResourceDatabasePopulator`...  ## Deliverables  - [x] Introduce `String[] commentPrefixes() default """"` in `@SqlConfig`.","closed","type: enhancement,","sbrannen","2019-07-22T17:24:25Z","2019-07-24T10:05:48Z"
"","23451","Migrate test suite from JUnit 4 to JUnit Jupiter","## Overview  Although we have to use JUnit 4 for various tests in `spring-test` that validate our JUnit 4 support, we should be able to migrate all other tests from JUnit 4 to JUnit Jupiter.  The primary challenges include parameterized tests, where the JUnit 4 style (i.e., class-level parameterization) does not always map easily to Jupiter's `@ParameterizedTest` support (i.e., method-level parameterization).  ## Related Issues  - gh-18091 - gh-22962","closed","type: task,","sbrannen","2019-08-12T09:29:02Z","2019-08-17T10:38:34Z"
"","23129","UrlBasedViewResolvers should not override custom requestContextAttribute with null","## Overview  `org.springframework.web.servlet.view.UrlBasedViewResolver.buildView(String)` and `org.springframework.web.reactive.result.view.UrlBasedViewResolver.createView(String)` both override the `requestContextAttribute` in the created `View` *even* if the `requestContextAttribute` in the `UrlBasedViewResolver` is `null`.  Consequently if a custom subclass of `org.springframework.web.servlet.view.AbstractView` or `org.springframework.web.reactive.result.view.AbstractUrlBasedView` configures the `requestContextAttribute`, it will be overwritten with `null` if the view is dynamically instantiated by a `UrlBasedViewResolver`. On the other hand, the custom configured `requestContextAttribute` will remain in tact if the view is used outside of a `UrlBasedViewResolver`, and this subtle difference can lead to unexpected results.  If the user explicitly configures the `requestContextAttribute` for a `UrlBasedViewResolver`, the user is probably (hopefully) aware of the effect. However, if the user does not explicitly configure the `requestContextAttribute` for a `UrlBasedViewResolver` we should not overwrite any custom configuration with `null`.  ## Deliverables  - [ ] Only propagate a non-null `requestContextAttribute` to a dynamically instantiated `View` in `UrlBasedViewResolver` in `spring-webmvc`. - [ ] Only propagate a non-null `requestContextAttribute` to a dynamically instantiated `View` in `UrlBasedViewResolver` in `spring-webflux`.","closed","type: enhancement,","sbrannen","2019-06-13T11:36:15Z","2019-06-13T14:44:50Z"
"","23638","Improve docs for AnnotatedBeanDefinitionReader, @Configuration, and @ContextConfiguration regarding ""annotated classes""","## Original Description  I find this test interesting:  ```java @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = RestTemplate.class) class MyTest {      @Autowired     RestTemplate restTemplate;      @Test     void check() {         assertThat(restTemplate).isNotNull();     }  } ```  This works because while loading a context, `AnnotationConfigContextLoader` registers `@ContextConfiguration` provided classes(`RestTemplate` in this case) to bean definitions, so that they are available for injections.  So, this is also possible:  ```java @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = { MyTest2.Foo.class, MyTest2.Bar.class }) class MyTest2 {      static class Foo {         public Foo(Bar bar) {  // dependency to Bar         }     }      static class Bar {         public Bar() {         }     }      @Autowired     Foo foo;      @Autowired     Bar bar;      @Test     void check() {         assertThat(this.foo).isNotNull();         assertThat(this.bar).isNotNull();     }  } ```  I think this is not an intended usage of `@ContextConfiguration#classes`.  Probably, by default, filter-out or validate those classes to be `@Configuration` classes. For the case of allowing non `@Configuration` classes (for example, lite-mode), probably provide an explicit option(new attribute) on `@ContextConfiguration`. e.g.: `@ContextConfiguration(classes=MyBean.class, liteMode=true)`  ----  This is what I found in real world code base:  ```java @ExtendWith({MockitoExtension.class, SpringExtension.class}) @ContextConfiguration(classes = {ResourceBundleMessageSource.class, MyService.class,         MyExceptionHandler.class, MyPropertyConfiguration.class, RestTemplate.class}) public class MyExceptionHandlerTest {     // ... } ```  So, would be nice not seeing such test class :)  ---  ## Deliverables  Improve documentation for the following regarding ""annotated classes"".  - [x] `AnnotationConfigRegistry` - [x] `AnnotationConfigApplicationContext` - [x] `AnnotationConfigWebApplicationContext` - [x] `AnnotatedBeanDefinitionReader` - [x] `@Configuration` - [x] `@Import` - [x] `AnnotationConfigContextLoader` - [x] `AnnotationConfigContextLoaderUtils` - [x] `@ContextConfiguration` - [x] Reference Manual: `testing.adoc`","closed","in: core,","ttddyy","2019-09-13T20:03:04Z","2019-09-26T09:02:43Z"
"","23542","DefaultListableBeanFactory throws a NullPointerException when resetBeanDefinition() is invoked concurrently","## Exception ![image](https://user-images.githubusercontent.com/11484269/63922943-3d9b8780-ca78-11e9-8e88-4919741b2632.png)  ## Code  ```java String beanName = ...; BeanDefinitionRegistry registry = ((BeanDefinitionRegistry) context.getAutowireCapableBeanFactory());         registry.removeBeanDefinition(beanName); ```  Any help is thanks!","closed","in: core,","xuanyimo","2019-08-29T08:17:22Z","2019-09-25T07:51:22Z"
"","23014","validation error message {0} is not working","# Application * Spring boot 2.1.5.RELEASE * Sample : https://github.com/suzukitadashi/validationMessageCheck * Blog : http://tadashi.hatenablog.com/entry/2019/05/22/095656 (Sorry, Japanese only...)  # config  ## ValidationMessages.properties  ``` javax.validation.constraints.NotEmpty.message={0} must not be empty javax.validation.constraints.Size.message=size must be between {min} and {max},please.  value=value1111  ```  ## Form  ``` @Setter @Getter public class TestForm {  	@NotEmpty 	@Size(min=5, max=100) 	String value; 	 } ```  ## run   http://localhost:8080/test  Press the button without inserting anything.  # Result  ## Spring boot 2.1.4  Error messages is no problem.  ``` size must be between 5 and 100,please.  value1111 must not be empty ```  ## Spring boot 2.1.5  Error message is...  ``` size must be between 5 and 100,please.  {0} must not be empty ```  I want to set the value in the part of {0}. Do you need to do something?","closed","in: core,","suzukitadashi","2019-05-22T03:25:02Z","2019-05-24T21:47:59Z"
"","23500","IncompatibleClassChangeError on Jetty WebSocket ExtensionFactory","![image](https://user-images.githubusercontent.com/17846308/63427719-64d6d100-c448-11e9-84df-b119494b318b.png)  error log: ``` org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.springframework.web.socket.server.HandshakeFailureException: Uncaught failure for request http://192.168.76.142:9095/login?pushToken=eyJhbGciOiJIUzI1NiJ9.eyJwdXNoX2RldmljZUlkIjoiNjY2ODc5MzExNTc2ODEzNTY4IiwiYWxpYXMiOiJ1NDAxMDkiLCJjcmVhdGlvbl9kYXRlIjoxNTY2NDUyOTA2Nzg3LCJjbGllbnRfdHlwZSI6InVzZXIiLCJkZWFkbGluZSI6MTU5Nzk4ODkwNjc5MSwiZXhwIjoxNTk3OTg4OTA2LCJub25jZSI6IkdBYjhVb1BXMTJZQTY2Njg3OTMxMTU5Nzc4NTA4OCIsImRldmljZUlkIjoiZmZmZmZmZmYtYzk1Yi1iYzJkLTAwMDAtMDAwMDVhMmZiMjJjLWNvbV9qaWFtaV9nemIifQ.w_vbUFvxbIUzhgTaVXV8L1ICsoLyBc0-yDbY2Txqqgw&deviceToken=97aec1bf-4f1c-4834-afd4-a2b79d7eb50d; nested exception is java.lang.IncompatibleClassChangeError: Found interface org.eclipse.jetty.websocket.api.extensions.ExtensionFactory, but class was expected 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1013) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:687) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) 	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:852) 	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1604) 	at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:243) 	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1591) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118) 	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1591) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118) 	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1591) 	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118) 	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1591) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118) 	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1591) 	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:542) 	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143) 	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:536) 	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127) 	at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:235) 	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1581) 	at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233) 	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1307) 	at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188) 	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:482) 	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1549) 	at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186) 	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1204) 	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141) 	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127) 	at org.eclipse.jetty.server.Server.handle(Server.java:494) 	at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:374) 	at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:268) 	at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311) 	at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103) 	at org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117) 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336) 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313) 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171) 	at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129) 	at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:367) 	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:782) 	at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:918) 	at java.lang.Thread.run(Thread.java:745) Caused by: org.springframework.web.socket.server.HandshakeFailureException: Uncaught failure for request http://192.168.76.142:9095/login?pushToken=eyJhbGciOiJIUzI1NiJ9.eyJwdXNoX2RldmljZUlkIjoiNjY2ODc5MzExNTc2ODEzNTY4IiwiYWxpYXMiOiJ1NDAxMDkiLCJjcmVhdGlvbl9kYXRlIjoxNTY2NDUyOTA2Nzg3LCJjbGllbnRfdHlwZSI6InVzZXIiLCJkZWFkbGluZSI6MTU5Nzk4ODkwNjc5MSwiZXhwIjoxNTk3OTg4OTA2LCJub25jZSI6IkdBYjhVb1BXMTJZQTY2Njg3OTMxMTU5Nzc4NTA4OCIsImRldmljZUlkIjoiZmZmZmZmZmYtYzk1Yi1iYzJkLTAwMDAtMDAwMDVhMmZiMjJjLWNvbV9qaWFtaV9nemIifQ.w_vbUFvxbIUzhgTaVXV8L1ICsoLyBc0-yDbY2Txqqgw&deviceToken=97aec1bf-4f1c-4834-afd4-a2b79d7eb50d; nested exception is java.lang.IncompatibleClassChangeError: Found interface org.eclipse.jetty.websocket.api.extensions.ExtensionFactory, but class was expected 	at org.springframework.web.socket.server.support.WebSocketHttpRequestHandler.handleRequest(WebSocketHttpRequestHandler.java:174) 	at org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter.handle(HttpRequestHandlerAdapter.java:53) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) 	... 49 common frames omitted Caused by: java.lang.IncompatibleClassChangeError: Found interface org.eclipse.jetty.websocket.api.extensions.ExtensionFactory, but class was expected 	at org.springframework.web.socket.server.jetty.JettyRequestUpgradeStrategy.buildWebSocketExtensions(JettyRequestUpgradeStrategy.java:170) 	at org.springframework.web.socket.server.jetty.JettyRequestUpgradeStrategy.getSupportedExtensions(JettyRequestUpgradeStrategy.java:164) 	at org.springframework.web.socket.server.support.AbstractHandshakeHandler.doHandshake(AbstractHandshakeHandler.java:283) 	at org.springframework.web.socket.server.support.WebSocketHttpRequestHandler.handleRequest(WebSocketHttpRequestHandler.java:167) 	... 53 common frames omitted ```","closed","type: enhancement,","zhouxiaohai","2019-08-22T06:05:51Z","2019-09-02T14:45:10Z"
"","23796","Added method to convert string from snake_case to camelCase","","closed","status: declined,","sachinp054","2019-10-15T13:39:04Z","2019-10-15T13:44:00Z"
"","23788","Fix typo","","closed","type: task,","bangseongbeom","2019-10-13T07:33:15Z","2019-11-01T12:30:40Z"
"","23746","Fixes broken links to dev.java.net","","closed","type: documentation,","LinkedList","2019-10-02T05:17:36Z","2019-10-02T10:48:43Z"
"","23728","Updates rsocket to 1.0.0-RC5","","closed","status: duplicate,","spencergibb","2019-09-30T01:37:35Z","2019-09-30T14:21:06Z"
"","23705","Add MetadataExtractorRegistry.metadataToExtract Kotlin extensions","","closed","in: messaging,","sdeleuze","2019-09-25T14:58:55Z","2019-09-25T15:05:35Z"
"","23695","Upgrade to Reactor Dysprosium-RELEASE","","closed","type: dependency-upgrade,","snicoll","2019-09-25T06:48:09Z","2019-09-25T06:50:53Z"
"","23694","Upgrade to Reactor Californium-SR12","","closed","type: dependency-upgrade,","snicoll","2019-09-25T06:45:57Z","2019-09-25T06:50:53Z"
"","23690","Obfuscate IP addresses in build scans","","closed","type: task,","wilkinsona","2019-09-24T15:42:10Z","2019-09-24T16:18:53Z"
"","23619","Upgrade to com.gradle.build-scan 2.4.2","","closed","type: task,","wilkinsona","2019-09-11T08:55:04Z","2019-09-11T13:36:45Z"
"","23609","Could not find key 'spring.liveBeansView.mbeanDomain' in any property source","","closed","for: stackoverflow,","Purva-Kaul","2019-09-08T17:03:11Z","2019-09-10T15:36:58Z"
"","23579","Upgrade to Reactor Dysprosium-RC1","","closed","type: dependency-upgrade,","snicoll","2019-09-04T06:10:37Z","2019-09-04T07:57:24Z"
"","23566","Treat Kotlin warnings as errors","","closed","type: task,","sdeleuze","2019-09-02T14:47:58Z","2019-09-02T14:58:54Z"
"","23555","Fix typos related to indefinite articles","","closed","type: documentation,","KangZhiDong","2019-08-31T19:39:48Z","2019-09-01T13:46:01Z"
"","23543","Upgrade to RSocket 1.0 RC3","","closed","type: dependency-upgrade,","rstoyanchev","2019-08-29T12:23:17Z","2019-09-02T08:46:46Z"
"","23540","Update the AspectJ Gradle Plugin to 4.0.1","","closed","status: duplicate,","larsgrefer","2019-08-28T21:00:18Z","2019-09-10T07:37:40Z"
"","23536","Upgrade to Kotlin 1.3.50","","closed","type: dependency-upgrade,","sdeleuze","2019-08-28T11:33:11Z","2019-08-28T11:49:36Z"
"","23535","Upgrade to Kotlin Coroutines 1.3.0","","closed","type: dependency-upgrade,","sdeleuze","2019-08-28T11:30:02Z","2019-08-28T11:48:18Z"
"","23487","Fix unmatched parenthesis in the documentation of ContextHierarchy","","closed","type: documentation,","johnlinp","2019-08-20T02:49:47Z","2019-08-30T06:15:06Z"
"","23482","Replace context object with ""it"" argument in also function","","closed","type: task,","wonwoo","2019-08-18T13:29:01Z","2019-12-13T17:04:34Z"
"","23480","Fix typo","","closed","type: task,","boojongmin","2019-08-18T04:21:01Z","2019-08-18T06:14:49Z"
"","23470","Simplify String concatenation","","closed","type: task,","stsypanov","2019-08-16T10:38:29Z","2019-08-28T12:45:20Z"
"","23454","Improve language-switch CSS","","closed","in: core,","larsgrefer","2019-08-12T23:07:43Z","2019-08-13T07:49:19Z"
"","23446","Unnecessary 'null' check before 'instanceof' expression","","closed","","NB216ers","2019-08-10T18:44:47Z","2022-02-18T19:07:09Z"
"","23393","Use Arrays.copyOf and Arrays.copyOfRange where possible","","closed","status: feedback-provided,","stsypanov","2019-07-31T16:20:33Z","2019-08-28T12:46:17Z"
"","23329","Fix typo in webflux.adoc","","closed","type: documentation,","ryanb93","2019-07-22T15:23:04Z","2019-07-22T16:38:49Z"
"","23323","Inconsistent use of getInterfaceMethodIfPossible for init method invocation","","closed","in: core,","AlexRenCN","2019-07-20T09:09:17Z","2019-07-23T07:04:27Z"
"","23279","Update ISSUE_TEMPLATE.md","","closed","status: invalid,","stomeshwars","2019-07-11T15:15:42Z","2019-07-11T16:19:23Z"
"","23274","Fix typo in UrlPathHelper","","closed","type: task,","akun2014","2019-07-11T07:29:30Z","2019-07-11T07:57:07Z"
"","23247","Fix typo in data-access.adoc","","closed","type: documentation,","lonre","2019-07-07T16:51:44Z","2019-07-08T04:32:57Z"
"","23244","5.0.x","","closed","status: invalid,","xiezhangbing","2019-07-07T06:53:29Z","2019-07-07T10:25:40Z"
"","23237","Use StringJoiner where possible to simplify String joining","","closed","in: core,","stsypanov","2019-07-04T13:19:49Z","2019-07-08T14:28:14Z"
"","23171","Virtil","","closed","","VirtiL","2019-06-21T09:27:29Z","2019-06-21T09:27:38Z"
"","23169","Added application/graphql media type","","closed","type: enhancement,","marceloverdijk","2019-06-20T18:06:31Z","2020-10-15T07:12:03Z"
"","23147","RSocket documentation","","closed","in: web,","rstoyanchev","2019-06-17T14:28:59Z","2019-09-23T11:18:45Z"
"","23146","Polishing 'Enhancer'","","closed","status: declined,","ijliym","2019-06-17T14:13:21Z","2019-06-18T01:04:09Z"
"","23143","Update build.gradle","","closed","status: invalid,","kiboroy","2019-06-17T10:15:00Z","2019-11-08T13:03:13Z"
"","23077","Handle escape character in ContentDisposition","","closed","type: task,","rstoyanchev","2019-06-03T19:37:06Z","2019-06-03T20:36:58Z"
"","23071","Replace expression with 'Integer.compare()'","","closed","","ielatif","2019-06-02T21:51:30Z","2022-02-18T19:10:13Z"
"","23067","Merge remote-tracking branch 'spring-projects/master'","","closed","status: invalid,","DeanSun","2019-05-31T01:48:51Z","2019-06-03T01:31:01Z"
"","23053","Simplify iteration over a map","","closed","in: core,","stsypanov","2019-05-29T15:07:27Z","2019-05-30T07:34:21Z"
"","23050","5.1.7.RELEASE snapshot for learn","","closed","status: invalid,","houqian","2019-05-29T05:37:44Z","2019-06-11T02:04:39Z"
"","23041","Fix (doc): broken link to transaction-declarative","","closed","","ArtsiomCh","2019-05-27T22:50:12Z","2019-05-28T06:04:09Z"
"","23036","Allocate objects only when it's necessary","","closed","type: task,","stsypanov","2019-05-27T06:43:59Z","2019-06-06T19:02:47Z"
"","22984","A couple of trivial simplifications","","closed","in: core,","stsypanov","2019-05-16T19:57:09Z","2019-05-21T08:44:00Z"
"","22922","Migrate away from ExpectedException","","closed","type: task,","philwebb","2019-05-08T08:15:28Z","2019-05-08T14:26:28Z"
"","22898","Fix direct modification to manualSingletonNames","","closed","","lmagyar89","2019-05-06T08:55:45Z","2022-02-18T19:10:09Z"
"","22897","init","","closed","status: invalid,","lifeisadrug","2019-05-06T08:42:34Z","2019-05-06T09:10:29Z"
"","22840","Merge remote-tracking branch 'refs/remotes/spring-projects/master'","","closed","status: invalid,","admin-haha","2019-04-26T02:19:45Z","2019-04-26T06:03:44Z"
"","22839","Add Nohttp Checks","","closed","type: task,","rwinch","2019-04-25T16:11:20Z","2019-07-12T12:41:22Z"
"","22837","Inconsistent use of firstIndex 0 in PatternMatchUtils","","closed","in: core,","orangesir","2019-04-25T09:34:03Z","2019-05-04T10:14:20Z"
"","22835","Update settings.gradle","","closed","status: invalid,","yanxingzhi","2019-04-25T02:51:11Z","2019-04-25T06:36:40Z"
"","22823","5.0.x","","closed","","liuquanwang","2019-04-21T10:48:19Z","2019-04-21T12:38:17Z"
"","22816","Temporal should be simple value type like Date","","closed","status: feedback-provided,","quaff","2019-04-18T02:20:58Z","2019-04-23T10:55:19Z"